{"problem_ids": 308, "project": "test-apps/python-semantic-release", "focal_function": "def current_commit_parser() -> Callable:\n    \"\"\"Get the currently-configured commit parser\n\n    :raises ImproperConfigurationError: if ImportError or AttributeError is raised\n    :returns: Commit parser\n    \"\"\"\n\n    try:\n        # All except the last part is the import path\n        parts = config.get(\"commit_parser\").split(\".\")\n        module = \".\".join(parts[:-1])\n        # The final part is the name of the parse function\n        return getattr(importlib.import_module(module), parts[-1])\n    except (ImportError, AttributeError) as error:\n        raise ImproperConfigurationError(f'Unable to import parser \"{error}\"')", "module": "semantic_release.settings", "code": "import configparser\nimport importlib\nimport logging\nimport os\nfrom collections import UserDict\nfrom functools import wraps\nfrom os import getcwd\nfrom typing import Callable, List\nimport tomlkit\nfrom tomlkit.exceptions import TOMLKitError\nfrom .errors import ImproperConfigurationError\n\nclass ImproperConfigurationError(SemanticReleaseBaseError):\n\nconfig = _config()\n\ndef current_commit_parser() -> Callable:\n    \"\"\"Get the currently-configured commit parser\n\n    :raises ImproperConfigurationError: if ImportError or AttributeError is raised\n    :returns: Commit parser\n    \"\"\"\n\n    try:\n        # All except the last part is the import path\n        parts = config.get(\"commit_parser\").split(\".\")\n        module = \".\".join(parts[:-1])\n        # The final part is the name of the parse function\n        return getattr(importlib.import_module(module), parts[-1])\n    except (ImportError, AttributeError) as error:\n        raise ImproperConfigurationError(f'Unable to import parser \"{error}\"')", "entry_point": "current_commit_parser", "test": null, "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert current_commit_parser().__name__ == 'commit_analyzer'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert current_commit_parser() == parse_commit_message", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert current_commit_parser() == current_commit_parser()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert current_commit_parser() == commit_parse", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert current_commit_parser() == \"github.GithubCommit\"", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert current_commit_parser() == parse_subject", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    assert current_commit_parser == parse_commit_message", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    assert current_commit_parser() == parse_commit_message.parser", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert current_commit_parser() ==  current_commit_parser()"]}
{"problem_ids": 309, "project": "test-apps/python-semantic-release", "focal_function": "def current_changelog_components() -> List[Callable]:\n    \"\"\"Get the currently-configured changelog components\n\n    :raises ImproperConfigurationError: if ImportError or AttributeError is raised\n    :returns: List of component functions\n    \"\"\"\n    component_paths = config.get(\"changelog_components\").split(\",\")\n    components = list()\n\n    for path in component_paths:\n        try:\n            # All except the last part is the import path\n            parts = path.split(\".\")\n            module = \".\".join(parts[:-1])\n            # The final part is the name of the component function\n            components.append(getattr(importlib.import_module(module), parts[-1]))\n        except (ImportError, AttributeError) as error:\n            raise ImproperConfigurationError(\n                f'Unable to import changelog component \"{path}\"'\n            )\n\n    return components", "module": "semantic_release.settings", "code": "import configparser\nimport importlib\nimport logging\nimport os\nfrom collections import UserDict\nfrom functools import wraps\nfrom os import getcwd\nfrom typing import Callable, List\nimport tomlkit\nfrom tomlkit.exceptions import TOMLKitError\nfrom .errors import ImproperConfigurationError\n\nclass ImproperConfigurationError(SemanticReleaseBaseError):\n\nconfig = _config()\n\ndef current_changelog_components() -> List[Callable]:\n    \"\"\"Get the currently-configured changelog components\n\n    :raises ImproperConfigurationError: if ImportError or AttributeError is raised\n    :returns: List of component functions\n    \"\"\"\n    component_paths = config.get(\"changelog_components\").split(\",\")\n    components = list()\n\n    for path in component_paths:\n        try:\n            # All except the last part is the import path\n            parts = path.split(\".\")\n            module = \".\".join(parts[:-1])\n            # The final part is the name of the component function\n            components.append(getattr(importlib.import_module(module), parts[-1]))\n        except (ImportError, AttributeError) as error:\n            raise ImproperConfigurationError(\n                f'Unable to import changelog component \"{path}\"'\n            )\n\n    return components", "entry_point": "current_changelog_components", "test": null, "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert len(current_changelog_components()) > 0", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert current_changelog_components()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert 4 == len(current_changelog_components())", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert 3 == len(current_changelog_components())", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert current_changelog_components() == [f, g]", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert 0 == len(current_changelog_components())", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    assert \"get_changelog_component\" in str(current_changelog_components()[0])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    assert current_changelog_components() == ['b', 'c']", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert all(\n        (\n            callable(component)\n            for component in current_changelog_components()\n        )\n    )", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_9():\n    assert callable(current_changelog_components()[0])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_10():\n    assert current_changelog_components() == []", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_11():\n    assert 2 == len([c for c in current_changelog_components() if c.__name__ == \"version_changelog\"])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_12():\n    assert 1 == len(current_changelog_components())", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_13():\n    assert current_changelog_components()[0](\n            \"UNRELEASED\", {\"UNRELEASED\": [], \"0.0.1\": []}\n        ) == \"<!-- Insert here the changes for 0.0.1 -->\\n\\n## 0.0.1\\n\\n\"", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_14():\n    assert current_changelog_components() == [h, i]"]}
{"problem_ids": 310, "project": "test-apps/python-semantic-release", "focal_function": "def overload_configuration(func):\n    \"\"\"This decorator gets the content of the \"define\" array and edits \"config\"\n    according to the pairs of key/value.\n    \"\"\"\n\n    @wraps(func)\n    def wrap(*args, **kwargs):\n        if \"define\" in kwargs:\n            for defined_param in kwargs[\"define\"]:\n                pair = defined_param.split(\"=\", maxsplit=1)\n                if len(pair) == 2:\n                    config[str(pair[0])] = pair[1]\n        return func(*args, **kwargs)\n\n    return wrap", "module": "semantic_release.settings", "code": "import configparser\nimport importlib\nimport logging\nimport os\nfrom collections import UserDict\nfrom functools import wraps\nfrom os import getcwd\nfrom typing import Callable, List\nimport tomlkit\nfrom tomlkit.exceptions import TOMLKitError\nfrom .errors import ImproperConfigurationError\n\nconfig = _config()\n\ndef overload_configuration(func):\n    \"\"\"This decorator gets the content of the \"define\" array and edits \"config\"\n    according to the pairs of key/value.\n    \"\"\"\n\n    @wraps(func)\n    def wrap(*args, **kwargs):\n        if \"define\" in kwargs:\n            for defined_param in kwargs[\"define\"]:\n                pair = defined_param.split(\"=\", maxsplit=1)\n                if len(pair) == 2:\n                    config[str(pair[0])] = pair[1]\n        return func(*args, **kwargs)\n\n    return wrap", "entry_point": "overload_configuration", "test": null, "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert 3 == overload_configuration(lambda x: x)(define=[\"a=3\"])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert overload_configuration(lambda a, **kwargs: print(config[\"GIT_BRANCH_NAME\"]))(define=[\"GIT_BRANCH_NAME=branch_name\"])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert overload_configuration('ok') == 'ok'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert 13 == overload_configuration(lambda x, **kwargs: x)(13)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert 3 == overload_configuration(lambda x: x)(define=[\"x=2\", \"a=3\"])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert 6 == overload_configuration(lambda x=5: x)(define=[\"y=6\"])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    assert 12 == overload_configuration(lambda x, **kwargs: x)(\n        12, define=[\"a=12\"]\n    )", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    assert 5 == overload_configuration(lambda x=5: x)()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert overload_configuration(lambda **kwargs: print(kwargs[\"define\"]))(define=[\"foo=bar\",\"hello=world\"]) == {'define': ['foo=bar', 'hello=world']}", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_9():\n    assert 2 == overload_configuration(lambda x: x)(define=[\"a=3\", \"x=2\"])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_10():\n    assert 42 == overload_configuration(lambda define=None: 42)(define=[\"NUMBER=42\"])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_11():\n    assert 6 == overload_configuration(lambda x=5: x)(define=[\"x=6\"])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_12():\n    assert 3 == overload_configuration(lambda x: x)(define=[\"a=3\", \"x=2\"], x=3)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_13():\n    assert 3 == overload_configuration(lambda x: x)(x=3, define=[\"a=3\", \"x=2\"])"]}
