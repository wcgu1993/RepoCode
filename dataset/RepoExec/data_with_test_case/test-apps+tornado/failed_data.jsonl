{"problem_ids": 548, "project": "test-apps/tornado", "focal_function": "def sleep(duration: float) -> \"Future[None]\":\n    \"\"\"Return a `.Future` that resolves after the given number of seconds.\n\n    When used with ``yield`` in a coroutine, this is a non-blocking\n    analogue to `time.sleep` (which should not be used in coroutines\n    because it is blocking)::\n\n        yield gen.sleep(0.5)\n\n    Note that calling this function on its own does nothing; you must\n    wait on the `.Future` it returns (usually by yielding it).\n\n    .. versionadded:: 4.1\n    \"\"\"\n    f = _create_future()\n    IOLoop.current().call_later(\n        duration, lambda: future_set_result_unless_cancelled(f, None)\n    )\n    return f", "module": "tornado.gen", "code": "from tornado.platform.asyncio import BaseAsyncIOLoop\nfrom tornado.platform.asyncio import AsyncIOMainLoop\nfrom tornado.platform.asyncio import AsyncIOLoop\nfrom tornado.gen import convert_yielded\nfrom tornado.process import cpu_count\nfrom tornado import gen\nimport asyncio\nimport builtins\nimport collections\nfrom collections.abc import Generator\nimport concurrent.futures\nimport datetime\nimport functools\nfrom functools import singledispatch\nfrom inspect import isawaitable\nimport sys\nimport types\nfrom tornado.concurrent import (\n    Future,\n    is_future,\n    chain_future,\n    future_set_exc_info,\n    future_add_done_callback,\n    future_set_result_unless_cancelled,\n)\nfrom tornado.ioloop import IOLoop\nfrom tornado.log import app_log\nfrom tornado.util import TimeoutError\nimport typing\nfrom typing import Union, Any, Callable, List, Type, Tuple, Awaitable, Dict, overload\n\ndef future_set_result_unless_cancelled(\n    future: \"Union[futures.Future[_T], Future[_T]]\", value: _T\n) -> None:\n    \"\"\"Set the given ``value`` as the `Future`'s result, if not cancelled.\n\n    Avoids ``asyncio.InvalidStateError`` when calling ``set_result()`` on\n    a cancelled `asyncio.Future`.\n\n    .. versionadded:: 5.0\n    \"\"\"\n\nclass IOLoop(Configurable):\n    \"\"\"An I/O event loop.\n\n    As of Tornado 6.0, `IOLoop` is a wrapper around the `asyncio` event\n    loop.\n\n    Example usage for a simple TCP server:\n\n    .. testcode::\n\n    import errno\n\n    import socket\n\n    import tornado.ioloop\n    from tornado.iostream import IOStream\n\n    async def handle_connection(connection, address):\n    stream = IOStream(connection)\n    message = await stream.read_until_close()\n    print(\"message from client:\", message.decode().strip())\n\n    def connection_ready(sock, fd, events):\n    while True:\n    try:\n    connection, address = sock.accept()\n    except BlockingIOError:\n    return\n    connection.setblocking(0)\n    io_loop = tornado.ioloop.IOLoop.current()\n    io_loop.spawn_callback(handle_connection, connection, address)\n\n    if __name__ == '__main__':\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.setblocking(0)\n    sock.bind((\"\", 8888))\n    sock.listen(128)\n\n    io_loop = tornado.ioloop.IOLoop.current()\n    callback = functools.partial(connection_ready, sock)\n    io_loop.add_handler(sock.fileno(), callback, io_loop.READ)\n    io_loop.start()\n\n    .. testoutput::\n    :hide:\n\n    By default, a newly-constructed `IOLoop` becomes the thread's current\n    `IOLoop`, unless there already is a current `IOLoop`. This behavior\n    can be controlled with the ``make_current`` argument to the `IOLoop`\n    constructor: if ``make_current=True``, the new `IOLoop` will always\n    try to become current and it raises an error if there is already a\n    current instance. If ``make_current=False``, the new `IOLoop` will\n    not try to become current.\n\n    In general, an `IOLoop` cannot survive a fork or be shared across\n    processes in any way. When multiple processes are being used, each\n    process should create its own `IOLoop`, which also implies that\n    any objects which depend on the `IOLoop` (such as\n    `.AsyncHTTPClient`) must also be created in the child processes.\n    As a guideline, anything that starts processes (including the\n    `tornado.process` and `multiprocessing` modules) should do so as\n    early as possible, ideally the first thing the application does\n    after loading its configuration in ``main()``.\n\n    .. versionchanged:: 4.2\n    Added the ``make_current`` keyword argument to the `IOLoop`\n    constructor.\n\n    .. versionchanged:: 5.0\n\n    Uses the `asyncio` event loop by default. The\n    ``IOLoop.configure`` method cannot be used on Python 3 except\n    to redundantly specify the `asyncio` event loop.\n\n    \"\"\"\n\n    def configure(\n            cls, impl: \"Union[None, str, Type[Configurable]]\", **kwargs: Any\n        ) -> None:\n\n    def instance() -> \"IOLoop\":\n        \"\"\"Deprecated alias for `IOLoop.current()`.\n\n        .. versionchanged:: 5.0\n\n        Previously, this method returned a global singleton\n        `IOLoop`, in contrast with the per-thread `IOLoop` returned\n        by `current()`. In nearly all cases the two were the same\n        (when they differed, it was generally used from non-Tornado\n        threads to communicate back to the main thread's `IOLoop`).\n        This distinction is not present in `asyncio`, so in order\n        to facilitate integration with that package `instance()`\n        was changed to be an alias to `current()`. Applications\n        using the cross-thread communications aspect of\n        `instance()` should instead set their own global variable\n        to point to the `IOLoop` they want to use.\n\n        .. deprecated:: 5.0\n        \"\"\"\n\n    def install(self) -> None:\n        \"\"\"Deprecated alias for `make_current()`.\n\n        .. versionchanged:: 5.0\n\n        Previously, this method would set this `IOLoop` as the\n        global singleton used by `IOLoop.instance()`. Now that\n        `instance()` is an alias for `current()`, `install()`\n        is an alias for `make_current()`.\n\n        .. deprecated:: 5.0\n        \"\"\"\n\n    def clear_instance() -> None:\n        \"\"\"Deprecated alias for `clear_current()`.\n\n        .. versionchanged:: 5.0\n\n        Previously, this method would clear the `IOLoop` used as\n        the global singleton by `IOLoop.instance()`. Now that\n        `instance()` is an alias for `current()`,\n        `clear_instance()` is an alias for `clear_current()`.\n\n        .. deprecated:: 5.0\n\n        \"\"\"\n\n    def current() -> \"IOLoop\":\n\n    def current(instance: bool = True) -> Optional[\"IOLoop\"]:\n\n    def current(instance: bool = True) -> Optional[\"IOLoop\"]:\n        \"\"\"Returns the current thread's `IOLoop`.\n\n        If an `IOLoop` is currently running or has been marked as\n        current by `make_current`, returns that instance.  If there is\n        no current `IOLoop` and ``instance`` is true, creates one.\n\n        .. versionchanged:: 4.1\n        Added ``instance`` argument to control the fallback to\n        `IOLoop.instance()`.\n        .. versionchanged:: 5.0\n        On Python 3, control of the current `IOLoop` is delegated\n        to `asyncio`, with this and other methods as pass-through accessors.\n        The ``instance`` argument now controls whether an `IOLoop`\n        is created automatically when there is none, instead of\n        whether we fall back to `IOLoop.instance()` (which is now\n        an alias for this method). ``instance=False`` is deprecated,\n        since even if we do not create an `IOLoop`, this method\n        may initialize the asyncio loop.\n        \"\"\"\n\n    def make_current(self) -> None:\n        \"\"\"Makes this the `IOLoop` for the current thread.\n\n        An `IOLoop` automatically becomes current for its thread\n        when it is started, but it is sometimes useful to call\n        `make_current` explicitly before starting the `IOLoop`,\n        so that code run at startup time can find the right\n        instance.\n\n        .. versionchanged:: 4.1\n        An `IOLoop` created while there is no current `IOLoop`\n        will automatically become current.\n\n        .. versionchanged:: 5.0\n        This method also sets the current `asyncio` event loop.\n        \"\"\"\n\n    def clear_current() -> None:\n        \"\"\"Clears the `IOLoop` for the current thread.\n\n        Intended primarily for use by test frameworks in between tests.\n\n        .. versionchanged:: 5.0\n        This method also clears the current `asyncio` event loop.\n        \"\"\"\n\n    def _clear_current_hook(self) -> None:\n        \"\"\"Instance method called when an IOLoop ceases to be current.\n\n        May be overridden by subclasses as a counterpart to make_current.\n        \"\"\"\n\n    def configurable_base(cls) -> Type[Configurable]:\n\n    def configurable_default(cls) -> Type[Configurable]:\n\n    def initialize(self, make_current: Optional[bool] = None) -> None:\n\n    def close(self, all_fds: bool = False) -> None:\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs for the\n        entire lifetime of the process.  In that case closing the `IOLoop`\n        is not necessary since everything will be cleaned up when the\n        process exits.  `IOLoop.close` is provided mainly for scenarios\n        such as unit tests, which create and destroy a large number of\n        ``IOLoops``.\n\n        An `IOLoop` must be completely stopped before it can be closed.  This\n        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must\n        be allowed to return before attempting to call `IOLoop.close()`.\n        Therefore the call to `close` will usually appear just after\n        the call to `start` rather than near the call to `stop`.\n\n        .. versionchanged:: 3.1\n        If the `IOLoop` implementation supports non-integer objects\n        for \"file descriptors\", those objects will have their\n        ``close`` method when ``all_fds`` is true.\n        \"\"\"\n\n    def add_handler(\n            self, fd: int, handler: Callable[[int, int], None], events: int\n        ) -> None:\n\n    def add_handler(\n            self, fd: _S, handler: Callable[[_S, int], None], events: int\n        ) -> None:\n\n    def add_handler(  # noqa: F811\n            self, fd: Union[int, _Selectable], handler: Callable[..., None], events: int\n        ) -> None:\n        \"\"\"Registers the given handler to receive the given events for ``fd``.\n\n        The ``fd`` argument may either be an integer file descriptor or\n        a file-like object with a ``fileno()`` and ``close()`` method.\n\n        The ``events`` argument is a bitwise or of the constants\n        ``IOLoop.READ``, ``IOLoop.WRITE``, and ``IOLoop.ERROR``.\n\n        When an event occurs, ``handler(fd, events)`` will be run.\n\n        .. versionchanged:: 4.0\n        Added the ability to pass file-like objects in addition to\n        raw file descriptors.\n        \"\"\"\n\n    def update_handler(self, fd: Union[int, _Selectable], events: int) -> None:\n        \"\"\"Changes the events we listen for ``fd``.\n\n        .. versionchanged:: 4.0\n        Added the ability to pass file-like objects in addition to\n        raw file descriptors.\n        \"\"\"\n\n    def remove_handler(self, fd: Union[int, _Selectable]) -> None:\n        \"\"\"Stop listening for events on ``fd``.\n\n        .. versionchanged:: 4.0\n        Added the ability to pass file-like objects in addition to\n        raw file descriptors.\n        \"\"\"\n\n    def start(self) -> None:\n        \"\"\"Starts the I/O loop.\n\n        The loop will run until one of the callbacks calls `stop()`, which\n        will make the loop stop after the current event iteration completes.\n        \"\"\"\n\n    def _setup_logging(self) -> None:\n        \"\"\"The IOLoop catches and logs exceptions, so it's\n        important that log output be visible.  However, python's\n        default behavior for non-root loggers (prior to python\n        3.2) is to print an unhelpful \"no handlers could be\n        found\" message rather than the actual log entry, so we\n        must explicitly configure logging if we've made it this\n        far without anything.\n\n        This method should be called from start() in subclasses.\n        \"\"\"\n\n    def stop(self) -> None:\n        \"\"\"Stop the I/O loop.\n\n        If the event loop is not currently running, the next call to `start()`\n        will return immediately.\n\n        Note that even after `stop` has been called, the `IOLoop` is not\n        completely stopped until `IOLoop.start` has also returned.\n        Some work that was scheduled before the call to `stop` may still\n        be run before the `IOLoop` shuts down.\n        \"\"\"\n\n    def run_sync(self, func: Callable, timeout: Optional[float] = None) -> Any:\n        \"\"\"Starts the `IOLoop`, runs the given function, and stops the loop.\n\n        The function must return either an awaitable object or\n        ``None``. If the function returns an awaitable object, the\n        `IOLoop` will run until the awaitable is resolved (and\n        `run_sync()` will return the awaitable's result). If it raises\n        an exception, the `IOLoop` will stop and the exception will be\n        re-raised to the caller.\n\n        The keyword-only argument ``timeout`` may be used to set\n        a maximum duration for the function.  If the timeout expires,\n        a `tornado.util.TimeoutError` is raised.\n\n        This method is useful to allow asynchronous calls in a\n        ``main()`` function::\n\n        async def main():\n        # do stuff...\n\n        if __name__ == '__main__':\n        IOLoop.current().run_sync(main)\n\n        .. versionchanged:: 4.3\n        Returning a non-``None``, non-awaitable value is now an error.\n\n        .. versionchanged:: 5.0\n        If a timeout occurs, the ``func`` coroutine will be cancelled.\n\n        \"\"\"\n\n    def run() -> None:\n\n    def timeout_callback() -> None:\n\n    def time(self) -> float:\n        \"\"\"Returns the current time according to the `IOLoop`'s clock.\n\n        The return value is a floating-point number relative to an\n        unspecified time in the past.\n\n        Historically, the IOLoop could be customized to use e.g.\n        `time.monotonic` instead of `time.time`, but this is not\n        currently supported and so this method is equivalent to\n        `time.time`.\n\n        \"\"\"\n\n    def add_timeout(\n            self,\n            deadline: Union[float, datetime.timedelta],\n            callback: Callable[..., None],\n            *args: Any,\n            **kwargs: Any\n        ) -> object:\n        \"\"\"Runs the ``callback`` at the time ``deadline`` from the I/O loop.\n\n        Returns an opaque handle that may be passed to\n        `remove_timeout` to cancel.\n\n        ``deadline`` may be a number denoting a time (on the same\n        scale as `IOLoop.time`, normally `time.time`), or a\n        `datetime.timedelta` object for a deadline relative to the\n        current time.  Since Tornado 4.0, `call_later` is a more\n        convenient alternative for the relative case since it does not\n        require a timedelta object.\n\n        Note that it is not safe to call `add_timeout` from other threads.\n        Instead, you must use `add_callback` to transfer control to the\n        `IOLoop`'s thread, and then call `add_timeout` from there.\n\n        Subclasses of IOLoop must implement either `add_timeout` or\n        `call_at`; the default implementations of each will call\n        the other.  `call_at` is usually easier to implement, but\n        subclasses that wish to maintain compatibility with Tornado\n        versions prior to 4.0 must use `add_timeout` instead.\n\n        .. versionchanged:: 4.0\n        Now passes through ``*args`` and ``**kwargs`` to the callback.\n        \"\"\"\n\n    def call_later(\n            self, delay: float, callback: Callable[..., None], *args: Any, **kwargs: Any\n        ) -> object:\n        \"\"\"Runs the ``callback`` after ``delay`` seconds have passed.\n\n        Returns an opaque handle that may be passed to `remove_timeout`\n        to cancel.  Note that unlike the `asyncio` method of the same\n        name, the returned object does not have a ``cancel()`` method.\n\n        See `add_timeout` for comments on thread-safety and subclassing.\n\n        .. versionadded:: 4.0\n        \"\"\"\n\n    def call_at(\n            self, when: float, callback: Callable[..., None], *args: Any, **kwargs: Any\n        ) -> object:\n        \"\"\"Runs the ``callback`` at the absolute time designated by ``when``.\n\n        ``when`` must be a number using the same reference point as\n        `IOLoop.time`.\n\n        Returns an opaque handle that may be passed to `remove_timeout`\n        to cancel.  Note that unlike the `asyncio` method of the same\n        name, the returned object does not have a ``cancel()`` method.\n\n        See `add_timeout` for comments on thread-safety and subclassing.\n\n        .. versionadded:: 4.0\n        \"\"\"\n\n    def remove_timeout(self, timeout: object) -> None:\n        \"\"\"Cancels a pending timeout.\n\n        The argument is a handle as returned by `add_timeout`.  It is\n        safe to call `remove_timeout` even if the callback has already\n        been run.\n        \"\"\"\n\n    def add_callback(self, callback: Callable, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        It is safe to call this method from any thread at any time,\n        except from a signal handler.  Note that this is the **only**\n        method in `IOLoop` that makes this thread-safety guarantee; all\n        other interaction with the `IOLoop` must be done from that\n        `IOLoop`'s thread.  `add_callback()` may be used to transfer\n        control from other threads to the `IOLoop`'s thread.\n\n        To add a callback from a signal handler, see\n        `add_callback_from_signal`.\n        \"\"\"\n\n    def add_callback_from_signal(\n            self, callback: Callable, *args: Any, **kwargs: Any\n        ) -> None:\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        Safe for use from a Python signal handler; should not be used\n        otherwise.\n        \"\"\"\n\n    def spawn_callback(self, callback: Callable, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Calls the given callback on the next IOLoop iteration.\n\n        As of Tornado 6.0, this method is equivalent to `add_callback`.\n\n        .. versionadded:: 4.0\n        \"\"\"\n\n    def add_future(\n            self,\n            future: \"Union[Future[_T], concurrent.futures.Future[_T]]\",\n            callback: Callable[[\"Future[_T]\"], None],\n        ) -> None:\n        \"\"\"Schedules a callback on the ``IOLoop`` when the given\n        `.Future` is finished.\n\n        The callback is invoked with one argument, the\n        `.Future`.\n\n        This method only accepts `.Future` objects and not other\n        awaitables (unlike most of Tornado where the two are\n        interchangeable).\n        \"\"\"\n\n    def run_in_executor(\n            self,\n            executor: Optional[concurrent.futures.Executor],\n            func: Callable[..., _T],\n            *args: Any\n        ) -> Awaitable[_T]:\n        \"\"\"Runs a function in a ``concurrent.futures.Executor``. If\n        ``executor`` is ``None``, the IO loop's default executor will be used.\n\n        Use `functools.partial` to pass keyword arguments to ``func``.\n\n        .. versionadded:: 5.0\n        \"\"\"\n\n    def set_default_executor(self, executor: concurrent.futures.Executor) -> None:\n        \"\"\"Sets the default executor to use with :meth:`run_in_executor`.\n\n        .. versionadded:: 5.0\n        \"\"\"\n\n    def _run_callback(self, callback: Callable[[], Any]) -> None:\n        \"\"\"Runs a callback with error handling.\n\n        .. versionchanged:: 6.0\n\n        CancelledErrors are no longer logged.\n        \"\"\"\n\n    def _discard_future_result(self, future: Future) -> None:\n        \"\"\"Avoid unhandled-exception warnings from spawned coroutines.\"\"\"\n\n    def split_fd(\n            self, fd: Union[int, _Selectable]\n        ) -> Tuple[int, Union[int, _Selectable]]:\n\n    def close_fd(self, fd: Union[int, _Selectable]) -> None:\n\ndef _create_future() -> Future:\n\ndef sleep(duration: float) -> \"Future[None]\":\n    \"\"\"Return a `.Future` that resolves after the given number of seconds.\n\n    When used with ``yield`` in a coroutine, this is a non-blocking\n    analogue to `time.sleep` (which should not be used in coroutines\n    because it is blocking)::\n\n        yield gen.sleep(0.5)\n\n    Note that calling this function on its own does nothing; you must\n    wait on the `.Future` it returns (usually by yielding it).\n\n    .. versionadded:: 4.1\n    \"\"\"\n    f = _create_future()\n    IOLoop.current().call_later(\n        duration, lambda: future_set_result_unless_cancelled(f, None)\n    )\n    return f", "entry_point": "sleep", "test": null, "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert 0.5 == _run(sleep(0.5))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert 0.105 < (\n        sleep(0.1)  # type: ignore\n        .result(timeout=10)\n        .result(timeout=10)\n    ) < 0.115", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert 0 == sleep(0)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert 0.0 < sleep(0.01).result() < 0.01", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert 0 < sleep(0.000001)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert 3 == run_sync(lambda: gen.sleep(0.001) or 3)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    assert 5 == len(list(sleep(5)))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    assert 0.5 == sleep(0.5).result(0.1)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert 1 in sleep(1)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_9():\n    assert 0.5 - (time.time() - sleep(.5).result()) <= 0.05", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_10():\n    assert 0.9 < sleep(1).result() < 1.1", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_11():\n    assert 0.2 < (asyncio.get_event_loop().run_until_complete(sleep(0.3)) - time.time()) < 0.5", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_12():\n    assert 0.1 == sleep(0.1)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_13():\n    assert 5 == IOLoop.current().run_sync(lambda : (sleep(0.01)  # type: ignore\n                                                    .add_done_callback(lambda _: 5)\n                                                    .result()))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_14():\n    assert 0.01 < sleep(0.01).result() < 0.03", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_15():\n    assert 0 < sleep(1)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_16():\n    assert 3 == IOLoop.current().run_sync(lambda: gen.sleep(3))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_17():\n    assert 0.9 < (time() - (time() + sleep(0.1))) < 1.1", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_18():\n    assert sleep(0.1).result() is None"]}
{"problem_ids": 561, "project": "test-apps/tornado", "focal_function": "def to_asyncio_future(tornado_future: asyncio.Future) -> asyncio.Future:\n    \"\"\"Convert a Tornado yieldable object to an `asyncio.Future`.\n\n    .. versionadded:: 4.1\n\n    .. versionchanged:: 4.3\n       Now accepts any yieldable object, not just\n       `tornado.concurrent.Future`.\n\n    .. deprecated:: 5.0\n       Tornado ``Futures`` have been merged with `asyncio.Future`,\n       so this method is now equivalent to `tornado.gen.convert_yielded`.\n    \"\"\"\n    return convert_yielded(tornado_future)", "module": "tornado.platform.asyncio", "code": "import asyncio\nimport atexit\nimport concurrent.futures\nimport errno\nimport functools\nimport select\nimport socket\nimport sys\nimport threading\nimport typing\nfrom tornado.gen import convert_yielded\nfrom tornado.ioloop import IOLoop, _Selectable\nfrom typing import Any, TypeVar, Awaitable, Callable, Union, Optional, List, Tuple, Dict\n\ndef to_asyncio_future(tornado_future: asyncio.Future) -> asyncio.Future:\n    \"\"\"Convert a Tornado yieldable object to an `asyncio.Future`.\n\n    .. versionadded:: 4.1\n\n    .. versionchanged:: 4.3\n       Now accepts any yieldable object, not just\n       `tornado.concurrent.Future`.\n\n    .. deprecated:: 5.0\n       Tornado ``Futures`` have been merged with `asyncio.Future`,\n       so this method is now equivalent to `tornado.gen.convert_yielded`.\n    \"\"\"\n    return convert_yielded(tornado_future)", "entry_point": "to_asyncio_future", "test": null, "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert 2 == to_asyncio_future(convert_yielded(2)).result()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert to_asyncio_future(asyncio.Future()) == convert_yielded(asyncio.Future())", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert 1 == to_asyncio_future(asyncio.ensure_future(1))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert 3 == asyncio.get_event_loop().run_until_complete(to_asyncio_future(Future())).result()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert 42 == to_asyncio_future(asyncio.Future()).result()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert to_asyncio_future(convert_yielded(asyncio.Future())) is convert_yielded(asyncio.Future())", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    assert 42 == to_asyncio_future(tornado.gen.convert_yielded(42)).result()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    assert 1 == to_asyncio_future(tornado_future=1).result()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert 2==to_asyncio_future(asyncio.sleep(0,2)).result()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_9():\n    assert 5 == to_asyncio_future(asyncio.Future()).result()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_10():\n    assert 1 == to_asyncio_future(1)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_11():\n    assert 5 == to_asyncio_future(tornado.gen.convert_yielded(tornado.gen.Return(5))).result()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_12():\n    assert to_asyncio_future(asyncio.ensure_future(asyncio.sleep(1, result=123))) == asyncio.sleep(1, result=123)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_13():\n    assert 1 == to_asyncio_future(asyncio.Future().__await__())", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_14():\n    assert 5 == to_asyncio_future(to_asyncio_future(5)).result()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_15():\n    assert 10 == asyncio.get_event_loop().run_until_complete(to_asyncio_future(asyncio.Future()))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_16():\n    assert to_asyncio_future(convert_yielded(asyncio.Future())) == convert_yielded(asyncio.Future())", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_17():\n    assert convert_yielded(to_asyncio_future(1)) == 1", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_18():\n    assert 1==to_asyncio_future(asyncio.sleep(0)).result()"]}
{"problem_ids": 598, "project": "test-apps/tornado", "focal_function": "def timedelta_to_seconds(td):\n    # type: (datetime.timedelta) -> float\n    \"\"\"Equivalent to ``td.total_seconds()`` (introduced in Python 2.7).\"\"\"\n    return td.total_seconds()", "module": "tornado.util", "code": "import array\nimport atexit\nfrom inspect import getfullargspec\nimport os\nimport re\nimport typing\nimport zlib\nfrom typing import (\n    Any,\n    Optional,\n    Dict,\n    Mapping,\n    List,\n    Tuple,\n    Match,\n    Callable,\n    Type,\n    Sequence,\n)\n\ndef timedelta_to_seconds(td):\n    # type: (datetime.timedelta) -> float\n    \"\"\"Equivalent to ``td.total_seconds()`` (introduced in Python 2.7).\"\"\"\n    return td.total_seconds()", "entry_point": "timedelta_to_seconds", "test": null, "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert 0 < timedelta_to_seconds(datetime.timedelta(1)) < 1", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert 1.2 <= timedelta_to_seconds(datetime.timedelta(seconds=1.2)) <= 1.2000001", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert 0.1 == timedelta_to_seconds(datetime.timedelta(seconds=0.1))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert 2 == timedelta_to_seconds(datetime.timedelta(seconds=2))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert 1 == timedelta_to_seconds(datetime.timedelta(microseconds = 1000))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert timedelta_to_seconds(datetime.timedelta(1000, 0, 0, 0, 0, 0, 0)) == 1000", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    assert 1.5 == timedelta_to_seconds(datetime.timedelta(milliseconds=1500))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    assert 2.0 == timedelta_to_seconds(datetime.timedelta(milliseconds=2000))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert 6.5 == timedelta_to_seconds(datetime.timedelta(seconds=6.5))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_9():\n    assert 0 < timedelta_to_seconds(datetime.timedelta(0, 0, 0, 0, 0, 1)) < 1", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_10():\n    assert 0.3 == timedelta_to_seconds(datetime.timedelta(microseconds=300000))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_11():\n    assert 2.0 <= timedelta_to_seconds(datetime.timedelta(seconds=2)) < 2.000001", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_12():\n    assert 0 < timedelta_to_seconds(datetime.timedelta(0, 0, 0, 0, 1)) < 1", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_13():\n    assert 2.0 == timedelta_to_seconds(datetime.timedelta(seconds=2.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_14():\n    assert timedelta_to_seconds(datetime.timedelta(0, 0, 0, 0, 0, 0, 1)) == 0.000001", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_15():\n    assert 1.2 <= timedelta_to_seconds(datetime.timedelta(seconds=1, milliseconds=200))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_16():\n    assert 1.2 < timedelta_to_seconds(datetime.timedelta(seconds=1, milliseconds=200)) < 1.3", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_17():\n    assert 0.0 <= timedelta_to_seconds(datetime.timedelta(0)) <= 1e-6", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_18():\n    assert 0 < timedelta_to_seconds(datetime.timedelta(0, 0, 1)) < 1", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_19():\n    assert 100.0 <= timedelta_to_seconds(datetime.timedelta(seconds=100)) <= 101.0", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_20():\n    assert 1.0 == timedelta_to_seconds(datetime.timedelta(nanoseconds=1000000000.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_21():\n    assert 2.0 == timedelta_to_seconds(datetime.timedelta(microseconds=2000000))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_22():\n    assert 4.0 == timedelta_to_seconds(datetime.timedelta(seconds=4))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_23():\n    assert 1.2 <= timedelta_to_seconds(datetime.timedelta(seconds=1.2))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_24():\n    assert 1.0 <= timedelta_to_seconds(datetime.timedelta(seconds=1)) <= 2.0", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_25():\n    assert 2.0 == timedelta_to_seconds(datetime.timedelta(minutes=0, hours=0, days=0,\n                                                          weeks=0, months=0,\n                                                          years=0, milliseconds=2))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_26():\n    assert 2 <= timedelta_to_seconds(datetime.timedelta(seconds=2))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_27():\n    assert 1.2 == timedelta_to_seconds(datetime.timedelta(seconds=1.2))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_28():\n    assert 1.0 == timedelta_to_seconds(datetime.timedelta(milliseconds=1000.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_29():\n    assert 10.1 == timedelta_to_seconds(datetime.timedelta(seconds=10.1))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_30():\n    assert 1.0 <= timedelta_to_seconds(datetime.timedelta(seconds=1)) < 1.000001", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_31():\n    assert 12.3456789 == timedelta_to_seconds(datetime.timedelta(microseconds=12345678.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_32():\n    assert 0.0 <= timedelta_to_seconds(datetime.timedelta(microseconds=1)) <= 1e-6", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_33():\n    assert 1.1 <= timedelta_to_seconds(datetime.timedelta(seconds=1.1)) <= 1.1 + 1e-6", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_34():\n    assert 1.0 < timedelta_to_seconds(datetime.timedelta(seconds=1.0)) < 2.0", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_35():\n    assert 1.0 == timedelta_to_seconds(datetime.timedelta(microseconds=1000000.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_36():\n    assert 10.0 <= timedelta_to_seconds(datetime.timedelta(seconds=10)) <= 11.0", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_37():\n    assert 3.0 == timedelta_to_seconds(datetime.timedelta(seconds=3.0, milliseconds=500))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_38():\n    assert 1.2 == timedelta_to_seconds(datetime.timedelta(seconds=1, milliseconds=200))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_39():\n    assert 1.0 == timedelta_to_seconds(datetime.timedelta(microseconds=1000001.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_40():\n    assert 1.0 == timedelta_to_seconds(datetime.timedelta(seconds=1.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_41():\n    assert 1.0 <= timedelta_to_seconds(datetime.timedelta(seconds=1.0)) < 2.0", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_42():\n    assert 1000.0 <= timedelta_to_seconds(datetime.timedelta(seconds=1000)) <= 1001.0", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_43():\n    assert 24.0 == timedelta_to_seconds(datetime.timedelta(days=1, hours=12.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_44():\n    assert 1 == timedelta_to_seconds(datetime.timedelta(microseconds=1))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_45():\n    assert 1.0 <= timedelta_to_seconds(\n        datetime.timedelta(seconds=1.0)\n    ) < 2.0", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_46():\n    assert 1.0 == timedelta_to_seconds(datetime.timedelta(seconds=1))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_47():\n    assert 0.1 <= timedelta_to_seconds(datetime.timedelta(seconds=0.1)) - 0.1 < 1e-6", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_48():\n    assert 1.1 == timedelta_to_seconds(datetime.timedelta(seconds=1.1))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_49():\n    assert 1.2 == timedelta_to_seconds(\n        datetime.timedelta(seconds=1, microseconds=200000)\n    )", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_50():\n    assert 1.2 < timedelta_to_seconds(\n        datetime.timedelta(seconds=1, microseconds=200000)\n    )", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_51():\n    assert 24 * 60 * 60 == timedelta_to_seconds(datetime.timedelta(1))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_52():\n    assert 2.3 == timedelta_to_seconds(datetime.timedelta(seconds=2, microseconds=300000))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_53():\n    assert 6 == timedelta_to_seconds(datetime.timedelta(seconds=6.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_54():\n    assert 0 < timedelta_to_seconds(datetime.timedelta(0, 0, 0, 1)) < 1", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_55():\n    assert 2.0 == timedelta_to_seconds(datetime.timedelta(seconds=2))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_56():\n    assert 3.0 == timedelta_to_seconds(datetime.timedelta(seconds=3.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_57():\n    assert 0.1 == timedelta_to_seconds(datetime.timedelta(microseconds=100000))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_58():\n    assert 12.34 == timedelta_to_seconds(datetime.timedelta(seconds=12, microseconds=340000))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_59():\n    assert 1.2 == timedelta_to_seconds(datetime.timedelta(seconds=1, microseconds=200000))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_60():\n    assert 12.34 == timedelta_to_seconds(datetime.timedelta(microseconds=12340000.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_61():\n    assert 1.2 <= timedelta_to_seconds(datetime.timedelta(seconds=1, milliseconds=200)) <= 1.3", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_62():\n    assert 0 == timedelta_to_seconds(datetime.timedelta(0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_63():\n    assert 1.0 == timedelta_to_seconds(datetime.timedelta(microseconds=1000000))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_64():\n    assert 1.0 == timedelta_to_seconds(\n        datetime.timedelta(seconds=1.0, microseconds=1000))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_65():\n    assert 0.0 <= timedelta_to_seconds(datetime.timedelta(milliseconds=1)) <= 1e-4", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_66():\n    assert 3601 == timedelta_to_seconds(datetime.timedelta(hours=1, minutes=1))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_67():\n    assert 1.2 < timedelta_to_seconds(datetime.timedelta(seconds=1, microseconds=200000)) < 1.3", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_68():\n    assert 0.0 <= timedelta_to_seconds(datetime.timedelta(nanoseconds=1)) <= 1e-9", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_69():\n    assert 1.2 <= timedelta_to_seconds(datetime.timedelta(seconds=1.2)) <= 1.3", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_70():\n    assert 45 == timedelta_to_seconds(datetime.timedelta(seconds=45))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_71():\n    assert timedelta_to_seconds(datetime.timedelta(0)) == 0", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_72():\n    assert 0.2 == timedelta_to_seconds(datetime.timedelta(microseconds=200000))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_73():\n    assert 0.2 == timedelta_to_seconds(datetime.timedelta(milliseconds=200))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_74():\n    assert 1.0001 == timedelta_to_seconds(datetime.timedelta(milliseconds=1))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_75():\n    assert 1e-6 <= timedelta_to_seconds(datetime.timedelta(microseconds=1)) < 1.000001", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_76():\n    assert 0.9 <= timedelta_to_seconds(datetime.timedelta(milliseconds=100)) < 1", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_77():\n    assert 12.34 == timedelta_to_seconds(datetime.timedelta(seconds=12.34))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_78():\n    assert 1.2 == timedelta_to_seconds(datetime.timedelta(milliseconds=1200.0))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_79():\n    assert 12.3456789 == timedelta_to_seconds(datetime.timedelta(seconds=12.3456789))"]}
{"problem_ids": 603, "project": "test-apps/tornado", "focal_function": "def run_on_executor(*args: Any, **kwargs: Any) -> Callable:\n    \"\"\"Decorator to run a synchronous method asynchronously on an executor.\n\n    Returns a future.\n\n    The executor to be used is determined by the ``executor``\n    attributes of ``self``. To use a different attribute name, pass a\n    keyword argument to the decorator::\n\n        @run_on_executor(executor='_thread_pool')\n        def foo(self):\n            pass\n\n    This decorator should not be confused with the similarly-named\n    `.IOLoop.run_in_executor`. In general, using ``run_in_executor``\n    when *calling* a blocking method is recommended instead of using\n    this decorator when *defining* a method. If compatibility with older\n    versions of Tornado is required, consider defining an executor\n    and using ``executor.submit()`` at the call site.\n\n    .. versionchanged:: 4.2\n       Added keyword arguments to use alternative attributes.\n\n    .. versionchanged:: 5.0\n       Always uses the current IOLoop instead of ``self.io_loop``.\n\n    .. versionchanged:: 5.1\n       Returns a `.Future` compatible with ``await`` instead of a\n       `concurrent.futures.Future`.\n\n    .. deprecated:: 5.1\n\n       The ``callback`` argument is deprecated and will be removed in\n       6.0. The decorator itself is discouraged in new code but will\n       not be removed in 6.0.\n\n    .. versionchanged:: 6.0\n\n       The ``callback`` argument was removed.\n    \"\"\"\n    # Fully type-checking decorators is tricky, and this one is\n    # discouraged anyway so it doesn't have all the generic magic.\n    def run_on_executor_decorator(fn: Callable) -> Callable[..., Future]:\n        executor = kwargs.get(\"executor\", \"executor\")\n\n        @functools.wraps(fn)\n        def wrapper(self: Any, *args: Any, **kwargs: Any) -> Future:\n            async_future = Future()  # type: Future\n            conc_future = getattr(self, executor).submit(fn, self, *args, **kwargs)\n            chain_future(conc_future, async_future)\n            return async_future\n\n        return wrapper\n\n    if args and kwargs:\n        raise ValueError(\"cannot combine positional and keyword args\")\n    if len(args) == 1:\n        return run_on_executor_decorator(args[0])\n    elif len(args) != 0:\n        raise ValueError(\"expected 1 argument, got %d\", len(args))\n    return run_on_executor_decorator", "module": "tornado.concurrent", "code": "import asyncio\nfrom concurrent import futures\nimport functools\nimport sys\nimport types\nfrom tornado.log import app_log\nimport typing\nfrom typing import Any, Callable, Optional, Tuple, Union\nfrom tornado.ioloop import IOLoop\n\nFuture = asyncio.Future\n\ndef chain_future(a: \"Future[_T]\", b: \"Future[_T]\") -> None:\n    \"\"\"Chain two futures together so that when one completes, so does the other.\n    The result (success or failure) of ``a`` will be copied to ``b``, unless\n    ``b`` has already been completed or cancelled by the time ``a`` finishes.\n    .. versionchanged:: 5.0\n    Now accepts both Tornado/asyncio `Future` objects and\n    `concurrent.futures.Future`.\n    \"\"\"\n\ndef run_on_executor(*args: Any, **kwargs: Any) -> Callable:\n    \"\"\"Decorator to run a synchronous method asynchronously on an executor.\n\n    Returns a future.\n\n    The executor to be used is determined by the ``executor``\n    attributes of ``self``. To use a different attribute name, pass a\n    keyword argument to the decorator::\n\n        @run_on_executor(executor='_thread_pool')\n        def foo(self):\n            pass\n\n    This decorator should not be confused with the similarly-named\n    `.IOLoop.run_in_executor`. In general, using ``run_in_executor``\n    when *calling* a blocking method is recommended instead of using\n    this decorator when *defining* a method. If compatibility with older\n    versions of Tornado is required, consider defining an executor\n    and using ``executor.submit()`` at the call site.\n\n    .. versionchanged:: 4.2\n       Added keyword arguments to use alternative attributes.\n\n    .. versionchanged:: 5.0\n       Always uses the current IOLoop instead of ``self.io_loop``.\n\n    .. versionchanged:: 5.1\n       Returns a `.Future` compatible with ``await`` instead of a\n       `concurrent.futures.Future`.\n\n    .. deprecated:: 5.1\n\n       The ``callback`` argument is deprecated and will be removed in\n       6.0. The decorator itself is discouraged in new code but will\n       not be removed in 6.0.\n\n    .. versionchanged:: 6.0\n\n       The ``callback`` argument was removed.\n    \"\"\"\n    # Fully type-checking decorators is tricky, and this one is\n    # discouraged anyway so it doesn't have all the generic magic.\n    def run_on_executor_decorator(fn: Callable) -> Callable[..., Future]:\n        executor = kwargs.get(\"executor\", \"executor\")\n\n        @functools.wraps(fn)\n        def wrapper(self: Any, *args: Any, **kwargs: Any) -> Future:\n            async_future = Future()  # type: Future\n            conc_future = getattr(self, executor).submit(fn, self, *args, **kwargs)\n            chain_future(conc_future, async_future)\n            return async_future\n\n        return wrapper\n\n    if args and kwargs:\n        raise ValueError(\"cannot combine positional and keyword args\")\n    if len(args) == 1:\n        return run_on_executor_decorator(args[0])\n    elif len(args) != 0:\n        raise ValueError(\"expected 1 argument, got %d\", len(args))\n    return run_on_executor_decorator", "entry_point": "run_on_executor", "test": null, "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert 3 == run_on_executor(lambda x: x+x)(2)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert 42 == run_on_executor(executor = 'a')(lambda self, a,b: a + b)(None, 0, 0)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert 42 == asyncio.run(run_on_executor(lambda x: 42)(None))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert 3 == run_on_executor(lambda x: x + 2, 1)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert 42 == asyncio.run(run_on_executor(executor='_thread_pool')(lambda x: 42)(None))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert 42 == run_on_executor(lambda a,b: a + b, 40, 2)(None, 0)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    assert 42 == run_on_executor(lambda: 42)()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    assert 42 == run_on_executor(lambda x: x)(42)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert 3 == run_on_executor(executor='_thread_pool')(lambda x: x+x)(2)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_9():\n    assert run_on_executor(4) == 4", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_10():\n    assert 3 == run_on_executor()(lambda x: x+x)(2)"]}
