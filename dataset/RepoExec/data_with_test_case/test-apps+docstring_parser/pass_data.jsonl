{"problem_ids": 323, "project": "test-apps/docstring_parser", "focal_function": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)", "module": "docstring_parser.google", "code": "import inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\nclass Docstring:\n    \"\"\"Docstring object representation.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize self.\"\"\"\n\n    def params(self) -> T.List[DocstringParam]:\n\n    def raises(self) -> T.List[DocstringRaises]:\n\n    def returns(self) -> T.Optional[DocstringReturns]:\n\n    def deprecation(self) -> T.Optional[DocstringDeprecated]:\n\nclass GoogleParser:\n\n    def __init__(\n            self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n        ):\n        \"\"\"Setup sections.\n        :param sections: Recognized sections or None to defaults.\n        :param title_colon: require colon after section title.\n        \"\"\"\n\n    def _setup(self):\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n\n    def _build_multi_meta(\n            self, section: Section, before: str, desc: str\n        ) -> DocstringMeta:\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n        :param section: The new section.\n        \"\"\"\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n        :returns: parsed docstring\n        \"\"\"\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)", "entry_point": "parse", "test": "import inspect\nimport re\nimport typing as T\nfrom collections import namedtuple, OrderedDict\nfrom enum import IntEnum\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom docstring_parser.google import * # noqa: autoimport\nfrom docstring_parser.google import parse # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert isinstance(parse.__qualname__, str)\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert isinstance(parse(\"\"), Docstring)\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert isinstance(parse, T.Callable)\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert isinstance(parse.__doc__, str)\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_13():\n    assert isinstance(parse.__name__, str)\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert isinstance(parse.__qualname__, str)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert isinstance(parse(\"\"), Docstring)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert isinstance(parse, T.Callable)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert isinstance(parse.__doc__, str)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_13():\n    assert isinstance(parse.__name__, str)"]}
{"problem_ids": 324, "project": "test-apps/docstring_parser", "focal_function": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    ret = Docstring()\n    if not text:\n        return ret\n\n    text = inspect.cleandoc(text)\n    match = re.search(\"^:\", text, flags=re.M)\n    if match:\n        desc_chunk = text[: match.start()]\n        meta_chunk = text[match.start() :]\n    else:\n        desc_chunk = text\n        meta_chunk = \"\"\n\n    parts = desc_chunk.split(\"\\n\", 1)\n    ret.short_description = parts[0] or None\n    if len(parts) > 1:\n        long_desc_chunk = parts[1] or \"\"\n        ret.blank_after_short_description = long_desc_chunk.startswith(\"\\n\")\n        ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n        ret.long_description = long_desc_chunk.strip() or None\n\n    for match in re.finditer(\n        r\"(^:.*?)(?=^:|\\Z)\", meta_chunk, flags=re.S | re.M\n    ):\n        chunk = match.group(0)\n        if not chunk:\n            continue\n        try:\n            args_chunk, desc_chunk = chunk.lstrip(\":\").split(\":\", 1)\n        except ValueError:\n            raise ParseError(\n                'Error parsing meta information near \"{}\".'.format(chunk)\n            )\n        args = args_chunk.split()\n        desc = desc_chunk.strip()\n        if \"\\n\" in desc:\n            first_line, rest = desc.split(\"\\n\", 1)\n            desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n\n        ret.meta.append(_build_meta(args, desc))\n\n    return ret", "module": "docstring_parser.rest", "code": "import inspect\nimport re\nimport typing as T\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\nclass ParseError(RuntimeError):\n    \"\"\"Base class for all parsing related errors.\"\"\"\n\nclass Docstring:\n    \"\"\"Docstring object representation.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize self.\"\"\"\n\n    def params(self) -> T.List[DocstringParam]:\n\n    def raises(self) -> T.List[DocstringRaises]:\n\n    def returns(self) -> T.Optional[DocstringReturns]:\n\n    def deprecation(self) -> T.Optional[DocstringDeprecated]:\n\ndef _build_meta(args: T.List[str], desc: str) -> DocstringMeta:\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    ret = Docstring()\n    if not text:\n        return ret\n\n    text = inspect.cleandoc(text)\n    match = re.search(\"^:\", text, flags=re.M)\n    if match:\n        desc_chunk = text[: match.start()]\n        meta_chunk = text[match.start() :]\n    else:\n        desc_chunk = text\n        meta_chunk = \"\"\n\n    parts = desc_chunk.split(\"\\n\", 1)\n    ret.short_description = parts[0] or None\n    if len(parts) > 1:\n        long_desc_chunk = parts[1] or \"\"\n        ret.blank_after_short_description = long_desc_chunk.startswith(\"\\n\")\n        ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n        ret.long_description = long_desc_chunk.strip() or None\n\n    for match in re.finditer(\n        r\"(^:.*?)(?=^:|\\Z)\", meta_chunk, flags=re.S | re.M\n    ):\n        chunk = match.group(0)\n        if not chunk:\n            continue\n        try:\n            args_chunk, desc_chunk = chunk.lstrip(\":\").split(\":\", 1)\n        except ValueError:\n            raise ParseError(\n                'Error parsing meta information near \"{}\".'.format(chunk)\n            )\n        args = args_chunk.split()\n        desc = desc_chunk.strip()\n        if \"\\n\" in desc:\n            first_line, rest = desc.split(\"\\n\", 1)\n            desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n\n        ret.meta.append(_build_meta(args, desc))\n\n    return ret", "entry_point": "parse", "test": "import inspect\nimport re\nimport typing as T\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom docstring_parser.rest import * # noqa: autoimport\nfrom docstring_parser.rest import parse # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_21():\n    assert None is parse(\":deprecated:\").returns\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_21():\n    assert None is parse(\":deprecated:\").returns"]}
{"problem_ids": 326, "project": "test-apps/docstring_parser", "focal_function": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return NumpydocParser().parse(text)", "module": "docstring_parser.numpydoc", "code": "import inspect\nimport itertools\nimport re\nimport typing as T\nfrom .common import (\n    Docstring,\n    DocstringDeprecated,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n)\n\nclass Docstring:\n    \"\"\"Docstring object representation.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize self.\"\"\"\n\n    def params(self) -> T.List[DocstringParam]:\n\n    def raises(self) -> T.List[DocstringRaises]:\n\n    def returns(self) -> T.Optional[DocstringReturns]:\n\n    def deprecation(self) -> T.Optional[DocstringDeprecated]:\n\nclass NumpydocParser:\n\n    def __init__(self, sections: T.Optional[T.Dict[str, Section]] = None):\n        \"\"\"Setup sections.\n        :param sections: Recognized sections or None to defaults.\n        \"\"\"\n\n    def _setup(self):\n\n    def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n        :param section: The new section.\n        \"\"\"\n\n    def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the numpy-style docstring into its components.\n        :returns: parsed docstring\n        \"\"\"\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return NumpydocParser().parse(text)", "entry_point": "parse", "test": "import inspect\nimport itertools\nimport re\nimport typing as T\nfrom .common import (\n    Docstring,\n    DocstringDeprecated,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n)\nimport sys\nsys.path.insert(1, \"/input/test-apps/docstring_parser\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom docstring_parser.numpydoc import * # noqa: autoimport\nfrom docstring_parser.numpydoc import parse # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_22():\n    assert isinstance(parse(\"\"), Docstring)\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_22():\n    assert isinstance(parse(\"\"), Docstring)"]}
