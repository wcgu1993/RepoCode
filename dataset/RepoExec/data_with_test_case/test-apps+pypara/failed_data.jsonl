{"problem_ids": 472, "project": "test-apps/pypara", "focal_function": "def compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program", "module": "pypara.accounting.ledger", "code": "import datetime\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal\nfrom typing import Dict, Generic, Iterable, List, Optional, Protocol, TypeVar\nfrom ..commons.numbers import Amount, Quantity\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry, Posting, ReadJournalEntries\n\nclass DateRange:\n    \"\"\"\n    Provides an encoding for date ranges.\n    \"\"\"\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n\n_T = TypeVar(\"_T\")\n\nclass GeneralLedger(Generic[_T]):\n    \"\"\"\n    Provides a general ledger model.\n    \"\"\"\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n\nclass ReadInitialBalances(Protocol):\n    \"\"\"\n    Type of functions which reads and returns initial balances.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> InitialBalances:\n\nclass GeneralLedgerProgram(Protocol[_T]):\n    \"\"\"\n    Type definition of the program which builds general ledger.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> GeneralLedger[_T]:\n\ndef compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program", "entry_point": "compile_general_ledger_program", "test": null, "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert 5 == compile_general_ledger_program(\n        lambda period: InitialBalances(\n            {\n                Account.OpeningBalances: Balance(\n                    Amount(Decimal(5), 'CHF'),\n                    Balance.Kind.Credit\n                )\n            }\n        ),\n        lambda period: [\n            JournalEntry(\n                datetime.date(2020, 3, 1),\n                [\n                    Posting(\n                        Account.from_string('Expenses:Conferences'),\n                        Amount(Decimal(40), 'CHF'),\n                        None,\n                        'Conference in Berlin'\n                    ),\n                    Posting(\n                        Account.from_string('Assets:Share Capital'),\n                        Amount(Decimal(40), 'CHF'),\n                        None,\n                        'Subscription'\n                    ),\n                ]\n            ),\n            JournalEntry(\n                datetime.date(2020, 3, 5),\n                [\n                    Posting(\n                        Account.from_string('Expenses:Food'),\n                        Amount(Decimal(40), 'CHF'),\n                        None,\n                        'Lunch with clients'\n                    ),\n                    Posting(\n                        Account.from_string('Expenses:Food'),\n                        Amount(Decimal(30), 'CHF'),\n                        None,\n                        'Dinner with clients'\n                    ),\n                    Posting(\n                        Account.from_string('Assets:Share Capital'),\n                        Amount(Decimal(30), 'CHF'),\n                        None,\n                        'Dividends'\n                    ),\n                ]\n            ),\n        ]\n    )(DateRange())[0].credit_balance.amount", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert 3 == compile_general_ledger_program(\n        lambda p: InitialBalances(\n            assets = { Account(\"A1\") : Balance(Decimal(100), Decimal(0)) },\n            liabilities = {},\n            equity = {},\n            revenues = {},\n            expenses = {},\n        ),\n        lambda p: [],\n    )(DateRange())", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert 42 == compile_general_ledger_program(\n        lambda _: {},\n        lambda _: [],\n    )(date.today())", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert 100 == compile_general_ledger_program(lambda x: InitialBalances([]), lambda x: [JournalEntry(datetime.date.today(), \"1234\", \"a\", \"b\", Decimal(100), None)])(DateRange()).balances()[0].amount", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert compile_general_ledger_program(lambda period: {}, lambda period: [])(None) == {}"]}
