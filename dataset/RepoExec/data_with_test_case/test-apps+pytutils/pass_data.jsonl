{"problem_ids": 149, "project": "test-apps/pytutils", "focal_function": "def update_query_params(url, params, doseq=True):\n    \"\"\"\n    Update and/or insert query parameters in a URL.\n\n    >>> update_query_params('http://example.com?foo=bar&biz=baz', dict(foo='stuff'))\n    'http://example.com?...foo=stuff...'\n\n    :param url: URL\n    :type url: str\n    :param kwargs: Query parameters\n    :type kwargs: dict\n    :return: Modified URL\n    :rtype: str\n    \"\"\"\n    scheme, netloc, path, query_string, fragment = urlparse.urlsplit(url)\n\n    query_params = urlparse.parse_qs(query_string)\n    query_params.update(**params)\n\n    new_query_string = urlencode(query_params, doseq=doseq)\n\n    new_url = urlparse.urlunsplit([scheme, netloc, path, new_query_string, fragment])\n    return new_url", "module": "pytutils.urls", "code": "import urlparse\nfrom urllib import urlencode\nimport urllib.parse as urlparse\n\ntry:\n    \n    \nexcept ImportError:  # py3k\n    \n    urlencode = urlparse.urlencode\n\ndef update_query_params(url, params, doseq=True):\n    \"\"\"\n    Update and/or insert query parameters in a URL.\n\n    >>> update_query_params('http://example.com?foo=bar&biz=baz', dict(foo='stuff'))\n    'http://example.com?...foo=stuff...'\n\n    :param url: URL\n    :type url: str\n    :param kwargs: Query parameters\n    :type kwargs: dict\n    :return: Modified URL\n    :rtype: str\n    \"\"\"\n    scheme, netloc, path, query_string, fragment = urlparse.urlsplit(url)\n\n    query_params = urlparse.parse_qs(query_string)\n    query_params.update(**params)\n\n    new_query_string = urlencode(query_params, doseq=doseq)\n\n    new_url = urlparse.urlunsplit([scheme, netloc, path, new_query_string, fragment])\n    return new_url", "entry_point": "update_query_params", "test": "try:\n    import urlparse\n    from urllib import urlencode\nexcept ImportError:  # py3k\n    import urllib.parse as urlparse\n    urlencode = urlparse.urlencode\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.urls import * # noqa: autoimport\nfrom pytutils.urls import update_query_params # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(foo='stuff', boo='zim'), doseq=True) =='http://example.com?foo=stuff&biz=baz&boo=zim'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert update_query_params(\"http://example.com?a=1\",dict(b=2))==\"http://example.com?a=1&b=2\"\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert (update_query_params('http://example.com?foo=bar&biz=baz', {'foo':'stuff'}) == 'http://example.com?foo=stuff&biz=baz')\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert update_query_params(\"https://www.youtube.com/watch?v=2lAe1cFze2o\",\n                                                        dict(t='15')) == 'https://www.youtube.com/watch?v=2lAe1cFze2o&t=15'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    assert update_query_params('http://example.com?foo=bar', dict(foo='stuff', test='test')) == 'http://example.com?foo=stuff&test=test'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    assert update_query_params(\n        'http://example.com?foo=bar&biz=baz',\n        {'foo': 'stuff'}\n    ) == 'http://example.com?foo=stuff&biz=baz'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert update_query_params('http://example.com?foo=bar', {'foo': ['baz', 'qux']}) == 'http://example.com?foo=baz&foo=qux'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_9():\n    assert update_query_params(\"http://test.com?p1=fo&p2=ba\", {\"p2\":\"bar\"}) == 'http://test.com?p1=fo&p2=bar'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_10():\n    assert update_query_params('http://example.com?foo=bar&biz=baz', {'foo': 'stuff'}) == 'http://example.com?foo=stuff&biz=baz'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_12():\n    assert (update_query_params('http://example.com?foo=bar&biz=baz&foo=grunt', {'foo':'stuff', 'nuf':'grunt'}) == 'http://example.com?foo=stuff&biz=baz&nuf=grunt')\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_13():\n    assert update_query_params(\"http://example.com?a=1&b=2\", {\"b\": \"2\"}) == \"http://example.com?a=1&b=2\"\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_14():\n    assert update_query_params('http://example.com?a=b', {'a':'c'})=='http://example.com?a=c'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_15():\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(new='stuff')) == 'http://example.com?foo=bar&biz=baz&new=stuff'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_16():\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(foo='stuff', boo='zim')) =='http://example.com?foo=stuff&biz=baz&boo=zim'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_17():\n    assert update_query_params('https://www.examplesite.com?food=cake', {'food': ['soup', 'candy']}) == 'https://www.examplesite.com?food=soup&food=candy'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_18():\n    assert update_query_params('http://example.com', {'foo': 'bar'}) == 'http://example.com?foo=bar'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_19():\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(foo='stuff', baz='test')) == 'http://example.com?foo=stuff&biz=baz&baz=test'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+urls/update_query_params/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert update_query_params('http://example.com?foo=bar&biz=baz', {'foo':'stuff'}, doseq=False) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+urls/update_query_params/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(foo='stuff', new='stuff', xyz=None)) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_11():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+urls/update_query_params/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(foo=['stuff','things'])) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_20():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+urls/update_query_params/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert update_query_params('https://example.com/abc?foo=bar&foo=baz&biz=baz', dict(foo='stuff', biz='thing')) == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(foo='stuff', boo='zim'), doseq=True) =='http://example.com?foo=stuff&biz=baz&boo=zim'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert update_query_params(\"http://example.com?a=1\",dict(b=2))==\"http://example.com?a=1&b=2\"", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert (update_query_params('http://example.com?foo=bar&biz=baz', {'foo':'stuff'}) == 'http://example.com?foo=stuff&biz=baz')", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert update_query_params(\"https://www.youtube.com/watch?v=2lAe1cFze2o\",\n                                                        dict(t='15')) == 'https://www.youtube.com/watch?v=2lAe1cFze2o&t=15'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    assert update_query_params('http://example.com?foo=bar', dict(foo='stuff', test='test')) == 'http://example.com?foo=stuff&test=test'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    assert update_query_params(\n        'http://example.com?foo=bar&biz=baz',\n        {'foo': 'stuff'}\n    ) == 'http://example.com?foo=stuff&biz=baz'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert update_query_params('http://example.com?foo=bar', {'foo': ['baz', 'qux']}) == 'http://example.com?foo=baz&foo=qux'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_9():\n    assert update_query_params(\"http://test.com?p1=fo&p2=ba\", {\"p2\":\"bar\"}) == 'http://test.com?p1=fo&p2=bar'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_10():\n    assert update_query_params('http://example.com?foo=bar&biz=baz', {'foo': 'stuff'}) == 'http://example.com?foo=stuff&biz=baz'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_12():\n    assert (update_query_params('http://example.com?foo=bar&biz=baz&foo=grunt', {'foo':'stuff', 'nuf':'grunt'}) == 'http://example.com?foo=stuff&biz=baz&nuf=grunt')", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_13():\n    assert update_query_params(\"http://example.com?a=1&b=2\", {\"b\": \"2\"}) == \"http://example.com?a=1&b=2\"", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_14():\n    assert update_query_params('http://example.com?a=b', {'a':'c'})=='http://example.com?a=c'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_15():\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(new='stuff')) == 'http://example.com?foo=bar&biz=baz&new=stuff'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_16():\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(foo='stuff', boo='zim')) =='http://example.com?foo=stuff&biz=baz&boo=zim'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_17():\n    assert update_query_params('https://www.examplesite.com?food=cake', {'food': ['soup', 'candy']}) == 'https://www.examplesite.com?food=soup&food=candy'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_18():\n    assert update_query_params('http://example.com', {'foo': 'bar'}) == 'http://example.com?foo=bar'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_19():\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(foo='stuff', baz='test')) == 'http://example.com?foo=stuff&biz=baz&baz=test'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+urls/update_query_params/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert update_query_params('http://example.com?foo=bar&biz=baz', {'foo':'stuff'}, doseq=False) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+urls/update_query_params/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(foo='stuff', new='stuff', xyz=None)) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_11():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+urls/update_query_params/test_11\", \"rb\") as f:\n        output = pickle.load(f)\n    assert update_query_params('http://example.com?foo=bar&biz=baz', dict(foo=['stuff','things'])) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_20():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+urls/update_query_params/test_20\", \"rb\") as f:\n        output = pickle.load(f)\n    assert update_query_params('https://example.com/abc?foo=bar&foo=baz&biz=baz', dict(foo='stuff', biz='thing')) == output"]}
{"problem_ids": 152, "project": "test-apps/pytutils", "focal_function": "def ensure_encoded_bytes(s, encoding='utf-8', errors='strict', allowed_types=(bytes, bytearray, memoryview)):\n    \"\"\"\n    Ensure string is encoded as byteslike; convert using specified parameters if we have to.\n\n    :param str|bytes|bytesarray|memoryview s: string/byteslike\n    :param str encoding: Decode using this encoding\n    :param str errors: How to handle errors\n    :return bytes|bytesarray|memoryview: Encoded string as str\n    \"\"\"\n    if isinstance(s, allowed_types):\n        return s\n    else:\n        return s.encode(encoding=encoding, errors=errors)", "module": "pytutils.pythree", "code": "import six\n\ndef ensure_encoded_bytes(s, encoding='utf-8', errors='strict', allowed_types=(bytes, bytearray, memoryview)):\n    \"\"\"\n    Ensure string is encoded as byteslike; convert using specified parameters if we have to.\n\n    :param str|bytes|bytesarray|memoryview s: string/byteslike\n    :param str encoding: Decode using this encoding\n    :param str errors: How to handle errors\n    :return bytes|bytesarray|memoryview: Encoded string as str\n    \"\"\"\n    if isinstance(s, allowed_types):\n        return s\n    else:\n        return s.encode(encoding=encoding, errors=errors)", "entry_point": "ensure_encoded_bytes", "test": "import six\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.pythree import * # noqa: autoimport\nfrom pytutils.pythree import ensure_encoded_bytes # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_235():\n    assert ensure_encoded_bytes(u\"café\") == b\"caf\\xc3\\xa9\"\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_236():\n    assert 0 == b'0'.find(ensure_encoded_bytes('0'))\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_238():\n    assert b'abc' == ensure_encoded_bytes(u'abc', errors='strict', allowed_types=(bytes, bytearray, memoryview))\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_239():\n    assert ensure_encoded_bytes(bytearray(b'abc'), 'utf-8') == b'abc'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_240():\n    assert b'abc' == ensure_encoded_bytes('abc', errors='strict', allowed_types=(bytes, bytearray, memoryview))\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_241():\n    assert ensure_encoded_bytes(memoryview(b'abc')) == b'abc'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_242():\n    assert isinstance(ensure_encoded_bytes(\"Hallo\"), six.binary_type)\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_243():\n    assert ensure_encoded_bytes(u'xxx', encoding='utf-8', errors='strict') == b'xxx'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert b'abc' == ensure_encoded_bytes(memoryview(b'abc'))\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert isinstance(ensure_encoded_bytes(\"x\"), six.binary_type)\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert b'string' == ensure_encoded_bytes(b'string')\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert isinstance(ensure_encoded_bytes(memoryview(b'test')), (bytes, bytearray, memoryview))\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert isinstance(ensure_encoded_bytes(u\"foo\", encoding=\"utf-8\", errors=\"strict\"), (bytes, bytearray, memoryview))\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    assert ensure_encoded_bytes(b'b', encoding='utf-8', errors='strict', allowed_types=(bytes, bytearray, memoryview)) == b'b'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert ensure_encoded_bytes(bytearray(b'abc'), 'utf-32') == b'abc'\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pythree/ensure_encoded_bytes/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert int(hash(ensure_encoded_bytes(b\"xyzzy\"))) == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_235():\n    assert ensure_encoded_bytes(u\"café\") == b\"caf\\xc3\\xa9\"", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_236():\n    assert 0 == b'0'.find(ensure_encoded_bytes('0'))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_238():\n    assert b'abc' == ensure_encoded_bytes(u'abc', errors='strict', allowed_types=(bytes, bytearray, memoryview))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_239():\n    assert ensure_encoded_bytes(bytearray(b'abc'), 'utf-8') == b'abc'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_240():\n    assert b'abc' == ensure_encoded_bytes('abc', errors='strict', allowed_types=(bytes, bytearray, memoryview))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_241():\n    assert ensure_encoded_bytes(memoryview(b'abc')) == b'abc'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_242():\n    assert isinstance(ensure_encoded_bytes(\"Hallo\"), six.binary_type)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_243():\n    assert ensure_encoded_bytes(u'xxx', encoding='utf-8', errors='strict') == b'xxx'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert b'abc' == ensure_encoded_bytes(memoryview(b'abc'))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert isinstance(ensure_encoded_bytes(\"x\"), six.binary_type)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert b'string' == ensure_encoded_bytes(b'string')", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert isinstance(ensure_encoded_bytes(memoryview(b'test')), (bytes, bytearray, memoryview))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert isinstance(ensure_encoded_bytes(u\"foo\", encoding=\"utf-8\", errors=\"strict\"), (bytes, bytearray, memoryview))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    assert ensure_encoded_bytes(b'b', encoding='utf-8', errors='strict', allowed_types=(bytes, bytearray, memoryview)) == b'b'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert ensure_encoded_bytes(bytearray(b'abc'), 'utf-32') == b'abc'", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pythree/ensure_encoded_bytes/test_7\", \"rb\") as f:\n        output = pickle.load(f)\n    assert int(hash(ensure_encoded_bytes(b\"xyzzy\"))) == output"]}
{"problem_ids": 153, "project": "test-apps/pytutils", "focal_function": "def ensure_decoded_text(s, encoding='utf-8', errors='strict', allowed_types=(six.text_type,)):\n    \"\"\"\n    Ensure string is decoded (eg unicode); convert using specified parameters if we have to.\n\n    :param str|bytes|bytesarray|memoryview s: string/bytes\n    :param str encoding: Decode using this encoding\n    :param str errors: How to handle errors\n    :return bytes|bytesarray|memoryview: Decoded string as bytes\n\n    :return: Encoded string\n    :rtype: bytes\n    \"\"\"\n    if not isinstance(s, allowed_types):\n        return s.decode(encoding=encoding, errors=errors)\n    else:\n        return s", "module": "pytutils.pythree", "code": "import six\n\ndef ensure_decoded_text(s, encoding='utf-8', errors='strict', allowed_types=(six.text_type,)):\n    \"\"\"\n    Ensure string is decoded (eg unicode); convert using specified parameters if we have to.\n\n    :param str|bytes|bytesarray|memoryview s: string/bytes\n    :param str encoding: Decode using this encoding\n    :param str errors: How to handle errors\n    :return bytes|bytesarray|memoryview: Decoded string as bytes\n\n    :return: Encoded string\n    :rtype: bytes\n    \"\"\"\n    if not isinstance(s, allowed_types):\n        return s.decode(encoding=encoding, errors=errors)\n    else:\n        return s", "entry_point": "ensure_decoded_text", "test": "import six\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.pythree import * # noqa: autoimport\nfrom pytutils.pythree import ensure_decoded_text # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pythree/ensure_decoded_text/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(ensure_decoded_text(b\"hello world\"), str) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pythree/ensure_decoded_text/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(ensure_decoded_text(bytearray(b'ABC'), errors='ignore'), bytearray) == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pythree/ensure_decoded_text/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(ensure_decoded_text(b\"hello world\"), str) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pythree/ensure_decoded_text/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert isinstance(ensure_decoded_text(bytearray(b'ABC'), errors='ignore'), bytearray) == output"]}
{"problem_ids": 154, "project": "test-apps/pytutils", "focal_function": "def multiplex(q, count=2, queue_factory=lambda: Queue()):\n    \"\"\" Convert one queue into several. Kind of like a teeing queue.\n\n    >>> in_q = Queue()\n    >>> q1, q2, q3 = multiplex(in_q, count=3)\n    \"\"\"\n    out_queues = [queue_factory() for _ in range(count)]\n\n    def f():\n        while True:\n            x = q.get()\n            for out_q in out_queues:\n                out_q.put(x)\n\n    t = Thread(target=f)\n    t.daemon = True\n    t.start()\n    return out_queues", "module": "pytutils.queues", "code": "from six.moves.queue import Queue\nfrom threading import Thread\n\ndef multiplex(q, count=2, queue_factory=lambda: Queue()):\n    \"\"\" Convert one queue into several. Kind of like a teeing queue.\n\n    >>> in_q = Queue()\n    >>> q1, q2, q3 = multiplex(in_q, count=3)\n    \"\"\"\n    out_queues = [queue_factory() for _ in range(count)]\n\n    def f():\n        while True:\n            x = q.get()\n            for out_q in out_queues:\n                out_q.put(x)\n\n    t = Thread(target=f)\n    t.daemon = True\n    t.start()\n    return out_queues", "entry_point": "multiplex", "test": "from six.moves.queue import Queue\nfrom threading import Thread\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.queues import * # noqa: autoimport\nfrom pytutils.queues import multiplex # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_22():\n    assert 5 == len(multiplex(Queue(), count=5))\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_24():\n    assert 2 == len(multiplex(Queue(), count=2))\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_27():\n    assert 2 == len(multiplex(Queue(maxsize=3), 2))\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_28():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+queues/multiplex/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(multiplex(Queue())) == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_22():\n    assert 5 == len(multiplex(Queue(), count=5))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_24():\n    assert 2 == len(multiplex(Queue(), count=2))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_27():\n    assert 2 == len(multiplex(Queue(maxsize=3), 2))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_28():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+queues/multiplex/test_28\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(multiplex(Queue())) == output"]}
{"problem_ids": 155, "project": "test-apps/pytutils", "focal_function": "def merge(*in_qs, **kwargs):\n    \"\"\" Merge multiple queues together\n\n    >>> q1, q2, q3 = [Queue() for _ in range(3)]\n    >>> out_q = merge(q1, q2, q3)\n    \"\"\"\n    out_q = Queue(**kwargs)\n    threads = [Thread(target=push, args=(q, out_q)) for q in in_qs]\n    for t in threads:\n        t.daemon = True\n        t.start()\n    return out_q", "module": "pytutils.queues", "code": "from six.moves.queue import Queue\nfrom threading import Thread\n\ndef push(in_q, out_q):\n\ndef merge(*in_qs, **kwargs):\n    \"\"\" Merge multiple queues together\n\n    >>> q1, q2, q3 = [Queue() for _ in range(3)]\n    >>> out_q = merge(q1, q2, q3)\n    \"\"\"\n    out_q = Queue(**kwargs)\n    threads = [Thread(target=push, args=(q, out_q)) for q in in_qs]\n    for t in threads:\n        t.daemon = True\n        t.start()\n    return out_q", "entry_point": "merge", "test": "from six.moves.queue import Queue\nfrom threading import Thread\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.queues import * # noqa: autoimport\nfrom pytutils.queues import merge # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_15():\n    assert 0 == merge(Queue(), Queue(), Queue()).qsize()\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_14():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+queues/merge/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert merge(Queue(maxsize=100), Queue(maxsize=100)).qsize() == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_18():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+queues/merge/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert merge(Queue(maxsize=1000), Queue(maxsize=1000), maxsize=1000).qsize() == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_15():\n    assert 0 == merge(Queue(), Queue(), Queue()).qsize()", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_14():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+queues/merge/test_14\", \"rb\") as f:\n        output = pickle.load(f)\n    assert merge(Queue(maxsize=100), Queue(maxsize=100)).qsize() == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_18():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+queues/merge/test_18\", \"rb\") as f:\n        output = pickle.load(f)\n    assert merge(Queue(maxsize=1000), Queue(maxsize=1000), maxsize=1000).qsize() == output"]}
{"problem_ids": 156, "project": "test-apps/pytutils", "focal_function": "def parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../yeee'),\n             ('THISIS', '.../a/test'),\n             ('YOLO',\n              '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n\n    \"\"\"\n    for line in lines:\n        m1 = re.match(r'\\A([A-Za-z_0-9]+)=(.*)\\Z', line)\n\n        if m1:\n            key, val = m1.group(1), m1.group(2)\n\n            m2 = re.match(r\"\\A'(.*)'\\Z\", val)\n            if m2:\n                val = m2.group(1)\n\n            m3 = re.match(r'\\A\"(.*)\"\\Z', val)\n            if m3:\n                val = re.sub(r'\\\\(.)', r'\\1', m3.group(1))\n\n            yield key, val", "module": "pytutils.env", "code": "import collections\nimport os\nimport re\nimport typing\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../yeee'),\n             ('THISIS', '.../a/test'),\n             ('YOLO',\n              '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n\n    \"\"\"\n    for line in lines:\n        m1 = re.match(r'\\A([A-Za-z_0-9]+)=(.*)\\Z', line)\n\n        if m1:\n            key, val = m1.group(1), m1.group(2)\n\n            m2 = re.match(r\"\\A'(.*)'\\Z\", val)\n            if m2:\n                val = m2.group(1)\n\n            m3 = re.match(r'\\A\"(.*)\"\\Z', val)\n            if m3:\n                val = re.sub(r'\\\\(.)', r'\\1', m3.group(1))\n\n            yield key, val", "entry_point": "parse_env_file_contents", "test": "import collections\nimport os\nimport re\nimport typing\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.env import * # noqa: autoimport\nfrom pytutils.env import parse_env_file_contents # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert dict(parse_env_file_contents([\"TEST=hi\", \"TEST=hi2\"])) == {\"TEST\":\"hi2\"}\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert dict(parse_env_file_contents(['TEST=$TEST1', 'TEST1=123', 'TEST=456'])) == {'TEST': '456', 'TEST1': '123'}\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert dict(parse_env_file_contents(['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST'])) != {'TEST': '${HOME}/yeee', 'THISIS': '~/a/test', 'YOLO': '~/swaggins/'}\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert collections.OrderedDict(parse_env_file_contents([\"TEST=${HOME}/yeee\", \"THISIS=~/a/test\", \"YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST\"])) == collections.OrderedDict([('TEST', '${HOME}/yeee'), ('THISIS', '~/a/test'), ('YOLO', '~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    assert dict(parse_env_file_contents(['TEST=123', 'TEST2=456'])) == {'TEST': '123', 'TEST2': '456'}\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert dict(parse_env_file_contents(['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST'])) == {'YOLO': '~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST', 'TEST': '${HOME}/yeee', 'THISIS': '~/a/test'}\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/parse_env_file_contents/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert dict(parse_env_file_contents(['TEST=$TEST1', 'TEST1=$TEST2', 'TEST2=123', 'TEST1=', 'TEST2='])) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_9():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/parse_env_file_contents/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(parse_env_file_contents(['THISIS=~/a/test', 'TEST=a/b/c']))) == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert dict(parse_env_file_contents([\"TEST=hi\", \"TEST=hi2\"])) == {\"TEST\":\"hi2\"}", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    assert dict(parse_env_file_contents(['TEST=$TEST1', 'TEST1=123', 'TEST=456'])) == {'TEST': '456', 'TEST1': '123'}", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert dict(parse_env_file_contents(['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST'])) != {'TEST': '${HOME}/yeee', 'THISIS': '~/a/test', 'YOLO': '~/swaggins/'}", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert collections.OrderedDict(parse_env_file_contents([\"TEST=${HOME}/yeee\", \"THISIS=~/a/test\", \"YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST\"])) == collections.OrderedDict([('TEST', '${HOME}/yeee'), ('THISIS', '~/a/test'), ('YOLO', '~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_7():\n    assert dict(parse_env_file_contents(['TEST=123', 'TEST2=456'])) == {'TEST': '123', 'TEST2': '456'}", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_8():\n    assert dict(parse_env_file_contents(['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST'])) == {'YOLO': '~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST', 'TEST': '${HOME}/yeee', 'THISIS': '~/a/test'}", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/parse_env_file_contents/test_5\", \"rb\") as f:\n        output = pickle.load(f)\n    assert dict(parse_env_file_contents(['TEST=$TEST1', 'TEST1=$TEST2', 'TEST2=123', 'TEST1=', 'TEST2='])) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_9():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/parse_env_file_contents/test_9\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(list(parse_env_file_contents(['THISIS=~/a/test', 'TEST=a/b/c']))) == output"]}
{"problem_ids": 157, "project": "test-apps/pytutils", "focal_function": "def load_env_file(lines: typing.Iterable[str], write_environ: typing.MutableMapping = os.environ) -> collections.OrderedDict:\n    \"\"\"\n    Loads (and returns) an env file specified by `filename` into the mapping `environ`.\n\n    >>> lines = ['TEST=${HOME}/yeee-$PATH', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../.../yeee-...:...'),\n             ('THISIS', '.../a/test'),\n             ('YOLO',\n              '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n    \"\"\"\n    values = parse_env_file_contents(lines)\n\n    changes = collections.OrderedDict()\n\n    for k, v in values:\n        v = expand(v)\n\n        changes[k] = v\n\n        if write_environ is not None:\n            write_environ[k] = v\n\n    return changes", "module": "pytutils.env", "code": "import collections\nimport os\nimport re\nimport typing\n\ndef expand(val: str) -> str:\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n    From honcho.\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../yeee'),\n    ('THISIS', '.../a/test'),\n    ('YOLO',\n    '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n    \"\"\"\n\ndef load_env_file(lines: typing.Iterable[str], write_environ: typing.MutableMapping = os.environ) -> collections.OrderedDict:\n    \"\"\"\n    Loads (and returns) an env file specified by `filename` into the mapping `environ`.\n\n    >>> lines = ['TEST=${HOME}/yeee-$PATH', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../.../yeee-...:...'),\n             ('THISIS', '.../a/test'),\n             ('YOLO',\n              '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n    \"\"\"\n    values = parse_env_file_contents(lines)\n\n    changes = collections.OrderedDict()\n\n    for k, v in values:\n        v = expand(v)\n\n        changes[k] = v\n\n        if write_environ is not None:\n            write_environ[k] = v\n\n    return changes", "entry_point": "load_env_file", "test": "import collections\nimport os\nimport re\nimport typing\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.env import * # noqa: autoimport\nfrom pytutils.env import load_env_file # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/load_env_file/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert load_env_file(['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/load_env_file/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert load_env_file(['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/load_env_file/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(load_env_file(['TEST=${HOME}/yeee', 'TEST=${HOME}/yeee', 'TEST=4'])) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/load_env_file/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(load_env_file(lines=['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST'])) == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/load_env_file/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert load_env_file(['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/load_env_file/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert load_env_file(['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/load_env_file/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(load_env_file(['TEST=${HOME}/yeee', 'TEST=${HOME}/yeee', 'TEST=4'])) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+env/load_env_file/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert list(load_env_file(lines=['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST'])) == output"]}
{"problem_ids": 159, "project": "test-apps/pytutils", "focal_function": "def pf(arg, lexer=__PP_LEXER_PYTHON, formatter=__PP_FORMATTER):\n    \"\"\"\n    Pretty formats with coloring.\n\n    Works in iPython, but not bpython as it does not write directly to term\n    and decodes it instead.\n    \"\"\"\n    arg = _pprint.pformat(arg)\n\n    if not pygments:\n        return arg\n    return pygments.highlight(arg, lexer, formatter)", "module": "pytutils.pretty", "code": "import six\nimport sys\nimport warnings\nimport pprint as _pprint\nimport pygments\nimport pygments.styles\nimport pygments.formatters\nimport pygments.lexers\n\ntry:\n    \n    .styles\n    .formatters\n    .lexers\n    __PP_STYLE = pygments.styles.get_style_by_name('monokai')\n    __PP_FORMATTER = pygments.formatters.get_formatter_by_name('console16m', style=__PP_STYLE)\n    __PP_LEXER_PYTHON = pygments.lexers.get_lexer_by_name('python{}'.format(six.PY3 and '3' or ''))\nexcept ImportError:\n    warnings.warn('Could not import `pygments`. Disabling syntax highlighting I guess.')\n    pygments = False\n\npformat = pf\n\ndef pf(arg, lexer=__PP_LEXER_PYTHON, formatter=__PP_FORMATTER):\n    \"\"\"\n    Pretty formats with coloring.\n\n    Works in iPython, but not bpython as it does not write directly to term\n    and decodes it instead.\n    \"\"\"\n    arg = _pprint.pformat(arg)\n\n    if not pygments:\n        return arg\n    return pygments.highlight(arg, lexer, formatter)", "entry_point": "pf", "test": "import six\nimport sys\nimport warnings\nimport pprint as _pprint\ntry:\n    import pygments\n    import pygments.styles\n    import pygments.formatters\n    import pygments.lexers\n\n    __PP_STYLE = pygments.styles.get_style_by_name('monokai')\n    __PP_FORMATTER = pygments.formatters.get_formatter_by_name('console16m', style=__PP_STYLE)\n    __PP_LEXER_PYTHON = pygments.lexers.get_lexer_by_name('python{}'.format(six.PY3 and '3' or ''))\n\nexcept ImportError:\n    warnings.warn('Could not import `pygments`. Disabling syntax highlighting I guess.')\n    pygments = False\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.pretty import * # noqa: autoimport\nfrom pytutils.pretty import pf # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pf/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(pf([1.0j, 2.0j, 3.0j])) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pf/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(pf([1, 2])) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pf/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(pf(1)) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pf/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(pf([1, 2, 3, 4.0, 5.0, 6.0j])) == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pf/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(pf([1.0j, 2.0j, 3.0j])) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pf/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(pf([1, 2])) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pf/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(pf(1)) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pf/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(pf([1, 2, 3, 4.0, 5.0, 6.0j])) == output"]}
{"problem_ids": 160, "project": "test-apps/pytutils", "focal_function": "def pp(arg, lexer=__PP_LEXER_PYTHON, formatter=__PP_FORMATTER, outfile=sys.stdout):\n    \"\"\"\n    Pretty prints with coloring.\n\n    Works in iPython, but not bpython as it does not write directly to term\n    and decodes it instead.\n    \"\"\"\n    arg = _pprint.pformat(arg)\n\n    close = False\n    try:\n        if isinstance(outfile, six.string_types):\n            close = True\n            outfile = open(outfile, 'w')\n\n        if not pygments:\n            return arg\n            outfile.write(arg)\n        else:\n            pygments.highlight(arg, lexer, formatter, outfile)\n    finally:\n        if close:\n            outfile.close()", "module": "pytutils.pretty", "code": "import six\nimport sys\nimport warnings\nimport pprint as _pprint\nimport pygments\nimport pygments.styles\nimport pygments.formatters\nimport pygments.lexers\n\ntry:\n    \n    .styles\n    .formatters\n    .lexers\n    __PP_STYLE = pygments.styles.get_style_by_name('monokai')\n    __PP_FORMATTER = pygments.formatters.get_formatter_by_name('console16m', style=__PP_STYLE)\n    __PP_LEXER_PYTHON = pygments.lexers.get_lexer_by_name('python{}'.format(six.PY3 and '3' or ''))\nexcept ImportError:\n    warnings.warn('Could not import `pygments`. Disabling syntax highlighting I guess.')\n    pygments = False\n\npformat = pf\n\ndef pp(arg, lexer=__PP_LEXER_PYTHON, formatter=__PP_FORMATTER, outfile=sys.stdout):\n    \"\"\"\n    Pretty prints with coloring.\n\n    Works in iPython, but not bpython as it does not write directly to term\n    and decodes it instead.\n    \"\"\"\n    arg = _pprint.pformat(arg)\n\n    close = False\n    try:\n        if isinstance(outfile, six.string_types):\n            close = True\n            outfile = open(outfile, 'w')\n\n        if not pygments:\n            return arg\n            outfile.write(arg)\n        else:\n            pygments.highlight(arg, lexer, formatter, outfile)\n    finally:\n        if close:\n            outfile.close()", "entry_point": "pp", "test": "import six\nimport sys\nimport warnings\nimport pprint as _pprint\ntry:\n    import pygments\n    import pygments.styles\n    import pygments.formatters\n    import pygments.lexers\n\n    __PP_STYLE = pygments.styles.get_style_by_name('monokai')\n    __PP_FORMATTER = pygments.formatters.get_formatter_by_name('console16m', style=__PP_STYLE)\n    __PP_LEXER_PYTHON = pygments.lexers.get_lexer_by_name('python{}'.format(six.PY3 and '3' or ''))\n\nexcept ImportError:\n    warnings.warn('Could not import `pygments`. Disabling syntax highlighting I guess.')\n    pygments = False\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.pretty import * # noqa: autoimport\nfrom pytutils.pretty import pp # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pp/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert pp(42) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pp/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert pp(2) == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pp/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert pp(42) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+pretty/pp/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert pp(2) == output"]}
{"problem_ids": 163, "project": "test-apps/pytutils", "focal_function": "def tree():\n    \"\"\"Extremely simple one-lined tree based on defaultdict.\"\"\"\n    return collections.defaultdict(tree)", "module": "pytutils.trees", "code": "import collections\n\ndef tree():\n    \"\"\"Extremely simple one-lined tree based on defaultdict.\"\"\"\n    return collections.defaultdict(tree)", "entry_point": "tree", "test": "import collections\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.trees import * # noqa: autoimport\nfrom pytutils.trees import tree # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert isinstance(tree()['a'], dict)\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert isinstance(tree()[1], dict)\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+trees/tree/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(tree()[\"a\"][\"b\"][\"c\"][\"d\"][\"e\"]) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+trees/tree/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(tree()[1][2]) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+trees/tree/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(tree()['b']['q']['j']) == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    assert isinstance(tree()['a'], dict)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    assert isinstance(tree()[1], dict)", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+trees/tree/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(tree()[\"a\"][\"b\"][\"c\"][\"d\"][\"e\"]) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+trees/tree/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(tree()[1][2]) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+trees/tree/test_4\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(tree()['b']['q']['j']) == output"]}
{"problem_ids": 167, "project": "test-apps/pytutils", "focal_function": "def accumulate(iterable, func=operator.add):\n    \"\"\"\n    Iterate over running totals, ie [a,b,c,d] -> func( func( func(a, b), c), d) with each func result yielded.\n    Func is operator.add by default.\n\n    >>> list(accumulate([1,2,3,4,5]))\n    [1, 3, 6, 10, 15]\n    >>> list(accumulate([1,2,3,4,5], operator.mul))\n    [1, 2, 6, 24, 120]\n\n    :param iterable: Iterable\n    :param func: method (default=operator.add) to call for each pair of (last call result or first item, next item)\n    :return generator: Generator\n    \"\"\"\n    it = iter(iterable)\n    try:\n        total = next(it)\n    except StopIteration:\n        return\n    yield total\n    for element in it:\n        total = func(total, element)\n        yield total", "module": "pytutils.iters", "code": "import wrapt\nimport collections\nimport itertools\nimport operator\n\ndef accumulate(iterable, func=operator.add):\n    \"\"\"\n    Iterate over running totals, ie [a,b,c,d] -> func( func( func(a, b), c), d) with each func result yielded.\n    Func is operator.add by default.\n\n    >>> list(accumulate([1,2,3,4,5]))\n    [1, 3, 6, 10, 15]\n    >>> list(accumulate([1,2,3,4,5], operator.mul))\n    [1, 2, 6, 24, 120]\n\n    :param iterable: Iterable\n    :param func: method (default=operator.add) to call for each pair of (last call result or first item, next item)\n    :return generator: Generator\n    \"\"\"\n    it = iter(iterable)\n    try:\n        total = next(it)\n    except StopIteration:\n        return\n    yield total\n    for element in it:\n        total = func(total, element)\n        yield total", "entry_point": "accumulate", "test": "import wrapt\nimport collections\nimport itertools\nimport operator\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.iters import * # noqa: autoimport\nfrom pytutils.iters import accumulate # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert [1, 2, 6, 24, 120] == list(accumulate([1, 2, 3, 4, 5], operator.mul))\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert all([x == y for x,y in zip(list(accumulate([1,2,3,4,5], operator.mul)), [1, 2, 6, 24, 120])])\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert 1 == next(accumulate([1,2]))\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+iters/accumulate/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert next(accumulate(range(10000))) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+iters/accumulate/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(accumulate([1,2,3,4,5], operator.mul)) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+iters/accumulate/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert next(accumulate([1,2,3])) == output\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+iters/accumulate/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert next(accumulate([1,2,3,4,5], lambda a,b: a+b*b)) == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    assert [1, 2, 6, 24, 120] == list(accumulate([1, 2, 3, 4, 5], operator.mul))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_4():\n    assert all([x == y for x,y in zip(list(accumulate([1,2,3,4,5], operator.mul)), [1, 2, 6, 24, 120])])", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_5():\n    assert 1 == next(accumulate([1,2]))", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_0():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+iters/accumulate/test_0\", \"rb\") as f:\n        output = pickle.load(f)\n    assert next(accumulate(range(10000))) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_1():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+iters/accumulate/test_1\", \"rb\") as f:\n        output = pickle.load(f)\n    assert sum(accumulate([1,2,3,4,5], operator.mul)) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_3():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+iters/accumulate/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert next(accumulate([1,2,3])) == output", "@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_6():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+iters/accumulate/test_6\", \"rb\") as f:\n        output = pickle.load(f)\n    assert next(accumulate([1,2,3,4,5], lambda a,b: a+b*b)) == output"]}
{"problem_ids": 168, "project": "test-apps/pytutils", "focal_function": "def dedupe(f, instance, args, kwargs):\n    \"\"\"\n    Decorator to dedupe it's output iterable automatically.\n\n    :param f: Wrapped meth\n    :param instance: wrapt provided property for decorating hydrated class instances (unused)\n    :param args: Passthrough args\n    :param kwargs: Passthrough kwargs\n    :return decorator: Decorator method that ingests iterables and dedupes them iteratively.\n    \"\"\"\n    gen = f(*args, **kwargs)\n    return dedupe_iter(gen)", "module": "pytutils.iters", "code": "import wrapt\nimport collections\nimport itertools\nimport operator\n\ndef dedupe_iter(iterator, hashfunc=hash):\n    \"\"\"\"\n    Deduplicates an iterator iteratively using hashed values in a set.\n    Not exactly memory efficient because of that of course.\n    If you have a large dataset with high cardinality look at HyperLogLog instead.\n    :return generator: Iterator of deduplicated results.\n    \"\"\"\n\ndef dedupe(f, instance, args, kwargs):\n    \"\"\"\n    Decorator to dedupe it's output iterable automatically.\n\n    :param f: Wrapped meth\n    :param instance: wrapt provided property for decorating hydrated class instances (unused)\n    :param args: Passthrough args\n    :param kwargs: Passthrough kwargs\n    :return decorator: Decorator method that ingests iterables and dedupes them iteratively.\n    \"\"\"\n    gen = f(*args, **kwargs)\n    return dedupe_iter(gen)", "entry_point": "dedupe", "test": "import wrapt\nimport collections\nimport itertools\nimport operator\nimport sys\nsys.path.insert(1, \"/input/test-apps/pytutils\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\nfrom pytutils.iters import * # noqa: autoimport\nfrom pytutils.iters import dedupe # noqa: autoimport\n\nLOCAL_TIMEOUT = 5\n\n@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+iters/dedupe/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(dedupe([1, 1, 2, 2, 3, 3, 4, 4])) == output\n\n", "test_list": ["@timeout_decorator.timeout(LOCAL_TIMEOUT)\ndef test_2():\n    with open(\"/output/test-apps+pytutils/test_output/pytutils+iters/dedupe/test_2\", \"rb\") as f:\n        output = pickle.load(f)\n    assert len(dedupe([1, 1, 2, 2, 3, 3, 4, 4])) == output"]}
