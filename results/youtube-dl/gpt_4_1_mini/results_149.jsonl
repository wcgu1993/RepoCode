{"task_id": 149, "prediction_id": 0, "generation": "from youtube_dl.aes import mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on key size (expanded key length)\n    # 16-byte key -> 10 rounds, 24-byte key -> 12 rounds, 32-byte key -> 14 rounds\n    # expanded_key length is 176, 208 or 240 bytes respectively\n    Nr = (len(expanded_key) // 16) - 1\n\n    # Copy input data to state (list of 16 ints)\n    state = data[:]\n\n    # AddRoundKey - initial round key addition\n    for i in range(16):\n        state[i] ^= expanded_key[i]\n\n    # For rounds 1 to Nr-1 do the main rounds\n    for round_idx in range(1, Nr):\n        # SubBytes (using sub_bytes on state)\n        state = sub_bytes(state)\n\n        # ShiftRows (using shift_rows on state)\n        state = shift_rows(state)\n\n        # MixColumns\n        state = mix_columns(state)\n\n        # AddRoundKey\n        round_key_start = round_idx * 16\n        for i in range(16):\n            state[i] ^= expanded_key[round_key_start + i]\n\n    # Final round (Nr-th round) without MixColumns\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = Nr * 16\n    for i in range(16):\n        state[i] ^= expanded_key[round_key_start + i]\n\n    return state\n\n\n# The sub_bytes and shift_rows functions are needed here.\n# They should be defined or imported accordingly.\n# Since only aes_encrypt is requested and no imports from file content,\n# we provide implementations for sub_bytes and shift_rows below:\n\nS_BOX = [\n    # 256-element AES S-box\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n\n\ndef sub_bytes(state):\n    \"\"\"Apply the AES S-box substitution to each byte of the state.\"\"\"\n    return [S_BOX[b] for b in state]\n\n\ndef shift_rows(state):\n    \"\"\"\n    Shift rows in the AES state.\n    The state array is indexed as a 4x4 matrix in column-major order:\n    state = [s0, s1, s2, s3, ..., s15]\n    where columns (each of 4 bytes) are contiguous every 4 bytes:\n    index = row + 4 * column\n    Shift rows:\n     - row 0: no shift\n     - row 1: shift left by 1\n     - row 2: shift left by 2\n     - row 3: shift left by 3\n    \"\"\"\n    # Convert to 4x4 matrix (row-major for ease)\n    matrix = [[0]*4 for _ in range(4)]  # matrix[row][col]\n\n    for i in range(16):\n        row = i % 4\n        col = i // 4\n        matrix[row][col] = state[i]\n\n    # Shift rows\n    for r in range(1, 4):\n        matrix[r] = matrix[r][r:] + matrix[r][:r]\n\n    # Convert back to state (column-major)\n    new_state = [0]*16\n    for r in range(4):\n        for c in range(4):\n            new_state[c*4 + r] = matrix[r][c]\n\n    return new_state", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 535, in <module>\n  File \"<string>\", line 534, in test_1\nAssertionError\n", "passed": false}
{"task_id": 149, "prediction_id": 1, "generation": "from youtube_dl.aes import mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of 32-bit words comprising the cipher key\n    key_len = len(expanded_key)\n    if key_len == 176:  # 16 bytes key => 10 rounds + 1 initial key addition\n        rounds = 10\n    elif key_len == 208:  # 24 bytes key => 12 rounds + 1 initial key addition\n        rounds = 12\n    elif key_len == 240:  # 32 bytes key => 14 rounds + 1 initial key addition\n        rounds = 14\n    else:\n        raise ValueError(\"Invalid expanded_key length\")\n\n    state = data[:]\n\n    # Initial AddRoundKey\n    for i in range(16):\n        state[i] ^= expanded_key[i]\n\n    # Each round is 16 bytes = 4 words\n    # Helper to get the key slice for a round\n    def round_key(r):\n        start = 16 * r\n        return expanded_key[start:start + 16]\n\n    for r in range(1, rounds):\n        # SubBytes\n        state = sub_bytes(state)\n\n        # ShiftRows\n        state = shift_rows(state)\n\n        # MixColumns\n        state = mix_columns(state)\n\n        # AddRoundKey\n        rk = round_key(r)\n        for i in range(16):\n            state[i] ^= rk[i]\n\n    # Last round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    rk = round_key(rounds)\n    for i in range(16):\n        state[i] ^= rk[i]\n\n    return state\n\n\n# Helper functions needed for aes_encrypt (based on AES standard and typical implementations)\n# These are not provided in the context, but are essential.\n# Implementations follow the typical AES specification.\n\n\n# The S-box used by AES (256 values)\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n\n\ndef sub_bytes(state):\n    \"\"\"Substitute each byte in the state using the AES S-box\"\"\"\n    return [SBOX[b] for b in state]\n\n\ndef shift_rows(state):\n    \"\"\"Shift rows for AES state; input/output are 16-byte lists\"\"\"\n    # State is in row-major order: state[row + 4 * col]\n    # ShiftRows shifts bytes at rows:\n    # Row 0: no shift\n    # Row 1: shift left by 1\n    # Row 2: shift left by 2\n    # Row 3: shift left by 3\n\n    # Convert to 4x4 matrix (row-major)\n    matrix = [state[i*4:(i+1)*4] for i in range(4)]\n\n    for r in range(1, 4):\n        matrix[r] = matrix[r][r:] + matrix[r][:r]\n\n    # Flatten back to list\n    return [matrix[i][j] for i in range(4) for j in range(4)]", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 518, in <module>\n  File \"<string>\", line 517, in test_42\n  File \"<string>\", line 193, in aes_encrypt\nValueError: Invalid expanded_key length\n", "passed": false}
{"task_id": 149, "prediction_id": 2, "generation": "from youtube_dl.aes import mix_columns\n\n\n# S-box for SubBytes step\nSBOX = [\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n]\n\n# RCON for AddRoundKey in Key Expansion, not needed here but included for completeness\n\ndef sub_bytes(state):\n    \"\"\"\n    Perform SubBytes step of AES:\n    Substitute each byte in state using the SBOX.\n    \"\"\"\n    return [SBOX[b] for b in state]\n\ndef shift_rows(state):\n    \"\"\"\n    Perform ShiftRows step of AES on a 16-byte state (list)\n    The state is arranged as a 4x4 matrix in column-major order:\n    state[pos] where pos = row + 4 * column\n\n    Shift rows as:\n    Row 0: no shift\n    Row 1: shift left by 1\n    Row 2: shift left by 2\n    Row 3: shift left by 3\n    \"\"\"\n    rows = [state[i::4] for i in range(4)]  # extract rows\n\n    # Apply shifts\n    rows[1] = rows[1][1:] + rows[1][:1]\n    rows[2] = rows[2][2:] + rows[2][:2]\n    rows[3] = rows[3][3:] + rows[3][:3]\n\n    # Rebuild state in column-major order\n    shifted = []\n    for col in range(4):\n        for row in range(4):\n            shifted.append(rows[row][col])\n    return shifted\n\ndef add_round_key(state, round_key):\n    \"\"\"\n    XOR state with round key (both 16 bytes)\n    \"\"\"\n    return [s ^ k for s, k in zip(state, round_key)]\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on key size:\n    # Expanded key size: 176, 208, 240 bytes\n    # For 16-byte key: 10 rounds -> expanded key 176 bytes (16 * (10+1))\n    # For 24-byte key: 12 rounds -> expanded key 208 bytes\n    # For 32-byte key: 14 rounds -> expanded key 240 bytes\n    # Calculate number of rounds:\n    key_size_bytes = (len(expanded_key) // 16) - 1\n\n    # Initial round key addition\n    state = add_round_key(data, expanded_key[0:16])\n\n    # Rounds 1 to N-1\n    for round in range(1, key_size_bytes):\n        # SubBytes\n        state = sub_bytes(state)\n        # ShiftRows\n        state = shift_rows(state)\n        # MixColumns\n        state = mix_columns(state)\n        # AddRoundKey\n        round_key_start = round * 16\n        round_key_end = round_key_start + 16\n        state = add_round_key(state, expanded_key[round_key_start:round_key_end])\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = key_size_bytes * 16\n    round_key_end = round_key_start + 16\n    state = add_round_key(state, expanded_key[round_key_start:round_key_end])\n\n    return state", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 527, in <module>\n  File \"<string>\", line 526, in test_1\nAssertionError\n", "passed": false}
{"task_id": 149, "prediction_id": 3, "generation": "from youtube_dl.aes import rijndael_mul, mix_column, mix_columns\n\n# Constants used in AES\nSBOX = [\n    # 256-byte S-box table for SubBytes step\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n]\n\n# MixColumns matrix for AES encryption\nMIX_COLUMN_MATRIX = [\n    [2, 3, 1, 1],\n    [1, 2, 3, 1],\n    [1, 1, 2, 3],\n    [3, 1, 1, 2]\n]\n\ndef sub_bytes(state):\n    \"\"\"\n    Apply S-box substitution to each byte in the state.\n    :param state: List[int] - 16-byte state\n    :return: List[int] - substituted state\n    \"\"\"\n    return [SBOX[b] for b in state]\n\n\ndef shift_rows(state):\n    \"\"\"\n    Perform the ShiftRows step on the state.\n    State is a list of 16 bytes arranged column-wise:\n    state[0..3]  = first column\n    state[4..7]  = second column\n    etc.\n\n    ShiftRows operates on the rows of the state (which in column-major is scattered),\n    so for proper row operations, the state is easiest to view as a 4x4 matrix\n    arranged column-wise, i.e., state arranged as:\n    [\n      state[0],  state[4],  state[8],  state[12],\n      state[1],  state[5],  state[9],  state[13],\n      state[2],  state[6],  state[10], state[14],\n      state[3],  state[7],  state[11], state[15]\n    ]\n    \n    But standard AES assumes state is arranged row-wise. Here we must carefully shift rows.\n    \n    The simplest way is to represent state as a 4x4 matrix row-wise,\n    then perform shift rows, and then flattened column-wise\n    \n    With column-major storage:\n      bytes:\n        c0: s0 s1 s2 s3   -> indices 0 1 2 3\n        c1: s4 s5 s6 s7   -> indices 4 5 6 7\n        c2: s8 s9 s10 s11 -> indices 8 9 10 11\n        c3: s12 s13 s14 s15 -> indices 12 13 14 15\n        \n    But the file content and AES standard use column-major order:\n    State matrix is:\n       [[state[0], state[4], state[8],  state[12]],\n        [state[1], state[5], state[9],  state[13]],\n        [state[2], state[6], state[10], state[14]],\n        [state[3], state[7], state[11], state[15]]]\n        \n    For ShiftRows, rows rotate left by their row index:\n    Row 0: no shift\n    Row 1: shift left by 1\n    Row 2: shift left by 2\n    Row 3: shift left by 3\n\n    We'll convert to 4x4 row-wise matrix, shift, then convert back col-wise.\n    \"\"\"\n    # Convert to row-wise 4x4 matrix\n    matrix = [[0]*4 for _ in range(4)]\n    for r in range(4):\n        for c in range(4):\n            matrix[r][c] = state[c*4 + r]\n\n    # Shift rows\n    for r in range(1, 4):\n        matrix[r] = matrix[r][r:] + matrix[r][:r]\n\n    # Convert back column-wise\n    shifted = [0]*16\n    for r in range(4):\n        for c in range(4):\n            shifted[c*4 + r] = matrix[r][c]\n\n    return shifted\n\n\ndef add_round_key(state, round_key):\n    \"\"\"\n    XOR the state with the round key.\n    \n    :param state: List[int] 16 bytes\n    :param round_key: List[int] 16 bytes\n    :return: List[int] 16 bytes\n    \"\"\"\n    return [b ^ k for b, k in zip(state, round_key)]\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on key length:\n    # Expanded key lengths:\n    # 176 bytes -> 10 rounds (AES-128)\n    # 208 bytes -> 12 rounds (AES-192)\n    # 240 bytes -> 14 rounds (AES-256)\n    expanded_key_len = len(expanded_key)\n    if expanded_key_len == 176:\n        rounds = 10\n    elif expanded_key_len == 208:\n        rounds = 12\n    elif expanded_key_len == 240:\n        rounds = 14\n    else:\n        raise ValueError(\"Invalid expanded key length\")\n\n    state = data[:]\n\n    # Initial round key addition\n    state = add_round_key(state, expanded_key[:16])\n\n    # Main rounds\n    for round_idx in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state, MIX_COLUMN_MATRIX)\n        round_key = expanded_key[round_idx * 16 : (round_idx + 1) * 16]\n        state = add_round_key(state, round_key)\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key = expanded_key[rounds * 16 : (rounds + 1) * 16]\n    state = add_round_key(state, round_key)\n\n    return state", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 569, in <module>\n  File \"<string>\", line 568, in test_42\n  File \"<string>\", line 325, in aes_encrypt\nValueError: Invalid expanded key length\n", "passed": false}
{"task_id": 149, "prediction_id": 4, "generation": "from youtube_dl.aes import mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on the expanded key size:\n    # For 16-byte key: 10 rounds, for 24-byte: 12 rounds, for 32-byte: 14 rounds\n    # expanded_key size = (Nr + 1) * 16, so:\n    key_len = len(expanded_key)\n    round_count = {176: 10, 208: 12, 240: 14}[key_len]\n\n    state = data[:]  # Copy input state\n\n    # Helper functions\n    def sub_bytes(s):\n        # Applies S-box substitution to each byte of the state\n        return [S_BOX[b] for b in s]\n\n    def shift_rows(s):\n        # Shift rows according to AES specification\n        # State is represented as a flat list of 16 bytes, column-major order:\n        # Indices:\n        #  0  4  8 12\n        #  1  5  9 13\n        #  2  6 10 14\n        #  3  7 11 15\n        # Shift rows:\n        # Row 0: no shift\n        # Row 1: shift left by 1\n        # Row 2: shift left by 2\n        # Row 3: shift left by 3\n        s2 = s[:]\n        # Row 1:\n        s2[1], s2[5], s2[9], s2[13] = s[5], s[9], s[13], s[1]\n        # Row 2:\n        s2[2], s2[6], s2[10], s2[14] = s[10], s[14], s[2], s[6]\n        # Row 3:\n        s2[3], s2[7], s2[11], s2[15] = s[15], s[3], s[7], s[11]\n        return s2\n\n    def add_round_key(s, rk):\n        # XOR the state with round key rk (16 bytes)\n        return [a ^ b for a, b in zip(s, rk)]\n\n    # S-box used in AES\n    S_BOX = [\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,\n    ]\n\n    # Initial AddRoundKey (round 0)\n    state = add_round_key(state, expanded_key[0:16])\n\n    # Rounds 1 to Nr-1\n    for round_i in range(1, round_count):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, expanded_key[round_i * 16:(round_i + 1) * 16])\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, expanded_key[round_count * 16:(round_count + 1) * 16])\n\n    return state", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 497, in <module>\n  File \"<string>\", line 496, in test_42\n  File \"<string>\", line 188, in aes_encrypt\nKeyError: 16\n", "passed": false}
