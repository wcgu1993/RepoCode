{"task_id": 152, "prediction_id": 0, "generation": "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    result = []\n    segments = boot_info.get('segments', [])\n    fragments_groups = boot_info.get('fragments', [])\n\n    # According to abst structure, segments and fragments lists correspond\n    # segments is a list of dicts with a 'segment_run' key with list of tuples\n    # fragments_groups is a list of dicts with a 'fragments' key with list of dicts\n\n    # Iterate over each segment group and corresponding fragment group\n    for segment_group, fragment_group in zip(segments, fragments_groups):\n        segment_runs = segment_group.get('segment_run', [])\n        fragments = fragment_group.get('fragments', [])\n\n        # For each segment run, get the first segment number and number of fragments for that segment\n        for (first_segment, fragments_per_segment) in segment_runs:\n            # We assume fragments are in order and map them accordingly\n            for i in range(fragments_per_segment):\n                idx = first_segment - 1 + i  # segment and fragment indices are 1-based\n                # Defensive check on index range\n                if 0 <= idx < len(fragments):\n                    fragment = fragments[idx]\n                    result.append(((first_segment + i), fragment))\n\n    return result", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 497, in <module>\n  File \"<string>\", line 496, in test_6\nAssertionError\n", "passed": false}
{"task_id": 152, "prediction_id": 1, "generation": "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    segments = boot_info.get('segments', [])\n    fragments = boot_info.get('fragments', [])\n\n    # The structure of boot_info has 'segments' as a list of segments,\n    # each segment being a dict with a 'segment_run' key,\n    # which is a list of tuples (first_segment, fragments_per_segment).\n    # 'fragments' is a list of fragment runs; each run contains a list of fragment dicts.\n\n    # We assume that segments and fragments runs correspond in order,\n    # and we want to pair each fragment with the originating segment it belongs to.\n\n    # Iterate matching segment runs with fragment runs\n    # For each segment run in segments, get its segment runs list\n    # For each fragment run in fragments, get its fragments list\n    # Then, for each (first_segment, fragments_per_segment) in segment_run,\n    # associate the corresponding fragments in order.\n\n    fragment_index = 0  # index in the flattened fragments list\n\n    for segment in segments:\n        segment_runs = segment.get('segment_run', [])\n        for first_segment, fragments_per_segment in segment_runs:\n            # For each fragment in this segment run\n            for _ in range(fragments_per_segment):\n                # Look for the fragment at fragment_index in all fragments runs concatenated\n                # According to the bootstrap structure, fragments is a list of dicts each having 'fragments' list\n                # Flatten the fragments runs to a list (done below), then index into it\n                # But we do it here lazily collecting fragments first\n\n                # We'll first flatten all fragments runs for easy lookup\n                pass\n\n    # Flatten fragments runs into a single list of fragment dicts\n    all_fragments = []\n    for frag_run in fragments:\n        frag_list = frag_run.get('fragments', [])\n        all_fragments.extend(frag_list)\n\n    fragment_index = 0\n    for segment in segments:\n        segment_runs = segment.get('segment_run', [])\n        for first_segment, fragments_per_segment in segment_runs:\n            for _ in range(fragments_per_segment):\n                if fragment_index >= len(all_fragments):\n                    # Defensive: if fragments are shorter than expected, stop\n                    break\n                fragment = all_fragments[fragment_index]\n                fragments_list.append((segment, fragment))\n                fragment_index += 1\n\n    return fragments_list", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 525, in <module>\n  File \"<string>\", line 524, in test_6\nAssertionError\n", "passed": false}
{"task_id": 152, "prediction_id": 2, "generation": "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    # We will collect tuples of (segment_dict, fragment_dict)\n    result = []\n\n    # segments is a list of dict, each dict contains a 'segment_run' key\n    # that stores list of tuples (first_segment, fragments_per_segment)\n    # fragments_runs is a list of dict, each dict contains 'fragments',\n    # a list of fragment dicts\n\n    # We iterate over segments and fragments_runs by corresponding indices.\n    # Each segment corresponds to a segments_run (list of tuples (first_segment, fragments_per_segment))\n    # and each fragments_run contains a list of fragments.\n\n    for segment, fragments_run in zip(segments, fragments_runs):\n        segment_runs = segment.get('segment_run', [])\n        fragments = fragments_run.get('fragments', [])\n\n        # We will iterate over each segment run, and for each run,\n        # iterate through the fragments that belong to that run.\n        # The fragments in fragments_run correspond sequentially to these runs.\n\n        # Index in fragments list:\n        frag_idx = 0\n\n        for first_segment, fragments_per_segment in segment_runs:\n            # For each fragment in this segment run, add tuple to result\n            for _ in range(fragments_per_segment):\n                if frag_idx >= len(fragments):\n                    # Defensive: if fragments fewer than expected, break early\n                    break\n                fragment = fragments[frag_idx]\n                # Append tuple of segment_run info + fragment info as requested:\n                # Note: segment_run info is (first_segment, fragments_per_segment),\n                # but we need to return (segment, fragment). Since segment is a dict\n                # and fragment is a dict, provide the segment dict that contains this run.\n                # The \"segment\" in result presumably means the segment dict from boot_info['segments']\n                # The fragment is one fragment dict from fragments list.\n                result.append((segment, fragment))\n                frag_idx += 1\n\n    return result", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 516, in <module>\n  File \"<string>\", line 515, in test_6\nAssertionError\n", "passed": false}
{"task_id": 152, "prediction_id": 3, "generation": "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_groups = boot_info.get('fragments', [])\n\n    fragments_list = []\n    # segments is a list of dicts with \"segment_run\" key, the segment run is a list of tuples (first_segment, fragments_per_segment)\n    # fragments_groups is a list of dicts with \"fragments\" key, which is a list of fragment dicts with keys 'first', 'ts', 'duration', 'discontinuity_indicator'\n    # We want to return list of (segment, fragment) tuples for each fragment\n\n    # Iterate over corresponding segments and fragments groups by index\n    for segment, fragments_group in zip(segments, fragments_groups):\n        fragment_entries = fragments_group.get('fragments', [])\n        segment_run = segment.get('segment_run', [])\n\n        # For each tuple in segment_run (first_segment, fragments_per_segment) we should map fragments accordingly\n        # The fragments from fragment_entries are arranged to correspond to entries in segment_run sequence with given counts\n\n        idx = 0\n        for first_segment, fragments_per_segment in segment_run:\n            for i in range(fragments_per_segment):\n                if idx >= len(fragment_entries):\n                    break\n                fragment = fragment_entries[idx]\n                # yield the current segment dict and the current fragment dict\n                fragments_list.append((segment, fragment))\n                idx += 1\n\n    return fragments_list", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 500, in <module>\n  File \"<string>\", line 499, in test_6\nAssertionError\n", "passed": false}
{"task_id": 152, "prediction_id": 4, "generation": "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    # Segments is a list of dicts with 'segment_run' which is a list of tuples:\n    # (first_segment, fragments_per_segment) describing segments with fragment counts.\n    # fragments_runs is a list of dicts with 'fragments' list describing fragments.\n\n    # According to the bootstrap structure:\n    # segments: list of dicts each with \"segment_run\": list of (first_segment, fragments_per_segment)\n    # fragments: list of dicts each with \"fragments\": list of fragment dicts\n\n    # We need to pair each segment number with each fragment.\n    # The segments and fragments are structured often in sequence.\n\n    # It appears segments and fragments_runs correspond index-wise,\n    # i.e. segments[i] relates to fragments_runs[i]\n    # Each segment defines a series of segment_run tuples (first segments and counts),\n    # each fragments_run contains fragments with info about those fragments.\n\n    # Build a combined list of (segment number, fragment) for all fragments.\n\n    fragment_index = 0\n    for seg_idx, (segment_info, fragment_run) in enumerate(zip(segments, fragments_runs)):\n        segment_run = segment_info.get('segment_run', [])\n        fragments = fragment_run.get('fragments', [])\n\n        # Each segment_run entry: (first_segment, fragments_per_segment)\n        # The fragments correspond to these segments sequentially.\n\n        frag_cursor = 0\n        for first_segment, fragments_per_segment in segment_run:\n            # For each segment in this run, from first_segment up to count\n            for seg_number in range(first_segment, first_segment + fragments_per_segment):\n                if frag_cursor >= len(fragments):\n                    # Defensive: no more fragments to assign\n                    break\n                fragments_list.append((seg_number, fragments[frag_cursor]))\n                frag_cursor += 1\n\n    return fragments_list", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 514, in <module>\n  File \"<string>\", line 513, in test_6\nAssertionError\n", "passed": false}
