{"task_id": 147, "prediction_id": 0, "generation": "from math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: Add N bytes each of value N, where N is the number of padding bytes needed\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [pad_len] * pad_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        xor_block = xor(block, previous_cipher_block)\n\n        cipher_block = aes_encrypt(xor_block, expanded_key)\n\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 111, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 147, "prediction_id": 1, "generation": "from math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [pad_len] * pad_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR with previous ciphertext block (or IV for first block)\n        xored_block = xor(block, previous_cipher_block)\n        # Encrypt the xored block\n        cipher_block = aes_encrypt(xored_block, expanded_key)\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 111, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 147, "prediction_id": 2, "generation": "from math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # Apply PKCS#7 padding\n    padding_length = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = data[:] + [padding_length] * padding_length\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR with previous ciphertext block (or IV for first)\n        block = xor(block, previous_cipher_block)\n        # Encrypt the block\n        cipher_block = aes_encrypt(block, expanded_key)\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 111, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 147, "prediction_id": 3, "generation": "from math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(padded_data)) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv[:]\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR plaintext block with previous cipher block (or IV for the first block)\n        xored_block = xor(block, previous_cipher_block)\n        # Encrypt the xored_block\n        cipher_block = aes_encrypt(xored_block, expanded_key)\n        encrypted_data += cipher_block\n        previous_cipher_block = cipher_block\n\n    return encrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 111, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 147, "prediction_id": 4, "generation": "from math import ceil\nfrom .aes import key_expansion, aes_encrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: add N bytes of value N to fill block size\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = data[:] + [pad_len] * pad_len\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES : (i + 1) * BLOCK_SIZE_BYTES]\n        block = xor(block, previous_cipher_block)\n\n        encrypted_block = aes_encrypt(block, expanded_key)\n        encrypted_data += encrypted_block\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 111, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
