{"task_id": 146, "prediction_id": 0, "generation": "from math import ceil\nfrom .aes import aes_decrypt, key_expansion\nfrom .utils import xor\nfrom .compat import compat_b64decode\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # If last block might be incomplete, pad it for aes_decrypt to avoid errors\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR decrypted block with previous ciphertext block (or IV for first block)\n        plaintext_block = xor(decrypted_block, previous_cipher_block)\n\n        decrypted_data += plaintext_block\n        previous_cipher_block = block\n\n    # Remove PKCS#7 padding from the decrypted data\n    if decrypted_data:\n        padding_len = decrypted_data[-1]\n        if 1 <= padding_len <= BLOCK_SIZE_BYTES:\n            # Verify padding validity\n            if decrypted_data[-padding_len:] == [padding_len] * padding_len:\n                decrypted_data = decrypted_data[:-padding_len]\n\n    return decrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 85, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 146, "prediction_id": 1, "generation": "from math import ceil\nfrom .aes import key_expansion, aes_decrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Decrypt the current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with the previous ciphertext block (or IV for first block)\n        plain_block = xor(decrypted_block, previous_cipher_block)\n        decrypted_data += plain_block\n        previous_cipher_block = block\n\n    decrypted_data = decrypted_data[:len(data)]\n    return decrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 85, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 146, "prediction_id": 2, "generation": "from math import ceil\nfrom youtube_dl.aes import key_expansion, aes_decrypt\nfrom .utils import xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Decrypt current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with previous cipher block (or IV for first block) to get plaintext block\n        plaintext_block = xor(decrypted_block, previous_cipher_block)\n        decrypted_data += plaintext_block\n        # Update previous cipher block to current ciphertext block\n        previous_cipher_block = block\n\n    # Remove PKCS#7 padding\n    if not decrypted_data:\n        return decrypted_data\n    padding_len = decrypted_data[-1]\n    if padding_len < 1 or padding_len > BLOCK_SIZE_BYTES:\n        # Invalid padding, return full decrypted_data\n        return decrypted_data\n    if decrypted_data[-padding_len:] != [padding_len] * padding_len:\n        # Invalid padding, return full decrypted_data\n        return decrypted_data\n\n    return decrypted_data[:-padding_len]", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 86, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 146, "prediction_id": 3, "generation": "from math import ceil\nfrom youtube_dl.aes import key_expansion, aes_decrypt, xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Decrypt current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with previous cipher block (or IV for first block)\n        plain_block = xor(decrypted_block, previous_block)\n        decrypted_data += plain_block\n        # Current cipher block becomes previous for next iteration\n        previous_block = block\n\n    # Remove PKCS#7 padding if present\n    if decrypted_data:\n        padding_len = decrypted_data[-1]\n        if 1 <= padding_len <= BLOCK_SIZE_BYTES and all(\n            decrypted_data[-i] == padding_len for i in range(1, padding_len + 1)\n        ):\n            decrypted_data = decrypted_data[:-padding_len]\n\n    return decrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 437, in <module>\n  File \"<string>\", line 430, in test_5\n  File \"<string>\", line 107, in aes_cbc_decrypt\n  File \"<string>\", line 223, in aes_decrypt\n  File \"<string>\", line 408, in shift_rows_inv\nIndexError: list index out of range\n", "passed": false}
{"task_id": 146, "prediction_id": 4, "generation": "from math import ceil\n\nfrom youtube_dl.aes import key_expansion, aes_decrypt, xor\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # If block less than 16 bytes (shouldn't normally happen), pad with zeros to decrypt safely\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        plain_block = xor(decrypted_block, previous_cipher_block)\n\n        decrypted_data += plain_block\n        previous_cipher_block = block\n\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data", "message": "passed", "passed": true}
