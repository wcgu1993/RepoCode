{"task_id": 152, "prediction_id": 0, "generation": "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_groups = boot_info.get('fragments', [])\n    result = []\n    for segment, fragments_group in zip(segments, fragments_groups):\n        # segment_run is a list of (first_segment, fragments_per_segment)\n        segment_run = segment.get('segment_run', [])\n        for (first_segment, fragments_per_segment) in segment_run:\n            # For each segment_run entry, take the corresponding fragments\n            for i in range(fragments_per_segment):\n                fragment_index = first_segment + i - 1  # segments start counting from 1\n                # Check bounds and fetch the fragment from fragments_group\n                if 0 <= fragment_index < len(fragments_group):\n                    fragment = fragments_group[fragment_index]\n                    result.append((segment, fragment))\n    return result", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 488, in <module>\n  File \"<string>\", line 487, in test_6\n  File \"<string>\", line 249, in build_fragments_list\nKeyError: 0\n", "passed": false}
{"task_id": 152, "prediction_id": 1, "generation": "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    result = []\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    for seg_idx, segment in enumerate(segments):\n        # segment_run is list of tuples (first_segment, fragments_per_segment)\n        segment_runs = segment.get('segment_run', [])\n        for fr_idx, fragments_data in enumerate(fragments_runs):\n            # Each fragments_data is a dict with a 'fragments' key (list of fragment dicts)\n            fragments = fragments_data.get('fragments', [])\n\n            # For each segment_run tuple in this segment, find fragments belonging to it.\n            for first_segment, fragments_per_segment in segment_runs:\n                # Select fragments that belong to this segment run\n                # The fragment's 'first' index should be within the segment range:\n                seg_start = first_segment\n                seg_end = first_segment + fragments_per_segment\n                # Collect matching fragments among fragments list (from fragments_data)\n                matched_fragments = [\n                    fragment\n                    for fragment in fragments\n                    if seg_start <= fragment.get('first', 0) < seg_end\n                ]\n                for fragment in matched_fragments:\n                    result.append((segment, fragment))\n\n    return result", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 500, in <module>\n  File \"<string>\", line 499, in test_6\nAssertionError\n", "passed": false}
{"task_id": 152, "prediction_id": 2, "generation": "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    fragments_list = []\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    # segments is a list of dicts with key 'segment_run' which is a list of (first_segment, fragments_per_segment)\n    # fragments_runs is a list of dicts with key 'fragments' which is a list of fragment dicts with 'first' integer\n\n    # We need to map each fragment to a segment.\n    # The segments list is a list of segments where each segment contains a 'segment_run' list of tuples:\n    # (first_segment_number, fragments_per_segment)\n    # The fragments list is a list of fragments runs, each with a 'fragments' list that has fragment dicts with 'first' fields (fragment number).\n\n    # We will enumerate segments and their runs to get segment index and fragment numbering.\n    # The segment_run entries give us the segment number and how many fragments it contains.\n\n    # Create a list indexed by segment number mapping to segment index in segments\n    # Actually, segments is a list of segment dicts; but each segment has multiple runs.\n    # We will combine all segment runs across segments, keeping track of which segment they belong to.\n\n    # For each segments[i] (segment), for each (first_segment, fragments_per_segment) in segment_run:\n    # We'll build a mapping of segment number to (segments index i, run index, first_segment, fragments_per_segment)\n    # Then when iterating fragments, find which segment run they belong to.\n\n    # However, the segments list itself is a list of dicts with 'segment_run' list, so it is a structure for grouping, but\n    # The fragment numbers are aligned globally.\n\n    # We'll construct a sorted list of (segment_number, segment_index, run_index, fragments_per_segment)\n    segment_run_info = []\n    for segment_index, segment in enumerate(segments):\n        for run_index, (first_segment, fragments_per_segment) in enumerate(segment['segment_run']):\n            segment_run_info.append((first_segment, segment_index, run_index, fragments_per_segment))\n\n    # Sort by first_segment\n    segment_run_info.sort(key=lambda x: x[0])\n\n    # Now iterate fragments runs and their fragments with fragment number (first)\n    # For each fragment, find which segment run it belongs to by comparing fragment number with segment_run intervals\n    # We build a list of intervals: each run covers fragment indices from first_segment to first_segment + fragments_per_segment -1\n\n    # We'll use segment_run_info and map fragment numbers to segment runs\n    # If no segment run is found, assign None\n\n    for fragments_run_index, fragments_run in enumerate(fragments_runs):\n        for fragment in fragments_run['fragments']:\n            fragment_number = fragment['first']\n\n            # Find segment run for this fragment_number\n            seg_index = None\n            run_index = None\n            for (first_segment, segment_index, run_idx, fragments_per_segment) in segment_run_info:\n                if first_segment <= fragment_number < first_segment + fragments_per_segment:\n                    seg_index = segment_index\n                    run_index = run_idx\n                    break\n\n            segment = segments[seg_index] if seg_index is not None else None\n            fragments_list.append((segment, fragment))\n\n    return fragments_list", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 532, in <module>\n  File \"<string>\", line 531, in test_6\nAssertionError\n", "passed": false}
{"task_id": 152, "prediction_id": 3, "generation": "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    result = []\n\n    for segment, fragments_run in zip(segments, fragments_runs):\n        # Each segment contains 'segment_run' list of tuples (first_segment, fragments_per_segment)\n        segment_runs = segment.get('segment_run', [])\n        \n        for first_segment, fragments_per_segment in segment_runs:\n            # fragment indices relative to the first fragment in this segment_run\n            for i in range(fragments_per_segment):\n                # Compute the fragment index relative to the fragments_run fragments list\n                fragment_index = i\n                if fragment_index < len(fragments_run['fragments']):\n                    fragment = fragments_run['fragments'][fragment_index]\n                    # Append tuple (segment, fragment) as requested\n                    result.append((segment, fragment))\n\n    return result", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 493, in <module>\n  File \"<string>\", line 492, in test_6\nAssertionError\n", "passed": false}
{"task_id": 152, "prediction_id": 4, "generation": "def build_fragments_list(boot_info):\n    \"\"\" Return a list of (segment, fragment) for each fragment in the video \"\"\"\n    segments = boot_info.get('segments', [])\n    fragments_runs = boot_info.get('fragments', [])\n\n    result = []\n    # Each segment corresponds to an entry in segments list.\n    # Each fragments run corresponds to an entry in fragments list.\n    # The fragments_runs list contains one or more fragment runs.\n    # As per read_abst, segments and fragments runs are separate lists.\n    #\n    # The boot_info does not explicitly link segments to fragments,\n    # but from the context, fragments_runs correspond to fragments runs for all segments.\n    #\n    # The data structure from read_asrt()\n    # 'segment_run': [(first_segment, fragments_per_segment), ...]\n    #\n    # Actually boot_info['segments'] is a list of dict with 'segment_run': list of tuples.\n    # Each segment dict like: {'segment_run': [(first_segment, fragments_per_segment), ...]}\n    #\n    # So we need to iterate through each Segment's segment_run entries and\n    # map fragments accordingly.\n    #\n    # For each segment_run entry in segments (segment_run is a list of tuples):\n    # first_segment: starting segment number\n    # fragments_per_segment: number of fragments in that segment\n    #\n    # fragments_runs is a list (from read_abst) of fragment runs,\n    # each fragment run dict has a 'fragments' list (from read_afrt),\n    # each fragment is a dict with keys including 'first' (fragment number), 'ts', 'duration', etc.\n    #\n    # We want to flatten this into a list of (segment, fragment) tuples,\n    # where segment is first_segment + segment index offset,\n    # fragment is the fragment dict from fragments_runs.\n    #\n    # But the official code uses a single segment (elements on boot_info['segments']) and multiple fragment runs;\n    # each fragment run contains fragment dicts.\n    #\n    # We assume a 1:1 mapping of segments to fragment runs by index.\n    #\n    # Because boot_info['segments'] is a list of dicts (each with segment_run list),\n    # and boot_info['fragments'] is list of dicts (each with 'fragments' list),\n    # we can do parallel iteration.\n    #\n    # We'll iterate over segments and fragments_runs by index and build the list.\n\n    for seg_idx, segment in enumerate(segments):\n        segment_runs = segment.get('segment_run', [])\n        # The corresponding fragments run for this segment (assuming matching index)\n        if seg_idx >= len(fragments_runs):\n            break\n        fragments_run = fragments_runs[seg_idx]\n        fragments = fragments_run.get('fragments', [])\n\n        # For each segment run in this segment:\n        # segment_run: list of tuples (first_segment, fragments_per_segment)\n        # The fragments list contains fragments numbered sequentially.\n        # We need to map each fragment to the correct segment,\n        # incrementing segment number as appropriate.\n\n        frag_index = 0\n        for first_segment, fragments_per_segment in segment_runs:\n            for i in range(fragments_per_segment):\n                if frag_index >= len(fragments):\n                    break\n                segment_num = first_segment + i\n                fragment = fragments[frag_index]\n                result.append((segment_num, fragment))\n                frag_index += 1\n\n    return result", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 542, in <module>\n  File \"<string>\", line 541, in test_6\nAssertionError\n", "passed": false}
