{"task_id": 147, "prediction_id": 0, "generation": "from math import ceil\n\nfrom youtube_dl.aes import key_expansion, aes_encrypt, xor\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: padding length = block_size - (len(data) % block_size)\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR plaintext block with previous cipher block (or IV for first block)\n        xor_block = xor(block, previous_cipher_block)\n\n        # Encrypt the XORed block\n        cipher_block = aes_encrypt(xor_block, expanded_key)\n\n        encrypted_data.extend(cipher_block)\n        previous_cipher_block = cipher_block\n\n    return encrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 442, in <module>\n  File \"<string>\", line 441, in test_38\nAssertionError\n", "passed": false}
{"task_id": 147, "prediction_id": 1, "generation": "from math import ceil\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding: pad to multiple of BLOCK_SIZE_BYTES\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    # If data is already a multiple of BLOCK_SIZE_BYTES, add a full block of padding\n    if padding_len == 0:\n        padding_len = BLOCK_SIZE_BYTES\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    prev_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES : (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR plaintext block with previous ciphertext (or IV for first block)\n        xor_block = xor(block, prev_block)\n        # Encrypt the block\n        encrypted_block = aes_encrypt(xor_block, expanded_key)\n        encrypted_data += encrypted_block\n        prev_block = encrypted_block\n\n    return encrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 440, in <module>\n  File \"<string>\", line 439, in test_38\nAssertionError\n", "passed": false}
{"task_id": 147, "prediction_id": 2, "generation": "from math import ceil\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # Apply PKCS#7 padding\n    padding_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [padding_len] * padding_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Ensure block is exactly BLOCK_SIZE_BYTES (should be guaranteed by padding)\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [padding_len] * (BLOCK_SIZE_BYTES - len(block))\n\n        # XOR plaintext block with previous ciphertext (or IV for first block)\n        xored_block = xor(block, previous_block)\n        # Encrypt the XORed block\n        encrypted_block = aes_encrypt(xored_block, expanded_key)\n        encrypted_data += encrypted_block\n        # Update previous_block for next iteration\n        previous_block = encrypted_block\n\n    return encrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 442, in <module>\n  File \"<string>\", line 441, in test_38\nAssertionError\n", "passed": false}
{"task_id": 147, "prediction_id": 3, "generation": "from math import ceil\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion, BLOCK_SIZE_BYTES\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # PKCS#7 padding\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padded_data = data + [pad_len] * pad_len\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_cipher_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # XOR with previous cipher block (or IV for first block)\n        block_to_encrypt = xor(block, previous_cipher_block)\n        encrypted_block = aes_encrypt(block_to_encrypt, expanded_key)\n        encrypted_data += encrypted_block\n        previous_cipher_block = encrypted_block\n\n    return encrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 433, in <module>\n  File \"<string>\", line 432, in test_38\nAssertionError\n", "passed": false}
{"task_id": 147, "prediction_id": 4, "generation": "from math import ceil\n\nfrom youtube_dl.aes import xor, aes_encrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n    # Apply PKCS#7 padding to make data length multiple of BLOCK_SIZE_BYTES\n    pad_len = BLOCK_SIZE_BYTES - (len(data) % BLOCK_SIZE_BYTES)\n    padding = [pad_len] * pad_len\n    padded_data = data + padding\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(len(padded_data) / BLOCK_SIZE_BYTES))\n\n    encrypted_data = []\n    previous_block = iv\n    for i in range(block_count):\n        block = padded_data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n\n        # XOR plaintext block with previous cipher block (or IV for first block)\n        xored_block = xor(block, previous_block)\n\n        # Encrypt this xored block\n        encrypted_block = aes_encrypt(xored_block, expanded_key)\n\n        encrypted_data += encrypted_block\n        previous_block = encrypted_block\n\n    return encrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 441, in <module>\n  File \"<string>\", line 440, in test_38\nAssertionError\n", "passed": false}
