{"task_id": 148, "prediction_id": 0, "generation": "from youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # The length of the key determines Nk (4,6,8), number of 32-bit words comprising the key.\n    key_size = len(data)\n    if key_size == 16:\n        Nk = 4\n        Nr = 10\n    elif key_size == 24:\n        Nk = 6\n        Nr = 12\n    elif key_size == 32:\n        Nk = 8\n        Nr = 14\n    else:\n        raise ValueError(\"Invalid key size. Must be 16, 24 or 32 bytes.\")\n\n    expanded_key = data[:]\n    i = Nk\n    # Each word is 4 bytes\n    while len(expanded_key) < 4 * (Nr + 1) * 4:  # Total expanded key length in bytes\n        temp = expanded_key[-4:]\n        if i % Nk == 0:\n            temp = key_schedule_core(temp, i // Nk - 1)\n        elif Nk > 6 and i % Nk == 4:\n            # For 256-bit keys, extra sub_bytes applied\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR with word Nk positions before\n        for j in range(4):\n            temp[j] ^= expanded_key[-4 * Nk + j]\n\n        expanded_key += temp\n        i += 1\n\n    return expanded_key[:4 * (Nr + 1) * 4]", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 436, in <module>\n  File \"<string>\", line 435, in test_36\n  File \"<string>\", line 159, in key_expansion\nValueError: Invalid key size. Must be 16, 24 or 32 bytes.\n", "passed": false}
{"task_id": 148, "prediction_id": 1, "generation": "from youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key must be 16, 24 or 32 bytes long\")\n\n    # Number of 4-byte words in the key\n    Nk = key_size // 4\n    # Number of rounds depends on key size\n    Nr = {4:10, 6:12, 8:14}[Nk]\n    Nb = 4  # block size in words\n\n    expanded_key = list(data)\n    i = Nk\n    rcon_iteration = 1\n\n    while len(expanded_key) < Nb * (Nr + 1) * 4:\n        temp = expanded_key[-4:]\n\n        if i % Nk == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        elif Nk > 6 and i % Nk == 4:\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR temp with the [i-Nk]th 4-byte word\n        for j in range(4):\n            temp[j] ^= expanded_key[-Nk*4 + j]\n        expanded_key.extend(temp)\n        i += 1\n\n    return expanded_key", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 433, in <module>\n  File \"<string>\", line 432, in test_36\n  File \"<string>\", line 149, in key_expansion\nValueError: Key must be 16, 24 or 32 bytes long\n", "passed": false}
{"task_id": 148, "prediction_id": 2, "generation": "from youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Invalid key size: must be 16, 24 or 32 bytes\")\n\n    # Number of 32-bit words comprising the key\n    Nk = key_size // 4\n    # Number of 32-bit words in the expanded key\n    Nb = 4\n    Nr = {4:10, 6:12, 8:14}[Nk]  # Number of rounds\n    expanded_key_size = Nb * (Nr + 1) * 4  # bytes\n\n    expanded_key = list(data)\n    rcon_iteration = 1\n\n    while len(expanded_key) < expanded_key_size:\n        t = expanded_key[-4:]  # last 4 bytes\n\n        if len(expanded_key) % (Nk * 4) == 0:\n            t = key_schedule_core(t, rcon_iteration)\n            rcon_iteration += 1\n        elif Nk > 6 and (len(expanded_key) % (Nk * 4) == 16):\n            # For 256-bit keys, extra sub_bytes at certain step\n            from youtube_dl.aes import sub_bytes\n            t = sub_bytes(t)\n\n        prev_bytes = expanded_key[-Nk*4 : -Nk*4 + 4]\n        t = xor(t, prev_bytes)\n        expanded_key.extend(t)\n\n    return expanded_key", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 432, in <module>\n  File \"<string>\", line 431, in test_36\n  File \"<string>\", line 149, in key_expansion\nValueError: Invalid key size: must be 16, 24 or 32 bytes\n", "passed": false}
{"task_id": 148, "prediction_id": 3, "generation": "from youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    # Length of original key determines number of rounds and key size\n    key_size = len(data)  # 16 / 24 / 32\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    # Determine the number of 4-byte words in the key\n    n_k = key_size // 4\n    # Determine the total number of 4-byte words in expanded key (Nb = 4 words per block, Nr depends on key size)\n    if key_size == 16:\n        n_r = 10\n    elif key_size == 24:\n        n_r = 12\n    else:  # key_size == 32\n        n_r = 14\n    n_w = 4 * (n_r + 1)  # total 4-byte words of key schedule\n\n    # The expanded keys array (list of ints)\n    expanded_key = list(data)\n    i = n_k\n\n    while i < n_w * 4:\n        # Get the previous 4-byte word\n        t = expanded_key[i - 4:i]\n\n        if i % n_k == 0:\n            t = key_schedule_core(t, i // n_k - 1)\n        elif n_k > 6 and i % n_k == 4:\n            # For 256-bit keys, extra sub_bytes step every 4th word\n            from youtube_dl.aes import sub_bytes\n            t = sub_bytes(t)\n\n        # XOR with the word n_k positions before\n        prev_word = expanded_key[i - n_k * 4: i - (n_k - 1) * 4]\n        # prev_word is 4 bytes, t is 4 bytes - perform xor element-wise\n        t = xor(t, prev_word)\n\n        expanded_key.extend(t)\n        i += 4\n\n    return expanded_key", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 430, in <module>\n  File \"<string>\", line 429, in test_2\n  File \"<string>\", line 172, in key_expansion\n  File \"<string>\", line 359, in key_schedule_core\nIndexError: tuple index out of range\n", "passed": false}
{"task_id": 148, "prediction_id": 4, "generation": "from youtube_dl.aes import key_schedule_core, xor\n\ndef key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n    key_size = len(data)\n    if key_size not in (16, 24, 32):\n        raise ValueError(\"Key length must be 16, 24, or 32 bytes\")\n\n    # The expanded key length depends on the key size:\n    # 16 bytes key -> 176 bytes expanded key (11 * 16)\n    # 24 bytes key -> 208 bytes expanded key (13 * 16)\n    # 32 bytes key -> 240 bytes expanded key (15 * 16)\n    expanded_key_size = {16: 176, 24: 208, 32: 240}[key_size]\n    expanded_key = data[:]  # start with original key bytes\n\n    rcon_iteration = 1\n    while len(expanded_key) < expanded_key_size:\n        # Take the last 4 bytes\n        temp = expanded_key[-4:]\n\n        if len(expanded_key) % key_size == 0:\n            temp = key_schedule_core(temp, rcon_iteration)\n            rcon_iteration += 1\n        elif key_size == 32 and (len(expanded_key) % key_size) == 16:\n            # For 32-byte keys, perform sub_bytes on temp every 16 bytes\n            from youtube_dl.aes import sub_bytes\n            temp = sub_bytes(temp)\n\n        # XOR temp with 4 bytes block key_size bytes before\n        block_to_xor = expanded_key[-key_size:]\n        for i in range(4):\n            temp[i] ^= block_to_xor[i]\n\n        expanded_key += temp\n\n    return expanded_key[:expanded_key_size]", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 434, in <module>\n  File \"<string>\", line 433, in test_36\n  File \"<string>\", line 149, in key_expansion\nValueError: Key length must be 16, 24, or 32 bytes\n", "passed": false}
