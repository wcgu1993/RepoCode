{"task_id": 146, "prediction_id": 0, "generation": "from math import ceil\n\nfrom youtube_dl.aes import xor, aes_decrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    if len(iv) != BLOCK_SIZE_BYTES:\n        raise ValueError(\"IV must be 16 bytes long\")\n\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        start = i * BLOCK_SIZE_BYTES\n        end = start + BLOCK_SIZE_BYTES\n        block = data[start:end]\n        # Pad block with zeros if incomplete block (should not normally happen if ciphertext is padded)\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR decrypted plaintext block with previous ciphertext block (or IV for first block)\n        plain_block = xor(decrypted_block, previous_block)\n\n        decrypted_data += plain_block\n\n        previous_block = block  # current ciphertext block becomes next iteration's 'previous_block'\n\n    # Trim to original data length (in case last block was padded)\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 443, in <module>\n  File \"<string>\", line 436, in test_5\n  File \"<string>\", line 101, in aes_cbc_decrypt\nValueError: IV must be 16 bytes long\n", "passed": false}
{"task_id": 146, "prediction_id": 1, "generation": "from youtube_dl.aes import xor, aes_decrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = (len(data) + BLOCK_SIZE_BYTES - 1) // BLOCK_SIZE_BYTES\n\n    decrypted_data = []\n    prev_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # pad block with zeros if not full block (usually ciphertext length is multiple of block size,\n        # but just to be safe and consistent with the aes_ctr_decrypt approach)\n        if len(block) < BLOCK_SIZE_BYTES:\n            block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        # XOR with previous ciphertext block or iv to get plaintext block\n        plaintext_block = xor(decrypted_block, prev_block)\n        decrypted_data += plaintext_block\n\n        prev_block = block\n\n    # truncate to original data length in case of padding in last block\n    return decrypted_data[:len(data)]", "message": "passed", "passed": true}
{"task_id": 146, "prediction_id": 2, "generation": "from youtube_dl.aes import xor, aes_decrypt, key_expansion\nfrom math import ceil\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    prev_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # If block is shorter than BLOCK_SIZE_BYTES, pad with zeros (should be rare in CBC decryption)\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        # Decrypt the current block\n        decrypted_block = aes_decrypt(block, expanded_key)\n\n        # XOR with previous ciphertext block (or IV for first block)\n        plain_block = xor(decrypted_block, prev_block)\n\n        decrypted_data += plain_block\n\n        # Update prev_block to current ciphertext block\n        prev_block = block\n\n    # Truncate plaintext to original data length\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data", "message": "passed", "passed": true}
{"task_id": 146, "prediction_id": 3, "generation": "from youtube_dl.aes import xor, aes_decrypt, key_expansion\nfrom math import ceil\n\nBLOCK_SIZE_BYTES = 16\n\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Pad incomplete block with zeros if necessary\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        plaintext_block = xor(decrypted_block, previous_block)\n\n        decrypted_data += plaintext_block\n        previous_block = block\n\n    decrypted_data = decrypted_data[:len(data)]\n\n    return decrypted_data", "message": "passed", "passed": true}
{"task_id": 146, "prediction_id": 4, "generation": "from math import ceil\nfrom youtube_dl.aes import xor, aes_decrypt, key_expansion\n\nBLOCK_SIZE_BYTES = 16\n\ndef aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n    expanded_key = key_expansion(key)\n    block_count = int(ceil(float(len(data)) / BLOCK_SIZE_BYTES))\n\n    decrypted_data = []\n    previous_block = iv\n\n    for i in range(block_count):\n        block = data[i * BLOCK_SIZE_BYTES: (i + 1) * BLOCK_SIZE_BYTES]\n        # Pad incomplete blocks with zeros (if any)\n        block += [0] * (BLOCK_SIZE_BYTES - len(block))\n\n        decrypted_block = aes_decrypt(block, expanded_key)\n        plain_block = xor(decrypted_block, previous_block)\n        decrypted_data += plain_block\n        previous_block = block\n\n    # Trim to original data length\n    return decrypted_data[:len(data)]", "message": "passed", "passed": true}
