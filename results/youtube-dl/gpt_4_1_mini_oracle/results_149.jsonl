{"task_id": 149, "prediction_id": 0, "generation": "from youtube_dl.aes import xor, sub_bytes, shift_rows, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of 4-byte words in the key (Nk) and the number of rounds (Nr) depends on expanded_key length:\n    # Expanded key length: 176 bytes -> 11 rounds (AES-128)\n    #                      208 bytes -> 13 rounds (AES-192)\n    #                      240 bytes -> 15 rounds (AES-256)\n    # key schedule words: expanded_key length / 4\n    # rounds = (key_schedule_words / 4) - 1\n    key_schedule_words = len(expanded_key) // 4\n    rounds = key_schedule_words // 4 - 1\n\n    state = data[:]\n\n    # Initial AddRoundKey (round 0)\n    round_key = expanded_key[0:16]\n    state = xor(state, round_key)\n\n    # Rounds 1 to Nr - 1\n    for round in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        round_key = expanded_key[round * 16 : (round + 1) * 16]\n        state = xor(state, round_key)\n\n    # Final round (without mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key = expanded_key[rounds * 16 : (rounds + 1) * 16]\n    state = xor(state, round_key)\n\n    return state", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 447, in <module>\n  File \"<string>\", line 446, in test_1\nAssertionError\n", "passed": false}
{"task_id": 149, "prediction_id": 1, "generation": "from youtube_dl.aes import xor, sub_bytes, shift_rows, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # Number of rounds depends on expanded_key length:\n    # 16-byte key -> 10 rounds (AES-128)\n    # 24-byte key -> 12 rounds (AES-192)\n    # 32-byte key -> 14 rounds (AES-256)\n    # expanded_key size:\n    #   176 bytes = 11 round keys * 16 bytes \u2192 10 rounds\n    #   208 bytes = 13 round keys * 16 bytes \u2192 12 rounds\n    #   240 bytes = 15 round keys * 16 bytes \u2192 14 rounds\n    \n    # Calculate rounds count:\n    round_key_count = len(expanded_key) // 16\n    rounds = round_key_count - 1  # rounds count (Nr), round keys = Nr + 1\n\n    state = data[:]\n\n    def get_round_key(round):\n        start = round * 16\n        end = start + 16\n        return expanded_key[start:end]\n\n    # Initial AddRoundKey\n    state = xor(state, get_round_key(0))\n\n    # Nr-1 rounds: SubBytes, ShiftRows, MixColumns, AddRoundKey\n    for round in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = xor(state, get_round_key(round))\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = xor(state, get_round_key(rounds))\n\n    return state", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 453, in <module>\n  File \"<string>\", line 452, in test_1\nAssertionError\n", "passed": false}
{"task_id": 149, "prediction_id": 2, "generation": "from youtube_dl.aes import xor, shift_rows, sub_bytes, mix_columns\n\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    state = data[:]\n    key_size_bytes = len(expanded_key) * 4 // 44  # Approximate key size by expanded key length\n    # Actually expanded_key sizes:\n    # 16 bytes key -> 176 bytes expanded key (11 rounds)\n    # 24 bytes key -> 208 bytes expanded key (13 rounds)\n    # 32 bytes key -> 240 bytes expanded key (15 rounds)\n    # Number of rounds:\n    rounds = {176: 10, 208: 12, 240: 14}[len(expanded_key)]\n\n    # Initial round key addition\n    state = xor(state, expanded_key[:16])\n\n    # Rounds 1 to rounds-1\n    for round_idx in range(1, rounds):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        round_key_start = round_idx * 16\n        state = xor(state, expanded_key[round_key_start:round_key_start + 16])\n\n    # Final round (no mix_columns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = rounds * 16\n    state = xor(state, expanded_key[round_key_start:round_key_start + 16])\n\n    return state", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 433, in <module>\n  File \"<string>\", line 432, in test_42\n  File \"<string>\", line 191, in aes_encrypt\nKeyError: 16\n", "passed": false}
{"task_id": 149, "prediction_id": 3, "generation": "from youtube_dl.aes import xor, shift_rows, sub_bytes, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    # AES parameters derived from expanded_key length (key size in words)\n    # Number of rounds = Nk + 6, where Nk is key length in 32-bit words (4 bytes each)\n    # expanded_key size in bytes: 176 (AES-128: Nk=4), 208 (AES-192: Nk=6), 240 (AES-256: Nk=8)\n    if len(expanded_key) == 176:\n        rounds = 10\n    elif len(expanded_key) == 208:\n        rounds = 12\n    elif len(expanded_key) == 240:\n        rounds = 14\n    else:\n        raise ValueError(\"Expanded key has invalid length\")\n\n    # Start with initial round key addition (AddRoundKey)\n    state = xor(data, expanded_key[:16])\n\n    # Perform main rounds\n    for round_idx in range(1, rounds):\n        # SubBytes step\n        state = sub_bytes(state)\n        # ShiftRows step\n        state = shift_rows(state)\n        # MixColumns step\n        state = mix_columns(state)\n        # AddRoundKey step\n        round_key_start = round_idx * 16\n        round_key_end = round_key_start + 16\n        state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = rounds * 16\n    round_key_end = round_key_start + 16\n    state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    return state", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 441, in <module>\n  File \"<string>\", line 440, in test_42\n  File \"<string>\", line 193, in aes_encrypt\nValueError: Expanded key has invalid length\n", "passed": false}
{"task_id": 149, "prediction_id": 4, "generation": "from .aes import xor, sub_bytes, shift_rows, mix_columns\n\ndef aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n    state = data[:]  # copy\n    key_size_bytes = len(expanded_key) * 16 // 176 if len(expanded_key) in (176, 208, 240) else 16\n    # Determine Nk and Nr based on key length\n    # Nk = number of 4-byte words in key\n    # Nr = number of rounds\n    Nk = key_size_bytes // 4\n    if Nk == 4:\n        Nr = 10\n    elif Nk == 6:\n        Nr = 12\n    elif Nk == 8:\n        Nr = 14\n    else:\n        # fallback to standard AES-128 rounds if unknown, though the provided expanded_key sizes align with those three\n        Nr = 10\n\n    # Initial round key addition\n    state = xor(state, expanded_key[0:16])\n\n    for round in range(1, Nr):\n        # SubBytes\n        state = sub_bytes(state)\n        # ShiftRows\n        state = shift_rows(state)\n        # MixColumns\n        state = mix_columns(state)\n        # AddRoundKey\n        round_key_start = round * 16\n        round_key_end = round_key_start + 16\n        state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    # Final round (no MixColumns)\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    round_key_start = Nr * 16\n    round_key_end = round_key_start + 16\n    state = xor(state, expanded_key[round_key_start:round_key_end])\n\n    return state", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 173, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
