{"task_id": 315, "prediction_id": 0, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\n\nfrom pypara.dcc import _construct_date, _get_actual_day_count\n\n\ndef dcfc_act_act_icma(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    if not start <= asof <= end:\n        # Outside the interval, return zero fraction\n        return Decimal(0)\n\n    # Frequency (payments per year) is required for the Act/Act (ICMA) convention.\n    # If freq is None, treat as annual (1)\n    freq_val = int(freq) if freq is not None else 1\n    # The coupon period in months\n    months_per_period = 12 // freq_val\n\n    # Determine the next notional coupon date relative to start at EOM or non-EOM\n    # Step 1: Determine if start is last day of month (EOM)\n    eom = start.day == (datetime.date(start.year, start.month,\n                                     28) + datetime.timedelta(days=4)).day and _construct_date(start.year, start.month + 1 if start.month < 12 else 1,\n                                                                                                 1) - datetime.timedelta(days=1) == start \\\n        if start.month < 12 else _is_last_day_of_month(start)\n\n    # More simply we can use the context function _is_last_day_of_month:\n    from pypara.dcc import _is_last_day_of_month\n    eom_flag = _is_last_day_of_month(start)\n\n    # Determine next coupon date from start:\n    # Use _next_payment_date logic inline:\n    def next_coupon_date(start_date, freq_, eom_=None):\n        from dateutil.relativedelta import relativedelta\n        months = int(12 / freq_)\n        nextdate = start_date + relativedelta(months=months)\n        if eom_:\n            try:\n                nextdate = nextdate.replace(day=eom_)\n            except ValueError:\n                # If matching day doesn't exist, use last day of month\n                nextdate = nextdate.replace(day=calendar.monthrange(nextdate.year, nextdate.month)[1])\n        return nextdate\n\n    # If eom_flag True, use day of month's last day for next coupon day else use start.day:\n    day_for_next_coupon = start.day\n    if eom_flag:\n        day_for_next_coupon = calendar.monthrange(start.year, start.month)[1]\n\n    next_coupon = next_coupon_date(start, freq_val, day_for_next_coupon)\n\n    # If next_coupon after end, next_coupon = end\n    if next_coupon > end:\n        next_coupon = end\n\n    # The previous coupon date is start (by definition the start of this accrual period)\n    prev_coupon = start\n\n    # Handle edge case: if asof == end and end==next_coupon, fraction is 1\n    if asof == end and next_coupon == end:\n        return Decimal(\"1\")\n\n    # Calculate the elapsed days between prev_coupon and asof\n    elapsed = _get_actual_day_count(prev_coupon, asof)\n    # Calculate the total days between prev_coupon and next_coupon\n    period_length = _get_actual_day_count(prev_coupon, next_coupon)\n\n    if period_length == 0:\n        # Avoid division by zero if dates coincide\n        return Decimal(0)\n\n    # return fraction as elapsed / period_length with Decimal division\n    return Decimal(elapsed) / Decimal(period_length)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 463\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 315, "prediction_id": 1, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\n\nfrom pypara.commons.numbers import isum\nfrom pypara.dcc import _get_actual_day_count, _construct_date\n\n\ndef dcfc_act_act_icma(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    # The Act/Act (ICMA) day count fraction is computed as:\n    # sum of actual days in each coupon period divided by the length in days of that coupon period.\n    #\n    # For the given period (start to end), payments occur at frequency freq (e.g., annual=1, semi=2, quarterly=4).\n    # We determine coupon period boundaries from start date using frequency.\n    # Then sum the fractional parts from start to asof date.\n\n    if freq is None:\n        raise ValueError(\"Frequency (freq) must be provided for Act/Act (ICMA) calculation\")\n\n    freq_int = int(freq)\n    if freq_int <= 0:\n        raise ValueError(\"Frequency must be a positive integer\")\n\n    # Helper: Build schedule of coupon payment dates from start to end\n    # going forward (start <= dates <= end)\n    def generate_coupon_schedule(start_date: datetime.date, end_date: datetime.date, frequency: int):\n        schedule = [start_date]\n        months_per_period = int(12 / frequency)\n        next_date = start_date\n        while next_date < end_date:\n            # Move forward by coupon period months:\n            next_date = next_date + datetime.timedelta(days=1)  # to avoid infinite loop if period=0\n            next_date = _construct_date(next_date.year, next_date.month, next_date.day)  # safe construction\n            # Instead reliably add coupon months via relativedelta:\n            from dateutil.relativedelta import relativedelta\n            next_coupon = schedule[-1] + relativedelta(months=months_per_period)\n\n            if next_coupon > end_date:\n                break\n            schedule.append(next_coupon)\n        if schedule[-1] != end_date:\n            schedule.append(end_date)\n        return schedule\n\n    # Instead of the above complex generator, use stable approach:\n\n    from dateutil.relativedelta import relativedelta\n\n    months_per_period = int(12 / freq_int)\n    # Build full coupon schedule from start till end (including end)\n    coupon_dates = [start]\n    current_date = start\n    while current_date < end:\n        current_date = current_date + relativedelta(months=months_per_period)\n        if current_date > end:\n            current_date = end\n        coupon_dates.append(current_date)\n    # Ensure unique and sorted\n    coupon_dates = sorted(set(coupon_dates))\n\n    # Compute day count fraction as sum over each segment [period_start, period_end)\n    # where for the last segment period_end might be end date.\n    # For the partial last sub-period, fraction is actual days in [period_start, asof) / actual days in [period_start, period_end)\n    #\n    # We identify which interval asof lies in.\n\n    total_fraction = Decimal(0)\n\n    # Iterate over coupon periods:\n    for i in range(len(coupon_dates) - 1):\n        period_start = coupon_dates[i]\n        period_end = coupon_dates[i + 1]\n\n        if asof <= period_start:\n            # asof before or at this coupon period start => fraction no more accrual:\n            break\n\n        if asof >= period_end:\n            # whole coupon period accrued\n            numerator = Decimal(_get_actual_day_count(period_start, period_end))\n        else:\n            # partial coupon period accrued\n            numerator = Decimal(_get_actual_day_count(period_start, asof))\n\n        denominator = Decimal(_get_actual_day_count(period_start, period_end))\n\n        # Protect against zero denominator (should not happen if schedule well formed)\n        if denominator == 0:\n            fraction = Decimal(0)\n        else:\n            fraction = numerator / denominator\n\n        total_fraction += fraction\n\n        # Stop if asof is inside this period (partial accrual)\n        if asof < period_end:\n            break\n\n    return total_fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 463\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 315, "prediction_id": 2, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\n\nfrom pypara.commons.numbers import isum\nfrom pypara.dcc import (\n    _construct_date,\n    _get_actual_day_count,\n)\n\nfrom pypara.commons.zeitgeist import Date\n\n\ndef dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n\n    # If frequency is not provided, assume annual payments = 1\n    if freq is None:\n        freq = Decimal(1)\n\n    freq_int = int(freq)\n\n    # For ICMA Act/Act, the fraction is calculated as (number of coupons passed including current coupon part - 1) + fraction of current coupon\n    # Typically, coupons are paid every (12 / freq) months.\n    # We'll work with coupon schedule dates from start, find previous and next coupon dates for 'asof', then calculate fraction accordingly.\n\n    # Step 1: Compute coupon period in months\n    months_per_period = int(12 / freq_int)\n\n    # Step 2: Define a function to generate coupon dates schedule from start until after end\n    def generate_coupon_schedule(start_date: Date, end_date: Date):\n        # yield all coupon dates from start_date every months_per_period months until beyond end_date\n        coupon_date = start_date\n        while coupon_date <= end_date:\n            yield coupon_date\n            # add months_per_period months\n            try:\n                # Try to keep the day same, but adjust if overflow\n                new_month = coupon_date.month + months_per_period\n                new_year = coupon_date.year + (new_month - 1) // 12\n                new_month = (new_month - 1) % 12 + 1\n                coupon_date = _construct_date(new_year, new_month, coupon_date.day)\n            except ValueError:\n                # fallback, reduce day until valid\n                # (But _construct_date handles that anyway)\n                coupon_date = _construct_date(new_year, new_month, coupon_date.day)\n\n    # Step 3: Find the coupon period containing 'asof'\n    # We'll generate all coupons between start and end plus one more period to cover asof\n    # Because asof should be between start and end, and frequency divides the whole period.\n    coupons = list(generate_coupon_schedule(start, end + datetime.timedelta(days=1)))  # +1 day for safe coverage\n    # If asof is before start, fraction is zero by convention (also covered in calling function)\n    if asof < start:\n        return Decimal(0)\n\n    # If only one coupon, that means freq=1 and start == end or asof before next coupon\n    if len(coupons) == 1:\n        coupon_start = start\n        coupon_end = end\n    else:\n        # find pair coupon_start <= asof < coupon_end to locate coupon period containing asof\n        coupon_start = None\n        coupon_end = None\n        for i in range(len(coupons) - 1):\n            if coupons[i] <= asof < coupons[i + 1]:\n                coupon_start = coupons[i]\n                coupon_end = coupons[i + 1]\n                break\n        # if asof == last coupon date, it's the last coupon period\n        if coupon_start is None and coupons[-1] == asof:\n            coupon_start = coupons[-1]\n            coupon_end = end\n\n        # if asof beyond last coupon (should not happen asof <= end), fallback to last period\n        if coupon_start is None:\n            coupon_start = coupons[-2]\n            coupon_end = coupons[-1]\n\n    # Step 4: Calculate number of whole coupon periods from start to coupon_start\n    # Each coupon period corresponds to 1/freq of a year\n    # Number of whole coupon periods = (coupon_start - start) in months / months_per_period\n    whole_periods = ((coupon_start.year - start.year) * 12 + (coupon_start.month - start.month)) // months_per_period\n\n    # Step 5: Calculate fraction of the current coupon period elapsed\n    # Fraction = (asof - coupon_start) / (coupon_end - coupon_start)\n    days_in_coupon_period = _get_actual_day_count(coupon_start, coupon_end)\n    if days_in_coupon_period == 0:\n        fraction_in_current = Decimal(0)\n    else:\n        days_elapsed_in_coupon = _get_actual_day_count(coupon_start, asof)\n        if days_elapsed_in_coupon < 0:\n            # asof before coupon_start\n            fraction_in_current = Decimal(0)\n        else:\n            fraction_in_current = Decimal(days_elapsed_in_coupon) / Decimal(days_in_coupon_period)\n\n    # Step 6: Total fraction = number of whole coupons + fraction of current coupon period\n    total_fraction = Decimal(whole_periods) + fraction_in_current\n\n    # According to ICMA, if end date is before the next coupon date after end, total fraction may exceed 1 for periods longer than 1 year.\n    # So if end < next coupon date (i.e., not a full coupon) that ends the period, the fraction is adjusted accordingly.\n    # Since we are calculating up to 'asof', which is between start and end, above calculation suffice.\n\n    return total_fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 463\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 315, "prediction_id": 3, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\nfrom pypara.dcc import _get_actual_day_count, _construct_date\n\n\ndef dcfc_act_act_icma(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    # Validate order of dates: start <= asof <= end\n    if not (start <= asof <= end):\n        return Decimal(0)\n\n    # Frequency is required for Act/Act (ICMA) because it depends on the coupon period length.\n    if freq is None:\n        # If frequency not provided, fallback to simple Act/365F fraction:\n        total_days = _get_actual_day_count(start, asof)\n        return Decimal(total_days) / Decimal(365)\n\n    # Calculate coupon period in months (12 months divided by frequency)\n    months = int(12 / freq)\n\n    # Determine the number of complete coupon periods between start and end\n    # Build coupon schedule dates from start by advancing multiples of months until we pass end\n    # We find the coupon period that contains 'asof' and calculate fraction as\n    # days from coupon start to asof / days in coupon period\n\n    # First, find the previous coupon date before or equal to 'asof'\n    coupon_start = start\n    while True:\n        next_coupon = _construct_date(coupon_start.year, coupon_start.month, coupon_start.day) + datetime.timedelta(days=0)\n        next_coupon = next_coupon + datetime.timedelta(days=0)\n        candidate = _construct_date(coupon_start.year, coupon_start.month, coupon_start.day)\n        next_coupon = coupon_start + datetime.timedelta(days=0)\n        next_coupon = coupon_start + datetime.timedelta(days=0)\n        next_coupon = coupon_start + datetime.timedelta(days=0)\n        next_coupon = coupon_start + datetime.timedelta(days=0)\n        next_coupon = coupon_start + datetime.timedelta(days=0)\n        next_coupon = coupon_start + datetime.timedelta(days=0)\n        next_payment = coupon_start + datetime.timedelta(days=0)\n        next_payment = coupon_start + datetime.timedelta(days=0)\n\n    # Instead, let's step through periods using dateutil.relativedelta (allowed in file content)\n\n    from dateutil.relativedelta import relativedelta\n\n    # Find the last coupon date before or equal to asof:\n    prev_coupon = start\n    while True:\n        candidate = prev_coupon + relativedelta(months=months)\n        if candidate > asof or candidate > end:\n            break\n        prev_coupon = candidate\n\n    # Next coupon date after prev_coupon and <= end or after asof\n    next_coupon = prev_coupon + relativedelta(months=months)\n    # Cap next_coupon at end (no coupons beyond end)\n    if next_coupon > end:\n        next_coupon = end\n\n    # Compute numerator: days between prev_coupon and asof\n    numerator = Decimal(_get_actual_day_count(prev_coupon, asof))\n    # Compute denominator: days in coupon period (prev_coupon to next_coupon)\n    denominator = Decimal(_get_actual_day_count(prev_coupon, next_coupon))\n\n    # Avoid division by zero (if prev_coupon == next_coupon)\n    if denominator == 0:\n        # If zero coupon period (unlikely), but asof == prev_coupon, fraction is zero\n        return Decimal(0)\n\n    fraction = numerator / denominator\n\n    # If asof > end and end > prev_coupon, then fraction includes additional periods - but asof <= end check above ensures this won't happen\n\n    return fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 463\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 315, "prediction_id": 4, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\n\nfrom pypara.commons.numbers import isum\nfrom pypara.dcc import (\n    _construct_date,\n    _get_actual_day_count,\n    _has_leap_day,\n)\n\n\ndef dcfc_act_act_icma(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    # If freq is not provided, we cannot compute proper fraction, so fallback to simple actual/actual count\n    # but as per ICMA standard freq is usually given, if not given we assume 2 (semi-annual) as standard\n    if freq is None:\n        freq = Decimal(2)\n\n    # Step 1: Identify the coupon period start date (start),\n    # coupon period end date (end),\n    # and asof date within the coupon period [start, end].\n\n    # Step 2: Determine the full coupon period length in days\n    full_coupon_period_days = _get_actual_day_count(start, end)\n\n    # Step 3: Calculate the days accrued from start to asof (actual accrued period)\n    accrued_days = _get_actual_day_count(start, asof)\n\n    # Step 4: The ICMA Act/Act fraction is accrued_days / full_coupon_period_days\n\n    # The above works if the coupon period is standard and the frequency corresponds to the actual coupon frequency.\n    # However, ICMA requires adjusting for coupon periods that may not be standard lengths.\n    # The general approach is:\n    # fraction = accrued_days / (365/freq) if no leap day in coupon period, else use leap year length\n\n    # But to be fully ICMA-compliant, we handle also when periods cover leap days:\n    # If the coupon period contains a leap day, then the denominator is days in the coupon period year(s),\n    # which in ICMA convention means we divide the accrued period by the length of the coupon period in days, which we already do.\n\n    # Therefore, the simplest ICMA Act/Act calculation:\n    fraction = Decimal(accrued_days) / Decimal(full_coupon_period_days)\n\n    return fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 463\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
