{"task_id": 311, "prediction_id": 0, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom pypara.dcc import _construct_date\n\n\ndef _next_payment_date(start: datetime.date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> datetime.date:\n    \"\"\"\n    Returns the next coupon payment date after the given start date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    eom = eom or start.day  # Use start day if eom is not specified\n\n    # Frequency defines how many payments per year,\n    # so the period in months between payments is:\n    period = int(12 / frequency)\n\n    # Starting from the start date, iterate adding periods of months \n    # until we get a date that is strictly greater than start\n    year, month = start.year, start.month\n\n    while True:\n        # move month forward by 'period'\n        month += period\n        # adjust year and month if month > 12\n        if month > 12:\n            year += (month - 1) // 12\n            month = ((month - 1) % 12) + 1\n\n        # Construct candidate date safely with eom day\n        candidate = _construct_date(year, month, eom)\n\n        # Return the first candidate strictly after start\n        if candidate > start:\n            return candidate", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1086, in <module>\n  File \"<string>\", line 1085, in test_3\nAssertionError\n", "passed": false}
{"task_id": 311, "prediction_id": 1, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom pypara.dcc import _construct_date\n\n\ndef _next_payment_date(start: datetime.date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> datetime.date:\n    \"\"\"\n    Returns the next coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014, 1, 1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014, 1, 1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    # Frequency must be int for division\n    freq_int = int(frequency)\n\n    # Determine the day of month of payment (end of month day or provided eom)\n    day = eom if eom is not None else start.day\n\n    # Calculate the period in months between payments\n    period = 12 // freq_int\n\n    # Starting month and year from start date\n    s_month = start.month\n    s_year = start.year\n\n    # Calculate the payment schedule months in a year relative to start month:\n    schedule = sorted([i if i > 0 else 12 for i in sorted([(s_month + i) % 12 for i in range(0, 12, period)])])\n\n    # Find the next payment month and year based on start date:\n    # We'll find the first scheduled month/year that is strictly after the start date (or the start month with day > start.day)\n\n    # Gather potential payment dates in the current year or next year\n    candidates = []\n    for month in schedule:\n        # If the payment month is less than starting month, payment will be next year\n        pay_year = s_year\n        if month < s_month or (month == s_month and day <= start.day):\n            pay_year += 1\n        candidates.append(_construct_date(pay_year, month, day))\n\n    # From candidates, pick the earliest date strictly after start date\n    for candidate in sorted(candidates):\n        if candidate > start:\n            return candidate\n\n    # Defensive fallback (should never reach here)\n    # Return start date incremented by one year with same month and day adjusted by eom\n    return _construct_date(s_year + 1, s_month, day)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 858, in <module>\n  File \"<string>\", line 857, in test_0\nAssertionError\n", "passed": false}
{"task_id": 311, "prediction_id": 2, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom pypara.dcc import _construct_date\n\n\ndef _next_payment_date(start: datetime.date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> datetime.date:\n    \"\"\"\n    Returns the next coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    eom = eom or start.day\n    s_month = start.month\n    s_year = start.year\n    period = int(12 / frequency)\n\n    day = eom\n\n    # Start from the year after the start\n    year = s_year + 1\n    month = s_month\n\n    # The next payment date is at the same month each year plus frequency months on schedule,\n    # so we need to find the next date after start with months increasing by period\n\n    # Because payments occur every 'period' months, find the next payment date after start:\n    # We'll generate months by adding the period repeatedly until we find a date > start.\n\n    # We'll loop until we find a date > start\n    while True:\n        # Construct date with the candidate year, month and day (adjust day if needed)\n        candidate = _construct_date(year, month, day)\n        if candidate > start:\n            return candidate\n        # Advance month by period\n        month += period\n        while month > 12:\n            month -= 12\n            year += 1", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1084, in <module>\n  File \"<string>\", line 1083, in test_1\nAssertionError\n", "passed": false}
{"task_id": 311, "prediction_id": 3, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom pypara.dcc import _construct_date\n\n\ndef _next_payment_date(start: datetime.date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> datetime.date:\n    \"\"\"\n    Returns the next coupon payment date after the given start date based on the frequency and optional end-of-month day (eom).\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    # Use the start day if eom is not provided\n    eom = eom or start.day\n\n    # Calculate the period in months between payments\n    period = int(12 / frequency)\n\n    # Calculate the next payment month and year by adding 'period' months to the start date\n    # Normalize month/year overflow\n    next_month = start.month + period\n    next_year = start.year + (next_month - 1) // 12\n    next_month = ((next_month - 1) % 12) + 1\n\n    # Construct and return the next payment date safely, adjusting day if needed\n    return _construct_date(next_year, next_month, eom)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1076, in <module>\n  File \"<string>\", line 1075, in test_3\nAssertionError\n", "passed": false}
{"task_id": 311, "prediction_id": 4, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom pypara.dcc import _construct_date\n\n\ndef _next_payment_date(start: datetime.date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> datetime.date:\n    \"\"\"\n    Returns the next coupon payment date based on the start date, frequency, and optional end-of-month day.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    eom = eom or start.day\n    frequency = int(frequency)\n    period = int(12 / frequency)\n    s_month = start.month\n    s_year = start.year\n\n    # Calculate the next payment month by adding the period to the start month\n    next_month = s_month + period\n    next_year = s_year\n    # If month overflow > 12, adjust year and month\n    if next_month > 12:\n        next_month -= 12\n        next_year += 1\n\n    # Construct and return the next payment date safely\n    return _construct_date(next_year, next_month, eom)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1072, in <module>\n  File \"<string>\", line 1071, in test_1\nAssertionError\n", "passed": false}
