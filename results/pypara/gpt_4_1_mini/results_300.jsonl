{"task_id": 300, "prediction_id": 0, "generation": "from typing import Iterable, Dict\nfrom pypara.commons.zeitgeist import DateRange\nfrom pypara.accounting.ledger import GeneralLedger, Ledger, LedgerEntry\nfrom pypara.accounting.journaling import JournalEntry, Posting\nfrom pypara.accounting.generic import Balance\nfrom pypara.accounting.ledger import InitialBalances\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    # Initialize the ledgers dictionary with initial balances\n    ledgers: Dict[Account, Ledger[_T]] = {}\n\n    for account, balance in initial.items():\n        ledgers[account] = Ledger(account=account, initial=balance)\n\n    # Iterate over all journal entries\n    for entry in journal:\n        # Iterate over all postings in the journal entry\n        for posting in entry.postings:\n            acct = posting.account\n            # Get or create ledger for the account\n            ledger = ledgers.get(acct)\n            if ledger is None:\n                # If no initial balance provided, assume zero initial balance.\n                ledger = Ledger(account=acct, initial=Balance(0))\n                ledgers[acct] = ledger\n            # Add the posting as a ledger entry\n            ledger.add(posting)\n\n    # Build and return the general ledger\n    return GeneralLedger(period=period, ledgers=ledgers)", "message": "passed", "passed": true}
{"task_id": 300, "prediction_id": 1, "generation": "from typing import Dict, Iterable\n\nfrom .ledger import GeneralLedger, Ledger, InitialBalances\nfrom .journaling import JournalEntry\nfrom ..commons.zeitgeist import DateRange\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    # Create ledger dict indexed by account, initialize with opening balances\n    ledgers: Dict[Account, Ledger[_T]] = {}\n\n    # Initialize ledgers with initial balances\n    for account, balance in initial.items():\n        ledgers[account] = Ledger(account=account, initial=balance)\n\n    # Process each journal entry, adding postings to corresponding ledgers\n    for entry in journal:\n        for posting in entry.postings:\n            account = posting.account\n            # Ensure ledger for account exists\n            if account not in ledgers:\n                # No initial balance for this account, use zero Balance\n                zero_balance = Balance(0)\n                ledgers[account] = Ledger(account=account, initial=zero_balance)\n            # Add posting to ledger (which updates balance and records entry)\n            ledgers[account].add(posting)\n\n    # Create and return the GeneralLedger instance\n    return GeneralLedger(period=period, ledgers=ledgers)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 183, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 300, "prediction_id": 2, "generation": "from typing import Dict, Iterable\n\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance, Quantity\nfrom .journaling import JournalEntry, Posting\nfrom .ledger import GeneralLedger, Ledger, InitialBalances, LedgerEntry, _T\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    # Dictionary to hold ledgers by Account\n    ledgers: Dict[Account, Ledger[_T]] = {}\n\n    # Initialize ledgers with initial balances\n    for account, balance in initial.items():\n        ledgers[account] = Ledger(account, balance)\n\n    # Process each journal entry\n    for entry in journal:\n        # Iterate over postings in the journal entry\n        for posting in entry.postings:\n            account = posting.account\n            # If ledger for account not yet created, create with zero initial balance\n            if account not in ledgers:\n                ledgers[account] = Ledger(account, Balance(Quantity(0)))\n\n            ledger = ledgers[account]\n            # Add posting to ledger which will create a LedgerEntry and update balance\n            ledger.add(posting)\n\n    # Build and return the GeneralLedger\n    return GeneralLedger(period=period, ledgers=ledgers)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 183, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 300, "prediction_id": 3, "generation": "from typing import Dict, Iterable, TypeVar\n\nfrom .accounts import Account\nfrom .generic import Balance\nfrom .journaling import JournalEntry\nfrom .ledger import GeneralLedger, Ledger, InitialBalances\nfrom ..commons.zeitgeist import DateRange\n\n_T = TypeVar(\"_T\")\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    # Initialize ledgers dictionary: account -> Ledger\n    ledgers: Dict[Account, Ledger[_T]] = {}\n\n    # Start from the given initial balances (accounts with opening balances)\n    # Use a copy so as not to mutate the input initial dict.\n    ledgers = {account: Ledger(account, balance) for account, balance in initial.items()}\n\n    # Process all journal entries in the given iterable:\n    # For each posting in each journal entry, add it to the respective Ledger\n    for entry in journal:\n        for posting in entry.postings:\n            account = posting.account\n            # Get or create the ledger for the account\n            if account not in ledgers:\n                # If no initial balance, start from zero Balance\n                # Assuming Balance has a default zero value (from .generic import Balance)\n                # Since Balance is a generic type, we initialize as Balance.zero or equivalent.\n                # But the context didn't provide Balance.zero, so use a default:\n                # It looks like Balance type might be a wrapper over Quantity.\n                # We can use Balance(Quantity(0)), but we don't have Quantity import here.\n                # In the file content Quantity is imported from commons.numbers.\n                # So let's import Quantity and pass Balance with Quantity(0).\n                # To keep self-contained, import Quantity here.\n                from ..commons.zeitgeist import DateRange  # already imported above\n                from ..commons.numbers import Quantity\n                ledgers[account] = Ledger(account, Balance(Quantity(0)))\n            # Add the posting to the ledger (which also updates balance)\n            ledgers[account].add(posting)\n\n    # Build the GeneralLedger object with the given period and the ledgers dict\n    general_ledger = GeneralLedger(period=period, ledgers=ledgers)\n    return general_ledger", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 183, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 300, "prediction_id": 4, "generation": "from typing import Dict, Iterable\n\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account\nfrom .generic import Balance, Quantity\nfrom .journaling import JournalEntry, Posting\nfrom .ledger import GeneralLedger, Ledger, InitialBalances\n\n\ndef build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    # Create ledger instances for all accounts in initial balances.\n    ledgers: Dict[Account, Ledger[_T]] = {\n        account: Ledger(account, balance)\n        for account, balance in initial.items()\n    }\n\n    # Iterate over all journal entries\n    for entry in journal:\n        # For each posting in the journal entry:\n        for posting in entry.postings:\n            account = posting.account\n\n            # If this account does not have a ledger yet, start with zero balance.\n            if account not in ledgers:\n                # Use zero balance with the same type as initial balances values \n                # but if initial is empty, fallback to Quantity(0).\n                # Since InitialBalances is Dict[Account, Balance], we must provide a Balance.\n                # Assuming Balance can be created from zero Quantity.\n                # But since Balance is imported from .generic, and initial.values() are Balance,\n                # create a zero Balance if needed:\n                # We take Quantity(0) since Balance presumably has a value attribute of Quantity.\n                ledgers[account] = Ledger(account, Balance(Quantity(0)))\n\n            # Add the posting to the appropriate ledger.\n            ledgers[account].add(posting)\n\n    # Build and return the GeneralLedger\n    return GeneralLedger(period=period, ledgers=ledgers)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 183, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
