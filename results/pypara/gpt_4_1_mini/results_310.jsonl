{"task_id": 310, "prediction_id": 0, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nDate = datetime.date\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the next coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    months = int(12 / frequency)\n    nextdate = start + relativedelta(months=months)\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n    return nextdate\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015,  12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    # Defensive: if asof < start, then no payment dates reached yet, return start\n    if asof < start:\n        # The start date is the first coupon date, so last payment can't be before start.\n        return start\n\n    # Calculate payment period in months\n    months = int(12 / frequency)\n\n    # Initialize candidate payment date to start date\n    candidate = start\n\n    # We will iterate forward in payment intervals until candidate > asof\n    while True:\n        # Compute next payment date from candidate\n        next_date = _next_payment_date(candidate, frequency, eom)\n        if next_date > asof:\n            # The current candidate is the last payment date on or before asof\n            break\n        candidate = next_date  # advance to next date\n\n    return candidate", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1307, in <module>\n  File \"<string>\", line 1306, in test_27\nAssertionError\n", "passed": false}
{"task_id": 310, "prediction_id": 1, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nDate = datetime.date  # Alias for clarity and consistency\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n\n    If the day is out of range for the month, decreases the day until valid.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the next coupon payment date after the given start date,\n    by advancing by the period defined by frequency (times per year),\n    adjusting for an optional end-of-month day.\n\n    months = 12 / frequency\n    \"\"\"\n    months = int(12 / frequency)\n    nextdate = start + relativedelta(months=months)\n    if eom:\n        # Try to replace day with eom, if invalid day leave as is\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n    return nextdate\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    # Edge case: if asof < start, no payments have been made; return start\n    if asof < start:\n        return start\n\n    # Compute period in months between coupon payments\n    months_per_period = int(12 / frequency)\n\n    # Initialize candidate payment date as start\n    candidate = start\n\n    # Loop forward in steps of months_per_period until next payment date > asof\n    while True:\n        next_pay = _next_payment_date(candidate, frequency=frequency, eom=eom)\n        if next_pay > asof:\n            # The candidate is the last payment on or before asof\n            return candidate\n        candidate = next_pay", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1307, in <module>\n  File \"<string>\", line 1306, in test_27\nAssertionError\n", "passed": false}
{"task_id": 310, "prediction_id": 2, "generation": "import datetime\nfrom typing import Optional, Union\nfrom decimal import Decimal\n\nfrom dateutil.relativedelta import relativedelta\n\n\ndef _last_payment_date(start: datetime.date, asof: datetime.date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> datetime.date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    # Convert frequency to int months per year\n    freq = int(frequency)\n    # Months between coupons\n    months_per_coupon = 12 // freq\n\n    # We need to find the last payment date on or before asof, starting from start date.\n    # Set candidate date to start date initially\n    last_payment = start\n\n    # Increment candidate date by coupon periods until next payment would be after asof\n    while True:\n        # Calculate next payment date by adding months_per_coupon to last_payment\n        try:\n            # Compute year and month for next payment\n            year = last_payment.year\n            month = last_payment.month + months_per_coupon\n            # Adjust year and month to valid ranges\n            while month > 12:\n                month -= 12\n                year += 1\n\n            # Determine day for next payment:\n            # If eom is provided and eom>0, use it as day if valid, else fallback to day of start date.\n            # If eom is None, use the day of start date.\n            day = eom if eom else start.day\n\n            # Build next payment date safely:\n            # If day doesn't exist in that month, replace with last day of month.\n            # We'll use calendar.monthrange to get last day of month:\n            import calendar\n            last_day_of_month = calendar.monthrange(year, month)[1]\n            if day > last_day_of_month:\n                day = last_day_of_month\n\n            next_payment = datetime.date(year, month, day)\n        except Exception:\n            # Fallback: just add relativedelta months\n            next_payment = last_payment + relativedelta(months=months_per_coupon)\n            # Adjust day similarly:\n            if eom:\n                try:\n                    next_payment = next_payment.replace(day=eom)\n                except ValueError:\n                    pass\n\n        # If next payment is after asof, break loop\n        if next_payment > asof:\n            break\n        # Otherwise update last_payment to next_payment and continue\n        last_payment = next_payment\n\n    return last_payment", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1570, in <module>\n  File \"<string>\", line 1569, in test_extra_0\nAssertionError\n", "passed": false}
{"task_id": 310, "prediction_id": 3, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom dateutil.relativedelta import relativedelta\n\n\ndef _last_payment_date(start: datetime.date, asof: datetime.date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> datetime.date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n\n    freq = int(frequency)  # Frequency as integer number of coupons per year\n    months_interval = 12 // freq\n\n    # If asof < start date, no payments made yet, consider last payment = start\n    if asof < start:\n        return start\n\n    # Calculate number of full periods (increments of months_interval) from start up to or before asof\n    # Using year and month calculations to avoid many loops\n    year_diff = asof.year - start.year\n    month_diff = asof.month - start.month\n    total_month_diff = year_diff * 12 + month_diff\n\n    # Number of full periods paid before or at asof\n    periods = total_month_diff // months_interval\n\n    # Calculate last payment date by adding periods * months_interval to start\n    last_payment_year = start.year + (start.month - 1 + periods * months_interval) // 12\n    last_payment_month = ((start.month - 1 + periods * months_interval) % 12) + 1\n\n    # Set day\n    if eom is not None:\n        day = eom\n    else:\n        day = start.day\n\n    # Try to construct last payment date safely (handle months with fewer days)\n    # We replicate _construct_date logic here to avoid importing, safe fallback\n    def _safe_construct_date(y, m, d):\n        while True:\n            try:\n                return datetime.date(y, m, d)\n            except ValueError:\n                d -= 1\n                if d == 0:\n                    # This shouldn't realistically happen if start.day > 0,\n                    # but as a fallback, push the date to 1st of month\n                    return datetime.date(y, m, 1)\n\n    last_payment = _safe_construct_date(last_payment_year, last_payment_month, day)\n\n    # If last_payment is after asof (possible if eom set to day after asof.day), decrement one period\n    if last_payment > asof and periods > 0:\n        periods -= 1\n        last_payment_year = start.year + (start.month - 1 + periods * months_interval) // 12\n        last_payment_month = ((start.month - 1 + periods * months_interval) % 12) + 1\n        last_payment = _safe_construct_date(last_payment_year, last_payment_month, day)\n\n    # If periods == 0 and last_payment > asof (means payment date after asof but periods=0), return start directly\n    if periods == 0 and last_payment > asof:\n        last_payment = start\n        if eom is not None:\n            # Adjust day to eom safely\n            last_payment = _safe_construct_date(start.year, start.month, eom)\n\n    return last_payment", "message": "timed out", "passed": false}
{"task_id": 310, "prediction_id": 4, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom pypara.dcc import _construct_date\n\nDate = datetime.date\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    months = int(12 / frequency)\n    last_date = start\n\n    # Helper to adjust day according to eom and valid day in month\n    def adjusted_date(year: int, month: int) -> Date:\n        if eom is not None:\n            day = eom\n        else:\n            day = start.day\n        return _construct_date(year, month, day)\n\n    # Iterate forward by frequency intervals until we pass 'asof'\n    current = start\n    while True:\n        # Compute next candidate date:\n        next_month = (current.month + months - 1) % 12 + 1\n        # Calculate year increment when month overflows 12\n        year_increment = (current.month + months - 1) // 12\n        next_year = current.year + year_increment\n        candidate = adjusted_date(next_year, next_month)\n\n        if candidate > asof:\n            break\n        last_date = candidate\n        current = candidate\n\n    return last_date", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1549, in <module>\n  File \"<string>\", line 1548, in test_extra_0\n  File \"<string>\", line 170, in _last_payment_date\n  File \"<string>\", line 160, in adjusted_date\n  File \"<string>\", line 212, in _construct_date\nValueError: year, month and day must be greater than 0.\n", "passed": false}
