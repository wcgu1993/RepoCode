{"task_id": 321, "prediction_id": 0, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\n\nfrom .commons.zeitgeist import Date\nfrom .dcc import _is_last_day_of_month\n\n\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    # Determine D1 per ISDA convention\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    # Determine D2 per ISDA convention\n    if asof.day == 31:\n        if asof != end:\n            d2 = 30\n        else:\n            d2 = asof.day\n    else:\n        d2 = asof.day\n\n    # Calculate number of days for 30/360 ISDA\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 620\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 321, "prediction_id": 1, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\nfrom .commons.zeitgeist import Date\nfrom .dcc import _is_last_day_of_month\n\n\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    # Compute D1\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    # Compute D2\n    if asof.day == 31:\n        if asof == end:\n            d2 = 30\n        else:\n            d2 = asof.day\n    elif asof.month == 2 and _is_last_day_of_month(asof) and end != asof:\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    # Calculate number of days according to 30/360 ISDA formula\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 620\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 321, "prediction_id": 2, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\n\nfrom .commons.zeitgeist import Date\nfrom .dcc import _is_last_day_of_month\n\n\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    # Per ISDA 30/360:\n    # If start day = 31 or is last day of Feb then set D1 = 30\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    # If asof day = 31 and start day < 30, then set D2 = 1 and increment month\n    # Else if asof day = 31 then set D2 = 30\n    if asof.day == 31:\n        if d1 < 30:\n            d2 = 1\n            # increment month by 1; if month > 12, increment year and set month=1\n            if asof.month == 12:\n                y = asof.year + 1\n                m = 1\n            else:\n                y = asof.year\n                m = asof.month + 1\n            asof_adj_day = d2\n            asof_year_adj = y\n            asof_month_adj = m\n        else:\n            d2 = 30\n            asof_year_adj = asof.year\n            asof_month_adj = asof.month\n            asof_adj_day = d2\n    else:\n        d2 = asof.day\n        asof_year_adj = asof.year\n        asof_month_adj = asof.month\n        asof_adj_day = d2\n\n    # Now compute number of days:\n    nod = (Decimal(asof_adj_day) - Decimal(d1)) \\\n          + Decimal(30) * (Decimal(asof_month_adj) - Decimal(start.month)) \\\n          + Decimal(360) * (Decimal(asof_year_adj) - Decimal(start.year))\n\n    # Return the fraction of 360\n    return nod / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 620\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 321, "prediction_id": 3, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\nfrom .commons.zeitgeist import Date\nfrom .dcc import _is_last_day_of_month\n\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    # Adjust start day (D1):\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    # Adjust asof day (D2):\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    # Calculate number of days according to 30/360 ISDA\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 620\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 321, "prediction_id": 4, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\n\nfrom .commons.zeitgeist import Date\nfrom .dcc import _is_last_day_of_month\n\n\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    # Adjust D1:\n    if start.day == 31:\n        d1 = 30\n    else:\n        d1 = start.day\n\n    # Adjust D2 based on asof and end dates:\n    if asof.day == 31:\n        if start.day in (30, 31):\n            d2 = 30\n        elif (asof.month == 2) and _is_last_day_of_month(asof) and (end != asof):\n            # According to ISDA documentation and examples,\n            # if asof is Feb 28 or 29 (last day of Feb), and not the end date,\n            # then treat D2 as 30.\n            d2 = 30\n        else:\n            d2 = asof.day\n    else:\n        d2 = asof.day\n\n    # Calculate number of days basis 30/360:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    # Return fraction as Decimal:\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 620\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
