{"task_id": 304, "prediction_id": 0, "generation": "from typing import Iterable, Optional, TypeVar, cast\nfrom decimal import Decimal\n\nDecimalLike = TypeVar(\"DecimalLike\", bound=Decimal)\nZERO = Decimal(\"0\")\n\ndef isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    # Determine start value: If given use it, else use ZERO casted to DecimalLike\n    if start is None:\n        # Cast ZERO to DecimalLike for type-checking\n        total = cast(DecimalLike, ZERO)\n    else:\n        total = start\n\n    for x in xs:\n        total += x\n\n    return total", "message": "passed", "passed": true}
{"task_id": 304, "prediction_id": 1, "generation": "from decimal import Decimal\nfrom typing import Iterable, Optional, TypeVar, cast\n\nDecimalLike = TypeVar(\"DecimalLike\", bound=Decimal)\nZERO = Decimal(\"0\")\n\ndef isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    # Determine the initial sum: if start is given, use it; else use ZERO cast to DecimalLike\n    if start is not None:\n        total = start\n    else:\n        # Cast ZERO (Decimal) to DecimalLike for proper static typing\n        total = cast(DecimalLike, ZERO)\n\n    for x in xs:\n        total = cast(DecimalLike, total + x)\n\n    return total", "message": "passed", "passed": true}
{"task_id": 304, "prediction_id": 2, "generation": "from decimal import Decimal\nfrom typing import Iterable, Optional, TypeVar, cast\n\nDecimalLike = TypeVar(\"DecimalLike\", bound=Decimal)\nZERO = Decimal(\"0\")\n\ndef isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    if start is None:\n        # Use ZERO casted to DecimalLike type for consistent return type\n        total = cast(DecimalLike, ZERO)\n    else:\n        total = start\n\n    for x in xs:\n        total = cast(DecimalLike, total + x)\n\n    return total", "message": "passed", "passed": true}
{"task_id": 304, "prediction_id": 3, "generation": "from typing import Iterable, Optional, TypeVar, cast\nfrom decimal import Decimal\n\nDecimalLike = TypeVar(\"DecimalLike\", bound=Decimal)\nZERO = Decimal(\"0\")\n\ndef isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    it = iter(xs)\n    # Determine initial accumulator value\n    if start is not None:\n        acc: DecimalLike = start\n    else:\n        # Try to infer type from first element if possible\n        try:\n            first = next(it)\n        except StopIteration:\n            # Empty iterable, return ZERO cast to DecimalLike\n            return cast(DecimalLike, ZERO)\n        else:\n            acc = cast(DecimalLike, ZERO)  # Base zero value, cast for type consistency\n            acc = type(first)(acc)  # Cast zero to the same type as first element\n            acc += first\n    for x in it:\n        acc += x\n    return acc", "message": "passed", "passed": true}
{"task_id": 304, "prediction_id": 4, "generation": "from typing import Iterable, Optional, TypeVar, cast\nfrom decimal import Decimal\n\nDecimalLike = TypeVar(\"DecimalLike\", bound=Decimal)\nZERO = Decimal(\"0\")\n\ndef isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    it = iter(xs)\n    # Determine start value; if not provided, default to ZERO casted to DecimalLike type\n    if start is not None:\n        total = start\n    else:\n        try:\n            first = next(it)\n        except StopIteration:\n            # empty iterable and no start => return ZERO casted to DecimalLike\n            return cast(DecimalLike, ZERO)\n        else:\n            total = first\n    for x in it:\n        total += x\n    return total", "message": "passed", "passed": true}
