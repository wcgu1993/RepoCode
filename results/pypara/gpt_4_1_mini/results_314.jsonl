{"task_id": 314, "prediction_id": 0, "generation": "from decimal import Decimal\nfrom typing import Optional\nimport datetime\nfrom .commons.zeitgeist import Date\nfrom .dcc import _get_actual_day_count, _has_leap_day\n\n\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    # Check if start <= asof <= end, else return 0\n    if not (start <= asof <= end):\n        return Decimal(0)\n\n    # Handle the simple case where freq is None or 0:\n    freq_val = freq if freq is not None else Decimal(1)\n\n    # When the period is within a single year:\n    if start.year == asof.year == end.year:\n        days_in_year = 366 if calendar.isleap(start.year) else 365\n        actual_days = Decimal(_get_actual_day_count(start, asof))\n        return actual_days / Decimal(days_in_year)\n\n    # When the period spans multiple years:\n    # We'll sum fractions from start to 31 Dec of start year,\n    # full years between start.year+1 and asof.year-1 (if any),\n    # and asof date fraction in the asof year.\n    \n    total_fraction = Decimal(0)\n\n    # 1) Calculate the fraction from start to end of start year or asof (whichever smaller)\n    end_of_start_year = datetime.date(start.year, 12, 31)\n    period_end = min(asof, end_of_start_year)\n    days_in_start_year = 366 if calendar.isleap(start.year) else 365\n    days_start_period = Decimal(_get_actual_day_count(start, period_end + datetime.timedelta(days=1)))\n    total_fraction += days_start_period / Decimal(days_in_start_year)\n\n    # 2) For each full year between start.year+1 and asof.year-1, add 1\n    for year in range(start.year + 1, asof.year):\n        # full year adds 1\n        total_fraction += Decimal(1)\n\n    # 3) For asof year fraction (if asof is not in start year), add days from Jan 1 to asof inclusive\n    if asof.year != start.year:\n        start_of_asof_year = datetime.date(asof.year, 1, 1)\n        days_in_asof_year = 366 if calendar.isleap(asof.year) else 365\n        days_asof_period = Decimal(_get_actual_day_count(start_of_asof_year, asof + datetime.timedelta(days=1)))\n        total_fraction += days_asof_period / Decimal(days_in_asof_year)\n\n    # If end < asof, we do not count past end, so result should be 0, but already handled above.\n\n    # Normalize by frequency (i.e., divide by freq)\n    return total_fraction / freq_val", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 419\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 314, "prediction_id": 1, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\nfrom pypara.dcc import _get_actual_day_count, _has_leap_day, _last_payment_date, _next_payment_date\n\n\ndef dcfc_act_act(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    # Return 0 if dates are not in proper order\n    if not (start <= asof <= end):\n        return Decimal('0')\n\n    # Convert freq to int if Decimal and defined, else default 1\n    frequency = int(freq) if freq is not None else 1\n\n    # If payment frequency is not given or is 0 (to avoid zero division), treat as 1\n    if frequency <= 0:\n        frequency = 1\n\n    # Handle cases where the accrual period spans multiple coupon periods (multi-year)\n    # We need to split the period into accrual sub-periods bounded by coupon payment dates\n    # and sum the fraction per sub-period.\n\n    # Get last payment date <= asof starting from start, frequency (e.g. 1,2,4)\n    prev_coupon = _last_payment_date(start, asof, frequency)\n\n    # Get next payment date after prev_coupon\n    next_coupon = _next_payment_date(prev_coupon, frequency)\n\n    total_fraction = Decimal('0')\n\n    # Case 1: asof and start are within the same coupon period\n    if prev_coupon <= start < next_coupon:\n        # Compute actual days between start and asof\n        days_in_period = _get_actual_day_count(start, next_coupon)\n        days_accrued = _get_actual_day_count(start, asof)\n        if days_in_period == 0:\n            return Decimal('0')\n        fraction = Decimal(days_accrued) / Decimal(days_in_period)\n        return fraction\n\n    # If asof > start but start < prev_coupon means start is before the previous coupon date,\n    # which can happen if start is before the first coupon payment.\n\n    # For multi coupon periods (period between start and asof spans multiple coupons), sum fractions per period.\n    # We iterate over coupon periods from start to asof, summing the fractions.\n\n    # We'll iterate coupon periods boundaries:\n    # We start from start date, get next payment date,\n    # Then accumulate fractions for each period that falls entirely or partially within start to asof.\n\n    current_start = start\n    total_fraction = Decimal('0')\n\n    while current_start < asof:\n        current_end = _next_payment_date(current_start, frequency)\n        # Limit the current_end to asof if it goes beyond it\n        period_end = current_end if current_end <= asof else asof\n        days_in_period = Decimal(_get_actual_day_count(current_start, current_end))\n        days_accrued = Decimal(_get_actual_day_count(current_start, period_end))\n        if days_in_period == 0:\n            # Avoid division by zero if period has zero length (should not happen in normal case)\n            period_fraction = Decimal('0')\n        else:\n            period_fraction = days_accrued / days_in_period\n        total_fraction += period_fraction\n        current_start = current_end\n\n    return +total_fraction  # unary plus applies context rounding if any", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 419\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 314, "prediction_id": 2, "generation": "from decimal import Decimal\nfrom typing import Optional\nimport datetime\n\nfrom .commons.numbers import ONE, ZERO\nfrom .commons.zeitgeist import Date\nfrom .dcc_act_act_icma import dcfc_act_act_icma\nfrom .dcc_act_365_a import dcfc_act_365_a\nfrom ._get_actual_day_count import _get_actual_day_count\nfrom ._has_leap_day import _has_leap_day\nfrom ._last_payment_date import _last_payment_date\nfrom ._next_payment_date import _next_payment_date\n\n\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    # If freq is None or 0 or 1, use simple Act/Act ISDA logic (by counting days and dividing by 365 or 366 depending on leap day)\n    if freq is None or freq == 0 or freq == 1:\n        # Compute total days and divide by 365 or 366 (if leap day in period)\n        actual_days = Decimal(_get_actual_day_count(start, asof))\n        year_length = Decimal(366 if _has_leap_day(start, asof) else 365)\n        return actual_days / year_length\n\n    # When frequency is provided and > 1, use Act/Act ICMA convention.\n\n    # frequency could be Decimal or int, ensure int for usage in _last_payment_date\n    freq_int = int(freq)\n\n    # Find last coupon payment date before or on 'asof' from 'start' and frequency\n    prev_date = _last_payment_date(start, asof, freq_int)\n\n    # Find next coupon payment date after prev_date\n    next_date = _next_payment_date(prev_date, freq_int)\n\n    # If asof is before prev_date, fallback to simple act/act (edge case)\n    if asof < prev_date:\n        # Defensive fallback: Calculate the fraction from start to asof over start to end divided by freq\n        p1 = Decimal(_get_actual_day_count(start, asof))\n        p2 = Decimal(_get_actual_day_count(start, end))\n        if p2 == 0:\n            return ZERO\n        return p1 / p2 / Decimal(freq)\n\n    # Calculate the fraction as:\n    # fraction = (actual days from prev_date to asof) / (days from prev_date to next_date)\n    # divided by frequency.\n    numerator = Decimal(_get_actual_day_count(prev_date, asof))\n    denominator = Decimal(_get_actual_day_count(prev_date, next_date))\n\n    if denominator == 0:\n        # This should not happen but guard to avoid division by zero\n        return ZERO\n\n    fraction = (numerator / denominator) / Decimal(freq)\n    return fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 419\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 314, "prediction_id": 3, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\nfrom pypara.dcc import _get_actual_day_count, _has_leap_day, _last_payment_date, _next_payment_date, _construct_date\nfrom pypara.dcc import ZERO  # ZERO might be useful if zero return needed\nfrom pypara.dcc import DCC  # for possible usage in typing annotations\nfrom pypara.dcc import ONE  # used for Decimal(1) fallback\n\n\ndef dcfc_act_act(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    # Early sanity check: If asof is not between start and end, return 0 per DCC.calculate_fraction pattern\n    if not (start <= asof <= end):\n        return ZERO\n\n    # Frequency fallback: if freq is None or 0, treat as 1 (annual)\n    freq_val = Decimal(freq) if freq is not None else Decimal(1)\n    if freq_val == 0:\n        freq_val = Decimal(1)\n\n    # Handle the simple case if period does not cross payment boundaries (or freq=1)\n    # The Act/Act (ISDA) methodology implemented here divides the period into sub-periods (coupons),\n    # sums actual days / days in coupon for each part.\n\n    # If freq is None or 0, treat as 1: annual periods\n\n    # Find the last coupon date before or on asof:\n    prev_coupon = _last_payment_date(start, asof, freq_val)\n    # Find the next coupon date after prev_coupon:\n    next_coupon = _next_payment_date(prev_coupon, freq_val)\n\n    # Now compute fraction as weighted sum over partial coupon periods\n\n    # Key logic:\n\n    # If the start is before prev_coupon => means asof spans more than one coupon period:\n    # Need to sum successive coupon fractions from start to asof\n\n    # Compute fraction parts:\n    total_fraction = Decimal(0)\n\n    # Pointer to iterate dates:\n    current_start = start\n\n    # While current_start < asof:\n    #   Find next coupon date after current_start (could reuse prev_coupon & next_coupon if aligned)\n    #   If next coupon date exceeds asof, limit to asof\n    #   Sum actual days / actual days in coupon\n\n    # But we must be careful: frequencies can be fractional decimal, so pay attention to integer frequency transformation for month counts in _last_payment_date.\n\n    # Loop approach:\n\n    while current_start < asof:\n        # Last payment date before asof or current_start:\n        last_pay = _last_payment_date(start, current_start, freq_val)\n        next_pay = _next_payment_date(last_pay, freq_val)\n\n        # The relevant period end is the min of next_pay and asof+1 (increment day to include asof if exact?)\n        period_end = next_pay if next_pay <= asof else asof\n\n        # Correct period end:\n        # period is current_start to period_end (exclude period_end)\n\n        # Number of days in the period:\n        actual_days = Decimal(_get_actual_day_count(current_start, period_end))\n        # Number of days in the whole coupon:\n        coupon_days = Decimal(_get_actual_day_count(last_pay, next_pay))\n\n        if coupon_days == 0:\n            # Defensive: avoid division by zero, fallback to actual_days / 365\n            # This should never ideally happen for well-formed coupon dates.\n            coupon_days = Decimal(365)\n\n        fraction = actual_days / coupon_days\n\n        total_fraction += fraction\n\n        # Move forward\n        current_start = period_end\n\n        # If current_start == asof, then break to avoid infinite loop\n        if current_start == asof:\n            break\n\n    # Return scaled by frequency:\n    # According to ISDA, no extra scale with freq, but \"Actual/Actual\" is normalized by freq\n\n    # The examples show that the resulting fraction is result of summing actual-day/count-of-coupon all normalized by frequency\n\n    # So scale total_fraction by 1/frequency\n\n    return total_fraction / freq_val", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 419\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 314, "prediction_id": 4, "generation": "from decimal import Decimal\nfrom typing import Optional\nimport datetime\n\nfrom .commons.zeitgeist import Date\nfrom .dcc import _get_actual_day_count, _last_payment_date, _next_payment_date, _has_leap_day\n\n\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    # Guard against zero or negative intervals or if asof outside [start, end]\n    if not (start <= asof <= end):\n        return Decimal('0')\n\n    # Use frequency of 1 if freq is None or zero to avoid division errors\n    freq_val = Decimal(freq) if freq else Decimal(1)\n\n    # If freq is 0 or negative, treat as 1 to avoid division by zero or nonsensical frequencies\n    if freq_val <= 0:\n        freq_val = Decimal(1)\n\n    # If period is less or equal to zero days, return zero\n    total_period_days = _get_actual_day_count(start, end)\n    if total_period_days == 0:\n        return Decimal('0')\n\n    # 1. Handle the simple case where the period between start and end is within one \"coupon period\"\n    # If frequency is not specified, treat as 1 (annual), standard Act/Act case\n\n    # 2. If frequency is specified, and the period spans multiple coupon periods, split calculation accacking\n    # the coupon schedule\n\n    # Check if frequency is given and greater than 1 (multiple payments per year)\n    # Then calculate fraction as sum of fractions over coupon periods proportionally\n\n    # If freq is given and > 1, we calculate accrued fraction using ISDA Act/Act methodology:\n    # Find last coupon date before asof using _last_payment_date\n    # Find next coupon date after that using _next_payment_date\n    # Accrue fractions over sub-periods accordingly\n\n    # If freq is 1 or missing, use simple fraction of actual days / actual days in the period\n\n    # For more precise Act/Act (ISDA) convention, this method is commonly used,\n    # matching the examples given.\n\n    # So, we implement the Act/Act ISDA algorithm per the examples:\n\n    # First, if freq is None or 1, calculate fraction = actual days from start to asof / actual days from start to end\n    # Else (freq >1), split the accrual into coupon periods from start to end.\n\n    if freq_val == 1:\n        # Simple: fraction = actual_days(start, asof) / actual_days(start, end)\n        numerator = Decimal(_get_actual_day_count(start, asof))\n        denominator = Decimal(_get_actual_day_count(start, end))\n        if denominator == 0:\n            return Decimal('0')\n        # Dividing numerator / denominator * 1/freq = just numerator / denominator since freq=1\n        fraction = numerator / denominator\n        return fraction\n\n    # For freq > 1, split the period at coupon boundaries and sum the fractions\n    # A helper to calculate fraction for subperiod given start and end dates of that subperiod\n\n    fraction_sum = Decimal(0)\n    period_start = start\n\n    while period_start < asof:\n        # Get last payment date prior to period_start (not needed)\n        # Determine next payment date from period_start\n        period_end = _next_payment_date(period_start, freq_val)\n\n        # If next payment date is after end, limit to end\n        if period_end > end:\n            period_end = end\n\n        # If period_end is after asof, clip to asof\n        if period_end > asof:\n            period_end = asof\n\n        # Calculate fraction for current sub-period:\n        numerator = Decimal(_get_actual_day_count(period_start, period_end))\n        denominator = Decimal(_get_actual_day_count(period_start, _next_payment_date(period_start, freq_val)))\n        # Handle edge case denominator=0:\n        if denominator == 0:\n            # fallback to actual_days / 365 or 366 if leap day included\n            denominator = Decimal(366 if _has_leap_day(period_start, period_end) else 365)\n\n        fraction_sum += numerator / denominator\n\n        period_start = period_end\n\n    return fraction_sum", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 419\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
