{"task_id": 324, "prediction_id": 0, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\n\nfrom pypara.dcc import _construct_date, _is_last_day_of_month\n\n\ndef dcfc_30_360_german(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    s_day, s_month, s_year = start.day, start.month, start.year\n    a_day, a_month, a_year = asof.day, asof.month, asof.year\n\n    # If start date is the last day of its month, change start day to 30\n    if _is_last_day_of_month(start):\n        s_day = 30\n\n    # If start day is 30 or 31 AND asof day is the last day of its month, change asof day to 30\n    if s_day in [30, 31] and _is_last_day_of_month(asof):\n        a_day = 30\n\n    # Construct adjusted dates safely\n    adj_start = _construct_date(s_year, s_month, s_day)\n    adj_asof = _construct_date(a_year, a_month, a_day)\n\n    nod = (a_day - s_day) + 30 * (a_month - s_month) + 360 * (a_year - s_year)\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 735\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 324, "prediction_id": 1, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\nfrom pypara.dcc import _construct_date, _is_last_day_of_month\n\n\ndef dcfc_30_360_german(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    y_1, m_1, d_1 = start.year, start.month, start.day\n    y_2, m_2, d_2 = asof.year, asof.month, asof.day\n\n    # If start date is the last day of month, set start day to 30\n    if _is_last_day_of_month(start):\n        d_1 = 30\n\n    # If asof date is the last day of month\n    if _is_last_day_of_month(asof):\n        # and start day is 30 or 31, then set asof day to 30\n        if d_1 in (30, 31):\n            d_2 = 30\n\n    # Construct adjusted dates safely\n    start_adj = _construct_date(y_1, m_1, d_1)\n    asof_adj = _construct_date(y_2, m_2, d_2)\n\n    nod = (d_2 - d_1) + 30 * (m_2 - m_1) + 360 * (y_2 - y_1)\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 735\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 324, "prediction_id": 2, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\n\nfrom pypara.dcc import _construct_date\n\n\ndef dcfc_30_360_german(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    # Adjust day of start: if it is 31, it becomes 30\n    start_day = 30 if start.day == 31 else start.day\n\n    # Adjust day of asof:\n    if asof.day == 31:\n        # If asof day is 31, set it to 30\n        asof_day = 30\n    else:\n        asof_day = asof.day\n\n    # Construct new adjusted start and asof dates safely\n    start_adj = _construct_date(start.year, start.month, start_day)\n    asof_adj = _construct_date(asof.year, asof.month, asof_day)\n\n    # Calculate the number of days according to 30/360 German rules:\n    nod = (asof_adj.day - start_adj.day) + 30 * (asof_adj.month - start_adj.month) + 360 * (asof_adj.year - start_adj.year)\n\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 735\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 324, "prediction_id": 3, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\n\nfrom pypara.dcc import _construct_date, _is_last_day_of_month\n\n\ndef dcfc_30_360_german(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    # Adjust start date if it is the last day of its month: treat day as 30\n    start_day = 30 if _is_last_day_of_month(start) else start.day\n\n    # Adjust asof day\n    # If asof is last day of month and start day is 30 or 31, then set asof day to 30\n    if _is_last_day_of_month(asof):\n        if start_day in (30, 31):\n            asof_day = 30\n        else:\n            asof_day = asof.day\n    else:\n        asof_day = asof.day\n\n    # Construct adjusted asof date safely\n    asof_adj = _construct_date(asof.year, asof.month, asof_day)\n\n    # Compute number of days following 30E/360 German rules\n    nod = (asof_adj.day - start_day) + 30 * (asof_adj.month - start.month) + 360 * (asof_adj.year - start.year)\n\n    # Return day count fraction as Decimal, denominator 360\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 735\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 324, "prediction_id": 4, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\n\nfrom pypara.dcc import _construct_date, _is_last_day_of_month\n\n\ndef dcfc_30_360_german(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    start_day = start.day\n    asof_day = asof.day\n\n    # Adjust start date day if it is 31 -> 30\n    if start_day == 31:\n        start = _construct_date(start.year, start.month, 30)\n        start_day = 30\n\n    # For asof date:\n    # If asof day is 31 and start day is 30 or 31, set asof day to 30\n    if asof_day == 31:\n        if start_day in (30, 31):\n            asof = _construct_date(asof.year, asof.month, 30)\n            asof_day = 30\n\n    # Compute number of days according to 30/360 German:\n    nod = (asof_day - start_day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 735\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
