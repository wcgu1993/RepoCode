{"task_id": 310, "prediction_id": 0, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\nfrom pypara.dcc import _construct_date\nfrom .commons.zeitgeist import Date\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n\n    # Normalize frequency to int\n    freq = int(frequency)\n\n    # If asof is before start, last payment is start\n    if asof < start:\n        return start\n\n    # Determine months to add for each payment period\n    months_per_period = 12 // freq\n\n    # Start with the start date for the first payment\n    # We will increment in periods until we pass asof, last payment date is the last one <= asof\n    current_payment = start\n    while True:\n        # Calculate next payment date by adding months_per_period\n        next_year = current_payment.year\n        next_month = current_payment.month + months_per_period\n        while next_month > 12:\n            next_month -= 12\n            next_year += 1\n\n        # Day adjustment:\n        day = current_payment.day\n\n        # If eom is set and last payment date should be adjusted to EOM:\n        if eom is not None:\n            # If eom==1 means adjust to last day of month\n            if eom == 1:\n                # Get last day of the next month\n                last_day = calendar.monthrange(next_year, next_month)[1]\n                day = last_day\n            # Otherwise keep original day, adjusted safely\n\n        # Construct next payment date safely\n        next_payment = _construct_date(next_year, next_month, day)\n\n        # If next payment is after asof, current_payment is the last payment date\n        if next_payment > asof:\n            return current_payment\n\n        current_payment = next_payment", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 110, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 310, "prediction_id": 1, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nDate = datetime.date  # alias for clarity\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    # Normalize frequency to int\n    freq = int(frequency)\n\n    # The coupon months interval\n    months_interval = 12 // freq\n\n    # Extract start day\n    start_day = start.day\n\n    # We walk periods starting from start date (the first coupon date)\n    # and find the last coupon date <= asof\n    # Because coupons pay regularly every months_interval months\n\n    # Start from start's year and month:\n    year = start.year\n    month = start.month\n\n    # Calculate the number of whole periods from start to asof:\n    # Each period is months_interval months;\n    # We calculate how many such periods can fit to reach asof date or just before it.\n\n    # Calculate total months difference from start to asof:\n    total_months_diff = (asof.year - start.year) * 12 + (asof.month - start.month)\n\n    # Number of coupon periods since start that fit before or at 'asof':\n    periods = total_months_diff // months_interval\n\n    # The last payment date month is start.month + periods*months_interval\n    last_payment_month = start.month + periods * months_interval\n\n    # Adjust year and month properly:\n    year += (last_payment_month - 1) // 12\n    month = ((last_payment_month - 1) % 12) + 1\n\n    # If EOM adjustment is requested and start is EOM, then result should also be EOM\n    if eom is not None and eom != 0:\n        # Adjust day to last day of month if start is end of month or eom flag is set\n        from calendar import monthrange\n\n        # Check if start date is last day of month:\n        _, last_day_start_month = monthrange(start.year, start.month)\n        is_start_eom = start.day == last_day_start_month\n\n        if is_start_eom or eom == 1:\n            # Set day to last day of target month:\n            _, last_day_target = monthrange(year, month)\n            day = last_day_target\n        else:\n            day = start_day\n    else:\n        day = start_day\n\n    # Construct safely the final date (adjust day downward if exceeding month length)\n    last_payment = _construct_date(year, month, day)\n\n    # If the computed last_payment is after asof, move back one period:\n    if last_payment > asof:\n        # Go back one period\n        last_payment_month -= months_interval\n        year = start.year + (last_payment_month - 1) // 12\n        month = ((last_payment_month - 1) % 12) + 1\n\n        if eom is not None and eom != 0:\n            from calendar import monthrange\n\n            _, last_day_start_month = monthrange(start.year, start.month)\n            is_start_eom = start.day == last_day_start_month\n\n            if is_start_eom or eom == 1:\n                _, last_day_target = monthrange(year, month)\n                day = last_day_target\n            else:\n                day = start_day\n        else:\n            day = start_day\n\n        last_payment = _construct_date(year, month, day)\n\n    return last_payment", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1136, in <module>\n  File \"<string>\", line 1135, in test_86\nAssertionError\n", "passed": false}
{"task_id": 310, "prediction_id": 2, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\ndef _last_payment_date(start: datetime.date, asof: datetime.date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> datetime.date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    # Normalize frequency to int in months per year; frequency is payments per year\n    freq = int(frequency)  # safe because frequency is typically int or Decimal representing integer\n\n    # Edge case: if asof is before start, no payment has occurred yet - return start date as last payment\n    if asof < start:\n        return start\n\n    # Calculate number of months between payments\n    months_per_payment = 12 // freq  # assuming frequency divides 12 evenly\n    \n    # We want to find the last payment date <= asof starting from start, adding multiples of months_per_payment\n    \n    # Count how many full payment periods have passed since start to asof\n    # We do this by iteratively finding the number of months/years between dates\n    \n    # Compute number of months difference between start and asof\n    total_months = (asof.year - start.year) * 12 + (asof.month - start.month)\n\n    # Calculate which payment period we are currently in (zero-indexed)\n    period_index = total_months // months_per_payment\n\n    # Compute candidate payment date by adding period_index * months_per_payment to start date\n    payment_year = start.year + (start.month - 1 + period_index * months_per_payment) // 12\n    payment_month = ((start.month - 1 + period_index * months_per_payment) % 12) + 1\n    payment_day = start.day\n\n    # Adjust payment_day if eom (end of month) adjustment is specified\n    # The docstring does not specify behavior for eom clearly; since it's optional and not used anywhere else,\n    # we keep naive implementation without EOM adjustment.\n    #\n    # However, we must ensure the day is valid for the month: e.g. start.day = 31 but month only 30 days or february\n    # Use a safe way to construct the date.\n    # The context function _construct_date can be used to adjust days down if invalid, but we don't have the code, so \n    # we implement a local helper:\n    def safe_date(y, m, d):\n        # Try constructing date, if fails reduce day by 1 until valid\n        while d > 28:\n            try:\n                return datetime.date(y, m, d)\n            except ValueError:\n                d -= 1\n        # If d <= 28, guaranteed valid:\n        return datetime.date(y, m, d)\n\n    candidate_date = safe_date(payment_year, payment_month, payment_day)\n\n    # If candidate_date > asof, step back one period (payment before candidate_date)\n    if candidate_date > asof:\n        period_index -= 1\n        if period_index < 0:\n            # Before start date, so return start date itself (no payments before start)\n            return start\n        payment_year = start.year + (start.month - 1 + period_index * months_per_payment) // 12\n        payment_month = ((start.month - 1 + period_index * months_per_payment) % 12) + 1\n        candidate_date = safe_date(payment_year, payment_month, payment_day)\n\n    return candidate_date", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1097, in <module>\n  File \"<string>\", line 1096, in test_86\nAssertionError\n", "passed": false}
{"task_id": 310, "prediction_id": 3, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nDate = datetime.date  # Alias to match expected type\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\ndef _last_payment_date(\n    start: Date,\n    asof: Date,\n    frequency: Union[int, Decimal],\n    eom: Optional[int] = None,\n) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    # Normalize frequency to int (quarterly frequency = 4 means every 3 months)\n    freq = int(frequency)\n    # Compute months between payments\n    months_per_period = 12 // freq\n\n    # Starting payment anchor date (initial payment date)\n    anchor_day = start.day\n\n    # If eom (end of month) flag is set and start date is last day of month, \n    # we fix anchor day as start date day and treat month ends accordingly\n    eom_flag = False\n    if eom is not None:\n        eom_flag = bool(eom)\n    else:\n        # Infer eom if start is last day of the month\n        import calendar\n        eom_flag = start.day == calendar.monthrange(start.year, start.month)[1]\n\n    # Initialize variable for search\n    candidate = start\n\n    # We try to find the latest date on the coupon cycle from start up to asof (inclusive)\n    while True:\n        # Compute next coupon date candidate by adding months_per_period to candidate\n        year, month = candidate.year, candidate.month + months_per_period\n\n        # Adjust year and month to proper range\n        while month > 12:\n            month -= 12\n            year += 1\n\n        # If eom_flag is True, set day as last day of that month\n        if eom_flag:\n            import calendar\n\n            day = calendar.monthrange(year, month)[1]\n        else:\n            # Use the anchor day but adjust if day is invalid for month\n            day = anchor_day\n\n        next_payment = _construct_date(year, month, day)\n\n        # If next payment is after asof, break, candidate is the last valid\n        if next_payment > asof:\n            break\n\n        candidate = next_payment\n\n    return candidate", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1297, in <module>\n  File \"<string>\", line 1296, in test_11\nAssertionError\n", "passed": false}
{"task_id": 310, "prediction_id": 4, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\ndef _last_payment_date(start: datetime.date, asof: datetime.date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> datetime.date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    # Convert frequency to int if Decimal\n    freq = int(frequency)\n\n    # If asof < start, last payment date cannot be before start, so return start\n    if asof < start:\n        return start\n\n    # Months between coupon payments\n    months_between = 12 // freq\n\n    # Calculate how many full periods have elapsed from start up to asof (or slightly after)\n    # We'll increment by months_between until exceeding asof, then step back once\n\n    # Start with the initial coupon date (start)\n    # To accommodate potential EOM adjustments, we will track day and use a safe construction approach.\n\n    start_year = start.year\n    start_month = start.month\n    start_day = start.day\n\n    # If eom is provided and is truthy (typically 1), when start was an EOM date,\n    # payments are adjusted to month-end.\n    # We consider that if eom is set and start is last day of month, then payments always fall on month-end.\n\n    def _is_last_day_of_month(date: datetime.date) -> bool:\n        import calendar\n        return date.day == calendar.monthrange(date.year, date.month)[1]\n\n    eom_flag = bool(eom) and _is_last_day_of_month(start)\n\n    # Use _construct_date to safely create dates, defined here:\n    def _construct_date(year: int, month: int, day: int) -> datetime.date:\n        if year <= 0 or month <= 0 or day <= 0:\n            raise ValueError(\"year, month and day must be greater than 0.\")\n        try:\n            return datetime.date(year, month, day)\n        except ValueError as exc:\n            if str(exc) == \"day is out of range for month\":\n                return _construct_date(year, month, day - 1)\n            else:\n                raise exc\n\n    # Count how many full coupon periods (in months_between) have passed since start up to asof\n    # We'll use relativedelta from dateutil to compute months difference precisely, but since\n    # we cannot import it (based on instructions), we calculate manually:\n\n    # Calculate the number of whole months between start and asof:\n    months_diff = (asof.year - start_year) * 12 + (asof.month - start_month)\n    # If asof.day < start.day, we consider that last payment not reached full month yet\n    # so decrease months_diff by 1 if day of asof < day of start to mimic half-month behavior\n    if asof.day < start_day:\n        months_diff -= 1\n\n    # Number of coupon periods elapsed (floored)\n    periods_elapsed = max(0, months_diff // months_between)\n\n    # Calculate last payment date by adding periods_elapsed * months_between months to start\n    total_months = start_month + periods_elapsed * months_between\n    year_increment = (total_months - 1) // 12\n    payment_year = start_year + year_increment\n    payment_month = ((total_months - 1) % 12) + 1\n\n    # Determine payment day\n    if eom_flag:\n        # Payment day is last day of month\n        import calendar\n        payment_day = calendar.monthrange(payment_year, payment_month)[1]\n    else:\n        payment_day = start_day\n\n    last_payment_date = _construct_date(payment_year, payment_month, payment_day)\n\n    # Edge case: if last_payment_date > asof, step back one coupon period\n    if last_payment_date > asof:\n        periods_elapsed -= 1\n        if periods_elapsed < 0:\n            # This can happen if asof < start, but we handled that above\n            return start\n        total_months = start_month + periods_elapsed * months_between\n        year_increment = (total_months - 1) // 12\n        payment_year = start_year + year_increment\n        payment_month = ((total_months - 1) % 12) + 1\n\n        if eom_flag:\n            import calendar\n            payment_day = calendar.monthrange(payment_year, payment_month)[1]\n        else:\n            payment_day = start_day\n\n        last_payment_date = _construct_date(payment_year, payment_month, payment_day)\n\n    return last_payment_date", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1132, in <module>\n  File \"<string>\", line 1131, in test_86\nAssertionError\n", "passed": false}
