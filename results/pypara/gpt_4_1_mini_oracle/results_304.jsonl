{"task_id": 304, "prediction_id": 0, "generation": "from decimal import Decimal\nfrom typing import Iterable, Optional, TypeVar, cast\n\nDecimalLike = TypeVar(\"DecimalLike\", bound=Decimal)\nZERO = Decimal(\"0\")\n\ndef isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    it = iter(xs)\n    if start is not None:\n        total: DecimalLike = start\n    else:\n        # if xs is empty, return ZERO cast to DecimalLike to match type signature\n        try:\n            first = next(it)\n        except StopIteration:\n            return cast(DecimalLike, ZERO)\n        total = first\n    # if start was provided, total is start, else total is first element already consumed\n\n    for x in it:\n        total += x\n\n    return total", "message": "passed", "passed": true}
{"task_id": 304, "prediction_id": 1, "generation": "from decimal import Decimal\nfrom typing import Iterable, Optional, TypeVar, cast\n\nDecimalLike = TypeVar(\"DecimalLike\", bound=Decimal)\nZERO = Decimal(\"0\")\n\ndef isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    it = iter(xs)\n    if start is not None:\n        total = start\n    else:\n        # Try to get first element to determine type, or default to Decimal ZERO\n        try:\n            first = next(it)\n        except StopIteration:\n            # Empty iterable with no start -> return Decimal ZERO casted to DecimalLike\n            return cast(DecimalLike, ZERO)\n        else:\n            total = first\n    # Sum remaining elements\n    for x in it:\n        total += x\n    return total", "message": "passed", "passed": true}
{"task_id": 304, "prediction_id": 2, "generation": "from decimal import Decimal\nfrom typing import Iterable, Optional, TypeVar, cast\n\nDecimalLike = TypeVar(\"DecimalLike\", bound=Decimal)\n\nZERO = Decimal(\"0\")\n\ndef isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    it = iter(xs)\n    try:\n        first = next(it)\n    except StopIteration:\n        # No elements: return start or ZERO cast to DecimalLike\n        if start is None:\n            return cast(DecimalLike, ZERO)\n        else:\n            return start\n    # Determine initial sum: use start if given, else first element\n    if start is not None:\n        total = start + first  # type: ignore\n    else:\n        total = first\n    for x in it:\n        total += x  # type: ignore\n    return total", "message": "passed", "passed": true}
{"task_id": 304, "prediction_id": 3, "generation": "from decimal import Decimal\nfrom typing import Iterable, Optional, TypeVar, cast\n\nDecimalLike = TypeVar(\"DecimalLike\", bound=Decimal)\nZERO = Decimal(\"0\")\n\ndef isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    if start is None:\n        # If xs is empty, we must still return ZERO but cast to DecimalLike\n        # Try to get one element's type from xs to cast ZERO accordingly.\n        # However, we can't consume xs without losing it, so we will:\n        # - Convert xs to iterator\n        # - Try to get first element\n        # - If no elements, return cast ZERO\n        it = iter(xs)\n        try:\n            first = next(it)\n        except StopIteration:\n            return cast(DecimalLike, ZERO)\n        else:\n            total = first\n            for x in it:\n                total += x\n            return total\n    else:\n        total = start\n        for x in xs:\n            total += x\n        return total", "message": "passed", "passed": true}
{"task_id": 304, "prediction_id": 4, "generation": "from typing import Iterable, Optional, TypeVar, cast\nfrom decimal import Decimal\n\nDecimalLike = TypeVar(\"DecimalLike\", bound=Decimal)\nZERO = Decimal(\"0\")\n\ndef isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    # Determine the start value - if not provided, default to ZERO casted to DecimalLike\n    if start is None:\n        total: DecimalLike = cast(DecimalLike, ZERO)\n    else:\n        total = start\n    for x in xs:\n        total += x  # type: ignore[assignment] to allow adding DecimalLikes\n    return total", "message": "passed", "passed": true}
