{"task_id": 314, "prediction_id": 0, "generation": "import datetime\nfrom decimal import Decimal\n\nfrom pypara.dcc import _get_date_range\n\ndef dcfc_act_act(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Decimal = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    # Early check: if asof is before start or after end, fraction is zero\n    if asof < start or asof > end:\n        return Decimal('0')\n    # Adjust the end date for calculation segment (\"asof\" is the current date we calculate to)\n    calc_end = asof\n\n    # Initialize total fraction accumulator\n    total_fraction = Decimal('0')\n\n    # We will sum fractions over each calendar year segment overlapping [start, calc_end]\n    current_start = start\n\n    # Iterate over dates from start until calc_end using _get_date_range to break by day\n    # But to optimize, we'll break the period by year boundaries\n\n    while current_start < calc_end:\n        start_year = current_start.year\n        # Year-end date for this segment - Dec 31 of current_start's year\n        year_end = datetime.date(start_year, 12, 31)\n        # Segment end is minimum of calc_end and year_end + 1 day (since end is exclusive for _get_date_range)\n        segment_end = min(calc_end, year_end)\n\n        # Compute actual days in segment: from current_start to segment_end (inclusive)\n        # Number of days = (segment_end - current_start) + 1\n        actual_days = Decimal((segment_end - current_start).days + 1)\n\n        # Determine if year is leap year\n        days_in_year = Decimal(366 if calendar.isleap(start_year) else 365)\n\n        # Accumulate fraction for this segment: actual_days / days_in_year\n        total_fraction += actual_days / days_in_year\n\n        # Move to next segment starting the day after segment_end\n        current_start = segment_end + datetime.timedelta(days=1)\n\n    return total_fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 419\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 314, "prediction_id": 1, "generation": "import datetime\nfrom decimal import Decimal\n\nfrom pypara.dcc import _get_date_range, _has_leap_day, _get_actual_day_count\n\ndef dcfc_act_act(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Decimal = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    # The ISDA Act/Act day count fraction is computed by summing fractions over calendar years,\n    # where days in each year are divided by 366 if leap year and 365 otherwise.\n    # When frequency is None, treat as ISDA standard Act/Act.\n\n    if not (start <= asof <= end):\n        return Decimal(0)\n\n    # Convert dates to datetime.date for safety if needed:\n    s = start\n    a = asof\n    e = end\n\n    total_fraction = Decimal(0)\n\n    # Iterate over each year part in the [start, asof] interval\n    current_start = s\n    while current_start < a:\n        # Define period end as min(next Jan 1 or asof+1 day, asof+1) to cover days until asof inclusive\n        year_end = datetime.date(current_start.year + 1, 1, 1)\n        # The sub period end is the minimum of year_end and a+1 (to include asof day)\n        period_end = min(year_end, a + datetime.timedelta(days=1))\n\n        # Compute actual day count in this sub-period\n        actual_days = (period_end - current_start).days\n\n        # Determine denominator: 366 if leap year else 365\n        denominator = Decimal(366) if calendar.isleap(current_start.year) else Decimal(365)\n\n        total_fraction += Decimal(actual_days) / denominator\n\n        current_start = period_end\n\n    return total_fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 419\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 314, "prediction_id": 2, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\n\nfrom pypara.dcc import _get_date_range\nfrom pypara.commons.zeitgeist import Date\nfrom pypara.commons.numbers import ONE, ZERO\n\n\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    if not start <= asof <= end:\n        return ZERO\n\n    # Sum of day fractions for each day in [start, asof)\n    total_fraction = Decimal(0)\n\n    # Iterate each day from start up to asof (excluding asof)\n    for day in _get_date_range(start, asof):\n        year = day.year\n        # Determine if leap year\n        days_in_year = 366 if calendar.isleap(year) else 365\n        # Add 1/days_in_year fraction for this day\n        total_fraction += ONE / Decimal(days_in_year)\n\n    return total_fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 419\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 314, "prediction_id": 3, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\nfrom pypara.commons.zeitgeist import Date\nfrom pypara.dcc import _get_date_range\n\n\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    # Ensure parameters are consistent, the actual fraction is calculated from start to asof\n    if not (start <= asof <= end):\n        return Decimal(\"0\")\n\n    total_fraction = Decimal(\"0\")\n\n    # Iterate over each day in the [start, asof) period using the helper _get_date_range (end exclusive)\n    # For each day, determine if it is in a leap year or not, then add 1/366 or 1/365 accordingly.\n    # But rather than per day, we group contiguous days in the same year to optimize.\n\n    current_date = start\n    while current_date < asof:\n        year = current_date.year\n        # End of current year or asof whichever is earlier to close the chunk\n        year_end = datetime.date(year, 12, 31)\n        chunk_end = min(year_end, asof - datetime.timedelta(days=1))\n\n        # Count days in this chunk (inclusive)\n        days_in_chunk = (chunk_end - current_date).days + 1\n\n        # Determine denominator based on leap year\n        denominator = Decimal(366 if calendar.isleap(year) else 365)\n\n        # Add fraction for this chunk\n        total_fraction += Decimal(days_in_chunk) / denominator\n\n        # Move current_date past this chunk\n        current_date = chunk_end + datetime.timedelta(days=1)\n\n    return total_fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 419\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 314, "prediction_id": 4, "generation": "import calendar\nimport datetime\nfrom decimal import Decimal, getcontext\n\nfrom pypara.dcc import _get_date_range\n\ndef dcfc_act_act(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Decimal = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n\n    # Ensure we have enough precision in Decimal operations\n    getcontext().prec = 28\n\n    # Validate input ordering\n    if not (start <= asof <= end):\n        return Decimal(\"0\")\n\n    total_fraction = Decimal(\"0\")\n    current_start = start\n\n    # Iterate through each year spanned by the range [start, asof)\n    # We partition the period into full or partial years and calculate\n    # the fraction of days in each segment divided by the length of that \"year\"\n    while current_start < asof:\n        # Determine the year boundary (end of the current year)\n        year_end = datetime.date(current_start.year, 12, 31)\n        segment_end = min(asof, year_end + datetime.timedelta(days=1))  # Inclusive end date for segment\n\n        # Number of days in this segment\n        days_in_segment = (segment_end - current_start).days\n\n        # Determine if this year is leap year and set denominator accordingly\n        days_in_year = 366 if calendar.isleap(current_start.year) else 365\n\n        # Add fraction for this segment\n        fraction = Decimal(days_in_segment) / Decimal(days_in_year)\n        total_fraction += fraction\n\n        # Move current_start to segment_end to process next segment\n        current_start = segment_end\n\n    return total_fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 419\n    import calendar\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
