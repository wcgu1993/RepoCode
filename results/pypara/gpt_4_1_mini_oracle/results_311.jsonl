{"task_id": 311, "prediction_id": 0, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom .commons.zeitgeist import Date\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Safely constructs a date object, fixing day if out of range for the given month/year.\n    \"\"\"\n    try:\n        return datetime.date(year, month, day)\n    except ValueError:\n        # If day is out of range (e.g., 30 Feb), adjust to last day of month:\n        last_day = calendar.monthrange(year, month)[1]\n        return datetime.date(year, month, last_day)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the next coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    # Ensure eom (end of month) day to use:\n    eom = eom or start.day\n\n    # Calculate the period months from frequency\n    period = int(12 / frequency)\n\n    # Calculate the next payment year and month:\n    year = start.year\n    month = start.month + period\n\n    # Adjust year and month if month > 12\n    while month > 12:\n        month -= 12\n        year += 1\n\n    # Construct and return the next payment date\n    return _construct_date(year, month, eom)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 173, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 311, "prediction_id": 1, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom .commons.zeitgeist import Date\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Safely constructs a date, adjusting day if it exceeds the month's last day.\n    \"\"\"\n    import calendar\n\n    last_day = calendar.monthrange(year, month)[1]\n    day = min(day, last_day)\n    return datetime.date(year, month, day)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the next coupon payment date.\n\n    The next payment date is calculated based on the `start` date and the payment `frequency`\n    (number of payments per year). `eom` (end of month day) defines the day of payment in the month;\n    if not provided, defaults to the day of `start`.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    eom = eom or start.day\n    freq = int(frequency)  # ensure frequency is int\n    \n    # Period months between payments\n    period = int(12 / freq)\n\n    # Starting month and year\n    s_month = start.month\n    s_year = start.year\n\n    # Payment schedule months within a year based on frequency and start month\n    schedule = sorted([i if i > 0 else 12 for i in sorted([(s_month + i) % 12 for i in range(0, 12, period)])])\n\n    # We want to find the next payment date after the start date + 1 period roughly.\n\n    # Construct a base candidate date as start shifted by one full period month:\n    # But to do this, we add one period to start date's month and keep day as eom.\n    # If day is beyond month end, adjust by _construct_date.\n\n    # Calculate candidate month and year\n    candidate_month = s_month + period\n    candidate_year = s_year\n    if candidate_month > 12:\n        candidate_month -= 12\n        candidate_year += 1\n\n    # Construct candidate date with eom as day\n    candidate_date = _construct_date(candidate_year, candidate_month, eom)\n\n    return candidate_date", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 173, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 311, "prediction_id": 2, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom .commons.zeitgeist import Date\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Safely constructs a date, adjusting the day if it is out of range for the given month/year.\n    \"\"\"\n    from calendar import monthrange\n\n    last_day = monthrange(year, month)[1]\n    day = min(day, last_day)\n    return datetime.date(year, month, day)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the next coupon payment date after the start date, based on the given frequency and\n    optionally the end-of-month day value.\n\n    :param start: The start date of the period.\n    :param frequency: The number of coupon payments per year (e.g. 1 for yearly, 2 for semiannual).\n    :param eom: Optional day of month for the coupon payment date. Defaults to start.day if None.\n    :return: The next coupon payment date as a date object.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    eom = eom or start.day\n    frequency = int(frequency)  # Ensure frequency is int for division\n\n    # Compute period in months between payments\n    period_months = 12 // frequency\n\n    # Calculate the next payment date by adding period_months repeatedly until > start\n    year = start.year\n    month = start.month\n    day = eom\n\n    # We will step through candidate dates by adding period_months, starting from start's month\n    # Find the next payment date strictly after start\n    while True:\n        month += period_months\n        # Adjust year and month if month > 12\n        while month > 12:\n            month -= 12\n            year += 1\n\n        candidate_date = _construct_date(year, month, day)\n        if candidate_date > start:\n            return candidate_date", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 173, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 311, "prediction_id": 3, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom .commons.zeitgeist import Date\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Safely constructs a date, adjusting the day if it exceeds the number of days in the month.\n    \"\"\"\n    last_day = (datetime.date(year, month, 1) + relativedelta(months=1, days=-1)).day\n    day = min(day, last_day)\n    return datetime.date(year, month, day)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the next coupon payment date after `start` assuming payments occur \n    at intervals defined by `frequency` per year.\n\n    :param start: The start date of the coupon schedule.\n    :param frequency: Number of coupon payments per year.\n    :param eom: The day of month for the payment date (end of month if None).\n    :return: The next payment date after `start`.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    # Determine the day of month for payments\n    day = eom if eom is not None else start.day\n\n    # Calculate months per period based on frequency\n    months_per_period = int(12 / frequency)\n\n    # Calculate next payment date by adding one full period from start date\n    next_date = start + relativedelta(months=+months_per_period)\n\n    # Adjust the day safely; if the adjusted day exceeds month's last day, clamp to last day\n    next_payment = _construct_date(next_date.year, next_date.month, day)\n\n    return next_payment", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 175, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 311, "prediction_id": 4, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional, Union\n\nfrom .commons.zeitgeist import Date  # Assuming Date is from this import\nfrom dateutil.relativedelta import relativedelta\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Safely construct a date, clamping day to the last day of the month if needed.\n    \"\"\"\n    import calendar\n\n    last_day = calendar.monthrange(year, month)[1]\n    day = min(day, last_day)\n    return datetime.date(year, month, day)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the next coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    # Frequency is expected as number of payments per year, so interval months = 12 / frequency\n    freq = int(frequency)\n\n    # Determine the day of month for payment\n    eom = eom or start.day\n\n    payment_interval = 12 // freq  # months per period\n\n    # Start from start date's year and month:\n    year = start.year\n    month = start.month\n\n    # We want the next payment date > start\n    # Iterate adding payment_interval months until date > start\n\n    # Initial candidate date\n    # If start is 2014-01-01 and freq=1 and eom=None, next payment is 2015-01-01 (one year after)\n\n    # To do it efficiently, compute how many periods (N) have passed since start till candidate payment\n    # and compute candidate from that.\n\n    # We'll use relativedelta to add months.\n\n    # Start with candidate = start + payment_interval months but eom day\n\n    # If the day of start itself is after eom day, the next payment is next interval\n    # But problem statement example suggests next payment date after the start date, on eom day, incrementing intervals accordingly.\n\n    # Let's calculate how many full intervals have elapsed + 1 for next payment\n\n    # The nearest payment date should be the first payment date after start where day = eom\n\n    # We'll calculate months difference for day offset and then increment.\n\n    # Since payments occur every payment_interval months starting at start date day (or eom), payments happen at months:\n    # start.month + k * payment_interval, with day = eom\n\n    # Let's find the smallest k > 0 such that the payment date > start\n\n    k = 1\n    while True:\n        month_shift = payment_interval * k\n        candidate_month = (month - 1 + month_shift) % 12 + 1\n        candidate_year = year + ((month - 1 + month_shift) // 12)\n        candidate = _construct_date(candidate_year, candidate_month, eom)\n        if candidate > start:\n            return candidate\n        k += 1", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 173, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
