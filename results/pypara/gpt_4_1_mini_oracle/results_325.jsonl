{"task_id": 325, "prediction_id": 0, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\n\ndef dcfc_30_360_us(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    d1 = start.day\n    d2 = asof.day\n\n    # Adjust start day\n    if d1 == 31:\n        d1 = 30\n\n    # Adjust asof day according to US 30/360 rules\n    if d2 == 31:\n        if d1 < 30:\n            d2 = 1\n            # increment month and possibly year for asof\n            if asof.month == 12:\n                asof = asof.replace(year=asof.year + 1, month=1)\n            else:\n                asof = asof.replace(month=asof.month + 1)\n        else:\n            d2 = 30\n\n    # Calculate number of days according to 30/360 US rules\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 777\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 325, "prediction_id": 1, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\n\ndef dcfc_30_360_us(start: datetime.date, asof: datetime.date, end: datetime.date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    # Adjustments for start.day\n    d1 = start.day\n    if d1 == 31:\n        d1 = 30\n\n    # Adjustments for asof.day\n    d2 = asof.day\n    if d2 == 31:\n        # If start.day < 30, set d2 to 1 and increment month by 1 (rollover)\n        # Otherwise, set d2 to 30\n        if d1 < 30:\n            d2 = 1\n            # Increase month, and adjust year if needed\n            new_month = asof.month + 1\n            new_year = asof.year\n            if new_month > 12:\n                new_month = 1\n                new_year += 1\n            asof = datetime.date(new_year, new_month, d2)\n        else:\n            d2 = 30\n\n    # Calculate the number of days according to 30/360 US convention rules\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 777\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 325, "prediction_id": 2, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\n\nfrom pypara.dcc import _is_last_day_of_month\nfrom pypara.commons.zeitgeist import Date\n\n\ndef dcfc_30_360_us(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    d1 = start.day\n    d2 = asof.day\n\n    # Following 30/360 US (NASD) conventions:\n    if d1 == 31:\n        d1 = 30\n\n    if d2 == 31:\n        if d1 < 30:\n            d2 = 1\n            if asof.month == 12:\n                # Roll to next year January 1\n                asof = datetime.date(asof.year + 1, 1, d2)\n            else:\n                asof = datetime.date(asof.year, asof.month + 1, d2)\n        else:\n            d2 = 30\n\n    # Calculate number of days\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 777\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 325, "prediction_id": 3, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\nfrom pypara.commons.zeitgeist import Date\n\ndef dcfc_30_360_us(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    d1 = start.day\n    d2 = asof.day\n\n    # Adjustments for start date day\n    if d1 == 31:\n        d1 = 30\n\n    # Adjustments for asof date day\n    if d2 == 31:\n        if d1 < 30:\n            d2 = 1\n            asof_month = asof.month + 1\n            asof_year = asof.year\n            if asof_month == 13:\n                asof_month = 1\n                asof_year += 1\n            try:\n                asof = datetime.date(asof_year, asof_month, d2)\n            except ValueError:\n                # If the next month does not have that day, use the last day of that month\n                last_day = datetime.date(asof_year, asof_month, 1) - datetime.timedelta(days=1)\n                asof = datetime.date(asof_year, asof_month, last_day.day)\n                d2 = last_day.day\n        else:\n            d2 = 30\n\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 777\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 325, "prediction_id": 4, "generation": "from decimal import Decimal\nimport datetime\n\ndef dcfc_30_360_us(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    # Day adjustments according to 30/360 US (NASD) convention:\n    d1 = start.day\n    d2 = asof.day\n\n    # Adjustments for start day:\n    if d1 == 31:\n        d1 = 30\n\n    # Adjustments for asof day:\n    if d2 == 31:\n        if d1 < 30:\n            d2 = 1\n            # increment asof month/year accordingly\n            if asof.month == 12:\n                asof = datetime.date(asof.year + 1, 1, d2)\n            else:\n                asof = datetime.date(asof.year, asof.month + 1, d2)\n        else:\n            d2 = 30\n\n    # Calculate number of days difference per 30/360 US\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    return Decimal(nod) / Decimal(360)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 777\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
