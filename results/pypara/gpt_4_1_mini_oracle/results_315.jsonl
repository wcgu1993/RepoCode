{"task_id": 315, "prediction_id": 0, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\n\nfrom .commons.zeitgeist import Date\nfrom .dcc import _get_actual_day_count\n\n\ndef dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    # The Act/Act (ICMA) method calculates fraction as:\n    #\n    # fraction = elapsed_days / (period_days * number_of_periods_in_year)\n    #\n    # where period_days = actual number of days between start and end,\n    # and number_of_periods_in_year = frequency (default assumed 1 if not provided).\n\n    if freq is None:\n        freq = Decimal(1)\n\n    elapsed_days = _get_actual_day_count(start, asof)\n    period_days = _get_actual_day_count(start, end)\n\n    if period_days == 0:\n        return Decimal(0)\n\n    # Fraction is the ratio of elapsed days to period length, divided by number of periods per year (freq).\n    # This corresponds to (elapsed_days / period_days) / freq\n\n    fraction = Decimal(elapsed_days) / Decimal(period_days) / freq\n    return fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 463\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 315, "prediction_id": 1, "generation": "from decimal import Decimal\nimport datetime\nfrom typing import Optional\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom .commons.zeitgeist import Date\nfrom .dcc import _get_actual_day_count, _construct_date\n\n\ndef dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    # Step 1: Determine frequency per year (default to 2 if None)\n    frequency = int(freq) if freq else 2\n\n    # Step 2: Calculate the previous coupon date relative to 'asof'\n    period_months = 12 // frequency\n\n    # Compute the last coupon date (payment date) before or on 'asof' starting from 'start'\n    # This replicates _last_payment_date but here done inline\n    eom = start.day\n    s_month = start.month\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period_months)])])\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n    if future:\n        p_year, p_month = c_year, future[-1]\n    else:\n        p_year, p_month = c_year - 1, schedule[-1]\n    prev_coupon_date = _construct_date(p_year, p_month, eom)\n\n    # Step 3: Calculate the next coupon date after the previous coupon date\n    next_coupon_month = prev_coupon_date.month + period_months\n    next_coupon_year = prev_coupon_date.year\n    if next_coupon_month > 12:\n        next_coupon_month -= 12\n        next_coupon_year += 1\n    # Construct next coupon date similarly to _construct_date with end of month adjustment\n    try:\n        next_coupon_date = datetime.date(next_coupon_year, next_coupon_month, eom)\n    except ValueError:\n        # If invalid day (e.g., Feb 30), back off day by one until valid\n        next_coupon_date = _construct_date(next_coupon_year, next_coupon_month, eom)\n\n    # Step 4: Calculate the actual day count days between prev_coupon_date and next_coupon_date\n    coupon_period_days = Decimal(_get_actual_day_count(prev_coupon_date, next_coupon_date))\n\n    # Step 5: Calculate the actual day count days between prev_coupon_date and asof\n    accrued_days = Decimal(_get_actual_day_count(prev_coupon_date, asof))\n\n    # Step 6: Day count fraction = accrued_days / coupon_period_days\n    if coupon_period_days == 0:\n        return Decimal('0')\n    return accrued_days / coupon_period_days", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 463\n    from decimal import Decimal\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 315, "prediction_id": 2, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\n\nfrom .commons.zeitgeist import Date\nfrom .dcc import _get_actual_day_count\n\n\ndef dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    # Ensure input dates are ordered\n    if not (start <= asof <= end):\n        return Decimal(0)\n\n    # Total length of the coupon period in days\n    coupon_period_length = Decimal(_get_actual_day_count(start, end))\n\n    # Length from start to asof in days\n    period_to_asof = Decimal(_get_actual_day_count(start, asof))\n\n    # If frequency not specified, attempt to derive frequency (fallback to 1)\n    # But since freq is not stated as required, just use coupon period length for denominator\n    # The formula: DCF = (actual days from start to asof) / (actual days in coupon period)\n\n    if coupon_period_length == 0:\n        # Avoid division by zero, return zero fraction\n        return Decimal(0)\n\n    fraction = period_to_asof / coupon_period_length\n\n    return fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 463\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 315, "prediction_id": 3, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\n\nfrom .commons.zeitgeist import Date\nfrom .dcc import _get_actual_day_count\n\n\ndef dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    # Ensure frequency is provided; Act/Act (ICMA) requires coupon frequency.\n    if freq is None:\n        raise ValueError(\"Frequency must be provided for Act/Act (ICMA) day count fraction calculation.\")\n\n    freq_int = int(freq)\n\n    # Calculate the last coupon payment date before or equal to 'asof'\n    prev_coupon_date = _last_payment_date(start, asof, freq_int)\n\n    # Calculate the next coupon payment date after 'prev_coupon_date'\n    next_coupon_date = _next_payment_date(prev_coupon_date, freq_int)\n\n    # Calculate day counts of sub-periods\n    # Days between prev_coupon_date and next_coupon_date (coupon period length)\n    coupon_period_days = _get_actual_day_count(prev_coupon_date, next_coupon_date)\n\n    # Days between prev_coupon_date and asof (accrued days)\n    accrued_days = _get_actual_day_count(prev_coupon_date, asof)\n\n    # Days between asof and end (remaining period)\n    remaining_days = _get_actual_day_count(asof, end)\n\n    # Handle edge case: if end equals next_coupon_date, count the last coupon period fraction as 1\n    if end == next_coupon_date:\n        # Fraction is accrued_days / coupon_period_days + full coupon periods after asof\n        # But since asof <= end and end == next_coupon_date, fraction just accrued_days / coupon_period_days\n        # The fraction to the end date is simply accrued days divided by coupon length.\n        fraction = Decimal(accrued_days) / Decimal(coupon_period_days)\n        return fraction\n\n    # If asof >= end, fraction is zero or 1 depending\n    if asof >= end:\n        return Decimal(_get_actual_day_count(start, end)) / Decimal(coupon_period_days)\n\n    # Calculate whole number of full coupon periods between asof and end\n    # This uses coupon frequency per year, so calculate the number of full coupon periods\n    # between asof and end by counting months or years difference\n    # The frequency is coupons per year, so months per coupon:\n    months_per_coupon = 12 // freq_int\n\n    # Find the next schedule date after 'asof' that aligns coupon periods\n    # Use start date as anchor for schedule\n    current_coupon_date = prev_coupon_date\n    full_periods = 0\n    while True:\n        next_date = _next_payment_date(current_coupon_date, freq_int)\n        if next_date < end:\n            full_periods += 1\n            current_coupon_date = next_date\n        else:\n            break\n\n    # Calculate the fraction as:\n    # (Days accrued in current coupon period) / (Days in coupon period)\n    # + (Number of whole coupon periods between asof and end)\n    # + (Days from last coupon period start to end) / (Days in coupon period)\n    # Calculate days in last fractional period:\n    last_fractional_start = current_coupon_date\n    last_fractional_days = _get_actual_day_count(last_fractional_start, end)\n    last_fractional_fraction = Decimal(last_fractional_days) / Decimal(coupon_period_days)\n\n    fraction = Decimal(accrued_days) / Decimal(coupon_period_days) + Decimal(full_periods) + last_fractional_fraction\n\n    return fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 463\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 315, "prediction_id": 4, "generation": "import datetime\nfrom decimal import Decimal\nfrom typing import Optional\n\nfrom .commons.zeitgeist import Date\nfrom .dcc import _get_actual_day_count\nfrom .monetary import Money\n\n\ndef dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    # Total number of days in the coupon period (start to end)\n    total_days = Decimal(_get_actual_day_count(start, end))\n    if total_days == 0:\n        return Decimal('0')\n\n    # Number of days accrued up to 'asof' (start to asof)\n    accrued_days = Decimal(_get_actual_day_count(start, asof))\n\n    # The fraction is the ratio of accrued days to total coupon period days\n    fraction = accrued_days / total_days\n    return fraction", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 463\n    import datetime\n    ^^^^^^\nSyntaxError: invalid syntax\n", "passed": false}
