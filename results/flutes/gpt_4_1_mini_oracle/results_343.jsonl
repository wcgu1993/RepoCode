{"task_id": 343, "prediction_id": 0, "generation": "from typing import Callable, Iterable, Iterator, List, Optional, TypeVar, Union\n\nA = TypeVar('A')\n\ndef split_by(iterable: Iterable[A], empty_segments: bool = False, *, criterion: Optional[Callable[[A], bool]] = None, separator: Optional[A] = None) \\\n        -> Iterator[List[A]]:\n    r\"\"\"Split a list into sub-lists by dropping certain elements. Exactly one of ``criterion`` and ``separator`` must be\n    specified. For example:\n\n    .. code:: python\n\n    >>> list(split_by(range(10), criterion=lambda x: x % 3 == 0))\n    [[1, 2], [4, 5], [7, 8]]\n\n    >>> list(split_by(\" Split by: \", empty_segments=True, separator='.'))\n    [[], ['S', 'p', 'l', 'i', 't'], ['b', 'y', ':'], []]\n\n    :param iterable: The list to split.\n    :param empty_segments: If ``True``, include an empty list in cases where two adjacent elements satisfy\n    the criterion.\n    :param criterion: The criterion to decide whether to drop an element.\n    :param separator: The separator for sub-lists. An element is dropped if it is equal to ``parameter``.\n    :return: List of sub-lists.\n    \"\"\"\n    if (criterion is None) == (separator is None):\n        # Both are None or both are set, invalid usage\n        raise ValueError(\"Exactly one of 'criterion' or 'separator' must be specified\")\n\n    if separator is not None:\n        def pred(x: A) -> bool:\n            return x == separator\n    else:\n        pred = criterion\n\n    segment: List[A] = []\n    for elem in iterable:\n        if pred(elem):\n            # Element matches the split condition, so yield current segment and start new one\n            if segment or empty_segments:\n                yield segment\n            segment = []\n        else:\n            segment.append(elem)\n\n    # Yield the last segment after finishing iteration\n    if segment or empty_segments:\n        yield segment", "message": "passed", "passed": true}
{"task_id": 343, "prediction_id": 1, "generation": "from typing import Iterable, Iterator, List, Optional, TypeVar, Callable\n\nA = TypeVar('A')\n\ndef split_by(iterable: Iterable[A], empty_segments: bool = False, *, criterion: Optional[Callable[[A], bool]] = None, separator: Optional[A] = None) \\\n        -> Iterator[List[A]]:\n    r\"\"\"Split a list into sub-lists by dropping certain elements. Exactly one of ``criterion`` and ``separator`` must be\n    specified. For example:\n\n    .. code:: python\n\n    >>> list(split_by(range(10), criterion=lambda x: x % 3 == 0))\n    [[1, 2], [4, 5], [7, 8]]\n\n    >>> list(split_by(\" Split by: \", empty_segments=True, separator='.'))\n    [[], ['S', 'p', 'l', 'i', 't'], ['b', 'y', ':'], []]\n\n    :param iterable: The list to split.\n    :param empty_segments: If ``True``, include an empty list in cases where two adjacent elements satisfy\n    the criterion.\n    :param criterion: The criterion to decide whether to drop an element.\n    :param separator: The separator for sub-lists. An element is dropped if it is equal to ``parameter``.\n    :return: List of sub-lists.\n    \"\"\"\n    if (criterion is None) == (separator is None):\n        raise ValueError(\"Exactly one of 'criterion' and 'separator' must be specified\")\n\n    # Define the predicate function to decide if an element is a separator\n    if criterion is not None:\n        is_separator = criterion\n    else:\n        def is_separator(x: A) -> bool:\n            return x == separator  # type: ignore\n\n    segment: List[A] = []\n    for item in iterable:\n        if is_separator(item):\n            if segment or empty_segments:\n                yield segment\n            segment = []\n        else:\n            segment.append(item)\n    # Yield the last segment if it's not empty or if empty_segments is True\n    if segment or empty_segments:\n        yield segment", "message": "passed", "passed": true}
{"task_id": 343, "prediction_id": 2, "generation": "from typing import Callable, Iterable, Iterator, List, Optional, TypeVar\n\nA = TypeVar('A')\n\ndef split_by(iterable: Iterable[A], empty_segments: bool = False, *, criterion: Optional[Callable[[A], bool]] = None,\n             separator: Optional[A] = None) -> Iterator[List[A]]:\n    r\"\"\"Split a list into sub-lists by dropping certain elements. Exactly one of ``criterion`` and ``separator`` must be\n    specified. For example:\n\n    .. code:: python\n\n    >>> list(split_by(range(10), criterion=lambda x: x % 3 == 0))\n    [[1, 2], [4, 5], [7, 8]]\n\n    >>> list(split_by(\" Split by: \", empty_segments=True, separator='.'))\n    [[], ['S', 'p', 'l', 'i', 't'], ['b', 'y', ':'], []]\n\n    :param iterable: The list to split.\n    :param empty_segments: If ``True``, include an empty list in cases where two adjacent elements satisfy\n    the criterion.\n    :param criterion: The criterion to decide whether to drop an element.\n    :param separator: The separator for sub-lists. An element is dropped if it is equal to ``parameter``.\n    :return: List of sub-lists.\n    \"\"\"\n    if (criterion is None) == (separator is None):\n        # Either both are None or both are specified - invalid\n        raise ValueError(\"Exactly one of 'criterion' and 'separator' must be specified\")\n\n    # If separator is specified, define criterion function based on equality to separator\n    if separator is not None:\n        def criterion(x: A) -> bool:\n            return x == separator\n\n    segment = []\n    yield_empty = empty_segments\n\n    for element in iterable:\n        if criterion(element):\n            # Element is a separator/drop element\n            if segment or yield_empty:\n                yield segment\n            segment = []\n        else:\n            segment.append(element)\n\n    # After iteration, yield the last segment if not empty or empty_segments requested\n    if segment or (empty_segments and yield_empty):\n        yield segment", "message": "passed", "passed": true}
{"task_id": 343, "prediction_id": 3, "generation": "from typing import Iterable, Iterator, List, TypeVar, Callable, Optional\n\nA = TypeVar('A')\n\ndef split_by(iterable: Iterable[A], empty_segments: bool = False, *, criterion: Optional[Callable[[A], bool]] = None, separator: Optional[A] = None) \\\n        -> Iterator[List[A]]:\n    r\"\"\"Split a list into sub-lists by dropping certain elements. Exactly one of ``criterion`` and ``separator`` must be\n    specified. For example:\n\n    .. code:: python\n\n    >>> list(split_by(range(10), criterion=lambda x: x % 3 == 0))\n    [[1, 2], [4, 5], [7, 8]]\n\n    >>> list(split_by(\" Split by: \", empty_segments=True, separator='.'))\n    [[], ['S', 'p', 'l', 'i', 't'], ['b', 'y', ':'], []]\n\n    :param iterable: The list to split.\n    :param empty_segments: If ``True``, include an empty list in cases where two adjacent elements satisfy\n    the criterion.\n    :param criterion: The criterion to decide whether to drop an element.\n    :param separator: The separator for sub-lists. An element is dropped if it is equal to ``parameter``.\n    :return: List of sub-lists.\n    \"\"\"\n    if (criterion is None) == (separator is None):\n        raise ValueError(\"Exactly one of 'criterion' and 'separator' must be specified\")\n\n    if separator is not None:\n        predicate = lambda x: x == separator\n    else:\n        predicate = criterion\n\n    segment = []\n    for element in iterable:\n        if predicate(element):\n            # We hit a separator element: yield current segment and reset\n            if segment or empty_segments:\n                yield segment\n            segment = []\n        else:\n            segment.append(element)\n    # Yield any remaining segment at the end\n    if segment or empty_segments:\n        yield segment", "message": "passed", "passed": true}
{"task_id": 343, "prediction_id": 4, "generation": "from typing import Callable, Iterable, Iterator, List, Optional, TypeVar\n\nA = TypeVar('A')\n\n\ndef split_by(iterable: Iterable[A], empty_segments: bool = False, *, criterion: Optional[Callable[[A], bool]] = None, separator: Optional[A] = None) -> Iterator[List[A]]:\n    r\"\"\"Split a list into sub-lists by dropping certain elements. Exactly one of ``criterion`` and ``separator`` must be\n    specified. For example:\n\n    .. code:: python\n\n    >>> list(split_by(range(10), criterion=lambda x: x % 3 == 0))\n    [[1, 2], [4, 5], [7, 8]]\n\n    >>> list(split_by(\" Split by: \", empty_segments=True, separator='.'))\n    [[], ['S', 'p', 'l', 'i', 't'], ['b', 'y', ':'], []]\n\n    :param iterable: The list to split.\n    :param empty_segments: If ``True``, include an empty list in cases where two adjacent elements satisfy\n    the criterion.\n    :param criterion: The criterion to decide whether to drop an element.\n    :param separator: The separator for sub-lists. An element is dropped if it is equal to ``parameter``.\n    :return: List of sub-lists.\n    \"\"\"\n    if (criterion is None) == (separator is None):\n        raise ValueError(\"Exactly one of 'criterion' and 'separator' must be specified\")\n\n    if separator is not None:\n        def criterion_fn(x: A) -> bool:\n            return x == separator\n    else:\n        criterion_fn = criterion  # type: ignore\n\n    segment: List[A] = []\n    for elem in iterable:\n        if criterion_fn(elem):\n            # element is dropped; segment boundary\n            if segment or empty_segments:\n                yield segment\n                segment = []\n        else:\n            segment.append(elem)\n    if segment or empty_segments:\n        yield segment", "message": "passed", "passed": true}
