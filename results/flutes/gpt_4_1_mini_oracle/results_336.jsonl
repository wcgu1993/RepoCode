{"task_id": 336, "prediction_id": 0, "generation": "from collections.abc import Mapping, Sequence, Set as AbstractSet\nfrom typing import Callable, Collection, TypeVar, Union\n\nT = TypeVar('T')\nR = TypeVar('R')\n\ndef map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n    # Handle no-map instances: if instance has the no-map attribute, return it as is\n    if hasattr(obj, _NO_MAP_INSTANCE_ATTR):\n        return obj\n\n    # Handle mappings (e.g. dict)\n    if isinstance(obj, Mapping):\n        # Preserve type, recursively map keys (usually keys are not mapped, but here presumably only values are mapped)\n        # Typical usage: only apply fn to the values, not keys\n        return type(obj)((key, map_structure(fn, value)) for key, value in obj.items())\n\n    # Handle sequences (but not strings and bytes which are also sequences)\n    # We'll treat strings/bytes as atomic, not to be traversed\n    if isinstance(obj, Sequence) and not isinstance(obj, (str, bytes)):\n        return type(obj)(map_structure(fn, item) for item in obj)\n\n    # Handle sets\n    if isinstance(obj, AbstractSet):\n        return type(obj)(map_structure(fn, item) for item in obj)\n\n    # Otherwise, treat as leaf and apply fn\n    return fn(obj)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 98\n    from collections.abc import Mapping, Sequence, Set as AbstractSet\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 336, "prediction_id": 1, "generation": "from collections.abc import Mapping, Sequence, Set as AbstractSet\nfrom typing import Callable, Collection, TypeVar, Union, Dict, List, Set\n\nT = TypeVar('T')\nR = TypeVar('R')\n\ndef map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n    # Check for no-map instance or type\n    if getattr(obj, _NO_MAP_INSTANCE_ATTR, False):\n        return obj\n\n    # If obj is a Mapping (like dict), map over values preserving keys\n    if isinstance(obj, Mapping):\n        # Preserve the mapping type\n        # For example, if it's a defaultdict or OrderedDict, reconstruct by type\n        return type(obj)((k, map_structure(fn, v)) for k, v in obj.items())\n\n    # If obj is a str, it should be treated as a leaf, to avoid recursing on chars\n    if isinstance(obj, str):\n        return fn(obj)\n\n    # If obj is a Sequence (like list or tuple), but not str, map over elements\n    if isinstance(obj, Sequence):\n        # preserve the seq type (list, tuple)\n        mapped = [map_structure(fn, x) for x in obj]\n        # reconstruct as original sequence type\n        return type(obj)(mapped)\n\n    # If obj is a Set (like set, frozenset), map over elements too\n    if isinstance(obj, AbstractSet):\n        mapped = {map_structure(fn, x) for x in obj}\n        return type(obj)(mapped)\n\n    # Otherwise, treat as leaf and apply fn\n    return fn(obj)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 98\n    from collections.abc import Mapping, Sequence, Set as AbstractSet\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 336, "prediction_id": 2, "generation": "from collections.abc import Mapping, Sequence, Set as AbstractSet\nfrom typing import Callable, Collection, TypeVar, Union\n\nT = TypeVar('T')\nR = TypeVar('R')\n\ndef map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n\n    # Check if the object is registered as no-map (has special attribute)\n    if getattr(obj, _NO_MAP_INSTANCE_ATTR, False):\n        return obj\n\n    # If it is a mapping (e.g. dict), recursively map over its values, preserving keys\n    if isinstance(obj, Mapping):\n        return type(obj)((k, map_structure(fn, v)) for k, v in obj.items())\n\n    # If it is a sequence but not a string (strings are sequences, but we typically do not recurse into them)\n    if isinstance(obj, Sequence) and not isinstance(obj, (str, bytes, bytearray)):\n        return type(obj)(map_structure(fn, el) for el in obj)\n\n    # If it is a set (but not a frozenset which is immutable, but let's treat similarly)\n    if isinstance(obj, AbstractSet):\n        return type(obj)(map_structure(fn, el) for el in obj)\n\n    # Otherwise, assume it is an element (non-collection), apply fn directly\n    return fn(obj)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 98\n    from collections.abc import Mapping, Sequence, Set as AbstractSet\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 336, "prediction_id": 3, "generation": "from collections.abc import Mapping, Sequence\nfrom typing import Callable, Collection, Dict, List, Set, Type, TypeVar, Union\n\nT = TypeVar('T')\nR = TypeVar('R')\n\n# Reusing _NO_MAP_TYPES and _NO_MAP_INSTANCE_ATTR from the file content\n_NO_MAP_TYPES: Set[Type] = set()\n_NO_MAP_INSTANCE_ATTR = \"--no-map--\"\n\ndef map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n    # Handle no_map instances and registered no-map types by treating as atomic\n    if getattr(obj, _NO_MAP_INSTANCE_ATTR, False):\n        return obj\n\n    obj_type = type(obj)\n    if obj_type in _NO_MAP_TYPES:\n        return obj\n\n    # Map over mappings (dict-like)\n    if isinstance(obj, Mapping):\n        return obj_type({k: map_structure(fn, v) for k, v in obj.items()})\n\n    # Map over sequences, but treat strings and bytes as atomic\n    elif isinstance(obj, Sequence) and not isinstance(obj, (str, bytes)):\n        return obj_type(map_structure(fn, v) for v in obj)\n\n    # Otherwise, treat as leaf\n    else:\n        return fn(obj)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 98\n    from collections.abc import Mapping, Sequence\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 336, "prediction_id": 4, "generation": "from typing import Callable, Collection, Dict, List, Sequence, Set, Type, TypeVar, no_type_check\n\nT = TypeVar('T')\nR = TypeVar('R')\n\n_NO_MAP_TYPES: Set[type] = set()\n_NO_MAP_INSTANCE_ATTR = \"--no-map--\"\n\n\ndef map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n    # If obj is None or not a collection, just apply fn and return\n    # But since annotation says Collection[T], we assume at least iterable\n    \n    # Handle objects marked as no-map or their types registered as no-map types.\n    # These should be treated as singleton objects (not traversed down).\n    # We check for the special attribute, or for the type membership\n    if hasattr(obj, _NO_MAP_INSTANCE_ATTR):\n        return fn(obj)\n    if type(obj) in _NO_MAP_TYPES:\n        return fn(obj)\n\n    # Handle base cases of known collection types:\n    # list, tuple, dict, set\n    \n    # dict: map over values, keep keys intact\n    if isinstance(obj, dict):\n        return type(obj)({k: map_structure(fn, v) for k, v in obj.items()})  # type: ignore\n\n    # list or tuple: map over elements\n    if isinstance(obj, list):\n        return [map_structure(fn, el) for el in obj]\n    if isinstance(obj, tuple):\n        return tuple(map_structure(fn, el) for el in obj)\n\n    # set or frozenset: map and convert back to same set type\n    if isinstance(obj, (set, frozenset)):\n        return type(obj)(map_structure(fn, el) for el in obj)\n\n    # If obj is a generic Collection but none of the above,\n    # try to convert back to the same type if possible\n    # but usually collections are lists, tuples, sets, dicts\n\n    # Finally, treat this as a leaf node and apply fn\n    return fn(obj)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 98\n    from typing import Callable, Collection, Dict, List, Sequence, Set, Type, TypeVar, no_type_check\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
