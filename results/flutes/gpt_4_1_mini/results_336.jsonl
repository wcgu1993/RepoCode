{"task_id": 336, "prediction_id": 0, "generation": "from typing import Callable, Collection, Dict, List, Sequence, Set, Type, TypeVar\n\nT = TypeVar('T')\nR = TypeVar('R')\n\n_NO_MAP_INSTANCE_ATTR = \"--no-map--\"\n_NO_MAP_TYPES: Set[Type] = set()\n\n\ndef map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n    # Helper to check if an object or its type is marked as non-mappable\n    def _is_no_map(o):\n        # Check attribute on instance\n        if hasattr(o, _NO_MAP_INSTANCE_ATTR):\n            return True\n        # Check if type is registered as no-map\n        if type(o) in _NO_MAP_TYPES:\n            return True\n        return False\n\n    if _is_no_map(obj):\n        # Treat obj as atomic, apply fn directly\n        return fn(obj)\n\n    # Handle common container types, preserving type and structure\n\n    if isinstance(obj, dict):\n        # Map over dict items, map_structure on values (keys assumed to be atomic)\n        return type(obj)({k: map_structure(fn, v) for k, v in obj.items()})\n\n    elif isinstance(obj, (list, tuple, set, frozenset)):\n        # For set/frozenset, map over elements and recreate same type\n        mapped = (map_structure(fn, x) for x in obj)\n        if isinstance(obj, list):\n            return [*mapped]\n        elif isinstance(obj, tuple):\n            return tuple(mapped)\n        elif isinstance(obj, set):\n            return set(mapped)\n        else:  # frozenset\n            return frozenset(mapped)\n\n    # For anything else (atomic), apply fn directly\n    return fn(obj)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 98\n    from typing import Callable, Collection, Dict, List, Sequence, Set, Type, TypeVar\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 336, "prediction_id": 1, "generation": "from collections.abc import Mapping, Sequence\n\ndef map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n    # Check if the object is registered as non-mappable type or instance:\n    if (\n        hasattr(obj, _NO_MAP_INSTANCE_ATTR)\n        or type(obj) in _NO_MAP_TYPES\n    ):\n        # Treat as leaf; apply function directly.\n        return fn(obj)\n\n    # For mappings (like dict), apply recursively to values preserving keys\n    if isinstance(obj, Mapping):\n        return type(obj)({k: map_structure(fn, v) for k, v in obj.items()})\n\n    # For sequences (like list, tuple), apply recursively to elements preserving type\n    if isinstance(obj, Sequence) and not isinstance(obj, (str, bytes)):\n        # Special-case tuple since it's immutable and may have subclasses\n        if isinstance(obj, tuple):\n            return type(obj)(map_structure(fn, v) for v in obj)\n        else:\n            return type(obj)(map_structure(fn, v) for v in obj)\n\n    # For other types, treat as leaf and apply function directly\n    return fn(obj)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 98\n    from collections.abc import Mapping, Sequence\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 336, "prediction_id": 2, "generation": "from collections.abc import Mapping, Sequence\n\ndef map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n    # Handle no-map types/instances: treat as atomic\n    if (\n        hasattr(obj, _NO_MAP_INSTANCE_ATTR)\n        or type(obj) in _NO_MAP_TYPES\n    ):\n        return obj\n\n    # Handle mappings (dict-like objects)\n    if isinstance(obj, Mapping):\n        # Preserve the same mapping type\n        return type(obj)((k, map_structure(fn, v)) for k, v in obj.items())\n\n    # Handle sequences (list, tuple, etc.) but not strings/bytes\n    if isinstance(obj, Sequence) and not isinstance(obj, (str, bytes)):\n        # Preserve the same sequence type\n        # tuples map to tuples, lists map to lists, etc.\n        mapped = (map_structure(fn, x) for x in obj)\n        if isinstance(obj, tuple):\n            return tuple(mapped)\n        else:\n            return type(obj)(mapped)\n\n    # Base case: apply fn\n    return fn(obj)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 98\n    from collections.abc import Mapping, Sequence\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 336, "prediction_id": 3, "generation": "from collections.abc import Mapping, Sequence\nfrom typing import Callable, Collection, TypeVar, Union, cast\n\nT = TypeVar('T')\nR = TypeVar('R')\n\n\ndef map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n    # If the obj is a registered no-map type or instance, do not traverse its contents, return as is\n    obj_type = type(obj)\n    if obj_type in _NO_MAP_TYPES or getattr(obj, _NO_MAP_INSTANCE_ATTR, False):\n        return cast(Collection[R], obj)\n\n    # If obj is a Mapping (e.g., dict), map over values preserving keys\n    if isinstance(obj, Mapping):\n        return obj_type(\n            (k, map_structure(fn, v)) for k, v in obj.items()\n        )  # type: ignore\n\n    # If obj is a Sequence but not a str, bytes or bytearray (these are treated as atomic)\n    if isinstance(obj, Sequence) and not isinstance(obj, (str, bytes, bytearray)):\n        # Rebuild the sequence type with mapped elements\n        return obj_type(map_structure(fn, item) for item in obj)  # type: ignore\n\n    # Base case: Not a collection to traverse, apply fn directly\n    return fn(cast(T, obj))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 98\n    from collections.abc import Mapping, Sequence\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
{"task_id": 336, "prediction_id": 4, "generation": "from collections.abc import Mapping, Sequence\nfrom typing import Callable, Collection, Dict, List, Sequence, Set, TypeVar, Union, cast, Iterable\n\nT = TypeVar('T')\nR = TypeVar('R')\n\n_NO_MAP_TYPES: Set[type] = set()\n_NO_MAP_INSTANCE_ATTR = \"--no-map--\"\n\n\ndef map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n    # Check if obj is marked as no-map instance or is of a no-map registered type\n    if (\n        hasattr(obj, _NO_MAP_INSTANCE_ATTR) or\n        type(obj) in _NO_MAP_TYPES\n    ):\n        # Treat as atomic, do not traverse internally\n        return cast(Collection[R], fn(obj))  # type: ignore\n\n    # Check if obj is a mapping (like dict)\n    if isinstance(obj, Mapping):\n        # Recursively map over values, keep keys same\n        return type(obj)({k: map_structure(fn, v) for k, v in obj.items()})\n\n    # Check if obj is a sequence but not a string/bytes (which are also sequences but atomic)\n    if isinstance(obj, Sequence) and not isinstance(obj, (str, bytes)):\n        # Recursively map over items\n        return type(obj)(map_structure(fn, v) for v in obj)\n\n    # For other collections (e.g., set, frozenset), try to reconstruct preserving type\n    # Handle common iterable collections not covered above (sets etc.)\n    # Since obj is a Collection, it supports iteration\n    # But to keep return type as Collection, we try to construct with the same type if possible\n    # If constructor doesn't support iterable, fallback to list\n    try:\n        return type(obj)(map_structure(fn, v) for v in obj)  # type: ignore\n    except Exception:\n        # Fallback, just return mapped items as list\n        return list(map_structure(fn, v) for v in obj)  # type: ignore\n\n    # If none of the above, treat as atomic and apply fn\n    # But technically, should not reach here as above try covers it\n    # Still, just for safety:\n    # return fn(obj)  # type: ignore", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 98\n    from collections.abc import Mapping, Sequence\n    ^^^^\nSyntaxError: invalid syntax\n", "passed": false}
