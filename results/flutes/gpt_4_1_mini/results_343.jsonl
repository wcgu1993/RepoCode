{"task_id": 343, "prediction_id": 0, "generation": "from typing import Callable, Iterable, Iterator, List, Optional, TypeVar\n\nA = TypeVar('A')\n\ndef split_by(iterable: Iterable[A], empty_segments: bool = False, *, criterion: Optional[Callable[[A], bool]] = None, separator: Optional[A] = None) \\\n        -> Iterator[List[A]]:\n    r\"\"\"Split a list into sub-lists by dropping certain elements. Exactly one of ``criterion`` and ``separator`` must be\n    specified. For example:\n\n    .. code:: python\n\n    >>> list(split_by(range(10), criterion=lambda x: x % 3 == 0))\n    [[1, 2], [4, 5], [7, 8]]\n\n    >>> list(split_by(\" Split by: \", empty_segments=True, separator='.'))\n    [[], ['S', 'p', 'l', 'i', 't'], ['b', 'y', ':'], []]\n\n    :param iterable: The list to split.\n    :param empty_segments: If ``True``, include an empty list in cases where two adjacent elements satisfy\n    the criterion.\n    :param criterion: The criterion to decide whether to drop an element.\n    :param separator: The separator for sub-lists. An element is dropped if it is equal to ``parameter``.\n    :return: List of sub-lists.\n    \"\"\"\n\n    if (criterion is None and separator is None) or (criterion is not None and separator is not None):\n        raise ValueError(\"Exactly one of 'criterion' or 'separator' must be specified.\")\n\n    # Define a function to decide if an element is a splitting point\n    if criterion is not None:\n        def is_sep(x: A) -> bool:\n            return criterion(x)\n    else:\n        def is_sep(x: A) -> bool:\n            return x == separator\n\n    segment: List[A] = []\n    for element in iterable:\n        if is_sep(element):\n            # We hit a separator - yield current segment if non-empty or if empty_segments=True\n            if segment or empty_segments:\n                yield segment\n            segment = []\n        else:\n            segment.append(element)\n\n    # After finishing iteration, yield the last segment if non-empty or empty_segments=True\n    if segment or empty_segments:\n        yield segment", "message": "passed", "passed": true}
{"task_id": 343, "prediction_id": 1, "generation": "from typing import Callable, Iterable, Iterator, List, Optional, TypeVar\n\nA = TypeVar('A')\n\ndef split_by(iterable: Iterable[A], empty_segments: bool = False, *, criterion: Optional[Callable[[A], bool]] = None,\n             separator: Optional[A] = None) -> Iterator[List[A]]:\n    r\"\"\"Split a list into sub-lists by dropping certain elements. Exactly one of ``criterion`` and ``separator`` must be\n    specified. For example:\n\n    .. code:: python\n\n    >>> list(split_by(range(10), criterion=lambda x: x % 3 == 0))\n    [[1, 2], [4, 5], [7, 8]]\n\n    >>> list(split_by(\" Split by: \", empty_segments=True, separator='.'))\n    [[], ['S', 'p', 'l', 'i', 't'], ['b', 'y', ':'], []]\n\n    :param iterable: The list to split.\n    :param empty_segments: If ``True``, include an empty list in cases where two adjacent elements satisfy\n    the criterion.\n    :param criterion: The criterion to decide whether to drop an element.\n    :param separator: The separator for sub-lists. An element is dropped if it is equal to ``parameter``.\n    :return: List of sub-lists.\n    \"\"\"\n    if (criterion is None and separator is None) or (criterion is not None and separator is not None):\n        raise ValueError(\"Exactly one of 'criterion' and 'separator' must be specified\")\n\n    if separator is not None:\n        def is_separator(x: A) -> bool:\n            return x == separator\n        criterion_fn = is_separator\n    else:\n        criterion_fn = criterion  # type: ignore\n\n    segment = []\n    for element in iterable:\n        if criterion_fn(element):\n            # When element matches criterion/separator: end current segment\n            if segment or empty_segments:\n                yield segment\n            segment = []\n        else:\n            segment.append(element)\n    # Yield the last segment\n    if segment or empty_segments:\n        yield segment", "message": "passed", "passed": true}
{"task_id": 343, "prediction_id": 2, "generation": "from typing import Callable, Iterable, Iterator, List, Optional, TypeVar\n\nA = TypeVar('A')\n\n\ndef split_by(\n    iterable: Iterable[A],\n    empty_segments: bool = False,\n    *,\n    criterion: Optional[Callable[[A], bool]] = None,\n    separator: Optional[A] = None,\n) -> Iterator[List[A]]:\n    r\"\"\"Split a list into sub-lists by dropping certain elements. Exactly one of ``criterion`` and ``separator`` must be\n    specified. For example:\n\n    .. code:: python\n\n    >>> list(split_by(range(10), criterion=lambda x: x % 3 == 0))\n    [[1, 2], [4, 5], [7, 8]]\n\n    >>> list(split_by(\" Split by: \", empty_segments=True, separator='.'))\n    [[], ['S', 'p', 'l', 'i', 't'], ['b', 'y', ':'], []]\n\n    :param iterable: The list to split.\n    :param empty_segments: If ``True``, include an empty list in cases where two adjacent elements satisfy\n    the criterion.\n    :param criterion: The criterion to decide whether to drop an element.\n    :param separator: The separator for sub-lists. An element is dropped if it is equal to ``parameter``.\n    :return: List of sub-lists.\n    \"\"\"\n    if (criterion is None) == (separator is None):\n        raise ValueError(\"Exactly one of `criterion` or `separator` must be specified\")\n\n    if separator is not None:\n        # Define criterion from separator equality.\n        def criterion_fn(x: A) -> bool:\n            return x == separator\n    else:\n        criterion_fn = criterion  # type: ignore\n\n    segment: List[A] = []\n    for element in iterable:\n        if criterion_fn(element):\n            if segment or empty_segments:\n                yield segment\n            segment = []\n        else:\n            segment.append(element)\n\n    if segment or empty_segments:\n        yield segment", "message": "passed", "passed": true}
{"task_id": 343, "prediction_id": 3, "generation": "from typing import Callable, Iterable, Iterator, List, Optional, TypeVar\n\nA = TypeVar('A')\n\n\ndef split_by(iterable: Iterable[A], empty_segments: bool = False, *, criterion: Optional[Callable[[A], bool]] = None,\n             separator: Optional[A] = None) -> Iterator[List[A]]:\n    r\"\"\"Split a list into sub-lists by dropping certain elements. Exactly one of ``criterion`` and ``separator`` must be\n    specified. For example:\n\n    .. code:: python\n\n    >>> list(split_by(range(10), criterion=lambda x: x % 3 == 0))\n    [[1, 2], [4, 5], [7, 8]]\n\n    >>> list(split_by(\" Split by: \", empty_segments=True, separator='.'))\n    [[], ['S', 'p', 'l', 'i', 't'], ['b', 'y', ':'], []]\n\n    :param iterable: The list to split.\n    :param empty_segments: If ``True``, include an empty list in cases where two adjacent elements satisfy\n    the criterion.\n    :param criterion: The criterion to decide whether to drop an element.\n    :param separator: The separator for sub-lists. An element is dropped if it is equal to ``parameter``.\n    :return: List of sub-lists.\n    \"\"\"\n    if (criterion is None and separator is None) or (criterion is not None and separator is not None):\n        raise ValueError(\"Exactly one of 'criterion' and 'separator' must be specified\")\n\n    # Define the function that decides if an element is a separator\n    if criterion is None:\n        def is_sep(x: A) -> bool:\n            return x == separator\n    else:\n        is_sep = criterion\n\n    segment: List[A] = []\n    for element in iterable:\n        if is_sep(element):\n            # We hit a separator element, yield the current segment (if any),\n            # or empty segment if allowed, then reset the segment\n            if segment or empty_segments:\n                yield segment\n            segment = []\n        else:\n            segment.append(element)\n\n    # Yield the last segment if any or if empty_segments is True (to match cases like trailing separator)\n    if segment or empty_segments:\n        yield segment", "message": "passed", "passed": true}
{"task_id": 343, "prediction_id": 4, "generation": "from typing import Callable, Iterable, Iterator, List, Optional, TypeVar\n\nA = TypeVar('A')\n\n\ndef split_by(iterable: Iterable[A], empty_segments: bool = False, *, criterion: Optional[Callable[[A], bool]] = None,\n             separator: Optional[A] = None) -> Iterator[List[A]]:\n    r\"\"\"Split a list into sub-lists by dropping certain elements. Exactly one of ``criterion`` and ``separator`` must be\n    specified. For example:\n\n    .. code:: python\n\n    >>> list(split_by(range(10), criterion=lambda x: x % 3 == 0))\n    [[1, 2], [4, 5], [7, 8]]\n\n    >>> list(split_by(\" Split by: \", empty_segments=True, separator='.'))\n    [[], ['S', 'p', 'l', 'i', 't'], ['b', 'y', ':'], []]\n\n    :param iterable: The list to split.\n    :param empty_segments: If ``True``, include an empty list in cases where two adjacent elements satisfy\n    the criterion.\n    :param criterion: The criterion to decide whether to drop an element.\n    :param separator: The separator for sub-lists. An element is dropped if it is equal to ``parameter``.\n    :return: List of sub-lists.\n    \"\"\"\n    if (criterion is None) == (separator is None):\n        # Both are None or both specified \u2014 invalid usage\n        raise ValueError(\"Exactly one of 'criterion' or 'separator' must be specified\")\n\n    # Decide predicate function according to the parameter specified\n    if separator is not None:\n        def pred_fn(x: A) -> bool:\n            return x == separator\n    else:\n        pred_fn = criterion  # type: ignore\n\n    segment: List[A] = []\n    for item in iterable:\n        if pred_fn(item):\n            # Upon hitting a separator/criterion True, yield segment accordingly\n            if segment or empty_segments:\n                yield segment\n            segment = []\n        else:\n            segment.append(item)\n    # Yield the last segment if any or if empty_segments requested\n    if segment or empty_segments:\n        yield segment", "message": "passed", "passed": true}
