{"task_id": 274, "prediction_id": 0, "generation": "from typing import Optional\n\n\ndef _get_content_range(start: Optional[int], end: Optional[int], total: int) -> str:\n    \"\"\"Returns a suitable Content-Range header:\n\n    >>> print(_get_content_range(None, 1, 4))\n    bytes 0-0/4\n    >>> print(_get_content_range(1, 3, 4))\n    bytes 1-2/4\n    >>> print(_get_content_range(None, None, 4))\n    bytes 0-3/4\n    \"\"\"\n    if start is None and end is None:\n        # full range, from 0 to total-1\n        start_pos = 0\n        end_pos = total - 1\n    else:\n        start_pos = start if start is not None else 0\n        # end is exclusive index, content-range end is inclusive index, so end-1 if not None\n        end_pos = end - 1 if end is not None else total - 1\n    return f\"bytes {start_pos}-{end_pos}/{total}\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1145, in <module>\n  File \"<string>\", line 1144, in test_0\nAssertionError\n", "passed": false}
{"task_id": 274, "prediction_id": 1, "generation": "from typing import Optional\n\n\ndef _get_content_range(start: Optional[int], end: Optional[int], total: int) -> str:\n    \"\"\"\n    Returns a suitable Content-Range header string based on the given start, end slice indexes, and total size.\n\n    The `start` and `end` parameters use Python slice semantics:\n    - `start` is inclusive start index or None\n    - `end` is exclusive end index or None\n\n    According to HTTP Content-Range header (bytes unit):\n    - The byte range is inclusive, so end_byte = end - 1\n    - If start is None, it is treated as 0\n    - If end is None, it is treated as total length\n\n    Examples:\n    >>> print(_get_content_range(None, 1, 4))\n    bytes 0-0/4\n    >>> print(_get_content_range(1, 3, 4))\n    bytes 1-2/4\n    >>> print(_get_content_range(None, None, 4))\n    bytes 0-3/4\n    \"\"\"\n    # Normalize start\n    byte_start = 0 if start is None else start\n    # Normalize end to the last included byte\n    byte_end = total - 1 if end is None else end - 1\n\n    return f\"bytes {byte_start}-{byte_end}/{total}\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1153, in <module>\n  File \"<string>\", line 1152, in test_0\nAssertionError\n", "passed": false}
{"task_id": 274, "prediction_id": 2, "generation": "from typing import Optional\n\ndef _get_content_range(start: Optional[int], end: Optional[int], total: int) -> str:\n    \"\"\"Returns a suitable Content-Range header:\n\n    >>> print(_get_content_range(None, 1, 4))\n    bytes 0-0/4\n    >>> print(_get_content_range(1, 3, 4))\n    bytes 1-2/4\n    >>> print(_get_content_range(None, None, 4))\n    bytes 0-3/4\n    \"\"\"\n    # If both start and end are None: range covers the entire resource\n    if start is None and end is None:\n        # Entire range is bytes 0 to total-1\n        return f\"bytes 0-{total - 1}/{total}\"\n    # If start is None but end is given: range starts at 0, end is end-1\n    if start is None:\n        return f\"bytes 0-{max(end - 1, 0)}/{total}\"\n    # If end is None but start is given: range starts at start, ends at total-1\n    if end is None:\n        return f\"bytes {start}-{total - 1}/{total}\"\n    # Normal case: start and end both given\n    # Note end is exclusive index, so content range is start to end-1\n    return f\"bytes {start}-{max(end - 1, start)}/{total}\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1362, in <module>\n  File \"<string>\", line 1361, in test_29\nAssertionError\n", "passed": false}
{"task_id": 274, "prediction_id": 3, "generation": "from typing import Optional\n\ndef _get_content_range(start: Optional[int], end: Optional[int], total: int) -> str:\n    \"\"\"Returns a suitable Content-Range header:\n\n    >>> print(_get_content_range(None, 1, 4))\n    bytes 0-0/4\n    >>> print(_get_content_range(1, 3, 4))\n    bytes 1-2/4\n    >>> print(_get_content_range(None, None, 4))\n    bytes 0-3/4\n    \"\"\"\n    if start is None and end is None:\n        # Entire range\n        content_start = 0\n        content_end = total - 1\n    elif start is not None and end is None:\n        # Start specified, no end\n        content_start = start\n        content_end = total - 1\n    elif start is None and end is not None:\n        # Only end specified - this means a suffix range (last 'end' bytes)\n        # But for Content-Range, need to compute the start.\n        # The given 'end' param here corresponds to the slice end index (exclusive in _parse_request_range),\n        # but here we don't have that context. Assuming end is slice end index, but in our input\n        # context, end can be None or int representing slice exclusivity.\n        # Since the docstring examples show start=None, end=1 means \"bytes 0-0\", it suggests end is slice exclusive.\n        # So here if start is None and end is not None, it means a range from 0 to end-1.\n        content_start = 0\n        content_end = max(0, end - 1)\n    else:\n        # Both start and end specified (end exclusive)\n        content_start = start\n        content_end = max(content_start, end - 1)\n\n    # Clamp values to valid ranges\n    if content_start < 0:\n        # Negative start indicates suffix range; in content-range it should be normalized\n        # but since we don't have the full content here, we just clamp to 0.\n        content_start = max(0, total + content_start)\n    if content_end >= total:\n        content_end = total - 1\n    if content_start >= total:\n        # Invalid range: start beyond total, make empty range at total-1\n        content_start = total - 1\n        content_end = total - 1\n\n    return f\"bytes {content_start}-{content_end}/{total}\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1247, in <module>\n  File \"<string>\", line 1246, in test_28\nAssertionError\n", "passed": false}
{"task_id": 274, "prediction_id": 4, "generation": "from typing import Optional\n\ndef _get_content_range(start: Optional[int], end: Optional[int], total: int) -> str:\n    \"\"\"Returns a suitable Content-Range header:\n\n    >>> print(_get_content_range(None, 1, 4))\n    bytes 0-0/4\n    >>> print(_get_content_range(1, 3, 4))\n    bytes 1-2/4\n    >>> print(_get_content_range(None, None, 4))\n    bytes 0-3/4\n    \"\"\"\n    # Determine the start position\n    if start is None:\n        content_start = 0\n    else:\n        content_start = start\n\n    # Determine the end position (inclusive, for the header)\n    if end is None:\n        content_end = total - 1\n    else:\n        # end is exclusive index suitable for Python slices,\n        # the Content-Range header shows inclusive end byte\n        content_end = end - 1\n\n    # Guard against invalid ranges (optional, but reasonable)\n    if content_start < 0:\n        content_start = 0\n    if content_end >= total:\n        content_end = total - 1\n\n    return f\"bytes {content_start}-{content_end}/{total}\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1156, in <module>\n  File \"<string>\", line 1155, in test_0\nAssertionError\n", "passed": false}
