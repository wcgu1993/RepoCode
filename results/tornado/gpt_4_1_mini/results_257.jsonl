{"task_id": 257, "prediction_id": 0, "generation": "import ssl\nfrom typing import Any, Dict, Union\n\n\ndef ssl_options_to_context(\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext]\n) -> ssl.SSLContext:\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    if isinstance(ssl_options, ssl.SSLContext):\n        return ssl_options\n    if not ssl_options:\n        # If ssl_options is None or empty dict, return default client context\n        return ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n\n    # Create SSLContext with protocol PROTOCOL_TLS_CLIENT to support highest TLS versions\n    context = ssl.SSLContext(getattr(ssl, \"PROTOCOL_TLS_CLIENT\", ssl.PROTOCOL_TLS))\n\n    # Map any ssl_options keys that are legacy and need special handling:\n    # ssl_version is ignored because SSLContext created above sets protocol\n    # certfile, keyfile\n    certfile = ssl_options.get(\"certfile\")\n    keyfile = ssl_options.get(\"keyfile\")\n    if certfile is not None:\n        context.load_cert_chain(certfile, keyfile)\n\n    # cert_reqs sets verify_mode\n    cert_reqs = ssl_options.get(\"cert_reqs\")\n    if cert_reqs is not None:\n        context.verify_mode = cert_reqs\n\n    # ca_certs sets the CA file for verification\n    ca_certs = ssl_options.get(\"ca_certs\")\n    if ca_certs is not None:\n        context.load_verify_locations(cafile=ca_certs)\n\n    # ciphers string to set ciphers\n    ciphers = ssl_options.get(\"ciphers\")\n    if ciphers is not None:\n        context.set_ciphers(ciphers)\n\n    # Handle context options flags if present (like OP_NO_COMPRESSION)\n    options = ssl_options.get(\"options\")\n    if options is not None:\n        context.options |= options\n\n    # check_hostname attribute can be explicitly specified in ssl_options\n    # If not specified, set check_hostname True if verify_mode requires cert verification\n    check_hostname = ssl_options.get(\"check_hostname\")\n    if check_hostname is not None:\n        context.check_hostname = check_hostname\n    else:\n        # Enable check_hostname only if verify_mode is CERT_REQUIRED or CERT_OPTIONAL\n        context.check_hostname = (\n            context.verify_mode == ssl.CERT_REQUIRED\n            or context.verify_mode == ssl.CERT_OPTIONAL\n        )\n\n    # Allow setting whether to verify hostname on context level (Python 3.7+ feature),\n    # but fallback gracefully if attribute not present.\n    # Already handled above by setting context.check_hostname.\n\n    return context", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 680, in <module>\n  File \"<string>\", line 679, in test_28\nAssertionError\n", "passed": false}
{"task_id": 257, "prediction_id": 1, "generation": "import ssl\nfrom typing import Any, Dict, Union\n\n\ndef ssl_options_to_context(\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext]\n) -> ssl.SSLContext:\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    if isinstance(ssl_options, ssl.SSLContext):\n        # Already an SSLContext, just return it\n        return ssl_options\n\n    if not isinstance(ssl_options, dict):\n        raise TypeError(\n            \"ssl_options must be either an ssl.SSLContext or a dict of ssl.wrap_socket arguments\"\n        )\n\n    # Create SSLContext with PROTOCOL_SSLv23 (best compatibility)\n    # Note: PROTOCOL_SSLv23 is deprecated in Python 3.6+ in favor of PROTOCOL_TLS, but\n    # for backward compatibility and parity with tornado codebase we use PROTOCOL_SSLv23.\n    context = ssl.SSLContext(getattr(ssl, \"PROTOCOL_SSLv23\", ssl.PROTOCOL_TLS))\n\n    # Handle some special ssl_options keys that map to SSLContext attributes\n    # and load appropriate certificate/key/ciphers\n    # Supported keys: 'ssl_version' (ignored here as context is already created),\n    # 'certfile', 'keyfile', 'cert_reqs', 'ca_certs', 'ciphers'\n\n    # Load certificate and key if present\n    certfile = ssl_options.get(\"certfile\")\n    keyfile = ssl_options.get(\"keyfile\")\n    if certfile is not None:\n        context.load_cert_chain(certfile, keyfile)\n\n    # Set certificate requirements and CA certificates if specified\n    cert_reqs = ssl_options.get(\"cert_reqs\")\n    if cert_reqs is not None:\n        context.verify_mode = cert_reqs\n\n    ca_certs = ssl_options.get(\"ca_certs\")\n    if ca_certs is not None:\n        context.load_verify_locations(cafile=ca_certs)\n\n    # Set ciphers if specified\n    ciphers = ssl_options.get(\"ciphers\")\n    if ciphers is not None:\n        context.set_ciphers(ciphers)\n\n    # Set options - copy any options present in the dict,\n    # but only known options that belong to context.options\n    # (Additional keys like options may exist, but tornado only handles ssl_version, certfile, keyfile, cert_reqs, ca_certs, ciphers)\n\n    # However, to be consistent with the tornado usage,\n    # if ssl_options has 'options', apply them to the context options attribute\n    # This is an extra safety to pass through options like OP_NO_COMPRESSION.\n    options = ssl_options.get(\"options\")\n    if options is not None:\n        context.options |= options\n\n    # Also if 'check_hostname' is provided and context supports it, set it\n    if \"check_hostname\" in ssl_options:\n        # This attribute is available in python >= 3.4\n        setattr(context, \"check_hostname\", ssl_options[\"check_hostname\"])\n\n    return context", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 656, in <module>\n  File \"<string>\", line 655, in test_2\nAssertionError\n", "passed": false}
{"task_id": 257, "prediction_id": 2, "generation": "import ssl\nfrom typing import Any, Dict, Union\n\n\ndef ssl_options_to_context(\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext]\n) -> ssl.SSLContext:\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    if isinstance(ssl_options, ssl.SSLContext):\n        return ssl_options\n\n    # ssl_options is a dict: create SSLContext and configure\n\n    # Pick protocol: if ssl_version is given in options, use it,\n    # else fallback to PROTOCOL_SSLv23 (widely compatible)\n    ssl_version = ssl_options.get(\"ssl_version\", ssl.PROTOCOL_SSLv23)\n    context = ssl.SSLContext(ssl_version)\n\n    # Certfile and keyfile\n    certfile = ssl_options.get(\"certfile\")\n    keyfile = ssl_options.get(\"keyfile\")\n    if certfile is not None:\n        # keyfile may be None, context.load_cert_chain accepts that\n        context.load_cert_chain(certfile, keyfile)\n\n    # cert_reqs\n    cert_reqs = ssl_options.get(\"cert_reqs\")\n    if cert_reqs is not None:\n        context.verify_mode = cert_reqs\n\n    # ca_certs: load CA certificates for verification\n    ca_certs = ssl_options.get(\"ca_certs\")\n    if ca_certs is not None:\n        context.load_verify_locations(cafile=ca_certs)\n\n    # ciphers: set ciphers if given\n    ciphers = ssl_options.get(\"ciphers\")\n    if ciphers is not None:\n        context.set_ciphers(ciphers)\n\n    # Copy the options flag if present,\n    # also copy check_hostname if set\n    options = ssl_options.get(\"options\")\n    if options is not None:\n        context.options |= options\n\n    # check_hostname: only set if attribute exists in context (py>=3.4)\n    check_hostname = ssl_options.get(\"check_hostname\")\n    if check_hostname is not None and hasattr(context, \"check_hostname\"):\n        context.check_hostname = check_hostname\n\n    # Also handle verify_flags if present (added in py3.4)\n    verify_flags = ssl_options.get(\"verify_flags\")\n    if verify_flags is not None and hasattr(context, \"verify_flags\"):\n        context.verify_flags = verify_flags\n\n    # post_handshake_auth if present (py3.7+)\n    post_handshake_auth = ssl_options.get(\"post_handshake_auth\")\n    if post_handshake_auth is not None and hasattr(context, \"post_handshake_auth\"):\n        context.post_handshake_auth = post_handshake_auth\n\n    # ALPN and NPN protocols if given (keys: \"alpn_protocols\", \"npn_protocols\")\n    alpn_protocols = ssl_options.get(\"alpn_protocols\")\n    if alpn_protocols is not None and hasattr(context, \"set_alpn_protocols\"):\n        context.set_alpn_protocols(alpn_protocols)\n\n    npn_protocols = ssl_options.get(\"npn_protocols\")\n    if npn_protocols is not None and hasattr(context, \"set_npn_protocols\"):\n        context.set_npn_protocols(npn_protocols)\n\n    return context", "message": "passed", "passed": true}
{"task_id": 257, "prediction_id": 3, "generation": "import ssl\nfrom typing import Any, Dict, Union\n\ndef ssl_options_to_context(\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext]\n) -> ssl.SSLContext:\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    if isinstance(ssl_options, ssl.SSLContext):\n        # Already an SSLContext, just return it\n        return ssl_options\n\n    if not isinstance(ssl_options, dict):\n        raise TypeError(\"ssl_options must be a dict or ssl.SSLContext\")\n\n    # Create SSLContext, default to PROTOCOL_TLS (most compatible)\n    # PROTOCOL_SSLv23 historically means the same as PROTOCOL_TLS,\n    # but PROTOCOL_TLS is preferred since Python 3.6.\n    # Use ssl.PROTOCOL_TLS, fallback to PROTOCOL_SSLv23 if not present.\n    protocol = getattr(ssl, \"PROTOCOL_TLS\", ssl.PROTOCOL_SSLv23)\n    context = ssl.SSLContext(protocol)\n\n    # Map of ssl.wrap_socket keyword args that correspond to SSLContext properties/methods\n    # These keys should be removed from ssl_options after processing.\n    ssl_context_keywords = {\n        \"ssl_version\",\n        \"certfile\",\n        \"keyfile\",\n        \"cert_reqs\",\n        \"ca_certs\",\n        \"ciphers\",\n    }\n\n    # Handle SSL version override if given (mostly ignored now, but handle nonetheless)\n    if \"ssl_version\" in ssl_options:\n        # If specified, recreate context with given protocol (if valid)\n        version = ssl_options[\"ssl_version\"]\n        if version is not None:\n            context = ssl.SSLContext(version)\n\n    # Load certificate chain if certfile present\n    certfile = ssl_options.get(\"certfile\")\n    keyfile = ssl_options.get(\"keyfile\")\n    if certfile is not None:\n        context.load_cert_chain(certfile, keyfile)\n\n    # Set verify mode (cert_reqs)\n    cert_reqs = ssl_options.get(\"cert_reqs\")\n    if cert_reqs is not None:\n        context.verify_mode = cert_reqs\n\n    # Load CA certificates if ca_certs given\n    ca_certs = ssl_options.get(\"ca_certs\")\n    if ca_certs is not None:\n        context.load_verify_locations(ca_certs)\n\n    # Set ciphers if present\n    ciphers = ssl_options.get(\"ciphers\")\n    if ciphers is not None:\n        context.set_ciphers(ciphers)\n\n    # Some safe defaults - disable compression if available (as original code does)\n    if hasattr(ssl, \"OP_NO_COMPRESSION\"):\n        context.options |= ssl.OP_NO_COMPRESSION\n\n    return context", "message": "passed", "passed": true}
{"task_id": 257, "prediction_id": 4, "generation": "import ssl\nfrom typing import Any, Dict, Union\n\n\ndef ssl_options_to_context(\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext]\n) -> ssl.SSLContext:\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    if isinstance(ssl_options, ssl.SSLContext):\n        # Already an SSLContext, just return it\n        return ssl_options\n\n    if not isinstance(ssl_options, dict):\n        raise TypeError(\"ssl_options must be a dict or ssl.SSLContext instance\")\n\n    # Start with a default context for server or client; decide based on usage\n    # Because we don't know \"server_side\" from here, default to CLIENT_AUTH to verify certs,\n    # as typical usage for ssl_options in client sockets\n    context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n\n    # Map ssl_options keys that correspond to SSLContext properties/methods\n    for key, value in ssl_options.items():\n        if key == \"ssl_version\":\n            # Set protocol version by creating context with that protocol if possible\n            # But context already created; recreate if protocol differs\n            # We recreate context if ssl_version is not default\n            if value != context.protocol:\n                context = ssl.SSLContext(value)\n        elif key == \"certfile\":\n            # Load cert chain if certfile specified\n            keyfile = ssl_options.get(\"keyfile\")  # can be None\n            context.load_cert_chain(certfile=value, keyfile=keyfile)\n        elif key == \"keyfile\":\n            # keyfile handled above with certfile; ignore standalone keyfile\n            # if certfile not present, keyfile alone cannot load cert chain\n            pass\n        elif key == \"cert_reqs\":\n            # Set verify mode\n            context.verify_mode = value\n        elif key == \"ca_certs\":\n            # Load CA certs for verifying peer certs\n            context.load_verify_locations(cafile=value)\n        elif key == \"ciphers\":\n            # Set ciphers string\n            context.set_ciphers(value)\n        else:\n            # Ignore any other keys or raise? In current codebase, only known keys handled.\n            # We simply ignore unknown keys.\n            pass\n\n    # Disable compression if available to prevent CRIME attack (per file content)\n    if hasattr(ssl, \"OP_NO_COMPRESSION\"):\n        context.options |= ssl.OP_NO_COMPRESSION\n\n    return context", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 673, in <module>\n  File \"<string>\", line 672, in test_28\nAssertionError\n", "passed": false}
