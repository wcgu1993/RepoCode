{"task_id": 258, "prediction_id": 0, "generation": "import ssl\nfrom typing import Any, Dict, Optional, Union\nimport socket\nfrom tornado.netutil import ssl_options_to_context\n\n\ndef ssl_wrap_socket(\n    socket: socket.socket,\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext],\n    server_hostname: Optional[str] = None,\n    **kwargs: Any\n) -> ssl.SSLSocket:\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n    # If the server_hostname is given, and the context supports SNI, pass it along\n    # ssl.SSLContext.wrap_socket supports server_hostname parameter since Python 3.5.\n    return context.wrap_socket(socket, server_hostname=server_hostname, **kwargs)", "message": "passed", "passed": true}
{"task_id": 258, "prediction_id": 1, "generation": "import ssl\nfrom typing import Any, Dict, Optional, Union\nimport socket\n\nfrom tornado.netutil import ssl_options_to_context\n\ndef ssl_wrap_socket(\n    socket: socket.socket,\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext],\n    server_hostname: Optional[str] = None,\n    **kwargs: Any\n) -> ssl.SSLSocket:\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n    if hasattr(context, 'wrap_socket'):\n        # Use SSLContext.wrap_socket which supports server_hostname argument (SNI)\n        return context.wrap_socket(socket, server_hostname=server_hostname, **kwargs)\n    else:\n        # fallback: use ssl.wrap_socket (older API) - rarely needed today\n        # Pass server_hostname only if Python version supports it (Python 3.5+)\n        wrap_args = dict(kwargs)\n        if server_hostname is not None:\n            wrap_args['server_hostname'] = server_hostname\n        return ssl.wrap_socket(socket, ssl_context=context, **wrap_args)", "message": "passed", "passed": true}
{"task_id": 258, "prediction_id": 2, "generation": "import ssl\nfrom typing import Any, Dict, Optional, Union\nimport socket\n\nfrom tornado.netutil import ssl_options_to_context\n\n\ndef ssl_wrap_socket(\n    socket: socket.socket,\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext],\n    server_hostname: Optional[str] = None,\n    **kwargs: Any\n) -> ssl.SSLSocket:\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n    # From Python 3.7+, SSLContext.wrap_socket supports `server_hostname` for SNI.\n    # We must pass server_hostname only if context is SSLContext.\n    # Pass any extra **kwargs to wrap_socket.\n\n    # If server_hostname is None, don't pass it.\n    if server_hostname is not None:\n        return context.wrap_socket(socket, server_hostname=server_hostname, **kwargs)\n    else:\n        return context.wrap_socket(socket, **kwargs)", "message": "passed", "passed": true}
{"task_id": 258, "prediction_id": 3, "generation": "import ssl\nfrom typing import Any, Dict, Optional, Union\nimport socket\nfrom tornado.netutil import ssl_options_to_context\n\n\ndef ssl_wrap_socket(\n    socket: socket.socket,\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext],\n    server_hostname: Optional[str] = None,\n    **kwargs: Any\n) -> ssl.SSLSocket:\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n    return context.wrap_socket(socket, server_hostname=server_hostname, **kwargs)", "message": "passed", "passed": true}
{"task_id": 258, "prediction_id": 4, "generation": "import ssl\nfrom typing import Any, Dict, Optional, Union\nfrom tornado.netutil import ssl_options_to_context\nimport socket\n\n\ndef ssl_wrap_socket(\n    socket: socket.socket,\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext],\n    server_hostname: Optional[str] = None,\n    **kwargs: Any\n) -> ssl.SSLSocket:\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n\n    # Use the SSLContext.wrap_socket method; server_hostname is used for SNI\n    # It is supported optionally; some older Python versions might not support it,\n    # but tornado requires Python 3.x, and server_hostname is generally supported.\n\n    return context.wrap_socket(socket, server_hostname=server_hostname, **kwargs)", "message": "passed", "passed": true}
