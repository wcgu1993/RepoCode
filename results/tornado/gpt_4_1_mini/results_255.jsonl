{"task_id": 255, "prediction_id": 0, "generation": "import socket\nfrom typing import Callable, Any\nfrom tornado.ioloop import IOLoop\n\ndef add_accept_handler(\n    sock: socket.socket, callback: Callable[[socket.socket, Any], None]\n) -> Callable[[], None]:\n    \"\"\"Adds an `.IOLoop` event handler to accept new connections on ``sock``.\n\n    When a connection is accepted, ``callback(connection, address)`` will\n    be run (``connection`` is a socket object, and ``address`` is the\n    address of the other end of the connection).  Note that this signature\n    is different from the ``callback(fd, events)`` signature used for\n    `.IOLoop` handlers.\n\n    A callable is returned which, when called, will remove the `.IOLoop`\n    event handler and stop processing further incoming connections.\n\n    .. versionchanged:: 5.0\n    The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n\n    .. versionchanged:: 5.0\n    A callable is returned (``None`` was returned before).\n    \"\"\"\n    io_loop = IOLoop.current()\n    fd = sock.fileno()\n\n    def handle_events(fd_int, events):\n        # Accept connections repeatedly until there are no more.\n        # This avoids starvation if multiple connections are waiting.\n        while True:\n            try:\n                connection, address = sock.accept()\n                # Set connection non-blocking for safety (common practice)\n                connection.setblocking(False)\n            except (BlockingIOError, InterruptedError):\n                # No more connections to accept at this time\n                break\n            except OSError as e:\n                # If this was a real error other than no more to accept, log and break\n                err = getattr(e, 'errno', None)\n                if err in (errno.EWOULDBLOCK, errno.EAGAIN):\n                    break\n                # Unexpected error, re-raise\n                raise\n            else:\n                # Run user callback for each accepted connection\n                callback(connection, address)\n\n    io_loop.add_handler(fd, handle_events, IOLoop.READ)\n\n    def remove_handler():\n        try:\n            io_loop.remove_handler(fd)\n        except Exception:\n            # Defensive: ignore errors on removal\n            pass\n\n    return remove_handler", "message": "passed", "passed": true}
{"task_id": 255, "prediction_id": 1, "generation": "import socket\nfrom typing import Callable, Any\nfrom tornado.ioloop import IOLoop\n\n\ndef add_accept_handler(\n    sock: socket.socket, callback: Callable[[socket.socket, Any], None]\n) -> Callable[[], None]:\n    \"\"\"Adds an `.IOLoop` event handler to accept new connections on ``sock``.\n\n    When a connection is accepted, ``callback(connection, address)`` will\n    be run (``connection`` is a socket object, and ``address`` is the\n    address of the other end of the connection).  Note that this signature\n    is different from the ``callback(fd, events)`` signature used for\n    `.IOLoop` handlers.\n\n    A callable is returned which, when called, will remove the `.IOLoop`\n    event handler and stop processing further incoming connections.\n\n    .. versionchanged:: 5.0\n    The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n\n    .. versionchanged:: 5.0\n    A callable is returned (``None`` was returned before).\n    \"\"\"\n    io_loop = IOLoop.current()\n    fd = sock.fileno()\n\n    def accept_handler(fd_arg, events):\n        # Accept all pending connections (may be multiple ready)\n        while True:\n            try:\n                connection, address = sock.accept()\n                connection.setblocking(False)\n            except (BlockingIOError, InterruptedError):\n                # No more connections to accept right now\n                break\n            except Exception:\n                # Unexpected error, log and stop\n                io_loop.add_callback(lambda: io_loop._run_callback(lambda: callback(None, None)))\n                break\n            else:\n                # Run the user-provided callback with the new connection and address\n                callback(connection, address)\n\n    io_loop.add_handler(fd, accept_handler, IOLoop.READ)\n\n    def remove_handler():\n        try:\n            io_loop.remove_handler(fd)\n        except Exception:\n            pass\n\n    return remove_handler", "message": "passed", "passed": true}
{"task_id": 255, "prediction_id": 2, "generation": "import socket\nfrom typing import Callable, Any\nfrom tornado.ioloop import IOLoop\n\ndef add_accept_handler(\n    sock: socket.socket, callback: Callable[[socket.socket, Any], None]\n) -> Callable[[], None]:\n    \"\"\"Adds an `.IOLoop` event handler to accept new connections on ``sock``.\n\n    When a connection is accepted, ``callback(connection, address)`` will\n    be run (``connection`` is a socket object, and ``address`` is the\n    address of the other end of the connection).  Note that this signature\n    is different from the ``callback(fd, events)`` signature used for\n    `.IOLoop` handlers.\n\n    A callable is returned which, when called, will remove the `.IOLoop`\n    event handler and stop processing further incoming connections.\n\n    .. versionchanged:: 5.0\n    The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n\n    .. versionchanged:: 5.0\n    A callable is returned (``None`` was returned before).\n    \"\"\"\n    io_loop = IOLoop.current()\n\n    def accept_handler(fd, events):\n        # Accept all pending connections without blocking\n        while True:\n            try:\n                connection, address = sock.accept()\n            except (BlockingIOError, InterruptedError):\n                # No more connections to accept right now\n                break\n            except OSError as e:\n                # If we have a rare recoverable error, break loop, else raise\n                if e.errno in (errno.EWOULDBLOCK, errno.EAGAIN):\n                    break\n                raise\n            else:\n                callback(connection, address)\n\n    fd = sock.fileno()\n    io_loop.add_handler(fd, accept_handler, io_loop.READ)\n\n    def remove_handler():\n        io_loop.remove_handler(fd)\n\n    return remove_handler", "message": "passed", "passed": true}
{"task_id": 255, "prediction_id": 3, "generation": "import socket\nfrom typing import Callable, Any\n\nfrom tornado.ioloop import IOLoop\n\n\ndef add_accept_handler(\n    sock: socket.socket, callback: Callable[[socket.socket, Any], None]\n) -> Callable[[], None]:\n    \"\"\"Adds an `.IOLoop` event handler to accept new connections on ``sock``.\n\n    When a connection is accepted, ``callback(connection, address)`` will\n    be run (``connection`` is a socket object, and ``address`` is the\n    address of the other end of the connection).  Note that this signature\n    is different from the ``callback(fd, events)`` signature used for\n    `.IOLoop` handlers.\n\n    A callable is returned which, when called, will remove the `.IOLoop`\n    event handler and stop processing further incoming connections.\n\n    .. versionchanged:: 5.0\n    The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n\n    .. versionchanged:: 5.0\n    A callable is returned (``None`` was returned before).\n    \"\"\"\n    io_loop = IOLoop.current()\n\n    def accept_handler(fd: int, events: int) -> None:\n        try:\n            while True:\n                try:\n                    connection, address = sock.accept()\n                    connection.setblocking(False)\n                except (BlockingIOError, InterruptedError):\n                    # No more connections to accept at this moment\n                    break\n                except OSError as e:\n                    # If the socket is non-blocking and no connections are present,\n                    # accept() may raise an OSError with EWOULDBLOCK or EAGAIN,\n                    # which we treat as no connections to accept.\n                    err = getattr(e, \"errno\", None)\n                    if err in (errno.EWOULDBLOCK, errno.EAGAIN):\n                        break\n                    raise\n                callback(connection, address)\n        except Exception:\n            # Log error but prevent crash in event loop\n            from tornado.log import app_log\n\n            app_log.error(\"Error in accept_handler\", exc_info=True)\n\n    # Add the accept_handler to the IOLoop to watch for read events\n    io_loop.add_handler(sock.fileno(), accept_handler, IOLoop.READ)\n\n    def remove_handler() -> None:\n        io_loop.remove_handler(sock.fileno())\n\n    return remove_handler", "message": "passed", "passed": true}
{"task_id": 255, "prediction_id": 4, "generation": "import socket\nfrom typing import Callable, Any\n\nfrom tornado.ioloop import IOLoop\n\n\ndef add_accept_handler(\n    sock: socket.socket, callback: Callable[[socket.socket, Any], None]\n) -> Callable[[], None]:\n    \"\"\"Adds an `.IOLoop` event handler to accept new connections on ``sock``.\n\n    When a connection is accepted, ``callback(connection, address)`` will\n    be run (``connection`` is a socket object, and ``address`` is the\n    address of the other end of the connection).  Note that this signature\n    is different from the ``callback(fd, events)`` signature used for\n    `.IOLoop` handlers.\n\n    A callable is returned which, when called, will remove the `.IOLoop`\n    event handler and stop processing further incoming connections.\n\n    .. versionchanged:: 5.0\n    The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n\n    .. versionchanged:: 5.0\n    A callable is returned (``None`` was returned before).\n    \"\"\"\n    io_loop = IOLoop.current()\n    fd = sock.fileno()\n\n    def _handle_events(fd_param, events):\n        try:\n            while True:\n                # Accept all available connections\n                connection, address = sock.accept()\n                # Set the accepted socket to non-blocking mode\n                connection.setblocking(False)\n                callback(connection, address)\n        except (BlockingIOError, InterruptedError):\n            # No more connections are ready to be accepted\n            pass\n\n    # Add the socket's file descriptor to the IOLoop with READ events\n    io_loop.add_handler(fd, _handle_events, IOLoop.READ)\n\n    def remove_handler():\n        io_loop.remove_handler(fd)\n\n    return remove_handler", "message": "passed", "passed": true}
