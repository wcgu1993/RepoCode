{"task_id": 252, "prediction_id": 0, "generation": "import binascii\nimport hashlib\nimport hmac\nimport time\nimport urllib.parse\n\nfrom tornado import escape\n\n\ndef _oauth10a_signature(\n    consumer_token: dict,\n    method: str,\n    url: str,\n    parameters: dict = {},\n    token: dict = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth 1.0a signature for the given request.\n\n    See http://oauth.net/core/1.0a/#signing_process\n    \"\"\"\n    # Normalize the URL (scheme and host lowercase, strip query, etc.)\n    parts = urllib.parse.urlparse(url)\n    scheme, netloc, path = parts.scheme.lower(), parts.netloc.lower(), parts.path\n    normalized_url = f\"{scheme}://{netloc}{path}\"\n\n    # Prepare the base string for signing (HTTP_METHOD&url&parameter_string)\n    # Parameters must be percent-encoded key=value pairs sorted by key\n    # Collect all parameters including oauth ones and any query/post parameters\n    # parameters dict may contain keys and values that need to be escaped\n\n    # Convert all keys and values to str and percent-encode them for signing.\n    # keys and values must be str - if bytes, convert to utf8 string first\n    def encode(value):\n        if isinstance(value, bytes):\n            value = value.decode(\"utf-8\")\n        return urllib.parse.quote(value, safe='~-._')\n\n    # Sort parameters by key, then by value if keys duplicate\n    items = []\n    for k, v in parameters.items():\n        # If v is a list or tuple, include all pairs; otherwise single pair\n        if isinstance(v, (list, tuple)):\n            for item in v:\n                items.append((encode(str(k)), encode(str(item))))\n        else:\n            items.append((encode(str(k)), encode(str(v))))\n    items.sort()\n\n    # Build the parameter string key=value pairs joined by &\n    param_string = \"&\".join(f\"{k}={v}\" for k, v in items)\n\n    # Construct the signature base string\n    base_elems = [\n        method.upper(),\n        normalized_url,\n        param_string,\n    ]\n    base_string = \"&\".join(urllib.parse.quote(elem, safe='~-._') for elem in base_elems)\n\n    # Construct the signing key\n    # key = percent_encode(consumer_secret) & percent_encode(token_secret or \"\")\n    def to_bytes(value):\n        if isinstance(value, bytes):\n            return value\n        return value.encode(\"utf-8\")\n\n    key_parts = [\n        to_bytes(consumer_token.get(\"secret\", \"\")),\n        to_bytes(token.get(\"secret\", \"\") if token else b\"\"),\n    ]\n    signing_key = b\"&\".join(key_parts)\n\n    # Compute HMAC-SHA1 signature and base64 encode\n    hashed = hmac.new(signing_key, base_string.encode(\"utf-8\"), hashlib.sha1)\n    signature = binascii.b2a_base64(hashed.digest())[:-1]  # remove trailing newline\n\n    return signature", "message": "passed", "passed": true}
{"task_id": 252, "prediction_id": 1, "generation": "import binascii\nimport hashlib\nimport hmac\nimport time\nimport urllib.parse\n\nfrom tornado import escape\n\n\ndef _oauth10a_signature(\n    consumer_token: dict,\n    method: str,\n    url: str,\n    parameters: dict = {},\n    token: dict = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth 1.0a signature for the given request.\n\n    See http://oauth.net/core/1.0a/#signing_process\n    \"\"\"\n    # Normalize URL by scheme, netloc, and path (no query or fragment)\n    parts = urllib.parse.urlparse(url)\n    scheme, netloc, path = parts[:3]\n    normalized_url = scheme.lower() + \"://\" + netloc.lower() + path\n\n    # Prepare parameters for base string: sort keys, escape keys and values\n    # parameters include all OAuth and request parameters (query and post)\n    # The signature base string: METHOD&urlencoded(BASE_URL)&urlencoded(PARAMS)\n    # Parameters must be sorted by key, keys and values percent encoded.\n\n    # According to RFC5849, repeated parameters should be sorted by name,\n    # then by value; we assume parameters dict has unique keys here.\n\n    # Construct the parameter string:\n    # - sort items by key\n    # - percent-encode key and value\n    # - join key=value pairs with &\n    def oauth_escape(s: str) -> str:\n        return urllib.parse.quote(s, safe='~')\n\n    # Sort parameters by key and then by value if duplicate keys\n    # Since parameters is a dict, keys are unique, so just sort by key.\n    encoded_params = []\n    for k, v in sorted(parameters.items()):\n        # escape both key and value to strings\n        ek = oauth_escape(str(k))\n        ev = oauth_escape(str(v))\n        encoded_params.append(f\"{ek}={ev}\")\n    param_str = \"&\".join(encoded_params)\n\n    base_elems = [\n        method.upper(),\n        normalized_url,\n        param_str,\n    ]\n    base_string = \"&\".join(oauth_escape(e) for e in base_elems)\n\n    # Build key for HMAC: consumer_secret&token_secret (token_secret can be empty)\n    consumer_secret_bytes = escape.utf8(consumer_token[\"secret\"])\n    token_secret_bytes = escape.utf8(token[\"secret\"]) if token and \"secret\" in token else b\"\"\n    key = consumer_secret_bytes + b\"&\" + token_secret_bytes\n\n    # Calculate HMAC-SHA1 digest and base64 encode it without trailing newline\n    hashed = hmac.new(key, escape.utf8(base_string), hashlib.sha1)\n    signature = binascii.b2a_base64(hashed.digest())[:-1]  # remove trailing newline\n\n    return signature", "message": "passed", "passed": true}
{"task_id": 252, "prediction_id": 2, "generation": "import binascii\nimport hashlib\nimport hmac\nimport time\nimport urllib.parse\n\nfrom tornado import escape\n\n\ndef _oauth10a_signature(\n    consumer_token: dict,\n    method: str,\n    url: str,\n    parameters: dict = {},\n    token: dict = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth 1.0a signature for the given request.\n\n    See http://oauth.net/core/1.0a/#signing_process\n    \"\"\"\n    # Normalize the URL (scheme and netloc lowercased, path only, no query or fragment)\n    parts = urllib.parse.urlparse(url)\n    scheme, netloc, path = parts.scheme.lower(), parts.netloc.lower(), parts.path\n    normalized_url = f\"{scheme}://{netloc}{path}\"\n\n    # Prepare the parameter string sorted by encoded key\n    # Parameters should include all query and POST arguments plus OAuth params\n    # Each key and value are percent-encoded\n    encoded_params = []\n    for k, v in sorted(parameters.items()):\n        encoded_k = _oauth_escape(str(k))\n        encoded_v = _oauth_escape(str(v))\n        encoded_params.append(f\"{encoded_k}={encoded_v}\")\n\n    parameter_string = \"&\".join(encoded_params)\n\n    # Construct the base string\n    base_elems = [\n        method.upper(),\n        normalized_url,\n        parameter_string,\n    ]\n    base_string = \"&\".join(_oauth_escape(e) for e in base_elems)\n\n    # Construct signing key: consumer_secret&token_secret (token_secret may be empty string)\n    consumer_secret = escape.utf8(consumer_token[\"secret\"])\n    token_secret = escape.utf8(token[\"secret\"]) if token and \"secret\" in token else b\"\"\n    key = b\"&\".join([consumer_secret, token_secret])\n\n    # Compute HMAC-SHA1 and base64 encode the result (without trailing newline)\n    hashed = hmac.new(key, escape.utf8(base_string), hashlib.sha1)\n    return binascii.b2a_base64(hashed.digest())[:-1]\n\n\ndef _oauth_escape(s: str) -> str:\n    # OAuth 1.0 percent encoding, similar to urllib.parse.quote but with safe chars '-._~'\n    return urllib.parse.quote(s, safe='~-._')", "message": "passed", "passed": true}
{"task_id": 252, "prediction_id": 3, "generation": "import base64\nimport binascii\nimport hashlib\nimport hmac\nimport time\nimport urllib.parse\nfrom typing import Dict, Any, Optional\n\n\ndef _oauth10a_signature(\n    consumer_token: Dict[str, Any],\n    method: str,\n    url: str,\n    parameters: Dict[str, Any] = {},\n    token: Optional[Dict[str, Any]] = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth 1.0a signature for the given request.\n\n    See http://oauth.net/core/1.0a/#signing_process\n    \"\"\"\n    # Parse the url to normalize it (scheme, netloc, path)\n    parts = urllib.parse.urlparse(url)\n    scheme, netloc, path = parts[:3]\n    normalized_url = scheme.lower() + \"://\" + netloc.lower() + path\n\n    # Normalize and sort parameters\n    # According to OAuth spec, each key=value pairs must be percent encoded,\n    # then joined with '&'\n    def _oauth_escape(s: str) -> str:\n        # Same escaping as Twitter and OAuth 1.0 spec\n        return urllib.parse.quote(str(s), safe='~')\n\n    # Collect all parameters, percent encode key and values, sort by key then value\n    # Note: parameters keys and values may be str or bytes; convert to str first\n    encoded_params = []\n    for k, v in parameters.items():\n        # parameters may be str, bytes or other, convert to str first\n        key_str = _oauth_escape(k)\n        value_str = _oauth_escape(v)\n        encoded_params.append((key_str, value_str))\n    # Sort lexicographically by key, then by value\n    encoded_params.sort(key=lambda tup: (tup[0], tup[1]))\n\n    # Build the parameter string: key=value&key=value...\n    normalized_params = \"&\".join(f\"{k}={v}\" for k, v in encoded_params)\n\n    # Construct the signature base string\n    base_elems = [\n        method.upper(),\n        _oauth_escape(normalized_url),\n        _oauth_escape(normalized_params),\n    ]\n    base_string = \"&\".join(base_elems)\n\n    # Construct the signing key:\n    # key = urlencode(consumer_secret) + '&' + urlencode(token_secret or \"\")\n    # consumer_token and token may have keys or bytes - convert to bytes after encoding\n    def to_bytes(x: Any) -> bytes:\n        # From tornado.escape.utf8 - ensure bytes\n        if isinstance(x, bytes):\n            return x\n        if isinstance(x, str):\n            return x.encode(\"utf-8\")\n        return str(x).encode(\"utf-8\")\n\n    consumer_secret = to_bytes(consumer_token[\"secret\"])\n    token_secret = to_bytes(token[\"secret\"]) if token else b\"\"\n    signing_key = b\"&\".join([consumer_secret, token_secret])\n\n    # Compute the HMAC-SHA1 signature and base64 encode without newlines\n    hashed = hmac.new(signing_key, to_bytes(base_string), hashlib.sha1)\n    signature = binascii.b2a_base64(hashed.digest())[:-1]  # strip trailing newline\n\n    return signature", "message": "passed", "passed": true}
{"task_id": 252, "prediction_id": 4, "generation": "import base64\nimport binascii\nimport hashlib\nimport hmac\nimport time\nimport urllib.parse\nimport uuid\n\nfrom tornado import escape\n\n\ndef _oauth10a_signature(\n    consumer_token: dict,\n    method: str,\n    url: str,\n    parameters: dict = {},\n    token: dict = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth 1.0a signature for the given request.\n\n    See http://oauth.net/core/1.0a/#signing_process\n    \"\"\"\n    # Normalize URL: scheme + netloc + path (no query)\n    parts = urllib.parse.urlparse(url)\n    scheme, netloc, path = parts.scheme, parts.netloc, parts.path\n    normalized_url = scheme.lower() + \"://\" + netloc.lower() + path\n\n    # Create the base string elements: HTTP method, normalized URL, normalized parameters\n    method_upper = method.upper()\n\n    # OAuth protocol requires parameters sorted by key lex order\n    # and urlencoded key=value pairs joined by \"&\"\n    # Parameters should include all query and post arguments plus OAuth arguments.\n\n    # According to RFC 5849, parameter keys and values must be percent-encoded\n    # For signing base string, keys and values are encoded by _oauth_escape function.\n    def _oauth_escape(s: str) -> str:\n        return urllib.parse.quote(s, safe='~-._')\n\n    # Sort parameters by key then by value (if multiple values per key - not the case here)\n    # Because parameters is a dict with str keys and values, we sort by keys only.\n    # Compose the param string as key=value, joined by &\n\n    # Some values can be bytes, ensure all are str before encoding\n    encoded_params = []\n    for k, v in sorted(parameters.items()):\n        k_enc = _oauth_escape(str(k))\n        v_enc = _oauth_escape(str(v))\n        encoded_params.append(f\"{k_enc}={v_enc}\")\n    params_string = \"&\".join(encoded_params)\n\n    base_elems = [\n        method_upper,\n        normalized_url,\n        params_string,\n    ]\n    base_string = \"&\".join(_oauth_escape(e) for e in base_elems)\n\n    # Construct signing key: consumer_secret&token_secret (token_secret optional)\n    key_elems = [\n        escape.utf8(consumer_token[\"secret\"]),\n        escape.utf8(token[\"secret\"]) if token and \"secret\" in token else b\"\",\n    ]\n    signing_key = b\"&\".join(key_elems)\n\n    # Calculate HMAC-SHA1 signature and base64-encode without newline\n    hashed = hmac.new(signing_key, escape.utf8(base_string), hashlib.sha1)\n    signature = binascii.b2a_base64(hashed.digest())[:-1]  # strip trailing newline\n\n    return signature", "message": "passed", "passed": true}
