{"task_id": 277, "prediction_id": 0, "generation": "import collections\nimport re\n\nResponseStartLine = collections.namedtuple(\n    \"ResponseStartLine\", [\"version\", \"code\", \"reason\"]\n)\n\n_http_response_line_re = re.compile(r\"^(HTTP/1\\.[0-9]) ([0-9]{3}) ([^\\r]*)$\")\n\ndef parse_response_start_line(line: str) -> ResponseStartLine:\n    \"\"\"Returns a (version, code, reason) tuple for an HTTP 1.x response line.\n\n    The response is a `collections.namedtuple`.\n\n    >>> parse_response_start_line(\"HTTP/1.1 200 OK\")\n    ResponseStartLine(version='HTTP/1.1', code=200, reason='OK')\n    \"\"\"\n    match = _http_response_line_re.match(line)\n    if not match:\n        # The input line does not conform to expected response start line format\n        # Should raise HTTPInputError consistent with parse_request_start_line style\n        from tornado.httpserver import HTTPInputError  # assuming it exists; else define below\n        raise HTTPInputError(f\"Malformed HTTP response line: {line!r}\")\n    version, code_str, reason = match.groups()\n    return ResponseStartLine(version, int(code_str), reason)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1204, in <module>\n  File \"<string>\", line 1203, in test_16\n  File \"<string>\", line 931, in parse_response_start_line\nTypeError: cannot use a string pattern on a bytes-like object\n", "passed": false}
{"task_id": 277, "prediction_id": 1, "generation": "import collections\nimport re\n\nResponseStartLine = collections.namedtuple(\n    \"ResponseStartLine\", [\"version\", \"code\", \"reason\"]\n)\n\n_http_response_line_re = re.compile(r\"^(HTTP/1\\.[0-9]) ([0-9]{3}) (.*)$\")\n\ndef parse_response_start_line(line: str) -> ResponseStartLine:\n    \"\"\"Returns a (version, code, reason) tuple for an HTTP 1.x response line.\n\n    The response is a `collections.namedtuple`.\n\n    >>> parse_response_start_line(\"HTTP/1.1 200 OK\")\n    ResponseStartLine(version='HTTP/1.1', code=200, reason='OK')\n    \"\"\"\n    m = _http_response_line_re.match(line)\n    if not m:\n        # The line does not match expected HTTP response start line format\n        raise ValueError(f\"Malformed HTTP response line: {line!r}\")\n    version, code_str, reason = m.groups()\n    return ResponseStartLine(version, int(code_str), reason)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1202, in <module>\n  File \"<string>\", line 1201, in test_16\n  File \"<string>\", line 931, in parse_response_start_line\nTypeError: cannot use a string pattern on a bytes-like object\n", "passed": false}
{"task_id": 277, "prediction_id": 2, "generation": "import collections\nimport re\n\nResponseStartLine = collections.namedtuple(\n    \"ResponseStartLine\", [\"version\", \"code\", \"reason\"]\n)\n\n_http_response_line_re = re.compile(r\"^(HTTP/1\\.[0-9]) ([0-9]{3}) ([^\\r]*)$\")\n\n\ndef parse_response_start_line(line: str) -> ResponseStartLine:\n    \"\"\"Returns a (version, code, reason) tuple for an HTTP 1.x response line.\n\n    The response is a `collections.namedtuple`.\n\n    >>> parse_response_start_line(\"HTTP/1.1 200 OK\")\n    ResponseStartLine(version='HTTP/1.1', code=200, reason='OK')\n    \"\"\"\n    match = _http_response_line_re.match(line)\n    if not match:\n        raise ValueError(\"Malformed HTTP response line\")\n    version, code_str, reason = match.groups()\n    return ResponseStartLine(version, int(code_str), reason)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1202, in <module>\n  File \"<string>\", line 1201, in test_16\n  File \"<string>\", line 932, in parse_response_start_line\nTypeError: cannot use a string pattern on a bytes-like object\n", "passed": false}
{"task_id": 277, "prediction_id": 3, "generation": "import collections\nimport re\nfrom typing import Optional\n\nResponseStartLine = collections.namedtuple(\n    \"ResponseStartLine\", [\"version\", \"code\", \"reason\"]\n)\n\n\n_http_response_line_re = re.compile(r\"^(HTTP/1\\.[0-9]) ([0-9]+) ([^\\r\\n]*)$\")\n\n\ndef parse_response_start_line(line: str) -> ResponseStartLine:\n    \"\"\"Returns a (version, code, reason) tuple for an HTTP 1.x response line.\n\n    The response is a `collections.namedtuple`.\n\n    >>> parse_response_start_line(\"HTTP/1.1 200 OK\")\n    ResponseStartLine(version='HTTP/1.1', code=200, reason='OK')\n    \"\"\"\n    match = _http_response_line_re.match(line)\n    if not match:\n        raise ValueError(f\"Malformed HTTP response line: {line!r}\")\n    version, code_str, reason = match.groups()\n    code = int(code_str)\n    return ResponseStartLine(version, code, reason)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1205, in <module>\n  File \"<string>\", line 1204, in test_16\n  File \"<string>\", line 934, in parse_response_start_line\nTypeError: cannot use a string pattern on a bytes-like object\n", "passed": false}
{"task_id": 277, "prediction_id": 4, "generation": "import collections\nimport re\nfrom typing import Optional\n\nResponseStartLine = collections.namedtuple(\n    \"ResponseStartLine\", [\"version\", \"code\", \"reason\"]\n)\n\n_http_response_line_re = re.compile(r\"^(HTTP/1\\.[0-9]) ([0-9]{3}) (.*)$\")\n\n\ndef parse_response_start_line(line: str) -> ResponseStartLine:\n    \"\"\"Returns a (version, code, reason) tuple for an HTTP 1.x response line.\n\n    The response is a `collections.namedtuple`.\n\n    >>> parse_response_start_line(\"HTTP/1.1 200 OK\")\n    ResponseStartLine(version='HTTP/1.1', code=200, reason='OK')\n    \"\"\"\n    match: Optional[re.Match] = _http_response_line_re.match(line)\n    if not match:\n        # Malformed response line should ideally raise an error similar to parse_request_start_line\n        # but none specified: raising HTTPInputError accordingly\n        from tornado.httpserver import HTTPInputError  # (if needed in integrated usage)\n        raise HTTPInputError(f\"Malformed HTTP response line: {line!r}\")\n    version, code_str, reason = match.groups()\n    code = int(code_str)\n    return ResponseStartLine(version, code, reason)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1207, in <module>\n  File \"<string>\", line 1206, in test_16\n  File \"<string>\", line 933, in parse_response_start_line\nTypeError: cannot use a string pattern on a bytes-like object\n", "passed": false}
