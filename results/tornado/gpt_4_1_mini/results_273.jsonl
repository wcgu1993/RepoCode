{"task_id": 273, "prediction_id": 0, "generation": "from typing import Optional, Tuple\n\n\ndef _parse_request_range(\n    range_header: str,\n) -> Optional[Tuple[Optional[int], Optional[int]]]:\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n    if not range_header.startswith(\"bytes=\"):\n        return None\n\n    # Remove the \"bytes=\" prefix\n    range_str = range_header[6:].strip()\n\n    # If empty, return (None, None)\n    if not range_str:\n        return (None, None)\n\n    # Only support one range, so reject if comma is present\n    if \",\" in range_str:\n        return None\n\n    # Parse start and end points separated by '-'\n    if \"-\" not in range_str:\n        return None  # malformed\n\n    start_str, end_str = range_str.split(\"-\", 1)\n\n    start: Optional[int] = None\n    end: Optional[int] = None\n\n    if start_str == \"\":\n        # This is a suffix-byte-range-spec: \"-<suffix-length>\"\n        # Example: \"bytes=-6\"\n        # Note: \"-0\" is acceptable and means (None,0)\n        try:\n            suffix_len = int(end_str)\n        except ValueError:\n            return None\n        if suffix_len == 0:\n            # According to example: (None, 0)\n            return (None, 0)\n        return (-suffix_len, None)\n\n    # Otherwise, parse start\n    try:\n        start = int(start_str)\n    except ValueError:\n        return None\n\n    if end_str == \"\":\n        # Example: \"bytes=6-\"\n        return (start, None)\n\n    # parse end\n    try:\n        end_inclusive = int(end_str)\n    except ValueError:\n        return None\n\n    # The HTTP Range header specifies inclusive end, so convert to exclusive by adding +1\n    # However, the end must be >= start if both are provided and start >= 0\n    if end_inclusive < start:\n        # Invalid range\n        return None\n\n    return (start, end_inclusive + 1)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1212, in <module>\n  File \"<string>\", line 1211, in test_16\nTypeError: 'NoneType' object is not subscriptable\n", "passed": false}
{"task_id": 273, "prediction_id": 1, "generation": "import re\nfrom typing import Optional, Tuple\n\ndef _parse_request_range(\n    range_header: str,\n) -> Optional[Tuple[Optional[int], Optional[int]]]:\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n\n    if not range_header.startswith(\"bytes=\"):\n        return None\n\n    ranges_part = range_header[len(\"bytes=\"):].strip()\n    # Reject multiple ranges (commas)\n    if ',' in ranges_part:\n        return None\n\n    # empty range (e.g., \"bytes=\")\n    if ranges_part == \"\":\n        return (None, None)\n\n    # regex for a single range specifier: start-end\n    # both start and end are optional to cover suffix or open ranges\n    # Examples:\n    #  \"1-2\", \"6-\", \"-6\"\n    match = re.fullmatch(r\"(\\d*)-(\\d*)\", ranges_part)\n    if not match:\n        return None\n\n    start_str, end_str = match.groups()\n\n    # Handle suffix case: \"-6\"\n    # if start_str is \"\", end_str is digits => suffix length (negative number)\n    if start_str == \"\":\n        # \"-0\" is a special case => (None, 0)\n        if end_str == \"0\":\n            return (None, 0)\n        else:\n            try:\n                suffix_len = int(end_str)\n            except ValueError:\n                return None\n            return (-suffix_len, None)\n\n    # Parse start (required in this case)\n    try:\n        start = int(start_str)\n    except ValueError:\n        return None\n\n    if end_str == \"\":\n        # open ended range\n        return (start, None)\n\n    try:\n        end = int(end_str)\n    except ValueError:\n        return None\n\n    # According to the docstring, HTTP Range header uses inclusive byte positions,\n    # but this function returns indexes for Python slices (end exclusive),\n    # so add 1 to end when returning it.\n\n    return (start, end + 1)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1197, in <module>\n  File \"<string>\", line 1196, in test_9\nTypeError: 'NoneType' object is not subscriptable\n", "passed": false}
{"task_id": 273, "prediction_id": 2, "generation": "import re\nfrom typing import Optional, Tuple\n\ndef _parse_request_range(\n    range_header: str,\n) -> Optional[Tuple[Optional[int], Optional[int]]]:\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n    if not range_header:\n        return None\n\n    range_header = range_header.strip()\n    # Only accept ranges starting with \"bytes=\"\n    if not range_header.startswith(\"bytes=\"):\n        return None\n\n    # Strip prefix\n    ranges_spec = range_header[6:]\n\n    # Only accept a single range, reject multiple ranges\n    if ',' in ranges_spec:\n        return None\n\n    # Allowed formats:\n    # 1) \"start-end\"\n    # 2) \"start-\"\n    # 3) \"-suffix_length\"\n    # 4) empty, e.g. \"bytes=\"\n\n    # If empty after bytes=, return (None, None)\n    if ranges_spec == '':\n        return (None, None)\n\n    m = re.fullmatch(r'(\\d*)-(\\d*)', ranges_spec)\n    if not m:\n        return None\n\n    start_str, end_str = m.groups()\n\n    # Logic according to RFC and example tests:\n    # If start_str present:\n    #   If end_str present: return (start, end+1)\n    #   else: return (start, None)\n    # If start_str empty:\n    #   If end_str present:\n    #       if end_str==\"0\": (None, 0)\n    #       else: (-int(end_str), None)\n    #   else:\n    #       (None, None)\n\n    if start_str:\n        start = int(start_str)\n        if end_str:\n            end = int(end_str)\n            # inclusive range, convert to slice end: +1\n            return (start, end + 1)\n        else:\n            return (start, None)\n    else:\n        if end_str:\n            if end_str == '0':\n                return (None, 0)\n            else:\n                return (-int(end_str), None)\n        else:\n            return (None, None)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1199, in <module>\n  File \"<string>\", line 1198, in test_9\nTypeError: 'NoneType' object is not subscriptable\n", "passed": false}
{"task_id": 273, "prediction_id": 3, "generation": "from typing import Optional, Tuple\n\n\ndef _parse_request_range(\n    range_header: str,\n) -> Optional[Tuple[Optional[int], Optional[int]]]:\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n\n    if not range_header.startswith(\"bytes=\"):\n        return None\n    ranges = range_header[6:].strip()\n    if not ranges:\n        return (None, None)\n    # Only support one range, reject multiple ranges separated by comma.\n    if \",\" in ranges:\n        return None\n\n    start_str, sep, end_str = ranges.partition(\"-\")\n    start = None\n    end = None\n\n    # Parse start\n    if start_str == \"\":\n        start = None\n    else:\n        try:\n            start = int(start_str)\n            if start < 0:\n                # Negative start without lead '-' is invalid\n                return None\n        except ValueError:\n            return None\n\n    # Parse end\n    if end_str == \"\":\n        end = None\n    else:\n        try:\n            end = int(end_str)\n            if end < 0:\n                # Negative end is not valid here according to standard\n                # but we will keep logic minimal and accept only non-negative end\n                return None\n        except ValueError:\n            return None\n\n    # Logic for the tuple to slice indexes:\n    # - If start is None (like bytes=-6), start is negative integer, according to test this is allowed.\n    #   But from above start would be None.\n    #   Actually in bytes=-6, start_str is \"\", end_str is \"6\"\n    #   So our vars are: start_str=\"\", end_str=\"6\"\n    #   That means the start_str is empty, so start=None; The end_str \"6\" parses to end=6\n    #   But test expects (-6, None).\n    #   So the slicing start is negative 6, end is None.\n    # So we have to interpret the ranges differently:\n    # bytes=6- -> start=6 end None\n    # bytes=-6 -> start=-6 end None\n    # According to RFC, bytes=-6 means last 6 bytes.\n\n    # So if start_str is empty, and end_str is a number n, then start = -n and end = None\n    if start_str == \"\" and end_str != \"\":\n        try:\n            n = int(end_str)\n        except ValueError:\n            return None\n        start = -n\n        end = None\n        # Special case: bytes=-0 means (None, 0)\n        if n == 0:\n            start = None\n            end = 0\n\n        return (start, end)\n\n    # bytes=1-2 means start=1, end=3 (for slicing)\n    # If start and end both not None, end += 1 for inclusive end in header to exclusive in slice\n    if start is not None and end is not None:\n        # Only if end >= start, otherwise invalid\n        if end < start:\n            return None\n        end += 1\n\n    return (start, end)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1217, in <module>\n  File \"<string>\", line 1216, in test_9\nTypeError: 'NoneType' object is not subscriptable\n", "passed": false}
{"task_id": 273, "prediction_id": 4, "generation": "from typing import Optional, Tuple\nimport re\n\n\ndef _parse_request_range(\n    range_header: str,\n) -> Optional[Tuple[Optional[int], Optional[int]]]:\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n    if not range_header.startswith(\"bytes=\"):\n        return None\n\n    ranges = range_header[6:]  # Strip \"bytes=\"\n    # Check for multiple ranges. If comma present, reject.\n    if \",\" in ranges:\n        return None\n\n    # Match patterns:\n    # 1) start-end (both optional)\n    # 2) -suffix-length\n    # 3) start-  (no end)\n    # \"\" empty range is allowed (means (None, None))\n\n    # regex for range:  ^(\\d*)-(\\d*)$\n    match = re.match(r\"^(\\d*)-(\\d*)$\", ranges)\n    if not match:\n        return None\n\n    start_str, end_str = match.group(1), match.group(2)\n    # Handle cases:\n    # If start_str and end_str are both empty - empty range\n    if start_str == \"\" and end_str == \"\":\n        return (None, None)\n\n    # If start_str is empty, this is a suffix range: bytes=-X\n    if start_str == \"\":\n        # suffix-length could be zero or positive int\n        try:\n            suffix_length = int(end_str)\n        except ValueError:\n            return None\n        # Special case: bytes=-0 means (None,0)\n        if suffix_length == 0:\n            return (None, 0)\n        return (-suffix_length, None)\n\n    # Otherwise start_str is not empty\n    try:\n        start = int(start_str)\n    except ValueError:\n        return None\n\n    if end_str == \"\":\n        # open-ended range: bytes=X-\n        return (start, None)\n\n    try:\n        end = int(end_str)\n    except ValueError:\n        return None\n\n    # According to docstring, the HTTP Range header uses inclusive byte positions,\n    # but this method returns indexes suitable for use in slices.\n    # So we add 1 to end if end >= start to make the slice exclusive at end.\n    if end >= start:\n        return (start, end + 1)\n    else:\n        # In case end < start, treat range as invalid (return None)\n        return None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1194, in <module>\n  File \"<string>\", line 1193, in test_6\nAssertionError\n", "passed": false}
