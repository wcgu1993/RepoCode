{"task_id": 284, "prediction_id": 0, "generation": "from typing import Dict\n\n\ndef parse_cookie(cookie: str) -> Dict[str, str]:\n    \"\"\"Parse a ``Cookie`` HTTP header into a dict of name/value pairs.\n\n    This function attempts to mimic browser cookie parsing behavior;\n    it specifically does not follow any of the cookie-related RFCs\n    (because browsers don't either).\n\n    The algorithm used is identical to that used by Django version 1.9.10.\n\n    .. versionadded:: 4.4.2\n    \"\"\"\n    cookie_dict = {}\n    if not cookie:\n        return cookie_dict\n\n    length = len(cookie)\n    i = 0\n\n    while i < length:\n        # Skip whitespace and separators before cookie name\n        while i < length and cookie[i] in \" \\t\\r\\n\\f;\":\n            i += 1\n        if i >= length:\n            break\n\n        # Find the cookie name, which is the token before '=' or ';'\n        name_start = i\n        while i < length and cookie[i] not in \"=;\":\n            i += 1\n        name_end = i\n\n        name = cookie[name_start:name_end].strip()\n\n        # If the character is not '=', then skip this cookie (no value)\n        if i >= length or cookie[i] != \"=\":\n            # Skip until next ';' or end\n            while i < length and cookie[i] != \";\":\n                i += 1\n            i += 1\n            continue\n\n        # Skip '='\n        i += 1\n\n        # Now parse the cookie value\n        if i < length and cookie[i] == '\"':\n            # Quoted value\n            i += 1  # Skip opening quote\n            value_start = i\n            value_parts = []\n            while i < length:\n                ch = cookie[i]\n                if ch == '\"':\n                    break  # End of quoted value\n                if ch == '\\\\' and i + 1 < length:\n                    # Skip escaped char, add next char literally\n                    value_parts.append(cookie[i + 1])\n                    i += 2\n                    continue\n                else:\n                    value_parts.append(ch)\n                i += 1\n            else:\n                # No closing quote found, accept everything until end\n                pass\n            value = \"\".join(value_parts)\n            i += 1  # Skip closing quote if present\n            # Skip until next ';' or end\n            while i < length and cookie[i] != \";\":\n                i += 1\n            i += 1  # Skip ';' too\n        else:\n            # Unquoted value\n            value_start = i\n            while i < length and cookie[i] != \";\":\n                i += 1\n            value_end = i\n            value = cookie[value_start:value_end].strip()\n            i += 1  # Skip ';'\n\n        if name:\n            cookie_dict[name] = value\n\n    return cookie_dict", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1743, in <module>\n  File \"<string>\", line 1742, in test_7\nAssertionError\n", "passed": false}
{"task_id": 284, "prediction_id": 1, "generation": "from typing import Dict\n\n\ndef parse_cookie(cookie: str) -> Dict[str, str]:\n    \"\"\"Parse a ``Cookie`` HTTP header into a dict of name/value pairs.\n\n    This function attempts to mimic browser cookie parsing behavior;\n    it specifically does not follow any of the cookie-related RFCs\n    (because browsers don't either).\n\n    The algorithm used is identical to that used by Django version 1.9.10.\n\n    .. versionadded:: 4.4.2\n    \"\"\"\n    cookies = {}\n    if not cookie:\n        return cookies\n    length = len(cookie)\n    i = 0\n\n    while i < length:\n        # Skip whitespace and separators\n        while i < length and cookie[i] in \" \\t\\r\\n\\f\\v;\":\n            i += 1\n        if i >= length:\n            break\n\n        # Extract the key (cookie name)\n        key_start = i\n        while i < length and cookie[i] not in \"=;\":\n            i += 1\n        key_end = i\n        key = cookie[key_start:key_end].strip()\n\n        # Skip whitespace before equals or semicolon\n        while i < length and cookie[i] in \" \\t\\r\\n\\f\\v\":\n            i += 1\n\n        # If no '=' follows key, treat it as a valueless cookie and set empty string as value\n        if i >= length or cookie[i] != \"=\":\n            # valueless cookie, no value\n            cookies[key] = \"\"\n            # Find next semicolon or end\n            while i < length and cookie[i] not in \";\":\n                i += 1\n            continue\n\n        # Skip '='\n        i += 1\n\n        # Skip whitespace after '='\n        while i < length and cookie[i] in \" \\t\\r\\n\\f\\v\":\n            i += 1\n        if i >= length:\n            cookies[key] = \"\"\n            break\n\n        # Parse value\n        if cookie[i] == '\"':\n            # Quoted cookie value, handle backslash escapes and quotes inside\n            i += 1\n            value_start = i\n            value_chars = []\n            while i < length:\n                c = cookie[i]\n                if c == '\"':\n                    i += 1\n                    break\n                if c == '\\\\' and i + 1 < length:\n                    i += 1\n                    value_chars.append(cookie[i])\n                else:\n                    value_chars.append(c)\n                i += 1\n            value = \"\".join(value_chars)\n            # After quoted value, skip until next semicolon or end\n            while i < length and cookie[i] not in \";\":\n                i += 1\n            cookies[key] = value\n        else:\n            # Unquoted cookie value\n            value_start = i\n            while i < length and cookie[i] != \";\":\n                i += 1\n            value_end = i\n            value = cookie[value_start:value_end].strip()\n            cookies[key] = value\n\n    return cookies", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1498, in <module>\n  File \"<string>\", line 1497, in test_137\nAssertionError\n", "passed": false}
{"task_id": 284, "prediction_id": 2, "generation": "def parse_cookie(cookie: str) -> Dict[str, str]:\n    \"\"\"Parse a ``Cookie`` HTTP header into a dict of name/value pairs.\n\n    This function attempts to mimic browser cookie parsing behavior;\n    it specifically does not follow any of the cookie-related RFCs\n    (because browsers don't either).\n\n    The algorithm used is identical to that used by Django version 1.9.10.\n\n    .. versionadded:: 4.4.2\n    \"\"\"\n    cookies = {}\n    if not cookie:\n        return cookies\n\n    # Split cookie string on semicolons\n    # Browsers typically separate cookie pairs with \";\", and the algorithm:\n    # - splits on \";\" \n    # - strips whitespace\n    # - splits on first '=' into key, value\n    # - ignores empty keys\n    # Values without '=' are treated as keys with empty string value.\n\n    for chunk in cookie.split(\";\"):\n        chunk = chunk.strip()\n        if not chunk:\n            continue\n        if '=' in chunk:\n            key, value = chunk.split(\"=\", 1)\n            key = key.strip()\n            value = value.strip()\n            if key:\n                cookies[key] = value\n        else:\n            # No '=', treat whole chunk as key with empty value\n            cookies[chunk] = \"\"\n\n    return cookies", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1167, in <module>\n  File \"<string>\", line 1165, in test_11\nAssertionError\n", "passed": false}
{"task_id": 284, "prediction_id": 3, "generation": "import re\nfrom typing import Dict\n\ndef parse_cookie(cookie: str) -> Dict[str, str]:\n    \"\"\"Parse a ``Cookie`` HTTP header into a dict of name/value pairs.\n\n    This function attempts to mimic browser cookie parsing behavior;\n    it specifically does not follow any of the cookie-related RFCs\n    (because browsers don't either).\n\n    The algorithm used is identical to that used by Django version 1.9.10.\n\n    .. versionadded:: 4.4.2\n    \"\"\"\n    cookies = {}\n    if not cookie:\n        return cookies\n\n    # The regex below matches cookie pairs (key=value) and flags (key without =).\n    # Cookies are separated by ';', commas can also be used to separate cookies but are ambiguous, so use ';' as primary separator.\n    # Leading/trailing whitespace around keys and values are stripped.\n    # Quoted values with escapes are unquoted similarly to _unquote_cookie function (copied from Python stdlib but simplified here).\n    def _unquote(s: str) -> str:\n        if len(s) >= 2 and s[0] == '\"' and s[-1] == '\"':\n            s = s[1:-1]\n            # Replace escaped characters \\\" and \\\\ with their literal equivalents\n            # We'll do a simple replace since cookie escaping is limited\n            s = s.replace(r'\\\"', '\"').replace(r'\\\\', '\\\\')\n        return s\n\n    parts = cookie.split(\";\")\n    for part in parts:\n        if not part.strip():\n            continue\n        if \"=\" in part:\n            name, value = part.split(\"=\", 1)\n            name = name.strip()\n            value = value.strip()\n            value = _unquote(value)\n            cookies[name] = value\n        else:\n            # Cookies without \"=\" set to empty string (flag cookies)\n            name = part.strip()\n            if name:\n                cookies[name] = \"\"\n    return cookies", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1455, in <module>\n  File \"<string>\", line 1454, in test_137\nAssertionError\n", "passed": false}
{"task_id": 284, "prediction_id": 4, "generation": "from typing import Dict\n\n\ndef parse_cookie(cookie: str) -> Dict[str, str]:\n    \"\"\"Parse a ``Cookie`` HTTP header into a dict of name/value pairs.\n\n    This function attempts to mimic browser cookie parsing behavior;\n    it specifically does not follow any of the cookie-related RFCs\n    (because browsers don't either).\n\n    The algorithm used is identical to that used by Django version 1.9.10.\n\n    .. versionadded:: 4.4.2\n    \"\"\"\n    cookies = {}\n    if not cookie:\n        return cookies\n\n    # Split cookie header by semicolon\n    for chunk in cookie.split(';'):\n        if not chunk:\n            continue\n        if '=' in chunk:\n            key, val = chunk.split('=', 1)\n        else:\n            # If no '=', treat entire chunk as key with empty value\n            key, val = chunk, ''\n        key = key.strip()\n        val = val.strip()\n\n        # Strip double quotes from value if present (common for cookie values)\n        if len(val) >= 2 and val[0] == '\"' and val[-1] == '\"':\n            val = val[1:-1]\n\n        cookies[key] = val\n    return cookies", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1169, in <module>\n  File \"<string>\", line 1168, in test_13\nAssertionError\n", "passed": false}
