{"task_id": 254, "prediction_id": 0, "generation": "import socket\nimport errno\nfrom typing import List, Optional\n\n_DEFAULT_BACKLOG = 128  # from file content\n\ndef bind_sockets(\n    port: int,\n    address: Optional[str] = None,\n    family: socket.AddressFamily = socket.AF_UNSPEC,\n    backlog: int = _DEFAULT_BACKLOG,\n    flags: Optional[int] = None,\n    reuse_port: bool = False,\n) -> List[socket.socket]:\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen() <socket.socket.listen>`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    if flags is None:\n        flags = socket.AI_PASSIVE\n\n    # Prepare list to collect bound sockets\n    sockets = []\n\n    # Use getaddrinfo to resolve address (or empty string if None)\n    try:\n        info = socket.getaddrinfo(\n            address if address is not None else \"\",\n            port,\n            family,\n            socket.SOCK_STREAM,\n            0,\n            flags,\n        )\n    except socket.gaierror as e:\n        # If address resolution fails (e.g. no address found), return empty list\n        return []\n\n    # Track addresses to avoid duplicates (e.g. if getaddrinfo returns multiple with same family/address)\n    # Actually typically getaddrinfo returns distinct addresses, so no need for duplicates filter\n    for res in info:\n        af, socktype, proto, canonname, sockaddr = res\n        try:\n            sock = socket.socket(af, socktype, proto)\n        except OSError:\n            continue\n\n        # Set socket options\n        try:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        except OSError as e:\n            # On some platforms like Hurd this may fail; ignore only if error is ENOPROTOOPT\n            if e.errno != errno.ENOPROTOOPT:\n                sock.close()\n                continue\n\n        if reuse_port:\n            try:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n            except (AttributeError, OSError) as e:\n                sock.close()\n                # Raise ValueError as per doc if unsupported platform\n                raise ValueError(\"SO_REUSEPORT is not supported on this platform\") from e\n\n        # Set non-blocking for socket (typically needed for async servers)\n        sock.setblocking(False)\n\n        # Bind socket\n        try:\n            sock.bind(sockaddr)\n        except OSError:\n            sock.close()\n            continue\n\n        # Listen with requested backlog\n        try:\n            sock.listen(backlog)\n        except OSError:\n            sock.close()\n            continue\n\n        sockets.append(sock)\n\n    return sockets", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 611, in <module>\n  File \"<string>\", line 610, in test_106\nAssertionError\n", "passed": false}
{"task_id": 254, "prediction_id": 1, "generation": "import socket\nimport os\nimport stat\nfrom typing import List, Optional\n\n_DEFAULT_BACKLOG = 128  # assuming default backlog from file content\n\n\ndef bind_sockets(\n    port: int,\n    address: Optional[str] = None,\n    family: socket.AddressFamily = socket.AF_UNSPEC,\n    backlog: int = _DEFAULT_BACKLOG,\n    flags: Optional[int] = None,\n    reuse_port: bool = False,\n) -> List[socket.socket]:\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen() <socket.socket.listen>`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    if flags is None:\n        flags = socket.AI_PASSIVE\n\n    sockets: List[socket.socket] = []\n\n    # Determine the address to pass to getaddrinfo\n    if not address:\n        # If address is None or empty string, listen on all interfaces\n        addr = None\n    else:\n        addr = address\n\n    # Use getaddrinfo to get all socket address infos that match criteria\n    # family: AF_UNSPEC, AF_INET, AF_INET6\n    # type: SOCK_STREAM (for TCP)\n    try:\n        addrinfos = socket.getaddrinfo(\n            addr,\n            port,\n            family,\n            socket.SOCK_STREAM,\n            0,\n            flags,\n        )\n    except socket.gaierror:\n        # In case getaddrinfo fails, return empty list\n        return []\n\n    # Keep track of addresses we've already bound to avoid duplicates\n    bound_addresses = set()\n\n    for res in addrinfos:\n        af, socktype, proto, canonname, sockaddr = res\n\n        # Avoid duplicate addresses (some platforms might return duplicates)\n        if (af, sockaddr) in bound_addresses:\n            continue\n\n        bound_addresses.add((af, sockaddr))\n\n        try:\n            sock = socket.socket(af, socktype, proto)\n        except OSError:\n            continue\n\n        try:\n            # Set socket options\n\n            # SO_REUSEADDR is commonly set for servers to allow quick restarts\n            try:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            except OSError:\n                # Some OS may not support SO_REUSEADDR for IPv6 or in general\n                pass\n\n            # Set SO_REUSEPORT if requested\n            if reuse_port:\n                # This may raise AttributeError or OSError on unsupported platforms\n                try:\n                    # SO_REUSEPORT might not be defined on all platforms\n                    if not hasattr(socket, \"SO_REUSEPORT\"):\n                        raise ValueError(\"SO_REUSEPORT not supported on this platform\")\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n                except (AttributeError, OSError) as e:\n                    # Close socket before raising to avoid resource leaks\n                    sock.close()\n                    raise ValueError(\"SO_REUSEPORT is not supported on this platform\") from e\n\n            # Make socket non-blocking\n            sock.setblocking(False)\n\n            sock.bind(sockaddr)\n            sock.listen(backlog)\n        except OSError:\n            sock.close()\n            continue\n        sockets.append(sock)\n\n    if not sockets:\n        # If no sockets could be created, raise an error\n        raise RuntimeError(f\"Could not bind to port {port} on address {address!r}\")\n\n    return sockets", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 636, in <module>\n  File \"<string>\", line 635, in test_2\nAssertionError\n", "passed": false}
{"task_id": 254, "prediction_id": 2, "generation": "import socket\nfrom typing import List, Optional\n\n_DEFAULT_BACKLOG = 128  # Redefine from the file context for completeness\n\n\ndef bind_sockets(\n    port: int,\n    address: Optional[str] = None,\n    family: socket.AddressFamily = socket.AF_UNSPEC,\n    backlog: int = _DEFAULT_BACKLOG,\n    flags: Optional[int] = None,\n    reuse_port: bool = False,\n) -> List[socket.socket]:\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen() <socket.socket.listen>`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    if flags is None:\n        flags = socket.AI_PASSIVE\n    else:\n        flags = flags | socket.AI_PASSIVE\n\n    # If the address is None, treat it as an empty string to listen on all interfaces\n    if address is None:\n        address = \"\"\n\n    sockets = []\n    # Use getaddrinfo to get all resolved addresses for the given host/port\n    # If family is AF_UNSPEC, it returns both IPv4 and IPv6 addresses if available\n    try:\n        info_list = socket.getaddrinfo(\n            address,\n            port,\n            family,\n            socket.SOCK_STREAM,\n            0,\n            flags,\n        )\n    except socket.gaierror as e:\n        # If address is specified but not resolvable, raise\n        # If address is empty and getaddrinfo fails, propagate error\n        raise e\n\n    for info in info_list:\n        af, socktype, proto, canonname, sockaddr = info\n        # Only create stream sockets (TCP)\n        if socktype != socket.SOCK_STREAM:\n            continue\n        try:\n            sock = socket.socket(af, socktype, proto)\n        except OSError:\n            continue  # Could not create socket for this address, try next\n\n        # Set socket options\n        # SO_REUSEADDR is generally recommended to avoid socket in use errors\n        try:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        except OSError:\n            pass  # Platform may not support it, ignore failure\n\n        if reuse_port:\n            # Try to set SO_REUSEPORT; may raise ValueError if unsupported\n            try:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n            except (AttributeError, OSError) as e:\n                sock.close()\n                raise ValueError(\"SO_REUSEPORT is not supported on this platform\") from e\n\n        # Set socket non-blocking\n        sock.setblocking(False)\n\n        try:\n            sock.bind(sockaddr)\n        except OSError:\n            sock.close()\n            continue  # Could not bind, try next address\n\n        sock.listen(backlog)\n        sockets.append(sock)\n\n    if not sockets:\n        raise OSError(f\"Could not bind any sockets for address={address} port={port}\")\n\n    return sockets", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 592, in <module>\n  File \"<string>\", line 591, in test_51\n  File \"<string>\", line 116, in bind_sockets\n  File \"<string>\", line 105, in bind_sockets\n  File \"/usr/local/lib/python3.10/socket.py\", line 955, in getaddrinfo\n    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):\nsocket.gaierror: [Errno -2] Name or service not known\n", "passed": false}
{"task_id": 254, "prediction_id": 3, "generation": "import socket\nimport errno\nfrom typing import List, Optional\n\n_DEFAULT_BACKLOG = 128  # Redefine here as we can't import from file context\n\n\ndef bind_sockets(\n    port: int,\n    address: Optional[str] = None,\n    family: socket.AddressFamily = socket.AF_UNSPEC,\n    backlog: int = _DEFAULT_BACKLOG,\n    flags: Optional[int] = None,\n    reuse_port: bool = False,\n) -> List[socket.socket]:\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen() <socket.socket.listen>`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    if flags is None:\n        flags = socket.AI_PASSIVE\n\n    # Normalize address: if None or empty string, set to None to listen on all interfaces\n    if address == \"\":\n        address = None\n\n    # Use socket.getaddrinfo to resolve addresses\n    try:\n        addrinfo = socket.getaddrinfo(\n            address,\n            port,\n            family,\n            socket.SOCK_STREAM,\n            0,\n            flags\n        )\n    except socket.gaierror:\n        # If address is None or '', and AF_UNSPEC, fallback to IPv4 and IPv6 all interfaces manually\n        # but normally getaddrinfo doesn't fail on None or '' with AI_PASSIVE\n        raise\n\n    sockets = []\n    seen = set()  # To avoid duplicate addresses\n\n    for res in addrinfo:\n        af, socktype, proto, canonname, sockaddr = res\n        if (af, sockaddr) in seen:\n            continue\n        seen.add((af, sockaddr))\n\n        sock = socket.socket(af, socktype, proto)\n\n        # Set socket options\n        try:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        except socket.error as e:\n            # Some platforms may not support SO_REUSEADDR\n            if e.errno != errno.ENOPROTOOPT:\n                sock.close()\n                raise\n\n        if reuse_port:\n            try:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n            except AttributeError:\n                # SO_REUSEPORT might not be defined on some platforms\n                sock.close()\n                raise ValueError(\"SO_REUSEPORT option is not supported on this platform\")\n            except socket.error as e:\n                sock.close()\n                raise ValueError(\"Error setting SO_REUSEPORT option: \" + str(e))\n\n        sock.setblocking(False)\n\n        # For IPv6 sockets, prevent dual-stack socket if possible,\n        # so that separate binding is possible for IPv4 and IPv6\n        if af == socket.AF_INET6:\n            try:\n                sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 1)\n            except (AttributeError, socket.error):\n                # IPV6_V6ONLY might not be available or supported\n                pass\n\n        try:\n            sock.bind(sockaddr)\n            sock.listen(backlog)\n        except OSError:\n            sock.close()\n            raise\n\n        sockets.append(sock)\n\n    return sockets", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 604, in <module>\n  File \"<string>\", line 603, in test_72\n  File \"<string>\", line 158, in bind_sockets\nOSError: [Errno 99] Cannot assign requested address\n", "passed": false}
{"task_id": 254, "prediction_id": 4, "generation": "import socket\nfrom typing import List, Optional\n\n_DEFAULT_BACKLOG = 128  # from file context\n\n\ndef bind_sockets(\n    port: int,\n    address: Optional[str] = None,\n    family: socket.AddressFamily = socket.AF_UNSPEC,\n    backlog: int = _DEFAULT_BACKLOG,\n    flags: Optional[int] = None,\n    reuse_port: bool = False,\n) -> List[socket.socket]:\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen() <socket.socket.listen>`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    # Determine flags for getaddrinfo\n    gai_flags = 0\n    if flags is not None:\n        gai_flags = flags\n    else:\n        # If address is empty or None, default to AI_PASSIVE to bind to all interfaces.\n        if not address:\n            gai_flags = socket.AI_PASSIVE\n\n    # Prepare address placeholder\n    bind_address = address if address else None\n\n    # getaddrinfo to resolve addresses for binding\n    try:\n        res = socket.getaddrinfo(\n            bind_address,\n            port,\n            family,\n            socket.SOCK_STREAM,\n            0,\n            gai_flags,\n        )\n    except socket.gaierror as e:\n        # If getaddrinfo fails, raise the error for the caller to handle\n        raise\n\n    sockets: List[socket.socket] = []\n    used = set()  # To avoid duplicates due to IPv4/IPv6 overlap\n\n    for family, socktype, proto, canonname, sockaddr in res:\n        # Avoid creating duplicate sockets for same sockaddr\n        if sockaddr in used:\n            continue\n        used.add(sockaddr)\n\n        sock = socket.socket(family, socktype, proto)\n\n        # Set socket options: Reuse address\n        try:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        except socket.error as e:\n            # Some platforms may not support this, ignore unless error is unexpected\n            if e.errno != errno.ENOPROTOOPT:\n                sock.close()\n                raise\n\n        # Set reuse_port if requested\n        if reuse_port:\n            if hasattr(socket, \"SO_REUSEPORT\"):\n                try:\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n                except (OSError, AttributeError) as e:\n                    sock.close()\n                    raise ValueError(\"SO_REUSEPORT is not supported on this platform\") from e\n            else:\n                sock.close()\n                raise ValueError(\"SO_REUSEPORT is not supported on this platform\")\n\n        # On IPv6 sockets, try to allow dual-stack sockets (both IPv4 and IPv6)\n        if family == socket.AF_INET6:\n            try:\n                sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)\n            except (OSError, AttributeError):\n                # Some systems do not support this option or setting it to 0, ignore silently\n                pass\n\n        # Set to non-blocking mode\n        sock.setblocking(False)\n\n        # Bind socket\n        sock.bind(sockaddr)\n\n        # Listen with specified backlog\n        sock.listen(backlog)\n\n        sockets.append(sock)\n\n    return sockets", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 603, in <module>\n  File \"<string>\", line 602, in test_51\n  File \"<string>\", line 162, in bind_sockets\nOSError: [Errno 98] Address already in use\n", "passed": false}
