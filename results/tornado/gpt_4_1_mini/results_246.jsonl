{"task_id": 246, "prediction_id": 0, "generation": "import asyncio\nimport sys\nimport typing\nfrom typing import Union, Any, Type, Tuple\n\nimport datetime\nfrom tornado.concurrent import Future, is_future, chain_future, future_set_exc_info, future_add_done_callback, future_set_result_unless_cancelled\nfrom tornado.ioloop import IOLoop\nfrom tornado.util import TimeoutError\n\n\n_Yieldable = Union[\n    None, typing.Awaitable, typing.List[typing.Awaitable], typing.Dict[Any, typing.Awaitable], typing.Any  # concurrent.futures.Future included in Any here\n]\n\n\ndef with_timeout(\n    timeout: Union[float, datetime.timedelta],\n    future: _Yieldable,\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> Future:\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is either of a type contained in\n    ``quiet_exceptions`` (which may be an exception type or a sequence of\n    types), or an ``asyncio.CancelledError``.\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n    Added the ``quiet_exceptions`` argument and the logging of unhandled\n    exceptions.\n\n    .. versionchanged:: 4.4\n    Added support for yieldable objects other than `.Future`.\n\n    .. versionchanged:: 6.0.3\n    ``asyncio.CancelledError`` is now always considered \"quiet\".\n\n    \"\"\"\n    io_loop = IOLoop.current()\n    real_future: Future = None  # type: ignore\n\n    def on_timeout() -> None:\n        if not real_future.done():\n            future_set_exc_info(real_future, (TimeoutError, TimeoutError(\"Operation timed out after %s seconds\" % timeout), None))\n\n    # Convert given yieldable to Future\n    real_future = Future()\n    try:\n        converted = maybe_future(future)\n    except Exception:\n        future_set_exc_info(real_future, sys.exc_info())\n        return real_future\n\n    # Schedule timeout callback\n    timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n\n    def on_future_done(f: Future) -> None:\n        # Cancel the timeout, as our future has yielded a result or an error\n        io_loop.remove_timeout(timeout_handle)\n\n        # If the timeout fired first, real_future is already done\n        if real_future.done():\n            # The wrapped future has completed after timeout\n            # Log the exception unless quiet\n            try:\n                exc = f.exception()\n            except Exception:\n                exc = None\n\n            if exc is not None:\n                if isinstance(exc, asyncio.CancelledError):\n                    # Always quiet on CancelledError\n                    return\n                quiet = False\n                if quiet_exceptions:\n                    if isinstance(quiet_exceptions, tuple):\n                        quiet = isinstance(exc, quiet_exceptions)\n                    else:\n                        quiet = isinstance(exc, quiet_exceptions)\n                if not quiet:\n                    from tornado.log import app_log\n                    app_log.error(\"Exception after future timed out\", exc_info=f)\n\n            # We don't overwrite the result or exception on real_future here\n            return\n\n        # Chain the wrapped future's result or exception to our future\n        chain_future(f, real_future)\n\n    future_add_done_callback(converted, on_future_done)\n\n    return real_future", "message": "passed", "passed": true}
{"task_id": 246, "prediction_id": 1, "generation": "import asyncio\nimport sys\nimport typing\nimport datetime\nfrom typing import Union, Type, Tuple, Any\n\nfrom tornado.concurrent import Future, is_future, chain_future\nfrom tornado.ioloop import IOLoop\nfrom tornado.util import TimeoutError\nfrom tornado.gen import convert_yielded\n\n\ndef with_timeout(\n    timeout: Union[float, datetime.timedelta],\n    future: typing.Any,\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> Future:\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is either of a type contained in\n    ``quiet_exceptions`` (which may be an exception type or a sequence of\n    types), or an ``asyncio.CancelledError``.\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n    Added the ``quiet_exceptions`` argument and the logging of unhandled\n    exceptions.\n\n    .. versionchanged:: 4.4\n    Added support for yieldable objects other than `.Future`.\n\n    .. versionchanged:: 6.0.3\n    ``asyncio.CancelledError`` is now always considered \"quiet\".\n\n    \"\"\"\n    io_loop = IOLoop.current()\n    timeout_future = Future()\n\n    # Convert the input to a Future if it isn't already\n    wrapped_future = convert_yielded(future)\n\n    # This will hold the handle to the scheduled timeout callback\n    timeout_handle = None\n\n    def on_timeout() -> None:\n        if timeout_future.done():\n            return\n        # Set the timeout exception as the result\n        timeout_future.set_exception(TimeoutError(\"Operation timed out after %s seconds\" % timeout))\n        # Do not cancel wrapped_future, as per docstring\n\n    # Schedule the timeout callback\n    try:\n        timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n    except Exception:\n        # Defensive fallback: If add_timeout raises, fail immediately\n        timeout_future.set_exception(sys.exc_info())\n\n    def on_future_done(fut: Future) -> None:\n        # If the timeout already triggered, we ignore result except for logging\n        if timeout_future.done():\n            # If wrapped_future finished after timeout, log exception unless quiet\n            try:\n                exc = fut.exception()\n            except Exception:\n                exc = None  # If exception query failed, ignore\n\n            if exc is not None:\n                # Always consider asyncio.CancelledError quiet\n                quiet_types: Tuple[Type[Exception], ...]\n                if isinstance(quiet_exceptions, tuple):\n                    quiet_types = quiet_exceptions\n                elif quiet_exceptions:\n                    quiet_types = (quiet_exceptions,)\n                else:\n                    quiet_types = ()\n                if not (\n                    isinstance(exc, quiet_types)\n                    or (sys.version_info >= (3, 8) and isinstance(exc, asyncio.CancelledError))\n                    or isinstance(exc, asyncio.CancelledError)\n                ):\n                    from tornado.log import app_log\n\n                    app_log.error(\n                        \"Exception in Future after timeout: %r\", exc, exc_info=True\n                    )\n            return\n\n        if not timeout_future.done():\n            # Cancel the timeout callback since future completed in time\n            if timeout_handle is not None:\n                io_loop.remove_timeout(timeout_handle)\n            # Propagate the wrapped future's result or exception to timeout_future\n            chain_future(fut, timeout_future)\n\n    # Attach the done callback to wrapped_future\n    wrapped_future.add_done_callback(on_future_done)\n\n    return timeout_future", "message": "passed", "passed": true}
{"task_id": 246, "prediction_id": 2, "generation": "import asyncio\nimport datetime\nimport sys\nfrom typing import Union, Type, Tuple, Any\n\nfrom tornado.concurrent import Future, is_future, chain_future\nfrom tornado.ioloop import IOLoop\nfrom tornado.log import app_log\nfrom tornado.util import TimeoutError\n\n\ndef with_timeout(\n    timeout: Union[float, datetime.timedelta],\n    future: Any,\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> Future:\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is either of a type contained in\n    ``quiet_exceptions`` (which may be an exception type or a sequence of\n    types), or an ``asyncio.CancelledError``.\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n    Added the ``quiet_exceptions`` argument and the logging of unhandled\n    exceptions.\n\n    .. versionchanged:: 4.4\n    Added support for yieldable objects other than `.Future`.\n\n    .. versionchanged:: 6.0.3\n    ``asyncio.CancelledError`` is now always considered \"quiet\".\n\n    \"\"\"\n    io_loop = IOLoop.current()\n    timeout_handle = None\n    future_obj = None\n\n    # Convert any yieldable into a Future\n    from tornado.gen import convert_yielded, BadYieldError\n\n    # Create the future that will be returned\n    wrapped_future = Future()  # type: Future\n\n    # Keep track if timeout occurred\n    timed_out = False\n\n    def on_timeout() -> None:\n        nonlocal timed_out\n        timed_out = True\n        if not wrapped_future.done():\n            future_set_result_unless_cancelled(wrapped_future, None)\n            future_set_exc_info(\n                wrapped_future, (TimeoutError, TimeoutError(\"Operation timed out\"), None)\n            )\n\n    try:\n        future_obj = convert_yielded(future)\n    except BadYieldError:\n        # Cannot convert to future: wrap in future with exception\n        future_obj = Future()\n        future_set_exc_info(future_obj, sys.exc_info())\n\n    def on_future_done(f: Future) -> None:\n        nonlocal timeout_handle\n        if timeout_handle is not None:\n            io_loop.remove_timeout(timeout_handle)\n            timeout_handle = None\n\n        if wrapped_future.done():\n            # wrapped_future is already done, probably due to timeout\n            # Log exception from future if it failed and not quiet\n            if f.cancelled():\n                # cancelled: do not log\n                return\n            exc = None\n            try:\n                _ = f.result()\n            except Exception as e:\n                exc = e\n            if exc is not None:\n                # Log if exception is not quiet or CancelledError\n                if (\n                    not isinstance(exc, quiet_exceptions)\n                    and not isinstance(exc, asyncio.CancelledError)\n                ):\n                    app_log.error(\n                        \"Exception in future after timeout\", exc_info=True\n                    )\n            return\n\n        # Chain result or exception from future_obj to wrapped_future\n        chain_future(f, wrapped_future)\n\n    # Schedule the timeout callback\n    timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n\n    # When original future completes, handle completion\n    io_loop.add_future(future_obj, on_future_done)\n\n    return wrapped_future\n\n\n# Helper import for future_set_exc_info and future_set_result_unless_cancelled\nfrom tornado.concurrent import future_set_exc_info, future_set_result_unless_cancelled", "message": "passed", "passed": true}
{"task_id": 246, "prediction_id": 3, "generation": "import asyncio\nimport sys\nimport typing\nfrom typing import Union, Type, Tuple, Any\n\nfrom tornado.concurrent import Future, is_future, chain_future\nfrom tornado.ioloop import IOLoop\nfrom tornado.util import TimeoutError\n\n\ndef with_timeout(\n    timeout: Union[float, typing.TypeVar(\"datetime.timedelta\")],\n    future: typing.Union[Future, typing.Awaitable, typing.List[typing.Awaitable], typing.Dict[Any, typing.Awaitable]],\n    quiet_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]] = (),\n) -> Future:\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is either of a type contained in\n    ``quiet_exceptions`` (which may be an exception type or a sequence of\n    types), or an ``asyncio.CancelledError``.\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n    Added the ``quiet_exceptions`` argument and the logging of unhandled\n    exceptions.\n\n    .. versionchanged:: 4.4\n    Added support for yieldable objects other than `.Future`.\n\n    .. versionchanged:: 6.0.3\n    ``asyncio.CancelledError`` is now always considered \"quiet\".\n\n    \"\"\"\n    io_loop = IOLoop.current()\n    timeout_future = Future()\n\n    try:\n        # Convert the yielded object to a Future\n        wrapped_future = maybe_future(future)\n    except Exception:\n        # If conversion failed, create a future with the exception set\n        timeout_future.set_exception(sys.exc_info()[1])\n        return timeout_future\n\n    def on_timeout() -> None:\n        if not timeout_future.done():\n            future_set_result_unless_cancelled(timeout_future, None)\n            # Mark the timeout future done with a TimeoutError exception\n            timeout_future.set_exception(TimeoutError(\"Operation timed out after %s\" % timeout))\n\n    timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n\n    def done_callback(fut: Future) -> None:\n        if timeout_future.done():\n            # Timeout already fired, possibly log exception unless quiet\n            exc = None\n            try:\n                exc = fut.exception()\n            except Exception:  # Defensive\n                exc = None\n            if exc is not None and not isinstance(\n                exc, (asyncio.CancelledError,) + (quiet_exceptions if isinstance(quiet_exceptions, tuple) else (quiet_exceptions,))\n            ):\n                from tornado.log import app_log\n\n                app_log.error(\"Future completed after timeout with exception\", exc_info=True)\n        else:\n            # Cancel the timeout since the future finished first\n            io_loop.remove_timeout(timeout_handle)\n            # Propagate the original future's result or exception to timeout_future\n            chain_future(fut, timeout_future)\n\n    wrapped_future.add_done_callback(done_callback)\n\n    return timeout_future\n\n\n# Helpers (these are used internally by Tornado and normally imported, \n# but we add here because the user requested self-contained code)\n\ndef maybe_future(x: Any) -> Future:\n    \"\"\"Converts ``x`` into a `.Future`.\"\"\"\n    if is_future(x):\n        return x\n    else:\n        fut = _create_future()\n        fut.set_result(x)\n        return fut\n\n\ndef _create_future() -> Future:\n    future = Future()\n    # Remove stack entries from this file for debugging clarity\n    source_traceback = getattr(future, \"_source_traceback\", ())\n    while source_traceback:\n        filename = source_traceback[-1][0]\n        if filename == __file__:\n            source_traceback = source_traceback[:-1]\n        else:\n            break\n    return future\n\n\ndef future_set_result_unless_cancelled(future: Future, value: Any) -> None:\n    \"\"\"Set the given ``value`` as the `Future`'s result, if not cancelled.\"\"\"\n    if not future.cancelled():\n        future.set_result(value)\n\n\ndef chain_future(a: Future, b: Future) -> None:\n    \"\"\"Chain two futures so when 'a' completes, 'b' does too.\"\"\"\n    def copy(fut: Future) -> None:\n        if b.done():\n            return\n        if fut.cancelled():\n            b.cancel()\n        else:\n            exc = fut.exception()\n            if exc is not None:\n                b.set_exception(exc)\n            else:\n                b.set_result(fut.result())\n\n    a.add_done_callback(copy)\n\n\ndef is_future(x: Any) -> bool:\n    return isinstance(x, Future)", "message": "passed", "passed": true}
{"task_id": 246, "prediction_id": 4, "generation": "import asyncio\nimport datetime\nimport sys\nfrom typing import Union, Type, Tuple\n\nfrom tornado.concurrent import is_future, Future, chain_future, future_set_exc_info\nfrom tornado.ioloop import IOLoop\nfrom tornado.util import TimeoutError\n\n\ndef with_timeout(\n    timeout: Union[float, datetime.timedelta],\n    future: _Yieldable,\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> Future:\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is either of a type contained in\n    ``quiet_exceptions`` (which may be an exception type or a sequence of\n    types), or an ``asyncio.CancelledError``.\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n    Added the ``quiet_exceptions`` argument and the logging of unhandled\n    exceptions.\n\n    .. versionchanged:: 4.4\n    Added support for yieldable objects other than `.Future`.\n\n    .. versionchanged:: 6.0.3\n    ``asyncio.CancelledError`` is now always considered \"quiet\".\n\n    \"\"\"\n    # Convert the input future or yieldable to a Tornado Future\n    fut = convert_yielded(future)\n\n    io_loop = IOLoop.current()\n    result_future = Future()\n\n    # Unified quiet exceptions as a tuple and always include asyncio.CancelledError\n    if isinstance(quiet_exceptions, tuple):\n        quiet_exc = quiet_exceptions + (asyncio.CancelledError,)\n    elif quiet_exceptions:\n        quiet_exc = (quiet_exceptions, asyncio.CancelledError)\n    else:\n        quiet_exc = (asyncio.CancelledError,)\n\n    timed_out = False\n\n    def on_timeout() -> None:\n        nonlocal timed_out\n        if timed_out:\n            return\n        timed_out = True\n        # Set exception on result_future if not done\n        if not result_future.done():\n            future_set_exc_info(result_future, sys.exc_info())\n            # We raise our own TimeoutError here explicitly instead of sys.exc_info from this context\n            # so replace result_future exception with TimeoutError\n            result_future.set_exception(TimeoutError(\"Operation timed out after %s seconds\" % timeout))\n\n    # Schedule the timeout callback on the IOLoop\n    timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n\n    def on_future_done(f: Future) -> None:\n        if result_future.done():\n            # Already timed out and finished\n            # If future failed after timeout, log it unless quiet\n            exc = None\n            try:\n                f.result()\n            except Exception as e:\n                exc = e\n            if exc is not None and not isinstance(exc, quiet_exc):\n                # Only log if not quiet exception\n                from tornado.log import app_log\n\n                app_log.error(\"Future failed after timeout\", exc_info=True)\n            return\n\n        # Cancel the timeout callback since future finished in time\n        io_loop.remove_timeout(timeout_handle)\n\n        try:\n            res = f.result()\n        except Exception:\n            # Propagate the exception to result_future\n            future_set_exc_info(result_future, sys.exc_info())\n        else:\n            # Set the result if not cancelled\n            future_set_result_unless_cancelled(result_future, res)\n\n    fut.add_done_callback(on_future_done)\n\n    # Chain original future's result or exception to result_future\n    chain_future(fut, result_future)\n\n    return result_future\n\n\ndef convert_yielded(yielded: _Yieldable) -> Future:\n    \"\"\"\n    Convert various yieldable types to a Tornado Future, similar to convert_yielded in gen module.\n    This is a minimal reimplementation to support with_timeout.\n\n    Raises BadYieldError if the type is not yieldable.\n\n    \"\"\"\n    from tornado.gen import maybe_future\n\n    return maybe_future(yielded)\n\n\ndef future_set_result_unless_cancelled(future: Future, value) -> None:\n    \"\"\"\n    Sets result on Future if not cancelled - imported from tornado.concurrent,\n    re-implemented here for self-contained code.\n    \"\"\"\n    if not future.cancelled():\n        future.set_result(value)", "message": "passed", "passed": true}
