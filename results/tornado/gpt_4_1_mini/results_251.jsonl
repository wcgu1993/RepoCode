{"task_id": 251, "prediction_id": 0, "generation": "import base64\nimport hashlib\nimport hmac\nimport urllib.parse\nfrom typing import Any, Dict, Optional\n\n\ndef _oauth_signature(\n    consumer_token: Dict[str, Any],\n    method: str,\n    url: str,\n    parameters: Dict[str, Any] = {},\n    token: Optional[Dict[str, Any]] = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    # 1. Normalize the request parameters\n    # - Collect all the parameters (OAuth params, query string params, POST params)\n    # - Exclude 'oauth_signature' if present\n    # - Percent encode key and value per OAuth spec\n    # - Sort the parameters by key and then by value (both lex order)\n\n    # Parameters might contain bytes or strings as keys/values; convert all to strings\n    # Also exclude \"oauth_signature\"\n\n    def _escape(s: Any) -> str:\n        # OAuth 1.0 percent encode, spaces must be encoded as %20 (not '+')\n        return urllib.parse.quote(str(s), safe='~')\n\n    items = []\n    for k, v in parameters.items():\n        if k == \"oauth_signature\":\n            continue\n        # If the value is a list or tuple, each item should be separate parameter\n        if isinstance(v, (list, tuple)):\n            for val_item in v:\n                items.append((_escape(k), _escape(val_item)))\n        else:\n            items.append((_escape(k), _escape(v)))\n\n    # Sort parameters\n    items.sort(key=lambda x: (x[0], x[1]))\n\n    # 2. Construct the normalized parameter string\n    # Key-value pairs joined by '=' and pairs joined by '&'\n    normalized_parameters = \"&\".join(f\"{k}={v}\" for k, v in items)\n\n    # 3. Construct the signature base string:\n    #   Uppercase HTTP method + '&' + percent-encoded base URL + '&' + percent-encoded normalized parameters\n\n    # Base URL excludes query and fragment\n    parsed_url = urllib.parse.urlparse(url)\n    scheme, netloc, path = parsed_url.scheme, parsed_url.netloc, parsed_url.path\n    base_url = f\"{scheme}://{netloc}{path}\"\n    base_string = \"&\".join([\n        _escape(method.upper()),\n        _escape(base_url),\n        _escape(normalized_parameters),\n    ])\n\n    # 4. Construct the signing key:\n    #   Percent-encoded consumer secret + '&' + percent-encoded token secret (empty if no token)\n    consumer_secret = consumer_token.get(\"secret\", \"\")\n    token_secret = \"\"\n    if token is not None:\n        # token may be dict with \"secret\" key; if missing, treat as empty string\n        token_secret = token.get(\"secret\", \"\")\n\n    key = f\"{_escape(consumer_secret)}&{_escape(token_secret)}\"\n\n    # 5. Calculate the HMAC-SHA1 of the base_string using the key\n    # Return the base64-encoded signature as bytes\n\n    digest = hmac.new(key.encode(\"utf-8\"), msg=base_string.encode(\"utf-8\"), digestmod=hashlib.sha1).digest()\n    signature = base64.b64encode(digest)\n\n    return signature", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1294, in <module>\n  File \"<string>\", line 1287, in test_6\nAssertionError\n", "passed": false}
{"task_id": 251, "prediction_id": 1, "generation": "import base64\nimport hashlib\nimport hmac\nimport urllib.parse\nfrom typing import Any, Dict, Optional\n\n\ndef _oauth_signature(\n    consumer_token: Dict[str, Any],\n    method: str,\n    url: str,\n    parameters: Dict[str, Any] = {},\n    token: Optional[Dict[str, Any]] = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    # 1. Normalize HTTP method (uppercase)\n    method = method.upper()\n\n    # 2. Parse the URL and normalize it (scheme and host lowercase, remove default ports)\n    parsed_url = urllib.parse.urlparse(url)\n    scheme, netloc, path = parsed_url.scheme.lower(), parsed_url.netloc.lower(), parsed_url.path\n    # Remove default ports\n    if scheme == \"http\" and netloc.endswith(\":80\"):\n        netloc = netloc[:-3]\n    elif scheme == \"https\" and netloc.endswith(\":443\"):\n        netloc = netloc[:-4]\n    normalized_url = f\"{scheme}://{netloc}{path}\"\n\n    # 3. Collect and normalize parameters\n    # - Include query parameters from URL\n    # - Include parameters from parameters dict\n    # - Include oauth_token key if token is provided and has 'key'\n    # - Percent encode keys and values\n    # - Sort parameters by key then value\n    query_params = urllib.parse.parse_qsl(parsed_url.query, keep_blank_values=True)\n    all_params = list(query_params)\n\n    if parameters:\n        # parameters might have keys with values that are lists or single values\n        for k, v in parameters.items():\n            if isinstance(v, list):\n                for item in v:\n                    all_params.append((k, str(item)))\n            else:\n                all_params.append((k, str(v)))\n\n    # Add oauth_token if token provided and has 'key' and not already in parameters\n    if token is not None and \"key\" in token:\n        token_key = token[\"key\"]\n        # Only add if not already present (some params might already have oauth_token)\n        if not any(k == \"oauth_token\" for k, _ in all_params):\n            all_params.append((\"oauth_token\", str(token_key)))\n\n    # Percent encode keys and values, per OAuth 1.0 spec\n    def encode(s: str) -> str:\n        # urllib.parse.quote plus safe='~' per OAuth1.0 spec\n        return urllib.parse.quote(s, safe=\"~\")\n\n    encoded_params = [(encode(k), encode(v)) for k, v in all_params]\n\n    # Sort by key, then by value\n    encoded_params.sort(key=lambda x: (x[0], x[1]))\n\n    # Construct the parameter string key=value&key=value...\n    normalized_params = \"&\".join(f\"{k}={v}\" for k, v in encoded_params)\n\n    # 4. Construct the base string\n    base_string = \"&\".join(\n        encode(x) for x in [method, normalized_url, normalized_params]\n    )\n\n    # 5. Construct signing key: consumer_secret&token_secret (token_secret is optional)\n    consumer_secret = consumer_token.get(\"secret\", \"\")\n    if isinstance(consumer_secret, bytes):\n        consumer_secret = consumer_secret.decode(\"utf-8\")\n    token_secret = \"\"\n    if token is not None:\n        token_secret = token.get(\"secret\", \"\")\n        if isinstance(token_secret, bytes):\n            token_secret = token_secret.decode(\"utf-8\")\n    signing_key = f\"{encode(consumer_secret)}&{encode(token_secret)}\"\n\n    # 6. Calculate HMAC-SHA1 signature and Base64 encode it\n    hashed = hmac.new(signing_key.encode(\"utf-8\"), base_string.encode(\"utf-8\"), hashlib.sha1)\n    signature = base64.b64encode(hashed.digest())\n\n    return signature", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1228, in <module>\n  File \"<string>\", line 1221, in test_0\nAssertionError\n", "passed": false}
{"task_id": 251, "prediction_id": 2, "generation": "import base64\nimport hashlib\nimport hmac\nimport urllib.parse\n\n\ndef _oauth_signature(\n    consumer_token: dict,\n    method: str,\n    url: str,\n    parameters: dict = {},\n    token: dict | None = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    # Normalize the HTTP method to uppercase\n    method = method.upper()\n\n    # Parse the URL and normalize scheme and host to lowercase\n    parsed_url = urllib.parse.urlparse(url)\n    scheme = parsed_url.scheme.lower()\n    netloc = parsed_url.hostname.lower()\n    if parsed_url.port:\n        # Include port only if it is non-default\n        default_port = (scheme == \"http\" and parsed_url.port == 80) or (\n            scheme == \"https\" and parsed_url.port == 443\n        )\n        if not default_port:\n            netloc += f\":{parsed_url.port}\"\n\n    # Rebuild normalized URL without query or fragment\n    normalized_url = f\"{scheme}://{netloc}{parsed_url.path or ''}\"\n\n    # Collect all query parameters from the URL\n    query_params = urllib.parse.parse_qsl(parsed_url.query, keep_blank_values=True)\n\n    # Convert parameters dict to list of tuples (key, value(s))\n    # parameters can have list values or single values, normalize to list\n    param_items = []\n    for k, v in parameters.items():\n        if isinstance(v, (list, tuple)):\n            for item in v:\n                param_items.append((k, str(item)))\n        else:\n            param_items.append((k, str(v)))\n\n    # Combine with query params\n    all_params = query_params + param_items\n\n    # Percent encode key and value as required by OAuth 1.0\n    def oauth_percent_encode(s: str) -> str:\n        # Per OAuth, the unreserved characters are ALPHA, DIGIT, '-', '.', '_', '~'\n        return urllib.parse.quote(s, safe='~')\n\n    # Sort parameters by key, then by value (both percent encoded)\n    # But we must percent encode before sorting to be consistent\n    encoded_params = [\n        (oauth_percent_encode(k), oauth_percent_encode(v)) for k, v in all_params\n    ]\n    encoded_params.sort(key=lambda x: (x[0], x[1]))\n\n    # Build parameter string: k=v pairs joined by &\n    param_string = \"&\".join(f\"{k}={v}\" for k, v in encoded_params)\n\n    # Construct the signature base string: METHOD&encoded(normalized_url)&encoded(param_string)\n    base_elements = [\n        oauth_percent_encode(method),\n        oauth_percent_encode(normalized_url),\n        oauth_percent_encode(param_string),\n    ]\n    base_string = \"&\".join(base_elements).encode(\"utf-8\")\n\n    # Construct the signing key: urlencoded(consumer_secret)&urlencoded(token_secret or \"\")\n    consumer_secret = consumer_token.get(\"secret\", \"\")\n    token_secret = \"\"\n    if token:\n        token_secret = token.get(\"secret\", \"\")\n    key = f\"{oauth_percent_encode(consumer_secret)}&{oauth_percent_encode(token_secret)}\".encode(\"utf-8\")\n\n    # Create the HMAC-SHA1 signature and then base64 encode it\n    hashed = hmac.new(key, base_string, hashlib.sha1)\n    signature = base64.b64encode(hashed.digest())\n\n    return signature", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1258, in <module>\n  File \"<string>\", line 1252, in test_3\nAssertionError\n", "passed": false}
{"task_id": 251, "prediction_id": 3, "generation": "import base64\nimport hashlib\nimport hmac\nimport urllib.parse\nfrom typing import Any, Dict, Optional\n\n\ndef _oauth_signature(\n    consumer_token: Dict[str, Any],\n    method: str,\n    url: str,\n    parameters: Dict[str, Any] = {},\n    token: Optional[Dict[str, Any]] = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    # 1. Normalize the URL (scheme, host, path; remove query and fragment)\n    parsed_url = urllib.parse.urlparse(url)\n    scheme, netloc, path = parsed_url.scheme, parsed_url.netloc.lower(), parsed_url.path or \"/\"\n    # Remove default ports\n    if (scheme == \"http\" and netloc.endswith(\":80\")) or (scheme == \"https\" and netloc.endswith(\":443\")):\n        netloc = netloc.rsplit(\":\", 1)[0]\n    normalized_url = f\"{scheme}://{netloc}{path}\"\n\n    # 2. Normalize parameters:\n    # - Combine query parameters from URL and parameters dict\n    # - Percent encode keys and values\n    # - Sort by key and then by value\n    # Note: parameters may include all query & POST args and OAuth params.\n\n    # Extract query parameters from URL\n    query_params = urllib.parse.parse_qsl(parsed_url.query, keep_blank_values=True)\n\n    # Convert parameters dict to list of (key, value) tuples\n    # Also flatten parameters values if they are lists or tuples\n    def flatten_params(params):\n        items = []\n        for k, v in params.items():\n            if isinstance(v, (list, tuple)):\n                for item in v:\n                    items.append((k, item))\n            else:\n                items.append((k, v))\n        return items\n\n    combined_params = query_params + flatten_params(parameters)\n\n    # Percent encode keys and values\n    def percent_encode(s: Any) -> str:\n        if isinstance(s, bytes):\n            s = s.decode(\"utf-8\")\n        elif not isinstance(s, str):\n            s = str(s)\n        # Per OAuth spec, encode as RFC3986\n        return urllib.parse.quote(s, safe='~-._')\n\n    encoded_params = [(percent_encode(k), percent_encode(v)) for k, v in combined_params]\n\n    # Sort by key, then by value\n    encoded_params.sort(key=lambda x: (x[0], x[1]))\n\n    # Re-encode normalized parameter string (key=value joined by &, for all params)\n    normalized_parameters = \"&\".join(f\"{k}={v}\" for k, v in encoded_params)\n\n    # 3. Construct the signature base string: METHOD&percent_encoded(normalized_url)&percent_encoded(normalized_parameters)\n    base_elements = [\n        method.upper(),\n        percent_encode(normalized_url),\n        percent_encode(normalized_parameters),\n    ]\n    signature_base_string = \"&\".join(base_elements).encode(\"utf-8\")\n\n    # 4. Construct the signing key: percent_encoded(consumer_secret) + '&' + percent_encoded(token_secret or '')\n    consumer_secret = consumer_token.get(\"secret\", \"\")\n    token_secret = token.get(\"secret\", \"\") if token else \"\"\n\n    key = f\"{percent_encode(consumer_secret)}&{percent_encode(token_secret)}\".encode(\"utf-8\")\n\n    # 5. Calculate HMAC-SHA1 using key and signature_base_string\n    hashed = hmac.new(key, signature_base_string, hashlib.sha1)\n\n    # 6. Return base64-encoded HMAC digest as bytes\n    signature = base64.b64encode(hashed.digest())\n\n    return signature", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1248, in <module>\n  File \"<string>\", line 1242, in test_2\nAssertionError\n", "passed": false}
{"task_id": 251, "prediction_id": 4, "generation": "import base64\nimport hashlib\nimport hmac\nimport urllib.parse\n\n\ndef _oauth_signature(\n    consumer_token: dict,\n    method: str,\n    url: str,\n    parameters: dict = {},\n    token: dict = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    # 1. Normalize the HTTP method to uppercase\n    method = method.upper()\n\n    # 2. Normalize the URL (scheme, host lowercase and port normalization)\n    parsed_url = urllib.parse.urlparse(url)\n    scheme, netloc, path = parsed_url.scheme.lower(), parsed_url.netloc.lower(), parsed_url.path\n\n    # Remove port 80 or 443 if default\n    if \":\" in netloc:\n        host, port = netloc.split(\":\", 1)\n        port = int(port)\n        if (scheme == \"http\" and port == 80) or (scheme == \"https\" and port == 443):\n            netloc = host\n\n    normalized_url = f\"{scheme}://{netloc}{path}\"\n\n    # 3. Collect all parameters from query string and the passed parameters dict\n    # Query params from url\n    query_params = urllib.parse.parse_qsl(parsed_url.query, keep_blank_values=True)\n\n    # Combine query_params and parameters (parameters passed in this function)\n    # parameters may contain bytes or strings, ensure all keys and values are str\n    combined_params = list(query_params)\n    for k, v in parameters.items():\n        # If value is bytes, decode as utf-8, else convert to str\n        if isinstance(v, bytes):\n            v = v.decode(\"utf-8\")\n        else:\n            v = str(v)\n        # Similarly for key\n        if isinstance(k, bytes):\n            k = k.decode(\"utf-8\")\n        else:\n            k = str(k)\n        combined_params.append((k, v))\n\n    # 4. Percent encode the keys and values, then sort them lexicographically by key and by value\n    def percent_encode(s: str) -> str:\n        # urllib.parse.quote defaults safe='/', but OAuth wants safe='~'\n        # Per OAuth spec, encoding as per RFC3986, safe chars are unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n        return urllib.parse.quote(s, safe='~-._0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n\n    encoded_params = [(percent_encode(k), percent_encode(v)) for k, v in combined_params]\n    encoded_params.sort(key=lambda x: (x[0], x[1]))\n\n    # 5. Concatenate parameters into a=1&b=2 form\n    normalized_parameters = \"&\".join(f\"{k}={v}\" for k, v in encoded_params)\n\n    # 6. Construct the signature base string: METHOD & percent_encoded(base_string_uri) & percent_encoded(normalized_parameters)\n    base_elements = [\n        method,\n        percent_encode(normalized_url),\n        percent_encode(normalized_parameters),\n    ]\n    base_string = \"&\".join(base_elements).encode(\"utf-8\")\n\n    # 7. Construct the signing key: consumer_secret&token_secret (token_secret may be empty if token is None)\n    consumer_secret = consumer_token.get(\"secret\", \"\")\n    if isinstance(consumer_secret, bytes):\n        consumer_secret = consumer_secret.decode(\"utf-8\")\n    consumer_secret_enc = percent_encode(consumer_secret)\n\n    token_secret = \"\"\n    if token is not None:\n        ts = token.get(\"secret\", \"\")\n        if isinstance(ts, bytes):\n            ts = ts.decode(\"utf-8\")\n        token_secret = percent_encode(ts)\n\n    signing_key = f\"{consumer_secret_enc}&{token_secret}\".encode(\"utf-8\")\n\n    # 8. Calculate HMAC-SHA1 signature and base64 encode it\n    hashed = hmac.new(signing_key, base_string, hashlib.sha1)\n    signature = base64.b64encode(hashed.digest())\n\n    return signature", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1265, in <module>\n  File \"<string>\", line 1259, in test_3\nAssertionError\n", "passed": false}
