{"task_id": 272, "prediction_id": 0, "generation": "from typing import Union, Dict, List, Tuple\nfrom urllib.parse import urlencode, urlparse, urlunparse, parse_qsl\n\n\ndef url_concat(\n    url: str,\n    args: Union[\n        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]\n    ],\n) -> str:\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if not args:\n        return url\n\n    # Parse the URL into components\n    parsed_url = urlparse(url)\n    # Parse existing query parameters preserving duplicates and order\n    existing_params = parse_qsl(parsed_url.query, keep_blank_values=True)\n\n    # Normalize new arguments to a list of tuples\n    if isinstance(args, dict):\n        new_params = list(args.items())\n    else:\n        new_params = list(args)\n\n    # Combine existing and new parameters\n    combined_params = existing_params + new_params\n    # Encode combined parameters\n    query_string = urlencode(combined_params, doseq=True)\n\n    # Rebuild the URL with the new query string\n    new_url = urlunparse(\n        (\n            parsed_url.scheme,\n            parsed_url.netloc,\n            parsed_url.path,\n            parsed_url.params,\n            query_string,\n            parsed_url.fragment,\n        )\n    )\n    return new_url", "message": "passed", "passed": true}
{"task_id": 272, "prediction_id": 1, "generation": "from typing import Union, Dict, List, Tuple\nfrom urllib.parse import urlparse, urlunparse, parse_qsl, urlencode\n\n\ndef url_concat(\n    url: str,\n    args: Union[\n        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]\n    ],\n) -> str:\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if not args:\n        return url\n\n    # Parse the URL into components\n    parsed_url = urlparse(url)\n\n    # Parse existing query parameters into a list of tuples\n    existing_params = parse_qsl(parsed_url.query, keep_blank_values=True)\n\n    # Normalize args into list of tuples\n    if isinstance(args, dict):\n        new_params = list(args.items())\n    else:\n        new_params = list(args)\n\n    # Combine existing and new parameters\n    combined_params = existing_params + new_params\n\n    # Encode combined parameters\n    new_query = urlencode(combined_params, doseq=True)\n\n    # Rebuild the URL with the new query\n    new_url = urlunparse(\n        (\n            parsed_url.scheme,\n            parsed_url.netloc,\n            parsed_url.path,\n            parsed_url.params,\n            new_query,\n            parsed_url.fragment,\n        )\n    )\n    return new_url", "message": "passed", "passed": true}
{"task_id": 272, "prediction_id": 2, "generation": "from typing import Union, Dict, List, Tuple\nfrom urllib.parse import urlparse, urlunparse, parse_qsl, urlencode\n\ndef url_concat(\n    url: str,\n    args: Union[\n        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]\n    ],\n) -> str:\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if not args:\n        return url\n\n    parsed_url = urlparse(url)\n    # Extract existing query parameters as a list of (key, value) tuples\n    existing_params = parse_qsl(parsed_url.query, keep_blank_values=True)\n\n    # Normalize args to list of (key, value) tuples\n    if isinstance(args, dict):\n        new_params = list(args.items())\n    else:\n        new_params = list(args)\n\n    # Combine existing and new parameters\n    combined_params = existing_params + new_params\n\n    # Encode combined params\n    new_query = urlencode(combined_params, doseq=True)\n\n    # Reconstruct the URL with the new query string\n    new_url = urlunparse(\n        (\n            parsed_url.scheme,\n            parsed_url.netloc,\n            parsed_url.path,\n            parsed_url.params,\n            new_query,\n            parsed_url.fragment,\n        )\n    )\n    return new_url", "message": "passed", "passed": true}
{"task_id": 272, "prediction_id": 3, "generation": "from typing import Union, Dict, List, Tuple\nfrom urllib.parse import urlparse, urlunparse, parse_qsl, urlencode\n\n\ndef url_concat(\n    url: str,\n    args: Union[\n        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]\n    ],\n) -> str:\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if not args:\n        return url\n\n    # Parse the original URL into components\n    parsed = urlparse(url)\n    # Extract existing query parameters as a list of (key, value) pairs\n    existing_args = parse_qsl(parsed.query, keep_blank_values=True)\n\n    # Normalize args to a list of (key, value) pairs for consistent handling\n    if isinstance(args, dict):\n        new_args = list(args.items())\n    else:\n        new_args = list(args)\n\n    # Combine existing and new arguments\n    combined_args = existing_args + new_args\n\n    # Construct a new query string\n    new_query = urlencode(combined_args, doseq=True)\n\n    # Rebuild the full URL with the new query string\n    new_url = urlunparse(\n        (\n            parsed.scheme,\n            parsed.netloc,\n            parsed.path,\n            parsed.params,\n            new_query,\n            parsed.fragment,\n        )\n    )\n    return new_url", "message": "passed", "passed": true}
{"task_id": 272, "prediction_id": 4, "generation": "from typing import Union, Dict, List, Tuple\nfrom urllib.parse import urlparse, urlunparse, parse_qsl, urlencode\n\ndef url_concat(\n    url: str,\n    args: Union[\n        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]\n    ],\n) -> str:\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if not args:\n        return url\n\n    # Parse the original URL into components\n    parsed_url = urlparse(url)\n\n    # Parse existing query parameters into a list of key-value pairs\n    existing_args = parse_qsl(parsed_url.query, keep_blank_values=True)\n\n    # Prepare new args as list of pairs\n    if isinstance(args, dict):\n        new_args = list(args.items())\n    else:\n        new_args = list(args)\n\n    # Combine existing args with new args\n    combined_args = existing_args + new_args\n\n    # Re-encode the query string\n    new_query = urlencode(combined_args, doseq=True)\n\n    # Reconstruct the full URL with the updated query string\n    new_url = urlunparse(\n        (\n            parsed_url.scheme,\n            parsed_url.netloc,\n            parsed_url.path,\n            parsed_url.params,\n            new_query,\n            parsed_url.fragment,\n        )\n    )\n    return new_url", "message": "passed", "passed": true}
