{"task_id": 278, "prediction_id": 0, "generation": "import urllib.parse\nimport re\nfrom typing import Tuple, Dict, Generator\n\ndef _parseparam(s: str) -> Generator[str, None, None]:\n    while s[:1] == \";\":\n        s = s[1:]\n        end = s.find(\";\")\n        # find semicolon that is not within quotes\n        while end > 0 and (s.count('\"', 0, end) - s.count('\\\\\"', 0, end)) % 2:\n            end = s.find(\";\", end + 1)\n        if end < 0:\n            end = len(s)\n        f = s[:end]\n        yield f.strip()\n        s = s[end:]\n\n\ndef _parse_header(line: str) -> Tuple[str, Dict[str, str]]:\n    r\"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    >>> d = \"form-data; foo=\\\"b\\\\\\\\a\\\\\\\"r\\\"; file*=utf-8''T%C3%A4st\"\n    >>> ct, d = _parse_header(d)\n    >>> ct\n    'form-data'\n    >>> d['file'] == r'T\\u00e4st'.encode('ascii').decode('unicode_escape')\n    True\n    >>> d['foo']\n    'b\\\\a\"r'\n    \"\"\"\n    parts = line.split(\";\", 1)\n    key = parts[0].strip().lower()\n    params = {}\n    if len(parts) == 1:\n        return key, params\n\n    for p in _parseparam(\";\" + parts[1]):\n        if not p:\n            continue\n        if \"=\" in p:\n            k, v = p.split(\"=\", 1)\n            k = k.strip().lower()\n\n            if k.endswith(\"*\"):\n                # RFC 2231 encoding like: filename*=utf-8''foo%20bar\n                k = k[:-1]\n                # Parse according to RFC 2231: charset'lang'value\n                charset_lang_val = v.strip()\n                # Try to split charset, lang and encoded_val\n                if \"'\" in charset_lang_val:\n                    try:\n                        charset, lang, encoded_val = charset_lang_val.split(\"'\", 2)\n                    except ValueError:\n                        # Invalid format, fallback - treat as regular value\n                        params[k] = encoded_val\n                        continue\n                    # Decode percent-encoded string\n                    decoded_val = urllib.parse.unquote(encoded_val)\n                    try:\n                        decoded_val = decoded_val.encode('latin-1').decode(charset)\n                    except Exception:\n                        # fallback: keep as is\n                        pass\n                    params[k] = decoded_val\n                else:\n                    # no charset/lang found, treat as normal value\n                    params[k] = v.strip()\n            else:\n                v = v.strip()\n                if len(v) >= 2 and v[0] == v[-1] == '\"':\n                    v = v[1:-1]\n                    # unescape \\\" and \\\\ in the quoted string\n                    v = v.replace(r'\\\\', '\\\\').replace(r'\\\"', '\"')\n                params[k] = v\n        else:\n            # valueless parameter treated as flag with empty string\n            k = p.strip().lower()\n            params[k] = \"\"\n\n    return key, params", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1486, in <module>\n  File \"<string>\", line 1485, in test_28\nAssertionError\n", "passed": false}
{"task_id": 278, "prediction_id": 1, "generation": "import urllib.parse\nimport re\nfrom typing import Tuple, Dict, Generator\n\n\ndef _parse_header(line: str) -> Tuple[str, Dict[str, str]]:\n    r\"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    >>> d = \"form-data; foo=\\\"b\\\\\\\\a\\\\\\\"r\\\"; file*=utf-8''T%C3%A4st\"\n    >>> ct, d = _parse_header(d)\n    >>> ct\n    'form-data'\n    >>> d['file'] == r'T\\u00e4st'.encode('ascii').decode('unicode_escape')\n    True\n    >>> d['foo']\n    'b\\\\a\"r'\n    \"\"\"\n    def _parseparam(s: str) -> Generator[str, None, None]:\n        # copied here since the code snippet in file context was cut off\n        while s[:1] == \";\":\n            s = s[1:]\n            end = s.find(\";\")\n            while end > 0 and (s.count('\"', 0, end) - s.count('\\\\\"', 0, end)) % 2:\n                end = s.find(\";\", end + 1)\n            if end < 0:\n                end = len(s)\n            f = s[:end]\n            yield f.strip()\n            s = s[end:]\n\n    parts = line.split(\";\")\n    key = parts[0].strip().lower() if parts else \"\"\n    opts = {}\n\n    # Parse parameters\n    for param in _parseparam(line[len(parts[0]):]):\n        if '=' in param:\n            k, v = param.split('=', 1)\n            k = k.strip().lower()\n\n            # Handle RFC 2231/5987 encoding: filename*=encoding'lang'value\n            if k.endswith('*'):\n                k = k[:-1]\n                try:\n                    # value is expected like utf-8''encoded-text (optional language tag)\n                    enc_lang_val = v.strip().split(\"'\", 2)\n                    if len(enc_lang_val) == 3:\n                        encoding, language, encoded_value = enc_lang_val\n                        decoded = urllib.parse.unquote(encoded_value)\n                        v = decoded.encode('latin-1').decode(encoding)\n                    else:\n                        v = urllib.parse.unquote(v)\n                except Exception:\n                    # fallback to raw value unquoting if decoding fails\n                    v = urllib.parse.unquote(v)\n\n            # Handle quoted-string and escaped characters\n            elif len(v) >= 2 and v[0] == '\"' and v[-1] == '\"':\n                # Strip quotes and unescape \\\" and \\\\\n                unquoted = v[1:-1]\n                unquoted = re.sub(r'\\\\(.)', r'\\1', unquoted)\n                v = unquoted\n\n            else:\n                v = v.strip()\n\n            opts[k] = v\n        else:\n            # valueless parameter, store as empty string\n            k = param.strip().lower()\n            if k:\n                opts[k] = ''\n    return key, opts", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1206, in <module>\n  File \"<string>\", line 1205, in test_9\nAssertionError\n", "passed": false}
{"task_id": 278, "prediction_id": 2, "generation": "import re\nfrom typing import Tuple, Dict\nfrom urllib.parse import unquote\n\ndef _parse_header(line: str) -> Tuple[str, Dict[str, str]]:\n    r\"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    >>> d = \"form-data; foo=\\\"b\\\\\\\\a\\\\\\\"r\\\"; file*=utf-8''T%C3%A4st\"\n    >>> ct, d = _parse_header(d)\n    >>> ct\n    'form-data'\n    >>> d['file'] == r'T\\u00e4st'.encode('ascii').decode('unicode_escape')\n    True\n    >>> d['foo']\n    'b\\\\a\"r'\n    \"\"\"\n    def decode_rfc2231_value(value: str) -> str:\n        # Parse charset'lang'value\n        # Example: utf-8''T%C3%A4st\n        try:\n            charset_lang, encoded = value.split(\"'\", 2)[0:2], value.split(\"'\", 2)[2]\n        except ValueError:\n            # fallback: no charset/lang\n            charset = 'utf-8'\n            encoded = value\n        else:\n            charset = charset_lang[0]\n            # encoded is value after 2nd '\n            encoded = value[len(charset) + 2 :]\n        # Percent decode\n        decoded_bytes = unquote(encoded)\n        # Decode bytes to str using charset\n        try:\n            return decoded_bytes.encode(\"latin-1\").decode(charset)\n        except Exception:\n            return decoded_bytes\n\n    def unquote_string(value: str) -> str:\n        # Remove quotes and handle backslash escapes\n        if len(value) >= 2 and value[0] == value[-1] == '\"':\n            value = value[1:-1]\n            # unescape \\\" and \\\\\n            return re.sub(r'\\\\(.)', r'\\1', value)\n        return value\n\n    # Split main value and parameters\n    parts = line.split(\";\", 1)\n    main_value = parts[0].strip().lower()\n    params_part = parts[1] if len(parts) > 1 else \"\"\n    params = {}\n\n    for param in _parseparam(params_part):\n        if '=' not in param:\n            key = param.strip().lower()\n            params[key] = ''\n            continue\n\n        key, value = param.split(\"=\", 1)\n        key = key.strip().lower()\n        value = value.strip()\n\n        if key.endswith(\"*\"):\n            key = key[:-1]\n            # RFC 2231 encoding\n            # e.g. utf-8''T%C3%A4st\n            # value might be quoted\n            if len(value) >= 2 and value[0] == value[-1] == '\"':\n                value = value[1:-1]\n            # decode percent-encoded UTF-8 string\n            try:\n                charset_lang, encoded_value = value.split(\"'\", 2)[0:2], value.split(\"'\", 2)[2]\n            except Exception:\n                # fallback - treat as plain value (unquoted)\n                decoded = unquote(value)\n            else:\n                charset = charset_lang[0]\n                encoded_value = value[len(charset) + 2 :]\n                try:\n                    decoded_bytes = unquote(encoded_value).encode('latin-1')\n                    decoded = decoded_bytes.decode(charset)\n                except Exception:\n                    decoded = unquote(encoded_value)\n            # According to docstring example, decode unicode escape sequences\n            decoded = decoded.encode('ascii', 'backslashreplace').decode('unicode_escape')\n            params[key] = decoded\n        else:\n            value = unquote_string(value)\n            params[key] = value\n\n    return main_value, params\n\n\ndef _parseparam(s: str) -> \"Generator[str, None, None]\":\n    # This is inferred and completed based on partial provided code\n    while s[:1] == \";\":\n        s = s[1:]\n        end = s.find(\";\")\n        while end > 0 and (s.count('\"', 0, end) - s.count('\\\\\"', 0, end)) % 2:\n            end = s.find(\";\", end + 1)\n        if end < 0:\n            end = len(s)\n        f = s[:end]\n        yield f.strip()\n        s = s[end:]\n    if s:\n        yield s.strip()", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1215, in <module>\n  File \"<string>\", line 1214, in test_1\nAssertionError\n", "passed": false}
{"task_id": 278, "prediction_id": 3, "generation": "import re\nimport codecs\nfrom typing import Tuple, Dict\nfrom urllib.parse import unquote\n\ndef _parse_header(line: str) -> Tuple[str, Dict[str, str]]:\n    r\"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    >>> d = \"form-data; foo=\\\"b\\\\\\\\a\\\\\\\"r\\\"; file*=utf-8''T%C3%A4st\"\n    >>> ct, d = _parse_header(d)\n    >>> ct\n    'form-data'\n    >>> d['file'] == r'T\\u00e4st'.encode('ascii').decode('unicode_escape')\n    True\n    >>> d['foo']\n    'b\\\\a\"r'\n    \"\"\"\n    def _unquote(value: str) -> str:\n        # Remove quotes and decode backslash escapes inside quoted string\n        if value.startswith('\"') and value.endswith('\"'):\n            value = value[1:-1]\n            # Decode backslash escapes like \\\\, \\\"\n            # This is a bit like unicode_escape but only for backslash escapes\n            # We'll decode with 'unicode_escape' encoding to handle the escapes properly\n            value = value.encode(\"ascii\", \"backslashreplace\").decode(\"unicode_escape\")\n        return value\n\n    # Parsing parameters generator: copied from file content:\n    def _parseparam(s: str):\n        while s[:1] == \";\":\n            s = s[1:]\n            end = s.find(\";\")\n            while end > 0 and (s.count('\"', 0, end) - s.count('\\\\\"', 0, end)) % 2:\n                end = s.find(\";\", end + 1)\n            if end < 0:\n                end = len(s)\n            f = s[:end]\n            yield f.strip()\n            s = s[end:]\n\n    parts = line.split(\";\", 1)\n    main_value = parts[0].strip().lower()\n    params: Dict[str, str] = {}\n\n    if len(parts) == 2:\n        param_str = \";\" + parts[1]  # so _parseparam can parse correctly\n\n        for param in _parseparam(param_str):\n            if not param:\n                continue\n            if \"=\" in param:\n                key, val = param.split(\"=\", 1)\n                key = key.strip().lower()\n                val = val.strip()\n                if key.endswith(\"*\"):\n                    # RFC 2231/5987 encoding: key*=charset'lang'%encoded_text\n                    key = key[:-1]\n                    # decode according to RFC 2231\n                    try:\n                        charset_lang, encoded = val.split(\"'\", 2)[0:2], val.split(\"'\", 2)[2]\n                        # The above line is complicated so better split once:\n                        # val example: utf-8''T%C3%A4st\n                        # split on first two ' -> [charset, language, encoded_text]\n                        parts_val = val.split(\"'\", 2)\n                        if len(parts_val) == 3:\n                            charset, lang, encoded_text = parts_val\n                            # Percent decode\n                            raw_bytes = unquote(encoded_text)\n                            # decode bytes with charset\n                            decoded_val = raw_bytes.encode('latin-1').decode(charset, errors='replace')\n                        else:\n                            # invalid format? fallback to val no decoding\n                            decoded_val = val\n                    except Exception:\n                        decoded_val = val\n                    params[key] = decoded_val\n                else:\n                    val = _unquote(val)\n                    params[key] = val\n            else:\n                # valueless param\n                key = param.strip().lower()\n                params[key] = \"\"\n\n    return main_value, params", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1218, in <module>\n  File \"<string>\", line 1217, in test_9\nAssertionError\n", "passed": false}
{"task_id": 278, "prediction_id": 4, "generation": "import re\nfrom typing import Tuple, Dict\nfrom urllib.parse import unquote\n\n\ndef _parseparam(s: str):\n    \"\"\"Generator to split parameter string by semicolons, respecting quoted semicolons.\n\n    Yields each parameter string without leading/trailing whitespace.\n    \"\"\"\n    while s[:1] == \";\":\n        s = s[1:]\n        end = 0\n        in_quote = False\n        escape = False\n        for i, c in enumerate(s):\n            if escape:\n                escape = False\n                continue\n            if c == \"\\\\\":\n                escape = True\n            elif c == '\"':\n                in_quote = not in_quote\n            elif c == \";\" and not in_quote:\n                end = i\n                break\n        else:\n            end = len(s)\n        yield s[:end].strip()\n        s = s[end:]\n\n\ndef _parse_header(line: str) -> Tuple[str, Dict[str, str]]:\n    r\"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    >>> d = \"form-data; foo=\\\"b\\\\\\\\a\\\\\\\"r\\\"; file*=utf-8''T%C3%A4st\"\n    >>> ct, d = _parse_header(d)\n    >>> ct\n    'form-data'\n    >>> d['file'] == r'T\\u00e4st'.encode('ascii').decode('unicode_escape')\n    True\n    >>> d['foo']\n    'b\\\\a\"r'\n    \"\"\"\n    result = {}\n    # Split main value and params\n    parts = line.split(\";\", 1)\n    main_value = parts[0].strip().lower()\n    param_str = \";\" + parts[1] if len(parts) > 1 else \"\"\n\n    # Parse parameters using _parseparam\n    for param in _parseparam(param_str):\n        if not param:\n            continue\n        if \"=\" in param:\n            key, val = param.split(\"=\", 1)\n            key = key.strip().lower()\n            val = val.strip()\n            if val.startswith('\"') and val.endswith('\"') and len(val) >= 2:\n                # Remove quotes and unescape\n                val = val[1:-1]\n                val = val.replace(r'\\\"', '\"').replace(r\"\\\\\", \"\\\\\")\n                # We must handle backslash escapes inside the quoted string:\n                # Backslash followed by any char means that char literal.\n                # But above replace may be insufficient if sequences like \\x\n                # So safer to decode manually:\n\n                # Re-implement proper unescape\n                unescaped = []\n                i = 0\n                length = len(val)\n                while i < length:\n                    c = val[i]\n                    if c == \"\\\\\" and i + 1 < length:\n                        next_c = val[i + 1]\n                        unescaped.append(next_c)\n                        i += 2\n                    else:\n                        unescaped.append(c)\n                        i += 1\n                val = \"\".join(unescaped)\n            elif key.endswith(\"*\"):\n                # RFC 2231 style encoding: key*=charset'lang'%encoded\n                try:\n                    # key after removing trailing *\n                    real_key = key[:-1]\n                    # value format charset'lang'%encoded_value\n                    charset_lang_value = val\n                    # Split at first '\n                    first_quote = charset_lang_value.find(\"'\")\n                    second_quote = charset_lang_value.find(\"'\", first_quote + 1)\n                    if first_quote == -1 or second_quote == -1:\n                        # Malformed, treat as normal token\n                        result[real_key] = val\n                    else:\n                        charset = charset_lang_value[:first_quote]\n                        # language = charset_lang_value[first_quote+1:second_quote] # language ignored\n                        encoded_value = charset_lang_value[second_quote + 1 :]\n                        # Percent decode\n                        decoded_bytes = unquote(encoded_value)\n                        # Decode bytes according to charset\n                        # decoded_bytes is str returned from unquote (unicode), but in Python3 unquote returns str\n                        # We need bytes to decode, encode to latin1 to get bytes back with exact 1:1 mapping\n                        decoded = decoded_bytes.encode(\"latin1\").decode(charset)\n                        result[real_key] = decoded\n                except Exception:\n                    # fallback\n                    result[key] = val\n                continue\n            else:\n                # unquoted val\n                result[key] = val\n        else:\n            # Valueless parameter like \"; secure\"\n            key = param.strip().lower()\n            result[key] = \"\"\n    return main_value, result", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1250, in <module>\n  File \"<string>\", line 1249, in test_9\nAssertionError\n", "passed": false}
