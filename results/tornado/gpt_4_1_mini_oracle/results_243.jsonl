{"task_id": 243, "prediction_id": 0, "generation": "from typing import Union, List, Dict, Any, Type, Tuple\nfrom tornado.concurrent import Future\nfrom tornado.gen import _Yieldable\nfrom tornado.gen import multi_future\n\n\ndef multi(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> \"Union[Future[List], Future[Dict]]\":\n    \"\"\"Runs multiple asynchronous operations in parallel.\n\n    ``children`` may either be a list or a dict whose values are\n    yieldable objects. ``multi()`` returns a new yieldable\n    object that resolves to a parallel structure containing their\n    results. If ``children`` is a list, the result is a list of\n    results in the same order; if it is a dict, the result is a dict\n    with the same keys.\n\n    That is, ``results = yield multi(list_of_futures)`` is equivalent\n    to::\n\n    results = []\n    for future in list_of_futures:\n    results.append(yield future)\n\n    If any children raise exceptions, ``multi()`` will raise the first\n    one. All others will be logged, unless they are of types\n    contained in the ``quiet_exceptions`` argument.\n\n    In a ``yield``-based coroutine, it is not normally necessary to\n    call this function directly, since the coroutine runner will\n    do it automatically when a list or dict is yielded. However,\n    it is necessary in ``await``-based coroutines, or to pass\n    the ``quiet_exceptions`` argument.\n\n    This function is available under the names ``multi()`` and ``Multi()``\n    for historical reasons.\n\n    Cancelling a `.Future` returned by ``multi()`` does not cancel its\n    children. `asyncio.gather` is similar to ``multi()``, but it does\n    cancel its children.\n\n    .. versionchanged:: 4.2\n    If multiple yieldables fail, any exceptions after the first\n    (which is raised) will be logged. Added the ``quiet_exceptions``\n    argument to suppress this logging for selected exception types.\n\n    .. versionchanged:: 4.3\n    Replaced the class ``Multi`` and the function ``multi_future``\n    with a unified function ``multi``. Added support for yieldables\n    other than ``YieldPoint`` and `.Future`.\n\n    \"\"\"\n    return multi_future(children, quiet_exceptions)", "message": "passed", "passed": true}
{"task_id": 243, "prediction_id": 1, "generation": "from typing import Union, List, Dict, Any, Tuple, Type\nfrom tornado.concurrent import Future, is_future\nfrom tornado.gen import _Yieldable\nfrom tornado.gen import _create_future, future_set_result_unless_cancelled, future_set_exc_info, future_add_done_callback\nfrom tornado.gen import multi_future\n\n\ndef multi(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> \"Union[Future[List], Future[Dict]]\":\n    \"\"\"Runs multiple asynchronous operations in parallel.\n\n    ``children`` may either be a list or a dict whose values are\n    yieldable objects. ``multi()`` returns a new yieldable\n    object that resolves to a parallel structure containing their\n    results. If ``children`` is a list, the result is a list of\n    results in the same order; if it is a dict, the result is a dict\n    with the same keys.\n\n    That is, ``results = yield multi(list_of_futures)`` is equivalent\n    to::\n\n    results = []\n    for future in list_of_futures:\n    results.append(yield future)\n\n    If any children raise exceptions, ``multi()`` will raise the first\n    one. All others will be logged, unless they are of types\n    contained in the ``quiet_exceptions`` argument.\n\n    In a ``yield``-based coroutine, it is not normally necessary to\n    call this function directly, since the coroutine runner will\n    do it automatically when a list or dict is yielded. However,\n    it is necessary in ``await``-based coroutines, or to pass\n    the ``quiet_exceptions`` argument.\n\n    This function is available under the names ``multi()`` and ``Multi()``\n    for historical reasons.\n\n    Cancelling a `.Future` returned by ``multi()`` does not cancel its\n    children. `asyncio.gather` is similar to ``multi()``, but it does\n    cancel its children.\n\n    .. versionchanged:: 4.2\n    If multiple yieldables fail, any exceptions after the first\n    (which is raised) will be logged. Added the ``quiet_exceptions``\n    argument to suppress this logging for selected exception types.\n\n    .. versionchanged:: 4.3\n    Replaced the class ``Multi`` and the function ``multi_future``\n    with a unified function ``multi``. Added support for yieldables\n    other than ``YieldPoint`` and `.Future`.\n\n    \"\"\"\n    return multi_future(children, quiet_exceptions)", "message": "passed", "passed": true}
{"task_id": 243, "prediction_id": 2, "generation": "from typing import Union, List, Dict, Any, Type, Tuple\nfrom tornado.concurrent import Future, is_future, future_set_result_unless_cancelled, future_set_exc_info, future_add_done_callback\nfrom tornado.gen import _Yieldable, _create_future, convert_yielded\nimport sys\nfrom tornado.log import app_log\n\ndef multi(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> \"Union[Future[List], Future[Dict]]\":\n    \"\"\"Runs multiple asynchronous operations in parallel.\n\n    ``children`` may either be a list or a dict whose values are\n    yieldable objects. ``multi()`` returns a new yieldable\n    object that resolves to a parallel structure containing their\n    results. If ``children`` is a list, the result is a list of\n    results in the same order; if it is a dict, the result is a dict\n    with the same keys.\n\n    That is, ``results = yield multi(list_of_futures)`` is equivalent\n    to::\n\n    results = []\n    for future in list_of_futures:\n    results.append(yield future)\n\n    If any children raise exceptions, ``multi()`` will raise the first\n    one. All others will be logged, unless they are of types\n    contained in the ``quiet_exceptions`` argument.\n\n    In a ``yield``-based coroutine, it is not normally necessary to\n    call this function directly, since the coroutine runner will\n    do it automatically when a list or dict is yielded. However,\n    it is necessary in ``await``-based coroutines, or to pass\n    the ``quiet_exceptions`` argument.\n\n    This function is available under the names ``multi()`` and ``Multi()``\n    for historical reasons.\n\n    Cancelling a `.Future` returned by ``multi()`` does not cancel its\n    children. `asyncio.gather` is similar to ``multi()``, but it does\n    cancel its children.\n\n    .. versionchanged:: 4.2\n    If multiple yieldables fail, any exceptions after the first\n    (which is raised) will be logged. Added the ``quiet_exceptions``\n    argument to suppress this logging for selected exception types.\n\n    .. versionchanged:: 4.3\n    Replaced the class ``Multi`` and the function ``multi_future``\n    with a unified function ``multi``. Added support for yieldables\n    other than ``YieldPoint`` and `.Future`.\n\n    \"\"\"\n    if isinstance(children, dict):\n        keys = list(children.keys())\n        children_seq = children.values()\n    else:\n        keys = None\n        children_seq = children\n\n    children_futs = list(map(convert_yielded, children_seq))\n    assert all(is_future(f) for f in children_futs)\n\n    unfinished_children = set(children_futs)\n    future = _create_future()\n\n    if not children_futs:\n        future_set_result_unless_cancelled(future, {} if keys is not None else [])\n        return future\n\n    def callback(fut: Future) -> None:\n        if fut in unfinished_children:\n            unfinished_children.remove(fut)\n        if not unfinished_children:\n            results = []\n            first_exception_info = None\n            for f in children_futs:\n                try:\n                    results.append(f.result())\n                except Exception:\n                    exc_info = sys.exc_info()\n                    if not first_exception_info:\n                        first_exception_info = exc_info\n                    else:\n                        if not isinstance(exc_info[1], quiet_exceptions):\n                            app_log.error(\"Multiple exceptions in yield list\", exc_info=exc_info)\n            if first_exception_info:\n                # Set exception on the returned future\n                if not future.done():\n                    future_set_exc_info(future, first_exception_info)\n            else:\n                # No exceptions, set result preserving structure\n                if keys is not None:\n                    future_set_result_unless_cancelled(future, dict(zip(keys, results)))\n                else:\n                    future_set_result_unless_cancelled(future, results)\n\n    listening = set()\n    for f in children_futs:\n        if f not in listening:\n            listening.add(f)\n            future_add_done_callback(f, callback)\n\n    return future", "message": "passed", "passed": true}
{"task_id": 243, "prediction_id": 3, "generation": "from typing import Union, List, Dict, Any, Type, Tuple\nfrom tornado.gen import _Yieldable, Future, multi_future\n\n\ndef multi(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]] = (),\n) -> Union[Future[List], Future[Dict]]:\n    \"\"\"Runs multiple asynchronous operations in parallel.\n\n    ``children`` may either be a list or a dict whose values are\n    yieldable objects. ``multi()`` returns a new yieldable\n    object that resolves to a parallel structure containing their\n    results. If ``children`` is a list, the result is a list of\n    results in the same order; if it is a dict, the result is a dict\n    with the same keys.\n\n    That is, ``results = yield multi(list_of_futures)`` is equivalent\n    to::\n\n    results = []\n    for future in list_of_futures:\n    results.append(yield future)\n\n    If any children raise exceptions, ``multi()`` will raise the first\n    one. All others will be logged, unless they are of types\n    contained in the ``quiet_exceptions`` argument.\n\n    In a ``yield``-based coroutine, it is not normally necessary to\n    call this function directly, since the coroutine runner will\n    do it automatically when a list or dict is yielded. However,\n    it is necessary in ``await``-based coroutines, or to pass\n    the ``quiet_exceptions`` argument.\n\n    This function is available under the names ``multi()`` and ``Multi()``\n    for historical reasons.\n\n    Cancelling a `.Future` returned by ``multi()`` does not cancel its\n    children. `asyncio.gather` is similar to ``multi()``, but it does\n    cancel its children.\n\n    .. versionchanged:: 4.2\n    If multiple yieldables fail, any exceptions after the first\n    (which is raised) will be logged. Added the ``quiet_exceptions``\n    argument to suppress this logging for selected exception types.\n\n    .. versionchanged:: 4.3\n    Replaced the class ``Multi`` and the function ``multi_future``\n    with a unified function ``multi``. Added support for yieldables\n    other than ``YieldPoint`` and `.Future`.\n\n    \"\"\"\n    return multi_future(children, quiet_exceptions)", "message": "passed", "passed": true}
{"task_id": 243, "prediction_id": 4, "generation": "from typing import Union, List, Dict, Any, Type, Tuple\nfrom tornado.gen import _Yieldable, Future, is_future, future_set_result_unless_cancelled, future_set_exc_info, future_add_done_callback, _create_future, convert_yielded\nfrom tornado.log import app_log\nimport sys\n\n\ndef multi(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> \"Union[Future[List], Future[Dict]]\":\n    \"\"\"Runs multiple asynchronous operations in parallel.\n\n    ``children`` may either be a list or a dict whose values are\n    yieldable objects. ``multi()`` returns a new yieldable\n    object that resolves to a parallel structure containing their\n    results. If ``children`` is a list, the result is a list of\n    results in the same order; if it is a dict, the result is a dict\n    with the same keys.\n\n    That is, ``results = yield multi(list_of_futures)`` is equivalent\n    to::\n\n    results = []\n    for future in list_of_futures:\n    results.append(yield future)\n\n    If any children raise exceptions, ``multi()`` will raise the first\n    one. All others will be logged, unless they are of types\n    contained in the ``quiet_exceptions`` argument.\n\n    In a ``yield``-based coroutine, it is not normally necessary to\n    call this function directly, since the coroutine runner will\n    do it automatically when a list or dict is yielded. However,\n    it is necessary in ``await``-based coroutines, or to pass\n    the ``quiet_exceptions`` argument.\n\n    This function is available under the names ``multi()`` and ``Multi()``\n    for historical reasons.\n\n    Cancelling a `.Future` returned by ``multi()`` does not cancel its\n    children. `asyncio.gather` is similar to ``multi()``, but it does\n    cancel its children.\n\n    .. versionchanged:: 4.2\n    If multiple yieldables fail, any exceptions after the first\n    (which is raised) will be logged. Added the ``quiet_exceptions``\n    argument to suppress this logging for selected exception types.\n\n    .. versionchanged:: 4.3\n    Replaced the class ``Multi`` and the function ``multi_future``\n    with a unified function ``multi``. Added support for yieldables\n    other than ``YieldPoint`` and `.Future`.\n\n    \"\"\"\n    if isinstance(children, dict):\n        keys = list(children.keys())\n        children_seq = children.values()\n    else:\n        keys = None\n        children_seq = children\n\n    children_futs = list(map(convert_yielded, children_seq))\n    assert all(is_future(f) for f in children_futs)\n\n    unfinished_children = set(children_futs)\n    future = _create_future()\n\n    if not children_futs:\n        future_set_result_unless_cancelled(future, {} if keys is not None else [])\n        return future\n\n    def callback(fut: Future) -> None:\n        if fut not in unfinished_children:\n            return\n        unfinished_children.remove(fut)\n        if not unfinished_children:\n            results = []\n            for f in children_futs:\n                try:\n                    results.append(f.result())\n                except Exception as e:\n                    if future.done():\n                        if not isinstance(e, quiet_exceptions):\n                            app_log.error(\n                                \"Multiple exceptions in multi()\", exc_info=True\n                            )\n                    else:\n                        future_set_exc_info(future, sys.exc_info())\n            if not future.done():\n                if keys is not None:\n                    future_set_result_unless_cancelled(\n                        future, dict(zip(keys, results))\n                    )\n                else:\n                    future_set_result_unless_cancelled(future, results)\n\n    listening = set()\n    for f in children_futs:\n        if f not in listening:\n            listening.add(f)\n            future_add_done_callback(f, callback)\n\n    return future", "message": "passed", "passed": true}
