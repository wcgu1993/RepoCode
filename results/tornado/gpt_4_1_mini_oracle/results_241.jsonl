{"task_id": 241, "prediction_id": 0, "generation": "from typing import Optional\nfrom tornado.escape import url_unescape\n\n\ndef _unquote_or_none(s: Optional[str]) -> Optional[bytes]:\n    \"\"\"None-safe wrapper around url_unescape to handle unmatched optional\n    groups correctly.\n\n    Note that args are passed as bytes so the handler can decide what\n    encoding to use.\n    \"\"\"\n    if s is None:\n        return None\n    return url_unescape(s, encoding=None, plus=False)", "message": "passed", "passed": true}
{"task_id": 241, "prediction_id": 1, "generation": "from typing import Optional\nfrom tornado.escape import url_unescape\n\n\ndef _unquote_or_none(s: Optional[str]) -> Optional[bytes]:\n    \"\"\"None-safe wrapper around url_unescape to handle unmatched optional\n    groups correctly.\n\n    Note that args are passed as bytes so the handler can decide what\n    encoding to use.\n    \"\"\"\n    if s is None:\n        return None\n    # url_unescape with encoding=None returns bytes, no plus decoding for path groups\n    return url_unescape(s, encoding=None, plus=False)", "message": "passed", "passed": true}
{"task_id": 241, "prediction_id": 2, "generation": "from typing import Optional\nfrom tornado.escape import url_unescape\n\ndef _unquote_or_none(s: Optional[str]) -> Optional[bytes]:\n    \"\"\"None-safe wrapper around url_unescape to handle unmatched optional\n    groups correctly.\n\n    Note that args are passed as bytes so the handler can decide what\n    encoding to use.\n    \"\"\"\n    if s is None:\n        return None\n    # url_unescape with encoding=None returns bytes\n    return url_unescape(s, encoding=None, plus=False)", "message": "passed", "passed": true}
{"task_id": 241, "prediction_id": 3, "generation": "from typing import Optional\nfrom tornado.escape import url_unescape\n\n\ndef _unquote_or_none(s: Optional[str]) -> Optional[bytes]:\n    \"\"\"None-safe wrapper around url_unescape to handle unmatched optional\n    groups correctly.\n\n    Note that args are passed as bytes so the handler can decide what\n    encoding to use.\n    \"\"\"\n    if s is None:\n        return None\n    # url_unescape with encoding=None returns bytes; plus=False since path components should not decode '+' as space\n    return url_unescape(s, encoding=None, plus=False)", "message": "passed", "passed": true}
{"task_id": 241, "prediction_id": 4, "generation": "from typing import Optional\nfrom tornado.escape import url_unescape\n\n\ndef _unquote_or_none(s: Optional[str]) -> Optional[bytes]:\n    \"\"\"None-safe wrapper around url_unescape to handle unmatched optional\n    groups correctly.\n\n    Note that args are passed as bytes so the handler can decide what\n    encoding to use.\n    \"\"\"\n    if s is None:\n        return None\n    return url_unescape(s, encoding=None, plus=False)", "message": "passed", "passed": true}
