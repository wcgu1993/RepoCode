{"task_id": 251, "prediction_id": 0, "generation": "import hmac\nimport hashlib\nimport urllib.parse\nfrom typing import Dict, Any, Optional, Union\nfrom tornado.util import unicode_type\n\n\ndef _oauth_escape(val: Union[str, bytes]) -> str:\n    if isinstance(val, unicode_type):\n        val = val.encode(\"utf-8\")\n    return urllib.parse.quote(val, safe=\"~\")\n\n\ndef _oauth_signature(\n    consumer_token: Dict[str, Any],\n    method: str,\n    url: str,\n    parameters: Dict[str, Any] = {},\n    token: Optional[Dict[str, Any]] = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    # Step 1: Normalize parameters: encode keys and values, sort by key and value\n    # Create a list of (key, value) with percent-encoded strings\n    encoded_params = []\n    for key, value in parameters.items():\n        # Parameters can be str or bytes or other; convert to str, then escape\n        # If value is a list (rare), flatten (not specified here, assume single values)\n        k_enc = _oauth_escape(key)\n        v_enc = _oauth_escape(value)\n        encoded_params.append((k_enc, v_enc))\n\n    # Sort parameters by key, then by value\n    encoded_params.sort()\n\n    # Construct the parameter string: key=value pairs joined by &\n    # According to OAuth 1.0 spec, all keys and values are percent encoded\n    param_str = \"&\".join(f\"{k}={v}\" for k, v in encoded_params)\n\n    # Step 2: Construct the signature base string: METHOD & base_string_uri & parameter_string\n    # Each item percent-encoded and joined by &\n    method_upper = method.upper()\n    base_string_uri = _oauth_escape(url)\n    parameter_string = _oauth_escape(param_str)\n\n    base_string = \"&\".join([method_upper, base_string_uri, parameter_string])\n\n    # Step 3: Construct the signing key: consumer_secret&token_secret (token_secret optional)\n    consumer_secret = consumer_token.get(\"secret\", \"\")\n    # Convert to bytes, utf-8 encoded\n    key = _oauth_escape(consumer_secret) + \"&\"\n    if token is not None:\n        token_secret = token.get(\"secret\", \"\")\n        key = key + _oauth_escape(token_secret)\n\n    # Step 4: Compute HMAC-SHA1 digest of base_string using key\n    hmac_key = key.encode(\"utf-8\") if not isinstance(key, bytes) else key\n    msg = base_string.encode(\"utf-8\") if not isinstance(base_string, bytes) else base_string\n\n    hashed = hmac.new(hmac_key, msg, hashlib.sha1)\n\n    # Step 5: Return the base64-encoded digest as bytes (bytes per the signature method's expectations)\n    # Note: The original tornado code expects a base64 string, but the signature method returns bytes (per hint)\n    import base64\n\n    sig = base64.b64encode(hashed.digest())\n    return sig", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1230, in <module>\n  File \"<string>\", line 1224, in test_2\n  File \"<string>\", line 1101, in _oauth_signature\n  File \"<string>\", line 1179, in _oauth_escape\n  File \"/usr/local/lib/python3.10/urllib/parse.py\", line 870, in quote\n    return quote_from_bytes(string, safe)\n  File \"/usr/local/lib/python3.10/urllib/parse.py\", line 895, in quote_from_bytes\n    raise TypeError(\"quote_from_bytes() expected bytes\")\nTypeError: quote_from_bytes() expected bytes\n", "passed": false}
{"task_id": 251, "prediction_id": 1, "generation": "import hmac\nimport hashlib\nimport urllib.parse\nfrom tornado.util import unicode_type\nfrom typing import Dict, Any, Optional, Union\n\ndef _oauth_escape(val: Union[str, bytes]) -> str:\n    if isinstance(val, unicode_type):\n        val = val.encode(\"utf-8\")\n    return urllib.parse.quote(val, safe=\"~\")\n\ndef _oauth_signature(\n    consumer_token: Dict[str, Any],\n    method: str,\n    url: str,\n    parameters: Dict[str, Any] = {},\n    token: Optional[Dict[str, Any]] = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    # 1. Normalize method (uppercase)\n    method = method.upper()\n\n    # 2. Normalize URL (scheme, host and path only, no query or fragment)\n    parsed_url = urllib.parse.urlparse(url)\n    scheme = parsed_url.scheme.lower()\n    netloc = parsed_url.netloc.lower()\n    # Remove default ports if present\n    if (scheme == \"http\" and netloc.endswith(\":80\")):\n        netloc = netloc[:-3]\n    elif (scheme == \"https\" and netloc.endswith(\":443\")):\n        netloc = netloc[:-4]\n\n    normalized_url = f\"{scheme}://{netloc}{parsed_url.path}\"\n\n    # 3. Collect and normalize parameters\n    # OAuth spec says to include query parameters and POST parameters and OAuth params (except oauth_signature)\n    params = []\n    for k, v in parameters.items():\n        if k != \"oauth_signature\":\n            if isinstance(v, (list, tuple)):\n                for vv in v:\n                    params.append((k, vv))\n            else:\n                params.append((k, v))\n    # Also include token params (e.g., for token secret?) No, for signature base string only OAuth params + URL query + POST params\n    # Token dict contains key and secret, OAuth params are already in parameters dict\n\n    # According to OAuth 1.0 spec, parameters in the URL's query string must also be included\n    url_query_params = urllib.parse.parse_qsl(parsed_url.query, keep_blank_values=True)\n    for k, v in url_query_params:\n        # Check that this parameter wasn't already included from parameters; they should all be included, but safe to include again\n        params.append((k, v))\n\n    # Percent encode keys and values\n    encoded_params = [( _oauth_escape(str(k)), _oauth_escape(str(v)) ) for k, v in params]\n\n    # Sort lexicographically by key, then by value\n    encoded_params.sort(key=lambda kv: (kv[0], kv[1]))\n\n    # Build parameter string\n    param_str = \"&\".join(f\"{k}={v}\" for k, v in encoded_params)\n\n    # Encode method, normalized URL, and parameter string for signature base string\n    base_elems = [\n        _oauth_escape(method),\n        _oauth_escape(normalized_url),\n        _oauth_escape(param_str),\n    ]\n\n    signature_base_string = \"&\".join(base_elems)\n\n    # Build signing key: consumer_secret&token_secret\n    consumer_secret = consumer_token.get(\"secret\", \"\")\n    if isinstance(consumer_secret, bytes):\n        consumer_secret = consumer_secret.decode(\"utf-8\")\n\n    token_secret = \"\"\n    if token and \"secret\" in token:\n        token_secret = token[\"secret\"]\n        if isinstance(token_secret, bytes):\n            token_secret = token_secret.decode(\"utf-8\")\n\n    signing_key = f\"{_oauth_escape(consumer_secret)}&{_oauth_escape(token_secret)}\"\n\n    # Compute HMAC-SHA1 signature and base64 encode it\n    hashed = hmac.new(\n        signing_key.encode(\"utf-8\"),\n        signature_base_string.encode(\"utf-8\"),\n        hashlib.sha1,\n    )\n    import base64\n    signature = base64.b64encode(hashed.digest())\n\n    return signature", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1269, in <module>\n  File \"<string>\", line 1263, in test_3\nAssertionError\n", "passed": false}
{"task_id": 251, "prediction_id": 2, "generation": "import hmac\nimport hashlib\nimport urllib.parse\nfrom typing import Dict, Any, Optional, Union\nfrom tornado.util import unicode_type\n\n\ndef _oauth_escape(val: Union[str, bytes]) -> str:\n    if isinstance(val, unicode_type):\n        val = val.encode(\"utf-8\")\n    return urllib.parse.quote(val, safe=\"~\")\n\n\ndef _oauth_signature(\n    consumer_token: Dict[str, Any],\n    method: str,\n    url: str,\n    parameters: Dict[str, Any] = {},\n    token: Optional[Dict[str, Any]] = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    # Prepare signing key: consumer_secret & token_secret (if available)\n    consumer_secret = consumer_token.get(\"secret\", \"\")\n    token_secret = token.get(\"secret\", \"\") if token else \"\"\n    # Both are escaped and joined by '&'\n    key = _oauth_escape(consumer_secret) + \"&\" + _oauth_escape(token_secret)\n\n    # Normalize request parameters per OAuth spec:\n    # 1. Percent-encode each key and value\n    # 2. Sort parameters by key and then by value\n    encoded_params = []\n    for k, v in parameters.items():\n        # Parameters can be bytes, str, int, or other\n        k_enc = _oauth_escape(k)\n        # Convert v to str for encoding; if list or tuple handle multiple values\n        if isinstance(v, (list, tuple)):\n            for item in v:\n                v_enc = _oauth_escape(str(item))\n                encoded_params.append((k_enc, v_enc))\n        else:\n            v_enc = _oauth_escape(str(v))\n            encoded_params.append((k_enc, v_enc))\n    # Sort by encoded key, then encoded value\n    encoded_params.sort(key=lambda pair: (pair[0], pair[1]))\n\n    # Concatenate encoded parameters into key=value pairs joined with &\n    normalized_params = \"&\".join(f\"{k}={v}\" for k, v in encoded_params)\n\n    # Construct base string as METHOD&percent_encoded_url&percent_encoded_params\n    base_elements = [\n        method.upper(),\n        _oauth_escape(url),\n        _oauth_escape(normalized_params),\n    ]\n    base_string = \"&\".join(base_elements)\n\n    # Calculate HMAC-SHA1 digest of the base string using key\n    hashed = hmac.new(key.encode(\"utf-8\"), base_string.encode(\"utf-8\"), hashlib.sha1)\n    # Return the base64-encoded digest (as bytes)\n    import base64\n\n    signature = base64.b64encode(hashed.digest())\n    return signature", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1238, in <module>\n  File \"<string>\", line 1232, in test_3\nAssertionError\n", "passed": false}
{"task_id": 251, "prediction_id": 3, "generation": "import hmac\nimport hashlib\nimport urllib.parse\nfrom typing import Dict, Any, Optional, Union\nfrom tornado.util import unicode_type\n\n\ndef _oauth_escape(val: Union[str, bytes]) -> str:\n    if isinstance(val, unicode_type):\n        val = val.encode(\"utf-8\")\n    return urllib.parse.quote(val, safe=\"~\")\n\n\ndef _oauth_signature(\n    consumer_token: Dict[str, Any],\n    method: str,\n    url: str,\n    parameters: Dict[str, Any] = {},\n    token: Optional[Dict[str, Any]] = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    # Normalize HTTP method to uppercase\n    method = method.upper()\n\n    # Combine consumer token and token secrets for signing key\n    consumer_secret = consumer_token.get(\"secret\") or \"\"\n    token_secret = token.get(\"secret\") if token else \"\"\n\n    # Percent encode the consumer_secret and token_secret\n    key = \"{}&{}\".format(\n        _oauth_escape(consumer_secret),\n        _oauth_escape(token_secret or \"\"),\n    ).encode(\"utf-8\")\n\n    # Extract base URL without query or fragment\n    parsed_url = urllib.parse.urlparse(url)\n    scheme, netloc, path = parsed_url.scheme, parsed_url.netloc, parsed_url.path\n    base_url = f\"{scheme}://{netloc}{path}\"\n\n    # Normalize parameters:\n    # Parameters include query params from URL plus input parameters dict.\n    url_params = urllib.parse.parse_qsl(parsed_url.query, keep_blank_values=True)\n    # Build a combined list of all parameters\n    all_parameters = list(url_params)\n    for k, v in parameters.items():\n        # In case a parameter value is a list, add all values\n        if isinstance(v, (list, tuple)):\n            for item in v:\n                all_parameters.append((k, str(item)))\n        else:\n            all_parameters.append((k, str(v)))\n\n    # Percent encode all key-value pairs\n    encoded_params = [( _oauth_escape(k), _oauth_escape(v) ) for k,v in all_parameters]\n\n    # Sort parameters lex by key, then value\n    encoded_params.sort()\n\n    # Create the parameter string\n    param_str = \"&\".join(f\"{k}={v}\" for k,v in encoded_params)\n\n    # Construct the signature base string\n    base_elems = [\n        _oauth_escape(method),\n        _oauth_escape(base_url),\n        _oauth_escape(param_str),\n    ]\n    base_string = \"&\".join(base_elems).encode(\"utf-8\")\n\n    # Calculate HMAC-SHA1 signature (binary digest)\n    hashed = hmac.new(key, base_string, hashlib.sha1)\n\n    # Return the binary signature bytes\n    return hashed.digest()", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1215, in <module>\n  File \"<string>\", line 1208, in test_0\nAssertionError\n", "passed": false}
{"task_id": 251, "prediction_id": 4, "generation": "import hmac\nimport hashlib\nimport urllib.parse\nfrom typing import Dict, Any, Optional\n\nfrom tornado.util import unicode_type\n\n\ndef _oauth_escape(val: Any) -> str:\n    if isinstance(val, unicode_type):\n        val = val.encode(\"utf-8\")\n    return urllib.parse.quote(val, safe=\"~\")\n\n\ndef _oauth_signature(\n    consumer_token: Dict[str, Any],\n    method: str,\n    url: str,\n    parameters: Dict[str, Any] = {},\n    token: Optional[Dict[str, Any]] = None,\n) -> bytes:\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    # Construct the signing key\n    # It is the percent-encoded consumer secret + '&' + percent-encoded token secret (if any)\n    key = _oauth_escape(consumer_token['secret']) + '&'\n    if token and 'secret' in token:\n        key += _oauth_escape(token['secret'])\n\n    # Normalize the URL: scheme and authority lowercased, no query or fragment\n    parsed_url = urllib.parse.urlparse(url)\n    scheme = parsed_url.scheme.lower()\n    netloc = parsed_url.netloc.lower()\n    # Strip port if default for scheme\n    if (scheme == \"http\" and netloc.endswith(\":80\")):\n        netloc = netloc[:-3]\n    elif (scheme == \"https\" and netloc.endswith(\":443\")):\n        netloc = netloc[:-4]\n    normalized_url = f\"{scheme}://{netloc}{parsed_url.path or '/'}\"\n\n    # Normalize and encode parameters:\n    # Include all query parameters from URL plus parameters passed as argument\n    # Flatten parameters (in case of lists)\n    params = []\n\n    # Extract query parameters from URL\n    query_params = urllib.parse.parse_qs(parsed_url.query, keep_blank_values=True)\n    for k, vs in query_params.items():\n        for v in vs:\n            params.append((k, v))\n\n    # Add passed parameters\n    for k, v in parameters.items():\n        if isinstance(v, (list, tuple)):\n            for item in v:\n                params.append((str(k), str(item)))\n        else:\n            params.append((str(k), str(v)))\n\n    # Percent encode parameters key and value\n    encoded_params = [(_oauth_escape(k), _oauth_escape(v)) for k, v in params]\n    # Sort parameters first by key, then by value\n    encoded_params.sort()\n\n    # Construct parameter string key=value&key=value...\n    param_string = \"&\".join(f\"{k}={v}\" for k, v in encoded_params)\n\n    # Build the signature base string\n    base_elems = [method.upper(), _oauth_escape(normalized_url), _oauth_escape(param_string)]\n    base_string = \"&\".join(base_elems)\n\n    # Compute HMAC-SHA1 signature\n    hashed = hmac.new(key.encode('utf-8'), base_string.encode('utf-8'), hashlib.sha1)\n    return hashed.digest()", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1214, in <module>\n  File \"<string>\", line 1207, in test_0\nAssertionError\n", "passed": false}
