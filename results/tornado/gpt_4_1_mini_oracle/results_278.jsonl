{"task_id": 278, "prediction_id": 0, "generation": "import re\nimport urllib.parse\nfrom typing import Tuple, Dict\n\ndef _parse_header(line: str) -> Tuple[str, Dict[str, str]]:\n    r\"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    >>> d = \"form-data; foo=\\\"b\\\\\\\\a\\\\\\\"r\\\"; file*=utf-8''T%C3%A4st\"\n    >>> ct, d = _parse_header(d)\n    >>> ct\n    'form-data'\n    >>> d['file'] == r'T\\u00e4st'.encode('ascii').decode('unicode_escape')\n    True\n    >>> d['foo']\n    'b\\\\a\"r'\n    \"\"\"\n    def unquote(value: str) -> str:\n        # Remove surrounding quotes if present and unescape \\\" and \\\\ inside\n        if len(value) >= 2 and value[0] == '\"' and value[-1] == '\"':\n            value = value[1:-1]\n            # Replace escaped quotes and backslashes\n            value = value.replace(r'\\\"', '\"').replace(r'\\\\', '\\\\')\n        return value\n\n    params = {}  # type: Dict[str, str]\n\n    # Split the line into parts separated by \";\"\n    # The first part is the main content-type; others are parameters\n    parts = line.split(\";\", 1)\n    main_value = parts[0].strip().lower() if parts else \"\"\n    rest = parts[1] if len(parts) > 1 else \"\"\n\n    # For parsing parameters correctly (handling quoted sections), use _parseparam logic here:\n    # I re-implement here instead of importing since only _parseparam code is in context.\n\n    s = rest\n    while s[:1] == \";\":\n        s = s[1:]\n        end = s.find(\";\")\n        while end > 0 and (s.count('\"', 0, end) - s.count('\\\\\"', 0, end)) % 2:\n            end = s.find(\";\", end + 1)\n        if end < 0:\n            end = len(s)\n        f = s[:end].strip()\n        s = s[end:]\n\n        if not f:\n            continue\n        if '=' in f:\n            key, val = f.split(\"=\", 1)\n            key = key.strip().lower()\n            val = val.strip()\n        else:\n            key = f.strip().lower()\n            val = \"\"\n\n        # Handle RFC 2231/5987 encoded parameters: key*=charset'lang'value\n        if key.endswith(\"*\"):\n            key = key[:-1]\n\n            # The val format: charset'lang'%xx...\n            # e.g. utf-8''T%C3%A4st\n            m = re.match(r\"^([^']*)'[^']*'(.*)\", val)\n            if m:\n                charset, encoded_value = m.group(1), m.group(2)\n                try:\n                    decoded_bytes = urllib.parse.unquote_to_bytes(encoded_value)\n                    val = decoded_bytes.decode(charset or \"utf-8\")\n                except (LookupError, UnicodeDecodeError):\n                    # If any error, fallback to original string\n                    val = urllib.parse.unquote(encoded_value)\n            else:\n                val = urllib.parse.unquote(val)\n\n        else:\n            val = unquote(val)\n\n        params[key] = val\n\n    return main_value, params", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1185, in <module>\n  File \"<string>\", line 1184, in test_0\nAssertionError\n", "passed": false}
{"task_id": 278, "prediction_id": 1, "generation": "from typing import Tuple, Dict\nfrom urllib.parse import unquote\n\ndef _parse_header(line: str) -> Tuple[str, Dict[str, str]]:\n    r\"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    >>> d = \"form-data; foo=\\\"b\\\\\\\\a\\\\\\\"r\\\"; file*=utf-8''T%C3%A4st\"\n    >>> ct, d = _parse_header(d)\n    >>> ct\n    'form-data'\n    >>> d['file'] == r'T\\u00e4st'.encode('ascii').decode('unicode_escape')\n    True\n    >>> d['foo']\n    'b\\\\a\"r'\n    \"\"\"\n    def _unquote(value: str) -> str:\n        \"\"\"Remove surrounding quotes and unescape quoted pairs.\"\"\"\n        if len(value) >= 2 and value[0] == '\"' and value[-1] == '\"':\n            value = value[1:-1]\n            # Unescape \\\" and \\\\ inside the quoted string\n            value = value.replace(r'\\\"', '\"').replace(r'\\\\', '\\\\')\n        return value\n\n    params = {}\n    # Split out main content-type from parameters\n    parts = line.split(\";\", 1)\n    main_value = parts[0].strip().lower()\n    rest = parts[1] if len(parts) > 1 else \"\"\n\n    # We will keep track of RFC 2231 encoded parameters to decode after parsing\n    rfc2231_params = {}\n\n    # Use the provided _parseparam generator adapted here (copied from context)\n    s = rest\n    while s[:1] == \";\":\n        s = s[1:]\n        end = s.find(\";\")\n        while end > 0 and (s.count('\"', 0, end) - s.count('\\\\\"', 0, end)) % 2:\n            end = s.find(\";\", end + 1)\n        if end < 0:\n            end = len(s)\n        f = s[:end].strip()\n        s = s[end:]\n        if not f:\n            continue\n        # Parse each param (key[=value])\n        if \"=\" not in f:\n            # valueless parameter\n            k = f.lower()\n            params[k] = \"\"\n            continue\n        k, v = f.split(\"=\", 1)\n        k = k.strip().lower()\n        v = v.strip()\n\n        # Handle RFC 2231 encoded parameters: key*=\n        # Example: filename*=utf-8''filename.ext or filename*0*=...\n        # We support only simple RFC 2231: key*=\n        if k.endswith(\"*\"):\n            # RFC 2231 format: charset'lang'value (lang is optional)\n            v_parts = v.split(\"'\", 2)\n            if len(v_parts) == 3:\n                charset, lang, encoded_text = v_parts\n                try:\n                    decoded = unquote(encoded_text, encoding=charset, errors='strict')\n                except (LookupError, UnicodeDecodeError):\n                    # fallback to utf-8 without strict decoding\n                    decoded = unquote(encoded_text)\n                rfc2231_params[k[:-1]] = decoded\n            else:\n                # Malformed, treat as normal value with unquote\n                params[k[:-1]] = unquote(v)\n        else:\n            # Normal parameter - remove quotes and unescape\n            v = _unquote(v)\n            params[k] = v\n\n    # Update params with any decoded RFC 2231 params (overwrites normal)\n    params.update(rfc2231_params)\n\n    return main_value, params", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1186, in <module>\n  File \"<string>\", line 1185, in test_0\nAssertionError\n", "passed": false}
{"task_id": 278, "prediction_id": 2, "generation": "import urllib.parse\nfrom typing import Tuple, Dict\n\n\ndef _parse_header(line: str) -> Tuple[str, Dict[str, str]]:\n    r\"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    >>> d = \"form-data; foo=\\\"b\\\\\\\\a\\\\\\\"r\\\"; file*=utf-8''T%C3%A4st\"\n    >>> ct, d = _parse_header(d)\n    >>> ct\n    'form-data'\n    >>> d['file'] == r'T\\u00e4st'.encode('ascii').decode('unicode_escape')\n    True\n    >>> d['foo']\n    'b\\\\a\"r'\n    \"\"\"\n    def _unquote(value: str) -> str:\n        \"\"\"Remove surrounding quotes and unescape quoted-pair inside quoted string.\"\"\"\n        if len(value) >= 2 and value[0] == value[-1] == '\"':\n            # Remove surrounding quotes\n            value = value[1:-1]\n            # Unescape \\\" and \\\\ inside the quoted string\n            value = value.replace(r'\\\"', '\"').replace(r'\\\\', '\\\\')\n        return value\n\n    def _decode_rfc2231(value: str) -> str:\n        \"\"\"Decode RFC 2231/5987 encoded string of form charset'lang'%XX%XX.\"\"\"\n        # Format: charset'lang'%xx%xx ...\n        parts = value.split(\"'\", 2)\n        if len(parts) == 3:\n            charset, lang, encoded = parts\n            # Percent decode\n            try:\n                decoded_bytes = urllib.parse.unquote_to_bytes(encoded)\n                # Decode with charset\n                return decoded_bytes.decode(charset, errors='replace')\n            except Exception:\n                # If decode fails, fallback to raw value\n                return value\n        return value\n\n    parts = line.split(\";\", 1)\n    main_value = parts[0].strip().lower()\n    params_str = parts[1] if len(parts) == 2 else \"\"\n\n    params: Dict[str, str] = {}\n\n    # Use _parseparam generator from context to get individual param strings\n    # Re-define _parseparam here as per context function (for self-contained code)\n    def _parseparam(s: str):\n        while s[:1] == \";\":\n            s = s[1:]\n            end = s.find(\";\")\n            while end > 0 and (s.count('\"', 0, end) - s.count('\\\\\"', 0, end)) % 2:\n                end = s.find(\";\", end + 1)\n            if end < 0:\n                end = len(s)\n            f = s[:end]\n            yield f.strip()\n            s = s[end:]\n\n    for param in _parseparam(\";\" + params_str):\n        if '=' in param:\n            name, value = param.split(\"=\", 1)\n            name = name.strip().lower()\n            value = value.strip()\n            if name.endswith('*'):\n                # RFC 2231/5987 encoding: decode the value\n                decoded_value = _decode_rfc2231(value)\n                name = name[:-1]  # Remove trailing '*'\n                params[name] = decoded_value\n            else:\n                # Normal value, possibly quoted-string with escapes\n                params[name] = _unquote(value)\n        else:\n            # valueless param, set empty string\n            params[param.lower()] = \"\"\n\n    return main_value, params", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1208, in <module>\n  File \"<string>\", line 1207, in test_8\nAssertionError\n", "passed": false}
{"task_id": 278, "prediction_id": 3, "generation": "import re\nfrom typing import Tuple, Dict\n\ndef _parse_header(line: str) -> Tuple[str, Dict[str, str]]:\n    r\"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    >>> d = \"form-data; foo=\\\"b\\\\\\\\a\\\\\\\"r\\\"; file*=utf-8''T%C3%A4st\"\n    >>> ct, d = _parse_header(d)\n    >>> ct\n    'form-data'\n    >>> d['file'] == r'T\\u00e4st'.encode('ascii').decode('unicode_escape')\n    True\n    >>> d['foo']\n    'b\\\\a\"r'\n    \"\"\"\n    # Helper generator to yield parameters from the line (context function)\n    def _parseparam(s: str):\n        while s[:1] == \";\":\n            s = s[1:]\n            end = s.find(\";\")\n            while end > 0 and (s.count('\"', 0, end) - s.count('\\\\\"', 0, end)) % 2:\n                end = s.find(\";\", end + 1)\n            if end < 0:\n                end = len(s)\n            f = s[:end]\n            yield f.strip()\n            s = s[end:]\n\n    main_value = \"\"\n    options = {}\n\n    if not line:\n        return main_value, options\n\n    parts = line.split(\";\", 1)\n    main_value = parts[0].strip().lower()  # lowercase main content type per convention\n    rest = \";\" + parts[1] if len(parts) > 1 else \"\"\n\n    # Regular expression for RFC 5987 encoding detection (e.g., file*=utf-8''...)\n    rfc5987_re = re.compile(r\"^([^\\*]+)\\*((?:\\*|\\d+)*)$\")  # param name with possible * or number suffix\n\n    # Temporary dict to hold encoded parameters (for possible continuation and encoding)\n    encoded_params = {}\n\n    for param in _parseparam(rest):\n        if not param:\n            continue\n        if \"=\" not in param:\n            # valueless attribute\n            key = param.strip().lower()\n            options[key] = \"\"\n            continue\n        key, val = param.split(\"=\", 1)\n        key = key.strip().lower()\n        val = val.strip()\n\n        # Remove outer quotes if any\n        if len(val) >= 2 and val[0] == val[-1] == '\"':\n            val = val[1:-1]\n            # Unescape \\\" and \\\\ inside quoted string\n            val = val.replace(r'\\\"', '\"').replace(r\"\\\\\", \"\\\\\")\n\n        # Check for RFC 5987 encoding/extensions (key ends with '*')\n        if key.endswith(\"*\"):\n            # RFC 5987 style encoding: e.g. filename*=utf-8''... or filename*0*=...\n            # We handle only the simplest form with a charset and percent encoded:\n            # Also support extended notation filename*0*, filename*1*, which can be joined\n\n            # Parse charset'lang'value form\n            # Example: filename*=utf-8''T%C3%A4st\n            # or filename*0*=some part\n            # or normal param continuation filename*0=value, filename*1=value2\n\n            base_key = key[:-1]\n            # Detect continuation indices e.g. filename*0, filename*1\n            cont_match = re.match(r\"^([\\w\\-]+)\\*(\\d+)(\\*)?$\", key)\n            if cont_match:\n                bkey, index, star = cont_match.groups()\n                if bkey not in encoded_params:\n                    encoded_params[bkey] = {}\n                encoded_params[bkey][int(index)] = val\n                continue\n\n            # Simple RFC 5987 encoded value\n            # val format: charset'lang'%encoded_val\n            charset_lang_val = val.split(\"'\", 2)\n            if len(charset_lang_val) == 3:\n                charset, lang, encoded_val = charset_lang_val\n                try:\n                    # Percent decode first\n                    from urllib.parse import unquote\n                    byte_str = unquote(encoded_val, encoding=charset, errors='strict')\n                    options[base_key] = byte_str\n                except Exception:\n                    # If decoding fails, fallback to original val without decoding\n                    options[base_key] = val\n            else:\n                # If split invalid, fallback to original\n                options[base_key] = val\n        else:\n            # Normal parameter\n            options[key] = val\n\n    # Now handle continuation encoded params by joining parts ordered by index\n    for key, parts_dict in encoded_params.items():\n        try:\n            # Join parts in order\n            joined = \"\".join(parts_dict[i] for i in sorted(parts_dict))\n            # RFC 5987 style with charset? Unclear if it can have charset here but unquote anyway\n            # The joined value might be quoted? Remove quotes if exist\n            if len(joined) >= 2 and joined[0] == joined[-1] == '\"':\n                joined = joined[1:-1]\n                joined = joined.replace(r'\\\"', '\"').replace(r\"\\\\\", \"\\\\\")\n\n            # Percent decode utf-8 by default, fallback silently to ascii for safety\n            from urllib.parse import unquote\n            decoded = unquote(joined)\n            options[key] = decoded\n        except Exception:\n            # On error, fallback to joined as is\n            options[key] = joined\n\n    return main_value, options", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1529, in <module>\n  File \"<string>\", line 1528, in test_28\nAssertionError\n", "passed": false}
{"task_id": 278, "prediction_id": 4, "generation": "import urllib.parse\nfrom typing import Tuple, Dict\n\ndef _parse_header(line: str) -> Tuple[str, Dict[str, str]]:\n    r\"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    >>> d = \"form-data; foo=\\\"b\\\\\\\\a\\\\\\\"r\\\"; file*=utf-8''T%C3%A4st\"\n    >>> ct, d = _parse_header(d)\n    >>> ct\n    'form-data'\n    >>> d['file'] == r'T\\u00e4st'.encode('ascii').decode('unicode_escape')\n    True\n    >>> d['foo']\n    'b\\\\a\"r'\n    \"\"\"\n\n    def _unquote(value: str) -> str:\n        # Unquote a quoted string, handling backslash escapes.\n        if len(value) >= 2 and value[0] == value[-1] == '\"':\n            value = value[1:-1]\n            result = []\n            i = 0\n            while i < len(value):\n                if value[i] == \"\\\\\" and i + 1 < len(value):\n                    result.append(value[i + 1])\n                    i += 2\n                else:\n                    result.append(value[i])\n                    i += 1\n            return \"\".join(result)\n        else:\n            return value\n\n    def _decode_rfc2231(value: str) -> str:\n        # RFC2231 format: charset'lang'%xx%yy...\n        # format: charset'language'urlencoded-text\n        try:\n            charset, lang, text = value.split(\"'\", 2)\n        except ValueError:\n            return value  # Malformed, return as is\n        # unquote percent encoding and decode using charset\n        decoded_bytes = urllib.parse.unquote_to_bytes(text)\n        try:\n            return decoded_bytes.decode(charset, \"strict\")\n        except Exception:\n            # If decoding fails, fallback to latin-1 to avoid crashing\n            return decoded_bytes.decode(\"latin-1\", \"replace\")\n\n    # Split the entire header line into main value and parameters\n    # The first token before any semicolon is the main content-type\n    parts = line.split(\";\", 1)\n    main_value = parts[0].strip().lower()  # Content types are case-insensitive, lowercase for consistency\n    params: Dict[str, str] = {}\n\n    if len(parts) == 2:\n        param_str = parts[1]\n        for param in _parseparam(param_str):\n            if not param:\n                continue\n            if \"=\" not in param:\n                # Valueless parameter\n                key = param.strip().lower()\n                params[key] = \"\"\n                continue\n            key, val = param.split(\"=\", 1)\n            key = key.strip().lower()\n            val = val.strip()\n\n            # Handle RFC2231 encoded parameters (key*=)\n            if key.endswith(\"*\"):\n                key_base = key[:-1]\n                # Decode RFC2231 value\n                decoded_val = _decode_rfc2231(val)\n                params[key_base] = decoded_val\n            else:\n                # Unquote quoted-string values\n                val = _unquote(val)\n                params[key] = val\n\n    return main_value, params", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1185, in <module>\n  File \"<string>\", line 1184, in test_0\nAssertionError\n", "passed": false}
