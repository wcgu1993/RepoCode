{"task_id": 244, "prediction_id": 0, "generation": "from typing import Union, List, Dict, Any, Type, Tuple\nfrom tornado.concurrent import Future, is_future, future_add_done_callback, future_set_exc_info, future_set_result_unless_cancelled\nfrom tornado.gen import _create_future\n\n_Yieldable = Union[\n    None,  # for yield None\n    Future,\n    List[Future],\n    Dict[Any, Future],\n]\n\n\ndef multi_future(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> \"Union[Future[List], Future[Dict]]\":\n    \"\"\"Wait for multiple asynchronous futures in parallel.\n\n    Since Tornado 6.0, this function is exactly the same as `multi`.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.2\n    If multiple ``Futures`` fail, any exceptions after the first (which is\n    raised) will be logged. Added the ``quiet_exceptions``\n    argument to suppress this logging for selected exception types.\n\n    .. deprecated:: 4.3\n    Use `multi` instead.\n    \"\"\"\n    if not children:\n        # If empty list or dict, return an immediately done Future with empty container\n        future = _create_future()\n        future_set_result_unless_cancelled(future, children)\n        return future\n\n    # Distinguish between list and dict types for result container\n    is_dict = isinstance(children, dict)\n    # Prepare keys and futures in order\n    if is_dict:\n        keys = list(children.keys())\n        futures = [children[k] for k in keys]\n    else:\n        keys = None\n        futures = list(children)\n\n    # Validate all are Futures or yieldables convertible to Futures\n    for f in futures:\n        if not (is_future(f)):\n            raise ValueError(\"multi_future children must be Futures\")\n\n    result_future = _create_future()\n    results = {} if is_dict else [None] * len(futures)\n    finished = [False] * len(futures)\n\n    # Track the first exception and whether the main future is done\n    done = False\n    fatal_exc = None\n\n    # Helper to check if an exception is quiet\n    def is_quiet(exc: Exception) -> bool:\n        if quiet_exceptions == ():\n            return False\n        if isinstance(quiet_exceptions, tuple):\n            return any(isinstance(exc, ex) for ex in quiet_exceptions)\n        return isinstance(exc, quiet_exceptions)\n\n    def callback(idx: int, f: Future) -> None:\n        nonlocal done, fatal_exc\n        if done:\n            # Already finished; just log if exception and not quiet\n            if f.exception() and not is_quiet(f.exception()):\n                import logging\n\n                logging.error(\"Exception ignored in multi_future child %d: %s\", idx, f.exception(), exc_info=True)\n            return\n\n        if f.cancelled():\n            # Cancel the main future too\n            done = True\n            result_future.cancel()\n            return\n\n        exc = f.exception()\n        if exc is not None:\n            if fatal_exc is None:\n                fatal_exc = exc\n                done = True\n                # Set exception on main future\n                future_set_exc_info(result_future, (type(exc), exc, exc.__traceback__))\n            else:\n                # Log additional exceptions except quiet ones\n                if not is_quiet(exc):\n                    import logging\n\n                    logging.error(\"Multiple exceptions in multi_future; ignoring: %s\", exc, exc_info=True)\n            return\n        else:\n            # Successful result\n            try:\n                res = f.result()\n            except Exception as e:\n                # Defensive - if calling result() raises here, treat as exception\n                if fatal_exc is None:\n                    fatal_exc = e\n                    done = True\n                    future_set_exc_info(result_future, (type(e), e, e.__traceback__))\n                else:\n                    if not is_quiet(e):\n                        import logging\n\n                        logging.error(\"Multiple exceptions in multi_future; ignoring: %s\", e, exc_info=True)\n                return\n\n            results[idx] = res\n            finished[idx] = True\n\n            if all(finished) and not done:\n                done = True\n                future_set_result_unless_cancelled(result_future, results)\n\n    for index, fut in enumerate(futures):\n        future_add_done_callback(fut, lambda f, idx=index: callback(idx, f))\n\n    return result_future", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 901, in <module>\n  File \"<string>\", line 895, in test_33\n  File \"<string>\", line 493, in multi_future\nValueError: multi_future children must be Futures\n", "passed": false}
{"task_id": 244, "prediction_id": 1, "generation": "from typing import Union, List, Dict, Any, Type, Tuple\nfrom tornado.concurrent import Future, is_future, future_add_done_callback, future_set_exc_info, future_set_result_unless_cancelled\nfrom tornado.gen import _create_future, convert_yielded\nimport sys\nimport collections\nimport logging\n\ndef multi_future(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> \"Union[Future[List], Future[Dict]]\":\n    \"\"\"Wait for multiple asynchronous futures in parallel.\n\n    Since Tornado 6.0, this function is exactly the same as `multi`.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.2\n    If multiple ``Futures`` fail, any exceptions after the first (which is\n    raised) will be logged. Added the ``quiet_exceptions``\n    argument to suppress this logging for selected exception types.\n\n    .. deprecated:: 4.3\n    Use `multi` instead.\n    \"\"\"\n    logger = logging.getLogger('tornado.gen.multi_future')\n\n    if not children:\n        # Return a resolved Future with an empty structure matching input type\n        future = _create_future()\n        if isinstance(children, dict):\n            future_set_result_unless_cancelled(future, {})\n        else:\n            future_set_result_unless_cancelled(future, [])\n        return future\n\n    # Determine if children is dict or list\n    is_dict = isinstance(children, dict)\n\n    # Dictionary to map Futures to their keys/indexes\n    if is_dict:\n        keys = list(children.keys())\n        yieldables = list(children.values())\n    else:\n        yieldables = children\n\n    # Convert all children to Futures\n    try:\n        futures = [convert_yielded(y) for y in yieldables]\n    except Exception as e:\n        future = _create_future()\n        future_set_exc_info(future, sys.exc_info())\n        return future\n\n    result_future = _create_future()\n\n    # Store results in container with same type as children\n    if is_dict:\n        results = {}  # type: Dict[Any, Any]\n    else:\n        results = [None] * len(futures)  # type: List[Any]\n\n    # Track unfinished futures: future -> key or index\n    unfinished = dict(zip(futures, keys if is_dict else range(len(futures))))\n\n    first_error = [None]  # Will hold the first exception raised\n\n    completed_count = [0]  # Number of futures completed\n\n    def _done_callback(f: Future) -> None:\n        nonlocal result_future\n\n        if result_future.done():\n            return  # Already finished due to error or cancellation\n\n        key = unfinished.pop(f, None)\n\n        try:\n            res = f.result()\n        except Exception as exc:\n            # If first error not set, set it and set exc on result_future\n            if first_error[0] is None:\n                first_error[0] = exc\n                exc_type, exc_value, exc_tb = sys.exc_info()\n                future_set_exc_info(result_future, (exc_type, exc_value, exc_tb))\n            else:\n                # Subsequent errors: log unless they're quiet exceptions\n                if not isinstance(exc, quiet_exceptions):\n                    logger.error(\"Multiple exceptions in multi_future after first:\", exc_info=True)\n            return\n\n        # Store the result\n        if is_dict:\n            results[key] = res  # type: ignore\n        else:\n            results[key] = res  # type: ignore\n\n        completed_count[0] += 1\n\n        # If all finished without error, set the results on the result_future\n        if not unfinished and not result_future.done():\n            future_set_result_unless_cancelled(result_future, results)\n\n    for fut in futures:\n        future_add_done_callback(fut, _done_callback)\n\n    return result_future", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 891, in <module>\n  File \"<string>\", line 888, in test_38\nAssertionError\n", "passed": false}
{"task_id": 244, "prediction_id": 2, "generation": "import collections\nimport sys\nimport traceback\nimport typing\nfrom typing import Union, Any, Callable, List, Type, Tuple, Awaitable, Dict\n\nfrom tornado.concurrent import Future, is_future, future_set_exc_info, future_set_result_unless_cancelled, future_add_done_callback\nfrom tornado.gen import _create_future\n\n_Yieldable = Union[\n    None, Awaitable, List[Awaitable], Dict[Any, Awaitable], typing.Any  # loosely typed for compatibility\n]\n\n\ndef multi_future(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> \"Union[Future[List], Future[Dict]]\":\n    \"\"\"Wait for multiple asynchronous futures in parallel.\n\n    Since Tornado 6.0, this function is exactly the same as `multi`.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.2\n    If multiple ``Futures`` fail, any exceptions after the first (which is\n    raised) will be logged. Added the ``quiet_exceptions``\n    argument to suppress this logging for selected exception types.\n\n    .. deprecated:: 4.3\n    Use `multi` instead.\n    \"\"\"\n    future = _create_future()\n\n    # Normalize quiet_exceptions to a tuple for isinstance checks\n    if isinstance(quiet_exceptions, type) and issubclass(quiet_exceptions, Exception):\n        quiet_exceptions = (quiet_exceptions,)\n    elif not isinstance(quiet_exceptions, tuple):\n        quiet_exceptions = tuple(quiet_exceptions)\n\n    # Detect whether children is list or dict\n    is_dict = isinstance(children, dict)\n\n    # We will store keys and corresponding futures\n    keys = list(children.keys()) if is_dict else list(range(len(children)))\n    futures = list(children.values()) if is_dict else list(children)\n\n    # Edge case: empty children\n    if not keys:\n        # Immediately resolve to empty structure\n        future_set_result_unless_cancelled(future, {} if is_dict else [])\n        return future\n\n    # State for tracking completion and errors\n    results = {} if is_dict else [None] * len(futures)\n    finished_futures = 0\n    first_exc_info = None\n    logged_exceptions = []  # list of (exc_info, traceback_str) after the first\n\n    def _on_future_done(done_future: Future, idx: int) -> None:\n        nonlocal finished_futures, first_exc_info\n\n        try:\n            result = done_future.result()\n        except Exception:\n            exc_info = sys.exc_info()\n\n            if first_exc_info is None:\n                # Save first exception info and set it in the returned future\n                first_exc_info = exc_info\n                # Set the exception on the main future immediately\n                future_set_exc_info(future, exc_info)\n            else:\n                # Subsequent exceptions: decide whether to log or suppress\n                ex_type = exc_info[0]\n                if ex_type is not None and not issubclass(ex_type, quiet_exceptions):\n                    try:\n                        tb_str = ''.join(traceback.format_exception(*exc_info))\n                    except Exception:\n                        tb_str = \"Could not format traceback for exception: %r\" % (exc_info[1],)\n                    logged_exceptions.append((exc_info, tb_str))\n                    # Log asynchronously to avoid side effects here\n                    # Use app_log.error if available else print to stderr\n                    try:\n                        from tornado.log import app_log\n                        for _, s in logged_exceptions:\n                            app_log.error(\"multiple exceptions raised in multi_future child (logging subsequent):\\n%s\", s)\n                    except ImportError:\n                        for _, s in logged_exceptions:\n                            print(\"multiple exceptions raised in multi_future child (logging subsequent):\\n%s\" % s, file=sys.stderr)\n\n            # Store a placeholder None or could omit the result on exception\n            results[keys[idx]] = None\n        else:\n            results[keys[idx]] = result\n\n        finished_futures += 1\n\n        if finished_futures == len(futures):\n            # All done, if no exception was set earlier, set the results\n            if first_exc_info is None:\n                future_set_result_unless_cancelled(future, results if is_dict else list(results))\n            # else: future already set with exception\n\n    # Add done callbacks to all futures\n    for idx, f in enumerate(futures):\n        # Defensive: convert to future if needed\n        if not is_future(f):\n            # This case shouldn't be common here, but just in case\n            raise Exception(\"multi_future expects Futures or yieldables already converted\")\n        # To ensure immediate callback if done\n        def make_callback(index: int) -> Callable[[Future], None]:\n            return lambda fut: _on_future_done(fut, index)\n\n        future_add_done_callback(f, make_callback(idx))\n\n    return future", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 893, in <module>\n  File \"<string>\", line 887, in test_33\n  File \"<string>\", line 553, in multi_future\nException: multi_future expects Futures or yieldables already converted\n", "passed": false}
{"task_id": 244, "prediction_id": 3, "generation": "import collections\nimport logging\nfrom typing import Any, Union, List, Dict, Type, Tuple\n\nfrom tornado.concurrent import Future, is_future, future_set_exc_info, future_set_result_unless_cancelled, future_add_done_callback\nfrom tornado.gen import _create_future\n\ndef multi_future(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> \"Union[Future[List], Future[Dict]]\":\n    \"\"\"Wait for multiple asynchronous futures in parallel.\n\n    Since Tornado 6.0, this function is exactly the same as `multi`.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.2\n    If multiple ``Futures`` fail, any exceptions after the first (which is\n    raised) will be logged. Added the ``quiet_exceptions``\n    argument to suppress this logging for selected exception types.\n\n    .. deprecated:: 4.3\n    Use `multi` instead.\n    \"\"\"\n    if not children:\n        # If children is empty list or dict, return immediately a future with same structure.\n        fut = _create_future()\n        result = children if isinstance(children, dict) else []\n        future_set_result_unless_cancelled(fut, result)\n        return fut\n\n    is_dict = isinstance(children, dict)\n    # Keys and futures extraction\n    if is_dict:\n        keys = list(children.keys())\n        futures = list(children.values())\n    else:\n        keys = list(range(len(children)))\n        futures = list(children)\n\n    # Create result storage container\n    results = {} if is_dict else [None] * len(futures)\n    result_future = _create_future()\n\n    # Track completion and exceptions\n    done_count = 0\n    first_exception = None\n    logged_exceptions = set()\n\n    # Internal callback for each future\n    def _on_future_done(fut: Future, index: int) -> None:\n        nonlocal done_count, first_exception\n\n        try:\n            res = fut.result()\n        except Exception as e:\n            if first_exception is None:\n                first_exception = e\n                # Set exception on the overall future immediately\n                future_set_exc_info(result_future, (type(e), e, e.__traceback__))\n            else:\n                # Suppress logging for quiet exceptions, log others\n                if not isinstance(e, quiet_exceptions):\n                    # Avoid logging the same exception multiple times\n                    exc_key = (type(e), str(e))\n                    if exc_key not in logged_exceptions:\n                        logged_exceptions.add(exc_key)\n                        logging.error(\"Exception in multi_future child future\", exc_info=True)\n\n            # Store None or omit storing results for failed future (results lost as per doc)\n            # So don't store any result for futures that raised\n        else:\n            results[keys[index]] = res\n\n            # If first_exception occurred before, we don't overwrite the future's exception\n            # The caller will get the first exception raised.\n\n        done_count += 1\n        # When all futures are done, if there was no exception, set the result\n        if done_count == len(futures):\n            if first_exception is None:\n                future_set_result_unless_cancelled(result_future, results)\n            # Else result_future was already set with exception, nothing more to do\n\n    for idx, fut in enumerate(futures):\n        if not is_future(fut):\n            # Defensive: convert to Future if necessary - but spec expects _Yieldable which can be various types\n            # For safety, wrap with tornado.gen.convert_yielded if available?\n            # But based on context this function expects Futures, so it is caller's responsibility.\n            raise TypeError(f\"multi_future expects futures or yieldables that are Futures, got {type(fut)}\")\n        future_add_done_callback(fut, lambda f, i=idx: _on_future_done(f, i))\n\n    return result_future", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 870, in <module>\n  File \"<string>\", line 864, in test_33\n  File \"<string>\", line 534, in multi_future\nTypeError: multi_future expects futures or yieldables that are Futures, got <class 'NoneType'>\n", "passed": false}
{"task_id": 244, "prediction_id": 4, "generation": "from typing import Union, List, Dict, Any, Type, Tuple\nfrom tornado.concurrent import Future, is_future, future_add_done_callback, future_set_exc_info, future_set_result_unless_cancelled\nfrom tornado.gen import _create_future\nimport collections\nimport sys\nimport logging\n\n# Use the app_log from tornado.log for logging errors\nfrom tornado.log import app_log\n\n\ndef multi_future(\n    children: Union[List[_Yieldable], Dict[Any, _Yieldable]],\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> \"Union[Future[List], Future[Dict]]\":\n    \"\"\"Wait for multiple asynchronous futures in parallel.\n\n    Since Tornado 6.0, this function is exactly the same as `multi`.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.2\n    If multiple ``Futures`` fail, any exceptions after the first (which is\n    raised) will be logged. Added the ``quiet_exceptions``\n    argument to suppress this logging for selected exception types.\n\n    .. deprecated:: 4.3\n    Use `multi` instead.\n    \"\"\"\n    if isinstance(children, dict):\n        keys = list(children.keys())\n        futures = list(children.values())\n        is_dict = True\n    else:\n        futures = list(children)\n        keys = None\n        is_dict = False\n\n    # Validate all are Future or yieldable converted to Future\n    # (Note: in gen module, yielding a list/dict auto-converts children)\n    # But here we assume already Futures or yieldable handled by the caller\n\n    # Create the aggregate future that will be returned\n    future = _create_future()\n\n    total = len(futures)\n    if total == 0:\n        # No futures: immediately set result to empty list/dict\n        if is_dict:\n            future_set_result_unless_cancelled(future, {})\n        else:\n            future_set_result_unless_cancelled(future, [])\n        return future\n\n    results = [None] * total  # type: List[Any]\n    done_count = 0\n    raised = False\n    raised_exc_info = None\n\n    # To track order of exceptions\n    logged_exc_info = None\n\n    def _handle_done(i: int, f: Future) -> None:\n        nonlocal done_count, raised, raised_exc_info\n\n        if future.done():\n            # If the aggregate future already done, ignore further results\n            return\n\n        try:\n            res = f.result()\n        except Exception:\n            exc_info = sys.exc_info()\n            if not raised:\n                # First exception: set exception on aggregate future\n                raised = True\n                raised_exc_info = exc_info\n                future_set_exc_info(future, exc_info)\n            else:\n                # Subsequent exceptions: log unless quiet_exceptions\n                etype = exc_info[0]\n                if not quiet_exceptions:\n                    to_log = True\n                elif isinstance(quiet_exceptions, tuple):\n                    to_log = not any(issubclass(etype, qe) for qe in quiet_exceptions)\n                else:\n                    to_log = not issubclass(etype, quiet_exceptions)\n                if to_log:\n                    app_log.error(\n                        \"Exception in child future after first failure\",\n                        exc_info=exc_info,\n                    )\n            return\n        else:\n            results[i] = res\n            done_count += 1\n            if done_count == total and not raised:\n                # All done successfully\n                if is_dict:\n                    result_dict = dict(zip(keys, results))\n                    future_set_result_unless_cancelled(future, result_dict)\n                else:\n                    future_set_result_unless_cancelled(future, results)\n\n    for idx, child_future in enumerate(futures):\n        # Defensive: if something is not a Future, convert to one\n        if not is_future(child_future):\n            raise TypeError(\"multi_future expects all items to be Future instances\")\n        # Add done callbacks with closure of index\n        def make_callback(i):\n            return lambda f: _handle_done(i, f)\n        future_add_done_callback(child_future, make_callback(idx))\n\n    return future", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 890, in <module>\n  File \"<string>\", line 884, in test_33\n  File \"<string>\", line 551, in multi_future\nTypeError: multi_future expects all items to be Future instances\n", "passed": false}
