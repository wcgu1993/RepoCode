{"task_id": 272, "prediction_id": 0, "generation": "from typing import Union, Dict, List, Tuple\nfrom urllib.parse import urlparse, urlunparse, parse_qsl, urlencode\n\n\ndef url_concat(\n    url: str,\n    args: Union[\n        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]\n    ],\n) -> str:\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if not args:\n        return url\n\n    parsed = urlparse(url)\n    # parse existing query parameters preserving duplicates\n    query_params = parse_qsl(parsed.query, keep_blank_values=True)\n\n    # If args is dict, convert to list of tuples for consistent processing\n    if isinstance(args, dict):\n        new_params = list(args.items())\n    else:\n        new_params = list(args)\n\n    # Combine existing and new parameters\n    combined_params = query_params + new_params\n\n    # Encode combined parameters preserving duplicates and order\n    new_query = urlencode(combined_params, doseq=True)\n\n    # Rebuild URL with new query string\n    new_url = urlunparse(\n        (\n            parsed.scheme,\n            parsed.netloc,\n            parsed.path,\n            parsed.params,\n            new_query,\n            parsed.fragment,\n        )\n    )\n    return new_url", "message": "passed", "passed": true}
{"task_id": 272, "prediction_id": 1, "generation": "from typing import Union, Dict, List, Tuple\nfrom urllib.parse import urlparse, urlunparse, parse_qsl, urlencode\n\ndef url_concat(\n    url: str,\n    args: Union[\n        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]\n    ],\n) -> str:\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if not args:\n        return url\n\n    # Parse the original URL into components\n    parsed_url = urlparse(url)\n\n    # Parse existing query parameters into a list of key-value pairs\n    existing_params = parse_qsl(parsed_url.query, keep_blank_values=True)\n\n    # Convert args to a list of tuples if it is a dict\n    if isinstance(args, dict):\n        new_params = list(args.items())\n    else:\n        new_params = list(args)\n\n    # Combine existing params with new params\n    combined_params = existing_params + new_params\n\n    # Encode combined parameters into a query string\n    new_query = urlencode(combined_params, doseq=True)\n\n    # Construct a new URL with the updated query string\n    new_url = urlunparse(\n        (\n            parsed_url.scheme,\n            parsed_url.netloc,\n            parsed_url.path,\n            parsed_url.params,\n            new_query,\n            parsed_url.fragment,\n        )\n    )\n\n    return new_url", "message": "passed", "passed": true}
{"task_id": 272, "prediction_id": 2, "generation": "from typing import Union, Dict, List, Tuple\nfrom urllib.parse import urlparse, urlunparse, parse_qsl, urlencode\n\n\ndef url_concat(\n    url: str,\n    args: Union[\n        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]\n    ],\n) -> str:\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if not args:\n        return url\n\n    # Parse the URL into components\n    parsed_url = urlparse(url)\n\n    # Parse existing query parameters into a list of pairs\n    existing_args = parse_qsl(parsed_url.query, keep_blank_values=True)\n\n    # Normalize the new args to a list of pairs\n    if isinstance(args, dict):\n        new_args = list(args.items())\n    else:\n        new_args = list(args)\n\n    # Combine existing and new query params\n    combined_args = existing_args + new_args\n\n    # Encode combined args back to a query string\n    new_query = urlencode(combined_args, doseq=True)\n\n    # Rebuild the URL with the new query string\n    new_url = urlunparse(\n        (\n            parsed_url.scheme,\n            parsed_url.netloc,\n            parsed_url.path,\n            parsed_url.params,\n            new_query,\n            parsed_url.fragment,\n        )\n    )\n\n    return new_url", "message": "passed", "passed": true}
{"task_id": 272, "prediction_id": 3, "generation": "from typing import Union, Dict, List, Tuple\nfrom urllib.parse import urlparse, urlunparse, parse_qsl, urlencode\n\n\ndef url_concat(\n    url: str,\n    args: Union[\n        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]\n    ],\n) -> str:\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if not args:\n        return url\n\n    parsed_url = urlparse(url)\n    # parse existing query parameters as a list of pairs\n    existing_args = parse_qsl(parsed_url.query, keep_blank_values=True)\n\n    # Normalize args to a list of tuples\n    if isinstance(args, dict):\n        new_args = list(args.items())\n    else:\n        new_args = list(args)\n\n    combined_args = existing_args + new_args\n\n    # urlencode with doseq=True to handle multiple values for same key\n    new_query = urlencode(combined_args, doseq=True)\n\n    # Rebuild the URL with the new query string\n    new_url = urlunparse(\n        (\n            parsed_url.scheme,\n            parsed_url.netloc,\n            parsed_url.path,\n            parsed_url.params,\n            new_query,\n            parsed_url.fragment,\n        )\n    )\n\n    return new_url", "message": "passed", "passed": true}
{"task_id": 272, "prediction_id": 4, "generation": "from typing import Union, Dict, List, Tuple\nfrom urllib.parse import urlparse, urlunparse, parse_qsl, urlencode\n\n\ndef url_concat(\n    url: str,\n    args: Union[\n        None, Dict[str, str], List[Tuple[str, str]], Tuple[Tuple[str, str], ...]\n    ],\n) -> str:\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if not args:\n        return url\n\n    parsed_url = urlparse(url)\n    # Parse existing query params to a list of pairs, keep_blank_values=True to preserve blank params\n    existing_params = parse_qsl(parsed_url.query, keep_blank_values=True)\n\n    if isinstance(args, dict):\n        # Convert dict to list of tuples to allow multiple values with the same key clearly.\n        new_params = list(args.items())\n    else:\n        # args is already a list or tuple of pairs\n        new_params = list(args)\n\n    # Combine existing and new params\n    combined_params = existing_params + new_params\n\n    # Encode combined params preserving order and multiple keys\n    new_query = urlencode(combined_params, doseq=True)\n\n    # Reconstruct URL with new query string\n    new_url = urlunparse(\n        (\n            parsed_url.scheme,\n            parsed_url.netloc,\n            parsed_url.path,\n            parsed_url.params,\n            new_query,\n            parsed_url.fragment,\n        )\n    )\n    return new_url", "message": "passed", "passed": true}
