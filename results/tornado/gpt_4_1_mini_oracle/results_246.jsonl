{"task_id": 246, "prediction_id": 0, "generation": "import asyncio\nimport datetime\nimport sys\nfrom typing import Union, Type, Tuple\n\nfrom tornado.concurrent import Future, is_future, chain_future\nfrom tornado.gen import _create_future, convert_yielded\nfrom tornado.ioloop import IOLoop\nfrom tornado.log import app_log\nfrom tornado.util import TimeoutError\nfrom tornado.concurrent import future_add_done_callback\n\n\ndef with_timeout(\n    timeout: Union[float, datetime.timedelta],\n    future: \"_Yieldable\",\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> Future:\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is either of a type contained in\n    ``quiet_exceptions`` (which may be an exception type or a sequence of\n    types), or an ``asyncio.CancelledError``.\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n    Added the ``quiet_exceptions`` argument and the logging of unhandled\n    exceptions.\n\n    .. versionchanged:: 4.4\n    Added support for yieldable objects other than `.Future`.\n\n    .. versionchanged:: 6.0.3\n    ``asyncio.CancelledError`` is now always considered \"quiet\".\n\n    \"\"\"\n    # Normalize quiet_exceptions to a tuple of exception types\n    if isinstance(quiet_exceptions, type) and issubclass(quiet_exceptions, Exception):\n        quiet_exceptions = (quiet_exceptions,)\n    elif not isinstance(quiet_exceptions, tuple):\n        # Accept anything iterable of exception types, else empty tuple\n        try:\n            quiet_exceptions = tuple(quiet_exceptions)\n        except Exception:\n            quiet_exceptions = ()\n\n    # asyncio.CancelledError is always quiet\n    quiet_exceptions += (asyncio.CancelledError,)\n\n    io_loop = IOLoop.current()\n    future = convert_yielded(future)\n    timeout_future = _create_future()\n\n    # Convert timeout into absolute time accepted by IOLoop.add_timeout\n    if isinstance(timeout, datetime.timedelta):\n        delay = timeout.total_seconds()\n        deadline = io_loop.time() + delay\n    else:\n        # if timeout is float or number, treat as absolute or relative time:\n        # IOLoop.add_timeout accepts either absolute or relative times.\n        # To be compatible with docstring, treat numbers as relative.\n        if isinstance(timeout, (int, float)):\n            deadline = io_loop.time() + timeout\n        else:\n            # Defensive, fallback: convert to seconds float and consider relative\n            try:\n                deadline = io_loop.time() + float(timeout)\n            except Exception:\n                raise ValueError(\"timeout must be float, timedelta, or absolute time\")\n\n    # Schedule callback to fire the timeout_future with TimeoutError if not done\n    def on_timeout():\n        if not timeout_future.done():\n            timeout_future.set_exception(TimeoutError())\n    timeout_handle = io_loop.add_timeout(deadline, on_timeout)\n\n    combined_future = _create_future()\n\n    def cleanup():\n        # Remove the timeout callback when done (cancel scheduled callback)\n        try:\n            io_loop.remove_timeout(timeout_handle)\n        except Exception:\n            # Remove timeout might fail if it's already expired or removed\n            pass\n\n    def on_completed(fut):\n        # Only one of future or timeout_future should complete the combined_future\n        if combined_future.done():\n            return\n        try:\n            result = fut.result()\n        except Exception as exc:\n            combined_future.set_exception(exc)\n        else:\n            combined_future.set_result(result)\n        cleanup()\n\n    def on_timeout_completed(fut):\n        # timeout_future finished first, set combined_future exception\n        if combined_future.done():\n            return\n        try:\n            fut.result()\n        except Exception as exc:\n            combined_future.set_exception(exc)\n        cleanup()\n\n    future_add_done_callback(future, on_completed)\n    future_add_done_callback(timeout_future, on_timeout_completed)\n\n    def log_if_needed(fut):\n        if fut.done() and not combined_future.done():\n            # The wrapped future finished after timeout expired, i.e. combined_future was already completed with TimeoutError\n            try:\n                exc = fut.exception()\n            except Exception:\n                # Unable to get exception, skip logging\n                return\n\n            if exc is None:\n                # No exception, no logging needed\n                return\n\n            # If exception is quiet, do not log\n            if isinstance(exc, quiet_exceptions):\n                return\n\n            # Log the unexpected exception from timed out future\n            app_log.error(\n                \"Future %r raised exception after timeout expired\", fut, exc_info=True\n            )\n\n    future_add_done_callback(future, log_if_needed)\n\n    # Chain combined_future's result to returned future so cancellation and result propagate\n    chain_future(combined_future, combined_future)\n\n    return combined_future", "message": "passed", "passed": true}
{"task_id": 246, "prediction_id": 1, "generation": "import asyncio\nimport sys\nimport typing\nfrom typing import Type, Union, Tuple, Any\n\nfrom tornado.concurrent import Future, is_future, chain_future\nfrom tornado.gen import convert_yielded, _create_future\nfrom tornado.ioloop import IOLoop\nfrom tornado.util import TimeoutError\nfrom tornado.concurrent import future_add_done_callback\nimport logging\n\ndef with_timeout(\n    timeout: Union[float, typing.datetime.timedelta],\n    future: typing._Yieldable,\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> Future:\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is either of a type contained in\n    ``quiet_exceptions`` (which may be an exception type or a sequence of\n    types), or an ``asyncio.CancelledError``.\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n    Added the ``quiet_exceptions`` argument and the logging of unhandled\n    exceptions.\n\n    .. versionchanged:: 4.4\n    Added support for yieldable objects other than `.Future`.\n\n    .. versionchanged:: 6.0.3\n    ``asyncio.CancelledError`` is now always considered \"quiet\".\n\n    \"\"\"\n    quiet_exception_types = quiet_exceptions\n    # Normalize to tuple for isinstance check\n    if not isinstance(quiet_exception_types, tuple):\n        quiet_exception_types = (quiet_exception_types,) if quiet_exception_types else ()\n\n    ioloop = IOLoop.current()\n    future_obj = convert_yielded(future)\n    timeout_future = _create_future()\n\n    # Schedule the timeout callback\n    def timeout_callback() -> None:\n        if not timeout_future.done():\n            timeout_future.set_exception(TimeoutError(f\"Operation timed out after {timeout}\"))\n\n    deadline_handle = ioloop.add_timeout(timeout, timeout_callback)\n\n    # This will be the future returned, which finishes with original future or timeout\n    wrapped_future = _create_future()\n\n    def _on_future_done(fut: Future) -> None:\n        # Cancel timeout callback if future completes first\n        ioloop.remove_timeout(deadline_handle)\n        if wrapped_future.done():\n            # wrapped_future already completed, ignore\n            return\n        try:\n            res = fut.result()\n        except Exception as e:\n            wrapped_future.set_exception(e)\n        else:\n            wrapped_future.set_result(res)\n\n    def _on_timeout_done(fut: Future) -> None:\n        # Called when timeout_future finishes (i.e. timeout triggered)\n        if wrapped_future.done():\n            return\n        # Timeout fires, wrap exception set on timeout_future\n        exc = fut.exception()\n        if exc is None:\n            # Unexpected, but just fail wrapped_future\n            wrapped_future.set_exception(TimeoutError(f\"Operation timed out after {timeout}\"))\n        else:\n            wrapped_future.set_exception(exc)\n\n    # When the input future finishes, propagate the result to wrapped_future\n    future_add_done_callback(future_obj, _on_future_done)\n    # When the timeout future finishes, set exception in wrapped_future\n    future_add_done_callback(timeout_future, _on_timeout_done)\n\n    def _log_unquiet_exc(fut: Future) -> None:\n        # If the future completed after a timeout (when wrapped_future is done but future_obj not),\n        # and the future_obj raised exception, log it unless it's quiet\n        if fut is future_obj and wrapped_future.done() and not fut.cancelled():\n            try:\n                fut.result()\n            except Exception as e:\n                # If exception is asyncio.CancelledError or in quiet_exceptions, don't log\n                if isinstance(e, asyncio.CancelledError) or isinstance(e, quiet_exception_types):\n                    return\n                # Log the unquiet exception from future\n                logging.getLogger(\"tornado.general\").error(\n                    \"Future completed with an error after with_timeout timed out\",\n                    exc_info=True,\n                )\n\n    future_add_done_callback(future_obj, _log_unquiet_exc)\n\n    return wrapped_future", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 541, in <module>\nAttributeError: module 'typing' has no attribute 'datetime'\n", "passed": false}
{"task_id": 246, "prediction_id": 2, "generation": "import sys\nimport datetime\nimport asyncio\nimport typing\nfrom typing import Union, Type, Tuple\n\nfrom tornado.concurrent import Future, is_future, chain_future\nfrom tornado.gen import _create_future, convert_yielded\nfrom tornado.ioloop import IOLoop\nfrom tornado.log import app_log\nfrom tornado.util import TimeoutError\nfrom tornado.concurrent import future_add_done_callback\n\n\ndef with_timeout(\n    timeout: Union[float, datetime.timedelta],\n    future: typing._Yieldable,\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> Future:\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is either of a type contained in\n    ``quiet_exceptions`` (which may be an exception type or a sequence of\n    types), or an ``asyncio.CancelledError``.\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n    Added the ``quiet_exceptions`` argument and the logging of unhandled\n    exceptions.\n\n    .. versionchanged:: 4.4\n    Added support for yieldable objects other than `.Future`.\n\n    .. versionchanged:: 6.0.3\n    ``asyncio.CancelledError`` is now always considered \"quiet\".\n\n    \"\"\"\n    # Convert the input yieldable to a Future to standardize handling\n    wrapped_future = convert_yielded(future)\n    timeout_future = _create_future()\n    io_loop = IOLoop.current()\n\n    # Convert timeout to an absolute deadline if needed\n    if isinstance(timeout, datetime.timedelta):\n        deadline = io_loop.time() + timeout.total_seconds()\n    else:\n        deadline = timeout  # Can be an absolute time or float\n\n    # Schedule callback when timeout expires\n    def on_timeout():\n        # Only set TimeoutError if timeout_future not done\n        if not timeout_future.done():\n            timeout_future.set_exception(TimeoutError(f\"Operation timed out after {timeout}\"))\n\n    timeout_handle = io_loop.add_timeout(deadline, on_timeout)\n\n    # This future will be returned, completes with the first to finish: wrapped_future or timeout_future\n    result_future = _create_future()\n\n    def on_future_done(fut: Future):\n        # If result_future already done, no action\n        if result_future.done():\n            return\n\n        # Cancel scheduled timeout callback to avoid it firing later\n        io_loop.remove_timeout(timeout_handle)\n\n        # Chain wrapped_future result or exception to result_future\n        chain_future(fut, result_future)\n\n    def on_timeout_done(fut: Future):\n        # timeout_future finished (with exception), if result_future not done yet, chain it\n        if not result_future.done():\n            chain_future(fut, result_future)\n\n        # Add done callback to wrapped_future to log any late exception\n        def log_late_error(f):\n            if f.cancelled():\n                return\n            try:\n                f.result()\n            except asyncio.CancelledError:\n                # Always considered quiet\n                pass\n            except quiet_exceptions:\n                # Quiet exceptions, no log\n                pass\n            except Exception:\n                # Log other exceptions from wrapped_future after timeout\n                app_log.error(\"Exception in future after timeout expired\", exc_info=True)\n\n        future_add_done_callback(wrapped_future, log_late_error)\n\n    future_add_done_callback(wrapped_future, on_future_done)\n    future_add_done_callback(timeout_future, on_timeout_done)\n\n    return result_future", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 544, in <module>\nAttributeError: module 'typing' has no attribute '_Yieldable'\n", "passed": false}
{"task_id": 246, "prediction_id": 3, "generation": "import asyncio\nimport sys\nimport typing\nfrom typing import Union, Type, Tuple, Any\n\nfrom tornado.concurrent import Future, is_future, chain_future\nfrom tornado.gen import _create_future, convert_yielded\nfrom tornado.ioloop import IOLoop\nfrom tornado.log import app_log\nfrom tornado.util import TimeoutError\nfrom tornado.concurrent import future_add_done_callback\n\n\ndef with_timeout(\n    timeout: Union[float, typing.datetime.timedelta],\n    future: typing.Union[Future, typing.Awaitable, typing.List[typing.Awaitable], typing.Dict[Any, typing.Awaitable]],\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> Future:\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is either of a type contained in\n    ``quiet_exceptions`` (which may be an exception type or a sequence of\n    types), or an ``asyncio.CancelledError``.\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n    Added the ``quiet_exceptions`` argument and the logging of unhandled\n    exceptions.\n\n    .. versionchanged:: 4.4\n    Added support for yieldable objects other than `.Future`.\n\n    .. versionchanged:: 6.0.3\n    ``asyncio.CancelledError`` is now always considered \"quiet\".\n\n    \"\"\"\n    # Convert input to a Future\n    converted_future = convert_yielded(future)\n\n    ret = _create_future()\n    io_loop = IOLoop.current()\n\n    # This callback will be triggered on timeout\n    def on_timeout() -> None:\n        if not ret.done():\n            exc = TimeoutError(f\"Future timed out after {timeout}\")\n            ret.set_exception(exc)\n\n    # Schedule the timeout callback\n    timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n\n    def on_future_done(fut: Future) -> None:\n        # Cancel the timeout callback as the future is done\n        io_loop.remove_timeout(timeout_handle)\n\n        if ret.done():\n            # The ret Future is already done (likely due to timeout), so handle logging\n            # If the future completed after timeout, log exceptions unless quiet\n            try:\n                exc = fut.exception()\n            except Exception:\n                # exception() raised unexpectedly, treat as no exception\n                exc = None\n\n            if exc is not None and not isinstance(\n                exc, (asyncio.CancelledError,) + (\n                    quiet_exceptions if isinstance(quiet_exceptions, tuple) else (quiet_exceptions,)\n                )\n            ):\n                # Log the exception\n                app_log.error(\"Exception in future after timeout\", exc_info=True)\n            return\n\n        # Chain the future to ret (set result or exception accordingly)\n        chain_future(fut, ret)\n\n    future_add_done_callback(converted_future, on_future_done)\n\n    return ret", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 542, in <module>\nAttributeError: module 'typing' has no attribute 'datetime'\n", "passed": false}
{"task_id": 246, "prediction_id": 4, "generation": "import asyncio\nimport datetime\nimport sys\nfrom typing import Union, Type, Tuple\n\nfrom tornado.concurrent import Future, is_future, chain_future\nfrom tornado.gen import _create_future, convert_yielded\nfrom tornado.ioloop import IOLoop\nfrom tornado.log import app_log\nfrom tornado.util import TimeoutError\nfrom tornado.concurrent import future_add_done_callback\n\n\ndef with_timeout(\n    timeout: Union[float, datetime.timedelta],\n    future: _Yieldable,\n    quiet_exceptions: \"Union[Type[Exception], Tuple[Type[Exception], ...]]\" = (),\n) -> Future:\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is either of a type contained in\n    ``quiet_exceptions`` (which may be an exception type or a sequence of\n    types), or an ``asyncio.CancelledError``.\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n    Added the ``quiet_exceptions`` argument and the logging of unhandled\n    exceptions.\n\n    .. versionchanged:: 4.4\n    Added support for yieldable objects other than `.Future`.\n\n    .. versionchanged:: 6.0.3\n    ``asyncio.CancelledError`` is now always considered \"quiet\".\n\n    \"\"\"\n    # Convert yieldable to a Future (if not already)\n    wrapped_future = convert_yielded(future)\n    timeout_future = _create_future()\n    io_loop = IOLoop.current()\n\n    # Schedule a callback to trigger when the timeout elapses\n    # tornado's add_timeout accepts:\n    #    - float (seconds delay relative to IOLoop.time)\n    #    - datetime.timedelta (interpreted as relative delay)\n    #    - absolute time\n    # We just pass it through without transformation\n    timeout_handle = io_loop.add_timeout(timeout, lambda: timeout_expired())\n\n    def timeout_expired():\n        if not timeout_future.done():\n            timeout_future.set_exception(TimeoutError())\n\n    def on_future_done(fut: Future) -> None:\n        # Cancel the timeout callback since the future completed\n        if not timeout_future.done():\n            # Remove timeout callback from IOLoop\n            io_loop.remove_timeout(timeout_handle)\n            # Chain the result/exception to timeout_future\n            try:\n                result = fut.result()\n            except Exception as e:\n                timeout_future.set_exception(e)\n            else:\n                timeout_future.set_result(result)\n\n    future_add_done_callback(wrapped_future, on_future_done)\n\n    def on_timeout_done(fut: Future) -> None:\n        # This callback is called if the timeout_future's exception was set due to timeout\n        # We want to handle logging of exceptions from wrapped_future after timeout\n        if fut.done() and fut.exception() is not None:\n            # If wrapped_future later fails after timeout, we log it unless it is \"quiet\"\n            def log_unhandled(f: Future) -> None:\n                try:\n                    f.result()\n                except Exception as e:\n                    if (\n                        isinstance(e, quiet_exceptions)\n                        or isinstance(e, asyncio.CancelledError)\n                    ):\n                        return  # quiet, do not log\n                    # Log unhandled exceptions\n                    app_log.error(\n                        \"Future exception after timeout expired: %r\", e, exc_info=True\n                    )\n\n            future_add_done_callback(wrapped_future, log_unhandled)\n\n    future_add_done_callback(timeout_future, on_timeout_done)\n\n    return timeout_future", "message": "passed", "passed": true}
