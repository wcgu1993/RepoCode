{"task_id": 257, "prediction_id": 0, "generation": "import ssl\nfrom typing import Any, Dict, Union\n\n\ndef ssl_options_to_context(\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext]\n) -> ssl.SSLContext:\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    # If the argument is already an SSLContext, just return it\n    if isinstance(ssl_options, ssl.SSLContext):\n        return ssl_options\n\n    # Otherwise it should be a dict of options similar to those passed\n    # to ssl.wrap_socket, so we convert it.\n\n    # _SSL_CONTEXT_KEYWORDS is from the file context (immutable set of recognized keys):\n    _SSL_CONTEXT_KEYWORDS = frozenset(\n        [\"ssl_version\", \"certfile\", \"keyfile\", \"cert_reqs\", \"ca_certs\", \"ciphers\"]\n    )\n\n    if not isinstance(ssl_options, dict):\n        raise TypeError(\"ssl_options must be either ssl.SSLContext or dict\")\n\n    ssl_version = ssl_options.get(\"ssl_version\", ssl.PROTOCOL_TLS)\n    context = ssl.SSLContext(ssl_version)\n\n    # Helper to set attributes on context if present in ssl_options\n    # Keys to handle: certfile, keyfile, cert_reqs, ca_certs, ciphers\n\n    certfile = ssl_options.get(\"certfile\")\n    keyfile = ssl_options.get(\"keyfile\")\n    cert_reqs = ssl_options.get(\"cert_reqs\")\n    ca_certs = ssl_options.get(\"ca_certs\")\n    ciphers = ssl_options.get(\"ciphers\")\n\n    if ciphers is not None:\n        context.set_ciphers(ciphers)\n\n    if cert_reqs is not None:\n        context.verify_mode = cert_reqs\n\n    if ca_certs is not None:\n        context.load_verify_locations(ca_certs)\n\n    if certfile is not None:\n        # keyfile may be None and is accepted by load_cert_chain\n        context.load_cert_chain(certfile, keyfile)\n\n    # Additional options from ssl_options dict that are not in _SSL_CONTEXT_KEYWORDS\n    # (e.g. check_hostname) are not handled here because ssl.wrap_socket does not accept them.\n    # We keep the conversion minimal to what wrap_socket supports.\n\n    return context", "message": "passed", "passed": true}
{"task_id": 257, "prediction_id": 1, "generation": "import ssl\nfrom typing import Union, Dict, Any\n\n\ndef ssl_options_to_context(\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext]\n) -> ssl.SSLContext:\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    # If the input is already an SSLContext, return it as is\n    if isinstance(ssl_options, ssl.SSLContext):\n        return ssl_options\n\n    # _client_ssl_defaults and _server_ssl_defaults are defined in the file content but not imported here;\n    # They are used internally as bases depending on ssl_version if possible\n    # We'll create a default context using ssl_options['ssl_version'] if provided, else use client default\n\n    # Extract ssl_version from options if present, else None\n    ssl_version = ssl_options.get(\"ssl_version\") if isinstance(ssl_options, dict) else None\n\n    # Choose default context based on ssl_version: SERVER_AUTH or CLIENT_AUTH usage is unclear here,\n    # but typical usage is SERVER_AUTH for client contexts, CLIENT_AUTH for server contexts.\n    # Since this function only converts ssl_options dict, and by default SSLContext is SERVER_AUTH for clients,\n    # we will use ssl.Purpose.SERVER_AUTH (client-side) context by default.\n    # If ssl_version specifies a server-side method, the user should override or provide context directly.\n\n    # Map ssl_version to purpose inference is not reliable; so just create a context with that ssl_version.\n    # ssl.create_default_context allows us to specify purpose, but not ssl_version.\n    # We will create simple SSLContext with ssl_version if given; else default client context.\n    # Note: ssl.create_default_context added in Python 3.4, but assumed available.\n\n    # Create SSLContext based on ssl_version or default client context\n    if ssl_version is not None:\n        try:\n            context = ssl.SSLContext(ssl_version)\n        except Exception:\n            # Fallback to default context if ssl_version is invalid\n            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n    else:\n        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n\n    # Now set the SSLContext options based on keys from ssl_options dict\n    # Exclude keys that are not SSLContext attributes or handled specially\n    # Based on the comment in file content, these keyword args must be translated:\n    # \"ssl_version\", \"certfile\", \"keyfile\", \"cert_reqs\", \"ca_certs\", \"ciphers\"\n    # ssl_version handled above, so skip it now\n\n    # Set certfile/keyfile:\n    certfile = ssl_options.get(\"certfile\")\n    keyfile = ssl_options.get(\"keyfile\")\n    if certfile:\n        # load_cert_chain requires both certfile and optionally keyfile\n        try:\n            context.load_cert_chain(certfile, keyfile)\n        except Exception:\n            # If loading cert chain fails, skip or raise?\n            # We choose to raise because it's likely a config error.\n            raise\n\n    # Set cert_reqs (certificate requirements)\n    cert_reqs = ssl_options.get(\"cert_reqs\")\n    if cert_reqs is not None:\n        context.verify_mode = cert_reqs\n\n    # Set ca_certs or cadata for verifying certificates\n    ca_certs = ssl_options.get(\"ca_certs\")\n    ca_data = ssl_options.get(\"ca_data\")\n    if ca_certs:\n        try:\n            context.load_verify_locations(cafile=ca_certs)\n        except Exception:\n            raise\n    elif ca_data:\n        try:\n            # Python 3.4+ supports cadata\n            context.load_verify_locations(cadata=ca_data)\n        except Exception:\n            raise\n\n    # Set ciphers string if provided\n    ciphers = ssl_options.get(\"ciphers\")\n    if ciphers:\n        context.set_ciphers(ciphers)\n\n    # Other common SSLContext options that might be passed through ssl_options:\n    # \"check_hostname\"\n    check_hostname = ssl_options.get(\"check_hostname\")\n    if check_hostname is not None:\n        context.check_hostname = check_hostname\n\n    # \"options\" (bitmask of SSL options)\n    options = ssl_options.get(\"options\")\n    if options is not None:\n        context.options |= options\n\n    # \"verify_flags\" (if present)\n    verify_flags = ssl_options.get(\"verify_flags\")\n    if verify_flags is not None and hasattr(context, \"verify_flags\"):\n        context.verify_flags = verify_flags\n\n    # \"hostname_checks_common_name\" has no direct SSLContext equivalent but often handled by check_hostname,\n    # so no action needed here.\n\n    # Return the constructed context\n    return context", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 722, in <module>\n  File \"<string>\", line 721, in test_28\nAssertionError\n", "passed": false}
{"task_id": 257, "prediction_id": 2, "generation": "import ssl\nfrom typing import Union, Dict, Any\n\n\ndef ssl_options_to_context(\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext]\n) -> ssl.SSLContext:\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    if isinstance(ssl_options, ssl.SSLContext):\n        return ssl_options\n\n    if not isinstance(ssl_options, dict):\n        raise TypeError(\"ssl_options must be either an SSLContext or a dict\")\n\n    # Start with a default SSLContext for server or client based on certfile presence\n    # This mimics the previous behavior with ssl.wrap_socket that needed ssl_version.\n    # Default to TLS client context if no ssl_version provided.\n    ssl_version = ssl_options.get(\"ssl_version\")\n    if ssl_version is None:\n        # Fallback: choose SERVER_AUTH context by default if certfile present, else CLIENT_AUTH\n        if ssl_options.get(\"certfile\") is not None:\n            context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        else:\n            context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n    else:\n        # Use the provided protocol version explicitly.\n        context = ssl.SSLContext(ssl_version)\n\n    # Mapping ssl.wrap_socket args to SSLContext attributes/methods\n    certfile = ssl_options.get(\"certfile\")\n    keyfile = ssl_options.get(\"keyfile\")\n    cert_reqs = ssl_options.get(\"cert_reqs\")\n    ca_certs = ssl_options.get(\"ca_certs\")\n    ciphers = ssl_options.get(\"ciphers\")\n\n    # Set verify mode if cert_reqs is provided\n    if cert_reqs is not None:\n        context.verify_mode = cert_reqs\n\n    # Load cert chain if certfile provided\n    if certfile is not None:\n        # keyfile may be None, which is acceptable\n        context.load_cert_chain(certfile, keyfile)\n\n    # Load CA certificates if ca_certs provided\n    if ca_certs is not None:\n        context.load_verify_locations(ca_certs)\n\n    # Set ciphers string if provided\n    if ciphers is not None:\n        context.set_ciphers(ciphers)\n\n    # Other ssl_options keys are not handled here because they either\n    # do not have direct equivalents or require more complex setup.\n    # This function covers the basic translation.\n\n    return context", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 675, in <module>\n  File \"<string>\", line 674, in test_28\nAssertionError\n", "passed": false}
{"task_id": 257, "prediction_id": 3, "generation": "import ssl\nfrom typing import Any, Dict, Union\n\n_SSL_CONTEXT_KEYWORDS = frozenset(\n    [\"ssl_version\", \"certfile\", \"keyfile\", \"cert_reqs\", \"ca_certs\", \"ciphers\"]\n)\n\ndef ssl_options_to_context(\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext]\n) -> ssl.SSLContext:\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    if isinstance(ssl_options, ssl.SSLContext):\n        return ssl_options\n\n    if not ssl_options:\n        return ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n\n    ssl_version = ssl_options.get(\"ssl_version\")\n    if ssl_version is None:\n        if hasattr(ssl, \"PROTOCOL_TLS_CLIENT\"):\n            ssl_version = ssl.PROTOCOL_TLS_CLIENT\n        elif hasattr(ssl, \"PROTOCOL_TLS\"):\n            ssl_version = ssl.PROTOCOL_TLS\n        else:\n            ssl_version = ssl.PROTOCOL_TLSv1_2\n\n    context = ssl.SSLContext(ssl_version)\n\n    if hasattr(ssl, \"OP_NO_COMPRESSION\"):\n        context.options |= ssl.OP_NO_COMPRESSION\n\n    certfile = ssl_options.get(\"certfile\")\n    keyfile = ssl_options.get(\"keyfile\")\n    if certfile:\n        context.load_cert_chain(certfile, keyfile)\n\n    cert_reqs = ssl_options.get(\"cert_reqs\")\n    if cert_reqs is not None:\n        context.verify_mode = cert_reqs\n\n    ca_certs = ssl_options.get(\"ca_certs\")\n    if ca_certs:\n        context.load_verify_locations(cafile=ca_certs)\n\n    ciphers = ssl_options.get(\"ciphers\")\n    if ciphers:\n        context.set_ciphers(ciphers)\n\n    return context", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 667, in <module>\n  File \"<string>\", line 666, in test_28\nAssertionError\n", "passed": false}
{"task_id": 257, "prediction_id": 4, "generation": "import ssl\nfrom typing import Union, Dict, Any\n\n\ndef ssl_options_to_context(\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext]\n) -> ssl.SSLContext:\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    if isinstance(ssl_options, ssl.SSLContext):\n        return ssl_options\n\n    if not isinstance(ssl_options, dict):\n        raise TypeError(\"ssl_options must be either a dict or ssl.SSLContext\")\n\n    # Create SSLContext\n    ssl_version = ssl_options.get(\"ssl_version\", ssl.PROTOCOL_TLS_CLIENT)\n    context = ssl.SSLContext(ssl_version)\n\n    # Set certfile and keyfile\n    certfile = ssl_options.get(\"certfile\")\n    keyfile = ssl_options.get(\"keyfile\")\n    if certfile is not None:\n        # load_cert_chain requires certfile, keyfile can be None\n        context.load_cert_chain(certfile, keyfile)\n\n    # Set verify mode\n    cert_reqs = ssl_options.get(\"cert_reqs\")\n    if cert_reqs is not None:\n        context.verify_mode = cert_reqs\n\n    # Set CA certs\n    ca_certs = ssl_options.get(\"ca_certs\")\n    if ca_certs is not None:\n        context.load_verify_locations(ca_certs)\n\n    # Set ciphers\n    ciphers = ssl_options.get(\"ciphers\")\n    if ciphers is not None:\n        context.set_ciphers(ciphers)\n\n    # Any other options that were in ssl_options but not handled here are ignored,\n    # as those not applicable to SSLContext.\n\n    return context", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 662, in <module>\n  File \"<string>\", line 661, in test_28\nAssertionError\n", "passed": false}
