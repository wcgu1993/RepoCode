{"task_id": 250, "prediction_id": 0, "generation": "import functools\nimport types\nimport typing\nfrom tornado import gen\nfrom tornado.testing import get_async_test_timeout\n\ndef gen_test(  # noqa: F811\n    func: typing.Optional[typing.Callable[..., typing.Union[types.GeneratorType, \"Coroutine\"]]] = None,\n    *,\n    timeout: typing.Optional[float] = None,\n) -> typing.Union[\n    typing.Callable[..., None],\n    typing.Callable[[typing.Callable[..., typing.Union[types.GeneratorType, \"Coroutine\"]]], typing.Callable[..., None]],\n]:\n    \"\"\"Testing equivalent of ``@gen.coroutine``, to be applied to test methods.\n\n    ``@gen.coroutine`` cannot be used on tests because the `.IOLoop` is not\n    already running.  ``@gen_test`` should be applied to test methods\n    on subclasses of `AsyncTestCase`.\n\n    Example::\n\n    class MyTest(AsyncHTTPTestCase):\n        @gen_test\n        def test_something(self):\n            response = yield self.http_client.fetch(self.get_url('/'))\n\n    By default, ``@gen_test`` times out after 5 seconds. The timeout may be\n    overridden globally with the ``ASYNC_TEST_TIMEOUT`` environment variable,\n    or for each test with the ``timeout`` keyword argument::\n\n    class MyTest(AsyncHTTPTestCase):\n        @gen_test(timeout=10)\n        def test_something_slow(self):\n            response = yield self.http_client.fetch(self.get_url('/'))\n\n    Note that ``@gen_test`` is incompatible with `AsyncTestCase.stop`,\n    `AsyncTestCase.wait`, and `AsyncHTTPTestCase.fetch`. Use ``yield\n    self.http_client.fetch(self.get_url())`` as shown above instead.\n\n    .. versionadded:: 3.1\n    The ``timeout`` argument and ``ASYNC_TEST_TIMEOUT`` environment\n    variable.\n\n    .. versionchanged:: 4.0\n    The wrapper now passes along ``*args, **kwargs`` so it can be used\n    on functions with arguments.\n\n    \"\"\"\n    if func is None:\n        # This means decorator is used as @gen_test(timeout=10)\n        def wrapper(f: typing.Callable[..., typing.Union[types.GeneratorType, \"Coroutine\"]]) -> typing.Callable[..., None]:\n            return gen_test(f, timeout=timeout)\n        return wrapper\n\n    @functools.wraps(func)\n    def run_test(self, *args, **kwargs) -> None:\n        # Determine final timeout to use\n        test_timeout = (\n            timeout if timeout is not None else get_async_test_timeout()\n        )\n        # Call the test function with provided args and kwargs,\n        # schedule it as a coroutine wrapped by gen.coroutine,\n        # then run it synchronously on self.io_loop with timeout.\n        f = gen.coroutine(func)\n        self.io_loop.run_sync(lambda: f(self, *args, **kwargs), timeout=test_timeout)\n\n    return run_test", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 804, in <module>\n  File \"<string>\", line 803, in test_10\nAssertionError\n", "passed": false}
{"task_id": 250, "prediction_id": 1, "generation": "import functools\nfrom typing import Callable, Optional, Union, Generator\nfrom tornado import gen\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Coroutine\n\ndef gen_test(  # noqa: F811\n    func: Optional[Callable[..., Union[Generator, \"Coroutine\"]]] = None,\n    timeout: Optional[float] = None,\n) -> Union[\n    Callable[..., None],\n    Callable[[Callable[..., Union[Generator, \"Coroutine\"]]], Callable[..., None]],\n]:\n    \"\"\"Testing equivalent of ``@gen.coroutine``, to be applied to test methods.\n\n    ``@gen.coroutine`` cannot be used on tests because the `.IOLoop` is not\n    already running.  ``@gen_test`` should be applied to test methods\n    on subclasses of `AsyncTestCase`.\n\n    Example::\n\n    class MyTest(AsyncHTTPTestCase):\n    @gen_test\n    def test_something(self):\n    response = yield self.http_client.fetch(self.get_url('/'))\n\n    By default, ``@gen_test`` times out after 5 seconds. The timeout may be\n    overridden globally with the ``ASYNC_TEST_TIMEOUT`` environment variable,\n    or for each test with the ``timeout`` keyword argument::\n\n    class MyTest(AsyncHTTPTestCase):\n    @gen_test(timeout=10)\n    def test_something_slow(self):\n    response = yield self.http_client.fetch(self.get_url('/'))\n\n    Note that ``@gen_test`` is incompatible with `AsyncTestCase.stop`,\n    `AsyncTestCase.wait`, and `AsyncHTTPTestCase.fetch`. Use ``yield\n    self.http_client.fetch(self.get_url())`` as shown above instead.\n\n    .. versionadded:: 3.1\n    The ``timeout`` argument and ``ASYNC_TEST_TIMEOUT`` environment\n    variable.\n\n    .. versionchanged:: 4.0\n    The wrapper now passes along ``*args, **kwargs`` so it can be used\n    on functions with arguments.\n\n    \"\"\"\n    def decorator(f: Callable[..., Union[Generator, \"Coroutine\"]]) -> Callable[..., None]:\n        @functools.wraps(f)\n        def wrapper(self: object, *args: object, **kwargs: object) -> None:\n            # Determine effective timeout\n            effective_timeout = timeout\n            if effective_timeout is None:\n                # Use environment or default timeout\n                from tornado.testing import get_async_test_timeout\n                effective_timeout = get_async_test_timeout()\n\n            # Assign the coroutine/generator to self._test_generator for tracking (used by AsyncTestCase)\n            self._test_generator = f(self, *args, **kwargs)\n            # Run the coroutine/generator until complete with timeout\n            self.io_loop.run_sync(lambda: self._test_generator, timeout=effective_timeout)\n\n        return wrapper\n\n    if func is None:\n        return decorator\n    else:\n        return decorator(func)", "message": "passed", "passed": true}
{"task_id": 250, "prediction_id": 2, "generation": "import functools\nimport inspect\nimport os\nfrom typing import Callable, Coroutine, Generator, Optional, Union\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.util import raise_exc_info\n\n# For typing only\nCoroutineType = Coroutine\nGeneratorType = Generator\n\n\ndef gen_test(  # noqa: F811\n    func: Optional[Callable[..., Union[GeneratorType, CoroutineType]]] = None,\n    timeout: Optional[float] = None,\n) -> Union[\n    Callable[..., None],\n    Callable[[Callable[..., Union[GeneratorType, CoroutineType]]], Callable[..., None]],\n]:\n    \"\"\"Testing equivalent of ``@gen.coroutine``, to be applied to test methods.\n\n    ``@gen.coroutine`` cannot be used on tests because the `.IOLoop` is not\n    already running.  ``@gen_test`` should be applied to test methods\n    on subclasses of `AsyncTestCase`.\n\n    Example::\n\n    class MyTest(AsyncHTTPTestCase):\n        @gen_test\n        def test_something(self):\n            response = yield self.http_client.fetch(self.get_url('/'))\n\n    By default, ``@gen_test`` times out after 5 seconds. The timeout may be\n    overridden globally with the ``ASYNC_TEST_TIMEOUT`` environment variable,\n    or for each test with the ``timeout`` keyword argument::\n\n    class MyTest(AsyncHTTPTestCase):\n        @gen_test(timeout=10)\n        def test_something_slow(self):\n            response = yield self.http_client.fetch(self.get_url('/'))\n\n    Note that ``@gen_test`` is incompatible with `AsyncTestCase.stop`,\n    `AsyncTestCase.wait`, and `AsyncHTTPTestCase.fetch`. Use ``yield\n    self.http_client.fetch(self.get_url())`` as shown above instead.\n\n    .. versionadded:: 3.1\n       The ``timeout`` argument and ``ASYNC_TEST_TIMEOUT`` environment\n       variable.\n\n    .. versionchanged:: 4.0\n       The wrapper now passes along ``*args, **kwargs`` so it can be used\n       on functions with arguments.\n\n    \"\"\"\n\n    def get_async_test_timeout() -> float:\n        env = os.environ.get(\"ASYNC_TEST_TIMEOUT\")\n        if env is not None:\n            try:\n                return float(env)\n            except ValueError:\n                pass\n        return 5.0\n\n    def decorator(f: Callable[..., Union[GeneratorType, CoroutineType]]) -> Callable[..., None]:\n        @functools.wraps(f)\n        def wrapper(self, *args, **kwargs) -> None:\n            # Determine timeout to use\n            to = timeout\n            if to is None:\n                to = get_async_test_timeout()\n\n            # Call the test method, which returns a generator or coroutine\n            gen = f(self, *args, **kwargs)\n\n            # The gen_test is intended to work with methods returning generators or coroutines\n            if not (inspect.isgenerator(gen) or inspect.iscoroutine(gen)):\n                raise TypeError(\n                    \"The decorated test method must return a generator or coroutine\"\n                )\n\n            # Run the coroutine or generator until complete with timeout\n            try:\n                # IOLoop.current().run_sync accepts a function returning a Future or coroutine\n                IOLoop.current().run_sync(lambda: gen, timeout=to)\n            except Exception as e:\n                # Reraise exceptions so unittest catches them properly\n                raise_exc_info((type(e), e, e.__traceback__))\n\n        return wrapper\n\n    if func is not None:\n        # If func is passed directly, return the decorated function\n        return decorator(func)\n    else:\n        # If no func passed, return the decorator for use with arguments\n        return decorator", "message": "passed", "passed": true}
{"task_id": 250, "prediction_id": 3, "generation": "import functools\nimport inspect\nimport os\nfrom typing import Callable, Coroutine, Optional, TypeVar, Union, Generator\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.util import raise_exc_info\n\n# Type variable for the decorated function\nF = TypeVar(\"F\", bound=Callable[..., Union[Generator, Coroutine]])\n\ndef get_async_test_timeout() -> float:\n    \"\"\"Get the global timeout setting for async tests.\n\n    Returns a float, the timeout in seconds.\n\n    .. versionadded:: 3.1\n    \"\"\"\n    env = os.environ.get(\"ASYNC_TEST_TIMEOUT\")\n    if env is not None:\n        try:\n            return float(env)\n        except ValueError:\n            pass\n    return 5\n\n\ndef gen_test(  # noqa: F811\n    func: Optional[Callable[..., Union[Generator, \"Coroutine\"]]] = None,\n    timeout: Optional[float] = None,\n) -> Union[\n    Callable[..., None],\n    Callable[[Callable[..., Union[Generator, \"Coroutine\"]]], Callable[..., None]],\n]:\n    \"\"\"Testing equivalent of ``@gen.coroutine``, to be applied to test methods.\n\n    ``@gen.coroutine`` cannot be used on tests because the `.IOLoop` is not\n    already running.  ``@gen_test`` should be applied to test methods\n    on subclasses of `AsyncTestCase`.\n\n    Example::\n\n    class MyTest(AsyncHTTPTestCase):\n    @gen_test\n    def test_something(self):\n    response = yield self.http_client.fetch(self.get_url('/'))\n\n    By default, ``@gen_test`` times out after 5 seconds. The timeout may be\n    overridden globally with the ``ASYNC_TEST_TIMEOUT`` environment variable,\n    or for each test with the ``timeout`` keyword argument::\n\n    class MyTest(AsyncHTTPTestCase):\n    @gen_test(timeout=10)\n    def test_something_slow(self):\n    response = yield self.http_client.fetch(self.get_url('/'))\n\n    Note that ``@gen_test`` is incompatible with `AsyncTestCase.stop`,\n    `AsyncTestCase.wait`, and `AsyncHTTPTestCase.fetch`. Use ``yield\n    self.http_client.fetch(self.get_url())`` as shown above instead.\n\n    .. versionadded:: 3.1\n    The ``timeout`` argument and ``ASYNC_TEST_TIMEOUT`` environment\n    variable.\n\n    .. versionchanged:: 4.0\n    The wrapper now passes along ``*args, **kwargs`` so it can be used\n    on functions with arguments.\n\n    \"\"\"\n    def decorator(f: F) -> Callable[..., None]:\n        @functools.wraps(f)\n        def wrapper(self, *args, **kwargs) -> None:\n            # Determine effective timeout\n            effective_timeout = timeout\n            if effective_timeout is None:\n                effective_timeout = get_async_test_timeout()\n\n            # Get the IOLoop to run with\n            loop = getattr(self, \"io_loop\", None)\n            if loop is None:\n                # Fallback: create new IOLoop (should not generally happen in AsyncTestCase)\n                loop = IOLoop.current()\n\n            # Call the decorated function and run it in the IOLoop until complete\n            try:\n                result = loop.run_sync(\n                    lambda: f(self, *args, **kwargs), timeout=effective_timeout\n                )\n            except Exception as e:\n                # Re-raise exceptions to preserve tracebacks and unittest integration\n                raise_exc_info(e.__class__, e, e.__traceback__)\n\n        return wrapper\n\n    if func is None:\n        # Used as @gen_test(timeout=5)\n        return decorator\n    else:\n        # Used as @gen_test\n        return decorator(func)", "message": "passed", "passed": true}
{"task_id": 250, "prediction_id": 4, "generation": "import functools\nimport typing\nfrom typing import Callable, Generator, Optional, Union\n\nfrom tornado import gen\nfrom tornado.testing import get_async_test_timeout\n\n\ndef gen_test(  # noqa: F811\n    func: Optional[Callable[..., Union[Generator, \"Coroutine\"]]] = None,\n    *,\n    timeout: Optional[float] = None,\n) -> Union[\n    Callable[..., None],\n    Callable[[Callable[..., Union[Generator, \"Coroutine\"]]], Callable[..., None]],\n]:\n    \"\"\"Testing equivalent of ``@gen.coroutine``, to be applied to test methods.\n\n    ``@gen.coroutine`` cannot be used on tests because the `.IOLoop` is not\n    already running.  ``@gen_test`` should be applied to test methods\n    on subclasses of `AsyncTestCase`.\n\n    Example::\n\n    class MyTest(AsyncHTTPTestCase):\n        @gen_test\n        def test_something(self):\n            response = yield self.http_client.fetch(self.get_url('/'))\n\n    By default, ``@gen_test`` times out after 5 seconds. The timeout may be\n    overridden globally with the ``ASYNC_TEST_TIMEOUT`` environment variable,\n    or for each test with the ``timeout`` keyword argument::\n\n    class MyTest(AsyncHTTPTestCase):\n        @gen_test(timeout=10)\n        def test_something_slow(self):\n            response = yield self.http_client.fetch(self.get_url('/'))\n\n    Note that ``@gen_test`` is incompatible with `AsyncTestCase.stop`,\n    `AsyncTestCase.wait`, and `AsyncHTTPTestCase.fetch`. Use ``yield\n    self.http_client.fetch(self.get_url())`` as shown above instead.\n\n    .. versionadded:: 3.1\n       The ``timeout`` argument and ``ASYNC_TEST_TIMEOUT`` environment\n       variable.\n\n    .. versionchanged:: 4.0\n       The wrapper now passes along ``*args, **kwargs`` so it can be used\n       on functions with arguments.\n\n    \"\"\"\n    def decorator(f: Callable[..., Union[Generator, \"Coroutine\"]]) -> Callable[..., None]:\n        @functools.wraps(f)\n        def wrapper(self, *args, **kwargs) -> None:\n            test_timeout = timeout if timeout is not None else get_async_test_timeout()\n            # Run the coroutine with the io_loop using run_sync with timeout\n            # f is expected to be a generator or coroutine function\n            fut = lambda: gen.convert_yielded(f(self, *args, **kwargs))\n            self.io_loop.run_sync(fut, timeout=test_timeout)\n\n        return wrapper\n\n    if func is None:\n        return decorator\n    else:\n        return decorator(func)", "message": "passed", "passed": true}
