{"task_id": 242, "prediction_id": 0, "generation": "import types\nfrom typing import Any\n\ndef is_coroutine_function(func: Any) -> bool:\n    \"\"\"Return whether *func* is a coroutine function, i.e. a function\n    wrapped with `~.gen.coroutine`.\n\n    .. versionadded:: 4.5\n    \"\"\"\n    # Tornado's coroutine decorator sets __tornado_coroutine__ to True on the wrapped function.\n    # Also support asyncio native coroutine functions.\n    if hasattr(func, \"__tornado_coroutine__\") and getattr(func, \"__tornado_coroutine__\"):\n        return True\n\n    # Additionally, support Python native coroutine functions (async def)\n    # These are recognized by types.coroutinetype in 3.5+ or via inspect.iscoroutinefunction.\n    # However, since this file's context avoids importing inspect, we check\n    # if the function is a coroutine function via types.coroutine type.\n\n    # Check for native coroutine function:\n    # types.coroutine wraps a generator-based coroutine to mark it as such\n    # but the cleanest is to check for asyncio.iscoroutinefunction, however\n    # since we import asyncio, use asyncio.iscoroutinefunction.\n\n    try:\n        import asyncio\n        return asyncio.iscoroutinefunction(func)\n    except ImportError:\n        # Fallback: check if it's a generator function with __await__ attribute\n        return hasattr(func, '__await__')", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 853, in <module>\n  File \"<string>\", line 852, in test_2\nAssertionError\n", "passed": false}
{"task_id": 242, "prediction_id": 1, "generation": "from types import FunctionType\nimport functools\nfrom typing import Any\n\ndef is_coroutine_function(func: Any) -> bool:\n    \"\"\"Return whether *func* is a coroutine function, i.e. a function\n    wrapped with `~.gen.coroutine`.\n\n    .. versionadded:: 4.5\n    \"\"\"\n    # Check if the function is a coroutine decorated with `gen.coroutine`.\n    # The decorator sets a __tornado_coroutine__ attribute on the wrapper.\n    # We check if that attribute exists and is True.\n    # Support functools.wraps and partial functions by unwrapping.\n    # If `func` is not callable, return False.\n    \n    # Unwrap functools.partial, functools.wraps and other common wrappers\n    # until the original function is found or no further unwrapping is possible.\n    # This helps to detect wrapped coroutine functions reliably.\n    \n    # We can use a loop for unwrapping:\n    f = func\n    while True:\n        # If function has __tornado_coroutine__ attribute True, return True\n        if getattr(f, \"__tornado_coroutine__\", False):\n            return True\n        # Unwrap functools.partial - check .func attribute\n        if isinstance(f, functools.partial):\n            f = f.func\n            continue\n        # unwrap __wrapped__ attribute (from functools.wraps)\n        if hasattr(f, \"__wrapped__\"):\n            f = f.__wrapped__\n            continue\n        break\n    return False", "message": "passed", "passed": true}
{"task_id": 242, "prediction_id": 2, "generation": "from typing import Any\nfrom inspect import isgeneratorfunction\n\ndef is_coroutine_function(func: Any) -> bool:\n    \"\"\"Return whether *func* is a coroutine function, i.e. a function\n    wrapped with `~.gen.coroutine`.\n\n    .. versionadded:: 4.5\n    \"\"\"\n    # Tornado's coroutine decorator adds an attribute __tornado_coroutine__ to the wrapped function.\n    # So if func has this attribute and it is True, it is a coroutine function.\n    return (\n        callable(func)\n        and getattr(func, \"__tornado_coroutine__\", False) is True\n    )", "message": "passed", "passed": true}
{"task_id": 242, "prediction_id": 3, "generation": "from typing import Any\n\ndef is_coroutine_function(func: Any) -> bool:\n    \"\"\"Return whether *func* is a coroutine function, i.e. a function\n    wrapped with `~.gen.coroutine`.\n\n    .. versionadded:: 4.5\n    \"\"\"\n    return getattr(func, \"__tornado_coroutine__\", False) is True", "message": "passed", "passed": true}
{"task_id": 242, "prediction_id": 4, "generation": "from inspect import isfunction\nfrom types import CoroutineType\nfrom typing import Any\n\ndef is_coroutine_function(func: Any) -> bool:\n    \"\"\"Return whether *func* is a coroutine function, i.e. a function\n    wrapped with `~.gen.coroutine`.\n\n    .. versionadded:: 4.5\n    \"\"\"\n    # The tornado.gen.coroutine decorator adds an attribute __tornado_coroutine__ to the wrapped function\n    # We check if func is callable and has this attribute set to True.\n    # It's safer to check attribute presence rather than type because it can wrap generators or normal funcs.\n    return callable(func) and getattr(func, \"__tornado_coroutine__\", False) is True", "message": "passed", "passed": true}
