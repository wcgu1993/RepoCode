{"task_id": 258, "prediction_id": 0, "generation": "import ssl\nfrom typing import Dict, Any, Union, Optional\nimport socket\n\nfrom tornado.netutil import ssl_options_to_context\n\n\ndef ssl_wrap_socket(\n    socket: socket.socket,\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext],\n    server_hostname: Optional[str] = None,\n    **kwargs: Any\n) -> ssl.SSLSocket:\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n\n    # If server_hostname is specified and context supports wrap_socket with it (SNI)\n    if server_hostname is not None:\n        # ssl.SSLContext.wrap_socket supports server_hostname parameter from Py 3.4+\n        return context.wrap_socket(socket, server_hostname=server_hostname, **kwargs)\n    else:\n        # No server_hostname, call wrap_socket without it\n        return context.wrap_socket(socket, **kwargs)", "message": "passed", "passed": true}
{"task_id": 258, "prediction_id": 1, "generation": "import ssl\nfrom typing import Dict, Any, Union, Optional\nfrom tornado.netutil import ssl_options_to_context\nimport socket\n\n\ndef ssl_wrap_socket(\n    socket: socket.socket,\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext],\n    server_hostname: Optional[str] = None,\n    **kwargs: Any\n) -> ssl.SSLSocket:\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n\n    # If server_hostname is not provided, default to None\n    # Wrap socket using SSLContext.wrap_socket method, passing server_hostname and additional kwargs\n    return context.wrap_socket(socket, server_hostname=server_hostname, **kwargs)", "message": "passed", "passed": true}
{"task_id": 258, "prediction_id": 2, "generation": "import ssl\nfrom typing import Dict, Any, Optional, Union\nfrom tornado.netutil import ssl_options_to_context\n\n\ndef ssl_wrap_socket(\n    socket: ssl.SSLSocket,\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext],\n    server_hostname: Optional[str] = None,\n    **kwargs: Any\n) -> ssl.SSLSocket:\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n    # Use context.wrap_socket method, passing through server_hostname and any further kwargs\n    return context.wrap_socket(socket, server_hostname=server_hostname, **kwargs)", "message": "passed", "passed": true}
{"task_id": 258, "prediction_id": 3, "generation": "import ssl\nfrom typing import Any, Dict, Optional, Union\nimport socket\nfrom tornado.netutil import ssl_options_to_context\n\n\ndef ssl_wrap_socket(\n    socket: socket.socket,\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext],\n    server_hostname: Optional[str] = None,\n    **kwargs: Any\n) -> ssl.SSLSocket:\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n    if hasattr(context, \"wrap_socket\"):\n        # Use SSLContext.wrap_socket. Pass server_hostname if given (SNI)\n        return context.wrap_socket(socket, server_hostname=server_hostname, **kwargs)\n    else:\n        # Fallback: wrap_socket function from ssl module (unlikely for context)\n        # Context is a dict or unknown, just pass accordingly\n        return ssl.wrap_socket(socket, ssl_version=context.get(\"ssl_version\", ssl.PROTOCOL_SSLv23),\n                               certfile=context.get(\"certfile\") if isinstance(context, dict) else None,\n                               keyfile=context.get(\"keyfile\") if isinstance(context, dict) else None,\n                               cert_reqs=context.get(\"cert_reqs\") if isinstance(context, dict) else None,\n                               ca_certs=context.get(\"ca_certs\") if isinstance(context, dict) else None,\n                               ciphers=context.get(\"ciphers\") if isinstance(context, dict) else None,\n                               server_hostname=server_hostname, **kwargs)", "message": "passed", "passed": true}
{"task_id": 258, "prediction_id": 4, "generation": "import ssl\nfrom typing import Any, Dict, Optional, Union\nfrom tornado.netutil import ssl_options_to_context\n\n\ndef ssl_wrap_socket(\n    socket: ssl.socket,\n    ssl_options: Union[Dict[str, Any], ssl.SSLContext],\n    server_hostname: Optional[str] = None,\n    **kwargs: Any\n) -> ssl.SSLSocket:\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n\n    # If server_hostname is not set, do not pass it (avoid Python 2.7 SSL bug)\n    if server_hostname is not None:\n        return context.wrap_socket(socket, server_hostname=server_hostname, **kwargs)\n    else:\n        return context.wrap_socket(socket, **kwargs)", "message": "passed", "passed": true}
