{"task_id": 288, "prediction_id": 0, "generation": "def _websocket_mask_python(mask: bytes, data: bytes) -> bytes:\n    \"\"\"Websocket masking function.\n\n    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.\n    Returns a `bytes` object of the same length as `data` with the mask applied\n    as specified in section 5.3 of RFC 6455.\n\n    This pure-python implementation may be replaced by an optimized version when available.\n    \"\"\"\n    # The masking is done by XOR'ing each byte of data with a byte from mask,\n    # cycling through mask bytes for the length of data.\n    mask_len = 4\n    masked = bytearray(len(data))\n    for i in range(len(data)):\n        masked[i] = data[i] ^ mask[i % mask_len]\n    return bytes(masked)", "message": "passed", "passed": true}
{"task_id": 288, "prediction_id": 1, "generation": "def _websocket_mask_python(mask: bytes, data: bytes) -> bytes:\n    \"\"\"Websocket masking function.\n\n    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.\n    Returns a `bytes` object of the same length as `data` with the mask applied\n    as specified in section 5.3 of RFC 6455.\n\n    This pure-python implementation may be replaced by an optimized version when available.\n    \"\"\"\n    if len(mask) != 4:\n        raise ValueError(\"mask must be 4 bytes long\")\n\n    mask_bytes = memoryview(mask)\n    data_bytes = memoryview(data)\n    result = bytearray(len(data_bytes))\n    for i in range(len(data_bytes)):\n        result[i] = data_bytes[i] ^ mask_bytes[i % 4]\n    return bytes(result)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 507, in <module>\n  File \"<string>\", line 506, in test_18\n  File \"<string>\", line 461, in _websocket_mask_python\nValueError: mask must be 4 bytes long\n", "passed": false}
{"task_id": 288, "prediction_id": 2, "generation": "def _websocket_mask_python(mask: bytes, data: bytes) -> bytes:\n    \"\"\"Websocket masking function.\n\n    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.\n    Returns a `bytes` object of the same length as `data` with the mask applied\n    as specified in section 5.3 of RFC 6455.\n\n    This pure-python implementation may be replaced by an optimized version when available.\n    \"\"\"\n    if len(mask) != 4:\n        raise ValueError(\"Mask must be exactly 4 bytes\")\n\n    masked = bytearray(len(data))\n    for i in range(len(data)):\n        masked[i] = data[i] ^ mask[i % 4]\n    return bytes(masked)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 505, in <module>\n  File \"<string>\", line 504, in test_18\n  File \"<string>\", line 461, in _websocket_mask_python\nValueError: Mask must be exactly 4 bytes\n", "passed": false}
{"task_id": 288, "prediction_id": 3, "generation": "def _websocket_mask_python(mask: bytes, data: bytes) -> bytes:\n    \"\"\"Websocket masking function.\n\n    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.\n    Returns a `bytes` object of the same length as `data` with the mask applied\n    as specified in section 5.3 of RFC 6455.\n\n    This pure-python implementation may be replaced by an optimized version when available.\n    \"\"\"\n    if len(mask) != 4:\n        raise ValueError(\"mask must be 4 bytes long\")\n\n    masked = bytearray(len(data))\n    for i in range(len(data)):\n        masked[i] = data[i] ^ mask[i % 4]\n    return bytes(masked)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 505, in <module>\n  File \"<string>\", line 504, in test_18\n  File \"<string>\", line 461, in _websocket_mask_python\nValueError: mask must be 4 bytes long\n", "passed": false}
{"task_id": 288, "prediction_id": 4, "generation": "def _websocket_mask_python(mask: bytes, data: bytes) -> bytes:\n    \"\"\"Websocket masking function.\n\n    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.\n    Returns a `bytes` object of the same length as `data` with the mask applied\n    as specified in section 5.3 of RFC 6455.\n\n    This pure-python implementation may be replaced by an optimized version when available.\n    \"\"\"\n    masked = bytearray(data)\n    mask_length = 4\n    for i in range(len(data)):\n        masked[i] ^= mask[i % mask_length]\n    return bytes(masked)", "message": "passed", "passed": true}
