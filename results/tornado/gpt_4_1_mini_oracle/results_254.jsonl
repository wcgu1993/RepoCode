{"task_id": 254, "prediction_id": 0, "generation": "import socket\nfrom typing import List, Optional\nfrom tornado.util import errno_from_exception\n\ndef bind_sockets(\n    port: int,\n    address: Optional[str] = None,\n    family: socket.AddressFamily = socket.AF_UNSPEC,\n    backlog: int = 128,\n    flags: Optional[int] = None,\n    reuse_port: bool = False,\n) -> List[socket.socket]:\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen() <socket.socket.listen>`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    if flags is None:\n        flags = socket.AI_PASSIVE\n\n    # Prefer family AF_UNSPEC, but if user specified AF_INET or AF_INET6, keep it.\n    # If address is None or '', listen on all available interfaces.\n    # getaddrinfo to resolve addresses\n    res = socket.getaddrinfo(\n        address,\n        port,\n        family,\n        socket.SOCK_STREAM,\n        0,\n        flags,\n    )\n\n    sockets = []\n    errors = []\n    for af, socktype, proto, canonname, sockaddr in res:\n        try:\n            sock = socket.socket(af, socktype, proto)\n        except OSError as e:\n            errors.append(e)\n            continue\n\n        try:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        except OSError:\n            # Some systems may not support this, ignore error\n            pass\n\n        if reuse_port:\n            try:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n            except AttributeError:\n                # SO_REUSEPORT not available in socket module\n                sock.close()\n                raise ValueError(\"SO_REUSEPORT not supported by this platform\")\n            except OSError as e:\n                # Some platforms may have it but don't support it on this socket\n                sock.close()\n                raise ValueError(\"SO_REUSEPORT not supported by this platform\") from e\n\n        try:\n            sock.bind(sockaddr)\n            sock.listen(backlog)\n        except OSError as e:\n            sock.close()\n            errors.append(e)\n            continue\n\n        sockets.append(sock)\n\n    if not sockets and errors:\n        # If no sockets successfully created, raise first error\n        err = errors[0]\n        err_no = errno_from_exception(err)\n        if err_no is not None:\n            raise OSError(err_no, str(err))\n        else:\n            raise err\n\n    return sockets", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 585, in <module>\n  File \"<string>\", line 584, in test_51\n  File \"<string>\", line 147, in bind_sockets\nOSError: [Errno 98] [Errno 98] Address already in use\n", "passed": false}
{"task_id": 254, "prediction_id": 1, "generation": "import socket\nfrom typing import List, Optional\n\nfrom tornado.util import errno_from_exception\n\ndef bind_sockets(\n    port: int,\n    address: Optional[str] = None,\n    family: socket.AddressFamily = socket.AF_UNSPEC,\n    backlog: int = 128,\n    flags: Optional[int] = None,\n    reuse_port: bool = False,\n) -> List[socket.socket]:\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen() <socket.socket.listen>`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    # Use AI_PASSIVE if no address is given to listen on all interfaces\n    if flags is None:\n        flags = 0\n    if address is None or address == '':\n        # AI_PASSIVE flag indicates the socket is intended for bind/listen\n        flags |= socket.AI_PASSIVE  \n\n    # getaddrinfo may return multiple entries to cover IPv4 and IPv6, etc.\n    try:\n        addrinfo = socket.getaddrinfo(address, port, family, socket.SOCK_STREAM, 0, flags)\n    except socket.gaierror as e:\n        # Will propagate the exception since we can't resolve the address\n        raise\n\n    sockets = []\n    errors = []\n    for res in addrinfo:\n        af, socktype, proto, canonname, sa = res\n        try:\n            sock = socket.socket(af, socktype, proto)\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            if reuse_port:\n                if not hasattr(socket, \"SO_REUSEPORT\"):\n                    sock.close()\n                    raise ValueError(\"SO_REUSEPORT option is not supported on this platform\")\n                try:\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n                except OSError as e:\n                    sock.close()\n                    # Raise ValueError if platform does not support reuse_port but sockopt fails\n                    err = errno_from_exception(e)\n                    if err in (errno.ENOPROTOOPT, errno.EINVAL):\n                        raise ValueError(\"SO_REUSEPORT option is not supported on this platform\") from e\n                    else:\n                        raise\n\n            sock.bind(sa)\n            sock.listen(backlog)\n            sockets.append(sock)\n        except OSError as e:\n            errors.append((e, res))\n            continue\n\n    if not sockets:\n        # If no sockets were successfully created, raise the last error\n        if errors:\n            raise errors[-1][0]\n        else:\n            # Shouldn't happen, but just in case\n            raise RuntimeError(\"Failed to bind any sockets\")\n\n    return sockets", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 592, in <module>\n  File \"<string>\", line 591, in test_93\n  File \"<string>\", line 137, in bind_sockets\n  File \"<string>\", line 127, in bind_sockets\nOSError: [Errno 98] Address already in use\n", "passed": false}
{"task_id": 254, "prediction_id": 2, "generation": "import socket\nfrom typing import List, Optional\nfrom tornado.util import errno_from_exception\n\ndef bind_sockets(\n    port: int,\n    address: Optional[str] = None,\n    family: socket.AddressFamily = socket.AF_UNSPEC,\n    backlog: int = 128,\n    flags: Optional[int] = None,\n    reuse_port: bool = False,\n) -> List[socket.socket]:\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen() <socket.socket.listen>`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    if flags is None:\n        flags = socket.AI_PASSIVE\n\n    # Use empty string for None address to listen on all interfaces\n    if address is None:\n        listen_addr = ''\n    else:\n        listen_addr = address\n\n    # Get address infos for the requested parameters\n    try:\n        info_list = socket.getaddrinfo(\n            listen_addr,\n            port,\n            family,\n            socket.SOCK_STREAM,\n            0,\n            flags,\n        )\n    except socket.gaierror as e:\n        raise  # propagate DNS resolution errors\n\n    sockets = []\n    errors = []\n\n    for res in info_list:\n        af, socktype, proto, canonname, sockaddr = res\n        try:\n            sock = socket.socket(af, socktype, proto)\n        except OSError as e:\n            errors.append(e)\n            continue\n\n        try:\n            # Allow socket address reuse for faster restarts\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            if reuse_port:\n                if hasattr(socket, \"SO_REUSEPORT\"):\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n                else:\n                    sock.close()\n                    raise ValueError(\"SO_REUSEPORT not supported on this platform\")\n\n            # On some platforms, setting IPV6_V6ONLY is needed to avoid dual-stack issues\n            if af == socket.AF_INET6:\n                # Prefer to enable dual-stack sockets (listening on both IPv4 and IPv6) if possible\n                # But if the address explicitly specifies IPv6, disable dual stack if possible\n                # Here we attempt to disable IPV6_V6ONLY to allow dual stack, fallback silent\n                # This is common practice to handle both IPv4/IPv6 listening on one socket\n                try:\n                    sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)\n                except (AttributeError, OSError):\n                    # Some platforms don't support IPV6_V6ONLY or disallow changing it\n                    pass\n\n            sock.bind(sockaddr)\n            sock.listen(backlog)\n            sockets.append(sock)\n\n        except OSError as e:\n            sock.close()\n            errors.append(e)\n\n    if not sockets:\n        # If no sockets could be created, raise the first error encountered or generic error\n        if errors:\n            err = errors[0]\n            err_no = errno_from_exception(err)\n            # Raise a more informative error with errno if available\n            raise OSError(err_no, f\"Cannot bind to {address}:{port}\") from err\n        else:\n            raise RuntimeError(f\"Could not create any listening socket for {address}:{port}\")\n\n    return sockets", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 597, in <module>\n  File \"<string>\", line 596, in test_51\n  File \"<string>\", line 101, in bind_sockets\n  File \"/usr/local/lib/python3.10/socket.py\", line 955, in getaddrinfo\n    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):\nsocket.gaierror: [Errno -2] Name or service not known\n", "passed": false}
{"task_id": 254, "prediction_id": 3, "generation": "import socket\nfrom typing import List, Optional\nfrom tornado.util import errno_from_exception\n\ndef bind_sockets(\n    port: int,\n    address: Optional[str] = None,\n    family: socket.AddressFamily = socket.AF_UNSPEC,\n    backlog: int = 128,\n    flags: Optional[int] = None,\n    reuse_port: bool = False,\n) -> List[socket.socket]:\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen() <socket.socket.listen>`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    if reuse_port and not hasattr(socket, \"SO_REUSEPORT\"):\n        raise ValueError(\"SO_REUSEPORT not supported on this platform\")\n\n    # If no flags are given, default to AI_PASSIVE if address is None or empty string\n    if flags is None:\n        flags = 0\n        if not address:\n            flags |= socket.AI_PASSIVE\n\n    # Use getaddrinfo to resolve the address, potentially returning multiple addresses\n    try:\n        addrinfo_list = socket.getaddrinfo(\n            address, port, family, socket.SOCK_STREAM, 0, flags\n        )\n    except socket.gaierror as e:\n        # Certain invalid flags or address formats may cause getaddrinfo to fail\n        raise\n\n    sockets = []\n    # We keep track of the addresses we have already bound to avoid duplicates\n    duplicates = set()\n\n    for res in addrinfo_list:\n        af, socktype, proto, canonname, sockaddr = res\n        # Avoid duplicates (e.g., same sockaddr may appear multiple times)\n        if sockaddr in duplicates:\n            continue\n        duplicates.add(sockaddr)\n\n        sock = socket.socket(af, socktype, proto)\n        # Allow reuse of address\n        try:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        except socket.error:\n            # Some platforms (Windows) may raise error here; ignore\n            pass\n\n        if reuse_port:\n            try:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n            except socket.error as e:\n                sock.close()\n                err = errno_from_exception(e)\n                if err in (errno.ENOPROTOOPT, errno.EINVAL):\n                    raise ValueError(\"SO_REUSEPORT not supported or invalid\") from e\n                raise\n\n        try:\n            sock.bind(sockaddr)\n            sock.listen(backlog)\n        except socket.error as e:\n            sock.close()\n            raise\n\n        sockets.append(sock)\n\n    return sockets", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 580, in <module>\n  File \"<string>\", line 579, in test_51\n  File \"<string>\", line 138, in bind_sockets\nOSError: [Errno 98] Address already in use\n", "passed": false}
{"task_id": 254, "prediction_id": 4, "generation": "import socket\nfrom typing import List, Optional\n\nfrom tornado.util import errno_from_exception\n\n\ndef bind_sockets(\n    port: int,\n    address: Optional[str] = None,\n    family: socket.AddressFamily = socket.AF_UNSPEC,\n    backlog: int = 128,\n    flags: Optional[int] = None,\n    reuse_port: bool = False,\n) -> List[socket.socket]:\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen()`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    if flags is None:\n        flags = socket.AI_PASSIVE\n\n    # Use getaddrinfo to get a list of address info tuples\n    try:\n        addrinfo_list = socket.getaddrinfo(\n            address,\n            port,\n            family,\n            socket.SOCK_STREAM,\n            0,\n            flags,\n        )\n    except socket.gaierror as e:\n        # Raise the same exception, user can handle it\n        raise e\n\n    sockets = []\n    for res in addrinfo_list:\n        af, socktype, proto, canonname, sa = res\n        sock = None\n        try:\n            sock = socket.socket(af, socktype, proto)\n            # Set socket options to reuse address\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            if reuse_port:\n                # SO_REUSEPORT might not be available on all systems\n                if not hasattr(socket, \"SO_REUSEPORT\"):\n                    sock.close()\n                    raise ValueError(\"SO_REUSEPORT is not supported on this platform\")\n                try:\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n                except OSError as e:\n                    # On some systems setting SO_REUSEPORT can fail\n                    sock.close()\n                    raise ValueError(\"SO_REUSEPORT is not supported on this platform\") from e\n\n            # Bind the socket\n            sock.bind(sa)\n            sock.listen(backlog)\n            sockets.append(sock)\n        except Exception as e:\n            if sock is not None:\n                sock.close()\n            # If error is EADDRINUSE (address already in use), continue with others\n            # Otherwise raise immediately\n            err = errno_from_exception(e)\n            if err == errno.EADDRINUSE:\n                continue\n            raise\n\n    if not sockets:\n        raise RuntimeError(f\"Could not bind any sockets for {address or '*'}:{port}\")\n\n    return sockets", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 584, in <module>\n  File \"<string>\", line 583, in test_72\n  File \"<string>\", line 130, in bind_sockets\nOSError: [Errno 99] Cannot assign requested address\n", "passed": false}
