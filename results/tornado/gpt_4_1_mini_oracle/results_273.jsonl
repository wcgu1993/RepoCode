{"task_id": 273, "prediction_id": 0, "generation": "from typing import Optional, Tuple\n\ndef _parse_request_range(\n    range_header: str,\n) -> Optional[Tuple[Optional[int], Optional[int]]]:\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n    def _int_or_none(val: str) -> Optional[int]:\n        val = val.strip()\n        if val == \"\":\n            return None\n        return int(val)\n\n    if not range_header.startswith(\"bytes=\"):\n        return None\n\n    ranges_spec = range_header[6:].strip()\n    # Only support one range, reject multiple\n    if \",\" in ranges_spec:\n        return None\n\n    # If empty after \"bytes=\" return (None, None)\n    if ranges_spec == \"\":\n        return (None, None)\n\n    # Parse the single range format: start-end\n    # Note: either start or end may be omitted as per HTTP spec\n\n    start_str, sep, end_str = ranges_spec.partition(\"-\")\n    # If no '-' found, invalid range\n    if sep == \"\":\n        return None\n\n    if start_str == \"\" and end_str == \"\":\n        # \"bytes=-\" - invalid\n        return None\n\n    if start_str == \"\":\n        # suffix-byte-range-spec: \"bytes=-<suffix-length>\"\n        suffix_length = _int_or_none(end_str)\n        if suffix_length is None:\n            return None\n        if suffix_length == 0:\n            # Special case from doctests: bytes=-0 => (None, 0)\n            return (None, 0)\n        return (-suffix_length, None)\n    else:\n        start = _int_or_none(start_str)\n        if start is None:\n            return None\n        if end_str == \"\":\n            # open-ended: bytes=<start>-\n            return (start, None)\n        else:\n            end = _int_or_none(end_str)\n            if end is None:\n                return None\n            # Convert inclusive end position to exclusive end index for slicing (+1)\n            return (start, end + 1)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1204, in <module>\n  File \"<string>\", line 1203, in test_16\nTypeError: 'NoneType' object is not subscriptable\n", "passed": false}
{"task_id": 273, "prediction_id": 1, "generation": "from typing import Optional, Tuple\n\n\ndef _int_or_none(val: str) -> Optional[int]:\n    val = val.strip()\n    if val == \"\":\n        return None\n    return int(val)\n\n\ndef _parse_request_range(\n    range_header: str,\n) -> Optional[Tuple[Optional[int], Optional[int]]]:\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n    if not range_header.startswith(\"bytes=\"):\n        return None\n\n    ranges_str = range_header[6:].strip()\n    if not ranges_str:\n        return (None, None)\n\n    # Only support a single range\n    if \",\" in ranges_str:\n        return None\n\n    if '-' not in ranges_str:\n        return None\n\n    start_str, end_str = ranges_str.split(\"-\", 1)\n\n    # Handle special case \"bytes=-0\"\n    if start_str == \"\" and end_str == \"0\":\n        # Per examples, returns (None, 0)\n        return (None, 0)\n\n    start = _int_or_none(start_str)\n    end = _int_or_none(end_str)\n\n    # If start is None, it is a suffix range ending at end (which can be None)\n    if start is None:\n        # When suffix range like \"-6\", means last 6 bytes.\n        # We return (-6, None) to indicate that.\n        # If end is also None (like \"bytes=-\"), return (None, None)\n        if end is not None:\n            return (-end, None)\n        else:\n            return (None, None)\n\n    # If start is not None:\n    # The HTTP Range header is inclusive, so convert end to slice end by adding 1\n    if end is None:\n        return (start, None)\n\n    # If end is not None, slice end must be end + 1\n    # Also if end < start, invalid range\n    if end < start:\n        return None\n\n    return (start, end + 1)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1205, in <module>\n  File \"<string>\", line 1204, in test_16\nTypeError: 'NoneType' object is not subscriptable\n", "passed": false}
{"task_id": 273, "prediction_id": 2, "generation": "from typing import Optional, Tuple\n\n\ndef _parse_request_range(\n    range_header: str,\n) -> Optional[Tuple[Optional[int], Optional[int]]]:\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n    def _int_or_none(val: str) -> Optional[int]:\n        val = val.strip()\n        if val == \"\":\n            return None\n        return int(val)\n\n    range_header = range_header.strip()\n    if not range_header.startswith(\"bytes=\"):\n        return None\n    ranges_spec = range_header[6:].strip()\n    if not ranges_spec or \",\" in ranges_spec:\n        # empty or multiple ranges not supported\n        return None\n\n    # Parse the single range spec\n    start_str, sep, end_str = ranges_spec.partition(\"-\")\n    if sep != \"-\":\n        return None\n\n    start = _int_or_none(start_str)\n    end = _int_or_none(end_str)\n\n    if start is None and end is None:\n        # \"bytes=\" with nothing after\n        return (None, None)\n\n    if start is not None and end is not None:\n        # Both start and end present: end is inclusive, but we return slice indexes, so add 1\n        # Validate that start <= end?\n        if end < start:\n            # invalid range\n            return None\n        return (start, end + 1)\n\n    if start is not None and end is None:\n        # bytes=6- : from 6 to end\n        return (start, None)\n\n    if start is None and end is not None:\n        # bytes=-6 : last 6 bytes\n        # Note special case if end == 0 -> means empty range\n        if end == 0:\n            return (None, 0)\n        return (-end, None)\n\n    # Fallback\n    return None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1180, in <module>\n  File \"<string>\", line 1179, in test_6\nAssertionError\n", "passed": false}
{"task_id": 273, "prediction_id": 3, "generation": "from typing import Optional, Tuple\n\ndef _parse_request_range(\n    range_header: str,\n) -> Optional[Tuple[Optional[int], Optional[int]]]:\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n    def _int_or_none(val: str) -> Optional[int]:\n        val = val.strip()\n        if val == \"\":\n            return None\n        return int(val)\n\n    if not range_header.startswith(\"bytes=\"):\n        return None\n\n    # Extract the ranges string after \"bytes=\"\n    ranges_str = range_header[len(\"bytes=\"):].strip()\n    if not ranges_str:\n        return (None, None)\n\n    # Per note: only one range supported, no commas allowed\n    if \",\" in ranges_str:\n        return None\n\n    # Possible range forms:\n    # 1-2 (start-end)\n    # 6- (start-)\n    # -6 (-suffix)\n    # -0 (-0 is special case => None,0)\n\n    start_end = ranges_str.split(\"-\", 1)\n    if len(start_end) != 2:\n        return None\n\n    start_str, end_str = start_end\n    start_str = start_str.strip()\n    end_str = end_str.strip()\n\n    # Case: suffix byte range (e.g. \"-6\")\n    if start_str == \"\":\n        # special case: \"-0\" means (None, 0)\n        if end_str == \"0\":\n            return (None, 0)\n        suffix_length = _int_or_none(end_str)\n        if suffix_length is None:\n            return None\n        return (-suffix_length, None)\n\n    # Case: \"start-\" or \"start-end\"\n    start = _int_or_none(start_str)\n    if start is None:\n        return None\n\n    end = _int_or_none(end_str)\n    if end is None:\n        # \"start-\" form\n        return (start, None)\n    else:\n        # \"start-end\" form\n        # The HTTP Range spec is inclusive for end, so add 1 for Python slice\n        return (start, end + 1)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1207, in <module>\n  File \"<string>\", line 1206, in test_16\nTypeError: 'NoneType' object is not subscriptable\n", "passed": false}
{"task_id": 273, "prediction_id": 4, "generation": "from typing import Optional, Tuple\nfrom tornado.httputil import _int_or_none\n\ndef _parse_request_range(\n    range_header: str,\n) -> Optional[Tuple[Optional[int], Optional[int]]]:\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n    # The Range header must start with \"bytes=\"\n    if not range_header.startswith(\"bytes=\"):\n        return None\n\n    # Remove \"bytes=\" prefix and strip spaces\n    ranges_str = range_header[6:].strip()\n\n    # Reject multiple ranges separated by a comma\n    if \",\" in ranges_str:\n        return None\n\n    # If empty after \"bytes=\", return (None, None)\n    if ranges_str == \"\":\n        return None, None\n\n    parts = ranges_str.split(\"-\", 1)\n    if len(parts) != 2:\n        return None\n\n    start_str, end_str = parts[0].strip(), parts[1].strip()\n\n    # Case 1: \"-suffix-length\" e.g. \"-6\" or \"-0\"\n    if start_str == \"\":\n        # According to RFC, \"-0\" means the last 0 bytes (special case)\n        if end_str == \"0\":\n            return (None, 0)\n\n        suffix_length = _int_or_none(end_str)\n        if suffix_length is None:\n            # Malformed range\n            return None\n        return (-suffix_length, None)\n\n    # Case 2: \"start-\" or \"start-end\"\n    start = _int_or_none(start_str)\n    if start is None or start < 0:\n        return None\n\n    if end_str == \"\":\n        # open ended range \"start-\"\n        return (start, None)\n\n    end = _int_or_none(end_str)\n    if end is None or end < start:\n        return None\n\n    # Adjust end to be exclusive for slicing (end + 1)\n    return (start, end + 1)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 1201, in <module>\n  File \"<string>\", line 1200, in test_16\nTypeError: 'NoneType' object is not subscriptable\n", "passed": false}
