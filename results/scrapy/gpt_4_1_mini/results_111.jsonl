{"task_id": 111, "prediction_id": 0, "generation": "from twisted.internet import defer\n\n\ndef defers(func):\n    \"\"\"Decorator to make sure a function always returns a deferred\"\"\"\n    @defer.inlineCallbacks\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        if isinstance(result, defer.Deferred):\n            res = yield result\n        elif hasattr(result, '__await__') or hasattr(result, '__iter__'):\n            # Covers coroutine or async generator (async iterables)\n            d = defer.Deferred()\n\n            def run_coro():\n                try:\n                    coro = result if hasattr(result, '__await__') else result.__aiter__()\n                    future = defer.ensureDeferred(result)\n                    future.addCallbacks(d.callback, d.errback)\n                except Exception as e:\n                    d.errback(e)\n\n            run_coro()\n            res = yield d\n        else:\n            res = result\n        defer.returnValue(res)\n    return wrapper", "message": "passed", "passed": true}
{"task_id": 111, "prediction_id": 1, "generation": "from twisted.internet import defer\n\ndef defers(func):\n    \"\"\"Decorator to make sure a function always returns a deferred\"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            result = func(*args, **kwargs)\n        except Exception as e:\n            return defer.fail(e)\n        if isinstance(result, defer.Deferred):\n            return result\n        else:\n            return defer.succeed(result)\n    return wrapper", "message": "passed", "passed": true}
{"task_id": 111, "prediction_id": 2, "generation": "from twisted.internet import defer\n\n\ndef defers(func):\n    \"\"\"Decorator to make sure a function always returns a deferred\"\"\"\n    @defer.inlineCallbacks\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        # If result is already a Deferred, yield it and return its result\n        if isinstance(result, defer.Deferred):\n            res = yield result\n            return res\n        # If result is a coroutine or asyncgen, use mustbe_deferred to get Deferred\n        try:\n            from scrapy.utils.defer import mustbe_deferred\n        except ImportError:\n            # fallback if scrapy.utils.defer is unavailable\n            mustbe_deferred = None\n\n        if mustbe_deferred is not None:\n            d = mustbe_deferred(lambda: result)\n            res = yield d\n            return res\n        else:\n            # If no mustbe_deferred available, just return result directly\n            return result\n\n    return wrapper", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 136, in <module>\n  File \"<string>\", line 135, in test_14\nAttributeError: 'Deferred' object has no attribute 'result'\n", "passed": false}
{"task_id": 111, "prediction_id": 3, "generation": "from twisted.internet import defer\n\n\ndef defers(func):\n    \"\"\"Decorator to make sure a function always returns a deferred\"\"\"\n    @defer.inlineCallbacks\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        # If the function returns a deferred already, yield it to get its result\n        if isinstance(result, defer.Deferred):\n            result = yield result\n        # Otherwise, if it is a coroutine or async generator, mustbe_deferred from context would help,\n        # but since we can't import it here, just yield result works to adapt inlineCallbacks\n        return result\n    return wrapper", "message": "passed", "passed": true}
{"task_id": 111, "prediction_id": 4, "generation": "from twisted.internet import defer\n\n\ndef defers(func):\n    \"\"\"Decorator to make sure a function always returns a deferred\"\"\"\n    @defer.inlineCallbacks\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        # If result is already a Deferred, yield it, else wrap in a Deferred\n        if isinstance(result, defer.Deferred):\n            res = yield result\n        else:\n            res = result\n        defer.returnValue(res)\n\n    return wrapper", "message": "passed", "passed": true}
