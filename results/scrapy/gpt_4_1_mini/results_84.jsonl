{"task_id": 84, "prediction_id": 0, "generation": "from twisted.internet import defer\nfrom scrapy.utils.defer import mustbe_deferred, parallel\n\n\ndef process_parallel(callbacks, input, *a, **kw):\n    \"\"\"Return a Deferred with the output of all successful calls to the given\n    callbacks\n    \"\"\"\n    if not callbacks:\n        return defer_succeed([])  # Return an immediate Deferred with empty list\n\n    def run_callback(cb):\n        # Wrap each callback call with mustbe_deferred to handle sync/async\n        return mustbe_deferred(cb, input, *a, **kw)\n\n    dlist = parallel(callbacks, len(callbacks), run_callback)\n\n    def gather_successful(results):\n        # results is a list of (success_boolean, result) tuples from DeferredList\n        successful_results = [res for success, res in results if success]\n        return successful_results\n\n    dlist.addCallback(gather_successful)\n    return dlist\n\n\ndef defer_succeed(result):\n    \"\"\"Delayed succeed Deferred, as defined in file content\"\"\"\n    from twisted.internet import reactor\n    d = defer.Deferred()\n    reactor.callLater(0.1, d.callback, result)\n    return d", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 219, in <module>\n  File \"<string>\", line 218, in test_4\nAttributeError: 'DeferredList' object has no attribute 'result'\n", "passed": false}
{"task_id": 84, "prediction_id": 1, "generation": "from twisted.internet import defer\nfrom scrapy.utils.defer import parallel\n\n\ndef process_parallel(callbacks, input, *a, **kw):\n    \"\"\"Return a Deferred with the output of all successful calls to the given\n    callbacks\n    \"\"\"\n    # Define a wrapper that applies each callback to the input with additional args/kwargs\n    def call_callback(cb):\n        return cb(input, *a, **kw)\n\n    # Run all callbacks in parallel with as many concurrent calls as the number of callbacks\n    dlist = parallel(callbacks, len(callbacks), call_callback)\n\n    # Filter only the successful results:\n    # DeferredList returns list of (success, result),\n    # we take only those where success is True\n    def only_successful(results):\n        return [result for success, result in results if success]\n\n    dlist.addCallback(only_successful)\n    return dlist", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 210, in <module>\n  File \"<string>\", line 209, in test_4\nAttributeError: 'DeferredList' object has no attribute 'result'\n", "passed": false}
{"task_id": 84, "prediction_id": 2, "generation": "from twisted.internet import defer\nfrom scrapy.utils.defer import mustbe_deferred, parallel\n\ndef process_parallel(callbacks, input, *a, **kw):\n    \"\"\"Return a Deferred with the output of all successful calls to the given\n    callbacks\n    \"\"\"\n    if not callbacks:\n        # No callbacks: return a Deferred that immediately fires with an empty list\n        d = defer.Deferred()\n        d.callback([])\n        return d\n\n    # Define a function that calls one callback with input and extra args,\n    # wrapped with mustbe_deferred to ensure a Deferred result\n    def call_callback(cb):\n        return mustbe_deferred(cb, input, *a, **kw)\n\n    # Use parallel to run call_callback for all callbacks.\n    # We run as many concurrent calls as the number of callbacks (all in parallel)\n    dlist = parallel(callbacks, len(callbacks), call_callback)\n\n    # dlist results is a list of (success, result) tuples; we want only successful results\n    def filter_success(results):\n        return [res for success, res in results if success]\n\n    return dlist.addCallback(filter_success)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 214, in <module>\n  File \"<string>\", line 213, in test_4\nAttributeError: 'DeferredList' object has no attribute 'result'\n", "passed": false}
{"task_id": 84, "prediction_id": 3, "generation": "from twisted.internet import defer\nfrom scrapy.utils.defer import process_chain\n\n\ndef process_parallel(callbacks, input, *a, **kw):\n    \"\"\"Return a Deferred with the output of all successful calls to the given\n    callbacks\n    \"\"\"\n    # Chain the given callbacks sequentially over the input using process_chain\n    d = process_chain(callbacks, input, *a, **kw)\n\n    # Prepare a Deferred to gather all successful callback results\n    result_deferred = defer.Deferred()\n\n    def gather_results(results):\n        # results is a tuple (success, value)\n        success, values = results\n        # values is a list of (success, result) tuples from DeferredList\n        # Extract successful results only\n        succeeded_results = [r for ok, r in values if ok]\n        result_deferred.callback(succeeded_results)\n        return succeeded_results\n\n    def err_handler(failure):\n        # On error, errback with the failure as is\n        result_deferred.errback(failure)\n        return failure\n\n    # Once the chain completes, values are passed to a DeferredList\n    chain_dl = defer.DeferredList([d])\n    chain_dl.addCallback(gather_results).addErrback(err_handler)\n\n    # Return the Deferred that will callback with all successful results\n    return result_deferred", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 221, in <module>\n  File \"<string>\", line 220, in test_4\nTypeError: object of type 'Failure' has no len()\n", "passed": false}
{"task_id": 84, "prediction_id": 4, "generation": "from twisted.internet import defer\nfrom scrapy.utils.defer import process_chain\n\ndef process_parallel(callbacks, input, *a, **kw):\n    \"\"\"Return a Deferred with the output of all successful calls to the given\n    callbacks\n    \"\"\"\n    # Create a list to hold Deferreds for each callback result\n    deferreds = []\n\n    # For each callback, process chaining with given input and arguments,\n    # this returns a Deferred that fires with the callback's output\n    for cb in callbacks:\n        d = process_chain([cb], input, *a, **kw)\n        deferreds.append(d)\n\n    # Gather results using DeferredList, but only succeed if all callbacks succeed\n    # errbacks will cause failures in the resulting Deferred\n    dl = defer.DeferredList(deferreds, consumeErrors=True)\n\n    # We want only the successful callback results,\n    # so filter out failures from DeferredList result\n    def filter_success(results):\n        # results: list of (success, value) tuples\n        return [res for success, res in results if success]\n\n    dl.addCallback(filter_success)\n    return dl", "message": "passed", "passed": true}
