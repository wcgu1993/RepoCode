{"task_id": 68, "prediction_id": 0, "generation": "import re\n\ndef _has_ajaxcrawlable_meta(text):\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    # We need to detect a <meta name=\"fragment\" content=\"!\"> tag that is not inside HTML comments.\n    # The tag can use single or double quotes, and there may be spaces around attributes.\n    # The best approach is to remove HTML comments first, then search for the tag.\n\n    # Remove HTML comments to avoid false positives inside comments\n    uncommented_text = re.sub(r'<!--.*?-->', '', text, flags=re.DOTALL)\n\n    # Now search for the meta tag with name=\"fragment\" and content=\"!\"\n    # Attributes order might vary, so we'll look for something like:\n    # <meta ... name=\"fragment\" ... content=\"!\" ... > in any order\n    # We'll use a regex to check if there is a meta tag with those attributes.\n\n    meta_re = re.compile(\n        r'<meta\\b[^>]*\\bname\\s*=\\s*[\"\\']fragment[\"\\'][^>]*\\bcontent\\s*=\\s*[\"\\']![\"\\'][^>]*/?\\s*>',\n        flags=re.IGNORECASE\n    )\n\n    return bool(meta_re.search(uncommented_text))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 200, in <module>\n  File \"<string>\", line 199, in test_24\nAssertionError\n", "passed": false}
{"task_id": 68, "prediction_id": 1, "generation": "import re\n\ndef _has_ajaxcrawlable_meta(text):\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    # This regex matches <meta name=\"fragment\" content=\"!\"/> or similar\n    # but avoids matching inside HTML comments.\n    # Approach:\n    # 1. Remove all HTML comments first.\n    # 2. Search for the meta tag in the cleaned text.\n\n    # Remove HTML comments to avoid false positives inside comments\n    no_comments = re.sub(r'<!--.*?-->', '', text, flags=re.DOTALL | re.IGNORECASE)\n\n    # Compile the pattern to match <meta name=\"fragment\" content=\"!\"/> with optional spaces & quote styles\n    pattern = re.compile(\n        r'<meta\\s+[^>]*name\\s*=\\s*[\"\\']fragment[\"\\'][^>]*content\\s*=\\s*[\"\\']![\"\\'][^>]*?/?>',\n        re.IGNORECASE\n    )\n\n    return bool(pattern.search(no_comments))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 198, in <module>\n  File \"<string>\", line 197, in test_24\nAssertionError\n", "passed": false}
{"task_id": 68, "prediction_id": 2, "generation": "import re\n\ndef _has_ajaxcrawlable_meta(text):\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    # Pattern that matches a meta tag with name=\"fragment\" and content=\"!\"\n    # but only if it's not inside an HTML comment.\n    # Approach:\n    # 1. Remove HTML comments from text\n    # 2. Search for the meta tag in the uncommented text\n\n    # Remove HTML comments (including multiline)\n    uncommented_text = re.sub(r'<!--.*?-->', '', text, flags=re.DOTALL | re.IGNORECASE)\n\n    # Regex that matches <meta name=\"fragment\" content=\"!\"/> or with single quotes and optional spaces\n    pattern = re.compile(\n        r'<meta\\s+[^>]*name\\s*=\\s*([\"\\'])fragment\\1\\s+[^>]*content\\s*=\\s*([\"\\'])!\\2[^>]*\\/?>',\n        re.IGNORECASE\n    )\n\n    return bool(pattern.search(uncommented_text))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 198, in <module>\n  File \"<string>\", line 197, in test_24\nAssertionError\n", "passed": false}
{"task_id": 68, "prediction_id": 3, "generation": "import re\n\n_ajax_crawlable_re = re.compile(\n    r'<meta\\s+name=[\"\\']fragment[\"\\']\\s+content=[\"\\']![\"\\']/?>',\n    re.IGNORECASE\n)\n\ndef _has_ajaxcrawlable_meta(text):\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    # Remove HTML comments first so we do not detect fragment meta tags inside comments\n    # This is a simple regex removal of comments; not perfect for nested comments but adequate here.\n    uncommented_text = re.sub(r'<!--.*?-->', '', text, flags=re.DOTALL)\n\n    # Search for the meta tag in uncommented text\n    return bool(_ajax_crawlable_re.search(uncommented_text))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 193, in <module>\n  File \"<string>\", line 192, in test_24\nAssertionError\n", "passed": false}
{"task_id": 68, "prediction_id": 4, "generation": "import re\n\ndef _has_ajaxcrawlable_meta(text):\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    # The function must detect a meta tag with: name=\"fragment\" and content=\"!\"\n    # It must not match meta tags that are inside HTML comments.\n\n    # Strategy:\n    # 1. Remove all HTML comments from text\n    # 2. Search for <meta ... name=\"fragment\" ... content=\"!\" ... />\n    #    The quotes can be ' or \"\n    #    Order of attributes is not guaranteed.\n    #    Attributes can have multiple spaces, and can have other attributes as well.\n\n    # Remove comments (<!-- ... -->)\n    text_no_comments = re.sub(r'<!--.*?-->', '', text, flags=re.DOTALL|re.IGNORECASE)\n\n    # Regex to match a meta tag with attributes containing name=\"fragment\" and content=\"!\"\n    # Match <meta ...> tags\n    # We'll capture all attributes then check if they contain the required attrs.\n    # Alternatively, use a regex that matches the pattern directly.\n\n    # regex to match <meta ...> tags (non-greedy for attributes)\n    meta_tags = re.findall(r'<meta\\s+([^>]+?)\\s*/?>', text_no_comments, flags=re.IGNORECASE)\n\n    for attrs_str in meta_tags:\n        # Search for name and content attributes in attrs_str\n\n        # Extract attributes as key=value pairs (naive but sufficient)\n        # Attributes can be unquoted, but usually quoted. We'll search for name and content.\n\n        # regex to find all attributes: key=\"value\" or key='value' or key=value (unquoted)\n        # we only care about name and content in this case.\n        attrs = dict(re.findall(r'(\\w+)\\s*=\\s*(\".*?\"|\\'.*?\\'|[^\\s\"\\'>]+)', attrs_str, flags=re.IGNORECASE))\n\n        # Normalize the attribute values by stripping quotes\n        for k in attrs:\n            val = attrs[k]\n            if (val.startswith('\"') and val.endswith('\"')) or (val.startswith(\"'\") and val.endswith(\"'\")):\n                attrs[k] = val[1:-1].strip()\n            else:\n                attrs[k] = val.strip()\n\n        # Check if name attribute equals 'fragment' (case-insensitive)\n        # and content attribute equals '!'\n        if 'name' in attrs and 'content' in attrs:\n            if attrs['name'].lower() == 'fragment' and attrs['content'] == '!':\n                return True\n\n    return False", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 228, in <module>\n  File \"<string>\", line 227, in test_24\nAssertionError\n", "passed": false}
