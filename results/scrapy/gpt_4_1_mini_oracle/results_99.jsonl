{"task_id": 99, "prediction_id": 0, "generation": "from urllib.parse import urlparse, urlunparse, parse_qsl, urlencode, quote\n\ndef escape_ajax(url):\n    \"\"\"\n    Return the crawleable url according to:\n    https://developers.google.com/webmasters/ajax-crawling/docs/getting-started\n\n    >>> escape_ajax(\"www.example.com/ajax.html#!key=value\")\n    'www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html?k1=v1&k2=v2#!key=value\")\n    'www.example.com/ajax.html?k1=v1&k2=v2&_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html?#!key=value\")\n    'www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html#!\")\n    'www.example.com/ajax.html?_escaped_fragment_='\n\n    URLs that are not \"AJAX crawlable\" (according to Google) returned as-is:\n\n    >>> escape_ajax(\"www.example.com/ajax.html#key=value\")\n    'www.example.com/ajax.html#key=value'\n    >>> escape_ajax(\"www.example.com/ajax.html#\")\n    'www.example.com/ajax.html#'\n    >>> escape_ajax(\"www.example.com/ajax.html\")\n    'www.example.com/ajax.html'\n    \"\"\"\n    parsed = urlparse(url)\n    fragment = parsed.fragment\n\n    # Only transform if fragment starts with '!'\n    if not fragment.startswith('!'):\n        return url\n\n    # Extract the fragment content after '!'\n    escaped_fragment_value = fragment[1:]  # could be empty string\n    \n    # Percent-encode the escaped fragment value\n    escaped_fragment_value = quote(escaped_fragment_value, safe='')\n\n    # Parse existing query parameters\n    query_params = parse_qsl(parsed.query, keep_blank_values=True)\n    # Append or replace _escaped_fragment_ param\n    # Remove any existing _escaped_fragment_ params first for safety\n    query_params = [(k, v) for k, v in query_params if k != '_escaped_fragment_']\n    query_params.append(('_escaped_fragment_', escaped_fragment_value))\n\n    new_query = urlencode(query_params, doseq=True)\n\n    # Build new URL without fragment and with updated query\n    new_parsed = parsed._replace(query=new_query, fragment='')\n    return urlunparse(new_parsed)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 209, in <module>\n  File \"<string>\", line 207, in test_0\nAssertionError\n", "passed": false}
{"task_id": 99, "prediction_id": 1, "generation": "from urllib.parse import urlparse, urlunparse, parse_qsl, urlencode, quote\n\ndef escape_ajax(url):\n    \"\"\"\n    Return the crawleable url according to:\n    https://developers.google.com/webmasters/ajax-crawling/docs/getting-started\n\n    >>> escape_ajax(\"www.example.com/ajax.html#!key=value\")\n    'www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html?k1=v1&k2=v2#!key=value\")\n    'www.example.com/ajax.html?k1=v1&k2=v2&_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html?#!key=value\")\n    'www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html#!\")\n    'www.example.com/ajax.html?_escaped_fragment_='\n\n    URLs that are not \"AJAX crawlable\" (according to Google) returned as-is:\n\n    >>> escape_ajax(\"www.example.com/ajax.html#key=value\")\n    'www.example.com/ajax.html#key=value'\n    >>> escape_ajax(\"www.example.com/ajax.html#\")\n    'www.example.com/ajax.html#'\n    >>> escape_ajax(\"www.example.com/ajax.html\")\n    'www.example.com/ajax.html'\n    \"\"\"\n    # Parse URL without scheme (to handle URLs like 'www.example.com/...')\n    # If scheme is missing, urlparse incorrectly puts the entire url in path.\n    # Add a dummy scheme if missing and remove it later.\n    dummy_scheme = ''\n    if '://' not in url:\n        dummy_scheme = 'http://'\n        parsed = urlparse(dummy_scheme + url)\n    else:\n        parsed = urlparse(url)\n\n    fragment = parsed.fragment\n\n    # Check if fragment starts with '!' meaning Ajax crawlable\n    if not fragment.startswith('!'):\n        # Return original url as-is\n        return url\n\n    # Get fragment content after '!'\n    escaped_fragment = fragment[1:]  # can be empty string\n\n    # Build new query dict by preserving existing ones and adding _escaped_fragment_\n    query_pairs = parse_qsl(parsed.query, keep_blank_values=True)\n    # Append the _escaped_fragment_ parameter; value must be URL-encoded\n    # But urlencode will encode it, so just pass raw string\n    query_pairs.append((\"_escaped_fragment_\", escaped_fragment))\n\n    # Encode query string with all parameters\n    new_query = urlencode(query_pairs, doseq=True)\n\n    # Rebuild the URL without the fragment, using the new query string\n    new_parts = (\n        parsed.scheme,\n        parsed.netloc,\n        parsed.path,\n        parsed.params,\n        new_query,\n        ''  # empty fragment\n    )\n    rebuilt = urlunparse(new_parts)\n\n    # Remove dummy scheme if added\n    if dummy_scheme:\n        rebuilt = rebuilt[len(dummy_scheme):]\n\n    return rebuilt", "message": "passed", "passed": true}
{"task_id": 99, "prediction_id": 2, "generation": "from urllib.parse import urlparse, urlunparse, parse_qsl, urlencode, quote\n\n\ndef escape_ajax(url):\n    \"\"\"\n    Return the crawleable url according to:\n    https://developers.google.com/webmasters/ajax-crawling/docs/getting-started\n\n    >>> escape_ajax(\"www.example.com/ajax.html#!key=value\")\n    'www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html?k1=v1&k2=v2#!key=value\")\n    'www.example.com/ajax.html?k1=v1&k2=v2&_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html?#!key=value\")\n    'www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html#!\")\n    'www.example.com/ajax.html?_escaped_fragment_='\n\n    URLs that are not \"AJAX crawlable\" (according to Google) returned as-is:\n\n    >>> escape_ajax(\"www.example.com/ajax.html#key=value\")\n    'www.example.com/ajax.html#key=value'\n    >>> escape_ajax(\"www.example.com/ajax.html#\")\n    'www.example.com/ajax.html#'\n    >>> escape_ajax(\"www.example.com/ajax.html\")\n    'www.example.com/ajax.html'\n    \"\"\"\n    parsed = urlparse(url)\n\n    fragment = parsed.fragment\n\n    # Check if fragment starts with '!'\n    if not fragment.startswith('!'):\n        # Not an AJAX crawlable fragment according to Google, return as is\n        return url\n\n    # Extract the escaped fragment part (after '!')\n    escaped_fragment = fragment[1:]\n\n    # Prepare the new query string\n    # parse existing query parameters into a list\n    query_params = parse_qsl(parsed.query, keep_blank_values=True)\n\n    # Append the _escaped_fragment_ parameter with the URL encoded escaped_fragment value\n    # The value needs to be URL-encoded\n    encoded_escaped_fragment = quote(escaped_fragment, safe='')\n    query_params.append(('_escaped_fragment_', encoded_escaped_fragment))\n\n    # Build new query string with updated params\n    new_query = urlencode(query_params)\n\n    # Remove fragment completely (Google AJAX crawl spec removes the #! fragment)\n    new_parsed = parsed._replace(query=new_query, fragment='')\n\n    return urlunparse(new_parsed)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 213, in <module>\n  File \"<string>\", line 211, in test_0\nAssertionError\n", "passed": false}
{"task_id": 99, "prediction_id": 3, "generation": "from urllib.parse import urlparse, urlunparse, parse_qsl, urlencode, quote\n\ndef escape_ajax(url):\n    \"\"\"\n    Return the crawleable url according to:\n    https://developers.google.com/webmasters/ajax-crawling/docs/getting-started\n\n    >>> escape_ajax(\"www.example.com/ajax.html#!key=value\")\n    'www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html?k1=v1&k2=v2#!key=value\")\n    'www.example.com/ajax.html?k1=v1&k2=v2&_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html?#!key=value\")\n    'www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html#!\")\n    'www.example.com/ajax.html?_escaped_fragment_='\n\n    URLs that are not \"AJAX crawlable\" (according to Google) returned as-is:\n\n    >>> escape_ajax(\"www.example.com/ajax.html#key=value\")\n    'www.example.com/ajax.html#key=value'\n    >>> escape_ajax(\"www.example.com/ajax.html#\")\n    'www.example.com/ajax.html#'\n    >>> escape_ajax(\"www.example.com/ajax.html\")\n    'www.example.com/ajax.html'\n    \"\"\"\n    # Parse the URL to get its components\n    parsed = urlparse(url)\n    fragment = parsed.fragment\n\n    # If fragment starts with '!', we handle escaping:\n    if fragment.startswith('!'):\n        # Remove the leading '!'\n        escaped_fragment = fragment[1:]\n        # Percent-encode the escaped fragment (key=value pair etc.)\n        quoted_fragment = quote(escaped_fragment, safe='')\n\n        # Preserve the query parameters (if any)\n        query_pairs = parse_qsl(parsed.query, keep_blank_values=True)\n        # Add or overwrite the _escaped_fragment_ param\n        query_pairs.append(('_escaped_fragment_', quoted_fragment))\n        new_query = urlencode(query_pairs)\n\n        # Construct a new URL with updated query and empty fragment\n        escaped_url = urlunparse((\n            parsed.scheme,\n            parsed.netloc,\n            parsed.path,\n            parsed.params,\n            new_query,\n            ''  # empty fragment\n        ))\n\n        # Note: If the original URL had no scheme/netloc, urlunparse will produce '///...'\n        # So handle such case by rebuilding from parts\n        if not parsed.scheme and not parsed.netloc:\n            # The original url likely lacks scheme, treat path as netloc+path\n            # This fallback ensures expected output for inputs like \"www.example.com/ajax.html#!key=value\"\n            base = parsed.path\n            if new_query:\n                base += '?' + new_query\n            # no fragment\n            escaped_url = base\n        return escaped_url\n\n    # If fragment does not start with '!', return URL as-is\n    return url", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 225, in <module>\n  File \"<string>\", line 223, in test_0\nAssertionError\n", "passed": false}
{"task_id": 99, "prediction_id": 4, "generation": "from urllib.parse import urlparse, urlunparse, parse_qsl, urlencode, quote\n\n\ndef escape_ajax(url):\n    \"\"\"\n    Return the crawleable url according to:\n    https://developers.google.com/webmasters/ajax-crawling/docs/getting-started\n\n    >>> escape_ajax(\"www.example.com/ajax.html#!key=value\")\n    'www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html?k1=v1&k2=v2#!key=value\")\n    'www.example.com/ajax.html?k1=v1&k2=v2&_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html?#!key=value\")\n    'www.example.com/ajax.html?_escaped_fragment_=key%3Dvalue'\n    >>> escape_ajax(\"www.example.com/ajax.html#!\")\n    'www.example.com/ajax.html?_escaped_fragment_='\n\n    URLs that are not \"AJAX crawlable\" (according to Google) returned as-is:\n\n    >>> escape_ajax(\"www.example.com/ajax.html#key=value\")\n    'www.example.com/ajax.html#key=value'\n    >>> escape_ajax(\"www.example.com/ajax.html#\")\n    'www.example.com/ajax.html#'\n    >>> escape_ajax(\"www.example.com/ajax.html\")\n    'www.example.com/ajax.html'\n    \"\"\"\n    parsed = urlparse(url)\n\n    # The fragment to check is parsed.fragment\n    fragment = parsed.fragment\n\n    # Only if the fragment starts with \"!\" do we modify the URL\n    if not fragment.startswith('!'):\n        # Not an AJAX crawlable URL according to Google's spec\n        return url\n\n    # Remove leading \"!\" from fragment value\n    escaped_fragment_value = fragment[1:]\n\n    # Percent-encode the escaped fragment value\n    # According to Google example, the entire fragment content is encoded.\n    # Use quote with safe='' to ensure full encoding\n    escaped_fragment_value = quote(escaped_fragment_value, safe='')\n\n    # Parse existing query parameters\n    query_pairs = parse_qsl(parsed.query, keep_blank_values=True)\n    # Add the _escaped_fragment_ parameter\n    query_pairs.append(('_escaped_fragment_', escaped_fragment_value))\n\n    # Reconstruct query string\n    new_query = urlencode(query_pairs, doseq=True)\n\n    # Rebuild URL without fragment (fragment removed)\n    rebuilt = parsed._replace(query=new_query, fragment='')\n\n    return urlunparse(rebuilt)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 215, in <module>\n  File \"<string>\", line 213, in test_0\nAssertionError\n", "passed": false}
