{"task_id": 68, "prediction_id": 0, "generation": "import re\n\ndef _has_ajaxcrawlable_meta(text):\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    # Regex to match <meta name=\"fragment\" content=\"!\"/> with optional spaces and quote styles,\n    # and to ensure it is NOT inside an HTML comment.\n    # Approach:\n    # 1) Remove HTML comments first (to avoid matching meta tags inside comments)\n    # 2) Search for the meta tag pattern in the uncommented text.\n    # This approach avoids false positives caused by commented-out meta tags.\n\n    # Remove comments\n    uncommented = re.sub(r'<!--.*?-->', '', text, flags=re.DOTALL|re.IGNORECASE)\n\n    # Meta tag regex pattern:\n    # <meta\\s+name=['\"]fragment['\"]\\s+content=['\"]!['\"]\\s*/?>\n    pattern = re.compile(\n        r'<meta\\s+name\\s*=\\s*[\"\\']fragment[\"\\']\\s+content\\s*=\\s*[\"\\']![\"\\']\\s*/?>',\n        re.IGNORECASE\n    )\n\n    return bool(pattern.search(uncommented))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 200, in <module>\n  File \"<string>\", line 199, in test_24\nAssertionError\n", "passed": false}
{"task_id": 68, "prediction_id": 1, "generation": "import re\n\ndef _has_ajaxcrawlable_meta(text):\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    # Regex to find a <meta> tag with name=\"fragment\" and content=\"!\"\n    # but it might be commented out. We need to ensure the tag is not within an HTML comment.\n    meta_re = re.compile(\n        r'<meta\\s+name=[\\'\"]fragment[\\'\"]\\s+content=[\\'\"]![\\'\"]\\s*/?>', \n        re.IGNORECASE\n    )\n    comment_re = re.compile(r'<!--.*?-->', re.DOTALL)\n\n    # Find all comments and record their spans\n    comments = list(comment_re.finditer(text))\n\n    def inside_comment(pos):\n        for c in comments:\n            if c.start() <= pos <= c.end():\n                return True\n        return False\n\n    # Search for all meta matches\n    for m in meta_re.finditer(text):\n        # Check if the match is inside a comment\n        if not inside_comment(m.start()):\n            return True\n    return False", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 205, in <module>\n  File \"<string>\", line 204, in test_24\nAssertionError\n", "passed": false}
{"task_id": 68, "prediction_id": 2, "generation": "import re\n\ndef _has_ajaxcrawlable_meta(text):\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    # We want to detect a meta tag:\n    # <meta name=\"fragment\" content=\"!\"/>\n    # or\n    # <meta name='fragment' content='!'>\n    # but only if it is not inside an HTML comment.\n    #\n    # Strategy:\n    # 1. Remove HTML comments <!-- ... -->\n    # 2. Search for the meta tag regex in the remaining text\n\n    # Remove comments (including multiline)\n    text_no_comments = re.sub(r'<!--.*?-->', '', text, flags=re.DOTALL)\n\n    # Pattern to match the meta tag (name=\"fragment\" or name='fragment', content=\"!\" or content='!')\n    # Allowing arbitrary attribute order, but per spec usually appears as name then content\n    # We'll consider only the pattern name=\"fragment\" content=\"!\" or name='fragment' content='!'\n    # with possible spaces between attributes and possible self-closing or not\n    meta_tag_re = re.compile(\n        r'<meta\\s+[^>]*name=[\"\\']fragment[\"\\']\\s+[^>]*content=[\"\\']![\"\\'][^>]*>',\n        re.IGNORECASE\n    )\n\n    return bool(meta_tag_re.search(text_no_comments))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 205, in <module>\n  File \"<string>\", line 204, in test_24\nAssertionError\n", "passed": false}
{"task_id": 68, "prediction_id": 3, "generation": "import re\n\ndef _has_ajaxcrawlable_meta(text):\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    # We want to detect a <meta name=\"fragment\" content=\"!\"/> tag that is NOT inside HTML comments.\n    # Basic approach:\n    # 1. Remove HTML comments from text.\n    # 2. Search for the meta tag pattern in the uncommented text.\n    # The regex should be case-insensitive, and allow for mixed single/double quotes and spacing.\n\n    # Remove HTML comments\n    uncommented_text = re.sub(r'<!--.*?-->', '', text, flags=re.DOTALL)\n\n    # Regex pattern for <meta name=\"fragment\" content=\"!\"/> with optional variations in quotes and spacing\n    pattern = re.compile(\n        r'<meta\\s+[^>]*name\\s*=\\s*[\"\\']fragment[\"\\'][^>]*content\\s*=\\s*[\"\\']![\"\\'][^>]*>',\n        re.IGNORECASE\n    )\n\n    return bool(pattern.search(uncommented_text))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 198, in <module>\n  File \"<string>\", line 197, in test_24\nAssertionError\n", "passed": false}
{"task_id": 68, "prediction_id": 4, "generation": "import re\n\ndef _has_ajaxcrawlable_meta(text):\n    \"\"\"\n    >>> _has_ajaxcrawlable_meta('<html><head><meta name=\"fragment\"  content=\"!\"/></head><body></body></html>')\n    True\n    >>> _has_ajaxcrawlable_meta(\"<html><head><meta name='fragment' content='!'></head></html>\")\n    True\n    >>> _has_ajaxcrawlable_meta('<html><head><!--<meta name=\"fragment\"  content=\"!\"/>--></head><body></body></html>')\n    False\n    >>> _has_ajaxcrawlable_meta('<html></html>')\n    False\n    \"\"\"\n    # The key is to detect the meta tag <meta name=\"fragment\" content=\"!\"/>\n    # but avoid matches inside HTML comments as that would mean it's not active\n    \n    # Remove HTML comments completely so that meta tags inside comments are not detected\n    # This avoids false positives where the meta tag is commented out.\n    uncommented = re.sub(r'<!--.*?-->', '', text, flags=re.DOTALL)\n    \n    # Now check for the AJAX-crawlable meta tag in the uncommented text\n    # The pattern matches meta tag with name=\"fragment\" or name='fragment'\n    # and content=\"!\" or content='!'\n    pattern = re.compile(\n        r'<meta\\s+[^>]*name\\s*=\\s*[\"\\']fragment[\"\\']\\s+[^>]*content\\s*=\\s*[\"\\']![\"\\'][^>]*/?>',\n        re.IGNORECASE\n    )\n    return bool(pattern.search(uncommented))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 197, in <module>\n  File \"<string>\", line 196, in test_24\nAssertionError\n", "passed": false}
