{"task_id": 112, "prediction_id": 0, "generation": "def potential_domain_matches(domain):\n    \"\"\"Potential domain matches for a cookie\n\n    >>> potential_domain_matches('www.example.com')\n    ['www.example.com', 'example.com', '.www.example.com', '.example.com']\n\n    \"\"\"\n    # This function should return a list of potential domain matches for cookie matching.\n    # According to the example, for 'www.example.com', it returns:\n    # ['www.example.com', 'example.com', '.www.example.com', '.example.com']\n    #\n    # So it includes:\n    # - the domain itself\n    # - the domain without the first label (e.g. example.com)\n    # - both of these prefixed with a dot.\n    #\n    # Plan:\n    # 1. Split the domain into labels by '.'\n    # 2. If there is more than one label, strip the first label (subdomain) to get the parent domain.\n    # 3. Construct the list with:\n    #    - full domain\n    #    - parent domain (if different from full)\n    #    - dot-prefixed full domain\n    #    - dot-prefixed parent domain (if different)\n    #\n    # 4. Remove duplicates if any.\n    # 5. Return the list in order as per example.\n\n    labels = domain.split('.')\n    # If domain has only one label, e.g. 'localhost', then parent domain is itself\n    if len(labels) > 1:\n        parent_domain = '.'.join(labels[1:])\n    else:\n        parent_domain = domain\n\n    results = [domain]\n    if parent_domain != domain:\n        results.append(parent_domain)\n\n    results += ['.' + d for d in results]\n\n    return results", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 263, in <module>\n  File \"<string>\", line 262, in test_11\nAssertionError\n", "passed": false}
{"task_id": 112, "prediction_id": 1, "generation": "def potential_domain_matches(domain):\n    \"\"\"Potential domain matches for a cookie\n\n    >>> potential_domain_matches('www.example.com')\n    ['www.example.com', 'example.com', '.www.example.com', '.example.com']\n\n    \"\"\"\n    parts = domain.split('.')\n    matches = []\n    # Generate all suffix domains, starting from the full domain,\n    # stripping off leftmost parts one by one as long as result has >1 part\n    for i in range(len(parts) - 1):\n        subdomain = '.'.join(parts[i:])\n        matches.append(subdomain)\n\n    # Append versions prefixed with dot for each generated domain\n    dot_matches = ['.' + m for m in matches]\n\n    return matches + dot_matches", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 373, in <module>\n  File \"<string>\", line 371, in test_92\nAssertionError\n", "passed": false}
{"task_id": 112, "prediction_id": 2, "generation": "def potential_domain_matches(domain):\n    \"\"\"Potential domain matches for a cookie\n\n    >>> potential_domain_matches('www.example.com')\n    ['www.example.com', 'example.com', '.www.example.com', '.example.com']\n\n    \"\"\"\n    parts = domain.split('.')\n    matches = []\n\n    # For domains with at least two parts, generate matches by stripping leading parts\n    # and adding both the normal and dot-prefixed version of each.\n    for i in range(len(parts) - 1):\n        subdomain = '.'.join(parts[i:])\n        matches.append(subdomain)\n    # Also add dot-prefixed versions for all except the full domain for non-empty string\n    matches += ['.' + m for m in matches]\n\n    return matches", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 373, in <module>\n  File \"<string>\", line 371, in test_92\nAssertionError\n", "passed": false}
{"task_id": 112, "prediction_id": 3, "generation": "def potential_domain_matches(domain):\n    \"\"\"Potential domain matches for a cookie\n\n    >>> potential_domain_matches('www.example.com')\n    ['www.example.com', 'example.com', '.www.example.com', '.example.com']\n\n    \"\"\"\n    # Split the domain into parts\n    parts = domain.split('.')\n    matches = []\n\n    # For domains with at least two parts, create variations by progressively removing the left-most label\n    for i in range(len(parts) - 1):\n        sub_domain = '.'.join(parts[i:])\n        matches.append(sub_domain)\n    # Also include the entire domain itself if not already included (usually is in above loop)\n    if domain not in matches:\n        matches.append(domain)\n\n    # Add dot-prefixed versions for each match\n    matches_with_dot = matches + ['.' + m for m in matches]\n\n    # Remove duplicates while preserving order\n    seen = set()\n    result = []\n    for m in matches_with_dot:\n        if m not in seen:\n            seen.add(m)\n            result.append(m)\n\n    return result", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 408, in <module>\n  File \"<string>\", line 407, in test_2\nAssertionError\n", "passed": false}
{"task_id": 112, "prediction_id": 4, "generation": "def potential_domain_matches(domain):\n    \"\"\"Potential domain matches for a cookie\n\n    >>> potential_domain_matches('www.example.com')\n    ['www.example.com', 'example.com', '.www.example.com', '.example.com']\n\n    \"\"\"\n    parts = domain.split('.')\n    matches = []\n    # Collect domain and its superdomains\n    for i in range(len(parts) - 1):\n        subdomain = '.'.join(parts[i:])\n        matches.append(subdomain)\n    # Also add the full domain\n    matches.append(domain)\n    # Remove duplicates and sort them by length descending, preserving original order\n    seen = set()\n    ordered_matches = []\n    for d in matches:\n        if d not in seen:\n            seen.add(d)\n            ordered_matches.append(d)\n    # Now add the dot-prefixed versions of all above domains (except those already starting with dot)\n    with_dots = []\n    for d in ordered_matches:\n        with_dots.append(d)\n    for d in ordered_matches:\n        if not d.startswith('.'):\n            with_dots.append('.' + d)\n    return with_dots", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 407, in <module>\n  File \"<string>\", line 406, in test_2\nAssertionError\n", "passed": false}
