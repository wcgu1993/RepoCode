{"task_id": 92, "prediction_id": 0, "generation": "from operator import itemgetter\nfrom collections import defaultdict\nfrom time import time\nfrom weakref import WeakKeyDictionary\n\ndef format_live_refs(ignore=NoneType):\n    \"\"\"Return a tabular representation of tracked objects\"\"\"\n    rows = []\n    for cls, refs in live_refs.items():\n        if ignore is not None and cls is ignore:\n            continue\n        count = len(refs)\n        if count == 0:\n            continue\n        # Find the earliest creation time among live instances\n        first_created = min(refs.values())\n        # Calculate the age in seconds\n        age = time() - first_created\n        rows.append((cls.__name__, count, age))\n    # Sort by class name\n    rows.sort(key=itemgetter(0))\n    # Format header and rows in a tabular string output\n    lines = [f\"{'Class':<25} {'Count':>10} {'Age(seconds)':>15}\"]\n    for cls_name, count, age in rows:\n        lines.append(f\"{cls_name:<25} {count:>10} {age:>15.2f}\")\n    return \"\\n\".join(lines)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 108, in <module>\n  File \"<string>\", line 107, in test_8\nAssertionError\n", "passed": false}
{"task_id": 92, "prediction_id": 1, "generation": "from operator import itemgetter\nfrom time import time\nfrom collections import defaultdict\nfrom weakref import WeakKeyDictionary\n\ndef format_live_refs(ignore=NoneType):\n    \"\"\"Return a tabular representation of tracked objects\"\"\"\n    lines = []\n    # Iterate over all tracked classes in live_refs\n    for cls, instances in live_refs.items():\n        # Skip the class if it is the type to ignore\n        if cls is ignore:\n            continue\n\n        # Gather instances info: instance id, age (seconds since recorded)\n        now = time()\n        entries = []\n        for instance, timestamp in instances.items():\n            age = now - timestamp\n            entries.append((id(instance), age))\n\n        if not entries:\n            continue\n\n        # Sort entries by age descending (oldest first)\n        entries.sort(key=itemgetter(1), reverse=True)\n\n        # Header for each class block\n        lines.append(f\"{cls.__module__}.{cls.__name__}: {len(entries)} instance(s)\")\n\n        # Entries: show id(instance) and age with 2 decimal places\n        for instance_id, age in entries:\n            lines.append(f\"  id={instance_id:#x} alive for {age:.2f} sec\")\n\n        # Blank line after each class block for readability\n        lines.append(\"\")\n\n    # Join all lines into a single string\n    return \"\\n\".join(lines).rstrip()", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 121, in <module>\n  File \"<string>\", line 120, in test_8\nAssertionError\n", "passed": false}
{"task_id": 92, "prediction_id": 2, "generation": "from operator import itemgetter\nfrom time import time\nfrom typing import DefaultDict\nfrom weakref import WeakKeyDictionary\n\n# We re-import or define as needed since the snippet must run independently\nNoneType = type(None)\nlive_refs: DefaultDict[type, WeakKeyDictionary] = defaultdict(WeakKeyDictionary)\n\n\ndef format_live_refs(ignore=NoneType):\n    \"\"\"Return a tabular representation of tracked objects\"\"\"\n    # Build a list of (class name, count, min_age, max_age)\n    now = time()\n    rows = []\n    for cls, refs in live_refs.items():\n        if cls is ignore:\n            continue\n        count = len(refs)\n        if count == 0:\n            continue\n        # Calculate ages of all live instances of this class\n        ages = [now - ts for ts in refs.values()]\n        min_age = min(ages)\n        max_age = max(ages)\n        rows.append((cls.__name__, count, min_age, max_age))\n\n    # Sort rows by class name\n    rows.sort(key=itemgetter(0))\n\n    # Prepare table header and rows formatted as strings\n    # Columns: Class Name | Count | Min Age | Max Age\n    header = f\"{'Class Name':<30} {'Count':>7} {'Min Age':>10} {'Max Age':>10}\"\n    lines = [header, \"-\" * len(header)]\n    for name, count, min_age, max_age in rows:\n        lines.append(f\"{name:<30} {count:7d} {min_age:10.2f} {max_age:10.2f}\")\n\n    return \"\\n\".join(lines)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 132, in <module>\n  File \"<string>\", line 131, in test_12\nAssertionError\n", "passed": false}
{"task_id": 92, "prediction_id": 3, "generation": "from operator import itemgetter\n\ndef format_live_refs(ignore=NoneType):\n    \"\"\"Return a tabular representation of tracked objects\"\"\"\n    # Prepare a list to collect info tuples: (class_name, count, oldest_age)\n    # oldest_age is time elapsed since oldest instance creation\n    now = time()\n    rows = []\n\n    for cls, refs in live_refs.items():\n        # Ignore entries with key equal to ignore (default NoneType)\n        if cls is ignore:\n            continue\n        count = len(refs)\n        if count == 0:\n            continue\n        # refs is a WeakKeyDictionary mapping obj -> timestamp (time of creation)\n        oldest = min(refs.values())\n        age = now - oldest\n        rows.append((cls.__name__, count, age))\n\n    # Sort rows by class name\n    rows.sort(key=itemgetter(0))\n\n    # Compose a tabular string with aligned columns\n    # Headers\n    header = (\"Class name\", \"Count\", \"Oldest age (s)\")\n    # Determine column widths\n    col_widths = [\n        max(len(header[0]), *(len(r[0]) for r in rows)) if rows else len(header[0]),\n        max(len(header[1]), *(len(str(r[1])) for r in rows)) if rows else len(header[1]),\n        max(len(header[2]), *(len(f\"{r[2]:.2f}\") for r in rows)) if rows else len(header[2]),\n    ]\n\n    # Format header line\n    line_fmt = f\"{{:<{col_widths[0]}}}  {{:>{col_widths[1]}}}  {{:>{col_widths[2]}}}\"\n    lines = [line_fmt.format(*header)]\n    # Separator line\n    lines.append(\"-\" * (sum(col_widths) + 4))\n\n    # Format rows\n    for name, count, age in rows:\n        lines.append(line_fmt.format(name, count, f\"{age:.2f}\"))\n\n    return \"\\n\".join(lines)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 139, in <module>\n  File \"<string>\", line 138, in test_12\nAssertionError\n", "passed": false}
{"task_id": 92, "prediction_id": 4, "generation": "from operator import itemgetter\n\ndef format_live_refs(ignore=NoneType):\n    \"\"\"Return a tabular representation of tracked objects\"\"\"\n    # Prepare a list of rows: each row is [class_name, count, earliest_timestamp]\n    rows = []\n    for cls, refs in live_refs.items():\n        if cls is ignore:\n            continue\n        count = len(refs)\n        if count == 0:\n            continue\n        earliest_ts = min(refs.values())\n        rows.append([cls.__name__, count, earliest_ts])\n\n    # Sort rows by count descending, then by earliest timestamp ascending\n    rows.sort(key=itemgetter(1, 2), reverse=True)\n    \n    # Format the output table as a string\n    if not rows:\n        return \"No live refs tracked.\"\n\n    # Determine column widths\n    name_width = max(len(\"Class\"), max(len(row[0]) for row in rows))\n    count_width = max(len(\"Count\"), max(len(str(row[1])) for row in rows))\n    time_width = max(len(\"First Seen\"), 16)  # time is a float, a fixed width is enough\n\n    # Header line\n    header = f\"{'Class':<{name_width}}  {'Count':>{count_width}}  {'First Seen':>{time_width}}\"\n    sep = f\"{'-' * name_width}  {'-' * count_width}  {'-' * time_width}\"\n    \n    # Rows lines\n    lines = [header, sep]\n    for cls_name, count, ts in rows:\n        lines.append(f\"{cls_name:<{name_width}}  {count:>{count_width}}  {ts:>{time_width}.6f}\")\n    return \"\\n\".join(lines)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 118, in <module>\n  File \"<string>\", line 117, in test_8\nAssertionError\n", "passed": false}
