{"task_id": 85, "prediction_id": 0, "generation": "import asyncio\nfrom twisted.internet import defer\nfrom twisted.python import failure\nfrom scrapy.utils.reactor import is_asyncio_reactor_installed\n\n\ndef deferred_from_coro(o):\n    \"\"\"Converts a coroutine into a Deferred, or returns the object as is if it isn't a coroutine\"\"\"\n    if asyncio.iscoroutine(o):\n        # if asyncio reactor is installed, convert coroutine to Deferred via asyncio.ensure_future\n        if is_asyncio_reactor_installed():\n            future = asyncio.ensure_future(o)\n\n            d = defer.Deferred()\n\n            def on_result(fut):\n                try:\n                    result = fut.result()\n                except Exception as e:\n                    d.errback(failure.Failure())\n                else:\n                    d.callback(result)\n\n            future.add_done_callback(on_result)\n            return d\n        else:\n            # If not asyncio reactor installed, still want to run coroutine in asyncio loop\n            # We create a Deferred wrapping the asyncio.Task with its own event loop.\n            # But generally it's expected to run under asyncio reactor, so fallback:\n            # Create Deferred and schedule execution of coroutine with asyncio.run_coroutine_threadsafe or loop\n\n            # Safer fallback: run coroutine in a fresh event loop and produce Deferred from that\n            # But we cannot block here; so simplest is to return a Deferred that fails\n            # because without asyncio reactor this is unsupported\n            return defer_fail(failure.Failure(\n                RuntimeError(\"Cannot convert coroutine to Deferred without asyncio reactor installed\")))\n    else:\n        return o", "message": "passed", "passed": true}
{"task_id": 85, "prediction_id": 1, "generation": "import asyncio\nfrom twisted.internet import defer\nfrom twisted.python import failure\nfrom scrapy.utils.reactor import is_asyncio_reactor_installed\n\n\ndef deferred_from_coro(o):\n    \"\"\"Converts a coroutine into a Deferred, or returns the object as is if it isn't a coroutine\"\"\"\n    if not asyncio.iscoroutine(o):\n        return o\n\n    # If the Twisted reactor uses the asyncio reactor, wrap the coroutine with ensure_future\n    if is_asyncio_reactor_installed():\n        # Wrap coroutine in asyncio.Task to schedule it\n        task = asyncio.ensure_future(o)\n        return defer.Deferred.fromFuture(task)\n\n    # Otherwise, run coroutine in its own asyncio event loop and convert to Deferred\n    # Create a new event loop for the coroutine and run it asynchronously,\n    # then wrap the future in a Deferred\n    loop = asyncio.new_event_loop()\n    fut = asyncio.run_coroutine_threadsafe(o, loop)\n\n    d = defer.Deferred()\n\n    def on_done(future):\n        try:\n            result = future.result()\n        except Exception as exc:\n            d.errback(failure.Failure(exc))\n        else:\n            d.callback(result)\n        loop.call_soon_threadsafe(loop.stop)\n\n    fut.add_done_callback(on_done)\n\n    def run_loop():\n        try:\n            loop.run_forever()\n        finally:\n            loop.close()\n\n    import threading\n    t = threading.Thread(target=run_loop, daemon=True)\n    t.start()\n\n    return d", "message": "passed", "passed": true}
{"task_id": 85, "prediction_id": 2, "generation": "import asyncio\nfrom twisted.internet import defer\nfrom twisted.python import failure\nfrom scrapy.utils.reactor import is_asyncio_reactor_installed\n\n\ndef deferred_from_coro(o):\n    \"\"\"Converts a coroutine into a Deferred, or returns the object as is if it isn't a coroutine\"\"\"\n    if not asyncio.iscoroutine(o):\n        return o\n\n    # If asyncio reactor is installed, wrap coroutine with ensure_future and convert via defer.Deferred.fromFuture\n    if is_asyncio_reactor_installed():\n        fut = asyncio.ensure_future(o)\n        return defer.Deferred.fromFuture(fut)\n\n    # Otherwise, run the coroutine on the default event loop and convert the asyncio Future to Deferred manually\n    loop = asyncio.get_event_loop()\n    fut = asyncio.ensure_future(o, loop=loop)\n    d = defer.Deferred()\n\n    def on_done(future):\n        try:\n            res = future.result()\n        except Exception as exc:\n            d.errback(failure.Failure(exc))\n        else:\n            d.callback(res)\n\n    fut.add_done_callback(on_done)\n    return d", "message": "passed", "passed": true}
{"task_id": 85, "prediction_id": 3, "generation": "from twisted.internet import defer\nimport asyncio\nfrom scrapy.utils.reactor import is_asyncio_reactor_installed\n\ndef deferred_from_coro(o):\n    \"\"\"Converts a coroutine into a Deferred, or returns the object as is if it isn't a coroutine\"\"\"\n    if not asyncio.iscoroutine(o):\n        return o\n\n    # If the reactor uses asyncio integration, we can convert coroutine to Deferred\n    if is_asyncio_reactor_installed():\n        d = defer.Deferred()\n        # Schedule the coroutine on the asyncio loop, and set callbacks on Deferred\n        future = asyncio.ensure_future(o)\n\n        def on_done(fut):\n            exc = fut.exception()\n            if exc is not None:\n                d.errback(fail=defer.failure.Failure(exc))\n            else:\n                d.callback(fut.result())\n\n        future.add_done_callback(on_done)\n        return d\n\n    # If not using asyncio reactor, run coroutine in new event loop and wrap result in a Deferred\n    # Because Twisted reactor is not asyncio-based, we cannot run coroutine asynchronously here.\n    # Instead, we run the coroutine until complete using asyncio.run or similar\n    try:\n        result = asyncio.run(o)\n    except Exception as e:\n        return defer.fail(failure.Failure(e))\n    return defer.succeed(result)", "message": "passed", "passed": true}
{"task_id": 85, "prediction_id": 4, "generation": "import asyncio\nfrom twisted.internet import defer\nfrom twisted.python import failure\nfrom scrapy.utils.reactor import is_asyncio_reactor_installed\n\ndef deferred_from_coro(o):\n    \"\"\"Converts a coroutine into a Deferred, or returns the object as is if it isn't a coroutine\"\"\"\n    if not asyncio.iscoroutine(o):\n        return o\n\n    if is_asyncio_reactor_installed():\n        # If the Twisted reactor uses asyncio, create a Deferred from the coroutine Future\n        fut = asyncio.ensure_future(o)\n        return defer.Deferred.fromFuture(fut)\n    else:\n        # If not using asyncio reactor, run the coroutine and convert its result/errors to a Deferred\n        d = defer.Deferred()\n\n        # Schedule the coroutine on the current event loop if available,\n        # otherwise create and run a new event loop internally.\n        try:\n            loop = asyncio.get_event_loop()\n        except RuntimeError:\n            loop = None\n\n        if loop and loop.is_running():\n            # Running in an active asyncio event loop (not the reactor loop though)\n            fut = asyncio.ensure_future(o)\n        else:\n            # Run the coroutine in a new event loop to completion inside callLater,\n            # so as not to block the reactor and to properly handle Deferred.\n            fut = asyncio.ensure_future(o)\n            # Can't really run the event loop here synchronously; fallback is to create a new event loop \n            # and run the coroutine to completion, but that would block. Instead, we will attach the callbacks.\n\n        def on_done(fut):\n            exc = fut.exception()\n            if exc is None:\n                d.callback(fut.result())\n            else:\n                d.errback(failure.Failure(exc))\n\n        fut.add_done_callback(on_done)\n\n        return d", "message": "passed", "passed": true}
