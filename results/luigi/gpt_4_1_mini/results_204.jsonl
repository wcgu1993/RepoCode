{"task_id": 204, "prediction_id": 0, "generation": "import re\nfrom collections import defaultdict\n\ndef _constrain_glob(glob, paths, limit=5):\n    \"\"\"\n    Tweaks glob into a list of more specific globs that together still cover paths and not too much extra.\n\n    Saves us minutes long listings for long dataset histories.\n\n    Specifically, in this implementation the leftmost occurrences of \"[0-9]\"\n    give rise to a few separate globs that each specialize the expression to\n    digits that actually occur in paths.\n    \"\"\"\n    # Find all occurrences of \"[0-9]\" in glob, left to right\n    occurrences = [m.start() for m in re.finditer(r'\\[0-9\\]', glob)]\n    if not occurrences:\n        # No [0-9] found, no specialization possible, just return the original glob\n        return [glob]\n\n    # Attempt to specialize starting from the leftmost [0-9]\n    # We will only specialize the leftmost occurrence to avoid explosion\n    leftmost_pos = occurrences[0]\n\n    # For each path, find the digit at the position corresponding to the [0-9] in glob\n    candidate_digits = defaultdict(set)  # position -> set of digits found in paths\n\n    # The position in the path string to check is leftmost_pos in glob, adjusted for glob syntax?\n    # Since [0-9] in the glob matches one character in path, the character in path at leftmost_pos is the digit.\n    # We assume the glob and paths align well. We must be careful if the glob has other wildcards before that position.\n\n    # To handle this more robustly, translate glob into a regex pattern that captures the digit at the leftmost_pos [0-9].\n    # But since the glob is something like \"prefix[0-9]suffix\", replace only the leftmost [0-9] with a capture group (\\d)\n    # and all other [0-9] with \\d, and other glob wildcards as needed.\n\n    # Convert glob to regex:\n    # Replace leftmost [0-9] with '(\\d)'\n    # Replace other [0-9] with '\\d'\n    # Replace '*' with '.*' and '?' with '.' (simple glob to regex conversion)\n\n    regex_parts = []\n    i = 0\n    leftmost_handled = False\n    while i < len(glob):\n        if glob[i:i+5] == '[0-9]':\n            if not leftmost_handled:\n                regex_parts.append(r'(\\d)')\n                leftmost_handled = True\n            else:\n                regex_parts.append(r'\\d')\n            i += 5\n        elif glob[i] == '*':\n            regex_parts.append('.*')\n            i += 1\n        elif glob[i] == '?':\n            regex_parts.append('.')\n            i += 1\n        else:\n            # Escape regex special characters if present in glob literal char\n            c = glob[i]\n            if c in '.^$+{}[]|()\\\\':\n                regex_parts.append('\\\\' + c)\n            else:\n                regex_parts.append(c)\n            i += 1\n\n    pattern = ''.join(regex_parts)\n    regex = re.compile('^' + pattern + '$')\n\n    # For each path that matches the pattern, get the captured digit from group(1)\n    digits_found = set()\n    for p in paths:\n        m = regex.match(p)\n        if m:\n            digits_found.add(m.group(1))\n\n    if not digits_found or len(digits_found) == 10:\n        # No filtering gain or all digits found, just return [glob]\n        return [glob]\n\n    # Build new specialized globs by substituting the leftmost [0-9] with each found digit\n    # For example, if glob = \"foo[0-9]bar\", and digits_found = {'2','7'}\n    # produce [\"foo2bar\", \"foo7bar\"]\n\n    results = []\n    for digit in sorted(digits_found)[:limit]:\n        # Replace only the leftmost [0-9] with digit, leave other [0-9] as is\n        new_glob = glob[:leftmost_pos] + digit + glob[leftmost_pos+5:]\n        results.append(new_glob)\n\n    return results", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 857, in <module>\n  File \"<string>\", line 856, in test_8\nAssertionError\n", "passed": false}
{"task_id": 204, "prediction_id": 1, "generation": "import re\nfrom collections import defaultdict\n\n\ndef _constrain_glob(glob, paths, limit=5):\n    \"\"\"\n    Tweaks glob into a list of more specific globs that together still cover paths and not too much extra.\n\n    Saves us minutes long listings for long dataset histories.\n\n    Specifically, in this implementation the leftmost occurrences of \"[0-9]\"\n    give rise to a few separate globs that each specialize the expression to\n    digits that actually occur in paths.\n    \"\"\"\n    # Find all occurrences of the pattern \"[0-9]\" from left to right in the glob string\n    digit_pattern = r'\\[0-9\\]'\n    matches = list(re.finditer(digit_pattern, glob))\n\n    if not matches:\n        # No digit class to specialize, return original glob as single element list\n        return [glob]\n\n    # The goal is to find the leftmost \"[0-9]\" occurrence and create constrained globs by\n    # splitting paths by the digit occurring at that position in the paths subset\n\n    # Position of the first \"[0-9]\"\n    first_match = matches[0]\n    start_idx, end_idx = first_match.start(), first_match.end()\n\n    # For each path, extract the digit character at the position where \"[0-9]\" is in the glob\n    digits_found = set()\n    paths_by_digit = defaultdict(list)\n\n    # We need to map pattern positions to path string positions as is.\n    # Assuming glob and paths are aligned at these positions.\n    # Since the glob contains \"[0-9]\", which is 5 characters, but matches one digit,\n    # replace \"[0-9]\" in the glob by one character, so the digit position corresponds to start_idx in the path string.\n\n    digit_pos = start_idx\n\n    for path in paths:\n        if len(path) <= digit_pos:\n            # Path shorter than position, skip\n            continue\n        ch = path[digit_pos]\n        if ch.isdigit():\n            digits_found.add(ch)\n            paths_by_digit[ch].append(path)\n\n    # Constrain to the limit number of digits found\n    digits_found = sorted(digits_found)[:limit]\n\n    constrained_globs = []\n    for d in digits_found:\n        # Replace only the first \"[0-9]\" in glob with the digit d\n        constrained_glob = glob[:start_idx] + d + glob[end_idx:]\n        constrained_globs.append(constrained_glob)\n\n    return constrained_globs", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 822, in <module>\n  File \"<string>\", line 821, in test_6\nAssertionError\n", "passed": false}
{"task_id": 204, "prediction_id": 2, "generation": "import re\nfrom collections import defaultdict\n\ndef _constrain_glob(glob, paths, limit=5):\n    \"\"\"\n    Tweaks glob into a list of more specific globs that together still cover paths and not too much extra.\n\n    Saves us minutes long listings for long dataset histories.\n\n    Specifically, in this implementation the leftmost occurrences of \"[0-9]\"\n    give rise to a few separate globs that each specialize the expression to\n    digits that actually occur in paths.\n    \"\"\"\n    # Find indices of leftmost [0-9] in glob\n    # We look for the literal substring \"[0-9]\"\n    index = glob.find('[0-9]')\n    if index == -1:\n        # No \"[0-9]\" found, no constraint possible, just return the original glob in a list\n        return [glob]\n\n    # Group paths by the digit occurring at the index where [0-9] appears in the glob\n    # The digit in path should be at the same position as the [0-9] placeholder in the glob string\n    groups = defaultdict(list)\n    for path in paths:\n        # Only consider paths at least as long as glob to have a char at index\n        # But note glob might have wildcards or literals; we only know exact index for [0-9] placeholder\n        # So we try to check the character at index in the path if exists and is a digit\n        if len(path) > index:\n            ch = path[index]\n            if ch.isdigit():\n                groups[ch].append(path)\n    # If no digits found at that position, return [glob] because we cannot constrain\n    if not groups:\n        return [glob]\n\n    # Build new globs replacing first occurrence of [0-9] with each digit from groups\n    constrained_globs = []\n    for digit in sorted(groups.keys()):\n        # Replace only the first occurrence of '[0-9]' with the digit\n        new_glob = glob.replace('[0-9]', digit, 1)\n        constrained_globs.append(new_glob)\n\n    # If more than limit, truncate\n    if len(constrained_globs) > limit:\n        constrained_globs = constrained_globs[:limit]\n\n    return constrained_globs", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 814, in <module>\n  File \"<string>\", line 813, in test_8\nAssertionError\n", "passed": false}
{"task_id": 204, "prediction_id": 3, "generation": "import re\n\ndef _constrain_glob(glob, paths, limit=5):\n    \"\"\"\n    Tweaks glob into a list of more specific globs that together still cover paths and not too much extra.\n\n    Saves us minutes long listings for long dataset histories.\n\n    Specifically, in this implementation the leftmost occurrences of \"[0-9]\"\n    give rise to a few separate globs that each specialize the expression to\n    digits that actually occur in paths.\n    \"\"\"\n    # Find all occurrences of \"[0-9]\" in the glob string, record their positions\n    pattern = re.compile(r'\\[0-9\\]')\n    matches = list(pattern.finditer(glob))\n\n    # If no [0-9] found, return the original glob as the only element in a list\n    if not matches:\n        return [glob]\n\n    # We'll specialize on the leftmost occurrences, up to limit times\n    # but at least one occurrence must be specialized\n    # Extract the index of replacement occurrences\n    # i.e. list of match.start() positions to replace in glob for each occurrence\n    # For each such occurrence, we will enumerate the actual digits present in paths at that position and generate globs accordingly\n\n    # We will perform specialized splitting on the leftmost N occurrences where N <= limit and N <= number of matches\n    specialize_count = min(limit, len(matches))\n\n    # Positions of the leftmost specialize_count [0-9] occurrences\n    target_matches = matches[:specialize_count]\n\n    # To find digits at each occurrence, we determine the corresponding position(s) in the paths strings\n    # Since \"[0-9]\" matches 3 characters in the glob, it will correspond to one character in the path at position:\n    # The position in the path adjusted by number of characters replaced before.\n\n    # Since glob may contain other regex patterns, we can only roughly map the position of the digit in path\n    # But given that \"[0-9]\" matches exactly one digit, and we want to know which digits occur at that position in the paths strings.\n\n    # We'll build a pattern that splits the glob by \"[0-9]\", capturing text parts between them\n    split_parts = pattern.split(glob)\n\n    # Number of digit slots is len(split_parts)-1 (number of [0-9])\n    # For each path, we check if path starts with split_parts[0], and then each digit slot matches one digit, and so on.\n    # But here, to find which digits occur at a given slot i, we can do as follows:\n\n    # Create a list of sets, each for digits occurring at slot i (0-based)\n    digits_at_slot = [set() for _ in range(len(split_parts) - 1)]\n\n    # Because the glob could match extra characters, we have to be careful.\n    # We'll create a regex from the glob that captures each digit at each [0-9] slot as a capture group.\n    # That allows us to extract the digits found in paths at each slot.\n\n    # Build regex pattern from glob to capture digits inside each [0-9]\n    # Escape other parts and replace [0-9] with '([0-9])'\n\n    # Escape regex special chars in split parts\n    escaped_parts = [re.escape(part) for part in split_parts]\n    capturing_regex = ''\n    for i in range(len(escaped_parts) - 1):\n        capturing_regex += escaped_parts[i] + r'([0-9])'\n    capturing_regex += escaped_parts[-1]\n\n    capturing_re = re.compile('^' + capturing_regex + '$')\n\n    for path in paths:\n        m = capturing_re.match(path)\n        if not m:\n            # Path does not totally match glob pattern, skip\n            continue\n        # m.groups() returns a tuple of digits for each slot\n        for i, digit in enumerate(m.groups()):\n            digits_at_slot[i].add(digit)\n\n    # Now focus on the leftmost specialize_count slots, create specialized globs for each digit at those slots\n    # The idea is to replace the [0-9] at these positions with actual digits from the collected sets\n\n    # Construct partial expansions:\n    # We will generate globs by replacing the first slot with each digit, for each generated glob \n    # we then replace the second slot similarly, recursively, and so forth up to specialize_count slots.\n\n    # To generate these efficiently, we do a recursive or iterative cartesian product over digits_at_slot[:specialize_count]\n\n    from itertools import product\n\n    digit_lists = [sorted(list(digits_at_slot[i])) if digits_at_slot[i] else [str(d)] for i, d in enumerate(range(specialize_count))]\n    # If any slot has no digit found (empty set), it means no path matched, so no specialized glob needed.\n\n    # If any slot is empty, return the original glob as fallback\n    for digit_set in digits_at_slot[:specialize_count]:\n        if not digit_set:\n            return [glob]\n\n    # Now generate all combinations of digits for the first specialize_count slots\n    combos = product(*digits_at_slot[:specialize_count])\n\n    specialized_globs = []\n\n    # Build function to reconstruct glob by replacing only the leftmost specialize_count \"[0-9]\" with given digits\n    def build_glob(digits_combo):\n        parts = []\n        for i in range(len(split_parts) - 1):\n            parts.append(split_parts[i])\n            # For the first specialize_count slots, replace [0-9] with digit from digits_combo\n            if i < specialize_count:\n                parts.append(digits_combo[i])\n            else:\n                # For remaining slots, keep as [0-9]\n                parts.append('[0-9]')\n        parts.append(split_parts[-1])\n        return ''.join(parts)\n\n    for combo in combos:\n        specialized_globs.append(build_glob(combo))\n\n    return specialized_globs", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 883, in <module>\n  File \"<string>\", line 882, in test_8\nAssertionError\n", "passed": false}
{"task_id": 204, "prediction_id": 4, "generation": "import re\nfrom collections import defaultdict\n\ndef _constrain_glob(glob, paths, limit=5):\n    \"\"\"\n    Tweaks glob into a list of more specific globs that together still cover paths and not too much extra.\n\n    Saves us minutes long listings for long dataset histories.\n\n    Specifically, in this implementation the leftmost occurrences of \"[0-9]\"\n    give rise to a few separate globs that each specialize the expression to\n    digits that actually occur in paths.\n    \"\"\"\n    # Find all leftmost occurrences of the pattern \"[0-9]\" in the glob\n    # We'll constrain on the first several such occurrences, up to the limit.\n\n    # Regex to find \"[0-9]\"\n    pattern = r'\\[0-9\\]'\n    matches = list(re.finditer(pattern, glob))\n\n    # If no matches, return the original glob as single element list\n    if not matches:\n        return [glob]\n\n    # Positions of the leftmost matched [0-9] patterns, up to limit\n    matches = matches[:limit]\n\n    # Recursive helper to build globs by replacing one \"[0-9]\" at a time\n    def helper(prefix, glob_rest, idx):\n        \"\"\"\n        prefix: so far constructed part of glob\n        glob_rest: remaining part of glob starting at idx\n        idx: index of which [0-9] match we are constraining (or beyond all matches)\n        \"\"\"\n        if idx >= len(matches):\n            # No more [0-9] to constrain, yield the combined glob\n            yield prefix + glob_rest\n            return\n\n        m = matches[idx]\n        start, end = m.start(), m.end()\n\n        # prefix of glob_rest before this [0-9]\n        before = glob_rest[:start]\n        after = glob_rest[end:]\n\n        # Positions in the original glob for this match:\n        # We want to find which digits actually occur in paths at this position:\n        # To do this, get the global index of this [0-9] in the original glob string,\n        # that is m.start() relative to the original glob, which is prefix + glob_rest.\n        # But prefix length + start = absolute position in glob. So we can calculate the character offset in each path.\n\n        abs_pos = len(prefix) + start\n\n        # Gather all digits that occur at position abs_pos in paths (if they have that length)\n        digits_at_pos = set()\n        for p in paths:\n            if len(p) > abs_pos:\n                c = p[abs_pos]\n                if c.isdigit():\n                    digits_at_pos.add(c)\n\n        # If no digits found, fallback to all 0-9 to avoid losing matches\n        if not digits_at_pos:\n            digits_at_pos = set('0123456789')\n\n        # Create specialized globs by replacing this \"[0-9]\" with [digits]\n        # but split into multiple globs each covering one digit to reduce listing too much\n        # We split when multiple digits found, creating one glob per digit.\n\n        for d in sorted(digits_at_pos):\n            new_glob = prefix + before + d + after\n            # recurse to next [0-9]\n            yield from helper(new_glob, after, idx + 1)\n\n    # Start recursion\n    # We take glob in full and matches positions relative to it\n    results = list(helper('', glob, 0))\n\n    # If no results generated for some reason, fallback to original glob\n    if not results:\n        return [glob]\n\n    return results", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 847, in <module>\n  File \"<string>\", line 846, in test_6\nAssertionError\n", "passed": false}
