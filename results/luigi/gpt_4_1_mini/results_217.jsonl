{"task_id": 217, "prediction_id": 0, "generation": "def _tasks_status(set_tasks):\n    \"\"\"\n    Given a grouped set of tasks, returns a LuigiStatusCode\n    \"\"\"\n    # If there are no tasks at all, return SUCCESS (no failures, no missing etc.)\n    total_tasks = sum(len(tasks) for tasks in set_tasks.values())\n    if total_tasks == 0:\n        return LuigiStatusCode.SUCCESS\n\n    # Check for any failed tasks\n    if len(set_tasks[\"failed\"]) > 0:\n        # Also check if there are scheduling errors alongside failures\n        if len(set_tasks[\"scheduling_error\"]) > 0:\n            return LuigiStatusCode.FAILED_AND_SCHEDULING_FAILED\n        return LuigiStatusCode.FAILED\n\n    # Check for scheduling failures only\n    if len(set_tasks[\"scheduling_error\"]) > 0:\n        return LuigiStatusCode.SCHEDULING_FAILED\n\n    # Check for any tasks that were not run\n    if len(set_tasks[\"not_run\"]) > 0:\n        return LuigiStatusCode.NOT_RUN\n\n    # Check for missing external dependencies among still pending tasks\n    if len(set_tasks[\"still_pending_ext\"]) > 0 or len(set_tasks[\"upstream_missing_dependency\"]) > 0:\n        return LuigiStatusCode.MISSING_EXT\n\n    # Check if there were tasks that previously failed but all succeeded eventually (no failed remain)\n    if len(set_tasks[\"ever_failed\"]) > 0:\n        # No current failed, so mark as success with retry\n        return LuigiStatusCode.SUCCESS_WITH_RETRY\n\n    # If none of the above hold, consider it a success\n    return LuigiStatusCode.SUCCESS", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 509, in <module>\n  File \"<string>\", line 508, in test_0\n  File \"<string>\", line 456, in _tasks_status\n  File \"<string>\", line 456, in <genexpr>\nTypeError: object of type 'bool' has no len()\n", "passed": false}
{"task_id": 217, "prediction_id": 1, "generation": "from luigi.execution_summary import LuigiStatusCode\n\ndef _tasks_status(set_tasks):\n    \"\"\"\n    Given a grouped set of tasks, returns a LuigiStatusCode\n    \"\"\"\n    # Checks for failed tasks\n    failed = set_tasks.get(\"failed\", set())\n    scheduling_error = set_tasks.get(\"scheduling_error\", set())\n    ever_failed = set_tasks.get(\"ever_failed\", set())\n    completed = set_tasks.get(\"completed\", set())\n    still_pending_ext = set_tasks.get(\"still_pending_ext\", set())\n    not_run = set_tasks.get(\"not_run\", set())\n\n    if failed:\n        # Check if all failed tasks eventually completed (i.e., succeeded after retry)\n        # If all failed tasks are completed, then SUCCESS_WITH_RETRY\n        if failed.issubset(completed):\n            return LuigiStatusCode.SUCCESS_WITH_RETRY\n        else:\n            # If there are also scheduling errors together with failures\n            if scheduling_error:\n                return LuigiStatusCode.FAILED_AND_SCHEDULING_FAILED\n            else:\n                return LuigiStatusCode.FAILED\n\n    if scheduling_error:\n        return LuigiStatusCode.SCHEDULING_FAILED\n\n    if still_pending_ext:\n        return LuigiStatusCode.MISSING_EXT\n\n    if not_run:\n        return LuigiStatusCode.NOT_RUN\n\n    # If nothing failed or pending or scheduling problems, success\n    return LuigiStatusCode.SUCCESS", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 511, in <module>\n  File \"<string>\", line 510, in test_0\n  File \"<string>\", line 468, in _tasks_status\nAttributeError: 'bool' object has no attribute 'issubset'\n", "passed": false}
{"task_id": 217, "prediction_id": 2, "generation": "def _tasks_status(set_tasks):\n    \"\"\"\n    Given a grouped set of tasks, returns a LuigiStatusCode\n    \"\"\"\n    # Determine status following the priority logic from Luigi's execution summary conventions\n\n    # If there are failed tasks and scheduling errors\n    if set_tasks[\"failed\"] and set_tasks[\"scheduling_error\"]:\n        return LuigiStatusCode.FAILED_AND_SCHEDULING_FAILED\n\n    # If there are failed tasks (and no scheduling errors)\n    if set_tasks[\"failed\"]:\n        return LuigiStatusCode.FAILED\n\n    # If there are scheduling errors (and no failed tasks)\n    if set_tasks[\"scheduling_error\"]:\n        return LuigiStatusCode.SCHEDULING_FAILED\n\n    # If there are tasks not run (no failed or scheduling error)\n    if set_tasks[\"not_run\"]:\n        return LuigiStatusCode.NOT_RUN\n\n    # If there are missing external dependencies (no failed, scheduling error, or not_run)\n    if set_tasks[\"still_pending_ext\"] or set_tasks[\"upstream_missing_dependency\"]:\n        return LuigiStatusCode.MISSING_EXT\n\n    # If there are still pending tasks that are not missing external deps (but no failed, error, not_run)\n    if set_tasks[\"still_pending_not_ext\"]:\n        # The presence of upstream failures or run_by_other_worker among them would typically elevate status\n        if set_tasks[\"upstream_failure\"] or set_tasks[\"upstream_run_by_other_worker\"] or set_tasks[\"upstream_scheduling_error\"]:\n            return LuigiStatusCode.NOT_RUN  # treat as not run due to upstream issues\n        # Otherwise, they are still pending but no explicit failure -> treat as NOT_RUN\n        return LuigiStatusCode.NOT_RUN\n\n    # Now, if no failures, no scheduling errors, nothing pending, then success\n    # Check if any failed tasks are ever_failed but all completed (retried successfully)\n    # i.e. failed empty but ever_failed not empty, so SUCCESS_WITH_RETRY\n    if not set_tasks[\"failed\"] and set_tasks[\"ever_failed\"]:\n        return LuigiStatusCode.SUCCESS_WITH_RETRY\n\n    # Default to SUCCESS, meaning no failed tasks or missing dependencies\n    return LuigiStatusCode.SUCCESS", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 526, in <module>\n  File \"<string>\", line 523, in test_4\n  File \"<string>\", line 474, in _tasks_status\nKeyError: 'upstream_missing_dependency'\n", "passed": false}
{"task_id": 217, "prediction_id": 3, "generation": "from luigi.execution_summary import LuigiStatusCode\n\ndef _tasks_status(set_tasks):\n    \"\"\"\n    Given a grouped set of tasks, returns a LuigiStatusCode\n    \"\"\"\n    failed = set_tasks.get(\"failed\", set())\n    scheduling_error = set_tasks.get(\"scheduling_error\", set())\n    still_pending_ext = set_tasks.get(\"still_pending_ext\", set())\n    not_run = set_tasks.get(\"not_run\", set())\n    ever_failed = set_tasks.get(\"ever_failed\", set())\n\n    if failed and scheduling_error:\n        return LuigiStatusCode.FAILED_AND_SCHEDULING_FAILED\n\n    if failed:\n        return LuigiStatusCode.FAILED\n\n    if scheduling_error:\n        return LuigiStatusCode.SCHEDULING_FAILED\n\n    if still_pending_ext:\n        return LuigiStatusCode.MISSING_EXT\n\n    if not_run:\n        return LuigiStatusCode.NOT_RUN\n\n    if ever_failed:\n        return LuigiStatusCode.SUCCESS_WITH_RETRY\n\n    return LuigiStatusCode.SUCCESS", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 590, in <module>\n  File \"<string>\", line 589, in test_18\nAssertionError\n", "passed": false}
{"task_id": 217, "prediction_id": 4, "generation": "from luigi.execution_summary import LuigiStatusCode\n\ndef _tasks_status(set_tasks):\n    \"\"\"\n    Given a grouped set of tasks, returns a LuigiStatusCode\n    \"\"\"\n    failed = set_tasks.get(\"failed\", set())\n    ever_failed = set_tasks.get(\"ever_failed\", set())\n    scheduling_error = set_tasks.get(\"scheduling_error\", set())\n    still_pending_ext = set_tasks.get(\"still_pending_ext\", set())\n    not_run = set_tasks.get(\"not_run\", set())\n\n    if failed and scheduling_error:\n        return LuigiStatusCode.FAILED_AND_SCHEDULING_FAILED\n    elif failed:\n        return LuigiStatusCode.FAILED\n    elif scheduling_error:\n        return LuigiStatusCode.SCHEDULING_FAILED\n    elif still_pending_ext:\n        return LuigiStatusCode.MISSING_EXT\n    elif not_run:\n        return LuigiStatusCode.NOT_RUN\n    elif (not failed and not scheduling_error and not still_pending_ext and not not_run and\n          (len(ever_failed) > 0)):\n        # Failed tasks all succeeded in retry\n        return LuigiStatusCode.SUCCESS_WITH_RETRY\n\n    return LuigiStatusCode.SUCCESS", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 512, in <module>\n  File \"<string>\", line 509, in test_4\n  File \"<string>\", line 474, in _tasks_status\nTypeError: object of type 'bool' has no len()\n", "passed": false}
