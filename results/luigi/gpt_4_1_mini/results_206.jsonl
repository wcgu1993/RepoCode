{"task_id": 206, "prediction_id": 0, "generation": "from luigi.parameter import ParameterException\n\ndef _list_existing(filesystem, glob, paths):\n    \"\"\"\n    Get all the paths that do in fact exist. Returns a set of all existing paths.\n\n    Takes a luigi.target.FileSystem object, a str which represents a glob and\n    a list of strings representing paths.\n    \"\"\"\n    # Use filesystem's glob or list method if available to get candidate paths\n    # but since only 'paths' are given we start from paths restricting by the glob.\n    # Refine glob if it contains digit wildcards to avoid too broad queries.\n\n    # If the filesystem has a glob method we could use it, but here we optimize\n    # by constraining the glob to more precise globs based on the existing paths,\n    # to minimize expensive listings.\n    from luigi.tools.range import _constrain_glob\n\n    # Restrict the glob into a list of more specific globs based on actual digits occurring in paths\n    constrained_globs = _constrain_glob(glob, paths)\n\n    existing_paths = set()\n    for specific_glob in constrained_globs:\n        # Since we only have paths given, filter by prefix matching for the glob pattern\n        # We interpret the glob pattern roughly as a prefix ending before any wildcard\n\n        # Find prefix before any [0-9] wildcard or character class, for efficient filtering\n        prefix_end = specific_glob.find('[')\n        if prefix_end == -1:\n            prefix_end = len(specific_glob)\n        prefix = specific_glob[:prefix_end]\n\n        # Filter candidate paths by prefix and also basic pattern match for this simple glob\n        candidates = [p for p in paths if p.startswith(prefix)]\n\n        for path in candidates:\n            try:\n                if filesystem.exists(path):\n                    existing_paths.add(path)\n            except Exception:\n                # If exception during exists call, ignore this path (fail-safe)\n                pass\n\n    return existing_paths", "message": "passed", "passed": true}
{"task_id": 206, "prediction_id": 1, "generation": "from luigi.parameter import ParameterException\n\ndef _list_existing(filesystem, glob, paths):\n    \"\"\"\n    Get all the paths that do in fact exist. Returns a set of all existing paths.\n\n    Takes a luigi.target.FileSystem object, a str which represents a glob and\n    a list of strings representing paths.\n    \"\"\"\n    existing_paths = set()\n    # First, constrain the glob pattern into a list of more specific globs (to reduce listing scope)\n    # Importing here to avoid cyclic dependency if this function is run standalone\n    from luigi.tools.range import _constrain_glob\n    refined_globs = _constrain_glob(glob, paths)\n\n    for g in refined_globs:\n        # perform a glob on the filesystem using refined glob pattern\n        # `filesystem.glob` returns an iterable of matching paths (as strings)\n        # If the filesystem.glob method does not exist (custom filesystem), fallback could be needed,\n        # but here we assume the correct interface.\n        try:\n            found = filesystem.glob(g)\n        except AttributeError:\n            # If the filesystem doesn't support glob, fallback to listing and filtering manually\n            # This is uncommon but possible for certain FS implementations.\n            # We filter all paths starting with the path prefix in g up to the first wildcard.\n            import re\n            # Convert glob to regex roughly (only processing [0-9] and digit chars)\n            regex_pattern = re.escape(g).replace(r'\\[0\\-9\\]', r'[0-9]')\n            regex = re.compile(regex_pattern)\n            found = filter(regex.match, filesystem.listdir(''))\n        for f in found:\n            existing_paths.add(f)\n\n    return existing_paths", "message": "passed", "passed": true}
{"task_id": 206, "prediction_id": 2, "generation": "def _list_existing(filesystem, glob, paths):\n    \"\"\"\n    Get all the paths that do in fact exist. Returns a set of all existing paths.\n\n    Takes a luigi.target.FileSystem object, a str which represents a glob and\n    a list of strings representing paths.\n    \"\"\"\n    # Refine the glob pattern into more specific globs to limit unnecessary listings\n    refined_globs = _constrain_glob(glob, paths)\n\n    existing_paths = set()\n    for g in refined_globs:\n        # List all files/directories matching the refined glob prefix\n        # We use the prefix up to the last '/' directory level as filesystem.listdir expects a directory path prefix\n        # Because filesystem.listdir doesn't support globs, only prefix matching is possible.\n        prefix = g.rsplit('/', 1)[0]\n        try:\n            listed = filesystem.listdir(prefix)\n        except Exception:\n            # If listing fails, skip this prefix gracefully.\n            listed = []\n\n        # Filter the listed paths to only those matching the refined glob pattern fully\n        # The glob pattern uses '[0-9]' style wildcards for digits, so convert it to a regex:\n        # Replace '[0-9]' with '\\d', and anchor the pattern for full match.\n        import re\n\n        regex_pattern = '^' + re.escape(g).replace('\\\\[0\\\\-9\\\\]', r'\\d') + '$'\n        regex = re.compile(regex_pattern)\n\n        for path in listed:\n            if regex.match(path):\n                existing_paths.add(path)\n\n    return existing_paths", "message": "passed", "passed": true}
{"task_id": 206, "prediction_id": 3, "generation": "def _list_existing(filesystem, glob, paths):\n    \"\"\"\n    Get all the paths that do in fact exist. Returns a set of all existing paths.\n\n    Takes a luigi.target.FileSystem object, a str which represents a glob and\n    a list of strings representing paths.\n    \"\"\"\n    existing = set()\n\n    # First refine the glob pattern into more specific globs to limit expensive listings\n    refined_globs = _constrain_glob(glob, paths)\n\n    for g in refined_globs:\n        try:\n            # Use filesystem's glob or equivalent listing method to find matching paths\n            # Since the FileSystem API differs, we cautiously use list or glob if available\n            # Some luigi filesystems have ls or glob matching\n            matches = filesystem.glob(g) if hasattr(filesystem, \"glob\") else None\n            if matches is None:\n                # Fallback: listdir for the parent directory of the glob pattern prefix\n                # Extract prefix before any wildcard/bracket pattern:\n                wildcard_pos = min([pos for pos in [g.find(c) for c in ['*', '?', '[']] if pos != -1] or [len(g)])\n                prefix = g[:wildcard_pos].rstrip('/')\n                matches = filesystem.listdir(prefix)\n                # Filter matches that match the glob pattern (convert glob to regex)\n                import fnmatch\n                matches = [p for p in matches if fnmatch.fnmatch(p, g)]\n        except (AttributeError, NotImplementedError):\n            # If glob or listdir not implemented, fallback to filtering paths argument\n            import fnmatch\n            matches = [p for p in paths if fnmatch.fnmatch(p, g)]\n\n        # Check existence of matches and add those that exist\n        for p in matches:\n            if filesystem.exists(p):\n                existing.add(p)\n\n    return existing", "message": "passed", "passed": true}
{"task_id": 206, "prediction_id": 4, "generation": "from luigi.parameter import ParameterException\nfrom luigi.target import FileSystemTarget\nfrom luigi.tools.range import _constrain_glob\n\n\ndef _list_existing(filesystem, glob, paths):\n    \"\"\"\n    Get all the paths that do in fact exist. Returns a set of all existing paths.\n\n    Takes a luigi.target.FileSystem object, a str which represents a glob and\n    a list of strings representing paths.\n    \"\"\"\n    # Refine the glob pattern into a limited set of more specific globs to reduce directory listings\n    refined_globs = _constrain_glob(glob, paths)\n\n    existing_paths = set()\n    for g in refined_globs:\n        # List all paths under the current refined glob directory prefix\n        # The glob is expected to end with a directory prefix (without filename pattern chars)\n        # We attempt to perform a directory listing from the glob prefix\n        # As we only have a glob string, infer a prefix path for listing:\n        # Use the glob up to the last '/' as prefix, which should be the folder prefix\n\n        # Extract directory prefix from glob - glob likely ends with [0-9] wildcards before last '/'\n        # So we get the prefix by truncation at last '/' for listing\n        prefix = g.rsplit('/', 1)[0] if '/' in g else g\n\n        # List files under the prefix\n        try:\n            listed_paths = filesystem.list_prefix(prefix)\n        except AttributeError:\n            # fallback to listdir if list_prefix doesn't exist\n            # listdir expects a directory path, so we truncate prefix at the last '/'\n            dir_prefix = prefix\n            if not hasattr(filesystem, 'listdir'):\n                raise AttributeError(f\"Provided filesystem object does not support 'list_prefix' or 'listdir' methods\")\n            listed_paths = filesystem.listdir(dir_prefix)\n\n        # For each path in listed paths, check if it matches the glob pattern\n        # The glob pattern here is an implicit string with wildcard '[0-9]' which means any digit\n        # We convert the glob pattern with '[0-9]' to regex to do matching\n\n        # Convert glob (with '[0-9]' wildcards) to regex\n        regex_pattern = (\n            '^' +\n            re.escape(g)\n            .replace('\\\\[0\\\\-9\\\\]', '[0-9]')\n            .replace('\\\\*', '.*')\n            .replace('\\\\?', '.') +\n            '$'\n        )\n        import re\n        regex = re.compile(regex_pattern)\n\n        for path in listed_paths:\n            if regex.match(path):\n                existing_paths.add(path)\n\n    return existing_paths", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 848, in <module>\n  File \"<string>\", line 844, in test_12\n  File \"<string>\", line 639, in _list_existing\nUnboundLocalError: local variable 're' referenced before assignment\n", "passed": false}
