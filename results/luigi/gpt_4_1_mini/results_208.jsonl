{"task_id": 208, "prediction_id": 0, "generation": "from urllib.parse import urlparse, urlunparse\n\ndef _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n    \"\"\"\n    # Parse base and url parts\n    base_parts = urlparse(base)\n    url_parts = urlparse(url)\n\n    # If url is absolute (has a scheme), return it normalized\n    if url_parts.scheme:\n        return urlunparse(url_parts)\n\n    # Otherwise, join with base similar to urljoin logic but supporting arbitrary scheme\n    # Assemble new parts step-by-step:\n\n    # scheme and netloc come from base\n    scheme = base_parts.scheme\n    netloc = base_parts.netloc\n\n    # path handling: if url's path starts with '/', it is absolute path\n    if url_parts.path.startswith('/'):\n        path = url_parts.path\n    else:\n        # join base path directory + url path\n        base_path = base_parts.path\n        if not base_path:\n            base_dir = '/'\n        else:\n            if base_path.endswith('/'):\n                base_dir = base_path\n            else:\n                base_dir = base_path.rpartition('/')[0] + '/'\n                if base_dir == '':\n                    base_dir = '/'\n        path = base_dir + url_parts.path\n\n    # Normalize path to remove ., .. when possible\n    # do manual normalization\n    segments = []\n    for segment in path.split('/'):\n        if segment == '..':\n            if segments and segments[-1] != '..':\n                segments.pop()\n            else:\n                segments.append(segment)\n        elif segment == '.' or segment == '':\n            # skip empty or current dir symbol except if it's leading\n            continue\n        else:\n            segments.append(segment)\n    norm_path = '/' + '/'.join(segments)\n\n    # Query and fragment come from url_parts\n    query = url_parts.query\n    fragment = url_parts.fragment\n\n    return urlunparse((scheme, netloc, norm_path, '', query, fragment))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 277, in <module>\n  File \"<string>\", line 276, in test_13\nAssertionError\n", "passed": false}
{"task_id": 208, "prediction_id": 1, "generation": "from urllib.parse import urlparse, urlunparse\n\ndef _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n    \"\"\"\n    # Parse the base and the url\n    base_parsed = urlparse(base)\n    url_parsed = urlparse(url)\n\n    # If the url to join is absolute (has scheme), just return it normalized\n    if url_parsed.scheme:\n        return urlunparse(url_parsed)\n\n    # For unknown schemes (like http+unix), perform URL join of the paths manually\n    # Build a new URL with the scheme and netloc from base, but joined path\n\n    # Normalize paths so they join properly:\n    if url.startswith('/'):\n        # url is absolute path component - replace the path part of base\n        new_path = url\n    else:\n        # relative path - join with base's path directory\n        base_path = base_parsed.path\n        if not base_path.endswith('/'):\n            base_path = base_path.rsplit('/', 1)[0] + '/'\n        new_path = base_path + url\n\n    # Normalize new_path to remove ../ and ./ using posixpath.normpath\n    import posixpath\n    normalized_path = posixpath.normpath(new_path)\n\n    # If the original new_path ended with a slash, keep trailing slash\n    if new_path.endswith('/') and not normalized_path.endswith('/'):\n        normalized_path += '/'\n\n    # Compose the new URL parts\n    new_url_parts = (\n        base_parsed.scheme,\n        base_parsed.netloc,\n        normalized_path,\n        '',  # params (unused)\n        '',  # query (discarded as url is relative, typically)\n        '',  # fragment\n    )\n    return urlunparse(new_url_parts)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 264, in <module>\n  File \"<string>\", line 263, in test_13\nAssertionError\n", "passed": false}
{"task_id": 208, "prediction_id": 2, "generation": "from urllib.parse import urlparse, urlunparse\n\n\ndef _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n    \"\"\"\n    base_parts = urlparse(base)\n    url_parts = urlparse(url)\n\n    # If the url to join is absolute (has scheme), return it as is\n    if url_parts.scheme:\n        return url\n\n    # Build the new path by joining the base path and url path following urljoin logic\n    # Use urlunparse to rebuild the URL with possibly updated path and query\n\n    # If url path starts with '/', it's absolute from root\n    if url.startswith('/'):\n        path = url\n    else:\n        # Join the paths componentwise\n        base_path = base_parts.path\n        if not base_path:\n            base_path = '/'\n        if base_path.endswith('/'):\n            path = base_path + url\n        else:\n            # Remove last segment after last '/' and append url\n            path = base_path.rpartition('/')[0] + '/' + url\n\n    # Normalize path by resolving '..' and '.' segments\n    segments = []\n    for segment in path.split('/'):\n        if segment == '..':\n            if segments:\n                segments.pop()\n        elif segment != '.' and segment != '':\n            segments.append(segment)\n    # Leading slash must be preserved if present\n    if path.startswith('/'):\n        normalized_path = '/' + '/'.join(segments)\n    else:\n        normalized_path = '/'.join(segments)\n\n    # Construct full new URL with base scheme, netloc, and replaced path/query/fragment\n    # Query and fragment come from the url_parts if provided else empty\n    result = urlunparse((\n        base_parts.scheme,\n        base_parts.netloc,\n        normalized_path,\n        url_parts.params,\n        url_parts.query,\n        url_parts.fragment,\n    ))\n    return result", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 274, in <module>\n  File \"<string>\", line 273, in test_13\nAssertionError\n", "passed": false}
{"task_id": 208, "prediction_id": 3, "generation": "from urllib.parse import urlparse, urlunparse\n\ndef _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n    \"\"\"\n    # Parse base and url\n    base_parts = urlparse(base)\n    url_parts = urlparse(url)\n\n    # If url is absolute (has scheme), return url as is\n    if url_parts.scheme:\n        return url\n\n    # For normal schemes like http/https, fallback to standard urljoin\n    # but we cannot use urllib.parse.urljoin directly because of arbitrary schemes,\n    # so we will mimic its behavior here.\n\n    # If url starts with \"//\", it is a scheme-relative URL\n    if url.startswith(\"//\"):\n        # Keep scheme from base, but replace netloc and path et al from url\n        return urlunparse((base_parts.scheme, url_parts.netloc, url_parts.path,\n                           url_parts.params, url_parts.query, url_parts.fragment))\n\n    # For relative URLs, resolve path relative to base path\n    # Handle schemes like 'http+unix' by treating netloc accordingly\n\n    # Construct the new path\n    # If url path starts with \"/\", it is absolute path on current server\n    if url_parts.path.startswith(\"/\"):\n        new_path = url_parts.path\n    else:\n        # Join the base path and relative url path in a similar way to urllib.parse.urljoin\n        # Remove the last segment of base path (if not ending with /) then append url path\n\n        # If base path is empty, treat as \"/\"\n        base_path = base_parts.path\n        if not base_path:\n            base_path = \"/\"\n\n        if base_path.endswith(\"/\"):\n            new_path = base_path + url_parts.path\n        else:\n            # remove last segment from base_path\n            new_path = base_path.rsplit('/', 1)[0] + '/' + url_parts.path\n\n    # Normalize path by resolving any ./ or ../ segments\n    segments = []\n    for segment in new_path.split('/'):\n        if segment == '..':\n            if segments:\n                segments.pop()\n        elif segment != '.' and segment != '':\n            segments.append(segment)\n    normalized_path = '/' + '/'.join(segments)\n\n    # Build the final URL parts\n    result_parts = (\n        base_parts.scheme,\n        base_parts.netloc,\n        normalized_path,\n        url_parts.params,\n        url_parts.query,\n        url_parts.fragment\n    )\n    return urlunparse(result_parts)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 324, in <module>\n  File \"<string>\", line 323, in test_47\nAssertionError\n", "passed": false}
{"task_id": 208, "prediction_id": 4, "generation": "from urllib.parse import urlparse, urlunparse\n\n\ndef _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n\n    The standard urllib.parse.urljoin does not properly handle custom schemes\n    like 'http+unix://', so this function parses the base URL and resolves\n    the relative URL properly by recombining the parts manually.\n\n    Args:\n        base (str): The base URL to join from.\n        url (str): The relative URL to join.\n\n    Returns:\n        str: The joined URL.\n    \"\"\"\n    base_parsed = urlparse(base)\n    # Use urlparse.urljoin for the path and query but manually handle scheme and netloc\n    # because urljoin doesn't properly handle \"+\" in the scheme like http+unix\n\n    # If the url is absolute, urlparse(url).scheme will be non-empty\n    url_parsed = urlparse(url)\n    if url_parsed.scheme:\n        # The url is absolute, just return it normalized\n        return url\n\n    # Resolve the url relative to the base path\n    # Use standard urljoin but with empty scheme + netloc so that we only join paths\n    # Then rebuild with original scheme and netloc\n    # Since urlparse.urljoin is a top-level function, let's import it here:\n    from urllib.parse import urljoin as std_urljoin\n\n    # Join the path/query/fragment relative to base.path\n    joined_path = std_urljoin(base_parsed.path, url)\n\n    # Rebuild the full URL manually with the original scheme and netloc\n    result = urlunparse((\n        base_parsed.scheme,\n        base_parsed.netloc,\n        joined_path,\n        '',  # params (deprecated)\n        '',  # query (already included in joined_path if any)\n        '',  # fragment\n    ))\n\n    return result", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 266, in <module>\n  File \"<string>\", line 265, in test_13\nAssertionError\n", "passed": false}
