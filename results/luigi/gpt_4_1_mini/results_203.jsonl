{"task_id": 203, "prediction_id": 0, "generation": "def parse_results(fields, data):\n    \"\"\"\n    Traverses ordered dictionary, calls _traverse_results() to recursively read into the dictionary depth of data\n    \"\"\"\n    def _traverse_results(fields, data):\n        \"\"\"\n        Recursively traverse the data dictionary or list to extract values corresponding to fields.\n        \"\"\"\n        results = []\n        if isinstance(data, dict):\n            # For each field, get its value from dict; if that value is also dict or list, recurse into it\n            current = []\n            for field in fields:\n                if field in data:\n                    val = data[field]\n                    # If the value is dict or list, recurse\n                    if isinstance(val, (dict, list)):\n                        current.append(_traverse_results(fields, val))\n                    else:\n                        current.append(val)\n                else:\n                    current.append(None)  # Field not present\n            return current\n        elif isinstance(data, list):\n            # If data is a list, traverse each element and collect results\n            for item in data:\n                res = _traverse_results(fields, item)\n                results.append(res)\n            return results\n        else:\n            # If data is neither dict nor list, return it as is (base case)\n            return data\n\n    return _traverse_results(fields, data)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 735, in <module>\n  File \"<string>\", line 734, in test_50\nAssertionError\n", "passed": false}
{"task_id": 203, "prediction_id": 1, "generation": "def parse_results(fields, data):\n    \"\"\"\n    Traverses ordered dictionary, calls _traverse_results() to recursively read into the dictionary depth of data\n    \"\"\"\n    return _traverse_results(fields, data)\n\n\ndef _traverse_results(fields, data):\n    \"\"\"\n    Helper function to recursively extract the values for given fields from nested ordered dictionary or list of ordered dictionaries.\n\n    :param fields: List of fields to extract, can represent path into nested dictionaries.\n    :param data: The data object (OrderedDict, dict, list) to extract from.\n    :return: OrderedDict containing the extracted fields with their corresponding values.\n    \"\"\"\n    results = OrderedDict()\n\n    if not fields:\n        return results\n\n    current_field = fields[0]\n\n    # If the current field is a nested path (like 'foo.bar'), split it\n    # but based on the given context, we just handle fields as simple keys.\n\n    if isinstance(data, (list, tuple)):\n        # If data is a list, apply the recursion on each element,\n        # collecting results into a list under the key for this level.\n        collected = []\n        for item in data:\n            res = _traverse_results(fields, item)\n            if res:\n                collected.append(res)\n        if collected:\n            return collected\n        else:\n            return None\n\n    if isinstance(data, dict) or isinstance(data, OrderedDict):\n        # If there is only one field, just fetch it from data.\n        if len(fields) == 1:\n            # Return the field and its value if present\n            if current_field in data:\n                results[current_field] = data[current_field]\n                return results\n            else:\n                return None\n\n        # If multiple fields, the next level field(s) must be extracted from the current field's value\n        if current_field in data:\n            next_data = data[current_field]\n            # recurse into next data with remaining fields\n            next_result = _traverse_results(fields[1:], next_data)\n            if next_result:\n                results[current_field] = next_result\n                return results\n            else:\n                return None\n\n    # If data is neither dict nor list, or key not found, return None\n    return None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 762, in <module>\n  File \"<string>\", line 761, in test_50\n  File \"<string>\", line 67, in parse_results\nTypeError: _traverse_results() missing 2 required positional arguments: 'row' and 'path'\n", "passed": false}
{"task_id": 203, "prediction_id": 2, "generation": "def parse_results(fields, data):\n    \"\"\"\n    Traverses ordered dictionary, calls _traverse_results() to recursively read into the dictionary depth of data\n    \"\"\"\n    def _traverse_results(fields, data):\n        \"\"\"\n        Recursively traverse the data dictionary according to the fields list.\n        If fields contain dot notation (nested keys), descend accordingly.\n        If data is a list, recurse into each element.\n        \"\"\"\n        if data is None:\n            return None\n\n        # If data is a list, traverse each element\n        if isinstance(data, list):\n            return [_traverse_results(fields, d) for d in data]\n\n        # If fields is empty, return data as is\n        if not fields:\n            return data\n\n        current_field = fields[0]\n        # If current_field includes dot notation, split here\n        if '.' in current_field:\n            # Split first part and remainder\n            parts = current_field.split('.', 1)\n            first_part = parts[0]\n            remainder = parts[1]\n            # Descend one level with first_part, then descend remainder as new field\n            sub_data = data.get(first_part, None) if isinstance(data, dict) else None\n            if sub_data is None:\n                return None\n            return _traverse_results([remainder] + fields[1:], sub_data)\n\n        # No dot notation in current_field, just descend one key\n        if isinstance(data, dict):\n            sub_data = data.get(current_field, None)\n        else:\n            sub_data = None\n\n        if sub_data is None:\n            return None\n\n        return _traverse_results(fields[1:], sub_data)\n\n    return _traverse_results(fields, data)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 751, in <module>\n  File \"<string>\", line 750, in test_52\nTypeError: object of type 'NoneType' has no len()\n", "passed": false}
{"task_id": 203, "prediction_id": 3, "generation": "def parse_results(fields, data):\n    \"\"\"\n    Traverses ordered dictionary, calls _traverse_results() to recursively read into the dictionary depth of data\n    \"\"\"\n    def _traverse_results(fields, data):\n        \"\"\"\n        Recursively traverse the data dictionary/list according to the fields list.\n        If fields is empty, return the current data.\n        Otherwise process each field in order, descending into nested dictionaries or lists.\n        \"\"\"\n        if not fields:\n            return data\n\n        field = fields[0]\n        remaining_fields = fields[1:]\n\n        if isinstance(data, list):\n            # If data is a list, traverse each item for the fields\n            return [_traverse_results(fields, item) for item in data]\n\n        if isinstance(data, dict):\n            # If the field is present in the current dict, descend into it\n            if field in data:\n                return _traverse_results(remaining_fields, data[field])\n            else:\n                # Field missing, return None or empty list? Let's choose None.\n                return None\n\n        # If data is neither dict nor list, no further traversal possible\n        return None\n\n    return _traverse_results(fields, data)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 737, in <module>\n  File \"<string>\", line 736, in test_52\nTypeError: object of type 'NoneType' has no len()\n", "passed": false}
{"task_id": 203, "prediction_id": 4, "generation": "def parse_results(fields, data):\n    \"\"\"\n    Traverses ordered dictionary, calls _traverse_results() to recursively read into the dictionary depth of data\n    \"\"\"\n    def _traverse_results(fields, data):\n        \"\"\"\n        Helper recursive function to extract values from data for the given fields.\n        If the data is a list, recursively process each item.\n        If the data is a dict or OrderedDict, collect the values corresponding to the fields.\n        \"\"\"\n        if isinstance(data, list):\n            return [_traverse_results(fields, entry) for entry in data]\n        elif isinstance(data, dict):\n            result = OrderedDict()\n            for field in fields:\n                if field in data:\n                    value = data[field]\n                    if isinstance(value, (list, dict)):\n                        # Recursively traverse if value is list/dict\n                        result[field] = _traverse_results(fields, value)\n                    else:\n                        result[field] = value\n                else:\n                    # Field not found: assign None\n                    result[field] = None\n            return result\n        else:\n            # Base case: data is a primitive; just return it (likely at leaf node)\n            return data\n\n    return _traverse_results(fields, data)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 732, in <module>\n  File \"<string>\", line 731, in test_50\nAssertionError\n", "passed": false}
