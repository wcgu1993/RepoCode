{"task_id": 194, "prediction_id": 0, "generation": "def getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n    \"\"\"\n    from luigi.task import Task\n\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, (list, tuple)):\n        return [getpaths(s) for s in struct]\n    elif isinstance(struct, dict):\n        return {k: getpaths(v) for k, v in struct.items()}\n    else:\n        return struct", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 919, in <module>\n  File \"<string>\", line 918, in test_15\nAssertionError\n", "passed": false}
{"task_id": 194, "prediction_id": 1, "generation": "from luigi import Task\n\ndef getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n\n    Traverses through lists, tuples, and dicts recursively. Replaces\n    any Task instance with its .output(). Other data types are kept as is.\n    \"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, list):\n        return [getpaths(item) for item in struct]\n    elif isinstance(struct, tuple):\n        return tuple(getpaths(item) for item in struct)\n    elif isinstance(struct, dict):\n        return {key: getpaths(value) for key, value in struct.items()}\n    else:\n        return struct", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 968, in <module>\n  File \"<string>\", line 967, in test_53\nAssertionError\n", "passed": false}
{"task_id": 194, "prediction_id": 2, "generation": "def getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n    \"\"\"\n    if struct is None:\n        return None\n\n    # Importing here to avoid circular import if needed\n    from luigi.task import Task\n\n    # If it's a Task instance, replace with its output (can be single or list)\n    if isinstance(struct, Task):\n        return struct.output()\n\n    # Recursively handle lists and tuples\n    if isinstance(struct, (list, tuple)):\n        # Recreate same structure type with getpaths applied to each element\n        result = [getpaths(item) for item in struct]\n        return type(struct)(result)\n\n    # Recursively handle dicts: apply getpaths to values, keep keys\n    if isinstance(struct, dict):\n        return {key: getpaths(value) for key, value in struct.items()}\n\n    # Any other type: return as is\n    return struct", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 967, in <module>\n  File \"<string>\", line 966, in test_40\nAssertionError\n", "passed": false}
{"task_id": 194, "prediction_id": 3, "generation": "def getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n    \"\"\"\n    from collections.abc import Mapping, Iterable\n    import luigi\n\n    # Helper to flatten results and keep structure as list\n    def flatten_output(output):\n        if isinstance(output, (list, tuple)):\n            # flatten nested lists/tuples recursively\n            result = []\n            for o in output:\n                if isinstance(o, (list, tuple)):\n                    result.extend(flatten_output(o))\n                else:\n                    result.append(o)\n            return result\n        else:\n            return [output]\n\n    if isinstance(struct, luigi.Task):\n        # If struct is a Task, return its output flattened as a list\n        output = struct.output()\n        return flatten_output(output)\n\n    elif isinstance(struct, Mapping):\n        # If struct is a dict-like mapping, recursively get outputs of values\n        result = {}\n        for k, v in struct.items():\n            result[k] = getpaths(v)\n        return result\n\n    elif isinstance(struct, Iterable) and not isinstance(struct, (str, bytes)):\n        # If struct is any other iterable (list, tuple, set but not str), recursively get outputs of elements\n        # Maintain original type for list and tuple, convert others to list\n        outputs = [getpaths(item) for item in struct]\n\n        if isinstance(struct, tuple):\n            return tuple(outputs)\n        elif isinstance(struct, list):\n            return outputs\n        else:\n            return outputs\n\n    else:\n        # For all other types return an empty list, since not a task nor a structure containing them\n        return []", "message": "passed", "passed": true}
{"task_id": 194, "prediction_id": 4, "generation": "from luigi.task import Task\n\ndef getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n    \"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, list):\n        return [getpaths(item) for item in struct]\n    elif isinstance(struct, tuple):\n        return tuple(getpaths(item) for item in struct)\n    elif isinstance(struct, dict):\n        return {key: getpaths(value) for key, value in struct.items()}\n    elif isinstance(struct, set):\n        return {getpaths(item) for item in struct}\n    else:\n        return struct", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 967, in <module>\n  File \"<string>\", line 966, in test_53\nAssertionError\n", "passed": false}
