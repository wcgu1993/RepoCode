{"task_id": 208, "prediction_id": 0, "generation": "from urllib.parse import urlparse, urlunparse\n\ndef _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n    \"\"\"\n    base_parts = urlparse(base)\n    url_parts = urlparse(url)\n\n    if url_parts.scheme:\n        # If url has a scheme, return it as is (absolute URL)\n        return url\n\n    # We need to join url to base path, but urlparse.urljoin does not support\n    # non-http schemes properly, so we handle path joining by ourselves.\n\n    # Combine paths similar to urljoin logic:\n    if url.startswith('/'):\n        # If url is absolute path, replace the path part of base\n        new_path = url\n    else:\n        # If url is relative path, join it to the base path directory\n        # Get base path directory (remove last segment)\n        base_path = base_parts.path\n        if not base_path.endswith('/'):\n            base_path = base_path[:base_path.rfind('/')+1]\n        new_path = base_path + url\n\n    # Normalize the path (resolve ../ and ./)\n    segments = []\n    for segment in new_path.split('/'):\n        if segment == '..':\n            if segments:\n                segments.pop()\n        elif segment != '.' and segment != '':\n            segments.append(segment)\n    normalized_path = '/' + '/'.join(segments)\n\n    # Reconstruct the new URL with base scheme, netloc, and normalized path,\n    # plus any query or fragment from url (which urlparse url did not have?)\n    # Since url was relative and has no scheme, params, netloc, just path and possibly query/fragment\n    final_query = url_parts.query\n    final_fragment = url_parts.fragment\n\n    new_parts = (\n        base_parts.scheme,\n        base_parts.netloc,\n        normalized_path,\n        '',  # params\n        final_query,\n        final_fragment\n    )\n    return urlunparse(new_parts)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 271, in <module>\n  File \"<string>\", line 270, in test_13\nAssertionError\n", "passed": false}
{"task_id": 208, "prediction_id": 1, "generation": "from urllib.parse import urljoin as std_urljoin, urlparse, urlunparse\n\ndef _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n\n    This function extends the behavior of urllib.parse.urljoin by handling\n    schemes that include '+' (like 'http+unix'), which the standard urljoin\n    does not support properly. It falls back to standard urljoin when the\n    scheme is conventional.\n\n    Args:\n        base (str): The base URL.\n        url (str): The relative or absolute URL to join with the base.\n\n    Returns:\n        str: The joined URL.\n    \"\"\"\n    # Parse the base URL\n    base_parts = urlparse(base)\n    # If scheme contains '+', e.g., 'http+unix', handle specially\n    if '+' in base_parts.scheme:\n        # Parse the url to join\n        url_parts = urlparse(url)\n\n        # If url has a scheme, return it as absolute url\n        if url_parts.scheme:\n            return url\n\n        # Join the path using posixpath normpath-like behavior by using urljoin on path only\n        # We construct a new URL keeping scheme, netloc from base\n        # and join the path from base and url manually\n        # Because urljoin fails on unknown scheme with '+'\n\n        # Compose a new path\n        if url.startswith('/'):\n            # Absolute path overriding base path\n            new_path = url\n        else:\n            # Relative path: Join base's directory + url\n            base_path = base_parts.path\n            if not base_path.endswith('/'):\n                base_path = base_path.rsplit('/', 1)[0] + '/'\n            new_path = base_path + url\n        \n        # Normalize the new path by using urljoin with dummy base\n        # This is to handle things like '../'\n        normalized_path = std_urljoin('http://dummy', new_path)\n        normalized_path = urlparse(normalized_path).path\n\n        # Rebuild the full URL with the original scheme and netloc\n        result = urlunparse((\n            base_parts.scheme,\n            base_parts.netloc,\n            normalized_path,\n            '',  # params\n            '',  # query\n            ''   # fragment\n        ))\n        return result\n    else:\n        # For standard schemes, just use standard urljoin\n        return std_urljoin(base, url)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 281, in <module>\n  File \"<string>\", line 280, in test_13\nAssertionError\n", "passed": false}
{"task_id": 208, "prediction_id": 2, "generation": "from urllib.parse import urlparse, urlunparse\n\n\ndef _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n\n    The standard urllib.parse.urljoin does not correctly handle schemes with\n    '+' in them (e.g., 'http+unix://'), so this function parses the base URL\n    manually, joins the path and query part appropriately, and reconstructs\n    the URL preserving the scheme and netloc.\n\n    Args:\n        base (str): The base URL.\n        url (str): The relative or absolute URL to join with the base.\n\n    Returns:\n        str: The joined URL.\n    \"\"\"\n    base_parts = urlparse(base)\n    url_parts = urlparse(url)\n\n    # If url is absolute (has a scheme), return as is\n    if url_parts.scheme:\n        return url\n\n    # Compose the new path using urljoin logic for the path part only\n    # We need to join the path relative to base's path\n    # Because urlparse.urljoin does not work well with 'http+unix://', we do manual join\n    \n    # If the url path is empty, keep base path, else join\n    if url_parts.path.startswith('/'):\n        # Absolute path, replace base path\n        path = url_parts.path\n    else:\n        # Relative path, join with base path directory\n        # Remove last segment of base path if not ending with '/'\n        base_path = base_parts.path\n        if not base_path.endswith('/'):\n            base_path = base_path[: base_path.rfind('/') + 1]\n        path = base_path + url_parts.path\n\n    # Normalize path by collapsing '..' and '.' segments\n    segments = []\n    for segment in path.split('/'):\n        if segment == '..':\n            if segments:\n                segments.pop()\n        elif segment != '.' and segment != '':\n            segments.append(segment)\n    normalized_path = '/' + '/'.join(segments)\n\n    # Use the url_parts query if present, else empty\n    query = url_parts.query\n\n    # Use fragment from url_parts if any\n    fragment = url_parts.fragment\n\n    # Rebuild the URL preserving base scheme, netloc, but replacing path, query, fragment\n    new_parts = (\n        base_parts.scheme,\n        base_parts.netloc,\n        normalized_path,\n        '',  # params, deprecated and rarely used\n        query,\n        fragment,\n    )\n    return urlunparse(new_parts)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 286, in <module>\n  File \"<string>\", line 285, in test_13\nAssertionError\n", "passed": false}
{"task_id": 208, "prediction_id": 3, "generation": "from urllib.parse import urlparse, urlunparse\n\ndef _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n    \"\"\"\n    # Parse the base and the url to join\n    base_parts = urlparse(base)\n    url_parts = urlparse(url)\n\n    # If url has a scheme, we can mostly use url as absolute\n    if url_parts.scheme:\n        # Special case: If the url scheme is same as base scheme, or url scheme differs but potentially similar\n        # Just return url itself; no joining needed.\n        return url\n\n    # Otherwise url is relative, we must join paths, preserving scheme and netloc from base\n\n    # Build new path by joining base path and url path with care\n    if url.startswith('/'):\n        # Absolute path override base path\n        path = url\n    else:\n        # Relative path: remove last segment of base path and append url\n        base_path = base_parts.path\n        if not base_path.endswith('/'):\n            base_path = base_path.rsplit('/', 1)[0] + '/'\n        path = base_path + url\n\n    # Normalize path to remove any ../ and ./ segments\n    # Use posixpath.normpath since URLs always use forward slash and want correct normalization\n    import posixpath\n    normalized_path = posixpath.normpath(path)\n\n    # If the path resulted from normpath does not start with a '/' but original url started relative, prepend '/'\n    if not normalized_path.startswith('/') and path.startswith('/'):\n        normalized_path = '/' + normalized_path\n\n    # If original url ended with a trailing slash, keep it\n    if url.endswith('/') and not normalized_path.endswith('/'):\n        normalized_path += '/'\n\n    # Construct the new URL\n    new_parts = (\n        base_parts.scheme,\n        base_parts.netloc,\n        normalized_path,\n        '',  # params\n        '',  # query\n        ''   # fragment\n    )\n    return urlunparse(new_parts)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 270, in <module>\n  File \"<string>\", line 269, in test_13\nAssertionError\n", "passed": false}
{"task_id": 208, "prediction_id": 4, "generation": "from urllib.parse import urlparse, urlunparse\n\n\ndef _urljoin(base, url):\n    \"\"\"\n    Join relative URLs to base URLs like urllib.parse.urljoin but support\n    arbitrary URIs (esp. 'http+unix://').\n    \"\"\"\n    # Parse the base and the url to join\n    base_parsed = urlparse(base)\n    url_parsed = urlparse(url)\n\n    # If the url to join is absolute (has a scheme), use it as is\n    if url_parsed.scheme:\n        return url\n\n    # For schemes like 'http+unix' which are non-standard, urllib.parse.urljoin may not work properly.\n    # So we manually join:\n    # - Keep the scheme and authority from base.\n    # - Join the path from base and url properly (respecting relative paths)\n    # To join paths, use posixpath.join with proper normalization.\n\n    import posixpath\n\n    # Determine new path by joining base path directory and the url path\n    if url_parsed.path.startswith('/'):\n        # url path is absolute, so just use it\n        new_path = url_parsed.path\n    else:\n        # url path is relative; join with base path directory\n        base_path_dir = posixpath.dirname(base_parsed.path)\n        new_path = posixpath.normpath(posixpath.join(base_path_dir, url_parsed.path))\n\n    # If url has query or fragment, keep them\n    new_query = url_parsed.query\n    new_fragment = url_parsed.fragment\n\n    # Construct final components tuple\n    new_parts = (\n        base_parsed.scheme,\n        base_parsed.netloc,\n        new_path,\n        url_parsed.params,\n        new_query,\n        new_fragment\n    )\n\n    return urlunparse(new_parts)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 265, in <module>\n  File \"<string>\", line 264, in test_13\nAssertionError\n", "passed": false}
