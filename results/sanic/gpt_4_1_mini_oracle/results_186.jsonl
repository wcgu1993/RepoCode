{"task_id": 186, "prediction_id": 0, "generation": "from collections import defaultdict\nfrom http.cookies import SimpleCookie\nfrom typing import Tuple\n\nfrom sanic.headers import parse_content_header\nfrom sanic.request import RequestParameters\n\n\ndef parse_multipart_form(body: bytes, boundary: bytes) -> Tuple[RequestParameters, RequestParameters]:\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    fields = defaultdict(list)\n    files = defaultdict(list)\n\n    # The boundary is prefixed by '--' in the body and separated by CRLF\n    delimiter = b\"--\" + boundary\n    end_delimiter = delimiter + b\"--\"\n\n    # Split body by boundary delimiter\n    parts = body.split(delimiter)\n\n    # The first part before the first delimiter and the last part after the end delimiter \n    # are usually empty or irrelevant, so ignore them\n    for part in parts[1:]:\n        if part == b\"--\" or part == b\"\":\n            # This is the final boundary or empty\n            continue\n        # Remove leading CRLF if present\n        if part.startswith(b\"\\r\\n\"):\n            part = part[2:]\n\n        # Separate headers and content by double CRLF (\\r\\n\\r\\n)\n        try:\n            header_end = part.index(b\"\\r\\n\\r\\n\")\n        except ValueError:\n            # Invalid multipart section, skip\n            continue\n\n        header_bytes = part[:header_end]\n        content = part[header_end + 4 :]  # content after \\r\\n\\r\\n\n\n        # Parse headers\n        headers = {}\n        for line in header_bytes.split(b\"\\r\\n\"):\n            if b\":\" not in line:\n                continue\n            name, value = line.split(b\":\", 1)\n            name = name.strip().decode(\"utf-8\").lower()\n            value = value.strip().decode(\"utf-8\")\n            headers[name] = value\n\n        # Content-Disposition header is mandatory to identify form-data parts\n        disposition_value = headers.get(\"content-disposition\")\n        if disposition_value is None:\n            continue\n\n        disposition, params = parse_content_header(disposition_value)\n\n        if disposition != \"form-data\":\n            continue\n\n        field_name = params.get(\"name\")\n        if not field_name:\n            continue\n\n        filename = params.get(\"filename\")\n\n        if filename is not None:\n            # It's a file\n            # Content-Type header might exist for files, default to text/plain if not\n            content_type = headers.get(\"content-type\", \"text/plain\")\n            # Store as a tuple (type, body, name) as in File named tuple\n            # Here, fields and files are RequestParameters so we store File-like namedtuple\n            # But the Query states to return RequestParameters for both fields and files.\n            # We'll store files[field_name] as a list of File named tuples.\n\n            # Since RequestParameters store lists of values, and get returns the first,\n            # we can store list of File named tuples for files.\n\n            from sanic.request import File\n\n            file_obj = File(type=content_type, body=content, name=filename)\n            files[field_name].append(file_obj)\n        else:\n            # Regular form field, decode content to string\n            # RFC7578 says it's US-ASCII or specified charset in Content-Type; if absent,\n            # often UTF-8 or Latin1 is used by browsers. Here, decode as utf-8 with fallback.\n            try:\n                value = content.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                value = content.decode(\"latin1\")\n            fields[field_name].append(value)\n\n    # Convert defaultdict to RequestParameters for return\n    return RequestParameters(fields), RequestParameters(files)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 866, in <module>\n  File \"<string>\", line 865, in test_4\nAssertionError\n", "passed": false}
{"task_id": 186, "prediction_id": 1, "generation": "from http.cookies import SimpleCookie\nfrom urllib.parse import unquote\n\nfrom sanic.headers import parse_content_header\n\n\ndef parse_multipart_form(body, boundary):\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    # Initialize containers for form fields and files\n    fields = {}\n    files = {}\n\n    # The delimiter to split parts is b\"--\" + boundary\n    delimiter = b\"--\" + boundary\n\n    # The end delimiter has an extra '--' at the end\n    close_delimiter = delimiter + b\"--\"\n\n    # Split body by delimiter, ignoring any prefix before first delimiter\n    parts = body.split(delimiter)\n\n    for part in parts:\n        # Strip leading/trailing whitespace and CRLF from each part\n        part = part.strip(b\"\\r\\n\")\n        if not part or part == b\"--\":\n            # Skip empty parts or the closing boundary marker\n            continue\n        if part == close_delimiter:\n            # End part\n            break\n\n        # Each part consists of headers and body separated by \\r\\n\\r\\n\n        try:\n            header_part, body_part = part.split(b\"\\r\\n\\r\\n\", 1)\n        except ValueError:\n            # Malformed part without header/body separation; ignore\n            continue\n\n        # Parse headers line by line\n        headers = {}\n        for header_line in header_part.split(b\"\\r\\n\"):\n            if b\":\" not in header_line:\n                continue\n            name, value = header_line.split(b\":\", 1)\n            headers[name.strip().decode(\"utf-8\").lower()] = value.strip().decode(\n                \"utf-8\"\n            )\n\n        # The Content-Disposition header is required to get the field name\n        content_disposition = headers.get(\"content-disposition\")\n        if not content_disposition:\n            # Skip if no content-disposition\n            continue\n\n        disposition, params = parse_content_header(content_disposition)\n\n        # If disposition is not form-data, ignore part\n        if disposition != \"form-data\":\n            continue\n\n        field_name = params.get(\"name\")\n        if not field_name:\n            # Cannot process without a field name\n            continue\n\n        filename = params.get(\"filename\")\n\n        if filename is None:\n            # This is a regular form field; decode body as utf-8 string\n            # Per form spec, lines might be CRLF terminated. We treat body_part raw.\n\n            # NOTE: Some forms may send fields with multiple values:\n            # this implementation collects all values in a list.\n\n            value = body_part.decode(\"utf-8\", errors=\"replace\")\n            value = unquote(value)  # decode any percent-encoded strings\n\n            # Accumulate values for the field\n            if field_name in fields:\n                fields[field_name].append(value)\n            else:\n                fields[field_name] = [value]\n        else:\n            # It's a file upload: store type, name, and content\n            # Content-Type header may be present\n            content_type = headers.get(\"content-type\", \"text/plain\")\n\n            # Accumulate files for the field (as list)\n            file_obj = (content_type, body_part, filename)\n            if field_name in files:\n                files[field_name].append(file_obj)\n            else:\n                files[field_name] = [file_obj]\n\n    # Convert to RequestParameters (dict subclass with lists)\n    from collections import defaultdict\n    from sanic.request import RequestParameters  # We must define this or assume exists\n\n    form_fields = RequestParameters(fields)\n    form_files = RequestParameters(files)\n\n    return form_fields, form_files", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 918, in <module>\n  File \"<string>\", line 894, in test_10\nAssertionError\n", "passed": false}
{"task_id": 186, "prediction_id": 2, "generation": "from http.cookies import SimpleCookie\nfrom collections import defaultdict\nfrom sanic.headers import parse_content_header\n\ndef parse_multipart_form(body, boundary):\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    # Prepare containers for fields and files\n    fields = defaultdict(list)\n    files = defaultdict(list)\n\n    # Boundary strings\n    boundary_str = b\"--\" + boundary\n    boundary_end = b\"--\" + boundary + b\"--\"\n\n    # Split body by boundary, ignoring first empty before first boundary\n    parts = body.split(boundary_str)\n    # The first element before the first boundary or after last may be empty or irrelevant\n    # The last part ends with boundary_end, may contain trailing CRLF, clean that\n\n    for part in parts:\n        # Strip CRLF\n        part = part.strip(b\"\\r\\n\")\n        if not part or part == b\"--\":\n            continue  # Skip empty or end boundary separators\n\n        # Separate headers and body by searching first blank line (double CRLF)\n        try:\n            header_end = part.index(b\"\\r\\n\\r\\n\")\n        except ValueError:\n            # No headers/body separator, invalid part; skip\n            continue\n\n        headers_block = part[:header_end].decode(\"utf-8\", errors=\"replace\")\n        data = part[header_end + 4 :]\n\n        # Parse headers into a dict\n        headers = {}\n        for line in headers_block.split(\"\\r\\n\"):\n            if \":\" not in line:\n                continue\n            key, value = line.split(\":\", 1)\n            headers[key.strip().lower()] = value.strip()\n\n        # Must have Content-Disposition header\n        if \"content-disposition\" not in headers:\n            continue\n        disposition, disp_params = parse_content_header(headers[\"content-disposition\"])\n\n        if disposition != \"form-data\":\n            # Not form-data disposition - ignore\n            continue\n\n        name = disp_params.get(\"name\")\n        if not name:\n            # No name param means we can't assign the field - skip\n            continue\n\n        filename = disp_params.get(\"filename\")\n\n        if filename is None:\n            # Normal form field\n            # Data could be bytes, decode as UTF-8 (standard) with errors replaced\n            value = data.decode(\"utf-8\", errors=\"replace\")\n            fields[name].append(value)\n        else:\n            # File upload field\n            # Determine content type, default to 'text/plain' if not present\n            content_type = headers.get(\"content-type\", \"text/plain\")\n            # Store as tuple-like File namedtuple\n            files[name].append(\n                File(type=content_type, body=data, name=filename)  # Using provided File NamedTuple\n            )\n\n    # Convert defaultdict to RequestParameters which accepts dict of list values\n    # for fields: decode lists into RequestParameters\n    from sanic.request import RequestParameters\n\n    fields_params = RequestParameters(fields)\n    files_params = RequestParameters(files)\n\n    return fields_params, files_params", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 897, in <module>\n  File \"<string>\", line 873, in test_10\nAssertionError\n", "passed": false}
{"task_id": 186, "prediction_id": 3, "generation": "from collections import defaultdict\nfrom typing import Tuple\n\ndef parse_multipart_form(body: bytes, boundary: bytes) -> Tuple[\"RequestParameters\", \"RequestParameters\"]:\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    fields = defaultdict(list)\n    files = defaultdict(list)\n\n    delimiter = b\"--\" + boundary\n    close_delimiter = b\"--\" + boundary + b\"--\"\n\n    # Split body by boundary, ignoring any prefix before the first boundary\n    parts = body.split(delimiter)\n    # The first part before initial boundary can be empty or junk, ignore\n    # The last part may contain the closing delimiter suffix\n    for part in parts[1:]:\n        # Remove leading \\r\\n (if any)\n        if part.startswith(b\"\\r\\n\"):\n            part = part[2:]\n\n        # Check for closing boundary\n        if part.endswith(b\"--\"):\n            part = part[:-2]\n            # This is the last part, could be empty so just break after processing\n            if not part:\n                break\n\n        # If the part is empty after stripping, skip\n        if not part.strip():\n            continue\n\n        # Headers end at the first empty line (\\r\\n\\r\\n)\n        header_end = part.find(b\"\\r\\n\\r\\n\")\n        if header_end == -1:\n            # No header-body separator, invalid part, skip\n            continue\n\n        headers_blob = part[:header_end].decode(\"utf-8\", errors=\"replace\")\n        part_body = part[header_end + 4 :]\n\n        # Parse headers into dict (case-insensitive keys)\n        headers = {}\n        for line in headers_blob.split(\"\\r\\n\"):\n            if \":\" not in line:\n                continue\n            k, v = line.split(\":\", 1)\n            headers[k.strip().lower()] = v.strip()\n\n        # Content-Disposition is mandatory for form-data parts\n        if \"content-disposition\" not in headers:\n            continue\n\n        # parse_content_header function is used to parse content-disposition value with parameters\n        content_disposition, disposition_params = parse_content_header(headers[\"content-disposition\"])\n\n        if content_disposition != \"form-data\":\n            continue\n\n        name = disposition_params.get(\"name\")\n        if not name:\n            # skip parts without a name param\n            continue\n\n        filename = disposition_params.get(\"filename\")\n\n        if filename is None:\n            # This is a regular form field\n            # Decode body as utf-8\n            value = part_body.decode(\"utf-8\", errors=\"replace\")\n            fields[name].append(value)\n        else:\n            # This is a file upload field\n            # Determine content type\n            content_type = headers.get(\"content-type\", \"text/plain\")\n            # Append a File namedtuple object with type, body, name\n            # The File tuple is (type: str, body: bytes, name: str)\n            files[name].append(File(type=content_type, body=part_body, name=filename))\n\n    # Convert lists to RequestParameters or leave as-is for files (RequestParameters works as a dict with list values)\n    fields_params = RequestParameters(fields)\n    files_params = RequestParameters(files)\n\n    return fields_params, files_params", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 855, in <module>\n  File \"<string>\", line 854, in test_4\nAssertionError\n", "passed": false}
{"task_id": 186, "prediction_id": 4, "generation": "from typing import Tuple, Dict, List\nfrom http.cookies import SimpleCookie\nfrom sanic_routing.route import Route  # type: ignore\nfrom sanic.headers import Options\n\n\ndef parse_multipart_form(body: bytes, boundary: bytes) -> Tuple[\"RequestParameters\", \"RequestParameters\"]:\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    from collections import defaultdict\n    from urllib.parse import unquote\n\n    # Import RequestParameters from the current module or define a dummy here for standalone\n    class RequestParameters(dict):\n        def get(self, name: str, default=None):\n            return super().get(name, [default])[0]\n\n        def getlist(self, name: str, default=None):\n            return super().get(name, default)\n\n    fields: RequestParameters = RequestParameters()\n    files: RequestParameters = RequestParameters()\n\n    # Boundary delimiters\n    delimiter = b\"--\" + boundary\n    close_delimiter = b\"--\" + boundary + b\"--\"\n\n    # Split body by boundary delimiter\n    parts = body.split(delimiter)\n\n    for part in parts:\n        part = part.strip(b\"\\r\\n\")\n        if not part or part == b'--':\n            continue  # skip empty and final extra delimiters\n\n        # Separate headers and data\n        try:\n            headers_blob, data = part.split(b\"\\r\\n\\r\\n\", 1)\n        except ValueError:\n            # No headers/data separation, skip invalid part\n            continue\n        headers_blob = headers_blob.decode(\"utf-8\", errors=\"replace\")\n        data = data.rstrip(b\"\\r\\n\")  # trim trailing CRLF from data\n\n        # Parse headers line by line\n        headers = {}\n        for line in headers_blob.split(\"\\r\\n\"):\n            if not line:\n                continue\n            if \":\" not in line:\n                continue\n            key, val = line.split(\":\", 1)\n            headers[key.strip().lower()] = val.strip()\n\n        # parse Content-Disposition header\n        if \"content-disposition\" not in headers:\n            # Skip parts without content-disposition header\n            continue\n\n        disposition, params = parse_content_header(headers[\"content-disposition\"])\n\n        if disposition != \"form-data\":\n            # Skip parts that are not form-data\n            continue\n\n        # Extract the name parameter (form field name)\n        if \"name\" not in params:\n            # Skip if no name parameter\n            continue\n        field_name = params[\"name\"]\n\n        if \"filename\" in params:\n            # This is a file upload\n            filename = params[\"filename\"]\n            content_type = headers.get(\"content-type\", \"text/plain\")\n\n            # Store as tuple mimetype, body, filename\n            files.setdefault(field_name, [])\n            files[field_name].append(\n                # We store like RequestParameters: a dict with list values, so append to list\n                # According to File namedtuple: (type, body, name)\n                # But since RequestParameters is dict of lists (strings), we will store file tuples\n                # We'll keep files[field_name] as list of File namedtuples\n                File(type=content_type, body=data, name=filename)\n            )\n        else:\n            # This is a regular form field\n            value = data.decode(\"utf-8\", errors=\"replace\")\n            fields.setdefault(field_name, [])\n            fields[field_name].append(value)\n\n    # Convert single values to lists in fields and files properly\n    # Make sure all values in fields and files are lists to satisfy RequestParameters contract\n    # fields and files are already using setdefault and appending in lists, so just done.\n\n    return fields, files", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 911, in <module>\n  File \"<string>\", line 887, in test_10\nAssertionError\n", "passed": false}
