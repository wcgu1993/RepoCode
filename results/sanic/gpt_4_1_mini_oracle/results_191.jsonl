{"task_id": 191, "prediction_id": 0, "generation": "def format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    # Compose the status line (bytes) using the prebuilt _HTTP1_STATUSLINES list.\n    # If status code is out of range, fallback to a default status line.\n    if 0 <= status < len(_HTTP1_STATUSLINES):\n        status_line = _HTTP1_STATUSLINES[status]\n    else:\n        # Compose a generic status line if status code is unknown/out of range\n        reason = STATUS_CODES.get(status, b\"UNKNOWN\")\n        status_line = b\"HTTP/1.1 %d %b\\r\\n\" % (status, reason)\n\n    # Compose headers lines, each header key and value are bytes, format as b\"key: value\\r\\n\"\n    header_lines = b\"\".join(key + b\": \" + value + b\"\\r\\n\" for key, value in headers)\n\n    # End of headers indicated by an empty line: b\"\\r\\n\"\n    return status_line + header_lines + b\"\\r\\n\"", "message": "passed", "passed": true}
{"task_id": 191, "prediction_id": 1, "generation": "from typing import Iterable, Tuple\n\nHeaderBytesIterable = Iterable[Tuple[bytes, bytes]]\n\ndef format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    # Compose the status line using a prebuilt list of status lines for efficiency\n    # If status is out of range, use a generic unknown status line\n    if 0 <= status < len(_HTTP1_STATUSLINES):\n        status_line = _HTTP1_STATUSLINES[status]\n    else:\n        # Compose a fallback status line if status code is invalid or out of range\n        reason = STATUS_CODES.get(status, b\"UNKNOWN\")\n        status_line = b\"HTTP/1.1 %d %b\\r\\n\" % (status, reason)\n\n    # Format headers: Each header is bytes key and bytes value,\n    # compose \"Key: Value\\r\\n\"\n    header_lines = b\"\".join(k + b\": \" + v + b\"\\r\\n\" for k, v in headers)\n\n    # Combine status line, headers, and the final blank line \"\\r\\n\" to indicate end of headers.\n    return status_line + header_lines + b\"\\r\\n\"", "message": "passed", "passed": true}
{"task_id": 191, "prediction_id": 2, "generation": "from typing import Iterable, Tuple, Any\n\ndef format_http1_response(status: int, headers: Iterable[Tuple[bytes, bytes]]) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    # Compose the status line using the preformatted template from _HTTP1_STATUSLINES if possible\n    if 0 <= status < 1000:\n        status_line = _HTTP1_STATUSLINES[status]\n    else:\n        # Fallback if status code is out of range\n        # Use \"UNKNOWN\" as the reason phrase for unknown codes\n        status_bytes = STATUS_CODES.get(status, b\"UNKNOWN\")\n        status_line = b\"HTTP/1.1 %d %b\\r\\n\" % (status, status_bytes)\n\n    # Compose headers lines: each as b\"key: value\\r\\n\"\n    header_lines = b\"\".join(key + b\": \" + value + b\"\\r\\n\" for key, value in headers)\n\n    # End of headers is an empty line\n    return status_line + header_lines + b\"\\r\\n\"", "message": "passed", "passed": true}
{"task_id": 191, "prediction_id": 3, "generation": "from typing import Iterable, Tuple\n\nHeaderBytesIterable = Iterable[Tuple[bytes, bytes]]\n\ndef format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    # Use prebuilt status line if status is in range\n    if 0 <= status < len(_HTTP1_STATUSLINES):\n        status_line = _HTTP1_STATUSLINES[status]\n    else:\n        # Fallback format for unknown status codes\n        text = STATUS_CODES.get(status, b\"UNKNOWN\")\n        status_line = b\"HTTP/1.1 %d %b\\r\\n\" % (status, text)\n\n    # Format each header as b\"Key: Value\\r\\n\"\n    headers_bytes = b\"\".join(\n        key + b\": \" + value + b\"\\r\\n\" for key, value in headers\n    )\n\n    # Combine status line, headers, and final CRLF to separate headers from body\n    return status_line + headers_bytes + b\"\\r\\n\"", "message": "passed", "passed": true}
{"task_id": 191, "prediction_id": 4, "generation": "def format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    # Use the pre-built HTTP/1.1 status line if possible\n    try:\n        status_line = _HTTP1_STATUSLINES[status]\n    except IndexError:\n        # fallback: construct manually if status out of range\n        reason = STATUS_CODES.get(status, b\"UNKNOWN\")\n        status_line = b\"HTTP/1.1 %d %b\\r\\n\" % (status, reason)\n\n    # Format headers as bytes: each header is `key: value\\r\\n`\n    # headers are already bytes tuples, so just join\n    headers_bytes = b\"\".join(\n        key + b\": \" + value + b\"\\r\\n\" for key, value in headers\n    )\n\n    # Final response header: status line + headers + extra \\r\\n\n    return status_line + headers_bytes + b\"\\r\\n\"", "message": "passed", "passed": true}
