{"task_id": 187, "prediction_id": 0, "generation": "import re\nfrom typing import Dict, Tuple, Union\n\nOptions = Dict[str, Union[int, str]]\n\n_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'\n_param = re.compile(fr\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n\ndef parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    if not value:\n        return '', {}\n\n    parts = value.split(';', 1)\n    main_value = parts[0].strip().lower()\n\n    options: Options = {}\n\n    if len(parts) == 1:\n        return main_value, options\n\n    rest = parts[1]\n    for match in _param.finditer(\";\" + rest):\n        key = match.group(1).lower()\n        if match.group(2) is not None:\n            val = match.group(2)\n            # Unescape Firefox-escaped quotes (\\\") inside quoted strings\n            val = _firefox_quote_escape.sub('\"', val)\n        else:\n            val = match.group(3)\n\n        options[key] = val\n\n    return main_value, options", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 282, in <module>\n  File \"<string>\", line 281, in test_13\nAssertionError\n", "passed": false}
{"task_id": 187, "prediction_id": 1, "generation": "import re\nfrom typing import Tuple, Dict, Union\n\nOptions = Dict[str, Union[int, str]]\n\n_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'\n_param = re.compile(fr\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n\ndef parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    if not value:\n        return \"\", {}\n\n    parts = value.split(\";\", 1)\n    key = parts[0].strip().lower()\n    opts: Options = {}\n\n    if len(parts) == 1:\n        return key, opts\n\n    rest = parts[1]\n\n    for match in _param.finditer(\";\" + rest):\n        k, v_quoted, v_unquoted = match.group(1), None, None\n\n        # match.group(2) corresponds to (?:token|quoted)\n        # Because the regex is fr\";\\s*({token})=(?:({token})|({quoted}))\"\n        # Our compiled pattern currently has two capture groups for value\n        # But here it's only two groups: group(2) captures either token or quoted excluding quotes.\n        # In _param pattern: group(2) could be token OR quoted (since they are alternatives)\n        # Actually from the _param definition, group(2) matches either token or quoted quoted string without quotes outside.\n        # We must distinguish between quoted or unquoted value:\n        val_match = match.group(2)\n        if val_match is not None:\n            # _quoted regex adds quotes captured in group(2), so val_match includes quotes?\n            # Actually _param pattern is fr\";\\s*{_token}=(?:{_token}|{_quoted})\"\n            # _token = group 1, then = (token or quoted):\n            # So group(1): key, group(2): token or quoted without quotes thanks to (_quoted) = r'\"([^\"]*)\"'\n            v = val_match\n        else:\n            v = \"\"\n\n        # Special unescaping of Firefox style escaping: \\\"\n        # only when quoted string\n        if v.startswith('\"') and v.endswith('\"'):\n            v = v[1:-1]\n            # unescape \\\"\n            v = _firefox_quote_escape.sub('\"', v)\n        # But our regex already excludes wrapping quotes in group capture for quoted,\n        # so above v can't start and end with quotes. So this is handled below.\n\n        # From inspecting group capture, the quoted string capture excludes the quotes themselves,\n        # so no need to strip quotes here. Use what was captured in group(2).\n\n        # Actually, _param captures group(1) = token key\n        # group(2) = either token (unquoted) or quoted string without quotes\n\n        # So above \"v\" is already unquoted if quoted.\n\n        # So simply unescape \\\"\n        v = _firefox_quote_escape.sub('\"', v)\n\n        opts[k.lower()] = v\n\n    return key, opts", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 268, in <module>\n  File \"<string>\", line 265, in test_0\nAssertionError\n", "passed": false}
{"task_id": 187, "prediction_id": 2, "generation": "import re\nfrom typing import Tuple, Dict, Union\n\nOptions = Dict[str, Union[int, str]]  # key=value fields in various headers\n\n_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'\n_param = re.compile(fr\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n\ndef parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    # Strip leading/trailing whitespace\n    if value is None:\n        return \"\", {}\n\n    parts = value.split(\";\", 1)\n    main_value = parts[0].strip().lower() if parts else \"\"\n    options: Options = {}\n\n    if len(parts) == 1:\n        return main_value, options\n\n    rest = parts[1]\n    for match in _param.finditer(\";\" + rest):\n        key, val = match.group(1), match.group(2)\n        # _param captures either token or quoted string in group 2\n        # If quoted string, unescape any Firefox-escaped quotes (\\\")\n        if val is None:\n            val = match.group(3) or \"\"\n        unescaped = _firefox_quote_escape.sub('\"', val) if val else val\n        options[key.lower()] = unescaped\n\n    return main_value, options", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 280, in <module>\n  File \"<string>\", line 279, in test_13\nAssertionError\n", "passed": false}
{"task_id": 187, "prediction_id": 3, "generation": "import re\nfrom typing import Dict, Tuple\n\nOptions = Dict[str, str]\n\n_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'\n_param = re.compile(fr\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n\n\ndef parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    if not value:\n        return \"\", {}\n\n    # Split the main value and the parameters (after semicolons)\n    parts = value.split(\";\")\n    main_value = parts[0].strip().lower()\n\n    options: Options = {}\n    for param_match in _param.finditer(value):\n        key = param_match.group(1).lower()\n        val = param_match.group(2)\n        if val is None:\n            val = param_match.group(3)  # quoted value group\n            if val is not None:\n                # Unescape escaped quotes (\\\") only for Firefox-style escaping\n                val = _firefox_quote_escape.sub('\"', val)\n        if val is None:\n            # fallback if regex didn't capture groups as expected\n            val = \"\"\n        options[key] = val\n\n    return main_value, options", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 281, in <module>\n  File \"<string>\", line 280, in test_13\nAssertionError\n", "passed": false}
{"task_id": 187, "prediction_id": 4, "generation": "import re\nfrom typing import Dict, Tuple, Union\n\nOptions = Dict[str, Union[int, str]]\n\n_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'\n_param = re.compile(fr\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n\ndef parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    if not value:\n        return \"\", {}\n\n    # split out the main value before any ';'\n    parts = value.split(\";\", 1)\n    main_value = parts[0].strip().lower()\n    options: Options = {}\n\n    if len(parts) == 1:\n        return main_value, options\n\n    # parse parameters after the first ';'\n    params_part = parts[1]\n\n    for match in _param.finditer(\";\" + params_part):\n        key = match.group(1).lower()\n        if match.group(2) is not None:\n            # Unquoted token\n            val = match.group(2)\n        else:\n            # Quoted value - group 3\n            val = match.group(3) or \"\"\n            # Firefox treats escaped quotes differently, so unescape those\n            val = _firefox_quote_escape.sub('\"', val)\n        options[key] = val\n\n    return main_value, options", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 285, in <module>\n  File \"<string>\", line 284, in test_13\nAssertionError\n", "passed": false}
