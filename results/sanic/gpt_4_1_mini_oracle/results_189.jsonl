{"task_id": 189, "prediction_id": 0, "generation": "import re\nfrom urllib.parse import unquote\n\n# We can infer from the rest of the code that an address normalization\n# function should handle IP addresses (IPv4 and IPv6), quoted strings,\n# and potentially unknown formats gracefully,\n# returning a cleaned string representation suitable for proxy header fields.\n\n_ipv6 = r\"(?:[0-9A-Fa-f]{0,4}:){2,7}[0-9A-Fa-f]{0,4}\"\n_ipv6_re = re.compile(f\"^{_ipv6}$\")\n\ndef fwd_normalize_address(addr: str) -> str:\n    \"\"\"Normalize address fields of proxy headers.\"\"\"\n    addr = addr.strip()\n    if not addr:\n        return addr\n\n    # Remove surrounding quotes if present\n    if len(addr) >= 2 and addr[0] == '\"' and addr[-1] == '\"':\n        addr = addr[1:-1]\n\n    # If IPv6 is wrapped in square brackets (e.g. [::1]), keep brackets\n    # but validate inside\n    if addr.startswith(\"[\") and addr.endswith(\"]\"):\n        ip = addr[1:-1]\n        if _ipv6_re.match(ip):\n            return f\"[{ip.lower()}]\"\n        else:\n            # Not a valid IPv6 inside, return as is (unquoted)\n            return ip.lower()\n\n    # Check if addr looks like IPv6 (without brackets)\n    if _ipv6_re.match(addr):\n        return addr.lower()\n\n    # Unquote any %-encoded sequences (for IPv6 zone index etc)\n    # Though normally zone index is after %, which unquote handles\n    addr = unquote(addr)\n\n    return addr", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 256, in <module>\n  File \"<string>\", line 255, in test_7\nAssertionError\n", "passed": false}
{"task_id": 189, "prediction_id": 1, "generation": "import re\n\n_ipv6 = \"(?:[0-9A-Fa-f]{0,4}:){2,7}[0-9A-Fa-f]{0,4}\"\n_ipv6_re = re.compile(_ipv6)\n_host_re = re.compile(\n    r\"((?:\\[\" + _ipv6 + r\"\\])|[a-zA-Z0-9.\\-]{1,253})(?::(\\d{1,5}))?\"\n)\n\n\ndef fwd_normalize_address(addr: str) -> str:\n    \"\"\"Normalize address fields of proxy headers.\"\"\"\n    addr = addr.strip()\n    # Handle obfuscated identifiers (like _hidden, unknown, unknown, etc.)\n    if not addr or addr == 'unknown':\n        return addr\n\n    # If addr starts with \"_\", treat as obfuscated identifier - return as is.\n    if addr.startswith(\"_\"):\n        return addr\n\n    # Parse IPv6 literal with optional port\n    if addr.startswith(\"[\"):\n        # e.g. [::1]:80\n        m = _host_re.fullmatch(addr)\n        if m:\n            host, port = m.groups()\n            # Normalize host by lowercasing\n            normalized_host = host.lower()\n            if port is not None:\n                return f\"{normalized_host}:{int(port)}\"\n            return normalized_host\n\n    # For IPv4 or hostname with optional port\n    m = _host_re.fullmatch(addr)\n    if m:\n        host, port = m.groups()\n        normalized_host = host.lower()\n        if port is not None:\n            # Validate port is in numeric range\n            try:\n                port_num = int(port)\n                if 0 <= port_num <= 65535:\n                    return f\"{normalized_host}:{port_num}\"\n            except ValueError:\n                pass\n            # If port invalid, return only host\n            return normalized_host\n        return normalized_host\n\n    # Fallback return original (lowercased)\n    return addr.lower()", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 347, in <module>\n  File \"<string>\", line 346, in test_49\nAssertionError\n", "passed": false}
{"task_id": 189, "prediction_id": 2, "generation": "import re\n\ndef fwd_normalize_address(addr: str) -> str:\n    \"\"\"Normalize address fields of proxy headers.\"\"\"\n    # Strip whitespace\n    addr = addr.strip()\n\n    # Check for IPv6 address in brackets with optional port: [IPv6]:port\n    if addr.startswith('['):\n        # Find the closing bracket\n        end = addr.find(']')\n        if end == -1:\n            # Malformed IPv6 address, return as is\n            return addr.lower()\n        # Extract IPv6 part inside brackets\n        host = addr[1:end]\n        # After the closing bracket, check for port e.g. :8080\n        port = addr[end+1:]\n        if port.startswith(':'):\n            port = port[1:]\n            # Validate port is numeric\n            if port.isdigit():\n                try:\n                    port_num = int(port)\n                    if 0 <= port_num <= 65535:\n                        return f\"[{host.lower()}]:{port_num}\"\n                except ValueError:\n                    pass\n            # If invalid port, just return lowercase address\n            return addr.lower()\n        else:\n            # No port, just IPv6 in brackets\n            return f\"[{host.lower()}]\"\n    else:\n        # Split addr by colon to check for IPv4/hostname + port\n        # Count colons to differentiate IPv6 without brackets and host:port\n        # If more than one colon and no brackets, treat whole as host (IPv6 without brackets is invalid per RFC7230 but might appear)\n        colon_count = addr.count(':')\n        if colon_count == 0:\n            # No port, just hostname or IPv4 address\n            return addr.lower()\n        elif colon_count == 1:\n            # Possible host:port format\n            host, sep, port = addr.rpartition(':')\n            if port.isdigit():\n                try:\n                    port_num = int(port)\n                    if 0 <= port_num <= 65535:\n                        return f\"{host.lower()}:{port_num}\"\n                except ValueError:\n                    pass\n            # Not a valid port, treat entire as host\n            return addr.lower()\n        else:\n            # Multiple colons but no brackets, treat whole as host (likely invalid or raw IPv6 without brackets)\n            return addr.lower()", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 296, in <module>\n  File \"<string>\", line 295, in test_14\nAssertionError\n", "passed": false}
{"task_id": 189, "prediction_id": 3, "generation": "import ipaddress\nimport re\n\ndef fwd_normalize_address(addr: str) -> str:\n    \"\"\"Normalize address fields of proxy headers.\"\"\"\n    # addr can be an IP (v4 or v6), optionally with a port (e.g. \"1.2.3.4:80\" or \"[::1]:443\")\n    # The goal is to return a normalized string IP without port and normalized format.\n    # For IPv6, normalize to its canonical form without brackets.\n    # If there's a port, discard it.\n    # If it is 'unknown', return it as is.\n    addr = addr.strip()\n    if not addr or addr.lower() == \"unknown\":\n        return addr\n\n    # Check for IPv6 literal with port, e.g. [::1]:443\n    if addr.startswith('['):\n        # IPv6 with brackets -> extract inside brackets\n        match = re.match(r'^\\[([^\\]]+)\\](?::\\d+)?$', addr)\n        if match:\n            ip_str = match.group(1)\n            try:\n                ip = ipaddress.IPv6Address(ip_str)\n                return ip.compressed.lower()\n            except ipaddress.AddressValueError:\n                # Not a valid IPv6, return as is without brackets and port\n                return ip_str.lower()\n        else:\n            # malformed, return lower\n            return addr.lower()\n\n    # Check if there's a port separated by colon, but not IPv6 literal\n    # To distinguish, if more than one colon and no brackets, it's IPv6 without port.\n    colon_pos = addr.rfind(\":\")\n    if colon_pos != -1:\n        # If more than one colon, likely IPv6 without port\n        if addr.count(\":\") > 1:\n            # Try to parse as IPv6\n            try:\n                ip = ipaddress.IPv6Address(addr)\n                return ip.compressed.lower()\n            except ipaddress.AddressValueError:\n                # Not IPv6, fallback\n                pass\n        else:\n            # Possibly IPv4 with port or hostname with port\n            ip_part = addr[:colon_pos]\n            port_part = addr[colon_pos+1:]\n            # Check if port part is digits\n            if port_part.isdigit():\n                # Validate IP part\n                try:\n                    ip = ipaddress.ip_address(ip_part)\n                    return ip.compressed.lower()\n                except ValueError:\n                    # Not IP, return ip_part lowercase\n                    return ip_part.lower()\n            else:\n                # Not a port, return lowercase whole addr\n                return addr.lower()\n\n    # No port found, try to parse as IP directly\n    try:\n        ip = ipaddress.ip_address(addr)\n        return ip.compressed.lower()\n    except ValueError:\n        # Not an IP, return lowercase as is\n        return addr.lower()", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 271, in <module>\n  File \"<string>\", line 270, in test_0\nAssertionError\n", "passed": false}
{"task_id": 189, "prediction_id": 4, "generation": "import re\n\ndef fwd_normalize_address(addr: str) -> str:\n    \"\"\"Normalize address fields of proxy headers.\"\"\"\n    addr = addr.strip()\n\n    # If addr is empty, return as is\n    if not addr:\n        return addr\n\n    # Check if addr is an IPv6 address enclosed in brackets, possibly with port\n    # Format: [IPv6]:port or [IPv6]\n    if addr.startswith(\"[\"):\n        # Match IPv6 and optional port\n        m = re.match(r\"^\\[([0-9A-Fa-f:]+)\\](?::(\\d{1,5}))?$\", addr)\n        if m:\n            ip = m.group(1).lower()\n            port = m.group(2)\n            # Validate port if present\n            if port:\n                try:\n                    port_num = int(port)\n                    if 0 <= port_num <= 65535:\n                        return f\"[{ip}]:{port_num}\"\n                except ValueError:\n                    pass\n                # If port invalid, omit port\n                return f\"[{ip}]\"\n            else:\n                return f\"[{ip}]\"\n        # If regex doesn't match, return as is (fallback)\n        return addr\n\n    # For non-bracket addresses, check if port included (IPv4 or hostname:port)\n    # Split on last colon for potential port\n    if \":\" in addr:\n        parts = addr.rsplit(\":\", 1)\n        host = parts[0]\n        port = parts[1]\n        # Validate port: must be numeric and 0-65535\n        if port.isdigit():\n            port_num = int(port)\n            if 0 <= port_num <= 65535:\n                # Normalize host to lowercase\n                # Host can be IPv4 or domain name; lowercase domain name makes sense\n                return f\"{host.lower()}:{port_num}\"\n        # If port not valid number, treat whole as host\n        return addr.lower()\n    else:\n        # No port, just normalize lowercase\n        return addr.lower()", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 291, in <module>\n  File \"<string>\", line 290, in test_14\nAssertionError\n", "passed": false}
