{"task_id": 187, "prediction_id": 0, "generation": "import re\nfrom typing import Tuple, Dict, Union\n\nOptions = Dict[str, Union[int, str]]\n\n_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'\n_param = re.compile(fr\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n\n\ndef parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    if not value:\n        return \"\", {}\n\n    value = value.strip()\n    if \";\" not in value:\n        # Only main value, no parameters\n        return value, {}\n\n    # Split once on first ';' to get main value and the rest parameters string\n    main_value, params_str = value.split(\";\", 1)\n    main_value = main_value.strip().lower()\n\n    options: Options = {}\n\n    # find all parameters\n    for match in _param.finditer(\";\" + params_str):\n        key, val = match.group(1), match.group(2)\n        if val is None:\n            # If second group didn't match (quoted) then try the first group again\n            val = match.group(3)\n        if val is None:\n            # Defensive fallback: treat as empty string if no value found\n            val = \"\"\n\n        # Unescape any Firefox-style escaped quotes (\\\"), and remove backslashes from quoted string\n        val = _firefox_quote_escape.sub('\"', val)\n\n        options[key.lower()] = val\n\n    return main_value, options", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 289, in <module>\n  File \"<string>\", line 288, in test_13\nAssertionError\n", "passed": false}
{"task_id": 187, "prediction_id": 1, "generation": "import re\nfrom typing import Tuple, Dict, Union\n\nOptions = Dict[str, Union[int, str]]\n\n_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'\n_param = re.compile(fr\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n\ndef parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    if not value:\n        return '', {}\n\n    # Split main value and params by looking for ';' but preserving quoted parts\n    # Use regex _param to find all parameters (key=value)\n    parts = value.split(\";\", 1)\n    main_value = parts[0].strip().lower()  # header values are case insensitive for type\n    options: Options = {}\n\n    # Find all params using regex _param\n    for match in _param.finditer(value):\n        key, val = match.group(1), match.group(2)\n        if val is None:\n            # Sometimes group(2) is None if second alternative (unquoted) matched as group(1)\n            # Actually per regex either group(2) or the second _token part will be matched.\n            val = match.group(3)  # This is None since we only have two groups per regex.\n        # Currently group(1) is key, group(2) is either _token or _quoted\n        # So in the regex:\n        #  group(1) = key\n        #  group(2) = either unquoted token or quoted value (without quotes)\n        # The regex uses (?:{_token}|{_quoted}), so only one will capture in second group\n        # Because _quoted is wrapped in quotes but group captures inside quotes.\n\n        # Unescape any escaped quotes (Firefox style)\n        if val is not None:\n            val_unescaped = _firefox_quote_escape.sub('\"', val)\n            options[key.lower()] = val_unescaped\n        else:\n            options[key.lower()] = ''\n\n    return main_value, options", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 289, in <module>\n  File \"<string>\", line 288, in test_13\nAssertionError\n", "passed": false}
{"task_id": 187, "prediction_id": 2, "generation": "import re\nfrom typing import Dict, Tuple, Union\n\n# These regex are copied from the code context\n_token = r\"([\\w!#$%&'*+\\-.^_`|~]+)\"\n_quoted = r'\"([^\"]*)\"'\n_param = re.compile(fr\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n\nOptions = Dict[str, Union[int, str]]  # from the context\n\ndef parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    # Split main value and parameters using semicolon\n    # The main value is the substring before first ';' or the whole string if no ';'\n    main_value, *rest = value.split(\";\", 1)\n    main_value = main_value.strip()\n    params_str = rest[0] if rest else \"\"\n\n    options: Options = {}\n\n    # Use regex to find all key=value pairs\n    for match in _param.finditer(value):\n        key = match.group(1).lower()  # header params keys are usually case-insensitive, lowercase to normalize\n        val_token = match.group(2)\n        val_quoted = match.group(3)\n        if val_token is not None:\n            val = val_token\n        elif val_quoted is not None:\n            # Unescape quotes inside the quoted string using _firefox_quote_escape\n            val = _firefox_quote_escape.sub('\"', val_quoted)\n        else:\n            val = \"\"\n\n        options[key] = val\n\n    return main_value, options", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 284, in <module>\n  File \"<string>\", line 283, in test_13\nAssertionError\n", "passed": false}
{"task_id": 187, "prediction_id": 3, "generation": "import re\nfrom typing import Tuple, Dict, Union\n\nOptions = Dict[str, Union[int, str]]\n\n# Patterns reused from file content for token and quoted string\n_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'\n_param = re.compile(fr\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n\n\ndef parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    if not value:\n        return \"\", {}\n\n    # Split off the first token (main value) before any parameters\n    # Note: We assume the first segment before ';' is the main value.\n    parts = value.split(\";\", 1)\n    main_value = parts[0].strip().lower()\n\n    options: Options = {}\n\n    if len(parts) == 1:\n        return main_value, options\n\n    # Parse parameters after first ';'\n    for match in _param.finditer(\";\" + parts[1]):\n        key = match.group(1).lower()\n        val = match.group(2) or match.group(3) or \"\"\n        # Unescape quoted strings like filename=\"file.txt\"\n        # The regex ensures group(2) is the quoted string content withoutquotes\n        # Undo escaped quotes \\\" inside quoted string (not at end or before ; or space)\n        if val and val.startswith('\"') and val.endswith('\"'):\n            val = val[1:-1]\n        # _param captures quoted part without surrounding quotes in group(2), so no need to strip quotes here\n        # But if quoted group(2) is used, val is already unquoted\n        # Our regex sets val=group(2) if quoted, else group(3) - we masked that here.\n\n        # Actually group(2) is the quoted content without quotes, group(3) is unquoted token.\n        # So val is group(2) if quoted, group(3) if unquoted. No quotes to strip.\n\n        # Fix escaped quotes inside quoted string for Firefox style\n        if val and '\"' in val:\n            val = _firefox_quote_escape.sub('\"', val)\n\n        options[key] = val\n\n    return main_value, options", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 296, in <module>\n  File \"<string>\", line 295, in test_13\nAssertionError\n", "passed": false}
{"task_id": 187, "prediction_id": 4, "generation": "import re\nfrom typing import Tuple, Dict, Union\n\nOptions = Dict[str, Union[int, str]]\n\n_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"((?:[^\"\\\\]|\\\\.)*)\"'\n_param = re.compile(fr\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_escapes = re.compile(r'\\\\(.)')\n\n\ndef _unescape_quoted(value: str) -> str:\n    \"\"\"Unescape quoted string by replacing escaped chars (\\\" -> \", \\\\ -> \\)\"\"\"\n    return _escapes.sub(r\"\\1\", value)\n\n\ndef parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    if not value:\n        return \"\", {}\n\n    parts = value.split(\";\", 1)\n    main_value = parts[0].strip().lower()\n    options: Options = {}\n\n    if len(parts) == 1:\n        return main_value, options\n\n    # Process parameters\n    for match in _param.finditer(\";\" + parts[1]):\n        key = match.group(1).lower()\n        val = match.group(2)\n        if val is None:\n            val = match.group(3)  # quoted group\n            if val is not None:\n                val = _unescape_quoted(val)\n        else:\n            val = val\n        options[key] = val\n\n    return main_value, options", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 479, in <module>\n  File \"<string>\", line 478, in test_82\nAssertionError\n", "passed": false}
