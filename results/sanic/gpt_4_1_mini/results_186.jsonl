{"task_id": 186, "prediction_id": 0, "generation": "from collections import defaultdict\nimport re\n\ndef parse_multipart_form(body, boundary):\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    # Prepare the prefix and suffix boundary markers\n    if not boundary.startswith(b'--'):\n        boundary = b'--' + boundary\n\n    # Split body by boundary, remove the first and last empty parts\n    parts = body.split(boundary)\n    # Strip the first and last parts if they are empty or just line breaks\n    if parts[0].strip() == b'':\n        parts = parts[1:]\n    if parts[-1].strip() in (b'--', b''):\n        parts = parts[:-1]\n\n    fields = defaultdict(list)\n    files = defaultdict(list)\n\n    # Regex to parse Content-Disposition header\n    cd_re = re.compile(\n        r'form-data;\\s*name=\"(?P<name>[^\"]+)\"(?:;\\s*filename=\"(?P<filename>[^\"]*)\")?'\n    )\n\n    for part in parts:\n        part = part.strip(b'\\r\\n')\n        if not part:\n            continue\n\n        # Split headers and content\n        try:\n            # Headers and body are separated by double CRLF\n            header_bytes, content = part.split(b'\\r\\n\\r\\n', 1)\n        except ValueError:\n            # Malformed part, skip\n            continue\n\n        # Parse headers lines\n        headers = {}\n        for line in header_bytes.split(b'\\r\\n'):\n            if b':' not in line:\n                continue\n            header_name, header_value = line.split(b':', 1)\n            headers[header_name.strip().lower()] = header_value.strip()\n\n        # Parse Content-Disposition header for name and filename\n        cd = headers.get(b'content-disposition')\n        if cd is None:\n            # Skip parts without content-disposition\n            continue\n\n        # Decode to string for regex matching\n        cd_str = cd.decode('utf-8', errors='replace')\n\n        m = cd_re.match(cd_str)\n        if not m:\n            continue  # Could not parse Content-Disposition\n\n        name = m.group('name')\n        filename = m.group('filename')\n\n        # Remove trailing CRLF from content, if any\n        if content.endswith(b'\\r\\n'):\n            content = content[:-2]\n\n        if filename is None or filename == '':\n            # This is a form field\n            # Decode bytes content to string using utf-8 or replace errors\n            value = content.decode('utf-8', errors='replace')\n            fields[name].append(value)\n        else:\n            # This is a file field\n            # Prepare a file tuple: (type, body, name)\n            # Try to get content-type header if any\n            content_type = headers.get(b'content-type', b'text/plain').decode('utf-8', errors='replace')\n            files[name].append((content_type, content, filename))\n\n    # Convert defaultdict to RequestParameters, which expects dict of lists\n    from sanic.request import RequestParameters\n\n    fields_params = RequestParameters(fields)\n    files_params = RequestParameters(files)\n\n    return fields_params, files_params", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 948, in <module>\n  File \"<string>\", line 934, in test_15\nAssertionError\n", "passed": false}
{"task_id": 186, "prediction_id": 1, "generation": "from collections import defaultdict\nfrom http.cookies import SimpleCookie\nfrom typing import Tuple\n\nfrom sanic.request import RequestParameters\n\n\ndef parse_multipart_form(body: bytes, boundary: bytes) -> Tuple[RequestParameters, RequestParameters]:\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    # Prepare the return containers\n    fields = RequestParameters()\n    files = RequestParameters()\n\n    # Boundary marker parts\n    delimiter = b\"--\" + boundary\n    close_delimiter = b\"--\" + boundary + b\"--\"\n\n    # Split body by boundary\n    parts = body.split(delimiter)\n\n    # The first element before the first boundary and after final boundary are not parts we want\n    # so trim empty or irrelevant parts\n    for part in parts:\n        part = part.strip(b\"\\r\\n\")\n        if not part or part == b'--':\n            continue\n        if part.startswith(b\"--\") and part.strip() == close_delimiter:\n            # End of multipart body\n            break\n\n        # Each part headers and content are separated by a blank line (i.e. \\r\\n\\r\\n)\n        try:\n            header_section, content = part.split(b\"\\r\\n\\r\\n\", 1)\n        except ValueError:\n            # Malformed part, skip it\n            continue\n\n        # Parse headers\n        headers = {}\n        for header_line in header_section.split(b\"\\r\\n\"):\n            if b\":\" not in header_line:\n                continue\n            name, value = header_line.split(b\":\", 1)\n            headers[name.strip().lower()] = value.strip()\n\n        # Extract Content-Disposition header (required)\n        content_disposition = headers.get(b\"content-disposition\")\n        if not content_disposition:\n            # Skip parts without content-disposition\n            continue\n\n        # Parse Content-Disposition parameters\n        # Example: b'form-data; name=\"field1\"; filename=\"example.txt\"'\n        disposition_parts = content_disposition.decode(\"utf-8\", errors=\"replace\").split(\";\")\n        disposition_type = disposition_parts[0].strip().lower()\n        disposition_params = {}\n        for disp_part in disposition_parts[1:]:\n            if \"=\" in disp_part:\n                key, val = disp_part.strip().split(\"=\", 1)\n                val = val.strip('\"')\n                disposition_params[key.strip().lower()] = val\n\n        if disposition_type != \"form-data\":\n            continue  # Ignore unknown disposition types for form-data parsing\n\n        name = disposition_params.get(\"name\")\n        filename = disposition_params.get(\"filename\")\n\n        # Extract Content-Type header (optional, for files)\n        content_type = headers.get(b\"content-type\")\n        if content_type:\n            content_type = content_type.decode(\"utf-8\", errors=\"replace\")\n        else:\n            # Default content type for files is text/plain\n            content_type = \"text/plain\"\n\n        # Eliminate trailing CRLF on content if present\n        if content.endswith(b\"\\r\\n\"):\n            content = content[:-2]\n\n        if filename:\n            # It's a file\n            files[name] = {\n                \"type\": content_type,\n                \"body\": content,\n                \"name\": filename,\n            }\n        else:\n            # It's a regular form field, decode bytes as utf-8 string\n            try:\n                fields[name] = content.decode(\"utf-8\", errors=\"replace\")\n            except Exception:\n                fields[name] = content  # fallback to bytes if decoding fails\n\n    return fields, files", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 911, in <module>\n  File \"<string>\", line 887, in test_10\nAssertionError\n", "passed": false}
{"task_id": 186, "prediction_id": 2, "generation": "import re\nfrom http.cookies import SimpleCookie\n\nfrom sanic.request import RequestParameters\n\n\ndef parse_multipart_form(body, boundary):\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    # Prepare the results containers\n    fields = RequestParameters()\n    files = RequestParameters()\n\n    # The full boundary is prefixed with b'--'\n    full_boundary = b\"--\" + boundary\n\n    # Split body by the boundary delimiter\n    parts = body.split(full_boundary)\n\n    # Normally the first part is preamble, last part is epilogue or b\"--\\r\\n\"\n    # We'll skip first and last if they are empty or irrelevant\n    for part in parts:\n        # Strip leading/trailing whitespace, including \\r\\n\n        part = part.strip(b\"\\r\\n\")\n        if not part or part == b\"--\":  # Ignore empty or closing boundary indicator\n            continue\n\n        # Separate headers and content by looking for first double CRLF (\\r\\n\\r\\n)\n        try:\n            header_bytes, content = part.split(b\"\\r\\n\\r\\n\", 1)\n        except ValueError:\n            # Malformed part (no headers/content separation)\n            continue\n\n        # Decode headers as ISO-8859-1 per HTTP spec to preserve bytes as is\n        headers_str = header_bytes.decode(\"iso-8859-1\")\n\n        # Parse headers lines\n        headers = {}\n        for header_line in headers_str.split(\"\\r\\n\"):\n            # headers like: Content-Disposition: form-data; name=\"field1\"; filename=\"a.txt\"\n            if \":\" not in header_line:\n                continue\n            name, value = header_line.split(\":\", 1)\n            headers[name.strip().lower()] = value.strip()\n\n        # Content-Disposition is required in multipart/form-data\n        if \"content-disposition\" not in headers:\n            continue\n\n        # Parse Content-Disposition parameters to get name and filename\n        disposition, *params = re.split(r\";\\s*\", headers[\"content-disposition\"])\n        if disposition.lower() != \"form-data\":\n            continue\n\n        disposition_params = {}\n        for param in params:\n            if \"=\" not in param:\n                continue\n            k, v = param.split(\"=\", 1)\n            k = k.strip().lower()\n            # Strip quotes if any\n            if len(v) >= 2 and v[0] == '\"' and v[-1] == '\"':\n                v = v[1:-1]\n            disposition_params[k] = v\n\n        # The 'name' parameter is mandatory for each field\n        if \"name\" not in disposition_params:\n            continue\n        field_name = disposition_params[\"name\"]\n\n        # Check if this part is a file upload (filename present)\n        filename = disposition_params.get(\"filename\")\n\n        # Extract Content-Type if any (default to text/plain if absent for file)\n        content_type = headers.get(\"content-type\")\n\n        if filename is None:\n            # Regular form field, decode as UTF-8 ignoring errors for safety\n            try:\n                value = content.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                # Fallback: decode as latin1 to preserve raw bytes as str\n                value = content.decode(\"latin1\")\n            # Store the value in fields dictionary (as list for multi-value support)\n            if field_name in fields:\n                # append to existing list\n                current = fields[field_name]\n                if isinstance(current, list):\n                    current.append(value)\n                    fields[field_name] = current\n                else:\n                    fields[field_name] = [current, value]\n            else:\n                fields[field_name] = [value]\n        else:\n            # It's a file upload\n            # Store a File namedtuple: (type, body, name)\n            from sanic.request import File\n\n            file_type = content_type or \"text/plain\"\n            file_obj = File(type=file_type, body=content, name=filename)\n\n            if field_name in files:\n                current = files[field_name]\n                if isinstance(current, list):\n                    current.append(file_obj)\n                    files[field_name] = current\n                else:\n                    files[field_name] = [current, file_obj]\n            else:\n                files[field_name] = [file_obj]\n\n    # Convert single-item lists to single values, keep lists if multiple\n    def _finalize(storage):\n        finalized = RequestParameters()\n        for key, val in storage.items():\n            if isinstance(val, list):\n                if len(val) == 1:\n                    finalized[key] = val[0]\n                else:\n                    finalized[key] = val\n            else:\n                finalized[key] = val\n        return finalized\n\n    return _finalize(fields), _finalize(files)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 942, in <module>\n  File \"<string>\", line 918, in test_10\nAssertionError\n", "passed": false}
{"task_id": 186, "prediction_id": 3, "generation": "from collections import defaultdict\nfrom http.cookies import SimpleCookie\n\n\ndef parse_multipart_form(body, boundary):\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    fields = defaultdict(list)\n    files = defaultdict(list)\n\n    if not boundary:\n        return fields, files\n\n    # The boundary format in the body is:\n    # --<boundary>\\r\\n\n    # headers\\r\\n\n    # \\r\\n\n    # body\n    # ...\n    # and ends with --<boundary>--\n    boundary_marker = b\"--\" + boundary\n    # Split body on boundary markers\n    parts = body.split(boundary_marker)\n    # Strip first empty part before first boundary and last after closing boundary\n    # The last part should be b'--' or b'--\\r\\n' or empty; ignore trailing parts after final boundary marker\n\n    # The last part should signify the end, e.g. b'--\\r\\n' or b'--'\n    # We'll ignore any part after encounter of the last '--' marker with trailing stuff.\n\n    for part in parts[1:]:  # skip the preamble before the first boundary marker\n        # Each part starts with b'\\r\\n' and ends before the next boundary or b'--' (final)\n        # Remove leading '\\r\\n' if present\n        if part.startswith(b\"\\r\\n\"):\n            part = part[2:]\n        # Check if this is the last part\n        if part.startswith(b\"--\"):\n            # This marks the end, stop parsing\n            break\n        if not part:\n            continue\n\n        # Split headers and body at first double CRLF (\\r\\n\\r\\n)\n        try:\n            headers_part, body_part = part.split(b\"\\r\\n\\r\\n\", 1)\n        except ValueError:\n            # Malformed part, no headers/body delimiter\n            continue\n\n        body_part = body_part.rstrip(b\"\\r\\n\")  # remove trailing newline(s)\n\n        # Parse headers lines\n        headers = {}\n        for header_line in headers_part.split(b\"\\r\\n\"):\n            if not header_line:\n                continue\n            try:\n                # header line is like b\"Content-Disposition: form-data; name=\\\"fieldname\\\"; filename=\\\"file.txt\\\"\"\n                name, value = header_line.split(b\":\", 1)\n                name = name.strip().decode(\"latin1\").lower()\n                value = value.strip().decode(\"latin1\")\n                headers[name] = value\n            except Exception:\n                continue  # ignore malformed header lines\n\n        # We require at least a Content-Disposition header\n        content_disposition = headers.get(\"content-disposition\")\n        if not content_disposition:\n            # Can't parse without content disposition\n            continue\n\n        # Parse Content-Disposition parameters (e.g. form-data; name=\"fieldname\"; filename=\"filename.txt\")\n        disposition_parts = content_disposition.split(\";\")\n        disposition_type = disposition_parts[0].strip().lower()\n        params = {}\n        for param in disposition_parts[1:]:\n            if '=' in param:\n                param_name, param_value = param.strip().split(\"=\", 1)\n                param_name = param_name.strip().lower()\n                param_value = param_value.strip()\n                if param_value.startswith('\"') and param_value.endswith('\"'):\n                    param_value = param_value[1:-1]\n                params[param_name] = param_value\n\n        field_name = params.get(\"name\")\n        filename = params.get(\"filename\")\n\n        if field_name is None:\n            # skip parts without a field name\n            continue\n\n        if filename is None:\n            # This is a regular form field\n            fields[field_name].append(body_part.decode(\"utf-8\", errors=\"replace\"))\n        else:\n            # This is a file upload\n            content_type = headers.get(\"content-type\", \"text/plain\")\n            # Create a simple file representation (type, body, name)\n            # Here, compatible with File namedtuple from file content:\n            # File(type: str, body: bytes, name: str)\n            # Use the fields dictionary to keep files keyed by field_name\n            # We store a File namedtuple for each file item\n            from sanic.request import File\n            files[field_name].append(File(type=content_type, body=body_part, name=filename))\n\n    # Convert lists to RequestParameters (dict subclass where get returns first)\n    # For files, use RequestParameters as well to be consistent with implementation pattern\n    from sanic.request import RequestParameters\n\n    fields_params = RequestParameters({k: v for k, v in fields.items()})\n    files_params = RequestParameters({k: v for k, v in files.items()})\n\n    return fields_params, files_params", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 883, in <module>\n  File \"<string>\", line 882, in test_4\nAssertionError\n", "passed": false}
{"task_id": 186, "prediction_id": 4, "generation": "from collections import defaultdict\nfrom http.cookies import SimpleCookie\nfrom typing import Tuple\n\nimport email.utils\n\n\ndef parse_multipart_form(body: bytes, boundary: bytes) -> Tuple[\"RequestParameters\", \"RequestParameters\"]:\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    # The request parameters to hold normal fields and files\n    fields = RequestParameters()\n    files = RequestParameters()\n\n    # Boundary marker used to split parts, prefixed by b'--'\n    delimiter = b\"--\" + boundary\n    # The end boundary is delimiter + b'--'\n    close_delimiter = delimiter + b\"--\"\n\n    # Split the body by the delimiter, trimming any leading/trailing whitespace/newlines\n    parts = body.split(delimiter)[1:]  # first split before first boundary is junk\n    # Remove last part if it is the closing boundary with trailing stuff\n    if parts and parts[-1].startswith(b\"--\"):\n        parts[-1] = parts[-1].rstrip(b\"\\r\\n\")\n\n    # Helpers to parse headers in each part\n    def parse_part_headers(header_bytes: bytes) -> dict:\n        headers = {}\n        for line in header_bytes.split(b\"\\r\\n\"):\n            if not line:\n                continue\n            if b\":\" not in line:\n                continue\n            key, value = line.split(b\":\", 1)\n            headers[key.strip().decode(\"utf-8\").lower()] = value.strip().decode(\"utf-8\")\n        return headers\n\n    for part in parts:\n        # Each part is separated into headers and body by b'\\r\\n\\r\\n'\n        # We strip leading CRLF to avoid empty first lines\n        part = part.lstrip(b\"\\r\\n\")\n        if not part:\n            continue\n\n        try:\n            header_part, part_body = part.split(b\"\\r\\n\\r\\n\", 1)\n        except ValueError:\n            # Malformed part (no headers/body separation), skip\n            continue\n\n        headers = parse_part_headers(header_part)\n\n        # Remove trailing CRLF from part_body\n        if part_body.endswith(b\"\\r\\n\"):\n            part_body = part_body[:-2]\n\n        disposition = headers.get(\"content-disposition\", \"\")\n        if not disposition:\n            continue\n\n        # Parse content-disposition parameters (e.g., form-data; name=\"field1\"; filename=\"file.txt\")\n        disposition, *params = disposition.split(\";\")\n        disposition = disposition.strip().lower()\n        params_dict = {}\n        for param in params:\n            if \"=\" not in param:\n                continue\n            key, val = param.strip().split(\"=\", 1)\n            val = val.strip()\n            if val.startswith('\"') and val.endswith('\"'):\n                val = val[1:-1]\n            params_dict[key.lower()] = val\n\n        # Must be form-data disposition with a name parameter\n        if disposition != \"form-data\" or \"name\" not in params_dict:\n            continue\n\n        field_name = params_dict[\"name\"]\n\n        # Determine if this part is a file or a field\n        filename = params_dict.get(\"filename\")\n        content_type = headers.get(\"content-type\", \"text/plain\")\n\n        if filename:\n            # This is a file part\n            file_obj = File(type=content_type, body=part_body, name=filename)\n            # store in files - multiple files per field name may appear, so use list behavior\n            if field_name not in files:\n                files[field_name] = []\n            files[field_name].append(file_obj)\n        else:\n            # This is a regular form field - decode as utf-8 string\n            try:\n                value = part_body.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                value = part_body.decode(\"latin1\")  # fallback to latin1 if utf-8 fails\n\n            # store in fields - multiple values per field name are possible\n            if field_name not in fields:\n                fields[field_name] = []\n            fields[field_name].append(value)\n\n    # Wrap all file lists as RequestParameters (with lists as values)\n    for key in files:\n        # If only one file, still keep list for compliance with RequestParameters\n        files[key] = files[key]\n\n    # Wrap all fields' values similarly\n    for key in fields:\n        fields[key] = fields[key]\n\n    return fields, files", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 883, in <module>\n  File \"<string>\", line 882, in test_4\nAssertionError\n", "passed": false}
