{"task_id": 178, "prediction_id": 0, "generation": "from sanic.utils import str_to_bool\n\n\ndef add_status_code(code, quiet=None):\n    \"\"\"\n    Decorator used for adding exceptions to :class:`SanicException`.\n    \"\"\"\n    # Normalize quiet to a boolean if it is not None\n    if quiet is not None:\n        quiet = str_to_bool(str(quiet))\n\n    def decorator(cls):\n        # Only add attribute if it is not already set to avoid overwriting\n        if not hasattr(cls, \"status_code\"):\n            cls.status_code = code\n\n        # Quiet attribute controls if the exception is logged or not (usually).\n        # Attach it only if quiet is explicitly set.\n        if quiet is not None:\n            cls.quiet = quiet\n\n        # Register the exception in the global exception map for the status code\n        _sanic_exceptions[code] = cls\n\n        return cls\n\n    return decorator", "message": "passed", "passed": true}
{"task_id": 178, "prediction_id": 1, "generation": "from sanic.exceptions import SanicException\nfrom sanic.utils import str_to_bool\n\ndef add_status_code(code, quiet=None):\n    \"\"\"\n    Decorator used for adding exceptions to :class:`SanicException`.\n    \"\"\"\n\n    if isinstance(quiet, str):\n        quiet = str_to_bool(quiet)\n\n    def decorator(exception_class):\n        if not isinstance(code, int) or not (100 <= code <= 599):\n            raise ValueError(f\"Invalid HTTP status code: {code}\")\n\n        if not issubclass(exception_class, SanicException):\n            if quiet:\n                return exception_class\n            raise TypeError(\n                \"The decorated class must be a subclass of SanicException\"\n            )\n\n        _sanic_exceptions[code] = exception_class\n        return exception_class\n\n    return decorator", "message": "passed", "passed": true}
{"task_id": 178, "prediction_id": 2, "generation": "import warnings\nfrom sanic.utils import str_to_bool\n\ndef add_status_code(code, quiet=None):\n    \"\"\"\n    Decorator used for adding exceptions to :class:`SanicException`.\n    \"\"\"\n\n    # Normalize quiet param\n    if quiet is not None and not isinstance(quiet, bool):\n        try:\n            quiet = str_to_bool(str(quiet))\n        except ValueError:\n            quiet = False\n    elif quiet is None:\n        quiet = False\n\n    def decorator(cls):\n        existing = _sanic_exceptions.get(code)\n        if existing is not None and not quiet:\n            warnings.warn(\n                f\"Replacing existing exception class {existing} for status code {code} \"\n                f\"with {cls}.\",\n                RuntimeWarning,\n            )\n        _sanic_exceptions[code] = cls\n        return cls\n\n    return decorator", "message": "passed", "passed": true}
{"task_id": 178, "prediction_id": 3, "generation": "from typing import Optional, Union, Callable, Type\nfrom sanic.utils import str_to_bool\n\n\ndef add_status_code(code: int, quiet: Optional[Union[str, bool]] = None) -> Callable[[Type[Exception]], Type[Exception]]:\n    \"\"\"\n    Decorator used for adding exceptions to :class:`SanicException`.\n    \n    Associates a given HTTP status code with an exception class.\n    \n    :param code: HTTP status code to associate with.\n    :param quiet: Suppress overriding warnings/errors if True. Can be a bool or string.\n    :return: class decorator that registers the exception.\n    \"\"\"\n    # _sanic_exceptions is from the same module global dict\n    global _sanic_exceptions\n\n    # Convert quiet string to bool if needed\n    if isinstance(quiet, str):\n        quiet = str_to_bool(quiet)\n    elif quiet is None:\n        quiet = False  # default to raise error on duplicates\n\n    def decorator(cls: Type[Exception]) -> Type[Exception]:\n        if not callable(cls):\n            raise TypeError(\"add_status_code decorator can only be applied to callable classes.\")\n\n        if code in _sanic_exceptions and not quiet:\n            existing_cls = _sanic_exceptions[code]\n            if existing_cls is not cls:\n                raise ValueError(\n                    f\"Status code {code} is already registered for exception {existing_cls.__name__}.\"\n                )\n\n        _sanic_exceptions[code] = cls\n\n        # Also set the status_code attribute on the class if not set yet\n        if not hasattr(cls, \"status_code\"):\n            setattr(cls, \"status_code\", code)\n\n        return cls\n\n    return decorator", "message": "passed", "passed": true}
{"task_id": 178, "prediction_id": 4, "generation": "from sanic.utils import str_to_bool\n\ndef add_status_code(code, quiet=None):\n    \"\"\"\n    Decorator used for adding exceptions to :class:`SanicException`.\n    \"\"\"\n\n    def decorator(cls):\n        # Assign the status code to the exception class\n        cls.status_code = code\n\n        # If quiet flag is provided, convert to bool if it's a string\n        if quiet is not None:\n            if isinstance(quiet, str):\n                cls.quiet = str_to_bool(quiet)\n            else:\n                cls.quiet = bool(quiet)\n\n        # Register the exception class under the HTTP status code\n        _sanic_exceptions[code] = cls\n\n        return cls\n\n    return decorator", "message": "passed", "passed": true}
