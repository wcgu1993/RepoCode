{"task_id": 191, "prediction_id": 0, "generation": "def format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    try:\n        status_line = _HTTP1_STATUSLINES[status]\n    except IndexError:\n        status_line = b\"HTTP/1.1 %d UNKNOWN\\r\\n\" % status\n\n    header_bytes = bytearray()\n    header_bytes.extend(status_line)\n    for key, value in headers:\n        header_bytes.extend(key)\n        header_bytes.extend(b\": \")\n        header_bytes.extend(value)\n        header_bytes.extend(b\"\\r\\n\")\n\n    header_bytes.extend(b\"\\r\\n\")\n    return bytes(header_bytes)", "message": "passed", "passed": true}
{"task_id": 191, "prediction_id": 1, "generation": "from typing import Iterable, Tuple\nfrom sanic.helpers import STATUS_CODES\n\nHeaderBytesIterable = Iterable[Tuple[bytes, bytes]]\n\n\ndef format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    status_message = STATUS_CODES.get(status, b\"UNKNOWN\")\n    status_line = b\"HTTP/1.1 \" + str(status).encode() + b\" \" + status_message + b\"\\r\\n\"\n    header_lines = [key + b\": \" + value + b\"\\r\\n\" for key, value in headers]\n    return b\"\".join([status_line] + header_lines + [b\"\\r\\n\"])", "message": "passed", "passed": true}
{"task_id": 191, "prediction_id": 2, "generation": "from typing import Iterable, Tuple\n\nHeaderBytesIterable = Iterable[Tuple[bytes, bytes]]\n\ndef format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    # Use prebuilt status lines for efficiency\n    if 0 <= status < len(_HTTP1_STATUSLINES):\n        status_line = _HTTP1_STATUSLINES[status]\n    else:\n        # Fallback to a generic status line\n        status_line = b\"HTTP/1.1 %d UNKNOWN\\r\\n\" % status\n\n    # Format headers\n    header_lines = []\n    for key, value in headers:\n        # Assuming headers are bytes as per type hint\n        header_lines.append(key + b\": \" + value + b\"\\r\\n\")\n\n    # Combine all parts\n    response = status_line + b\"\".join(header_lines) + b\"\\r\\n\"\n    return response", "message": "passed", "passed": true}
{"task_id": 191, "prediction_id": 3, "generation": "def format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    if 0 <= status < len(_HTTP1_STATUSLINES):\n        status_line = _HTTP1_STATUSLINES[status]\n    else:\n        reason = STATUS_CODES.get(status, b\"UNKNOWN\")\n        status_line = b\"HTTP/1.1 %d %b\\r\\n\" % (status, reason)\n\n    header_lines = b\"\".join(key + b\": \" + value + b\"\\r\\n\" for key, value in headers)\n\n    return status_line + header_lines + b\"\\r\\n\"", "message": "passed", "passed": true}
{"task_id": 191, "prediction_id": 4, "generation": "from typing import Iterable, Tuple\nfrom sanic.helpers import STATUS_CODES\n\nHeaderBytesIterable = Iterable[Tuple[bytes, bytes]]\n\n_HTTP1_STATUSLINES = [\n    b\"HTTP/1.1 %d %b\\r\\n\" % (status, STATUS_CODES.get(status, b\"UNKNOWN\"))\n    for status in range(1000)\n]\n\n\ndef format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    if 0 <= status < 1000:\n        status_line = _HTTP1_STATUSLINES[status]\n    else:\n        reason = STATUS_CODES.get(status, b\"UNKNOWN\")\n        status_line = b\"HTTP/1.1 %d %b\\r\\n\" % (status, reason)\n\n    headers_bytes = b\"\".join(name + b\": \" + value + b\"\\r\\n\" for name, value in headers)\n    return status_line + headers_bytes + b\"\\r\\n\"", "message": "passed", "passed": true}
