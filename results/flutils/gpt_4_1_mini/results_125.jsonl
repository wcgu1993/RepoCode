{"task_id": 125, "prediction_id": 0, "generation": "from typing import Optional, Union, Tuple, List, cast\nfrom distutils.version import StrictVersion\n\n# Constants (as from file content)\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n\n_BUMP_VERSION_POSITION_NAMES = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\nclass _VersionPart(tuple):\n    # Re-create NamedTuple like class for _VersionPart here for type clarity\n    # but here we just use tuple with named fields for easier access\n    # We won't use this class explicitly, but will in yield from _each_version_part\n    pass\n\ndef _each_version_part(\n        ver_obj: StrictVersion,\n) -> 'List[_VersionPart]':\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    parts = []\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        parts.append(_VersionPart(\n            kwargs['pos'],\n            kwargs['txt'],\n            kwargs['num'],\n            kwargs['pre_txt'],\n            kwargs['pre_num'],\n            kwargs['name'],\n        ))\n    return parts\n\nclass _VersionPart(tuple):\n    def __new__(cls, pos, txt, num, pre_txt, pre_num, name):\n        return tuple.__new__(cls, (pos, txt, num, pre_txt, pre_num, name))\n\n    @property\n    def pos(self):\n        return self[0]\n    @property\n    def txt(self):\n        return self[1]\n    @property\n    def num(self):\n        return self[2]\n    @property\n    def pre_txt(self):\n        return self[3]\n    @property\n    def pre_num(self):\n        return self[4]\n    @property\n    def name(self):\n        return self[5]\n\nclass _VersionInfo(tuple):\n    def __new__(cls,\n                version: str,\n                major: _VersionPart,\n                minor: _VersionPart,\n                patch: _VersionPart,\n                pre_pos: int):\n        return tuple.__new__(cls, (version, major, minor, patch, pre_pos))\n\n    @property\n    def version(self):\n        return self[0]\n    @property\n    def major(self):\n        return self[1]\n    @property\n    def minor(self):\n        return self[2]\n    @property\n    def patch(self):\n        return self[3]\n    @property\n    def pre_pos(self):\n        return self[4]\n\ndef _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    parts = _each_version_part(ver_obj)\n    for part in parts:\n        if part.pre_txt:\n            pre_pos = part.pos\n    return _VersionInfo(version, parts[0], parts[1], parts[2], pre_pos)\n\ndef _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index\n    pos = _build_version_bump_position(position)\n\n    # Build version info (parsing the version)\n    ver_info = _build_version_info(version)\n\n    # Determine bump type from position and pre_release\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract original version parts for ease\n    major = ver_info.major\n    minor = ver_info.minor\n    patch = ver_info.patch\n    pre_pos = ver_info.pre_pos  # Position of pre-release part if any (-1 if none)\n\n    # Prepare components to modify\n    new_major = major.num\n    new_minor = minor.num\n    new_patch = patch.num\n\n    # Flags for prerelease bump\n    bump_prerelease = pre_release is not None and pre_release != ''\n    pre_rel_str = None\n    pre_rel_num = -1\n\n    # Existing pre-release info to be potentially modified\n    existing_pre_txt = None\n    existing_pre_num = -1\n    existing_pre_pos = -1\n\n    # Identify current prerelease info based on version info\n    if pre_pos >= 0:\n        if pre_pos == 1:\n            existing_pre_txt = minor.pre_txt\n            existing_pre_num = minor.pre_num\n            existing_pre_pos = pre_pos\n        elif pre_pos == 2:\n            existing_pre_txt = patch.pre_txt\n            existing_pre_num = patch.pre_num\n            existing_pre_pos = pre_pos\n\n    # Clear prerelease if pre_release argument is None or empty string\n    if not bump_prerelease:\n        # If original version has prerelease, but no pre_release parameter provided,\n        # bumping just removes the prerelease (resets to normal version)\n        if pre_pos >= 0:\n            # If bumping major or minor or patch, remove prerelease by just clearing it\n            # If bumping part below pre_pos, then the pre-release part gone.\n            pass  # no prerelease in result\n    else:\n        pre_release_lower = pre_release.strip().lower()\n\n        # Determine prerelease string and number to set\n        # Decide correct pre_release string according to bump_type:\n        if bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_PATCH_ALPHA):\n            pre_rel_str = 'a'\n        elif bump_type in (_BUMP_VERSION_MINOR_BETA, _BUMP_VERSION_PATCH_BETA):\n            pre_rel_str = 'b'\n        else:\n            # Should not happen, _build_version_bump_type already raises in major with prerelease\n            raise ValueError(f\"Invalid prerelease bump type deduced: {bump_type}\")\n\n    # Bump version numbers and handle prerelease accordingly\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Bump major: increase major, reset minor and patch, no prerelease allowed\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        # prerelease removed (if any)\n        pre_rel_str = None\n        pre_rel_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Bump minor: increase minor, reset patch, no prerelease (unless pre_release passed)\n        new_minor += 1\n        new_patch = 0\n        # prerelease removed if any and no pre_release passed (else handled later)\n        if not bump_prerelease:\n            pre_rel_str = None\n            pre_rel_num = -1\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Bump patch: increase patch, no prerelease (unless pre_release passed)\n        new_patch += 1\n        # prerelease removed if any and no pre_release passed\n        if not bump_prerelease:\n            pre_rel_str = None\n            pre_rel_num = -1\n\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA,\n                       _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Prerelease bumps for minor or patch\n\n        # Determine if bump is minor or patch prerelease\n        is_minor_pre = bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA)\n        is_patch_pre = bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA)\n\n        # Set version numbers accordingly\n        if is_minor_pre:\n            new_minor += 1\n            new_patch = 0\n        elif is_patch_pre:\n            new_patch += 1\n\n        # If original version already has prerelease on the same position and same pre_txt,\n        # increase pre_num by 1 if pre_release matches existing pre_txt,\n        # else reset pre_num to 0 and set new pre_txt\n\n        if existing_pre_pos == (1 if is_minor_pre else 2):\n            if existing_pre_txt == pre_rel_str:\n                pre_rel_num = existing_pre_num + 1\n            else:\n                pre_rel_num = 0\n        else:\n            # No existing prerelease or on different position\n            pre_rel_num = 0\n\n    else:\n        # Should not happen as _build_version_bump_type covers all cases\n        raise ValueError(f\"Unsupported bump type: {bump_type}\")\n\n    # If no prerelease (pre_rel_str is None), make sure to clear prerelease info\n    # Compose the version string accordingly\n\n    # Compose version string parts\n    # Major always shown\n    if new_patch == 0 and pos <= 1:\n        # When patch==0 and position being bumped is major or minor,\n        # omit patch part (as in examples: '1.3' from 1.2.3 with position=1 bump)\n        version_parts = [str(new_major), str(new_minor)]\n    else:\n        version_parts = [str(new_major), str(new_minor), str(new_patch)]\n\n    # Append prerelease if present\n    if pre_rel_str is not None:\n        version_str = ''.join(version_parts)  # initial join to combine parts, but no dots?\n        # Actually we want to join with dots except prerelease at last part\n        version_str = '.'.join(version_parts)\n        version_str += f\"{pre_rel_str}{pre_rel_num}\"\n    else:\n        version_str = '.'.join(version_parts)\n\n    return version_str", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 588, in <module>\n  File \"<string>\", line 587, in test_21\nAssertionError\n", "passed": false}
{"task_id": 125, "prediction_id": 1, "generation": "from typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _each_version_part,\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Validate and normalize position\n    pos = _build_version_bump_position(position)\n\n    # Determine bump type (major/minor/patch/alpha/beta)\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Parse current version info\n    ver_info = _build_version_info(version)\n\n    # Extract numeric version parts, ignoring pre-release suffix for base numbers\n    major_num = ver_info.major.num\n    minor_num = ver_info.minor.num\n    patch_num = ver_info.patch.num\n\n    # Current pre-release info, if any, and position\n    pre_pos = ver_info.pre_pos\n    pre_txt = ''\n    pre_num = -1\n    if pre_pos != -1:\n        # Get the VersionPart corresponding to pre-release\n        parts = [ver_info.major, ver_info.minor, ver_info.patch]\n        vpre_part = parts[pre_pos]\n        pre_txt = vpre_part.pre_txt\n        pre_num = vpre_part.pre_num\n\n    def new_version_str(major: int, minor: int, patch: int, pre_txt_: str = '', pre_num_: int = -1) -> str:\n        \"\"\"Format the version string accordingly:\n        - If patch is zero and position >= 1, omit patch,\n          unless pre-release is attached to patch.\n        - If pre-release present, append pre_txt and pre_num.\n        \"\"\"\n        version_core = ''\n        if patch == 0 and pos <= 1:\n            # If patch zero and we're bumping major or minor, omit patch\n            version_core = f\"{major}.{minor}\"\n        else:\n            version_core = f\"{major}.{minor}.{patch}\"\n\n        # Append pre-release suffix if present\n        if pre_txt_ and pre_num_ >= 0:\n            version_core += f\"{pre_txt_}{pre_num_}\"\n        return version_core\n\n    # Now handle bump logic by bump_type\n    # Refs for constants:\n    # _BUMP_VERSION_MAJOR = 0\n    # _BUMP_VERSION_MINOR = 1\n    # _BUMP_VERSION_PATCH = 2\n    # _BUMP_VERSION_MINOR_ALPHA = 3\n    # _BUMP_VERSION_MINOR_BETA = 4\n    # _BUMP_VERSION_PATCH_ALPHA = 5\n    # _BUMP_VERSION_PATCH_BETA = 6\n\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Major bump: increment major, reset minor and patch to zero, drop pre-release\n        major_num += 1\n        minor_num = 0\n        patch_num = 0\n        return f\"{major_num}.0\"\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Minor bump: increment minor, reset patch to zero, drop pre-release\n        minor_num += 1\n        patch_num = 0\n        return f\"{major_num}.{minor_num}\"\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Patch bump: increment patch, drop pre-release\n        patch_num += 1\n        return f\"{major_num}.{minor_num}.{patch_num}\"\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # Minor alpha or beta bump\n        minor_pre_type = 'a' if bump_type == _BUMP_VERSION_MINOR_ALPHA else 'b'\n        # If prerelease exists on minor part, increment it\n        if pre_pos == 1 and pre_txt == minor_pre_type:\n            new_pre_num = pre_num + 1\n            major_num_str = str(major_num)\n            return f\"{major_num}.{minor_num}{minor_pre_type}{new_pre_num}\"\n        # If prerelease exists on patch (pos=2), strip it and bump minor and add pre_release suffix 0\n        if pre_pos == 2:\n            # Strip patch pre-release to normal patch number first\n            # We increase minor and start pre-release with 0\n            minor_num += 1\n            return f\"{major_num}.{minor_num}{minor_pre_type}0\"\n        # No or different pre-release: bump minor and add pre-release 0\n        minor_num += 1\n        return f\"{major_num}.{minor_num}{minor_pre_type}0\"\n    elif bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Patch alpha or beta bump\n        patch_pre_type = 'a' if bump_type == _BUMP_VERSION_PATCH_ALPHA else 'b'\n        # Cases:\n        if pre_pos == 2 and pre_txt == patch_pre_type:\n            # Same prerelease at patch position, increment pre_num\n            new_pre_num = pre_num + 1\n            return f\"{major_num}.{minor_num}.{patch_num}{patch_pre_type}{new_pre_num}\"\n        elif pre_pos == 2 and pre_txt != patch_pre_type:\n            # Different prerelease at patch, reset to new pre-release type at zero\n            return f\"{major_num}.{minor_num}.{patch_num}{patch_pre_type}0\"\n        elif pre_pos != 2:\n            # No prerelease or prerelease at other position\n            # If patch is zero and pre_pos -1 (no prerelease), bump patch to 0 for prerelease\n            # Based on example bump_version('1.2.3', prerelease='a') => '1.2.4a0'\n            # So we bump patch by 1 and add prerelease a0/b0\n            patch_num += 1\n            return f\"{major_num}.{minor_num}.{patch_num}{patch_pre_type}0\"\n    else:\n        # Should not reach here, but as fallback, raise\n        raise ValueError(\"Invalid bump type computed.\")\n\n    # Fallback return original version if no changes made,\n    # but logic should never reach here\n    return version", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 378, in <module>\n  File \"<string>\", line 377, in test_5\nAssertionError\n", "passed": false}
{"task_id": 125, "prediction_id": 2, "generation": "from typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _build_version_info,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize and validate position to a positive index 0..2\n    pos = _build_version_bump_position(position)\n\n    # Convert version string to StrictVersion to validate\n    try:\n        ver_obj = StrictVersion(version)\n    except Exception as ex:\n        raise ValueError(f\"Invalid version number: {version!r}\") from ex\n\n    # Build detailed version info with our utility\n    version_info = _build_version_info(version)\n\n    # Determine the bump type (major, minor, patch, or prerelease variants)\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract current version parts: major, minor, patch\n    major_num = version_info.major.num\n    minor_num = version_info.minor.num\n    patch_num = version_info.patch.num\n\n    # Current prerelease info at the bump position (if any)\n    pre_txt = ''\n    pre_num = -1\n    # Determine if the current version has prerelease on the bump position\n    if version_info.pre_pos == pos:\n        # Get the _VersionPart matching pos: major=0, minor=1, patch=2\n        # We have them in version_info attributes: major, minor, patch\n        if pos == 0:\n            pre_txt = version_info.major.pre_txt\n            pre_num = version_info.major.pre_num\n        elif pos == 1:\n            pre_txt = version_info.minor.pre_txt\n            pre_num = version_info.minor.pre_num\n        else:\n            pre_txt = version_info.patch.pre_txt\n            pre_num = version_info.patch.pre_num\n\n    # Based on bump type, calculate new values:\n    # Constants for bump types representing each case, from file content:\n    _BUMP_VERSION_MAJOR = 0\n    _BUMP_VERSION_MINOR = 1\n    _BUMP_VERSION_PATCH = 2\n    _BUMP_VERSION_MINOR_ALPHA = 3\n    _BUMP_VERSION_MINOR_BETA = 4\n    _BUMP_VERSION_PATCH_ALPHA = 5\n    _BUMP_VERSION_PATCH_BETA = 6\n\n    # Initialize new version numbers\n    new_major = major_num\n    new_minor = minor_num\n    new_patch = patch_num\n    new_pre_txt = ''\n    new_pre_num = -1\n\n    # Clear prerelease if bump type is plain major, minor, patch\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increase major by 1, reset minor and patch to 0\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        # No prerelease in major bump\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Increase minor by 1, reset patch to 0\n        new_minor += 1\n        new_patch = 0\n        # Clear prerelease\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Increase patch by 1\n        new_patch += 1\n        # Clear prerelease\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR_ALPHA:\n        # minor alpha prerelease bump\n        # Increase minor if bump position is 1, and prerelease 'a'\n        # If current version is already minor with alpha prerelease increment pre_num, else reset to 0\n        if pos != 1:\n            # This should not happen, as per bump_type definition, but guard\n            raise ValueError(\"Minor alpha bump must be position 1 (minor)\")\n\n        new_minor += 0  # stay the same minor number if prerelease bumps patch?\n        new_patch = 0   # patch reset\n\n        if pos == version_info.pre_pos and pre_txt in ('a', 'alpha'):\n            # already alpha prerelease on minor, increment pre_num\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            # starting alpha prerelease at 0\n            new_pre_num = 0\n\n        new_pre_txt = 'a'\n        # The minor number must be increased by 1 if current version's minor is different?\n        # Actually, example '2.1.3', position=1, pre_release='a' -> '2.2a0'\n        # so minor increments by 1 and prerelease sets to a0\n        # So increase minor by 1, reset patch to 0, prerelease a0\n        new_minor += 1\n        new_patch = 0\n\n    elif bump_type == _BUMP_VERSION_MINOR_BETA:\n        # Similar to minor alpha, but beta prerelease\n        if pos != 1:\n            raise ValueError(\"Minor beta bump must be position 1 (minor)\")\n\n        new_minor += 1\n        new_patch = 0\n\n        if pos == version_info.pre_pos and pre_txt in ('b', 'beta'):\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            new_pre_num = 0\n\n        new_pre_txt = 'b'\n\n    elif bump_type == _BUMP_VERSION_PATCH_ALPHA:\n        # patch alpha prerelease bump\n        # patch increments if prerelease not already patch alpha\n        # else increments prerelease number\n        if pos != 2:\n            raise ValueError(\"Patch alpha bump must be position 2 (patch)\")\n\n        if pos == version_info.pre_pos and pre_txt in ('a', 'alpha'):\n            # same prerelease bump\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            # new patch prerelease alpha means patch bump if prerelease is different\n            if pos == version_info.pre_pos:\n                # prerelease exists but different type: reset pre_num 0\n                new_pre_num = 0\n            else:\n                # bump patch\n                new_patch += 1\n                new_pre_num = 0\n\n        new_pre_txt = 'a'\n        new_major = major_num\n        new_minor = minor_num\n\n    elif bump_type == _BUMP_VERSION_PATCH_BETA:\n        # patch beta prerelease bump, similar to patch alpha\n        if pos != 2:\n            raise ValueError(\"Patch beta bump must be position 2 (patch)\")\n\n        if pos == version_info.pre_pos and pre_txt in ('b', 'beta'):\n            new_pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            if pos == version_info.pre_pos:\n                new_pre_num = 0\n            else:\n                new_patch += 1\n                new_pre_num = 0\n\n        new_pre_txt = 'b'\n        new_major = major_num\n        new_minor = minor_num\n\n    else:\n        raise ValueError(f\"Invalid bump type: {bump_type}\")\n\n    # If pre_release is None or empty string -> clear prerelease\n    if pre_release is None or (isinstance(pre_release, str) and pre_release.strip() == ''):\n        # If the version had a prerelease, but bump was plain, clear prerelease\n        new_pre_txt = ''\n        new_pre_num = -1\n\n    # Assemble version string parts\n    # Rules from _each_version_part and examples:\n    # - Major always shown\n    # - Minor omitted if 0 patch and 0 minor? StrictVersion expects major.minor.patch\n    # - But examples always show at least major.minor\n    # - Patch shown only if >0 or prerelease on patch or position >= 2\n    # - Prerelease suffix is attached to the field\n    #   E.g. '4a0', '4b0', etc.\n\n    # From examples:\n    # bump_version('1.2.3', position=1) -> '1.3'  (patch omitted if 0)\n    # bump_version('1.3.4', position=0) -> '2.0'  (minor zero)\n    # bump_version('1.2.3', prerelease='a') -> '1.2.4a0'\n\n    # Decide how to format version string:\n\n    # We will output:\n    # major.minor[prerelease][.patch[prerelease]]\n    # But patch can be omitted if zero and position < 2 and no patch prerelease\n\n    # Compose version parts with prerelease as suffix on the bumped position\n\n    # We'll assign prerelease suffix only where pre_txt and pre_num exist on that position.\n\n    # The prerelease suffix belongs on the part where prerelease was applied\n    # We determine where the prerelease is: new_pre_txt and new_pre_num\n    # If new_pre_txt is empty, no prerelease suffix.\n\n    def part_version(num: int, pr_txt: str, pr_num: int) -> str:\n        if num == 0:\n            base = '0'\n        else:\n            base = str(num)\n        if pr_txt and pr_num >= 0:\n            return f\"{base}{pr_txt}{pr_num}\"\n        return base\n\n    # We only place prerelease suffix on the part being bumped for prereleases,\n    # but from the examples it looks like the prerelease suffix goes on the bumped part.\n\n    # Determine prerelease suffix position: it is on the bumped position\n    # So we add prerelease suffix only on bumped position:\n    major_str = str(new_major)\n    minor_str = str(new_minor)\n    patch_str = str(new_patch) if new_patch != 0 else ''\n\n    # Attach prerelease suffix to the bumped position only\n    if new_pre_txt and new_pre_num >= 0:\n        if pos == 0:\n            major_str += f\"{new_pre_txt}{new_pre_num}\"\n            # If patch or minor were reset to zero, we respect the examples and omit patch if zero\n            # Minor and patch shown normally\n        elif pos == 1:\n            minor_str += f\"{new_pre_txt}{new_pre_num}\"\n        elif pos == 2:\n            patch_str += f\"{new_pre_txt}{new_pre_num}\"\n\n    # Format output\n    # Apply rules for omission of patch if zero and no prerelease on patch\n    if patch_str == '':\n        # if patch is zero and no prerelease on patch\n        return f\"{major_str}.{minor_str}\"\n    else:\n        return f\"{major_str}.{minor_str}.{patch_str}\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 495, in <module>\n  File \"<string>\", line 494, in test_5\nAssertionError\n", "passed": false}
{"task_id": 125, "prediction_id": 3, "generation": "from typing import Optional\nfrom distutils.version import StrictVersion\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _each_version_part,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize and validate position\n    pos = _build_version_bump_position(position)\n\n    # Determine bump type from position and prerelease argument\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Parse version string into parts and info\n    try:\n        ver_info = _build_version_info(version)\n    except Exception as e:\n        # Convert any parsing error to ValueError explicitly\n        raise ValueError(f\"Invalid version string {version!r}: {e}\") from e\n\n    # Extract current parts for easy access\n    parts = {part.pos: part for part in (ver_info.major, ver_info.minor, ver_info.patch)}\n\n    # Determine current bump context parameters\n    # Position corresponds to 0=major,1=minor,2=patch\n\n    # Base version numbers\n    major_num = parts.get(0, None)\n    minor_num = parts.get(1, None)\n    patch_num = parts.get(2, None)\n\n    # For safety, if any part missing, fill with 0\n    major = major_num.num if major_num is not None else 0\n    minor = minor_num.num if minor_num is not None else 0\n    patch = patch_num.num if patch_num is not None else 0\n\n    # Current pre-release info at each position (if any)\n    # We'll also note where current prerelease is\n\n    pre_pos = ver_info.pre_pos  # -1 if no pre-release\n\n    # Helper to check if currently prerelease at given pos\n    def is_prerelease_at(pos):\n        if pre_pos != pos:\n            return False\n        part = parts[pos]\n        return part.pre_txt != '' and part.pre_num >= 0\n\n    # Implementation depending on bump_type:\n    # The bump_types map to:\n    # _BUMP_VERSION_MAJOR = 0\n    # _BUMP_VERSION_MINOR = 1\n    # _BUMP_VERSION_PATCH = 2\n    # _BUMP_VERSION_MINOR_ALPHA = 3\n    # _BUMP_VERSION_MINOR_BETA = 4\n    # _BUMP_VERSION_PATCH_ALPHA = 5\n    # _BUMP_VERSION_PATCH_BETA = 6\n\n    # We will build final version as a list/tuple of strings to join.\n\n    # Increment logic:\n\n    # Start with the base version as list [major, minor, patch]\n    new_major = major\n    new_minor = minor\n    new_patch = patch\n\n    # Determine how to bump or reset parts based on bump_type\n    # The \"position\" parameter determines which part to increase/reset.\n    # If bump is major (0):\n    #   major += 1\n    #   minor = 0\n    #   patch = 0\n    #   no pre-release allowed\n\n    # If bump is minor:\n    #   minor += 1\n    #   patch = 0\n    #   remove pre-release unless alpha/beta bumping minor\n\n    # If bump is patch:\n    #   patch += 1\n    #   remove pre-release unless alpha/beta bumping patch\n\n    # For alpha/beta bumps, we check if existing pre-release is the same type and increment the numeric suffix.\n    # If not, start a new pre-release numeric suffix at 0.\n\n    # if no pre_release given and current version has prerelease, strip it (set clean).\n\n    # Compose final version string accordingly.\n\n    # Implementation:\n\n    # Remove pre-release text if no pre_release argument given (clean bump)\n    # unless bump_type indicates prerelease bump (alpha/beta)\n\n    is_alpha_bump = bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_PATCH_ALPHA)\n    is_beta_bump = bump_type in (_BUMP_VERSION_MINOR_BETA, _BUMP_VERSION_PATCH_BETA)\n    is_prerelease_bump = is_alpha_bump or is_beta_bump\n\n    pre_txt = ''\n    pre_num = -1\n\n    # Process bump based on bump_type\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # major bump: increment major, reset minor and patch, no prerelease allowed\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # minor bump: increment minor, reset patch, remove prerelease\n        new_minor += 1\n        new_patch = 0\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # patch bump: increment patch, remove prerelease\n        new_patch += 1\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # minor alpha or beta bump\n        # increment minor, reset patch\n        new_minor += 1\n        new_patch = 0\n        pre_txt = 'a' if is_alpha_bump else 'b'\n        pre_num = 0\n    elif bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # patch alpha or beta bump\n        new_patch += 1\n        pre_txt = 'a' if is_alpha_bump else 'b'\n        pre_num = 0\n    else:\n        # Unknown bump type (should not happen)\n        raise ValueError(f\"Unknown bump type {bump_type}\")\n\n    # Now, handle the case when we are bumping a prerelease (alpha/beta) but the version already has a prerelease at bump pos\n    # We want to increment the pre_num for the same pre_txt (alpha or beta).\n    # If pre_release is None, and version currently has prerelease, remove it.\n\n    # If bump expects a prerelease bump (alpha or beta), but the current part at bump pos has the same pre_txt,\n    # then increment pre_num instead of resetting it.\n\n    if is_prerelease_bump:\n        # Check if current prerelease is at the bumped position with same pre_txt\n        if is_prerelease_at(pos) and parts[pos].pre_txt == pre_txt:\n            # Increment pre_num from current pre_num\n            pre_num = parts[pos].pre_num + 1\n        # Else, pre_num remains as 0 (just initialized above)\n    else:\n        # If no prerelease bump, but version currently has prerelease, remove it\n        # Only if bump_type is a clean bump (_BUMP_VERSION_MAJOR/MINOR/PATCH)\n        if ver_info.pre_pos != -1:\n            # We have to remove prerelease info by ignoring it on output\n            pre_txt = ''\n            pre_num = -1\n\n        # Exception: if version had prerelease at a different position than bump pos,\n        # that prerelease should be removed since we bump different position.\n\n    # Compose the final version string\n\n    # For major bump (pos=0), if minor and patch are zero, output as \"X.0\"\n    # For minor bump (pos=1), if patch is zero, output as \"X.Y\"\n    # For patch bump, output full \"X.Y.Z\"\n\n    # The original _each_version_part handles patch=0 by returning empty string, but we must handle here.\n\n    # Construct the version parts:\n\n    # major part always included\n    parts_str = [str(new_major)]\n\n    # minor part included if minor > 0 or position < 2 (patch)\n    # From examples, if position=1, patch is omitted if 0\n    # Examples:\n    # bump_version('1.2.3', position=1) -> '1.3' (patch omitted)\n    # bump_version('1.2.3', position=0) -> '2.0' (patch omitted)\n    # bump_version('1.2b0', position=2) -> '1.2.1' (patch included)\n\n    # So, if minor or position <= 1 include minor\n    if (new_minor > 0) or (pos <= 1):\n        parts_str.append(str(new_minor))\n\n    # patch included if position ==2 or patch > 0\n    if (pos == 2) or (new_patch > 0):\n        parts_str.append(str(new_patch))\n\n    # Join main version string\n    base_version = '.'.join(parts_str)\n\n    # Append prerelease if any\n    if pre_txt and pre_num >= 0:\n        base_version += f\"{pre_txt}{pre_num}\"\n\n    return base_version", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 456, in <module>\n  File \"<string>\", line 455, in test_18\nAssertionError\n", "passed": false}
{"task_id": 125, "prediction_id": 4, "generation": "from typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index and validate\n    pos = _build_version_bump_position(position)\n\n    # Parse current version and parts info\n    try:\n        vinfo = _build_version_info(version)\n    except Exception as e:\n        raise ValueError(f\"Invalid version number {version!r}: {e}\")\n\n    # Determine bump type based on position and prerelease option\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract current parts as mutable variables\n    major_num = vinfo.major.num\n    minor_num = vinfo.minor.num\n    patch_num = vinfo.patch.num\n    major_pre_txt = vinfo.major.pre_txt\n    major_pre_num = vinfo.major.pre_num\n    minor_pre_txt = vinfo.minor.pre_txt\n    minor_pre_num = vinfo.minor.pre_num\n    patch_pre_txt = vinfo.patch.pre_txt\n    patch_pre_num = vinfo.patch.pre_num\n\n    # Currently existing pre-release info and positions\n    current_pre_pos = vinfo.pre_pos\n\n    # Helper to clear prerelease info from a part\n    def clear_prerelease(pos):\n        if pos == 0:\n            nonlocal major_pre_txt, major_pre_num\n            major_pre_txt, major_pre_num = '', -1\n        elif pos == 1:\n            nonlocal minor_pre_txt, minor_pre_num\n            minor_pre_txt, minor_pre_num = '', -1\n        elif pos == 2:\n            nonlocal patch_pre_txt, patch_pre_num\n            patch_pre_txt, patch_pre_num = '', -1\n\n    # Helper to set prerelease info for a part\n    def set_prerelease(pos, pre_txt, pre_num):\n        if pos == 0:\n            nonlocal major_pre_txt, major_pre_num\n            major_pre_txt, major_pre_num = pre_txt, pre_num\n        elif pos == 1:\n            nonlocal minor_pre_txt, minor_pre_num\n            minor_pre_txt, minor_pre_num = pre_txt, pre_num\n        elif pos == 2:\n            nonlocal patch_pre_txt, patch_pre_num\n            patch_pre_txt, patch_pre_num = pre_txt, pre_num\n\n    # Bump logic by bump_type\n    if bump_type == 0:  # _BUMP_VERSION_MAJOR = 0\n        # Increase major, reset minor & patch and clear pre-releases\n        major_num += 1\n        minor_num = 0\n        patch_num = 0\n        clear_prerelease(0)\n        clear_prerelease(1)\n        clear_prerelease(2)\n        result = f'{major_num}.0'\n        # Patch and minor 0 omitted when patch == 0 in StrictVersion style\n\n    elif bump_type == 1:  # _BUMP_VERSION_MINOR = 1\n        major_num = major_num  # no change\n        minor_num += 1\n        patch_num = 0\n        clear_prerelease(1)\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}'\n        # patch=0 omitted for trailing version\n\n    elif bump_type == 2:  # _BUMP_VERSION_PATCH = 2\n        major_num = major_num\n        minor_num = minor_num if minor_num is not None else 0\n        patch_num += 1\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}.{patch_num}'\n\n    elif bump_type == 3:  # _BUMP_VERSION_MINOR_ALPHA = 3\n        # position must be 1, create or increment minor alpha\n        # Clear other pre-release pos if any\n        if current_pre_pos != 1:\n            # start at alpha0\n            set_prerelease(1, 'a', 0)\n        else:\n            # if already minor alpha, increment pre_num\n            new_num = minor_pre_num + 1 if minor_pre_num >= 0 else 0\n            set_prerelease(1, 'a', new_num)\n        # bump minor if not changed? Actually if prerelease exists, minor already bumped?\n        minor_num += 1 if (current_pre_pos != 1) else 0\n        patch_num = 0\n        # clear patch prerelease\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}a{minor_pre_num if minor_pre_num != -1 else 0}'\n\n    elif bump_type == 4:  # _BUMP_VERSION_MINOR_BETA = 4\n        # Same as minor alpha but with 'b'\n        if current_pre_pos != 1:\n            set_prerelease(1, 'b', 0)\n        else:\n            new_num = minor_pre_num + 1 if minor_pre_num >= 0 else 0\n            set_prerelease(1, 'b', new_num)\n        minor_num += 1 if (current_pre_pos != 1) else 0\n        patch_num = 0\n        clear_prerelease(2)\n        result = f'{major_num}.{minor_num}b{minor_pre_num if minor_pre_num != -1 else 0}'\n\n    elif bump_type == 5:  # _BUMP_VERSION_PATCH_ALPHA = 5\n        # Patch alpha prerelease\n        if current_pre_pos != 2:\n            set_prerelease(2, 'a', 0)\n        else:\n            new_num = patch_pre_num + 1 if patch_pre_num >= 0 else 0\n            set_prerelease(2, 'a', new_num)\n        # bump patch if not already patch prerelease\n        patch_num += 1 if (current_pre_pos != 2) else 0\n        result = f'{major_num}.{minor_num}.{patch_num}a{patch_pre_num if patch_pre_num != -1 else 0}'\n\n    elif bump_type == 6:  # _BUMP_VERSION_PATCH_BETA = 6\n        # Patch beta prerelease\n        if current_pre_pos != 2:\n            set_prerelease(2, 'b', 0)\n        else:\n            new_num = patch_pre_num + 1 if patch_pre_num >= 0 else 0\n            set_prerelease(2, 'b', new_num)\n        patch_num += 1 if (current_pre_pos != 2) else 0\n        result = f'{major_num}.{minor_num}.{patch_num}b{patch_pre_num if patch_pre_num != -1 else 0}'\n\n    else:\n        raise ValueError(f\"Unsupported bump type: {bump_type}\")\n\n    # Special handling if no prerelease requested and current version has a prerelease but bumping same position:\n    # then remove prerelease (final release)\n    # But only if no explicit pre_release is specified (None)\n    # and bump is at the same pre_pos.\n    # According to examples:\n    # This means bump_version('1.2.4a1') -> '1.2.4' if no pre_release given\n    # Only if bumping patch in that case (default)\n    if pre_release is None:\n        # If current version had prerelease and bumping that prerelease position, drop prerelease\n        if current_pre_pos == pos:\n            # Compose version without prerelease\n            if pos == 0:\n                # Major, no prerelease, no minor or patch in StrictVersion format? Use 'major.0'\n                result = f'{major_num}.0'\n            elif pos == 1:\n                # Minor bump: major.minor no patch as patch=0 omited\n                result = f'{major_num}.{minor_num}'\n            elif pos == 2:\n                result = f'{major_num}.{minor_num}.{patch_num}'\n\n    return result", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 412, in <module>\n  File \"<string>\", line 411, in test_5\nAssertionError\n", "passed": false}
