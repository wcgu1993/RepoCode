{"task_id": 126, "prediction_id": 0, "generation": "from collections import (\n    namedtuple,\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import Union, NamedTuple, Tuple, List, Any\nfrom flutils.validators import validate_identifier\nfrom flutils.namedtupleutils import _to_namedtuple\nfrom flutils.objutils import is_subclass_of_any\nimport keyword\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>` keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper: validate identifier (no leading underscore, valid identifier)\n    def _is_valid_key(key: Any) -> bool:\n        # key must be string type and:\n        # - not start with underscore\n        # - be a valid identifier (including no keyword or builtin names)\n        if not isinstance(key, str):\n            return False\n        if key.startswith('_'):\n            return False\n        try:\n            validate_identifier(key, allow_underscore=False)\n        except (SyntaxError, TypeError):\n            return False\n        return True\n\n    # Recursive conversion\n    if obj is None:\n        return obj\n\n    # If obj is a NamedTuple instance or tuple subclass but NOT a dict or list\n    # Note: We want to treat NamedTuple instances as NamedTuple, converting their fields.\n    # But careful: NamedTuple is a subclass of tuple.\n    # We must handle NamedTuple/tuple separately.\n\n    # Check if obj is a NamedTuple instance:\n    # NamedTuple is a subclass of tuple with _fields attribute\n    if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n        # Convert each element recursively\n        converted_values = tuple(to_namedtuple(v) for v in obj)\n        # Construct same NamedTuple type with converted values\n        return type(obj)(*converted_values)\n\n    # Handle lists and tuples: convert each item recursively\n    if isinstance(obj, list):\n        # Return a new list with converted elements\n        return [to_namedtuple(item) for item in obj]\n\n    if isinstance(obj, tuple):\n        # Return a new tuple with converted elements\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # Handle SimpleNamespace: convert its __dict__ (attributes)\n    if isinstance(obj, SimpleNamespace):\n        # Extract attributes dict\n        attribute_dict = vars(obj)\n        # Filter valid keys sorted alphabetically\n        keys = sorted(k for k in attribute_dict if _is_valid_key(k))\n        # Recursively convert values\n        values = [to_namedtuple(attribute_dict[k]) for k in keys]\n        # Create namedtuple with sorted keys\n        NamedTupleClass = namedtuple('NamedTuple', keys)\n        return NamedTupleClass(*values)\n\n    # Handle mappings (dict and subclasses)\n    if isinstance(obj, Mapping):\n        if isinstance(obj, OrderedDict):\n            keys = [k for k in obj.keys() if _is_valid_key(k)]\n        else:\n            keys = sorted(k for k in obj.keys() if _is_valid_key(k))\n        values = [to_namedtuple(obj[k]) for k in keys]\n        if keys:\n            NamedTupleClass = namedtuple('NamedTuple', keys)\n            return NamedTupleClass(*values)\n        else:\n            # Empty namedtuple\n            EmptyClass = namedtuple('NamedTuple', '')\n            return EmptyClass()\n\n    # For any other type, return as-is (base types like int, str, etc.)\n    return obj", "message": "passed", "passed": true}
{"task_id": 126, "prediction_id": 1, "generation": "from collections import namedtuple, OrderedDict\nfrom types import SimpleNamespace\nfrom typing import Any, List, NamedTuple, Tuple, Union, Mapping, Sequence, cast\n\nfrom flutils.validators import validate_identifier\n\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    # Recursive helper for mappings\n    def _convert_mapping(mapping: Mapping) -> Any:\n        # Collect valid keys (str and valid identifiers without leading underscore)\n        if isinstance(mapping, OrderedDict):\n            keys = list(mapping.keys())\n            # Filter keys that are valid identifiers and don't start with underscore\n            valid_keys = []\n            for key in keys:\n                if isinstance(key, str):\n                    try:\n                        validate_identifier(key, allow_underscore=False)\n                    except Exception:\n                        continue\n                    valid_keys.append(key)\n        else:\n            # For dict or other mappings, sort keys alphabetically\n            valid_keys = []\n            for key in mapping.keys():\n                if isinstance(key, str):\n                    try:\n                        validate_identifier(key, allow_underscore=False)\n                    except Exception:\n                        continue\n                    valid_keys.append(key)\n            valid_keys = tuple(sorted(valid_keys))\n\n        # Recursively convert each valid key's value\n        converted_values = []\n        for key in valid_keys:\n            val = mapping[key]\n            val = to_namedtuple(val)\n            converted_values.append(val)\n\n        # Create namedtuple class with collected keys\n        if valid_keys:\n            tuple_class = namedtuple('NamedTuple', valid_keys)\n            return tuple_class(*converted_values)\n        else:\n            # Return empty namedtuple (no fields)\n            empty_nt = namedtuple('NamedTuple', '')\n            return empty_nt()\n\n    # Start of main function logic\n    # Handle NamedTuple input - no conversion, but we must recursively convert its items\n    # NamedTuple is a subclass of tuple, but has _fields attribute\n    if hasattr(obj, '_fields') and isinstance(obj, tuple):\n        # Convert each item recursively, build new namedtuple of same class\n        values = [to_namedtuple(item) for item in obj]\n        return type(obj)(*values)\n\n    # Handle SimpleNamespace: treat like dict with attributes sorted alphabetically\n    if isinstance(obj, SimpleNamespace):\n        # Get attribute dict, filter keys like dict keys\n        attrs = vars(obj)\n        # Sort keys alphabetically to match docstring\n        sorted_keys = sorted(\n            k for k in attrs.keys()\n            if isinstance(k, str) and not k.startswith('_')\n        )\n        # Validate keys\n        valid_keys = []\n        for key in sorted_keys:\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except Exception:\n                continue\n            valid_keys.append(key)\n\n        values = [to_namedtuple(attrs[k]) for k in valid_keys]\n\n        if valid_keys:\n            tuple_class = namedtuple('NamedTuple', valid_keys)\n            return tuple_class(*values)\n        else:\n            empty_nt = namedtuple('NamedTuple', '')\n            return empty_nt()\n\n    # Handle Mapping (dict or OrderedDict or other Mapping)\n    if isinstance(obj, Mapping):\n        return _convert_mapping(obj)\n\n    # Handle list: return new list with recursively converted items\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # Handle tuple (without _fields i.e. not namedtuple): return new tuple with converted items\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # For other types, return as is\n    return obj", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 236, in <module>\n  File \"/usr/local/lib/python3.10/functools.py\", line 862, in register\n    raise TypeError(\nTypeError: Invalid first argument to `register()`: typing.Mapping. Use either `@register(some_class)` or plain `@register` on an annotated function.\n", "passed": false}
{"task_id": 126, "prediction_id": 2, "generation": "from collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom types import SimpleNamespace\nfrom typing import (\n    Any,\n    List,\n    NamedTuple,\n    Tuple,\n    Union,\n    cast,\n)\nimport keyword\n\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>` keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper inner function to check if a key is a valid attribute name\n    def _is_valid_attr_name(name: Any) -> bool:\n        if not isinstance(name, str):\n            return False\n        if name.startswith('_'):\n            return False\n        try:\n            validate_identifier(name, allow_underscore=False)\n        except (SyntaxError, TypeError):\n            return False\n        return True\n\n    # Handle Mappings (dict-like objects)\n    if isinstance(obj, Mapping):\n        # Determine keys order\n        if isinstance(obj, OrderedDict):\n            keys = [k for k in obj.keys() if _is_valid_attr_name(k)]\n        else:\n            # Sort keys alphabetically (only those valid)\n            keys = sorted(k for k in obj.keys() if _is_valid_attr_name(k))\n\n        values = []\n        for key in keys:\n            val = obj[key]\n            val_converted = to_namedtuple(val)\n            values.append(val_converted)\n\n        # Create namedtuple class and instantiate\n        if keys:\n            NTClass = namedtuple('NamedTuple', keys)\n            return NTClass(*values)\n        else:\n            # Empty namedtuple with no fields\n            NTClass = namedtuple('NamedTuple', [])\n            return NTClass()\n\n    # Handle SimpleNamespace (like an object with attributes)\n    if isinstance(obj, SimpleNamespace):\n        # Extract attributes as dict and sort keys alphabetically\n        attrs = {k: v for k, v in vars(obj).items() if _is_valid_attr_name(k)}\n        keys = sorted(attrs.keys())\n        values = [to_namedtuple(attrs[k]) for k in keys]\n\n        if keys:\n            NTClass = namedtuple('NamedTuple', keys)\n            return NTClass(*values)\n        else:\n            NTClass = namedtuple('NamedTuple', [])\n            return NTClass()\n\n    # Handle lists: return new list with converted items\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # Handle tuples: return new tuple with converted items\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj]\n\n    # If not any of above types, return as is\n    return obj", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 198\n    return tuple(to_namedtuple(item) for item in obj]\n                                                    ^\nSyntaxError: closing parenthesis ']' does not match opening parenthesis '('\n", "passed": false}
{"task_id": 126, "prediction_id": 3, "generation": "from collections import namedtuple, OrderedDict\nfrom collections.abc import Mapping\nfrom types import SimpleNamespace\nfrom typing import Union, NamedTuple, List, Tuple, Any\n\nfrom flutils.validators import validate_identifier\n\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    # Helper function to recursively convert an object to namedtuple if possible\n    def _convert(obj: Any) -> Any:\n        # Handle Mapping (dict, OrderedDict, etc)\n        if isinstance(obj, Mapping):\n            # Determine keys to use as attributes:\n            if isinstance(obj, OrderedDict):\n                keys = [k for k in obj.keys()\n                        if (isinstance(k, str)\n                            and not k.startswith('_')\n                            and k.isidentifier())]\n            else:\n                # For all other mappings, keys that are valid identifiers,\n                # not starting with underscore, sorted alphabetically.\n                keys = []\n                for k in obj.keys():\n                    if isinstance(k, str) and not k.startswith('_'):\n                        # use validate_identifier to ensure correctness\n                        try:\n                            validate_identifier(k, allow_underscore=False)\n                            keys.append(k)\n                        except (SyntaxError, TypeError):\n                            continue\n                keys = tuple(sorted(keys))\n\n            # Recursively convert each value for valid keys\n            values = []\n            for key in keys:\n                val = obj[key]\n                try:\n                    val = _convert(val)\n                except Exception:\n                    # if cannot convert, keep original value\n                    pass\n                values.append(val)\n\n            # Create namedtuple class\n            NamedTupleCls = namedtuple('NamedTuple', keys)\n            return NamedTupleCls(*values)\n\n        # Handle SimpleNamespace\n        if isinstance(obj, SimpleNamespace):\n            # Get attributes dictionary\n            attrs = vars(obj)\n            keys = []\n            for key in attrs.keys():\n                if isinstance(key, str) and not key.startswith('_'):\n                    try:\n                        validate_identifier(key, allow_underscore=False)\n                        keys.append(key)\n                    except (SyntaxError, TypeError):\n                        continue\n            # Sort keys alphabetically\n            keys = tuple(sorted(keys))\n\n            values = []\n            for key in keys:\n                val = attrs[key]\n                try:\n                    val = _convert(val)\n                except Exception:\n                    pass\n                values.append(val)\n\n            NamedTupleCls = namedtuple('NamedTuple', keys)\n            return NamedTupleCls(*values)\n\n        # Handle list: return a new list with items converted recursively if possible\n        if isinstance(obj, list):\n            new_list = []\n            for item in obj:\n                try:\n                    item_conv = _convert(item)\n                except Exception:\n                    item_conv = item\n                new_list.append(item_conv)\n            return new_list\n\n        # Handle tuple: return a tuple with items converted recursively if possible\n        if isinstance(obj, tuple):\n            new_tuple = []\n            for item in obj:\n                try:\n                    item_conv = _convert(item)\n                except Exception:\n                    item_conv = item\n                new_tuple.append(item_conv)\n            return tuple(new_tuple)\n\n        # For other types, return as is\n        return obj\n\n    return _convert(obj)", "message": "passed", "passed": true}
{"task_id": 126, "prediction_id": 4, "generation": "import keyword\nfrom collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import Any, List, NamedTuple, Tuple, Union, cast\n\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    def _is_valid_key(key: Any) -> bool:\n        \"\"\"Return True if key is a string identifier not starting with underscore.\"\"\"\n        if not isinstance(key, str):\n            return False\n        if key.startswith('_'):\n            return False\n        try:\n            validate_identifier(key, allow_underscore=False)\n        except (SyntaxError, TypeError):\n            return False\n        return True\n\n    if isinstance(obj, Mapping):\n        # Extract keys that are valid identifiers and do not start with underscore\n        if isinstance(obj, OrderedDict):\n            keys = [k for k in obj.keys() if _is_valid_key(k)]\n        else:\n            # Sort keys alphabetically if not OrderedDict\n            keys = sorted(k for k in obj.keys() if _is_valid_key(k))\n\n        values = []\n        for key in keys:\n            val = obj[key]\n            try:\n                val_conv = to_namedtuple(val)\n            except Exception:\n                val_conv = val\n            values.append(val_conv)\n\n        if keys:\n            MakeNamedTuple = namedtuple('NamedTuple', keys)\n            return MakeNamedTuple(*values)\n        else:\n            # No valid keys -> return empty namedtuple\n            MakeEmpty = namedtuple('NamedTuple', '')\n            return MakeEmpty()\n\n    elif isinstance(obj, SimpleNamespace):\n        # Extract attributes, filter valid keys (no underscore start) and sort alphabetically\n        attrs = vars(obj)\n        keys = sorted(k for k in attrs.keys() if _is_valid_key(k))\n        values = []\n        for key in keys:\n            val = attrs[key]\n            try:\n                val_conv = to_namedtuple(val)\n            except Exception:\n                val_conv = val\n            values.append(val_conv)\n        if keys:\n            MakeNamedTuple = namedtuple('NamedTuple', keys)\n            return MakeNamedTuple(*values)\n        else:\n            MakeEmpty = namedtuple('NamedTuple', '')\n            return MakeEmpty()\n\n    elif isinstance(obj, list):\n        # Return a new list with each value converted recursively\n        converted_list = []\n        for item in obj:\n            try:\n                converted_list.append(to_namedtuple(item))\n            except Exception:\n                converted_list.append(item)\n        return converted_list\n\n    elif isinstance(obj, tuple):\n        # Return a new tuple with each value converted recursively\n        converted_tuple = []\n        for item in obj:\n            try:\n                converted_tuple.append(to_namedtuple(item))\n            except Exception:\n                converted_tuple.append(item)\n        return tuple(converted_tuple)\n\n    else:\n        # For other types (including NamedTuple) return as is\n        return obj", "message": "passed", "passed": true}
