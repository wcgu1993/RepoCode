{"task_id": 126, "prediction_id": 0, "generation": "from collections import (\n    OrderedDict,\n    namedtuple,\n)\nfrom collections.abc import (\n    Mapping,\n    Sequence,\n)\nfrom types import SimpleNamespace\nfrom typing import (\n    NamedTuple,\n    Tuple,\n    List,\n    Union,\n    cast,\n)\n\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper to check if key is allowed attribute name for NamedTuple\n    def _is_valid_identifier(key: str) -> bool:\n        # Must be a valid python identifier, cannot start with underscore,\n        # and validated by external validate_identifier\n        if not isinstance(key, str):\n            return False\n        if key.startswith('_'):\n            return False\n        return validate_identifier(key)\n\n    # Recursive conversion function\n    def _convert(obj: Any) -> Any:\n        # Lists: return new list with items converted recursively\n        if isinstance(obj, list):\n            return [_convert(item) for item in obj]\n\n        # Tuples: return new tuple with items converted recursively\n        if isinstance(obj, tuple):\n            return tuple(_convert(item) for item in obj)\n\n        # Mapping types (dict or OrderedDict)\n        if isinstance(obj, Mapping):\n            # Determine keys for NamedTuple:\n            # OrderedDict keys preserve order, dict keys are sorted\n            if isinstance(obj, OrderedDict):\n                keys = list(obj.keys())\n            else:\n                keys = sorted(obj.keys())\n\n            # Filter keys that are valid names (no underscore start and valid identifier)\n            filtered_keys = [k for k in keys if _is_valid_identifier(k)]\n\n            # Recursively convert values corresponding to filtered keys\n            values = [_convert(obj[k]) for k in filtered_keys]\n\n            # Create NamedTuple type with given fields order\n            NT = namedtuple('NamedTuple', filtered_keys)\n            return NT(*values)\n\n        # SimpleNamespace: treat attributes like a dict, attributes sorted\n        if isinstance(obj, SimpleNamespace):\n            attrs = {k: v for k, v in vars(obj).items() if _is_valid_identifier(k)}\n            keys = sorted(attrs.keys())\n            values = [_convert(attrs[k]) for k in keys]\n            NT = namedtuple('NamedTuple', keys)\n            return NT(*values)\n\n        # For already a NamedTuple: convert its fields like a tuple\n        if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n            # NamedTuple is a subclass of tuple with _fields attribute\n            # We convert its items recursively, output another NamedTuple instance with same fields\n            converted_items = tuple(_convert(getattr(obj, field)) for field in obj._fields)\n            NT = namedtuple(type(obj).__name__, obj._fields)\n            return NT(*converted_items)\n\n        # Other types: return as is\n        return obj\n\n    return _convert(obj)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 348, in <module>\n  File \"<string>\", line 345, in test_20\nAttributeError: 'NamedTuple' object has no attribute 'a'\n", "passed": false}
{"task_id": 126, "prediction_id": 1, "generation": "from collections import OrderedDict, namedtuple\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import NamedTuple, Tuple, List, Union, Any, cast\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    # Helper function to check if a string is a valid identifier and doesn't start with underscore\n    def _is_valid_identifier(name: Any) -> bool:\n        if not isinstance(name, str):\n            return False\n        if name.startswith(\"_\"):\n            return False\n        return validate_identifier(name)\n\n    # If the object is a list, return a new list where each item is converted recursively if possible\n    if isinstance(obj, list):\n        return [to_namedtuple(item) if _is_convertible(item) else item for item in obj]\n\n    # If the object is a tuple, return a new tuple with converted items recursively if possible\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) if _is_convertible(item) else item for item in obj)\n\n    # If the object is a Mapping (including dict and OrderedDict)\n    if isinstance(obj, Mapping):\n\n        # Determine the keys/attributes order:\n        # If OrderedDict: preserve order\n        # else: sort keys alphabetically\n\n        if isinstance(obj, OrderedDict):\n            keys = list(obj.keys())\n        else:\n            keys = sorted(obj.keys())\n\n        # Filter keys that can be attribute names (valid identifiers, no leading underscore)\n        # and convert their corresponding values recursively\n\n        attrs = []\n        values = []\n\n        for key in keys:\n            if _is_valid_identifier(key):\n                attrs.append(key)\n                values.append(to_namedtuple(obj[key]))\n        # Build the namedtuple type\n        # Use a fixed typename, e.g. 'NamedTuple'\n        NTType = namedtuple('NamedTuple', attrs)\n        return NTType(*values)\n\n    # If the object is SimpleNamespace, attributes are the __dict__ keys, sorted alphabetically\n    if isinstance(obj, SimpleNamespace):\n        keys = sorted(vars(obj).keys())\n\n        attrs = []\n        values = []\n        for key in keys:\n            if _is_valid_identifier(key):\n                attrs.append(key)\n                values.append(to_namedtuple(getattr(obj, key)))\n        NTType = namedtuple('NamedTuple', attrs)\n        return NTType(*values)\n\n    # If the object is already a NamedTuple (or a tuple subclass with _fields)\n    # just return as is; this does not appear directly in doc, but safest to handle\n    if hasattr(obj, '_fields'):\n        # However, we may wish to recursively convert its values\n        # Let's convert fields to maintain recursive conversions\n        attrs = obj._fields\n        values = []\n        for attr in attrs:\n            value = getattr(obj, attr)\n            values.append(to_namedtuple(value) if _is_convertible(value) else value)\n        NTType = namedtuple(type(obj).__name__, attrs)\n        return NTType(*values)\n\n    # Otherwise, return the object as is\n    return obj\n\n\ndef _is_convertible(value: Any) -> bool:\n    \"\"\"Return True if the value is of a type that can be converted by to_namedtuple.\"\"\"\n\n    # Based on _AllowedTypes definition: list, Mapping, NamedTuple, SimpleNamespace, tuple\n\n    # Check for list or tuple\n    if isinstance(value, (list, tuple)):\n        return True\n\n    # Mapping types - dict, OrderedDict, etc.\n    if isinstance(value, Mapping):\n        return True\n\n    # SimpleNamespace\n    if isinstance(value, SimpleNamespace):\n        return True\n\n    # NamedTuple: any tuple subclass with _fields attribute is treated as NamedTuple\n    if hasattr(value, '_fields') and isinstance(value, tuple):\n        return True\n\n    return False", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 372, in <module>\n  File \"<string>\", line 369, in test_20\nAttributeError: 'NamedTuple' object has no attribute 'a'\n", "passed": false}
{"task_id": 126, "prediction_id": 2, "generation": "from collections import OrderedDict, namedtuple\nfrom collections.abc import Mapping, Sequence\nfrom types import SimpleNamespace\nfrom typing import Any, List, NamedTuple, Tuple, Union, cast\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n\n    def is_valid_identifier(s: str) -> bool:\n        # Valid identifiers do not start with underscore and satisfy Python identifier rule\n        return s.isidentifier() and not s.startswith('_')\n\n    # Recursive conversion starts here\n    # Handle list: return a new list with converted items\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # Handle tuple: return a new tuple with converted items\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # Handle Mapping (like dict or OrderedDict)\n    if isinstance(obj, Mapping):\n        # Determine keys for attributes\n        # Keys must be strings and valid identifiers and not starting with underscore\n        # For OrderedDict, keep order; otherwise, sort alphabetically\n        if isinstance(obj, OrderedDict):\n            keys = list(obj.keys())\n        else:\n            # sort keys alphabetically (converted to strings), but filter out bad keys first\n            keys = sorted(k for k in obj.keys() if isinstance(k, str))\n\n        # Filter keys to only valid identifiers and no underscore start\n        filtered_keys = [k for k in keys if isinstance(k, str) and is_valid_identifier(k)]\n\n        # Recursively convert values for these keys\n        values = [to_namedtuple(obj[k]) for k in filtered_keys]\n\n        # Create namedtuple type with name 'NamedTuple'\n        NT = namedtuple('NamedTuple', filtered_keys)\n        return NT(*values)\n\n    # Handle SimpleNamespace\n    if isinstance(obj, SimpleNamespace):\n        # Extract attributes dict\n        attrs = vars(obj)\n        # Sort keys alphabetically\n        keys = sorted(k for k in attrs.keys() if is_valid_identifier(k))\n        values = [to_namedtuple(attrs[k]) for k in keys]\n        NT = namedtuple('NamedTuple', keys)\n        return NT(*values)\n\n    # For NamedTuple instances or other types (including primitives), \n    # leave as is\n    return obj", "message": "passed", "passed": true}
{"task_id": 126, "prediction_id": 3, "generation": "from collections import namedtuple, OrderedDict\nfrom types import SimpleNamespace\nfrom typing import NamedTuple, Tuple, List, Union, Mapping, Any, cast\nfrom flutils.validators import validate_identifier\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    SimpleNamespace,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Helper function to check if a string is a valid identifier for NamedTuple attribute\n    def is_valid_identifier(s: str) -> bool:\n        # Must not start with underscore, must be valid identifier, and validated by flutils.validator\n        if not isinstance(s, str):\n            return False\n        if s.startswith('_'):\n            return False\n        try:\n            # Use the validate_identifier function from flutils.validators to check validity\n            # If this raises, it's invalid\n            validate_identifier(s)\n            return True\n        except Exception:\n            return False\n\n    # If obj is a list, recursively convert each element and return a new list\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # If obj is a tuple, recursively convert each element and return a new tuple\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # If obj is a Mapping subclass (dict, OrderedDict), convert keys and values \n    if isinstance(obj, Mapping):\n        # Determine if obj is OrderedDict to preserve order or normal dict to sort keys\n        keys = list(obj.keys())\n        if isinstance(obj, OrderedDict):\n            # keep order\n            keys_for_attrs = keys\n        else:\n            # sort keys alphabetically\n            keys_for_attrs = sorted(keys)\n\n        # Filter keys to valid identifiers per rules (no underscore start and valid identifier)\n        valid_keys = [k for k in keys_for_attrs if is_valid_identifier(k)]\n\n        # Prepare values, recursively converted\n        values = [to_namedtuple(obj[k]) for k in valid_keys]\n\n        # Create a NamedTuple subclass dynamically with these valid keys\n        NT = namedtuple('NamedTuple', valid_keys)\n\n        # Instantiate and return\n        return NT(*values)\n\n    # If obj is a SimpleNamespace, treat similarly with sorting its __dict__ keys alphabetically\n    if isinstance(obj, SimpleNamespace):\n        attr_dict = vars(obj)\n        keys_for_attrs = sorted(attr_dict.keys())\n        valid_keys = [k for k in keys_for_attrs if is_valid_identifier(k)]\n        values = [to_namedtuple(attr_dict[k]) for k in valid_keys]\n\n        NT = namedtuple('NamedTuple', valid_keys)\n        return NT(*values)\n\n    # If obj is already a NamedTuple (has _fields attribute), then convert its fields recursively and rebuild it\n    # But the docstring doesn't explicitly mention this; we can safely return obj as is, or convert.\n    # Since NamedTuple is an instance of tuple and has _fields, we convert the fields recursively\n\n    # For safety, detect NamedTuple (has _fields) and is not a Mapping or SimpleNamespace or normal tuple or list.\n    if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n        # Get the field names\n        field_names = obj._fields\n        # Recursively convert each field value\n        values = [to_namedtuple(getattr(obj, f)) for f in field_names]\n        NT = namedtuple(obj.__class__.__name__, field_names)\n        return NT(*values)\n\n    # For any other type, return as is\n    return obj", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 213, in <module>\n  File \"/usr/local/lib/python3.10/functools.py\", line 862, in register\n    raise TypeError(\nTypeError: Invalid first argument to `register()`: typing.Mapping. Use either `@register(some_class)` or plain `@register` on an annotated function.\n", "passed": false}
{"task_id": 126, "prediction_id": 4, "generation": "from collections import namedtuple, OrderedDict\nfrom types import SimpleNamespace\nfrom typing import Union, NamedTuple, Tuple, List, Mapping, Any, cast\n\n# We assume validate_identifier function is available from flutils.validators as per file content,\n# but since we must make the code self-contained, let's implement a minimal version here:\n# The description indicates keys must be proper identifiers and not start with underscore.\n# validate_identifier likely returns True if valid, False otherwise.\n# To avoid import, define a simple validator:\ndef validate_identifier(name: str) -> bool:\n    if not isinstance(name, str):\n        return False\n    if not name.isidentifier():\n        return False\n    if name.startswith('_'):\n        return False\n    return True\n\n\n_AllowedTypes = Union[\n    List,\n    Mapping,\n    NamedTuple,\n    Tuple,\n]\n\n\ndef to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n    # Internal helper for recursively converting mapping to NamedTuple\n    def _mapping_to_namedtuple(mapping: Mapping[str, Any]) -> NamedTuple:\n        # Filter valid keys: strings that are valid identifiers and don't start with underscore\n        if isinstance(mapping, OrderedDict):\n            keys_iter = mapping.keys()\n        else:\n            keys_iter = sorted(mapping.keys())\n\n        # Collect attributes and recursively convert their values\n        attrs = []\n        values = []\n        for key in keys_iter:\n            # Only string keys that are valid identifiers and do not start with _\n            if isinstance(key, str) and validate_identifier(key):\n                value = mapping[key]\n                value = to_namedtuple(value)  # recursive convert\n                attrs.append(key)\n                values.append(value)\n            # keys not pass filter are ignored and not added as attributes\n\n        # Create a NamedTuple subclass dynamically with these attribute names\n        NT = namedtuple('NamedTuple', attrs)\n        return NT(*values)\n\n    # Main conversion logic:\n    # If list -> recurse each item and return new list\n    if isinstance(obj, list):\n        return [to_namedtuple(item) for item in obj]\n\n    # If tuple -> recurse each item and return new tuple\n    if isinstance(obj, tuple):\n        return tuple(to_namedtuple(item) for item in obj)\n\n    # If SimpleNamespace -> convert vars (attributes) dict, sorted keys\n    if isinstance(obj, SimpleNamespace):\n        d = vars(obj)\n        # We must sort keys alphabetically, then filter by validate_identifier rules\n        # This logic is re-used in _mapping_to_namedtuple, so reuse that function by passing a sorted dict.\n        sorted_dict = OrderedDict(sorted(d.items()))\n        return _mapping_to_namedtuple(sorted_dict)\n\n    # If Mapping (dict or OrderedDict etc)\n    if isinstance(obj, Mapping):\n        # If OrderedDict: preserve order; else sort keys\n        # if OrderedDict, _mapping_to_namedtuple will preserve order\n        # if not ordered, we sort keys alphabetically in that function\n        return _mapping_to_namedtuple(obj)\n\n    # If NamedTuple (is a subclass of tuple with _fields attribute)\n    # According to _AllowedTypes, NamedTuple is allowed input.\n    # NamedTuple is a subclass of tuple, but has _fields attribute containing attribute names,\n    # but the docstring doesn't mention special treatment for input NamedTuple.\n    # Therefore, to follow the recursion rules, convert each field value and recreate the NamedTuple.\n\n    # If obj has _fields attribute and is tuple subclass, treat as NamedTuple\n    if isinstance(obj, tuple) and hasattr(obj, '_fields'):\n        # get type to reconstruct NamedTuple instance with same type\n        cls = type(obj)\n        # recurse each item\n        values = tuple(to_namedtuple(getattr(obj, field)) for field in obj._fields)\n        # create new instance with these values\n        return cls(*values)\n\n    # Otherwise, type not handled, return as is\n    return obj", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 220, in <module>\n  File \"/usr/local/lib/python3.10/functools.py\", line 862, in register\n    raise TypeError(\nTypeError: Invalid first argument to `register()`: typing.Mapping. Use either `@register(some_class)` or plain `@register` on an annotated function.\n", "passed": false}
