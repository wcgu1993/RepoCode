{"task_id": 125, "prediction_id": 0, "generation": "from typing import Optional, Union\nfrom distutils.version import StrictVersion\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index and validate\n    pos = _build_version_bump_position(position)\n\n    # Get detailed version info\n    version_info = _build_version_info(version)\n\n    # Determine bump type based on position and prerelease input\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract the version parts as mutable variables\n    major_num = version_info.major.num\n    minor_num = version_info.minor.num\n    patch_num = version_info.patch.num\n\n    # Detect existing prerelease info at patch or minor level\n    current_pre_pos = version_info.pre_pos\n    current_pre_part = None\n    if current_pre_pos != -1:\n        # current pre-release part exists\n        if current_pre_pos == 1:\n            current_pre_part = version_info.minor\n        elif current_pre_pos == 2:\n            current_pre_part = version_info.patch\n\n    # Helper to convert bump_type int to actual increments and pre-release\n    def bump_and_build_version() -> str:\n        # Starting base values possibly adjusted by bump\n        new_major = major_num\n        new_minor = minor_num\n        new_patch = patch_num\n        pre_txt = ''\n        pre_num = -1\n\n        if bump_type == _BUMP_VERSION_MAJOR:\n            # Increment major, reset minor and patch\n            new_major += 1\n            new_minor = 0\n            new_patch = 0\n        elif bump_type == _BUMP_VERSION_MINOR:\n            new_minor += 1\n            new_patch = 0\n        elif bump_type == _BUMP_VERSION_PATCH:\n            new_patch += 1\n        elif bump_type == _BUMP_VERSION_MINOR_ALPHA:\n            # prerelease is alpha at minor\n            new_minor += 1\n            new_patch = 0\n            pre_txt = 'a'\n            pre_num = 0\n        elif bump_type == _BUMP_VERSION_MINOR_BETA:\n            new_minor += 1\n            new_patch = 0\n            pre_txt = 'b'\n            pre_num = 0\n        elif bump_type == _BUMP_VERSION_PATCH_ALPHA:\n            new_patch = patch_num  # stay same patch if prerelease bump at patch\n            pre_txt = 'a'\n            if current_pre_part and current_pre_part.pre_txt == 'a':\n                pre_num = current_pre_part.pre_num + 1\n            else:\n                pre_num = 0\n        elif bump_type == _BUMP_VERSION_PATCH_BETA:\n            new_patch = patch_num\n            pre_txt = 'b'\n            if current_pre_part and current_pre_part.pre_txt == 'b':\n                pre_num = current_pre_part.pre_num + 1\n            else:\n                pre_num = 0\n        else:\n            # Should not happen, bump_type validated upstream\n            raise ValueError(f\"Unknown bump_type {bump_type}\")\n\n        # Compose version string parts\n        # Major part always included\n        parts = [str(new_major)]\n\n        # Add minor only if > 0 or bump_type > _BUMP_VERSION_MAJOR to reduce trailing parts\n        # But examples show minor is always included for position 1 or 0 bumps\n        if bump_type in (_BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA) or new_minor != 0 or new_patch != 0:\n            parts.append(str(new_minor))\n\n        # Add patch if bump position is patch or there was patch part originally\n        # but if patch num is zero and pre-release at patch with alpha/beta the patch zero is kept\n        # Examples show patch generally included for position=2 bumps or if patch nonzero\n        # Special case: if bump at major (pos=0), example shows version like '2.0' (no patch). We'll omit patch if zero in that case.\n        if bump_type in (_BUMP_VERSION_PATCH, _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA) or new_patch != 0:\n            # Only add patch if patch is non-zero or if bump_type targets patch (or alpha/beta patch)\n            # To align with examples: patch can be omitted if zero and bump_type is major or minor.\n            if not (bump_type in (_BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA) and new_patch == 0):\n                # For patch zero, only include if example shows it (like '1.2.0'), else omit.\n                parts.append(str(new_patch))\n\n        # Build base version string\n        base_version = '.'.join(parts)\n\n        # Add prerelease if exists\n        if pre_num >= 0:\n            base_version += f\"{pre_txt}{pre_num}\"\n\n        return base_version\n\n    # Handle special case: if no pre_release argument but current version has pre-release,\n    # bumping without pre_release removes the pre-release by increasing the numeric portion appropriately.\n    # According to examples:\n    # bump_version('1.2.4a1') -> '1.2.4'\n    # bump_version('1.2.4b0') -> '1.2.4'\n    # So if pre_release is None and version is prerelease => remove prerelease by bumping numeric?\n    if pre_release is None and current_pre_pos != -1:\n        # We remove prerelease by incrementing the numeric part if possible\n        # Based on examples, bump_version('1.2.4a1') -> '1.2.4' (no bump, just strip prerelease)\n        # So, basically, remove prerelease without incrementing numeric part.\n        # That means return version without prerelease string\n\n        # Compose parts without prerelease\n        # The original version_parts are major.minor.patch as integers\n        # But if patch is zero and omitted in string, we should replicate that behavior.\n        # From _each_version_part, patch part is empty string if 0 at patch: '1.3' instead of '1.3.0'\n\n        # Construct version string removing prerelease\n\n        parts = [str(major_num)]\n\n        # Include minor if > 0 or patch>0 or minor prerelease\n        include_minor = (minor_num != 0) or (patch_num != 0) or (current_pre_pos == 1)\n\n        if include_minor:\n            parts.append(str(minor_num))\n\n        # Include patch if patch number > 0\n        include_patch = patch_num != 0\n\n        if include_patch:\n            parts.append(str(patch_num))\n\n        return '.'.join(parts)\n\n    # Otherwise proceed with normal bump and pre_release handling\n    return bump_and_build_version()", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 404, in <module>\n  File \"<string>\", line 403, in test_5\nAssertionError\n", "passed": false}
{"task_id": 125, "prediction_id": 1, "generation": "from typing import Optional, Union\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n    _BUMP_VERSION_MINORS,\n    _BUMP_VERSION_PATCHES,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Validate and normalize position\n    pos = _build_version_bump_position(position)\n\n    # Parse version into detailed parts\n    version_info = _build_version_info(version)\n\n    # Determine bump type (major, minor, patch, pre-release variants)\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract base version components as a list of integers [major, minor, patch]\n    major_num = version_info.major.num\n    minor_num = version_info.minor.num\n    patch_num = version_info.patch.num\n\n    # Existing pre-release data\n    pre_pos = version_info.pre_pos\n    pre_txt = ''\n    pre_num = -1\n    if pre_pos != -1:\n        # Extract current prerelease info on that part\n        if pre_pos == 0:\n            # Major part cannot have prerelease per rules, but just in case\n            pre_txt, pre_num = '', -1\n        elif pre_pos == 1:\n            pre_txt = version_info.minor.pre_txt\n            pre_num = version_info.minor.pre_num\n        elif pre_pos == 2:\n            pre_txt = version_info.patch.pre_txt\n            pre_num = version_info.patch.pre_num\n\n    # Result parts (will build after bumping)\n    new_major = major_num\n    new_minor = minor_num\n    new_patch = patch_num\n\n    # Function to clear lower parts after the bumped one\n    def clear_lower_parts(pos_to_clear: int):\n        nonlocal new_major, new_minor, new_patch\n        if pos_to_clear < 2:\n            new_patch = 0\n        if pos_to_clear < 1:\n            new_minor = 0\n\n    # Handle the bump types:\n    # bump_type tells exactly which kind of bump needed\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increment major, reset minor and patch, no prerelease allowed here\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        pre_txt = ''\n        pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Increment minor, reset patch, remove prerelease\n        if pos > 2:\n            raise ValueError(f\"Invalid position {position} for minor bump\")\n        new_minor += 1\n        new_patch = 0\n        pre_txt = ''\n        pre_num = -1\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Increment patch, remove prerelease\n        if pos > 2:\n            raise ValueError(f\"Invalid position {position} for patch bump\")\n        new_patch += 1\n        pre_txt = ''\n        pre_num = -1\n\n    elif bump_type in _BUMP_VERSION_MINORS:\n        # Minor pre-release bump: minor part stays same but prerelease bumps\n        # Position must be 1\n        if pos != 1:\n            raise ValueError(\"Minor alpha/beta bumps only allowed at position 1\")\n        # For pre-release minor bump:\n        # If current prerelease matches requested type (alpha or beta), increment pre_num\n        # Otherwise reset pre_num to 0 and set pre_txt to new pre-release type\n        is_alpha = bump_type == _BUMP_VERSION_MINOR_ALPHA\n        want_pre_txt = 'a' if is_alpha else 'b'\n        if pre_pos == 1 and pre_txt == want_pre_txt:\n            pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            pre_num = 0\n            pre_txt = want_pre_txt\n        # minor version number stays unchanged, patch set to 0 (don't bump it)\n        new_patch = 0\n        # major and minor stay unchanged\n        new_major = major_num\n        new_minor = minor_num\n\n    elif bump_type in _BUMP_VERSION_PATCHES:\n        # Patch pre-release bump: patch part stays same but prerelease bumps\n        # Position must be 2 (patch)\n        if pos != 2:\n            raise ValueError(\"Patch alpha/beta bumps only allowed at position 2\")\n        is_alpha = bump_type == _BUMP_VERSION_PATCH_ALPHA\n        want_pre_txt = 'a' if is_alpha else 'b'\n        if pre_pos == 2 and pre_txt == want_pre_txt:\n            pre_num = pre_num + 1 if pre_num >= 0 else 0\n        else:\n            pre_num = 0\n            pre_txt = want_pre_txt\n        # major, minor, patch stay unchanged\n        new_major = major_num\n        new_minor = minor_num\n        new_patch = patch_num\n\n    else:\n        # Unknown bump type (should not occur)\n        raise ValueError(f\"Unsupported bump type: {bump_type}\")\n\n    # If no pre_release argument given, but the version has prerelease, then\n    # we remove the prerelease by returning the cleaned version (strip prerelease)\n    if pre_release is None and pre_pos != -1:\n        # remove prerelease, return just \"major.minor.patch\" (dropping trailing zero patch if 0)\n        parts = [new_major, new_minor]\n        if new_patch != 0:\n            parts.append(new_patch)\n        else:\n            # in original code, patch 0 can be omitted if position < 2\n            pass\n        version_str = '.'.join(str(p) for p in parts)\n        return version_str\n\n    # Compose final version string with possible prerelease suffix:\n    parts = [str(new_major), str(new_minor)]\n    # Decide if patch part needed in the version string:\n    # If position is 0 or 1 and patch == 0, patch can be omitted\n    # If position is 2, patch always shown\n    if pos == 2 or new_patch != 0:\n        parts.append(str(new_patch))\n\n    version_str = '.'.join(parts)\n    if pre_txt and pre_num >= 0:\n        version_str += f\"{pre_txt}{pre_num}\"\n\n    return version_str", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 407, in <module>\n  File \"<string>\", line 406, in test_5\nAssertionError\n", "passed": false}
{"task_id": 125, "prediction_id": 2, "generation": "from typing import Optional\nfrom distutils.version import StrictVersion\n\nfrom flutils.packages import (\n    _build_version_info,\n    _build_version_bump_position,\n    _build_version_bump_type,\n    _BUMP_VERSION_MAJOR,\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Normalize position to positive index, validating range\n    pos = _build_version_bump_position(position)\n\n    # Build detailed version information from the given version string\n    ver_info = _build_version_info(version)\n\n    # Determine the bump type constant based on position and pre_release indicator\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract parts for easy reference\n    major = ver_info.major\n    minor = ver_info.minor\n    patch = ver_info.patch\n\n    # Initialize new version parts as integers\n    new_major = major.num\n    new_minor = minor.num\n    new_patch = patch.num\n\n    # Determine current pre-release text and number for the bump position\n    cur_pre_txt = ''\n    cur_pre_num = -1\n    if ver_info.pre_pos == pos:\n        # There is a prerelease at the bumped position\n        if pos == 0:\n            # The code does not support prerelease on major (raises earlier)\n            pass\n        else:\n            # Assign existing prerelease text and number from the part\n            parts_map = {0: major, 1: minor, 2: patch}\n            part = parts_map[pos]\n            cur_pre_txt = part.pre_txt\n            cur_pre_num = part.pre_num\n\n    # Logic to bump version parts depending on bump_type:\n    # The bump types are:\n    # Major: 0\n    # Minor: 1\n    # Patch: 2\n    # Minor Alpha: 3\n    # Minor Beta: 4\n    # Patch Alpha: 5\n    # Patch Beta: 6\n\n    # We'll build the bumped version string at the end step by step.\n\n    # Function to reset lower parts when major/minor increments happen\n    def reset_lower_parts(upto_pos: int):\n        nonlocal new_major, new_minor, new_patch\n        # Reset parts below the given position\n        if upto_pos == 0:\n            new_minor = 0\n            new_patch = 0\n        elif upto_pos == 1:\n            new_patch = 0\n\n    # Primary bump logic\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increment major, reset minor and patch, no prerelease allowed\n        new_major += 1\n        reset_lower_parts(0)\n        # Prerelease not allowed for major bump, so ignore any pre-release suffix\n        bumped_version = f\"{new_major}.0\"\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Increment minor, reset patch, drop prerelease if any\n        new_minor += 1\n        new_patch = 0\n        bumped_version = f\"{new_major}.{new_minor}\"\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Increment patch, drop prerelease if any\n        new_patch += 1\n        # Special case: if patch is 0 after increment (should not happen here), omit patch\n        if new_patch == 0:\n            # E.g. 1.2.0 -> '1.2'\n            bumped_version = f\"{new_major}.{new_minor}\"\n        else:\n            bumped_version = f\"{new_major}.{new_minor}.{new_patch}\"\n    elif bump_type in (_BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # Minor pre-release bump (alpha: 3, beta:4)\n        # Reset patch to 0, increment minor if needed, handle prerelease number increment\n        # The pre-release tag depends on bump_type: alpha or beta\n\n        pre_txt = 'a' if bump_type == _BUMP_VERSION_MINOR_ALPHA else 'b'\n\n        # For minor prerelease bump:\n        # if current version's pre-release at minor position matches pre_txt,\n        # increment the pre-release num; else start at 0\n        # If current minor == ver_info.minor.num and prerelease matches pre_txt, bump pre_num\n        # else increment minor and start pre_num at 0\n\n        if pos != 1:\n            # Defensive, position for minor pre-release bump must be 1\n            raise ValueError(\"Minor pre-release bump must have position == 1\")\n\n        if ver_info.pre_pos == 1 and minor.pre_txt == pre_txt:\n            new_minor = minor.num\n            new_patch = 0\n            new_pre_num = minor.pre_num + 1\n        else:\n            # Increment minor, reset patch, start pre_num at 0\n            new_minor = minor.num + 1\n            new_patch = 0\n            new_pre_num = 0\n\n        # Prepare the bumped version string\n        bumped_version = f\"{new_major}.{new_minor}{pre_txt}{new_pre_num}\"\n    elif bump_type in (_BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Patch pre-release bump (alpha: 5, beta: 6)\n        pre_txt = 'a' if bump_type == _BUMP_VERSION_PATCH_ALPHA else 'b'\n\n        # For patch prerelease bump:\n        # if current version's pre-release at patch position matches pre_txt,\n        # increment the pre-release num; else start at 0\n        # If current patch == ver_info.patch.num and prerelease matches pre_txt, bump pre_num\n        # else increment patch and start pre_num at 0\n\n        if pos != 2:\n            # Defensive, position for patch pre-release bump must be 2\n            raise ValueError(\"Patch pre-release bump must have position == 2\")\n\n        if ver_info.pre_pos == 2 and patch.pre_txt == pre_txt:\n            new_patch = patch.num\n            new_pre_num = patch.pre_num + 1\n        else:\n            # Increment patch and start pre_num at 0\n            new_patch = patch.num + 1\n            new_pre_num = 0\n\n        # Prepare bumped version string\n        bumped_version = f\"{new_major}.{new_minor}.{new_patch}{pre_txt}{new_pre_num}\"\n    else:\n        # Defensive fallback: if bump_type unexpected, raise error\n        raise ValueError(f\"Unhandled bump type: {bump_type}\")\n\n    # If bump_type is *not* a prerelease, but the original version had a prerelease,\n    # and no pre_release argument was given, strip prerelease suffix (i.e., return final release)\n    # This is shown by examples: bump_version('1.2.4a1') -> '1.2.4'\n    # So if pre_release is None, and version has a prerelease component,\n    # and bump_type is a regular bump (major, minor, patch), strip the prerelease\n\n    is_prerelease_bump = bump_type in (\n        _BUMP_VERSION_MINOR_ALPHA,\n        _BUMP_VERSION_MINOR_BETA,\n        _BUMP_VERSION_PATCH_ALPHA,\n        _BUMP_VERSION_PATCH_BETA,\n    )\n\n    if not is_prerelease_bump and pre_release is None and ver_info.pre_pos != -1:\n        # Remove pre-release suffix from bumped_version:\n        # The bumped_version was built with no prerelease suffix,\n        # but original version had prerelease -> we want the final release version (no suffix)\n        # So nothing to remove actually, just return bumped_version as is.\n        # Because bumped_version was built without suffix already.\n\n        # But edge case: if bumped_version still has trailing zero patch which should not be displayed\n        # For example, if bumped_version ends with \".0\" in patch, drop it as per examples\n        # Actually, examples suggest that:\n        # - If patch == 0, and position==1, just return major.minor (e.g. '1.3')\n        # - If patch == 0, position==0, '2.0'\n        # - Else 'x.y.z'\n\n        # Already handled in bump string construction above.\n\n        pass\n\n    return bumped_version", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 445, in <module>\n  File \"<string>\", line 444, in test_21\nAssertionError\n", "passed": false}
{"task_id": 125, "prediction_id": 3, "generation": "from typing import Optional, Union, cast, List\nfrom distutils.version import StrictVersion\n\n# Constants (copied from file content for standalone code)\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS: tuple = (\n    _BUMP_VERSION_MINOR,\n    _BUMP_VERSION_MINOR_ALPHA,\n    _BUMP_VERSION_MINOR_BETA,\n)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES: tuple = (\n    _BUMP_VERSION_PATCH,\n    _BUMP_VERSION_PATCH_ALPHA,\n    _BUMP_VERSION_PATCH_BETA,\n)\n_BUMP_VERSION_POSITION_NAMES = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\n# NamedTuple for version parts\nfrom collections import namedtuple\n_VersionPart = namedtuple('_VersionPart', ['pos', 'txt', 'num', 'pre_txt', 'pre_num', 'name'])\n_VersionInfo = namedtuple('_VersionInfo', ['version', 'major', 'minor', 'patch', 'pre_pos'])\n\n\ndef _each_version_part(ver_obj: StrictVersion):\n    version = ver_obj.version\n    prerelease = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n\n        if (prerelease_built is False and pos > 0 and prerelease is not None):\n            prerelease = cast(tuple, prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)\n\n\ndef _build_version_info(version: str) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)\n\n\ndef _build_version_bump_position(position: int) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Parse and validate version\n    ver_info = _build_version_info(version)\n\n    # Normalize position (handle negative and range checks)\n    position_positive = _build_version_bump_position(position)\n\n    bump_type = _build_version_bump_type(position_positive, pre_release)\n\n    # Extract version numbers to manipulate\n    major_num = ver_info.major.num\n    minor_num = ver_info.minor.num\n    patch_num = ver_info.patch.num\n\n    major_txt = ver_info.major.txt\n    minor_txt = ver_info.minor.txt\n    patch_txt = ver_info.patch.txt\n\n    major_pre_txt = ver_info.major.pre_txt\n    minor_pre_txt = ver_info.minor.pre_txt\n    patch_pre_txt = ver_info.patch.pre_txt\n\n    major_pre_num = ver_info.major.pre_num\n    minor_pre_num = ver_info.minor.pre_num\n    patch_pre_num = ver_info.patch.pre_num\n\n    # Handle bumps depending on type:\n    # First, some helper logic:\n\n    def _clear_lower_positions(start_pos: int):\n        # After bumping the given position, all lower positions should be reset to zero\n        nonlocal major_num, minor_num, patch_num\n        if start_pos <= 0:\n            minor_num = 0\n            patch_num = 0\n        elif start_pos == 1:\n            patch_num = 0\n        # For position 2 (patch), no lower to reset\n\n    def _clear_pre_releases_except(pos: int):\n        # Clear pre_release on all parts except the one at pos\n        nonlocal major_pre_txt, minor_pre_txt, patch_pre_txt\n        nonlocal major_pre_num, minor_pre_num, patch_pre_num\n        if pos != 0:\n            major_pre_txt = ''\n            major_pre_num = -1\n        if pos != 1:\n            minor_pre_txt = ''\n            minor_pre_num = -1\n        if pos != 2:\n            patch_pre_txt = ''\n            patch_pre_num = -1\n\n    # Determine if it's a pre-release bump or normal bump\n    is_pre_release = bump_type in _BUMP_VERSION_MINORS + _BUMP_VERSION_PATCHES\n\n    # For major bump, must not be pre-release (checked in _build_version_bump_type)\n\n    # Handle bump types:\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Major bump: increment major, reset minor and patch, drop pre-release\n        major_num += 1\n        minor_num = 0\n        patch_num = 0\n        major_pre_txt = ''\n        major_pre_num = -1\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        # Return just major.minor (patch dropped if zero)\n        # According to example: bumping position=0 from 1.3.4 -> 2.0 (so patch dropped)\n        # So we return major.minor without patch if patch zero\n        # If patch is zero (which it always is here), omit patch\n        return f\"{major_num}.{minor_num}\"\n\n    elif bump_type == _BUMP_VERSION_MINOR:\n        # Minor bump normal: increment minor, reset patch, clear pre-release on minor and patch\n        minor_num += 1\n        patch_num = 0\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(1)\n        _clear_lower_positions(1)\n\n    elif bump_type == _BUMP_VERSION_PATCH:\n        # Patch bump normal\n        patch_num += 1\n\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(2)\n        _clear_lower_positions(2)\n\n    elif bump_type == _BUMP_VERSION_MINOR_ALPHA:\n        # pre-release alpha bump on minor\n        # increment minor if jump from no pre-release or different pre-release?\n        # refer examples: bump_position=1, prerelease='a'\n\n        # We only bump pre_num if pre_txt matches alpha, else start a0\n        # or if previously beta, start alpha anew (0)\n\n        # If current minor pre_txt != 'a' or 'alpha', start at 0, else increment\n        if minor_pre_txt not in ('a', 'alpha'):\n            # new alpha pre-release\n            minor_num += 1\n            minor_pre_num = 0\n            minor_pre_txt = 'a'\n        else:\n            # increment alpha pre\n            minor_pre_num += 1\n\n        # clear patch and patch pre-release\n        patch_num = 0\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        # clear major pre-release\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(1)\n        _clear_lower_positions(1)\n\n    elif bump_type == _BUMP_VERSION_MINOR_BETA:\n        # pre-release beta bump on minor\n        if minor_pre_txt not in ('b', 'beta'):\n            minor_num += 1\n            minor_pre_num = 0\n            minor_pre_txt = 'b'\n        else:\n            minor_pre_num += 1\n\n        patch_num = 0\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(1)\n        _clear_lower_positions(1)\n\n    elif bump_type == _BUMP_VERSION_PATCH_ALPHA:\n        # pre-release alpha bump on patch\n        if patch_pre_txt not in ('a', 'alpha'):\n            patch_num += 1\n            patch_pre_num = 0\n            patch_pre_txt = 'a'\n        else:\n            patch_pre_num += 1\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(2)\n        _clear_lower_positions(2)\n\n    elif bump_type == _BUMP_VERSION_PATCH_BETA:\n        # pre-release beta bump on patch\n        if patch_pre_txt not in ('b', 'beta'):\n            patch_num += 1\n            patch_pre_num = 0\n            patch_pre_txt = 'b'\n        else:\n            patch_pre_num += 1\n\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        major_pre_txt = ''\n        major_pre_num = -1\n\n        _clear_pre_releases_except(2)\n        _clear_lower_positions(2)\n\n    else:\n        # Should never occur due to _build_version_bump_type validation\n        raise ValueError(\"Unsupported bump type: %r\" % bump_type)\n\n    # After bump, if no pre_release arg given but version had pre_release, we remove it (like examples)\n    if pre_release is None and (minor_pre_txt or patch_pre_txt):\n        # Remove pre-release from bumped minor or patch\n        minor_pre_txt = ''\n        minor_pre_num = -1\n        patch_pre_txt = ''\n        patch_pre_num = -1\n\n    # Compose version string\n\n    def _compose_part(num: int, pre_txt: str, pre_num: int) -> str:\n        if num == 0 and pre_txt == '' and pre_num == -1:\n            # For patch zero, often ommitted (e.g., '1.2'), but in examples patch 0 is included sometimes\n            # Nicer to include zero, except in patch 0 at end with no pre-release - then omit patch\n            return '0'\n        part = str(num)\n        if pre_txt:\n            part += f\"{pre_txt}{pre_num}\"\n        return part\n\n    # Format depends on position, but safely always include major, minor,\n    # and include patch only if it is non-zero or needed\n\n    # According to examples:\n    # - major bump: output major.minor (patch zero omitted)\n    # - minor bump: output major.minor (patch zero omitted)\n    # - patch bump: output major.minor.patch\n    # - pre-release bumps may have alpha/beta suffix on minor or patch\n\n    # Determine text parts for output:\n    major_part = str(major_num)\n    # Include pre-release on major? Examples have no pre-release on major, so no\n\n    minor_part = str(minor_num)\n    if minor_pre_txt:\n        minor_part += f\"{minor_pre_txt}{minor_pre_num}\"\n\n    patch_part = ''\n    if patch_num != 0 or patch_pre_txt:\n        patch_part = str(patch_num)\n        if patch_pre_txt:\n            patch_part += f\"{patch_pre_txt}{patch_pre_num}\"\n\n    # Compose final version string:\n    # If patch is empty string or zero and position is 0 or 1 bump, omit patch (as in examples)\n    # Otherwise include patch part\n\n    if patch_part == '' or patch_part == '0':\n        # If patch empty or 0 without pre_release, omit patch\n        # Include patch if pre-release is on patch (non-empty patch_part)\n        if bump_type in (_BUMP_VERSION_MAJOR, _BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n            # major or minor bumps -> return major.minor only\n            return f\"{major_part}.{minor_part}\"\n        else:\n            # patch bumps, include patch even if zero\n            # but example '1.2b0' bump with position=2 -> '1.2.1' means patch included\n            return f\"{major_part}.{minor_part}.0\"\n    else:\n        return f\"{major_part}.{minor_part}.{patch_part}\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 651, in <module>\n  File \"<string>\", line 650, in test_21\nAssertionError\n", "passed": false}
{"task_id": 125, "prediction_id": 4, "generation": "from typing import Optional, Union, cast\nfrom distutils.version import StrictVersion\n\n_BUMP_VERSION_MAJOR: int = 0\n_BUMP_VERSION_MINOR: int = 1\n_BUMP_VERSION_PATCH: int = 2\n_BUMP_VERSION_MINOR_ALPHA: int = 3\n_BUMP_VERSION_MINOR_BETA: int = 4\n_BUMP_VERSION_MINORS = (_BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA)\n_BUMP_VERSION_PATCH_ALPHA: int = 5\n_BUMP_VERSION_PATCH_BETA: int = 6\n_BUMP_VERSION_PATCHES = (_BUMP_VERSION_PATCH, _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA)\n_BUMP_VERSION_POSITION_NAMES = {\n    _BUMP_VERSION_MAJOR: 'major',\n    _BUMP_VERSION_MINOR: 'minor',\n    _BUMP_VERSION_PATCH: 'patch',\n}\n\n\nclass _VersionPart:\n    def __init__(self, pos: int, txt: str, num: int, pre_txt: str, pre_num: int, name: str) -> None:\n        self.pos = pos\n        self.txt = txt\n        self.num = num\n        self.pre_txt = pre_txt\n        self.pre_num = pre_num\n        self.name = name\n\n\ndef _each_version_part(ver_obj: StrictVersion):\n    version = ver_obj.version\n    prerelease = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        pre_txt = ''\n        pre_num = -1\n        if not prerelease_built and pos > 0 and prerelease is not None:\n            prerelease = cast(tuple, prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add:\n                txt = '%s%s%s' % (txt, prerelease[0], prerelease[1])\n                pre_txt = prerelease[0]\n                pre_num = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(pos, txt, num, pre_txt, pre_num, _BUMP_VERSION_POSITION_NAMES[pos])\n\n\nclass _VersionInfo:\n    def __init__(self, version: str, major: _VersionPart, minor: _VersionPart,\n                 patch: _VersionPart, pre_pos: int) -> None:\n        self.version = version\n        self.major = major\n        self.minor = minor\n        self.patch = patch\n        self.pre_pos = pre_pos\n\n\ndef _build_version_info(version: str) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    parts = []\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        parts.append(part)\n    # parts order: major, minor, patch\n    return _VersionInfo(version, parts[0], parts[1], parts[2], pre_pos)\n\n\ndef _build_version_bump_position(position: int) -> int:\n    pos_min = -3\n    pos_max = 2\n    if not (pos_min <= position <= pos_max):\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position\n\n\ndef _build_version_bump_type(position_positive: int, pre_release: Union[str, None]) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = prerelease in ('a', 'alpha')\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )\n\n\ndef bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n    # Validate and normalize position\n    pos = _build_version_bump_position(position)\n    # Build current version info\n    info = _build_version_info(version)\n    # Determine bump type from position and pre_release\n    bump_type = _build_version_bump_type(pos, pre_release)\n\n    # Extract current version parts for easier manipulation\n    major_num = info.major.num\n    minor_num = info.minor.num\n    patch_num = info.patch.num\n\n    major_pre_txt = info.major.pre_txt\n    major_pre_num = info.major.pre_num\n    minor_pre_txt = info.minor.pre_txt\n    minor_pre_num = info.minor.pre_num\n    patch_pre_txt = info.patch.pre_txt\n    patch_pre_num = info.patch.pre_num\n\n    # Define helper to format version parts with or without pre-release\n    def format_version_part(num: int, pre_txt: str = '', pre_num: int = -1) -> str:\n        if num == 0:\n            base = ''\n        else:\n            base = str(num)\n        if pre_txt and pre_num >= 0:\n            return f\"{base}{pre_txt}{pre_num}\"\n        return base\n\n    # Build new version components initialization\n    new_major = major_num\n    new_minor = minor_num\n    new_patch = patch_num\n\n    # Manage bump logic based on bump_type:\n    if bump_type == _BUMP_VERSION_MAJOR:\n        # Increment major, reset minor and patch to 0, no prerelease allowed\n        new_major += 1\n        new_minor = 0\n        new_patch = 0\n        # pre-release not allowed on major, so no pre text/num\n        return f\"{new_major}.0\"\n\n    if bump_type in (_BUMP_VERSION_MINOR, _BUMP_VERSION_MINOR_ALPHA, _BUMP_VERSION_MINOR_BETA):\n        # Bumping minor (may be prerelease)\n        new_minor = minor_num\n        new_patch = 0\n\n        if bump_type == _BUMP_VERSION_MINOR:\n            # Normal minor bump: increment minor, reset patch (no prerelease)\n            new_minor = minor_num + 1\n            # After bump, no prerelease allowed, so just \"X.Y\"\n            # Major untouched\n            return f\"{major_num}.{new_minor}\"\n        else:\n            # Minor prerelease bump (alpha or beta)\n            is_alpha = bump_type == _BUMP_VERSION_MINOR_ALPHA\n            pre_txt = 'a' if is_alpha else 'b'\n            # Determine number for prerelease:\n            if info.pre_pos == 1 and minor_pre_txt == pre_txt and minor_pre_num >= 0:\n                # bump existing prerelease number\n                new_pre_num = minor_pre_num + 1\n            else:\n                # start new prerelease at 0\n                new_pre_num = 0\n\n            # increment minor if not already incremented to start prerelease (if current minor is different)\n            if info.pre_pos != 1 or minor_pre_txt != pre_txt:\n                # This indicates the version wasn't already on this prerelease, so bump minor\n                new_minor = minor_num + 1\n            return f\"{major_num}.{new_minor}{pre_txt}{new_pre_num}\"\n\n    if bump_type in (_BUMP_VERSION_PATCH, _BUMP_VERSION_PATCH_ALPHA, _BUMP_VERSION_PATCH_BETA):\n        # Bumping patch (may be prerelease)\n        new_patch = patch_num\n\n        if bump_type == _BUMP_VERSION_PATCH:\n            # Normal patch bump: increment patch, no prerelease\n            new_patch = patch_num + 1\n            return f\"{major_num}.{minor_num}.{new_patch}\"\n\n        # Patch prerelease bump alpha or beta\n        is_alpha = bump_type == _BUMP_VERSION_PATCH_ALPHA\n        pre_txt = 'a' if is_alpha else 'b'\n        # Determine number for prerelease:\n        if info.pre_pos == 2 and patch_pre_txt == pre_txt and patch_pre_num >= 0:\n            new_pre_num = patch_pre_num + 1\n            new_patch = patch_num\n        else:\n            # If current prerelease is different or doesn't exist, start patch bump from patch_num +1 pre 0\n            # But if it was a prerelease with different pre_txt (ex. a->b), keep patch_num unchanged and reset\n            # Need to handle cases like bump_version('1.2.4a1', pre_release='b') -> '1.2.4b0'\n            if info.pre_pos == 2:\n                # Different prerelease on patch part\n                new_pre_num = 0\n                new_patch = patch_num\n            else:\n                # No prerelease or prerelease on other position: increment patch and start prerelease\n                new_patch = patch_num + 1\n                new_pre_num = 0\n\n        return f\"{major_num}.{minor_num}.{new_patch}{pre_txt}{new_pre_num}\"\n\n    # If none matched (should not happen)\n    raise RuntimeError(\"Unhandled bump type\")", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 477, in <module>\n  File \"<string>\", line 476, in test_5\nAssertionError\n", "passed": false}
