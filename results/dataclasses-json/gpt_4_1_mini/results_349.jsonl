{"task_id": 349, "prediction_id": 0, "generation": "from typing import Optional, Union\n\nfrom dataclasses_json.api import _process_class\nfrom dataclasses_json.undefined import Undefined\n\n\ndef dataclass_json(_cls=None, *, letter_case=None,\n                   undefined: Optional[Union[str, Undefined]] = None):\n    \"\"\"\n    Based on the code in the `dataclasses` module to handle optional-parens\n    decorators. See example below:\n\n    @dataclass_json\n    @dataclass_json(letter_case=LetterCase.CAMEL)\n    class Example:\n    ...\n    \"\"\"\n    def wrap(cls):\n        return _process_class(cls, letter_case, undefined)\n\n    if _cls is None:\n        # called with parentheses\n        return wrap\n    else:\n        # called without parentheses\n        return wrap(_cls)", "message": "passed", "passed": true}
{"task_id": 349, "prediction_id": 1, "generation": "import functools\nfrom typing import Optional, Union\n\nfrom dataclasses_json.api import _process_class\nfrom dataclasses_json.cfg import LetterCase\nfrom dataclasses_json.undefined import Undefined\n\n\ndef dataclass_json(_cls=None, *, letter_case: Optional[LetterCase] = None,\n                   undefined: Optional[Union[str, Undefined]] = None):\n    \"\"\"\n    Based on the code in the `dataclasses` module to handle optional-parens\n    decorators. See example below:\n\n    @dataclass_json\n    @dataclass_json(letter_case=LetterCase.CAMEL)\n    class Example:\n    ...\n    \"\"\"\n    def wrap(cls):\n        return _process_class(cls, letter_case, undefined)\n\n    if _cls is None:\n        # Called with kwargs, return decorator function to wrap class\n        return wrap\n    else:\n        # Called without kwargs, directly decorate the class\n        return wrap(_cls)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 145, in <module>\nImportError: cannot import name 'LetterCase' from 'dataclasses_json.cfg' (/input/test-apps/dataclasses-json/dataclasses_json/cfg.py)\n", "passed": false}
{"task_id": 349, "prediction_id": 2, "generation": "import functools\nfrom typing import Optional, Union\n\nfrom dataclasses_json.api import _process_class\nfrom dataclasses_json.cfg import LetterCase\nfrom dataclasses_json.undefined import Undefined\n\n\ndef dataclass_json(_cls=None, *, letter_case: Optional[LetterCase] = None,\n                   undefined: Optional[Union[str, Undefined]] = None):\n    \"\"\"\n    Based on the code in the `dataclasses` module to handle optional-parens\n    decorators. See example below:\n\n    @dataclass_json\n    @dataclass_json(letter_case=LetterCase.CAMEL)\n    class Example:\n    ...\n    \"\"\"\n    def wrap(cls):\n        return _process_class(cls, letter_case=letter_case, undefined=undefined)\n\n    if _cls is None:\n        return wrap\n    else:\n        return wrap(_cls)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 145, in <module>\nImportError: cannot import name 'LetterCase' from 'dataclasses_json.cfg' (/input/test-apps/dataclasses-json/dataclasses_json/cfg.py)\n", "passed": false}
{"task_id": 349, "prediction_id": 3, "generation": "from typing import Optional, Union\nfrom dataclasses_json.utils import _undefined_parameter_action_safe\nfrom dataclasses_json.cfg import config\nfrom dataclasses_json.api import _process_class\nfrom dataclasses_json.undefined import Undefined\nfrom enum import Enum\n\n\ndef dataclass_json(_cls=None, *, letter_case: Optional[Enum] = None,\n                   undefined: Optional[Union[str, Undefined]] = None):\n    \"\"\"\n    Based on the code in the `dataclasses` module to handle optional-parens\n    decorators. See example below:\n\n    @dataclass_json\n    @dataclass_json(letter_case=LetterCase.CAMEL)\n    class Example:\n    ...\n    \"\"\"\n    def wrap(cls):\n        # Save config on class if letter_case or undefined are provided\n        if letter_case is not None or undefined is not None:\n            cls.dataclass_json_config = config(\n                letter_case=letter_case, undefined=undefined)['dataclasses_json']\n\n        # Process and extend the class with JSON (de)serialization methods\n        return _process_class(cls, letter_case, undefined)\n\n    # If decorator is used without arguments: @dataclass_json\n    if _cls is not None:\n        return wrap(_cls)\n\n    # If decorator is used with arguments: @dataclass_json(...)\n    return wrap", "message": "passed", "passed": true}
{"task_id": 349, "prediction_id": 4, "generation": "from typing import Optional, Union\n\nfrom dataclasses_json.api import _process_class\nfrom dataclasses_json.undefined import Undefined\n\n\ndef dataclass_json(_cls=None, *, letter_case=None,\n                   undefined: Optional[Union[str, Undefined]] = None):\n    \"\"\"\n    Based on the code in the `dataclasses` module to handle optional-parens\n    decorators. See example below:\n\n    @dataclass_json\n    @dataclass_json(letter_case=LetterCase.CAMEL)\n    class Example:\n    ...\n    \"\"\"\n    def wrap(cls):\n        return _process_class(cls, letter_case=letter_case, undefined=undefined)\n\n    if _cls is None:\n        return wrap\n    else:\n        return wrap(_cls)", "message": "passed", "passed": true}
