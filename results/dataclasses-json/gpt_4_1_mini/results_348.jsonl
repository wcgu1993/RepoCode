{"task_id": 348, "prediction_id": 0, "generation": "import copy\nfrom collections import abc\nfrom dataclasses import fields, is_dataclass\n\nfrom dataclasses_json.core import _encode_json_type, _encode_overrides\nfrom dataclasses_json.utils import _isinstance_safe\n\n\ndef _asdict(obj, encode_json=False):\n    \"\"\"\n    A re-implementation of `asdict` (based on the original in the `dataclasses`\n    source) to support arbitrary Collection and Mapping types.\n    \"\"\"\n    # If obj is not a dataclass instance, return it as is or encode if requested\n    if not is_dataclass(obj):\n        if encode_json:\n            return _encode_json_type(obj)\n        return obj\n\n    # Prepare field overrides for this dataclass type \n    overrides = _user_overrides_or_exts(obj.__class__)\n\n    def _convert(obj_inner):\n        if is_dataclass(obj_inner):\n            # We will create a dict of field names to their values, recursively calling _convert\n            result = {}\n            for f in fields(obj_inner):\n                value = getattr(obj_inner, f.name)\n                result[f.name] = _convert(value)\n            # Apply overrides: includes filtering by exclude predicate, letter case, encoder etc.\n            result = _encode_overrides(result, overrides, encode_json)\n            return result\n        elif _isinstance_safe(obj_inner, abc.Mapping):\n            # For mappings, convert keys and values by recursively calling _convert on values\n            return type(obj_inner)(\n                (key, _convert(value)) for key, value in obj_inner.items()\n            )\n        elif _isinstance_safe(obj_inner, abc.Collection) and not isinstance(obj_inner, (str, bytes, bytearray)):\n            # For other collections (lists, sets, tuples), convert each element recursively\n            converted = [_convert(v) for v in obj_inner]\n            # Preserve original collection type if possible\n            try:\n                return type(obj_inner)(converted)\n            except TypeError:\n                # fallback to list if the type constructor fails\n                return converted\n        else:\n            # Primitive types or objects that are not dataclasses/collections:\n            # If encode_json is requested, encode basic JSON types, else return as is\n            if encode_json:\n                return _encode_json_type(obj_inner)\n            return obj_inner\n\n    return _convert(obj)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 400, in <module>\n  File \"<string>\", line 399, in test_3\nAssertionError\n", "passed": false}
{"task_id": 348, "prediction_id": 1, "generation": "from collections.abc import Collection, Mapping\nfrom dataclasses import fields, is_dataclass\nfrom typing import Any\n\nfrom dataclasses_json.core import _encode_json_type, _encode_overrides, _user_overrides_or_exts\nfrom dataclasses_json.utils import _isinstance_safe\n\n\ndef _asdict(obj, encode_json=False):\n    \"\"\"\n    A re-implementation of `asdict` (based on the original in the `dataclasses`\n    source) to support arbitrary Collection and Mapping types.\n    \"\"\"\n    if not is_dataclass(obj):\n        raise TypeError(\"asdict() should be called on dataclass instances\")\n\n    # Obtain field-specific overrides (e.g. encoders, lettercase functions, excludes)\n    overrides = _user_overrides_or_exts(type(obj))\n\n    def _convert(value):\n        # For dataclass instances, recurse into their fields\n        if is_dataclass(value):\n            return _convert(_asdict(value, encode_json=encode_json))\n\n        # For general Mappings, recursively convert both keys and values\n        elif _isinstance_safe(value, Mapping):\n            # Dict keys are typically strings (JSON keys), \n            # so keys are left as-is (not converted to dict keys as in decode)\n            return type(value)(\n                (_convert(k), _convert(v)) for k, v in value.items()\n            )\n\n        # For Collections (but not strings), recursively convert items\n        elif (_isinstance_safe(value, Collection)\n              and not isinstance(value, (str, bytes, bytearray))):\n            return type(value)(_convert(v) for v in value)\n\n        # Otherwise, encode json type if requested or return as-is\n        else:\n            if encode_json:\n                return _encode_json_type(value)\n            else:\n                return value\n\n    # Build dictionary of field names to converted values, respecting overrides (excludes, encoders, letter case)\n    kw = {}\n    for field in fields(obj):\n        value = getattr(obj, field.name)\n        # Check exclude predicate from overrides - skip if exclude says so\n        override = overrides.get(field.name)\n        if override is not None and override.exclude is not None and override.exclude(value):\n            continue\n\n        # Apply encoder if present on the field override before recursion (to encode or transform field value)\n        if override is not None and override.encoder is not None:\n            value = override.encoder(value)\n\n        # Recurse conversion\n        value = _convert(value)\n\n        # Handle letter_case renaming if set\n        if override is not None and override.letter_case is not None:\n            key = override.letter_case(field.name)\n        else:\n            key = field.name\n\n        kw[key] = value\n\n    return kw", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 411, in <module>\n  File \"<string>\", line 410, in test_2\n  File \"<string>\", line 351, in _asdict\nTypeError: asdict() should be called on dataclass instances\n", "passed": false}
{"task_id": 348, "prediction_id": 2, "generation": "import copy\nfrom collections.abc import Mapping, Collection\nfrom dataclasses import is_dataclass, fields\n\nfrom dataclasses_json.core import _encode_json_type\nfrom dataclasses_json.core import _encode_overrides\nfrom dataclasses_json.core import _user_overrides_or_exts\nfrom dataclasses_json.utils import _isinstance_safe\n\n\ndef _asdict(obj, encode_json=False):\n    \"\"\"\n    A re-implementation of `asdict` (based on the original in the `dataclasses`\n    source) to support arbitrary Collection and Mapping types.\n    \"\"\"\n    if not is_dataclass(obj):\n        raise TypeError(f\"_asdict() should be called on dataclass instances, got {type(obj)}\")\n\n    # Recursively convert dataclass fields to dict\n    def _convert(obj_inner):\n        if is_dataclass(obj_inner):\n            cls = type(obj_inner)\n            overrides = _user_overrides_or_exts(cls)\n\n            result = {}\n            for f in fields(obj_inner):\n                if not f.init and f.repr is False:\n                    # Skip fields not included in initializer and representation, per dataclass standard asdict\n                    continue\n                value = getattr(obj_inner, f.name)\n                # Recursively convert value\n                value = _convert(value)\n                result[f.name] = value\n\n            # Apply overrides (encoder, letter_case, exclusion) and optionally encode JSON types\n            result = _encode_overrides(result, overrides, encode_json=encode_json)\n\n            return result\n\n        # For general Mapping (e.g. dict, OrderedDict, etc.), apply to keys and values recursively\n        elif _isinstance_safe(obj_inner, Mapping):\n            # Preserve the mapping type if possible\n            # Create a new mapping instance of the same type if possible, else dict\n            res_mapping = obj_inner.__class__() if type(obj_inner) != dict else {}\n            for k, v in obj_inner.items():\n                # Keys are usually strings in JSON/dict, so do not convert keys\n                res_mapping[k] = _convert(v)\n            return res_mapping\n\n        # For Collections (list, set, tuple, etc.) but not strings, convert each element recursively\n        elif _isinstance_safe(obj_inner, Collection) and not isinstance(obj_inner, (str, bytes)):\n            # Preserve the type where possible\n            cons = type(obj_inner)\n            # Convert each element\n            converted = (_convert(v) for v in obj_inner)\n            if cons in (list, set, tuple):\n                return cons(converted)\n            else:\n                # If unknown collection type, try to create from iterable, fallback to list\n                try:\n                    return cons(converted)\n                except Exception:\n                    return list(converted)\n\n        else:\n            # Base case: not a dataclass, not mapping, not collection\n            # Optionally encode_json types (e.g. Decimal, UUID, Enum, datetime)\n            if encode_json:\n                return _encode_json_type(obj_inner)\n            else:\n                return obj_inner\n\n    # Make a deep copy before conversion to avoid mutability side-effects\n    obj_copy = copy.deepcopy(obj)\n    return _convert(obj_copy)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 417, in <module>\n  File \"<string>\", line 416, in test_2\n  File \"<string>\", line 353, in _asdict\nTypeError: _asdict() should be called on dataclass instances, got <class 'list'>\n", "passed": false}
{"task_id": 348, "prediction_id": 3, "generation": "from collections.abc import Collection, Mapping\nfrom dataclasses import fields, is_dataclass\nfrom typing import Any, Dict\n\nfrom dataclasses_json.core import _encode_json_type, _encode_overrides, _user_overrides_or_exts\nfrom dataclasses_json.utils import _isinstance_safe\n\n\ndef _asdict(obj, encode_json=False):\n    \"\"\"\n    A re-implementation of `asdict` (based on the original in the `dataclasses`\n    source) to support arbitrary Collection and Mapping types.\n    \"\"\"\n    if not is_dataclass(obj):\n        raise TypeError(f\"_asdict() should be called on dataclass instances, got {type(obj)}\")\n\n    overrides = _user_overrides_or_exts(type(obj))\n\n    def _convert(obj):\n        if _isinstance_safe(obj, tuple(fields(type(obj)))):\n            # Should never happen as fields return Field objects, not types,\n            # so this is not useful here; skip this condition.\n            pass\n\n        if is_dataclass(obj) and not isinstance(obj, type):\n            # Convert dataclass instance to dict with keys encoded and values converted recursively\n            result = {}\n            for f in fields(obj):\n                if not f.init:\n                    continue\n                value = getattr(obj, f.name)\n                if value is None:\n                    result[f.name] = None\n                elif is_dataclass(value):\n                    result[f.name] = _convert(value)\n                elif isinstance(value, (Mapping, Collection)) and not isinstance(value, (str, bytes)):\n                    # Collections handled normally below\n                    pass\n                else:\n                    result[f.name] = value\n            result = _encode_overrides(result, overrides, encode_json)\n            return result\n\n        if _isinstance_safe(obj, Mapping):\n            return obj.__class__((_convert(k), _convert(v)) for k, v in obj.items())\n        elif _isinstance_safe(obj, Collection) and not isinstance(obj, (str, bytes)):\n            return obj.__class__(_convert(v) for v in obj)\n        else:\n            if encode_json:\n                return _encode_json_type(obj)\n            return obj\n\n    return _convert(obj)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 395, in <module>\n  File \"<string>\", line 394, in test_2\n  File \"<string>\", line 351, in _asdict\nTypeError: _asdict() should be called on dataclass instances, got <class 'list'>\n", "passed": false}
{"task_id": 348, "prediction_id": 4, "generation": "from collections.abc import Mapping, Collection\nfrom dataclasses import fields, is_dataclass\nfrom dataclasses_json.core import _encode_json_type, _encode_overrides, _ExtendedEncoder, _user_overrides_or_exts\nfrom dataclasses_json.utils import _isinstance_safe\nfrom typing import Any\n\ndef _asdict(obj: Any, encode_json: bool = False) -> Any:\n    \"\"\"\n    A re-implementation of `asdict` (based on the original in the `dataclasses`\n    source) to support arbitrary Collection and Mapping types.\n    \"\"\"\n    if not is_dataclass(obj):\n        # Not a dataclass instance, return it (optionally encode to JSON-compatible)\n        return _encode_json_type(obj) if encode_json else obj\n\n    # Retrieve field overrides for encoding/decoding to honor encoders, letter_case, exclude etc.\n    overrides = _user_overrides_or_exts(type(obj))\n\n    def _convert(value):\n        # If value is a dataclass instance, recurse\n        if is_dataclass(value) and not isinstance(value, type):\n            return _asdict(value, encode_json=encode_json)\n        elif _isinstance_safe(value, Mapping):\n            # For mappings, preserve type (e.g. dict or OrderedDict)\n            # map keys/values recursively converting values, keys remain the same\n            return type(value)(\n                (k, _convert(v))\n                for k, v in value.items()\n            )\n        elif _isinstance_safe(value, Collection) and not isinstance(value, (str, bytes, bytearray)):\n            # For collections (list, set, tuple, etc) but not strings, bytes\n            return type(value)(_convert(v) for v in value)\n        else:\n            # For primitive or unknown types, optionally encode json or pass as is\n            return _encode_json_type(value) if encode_json else value\n\n    # Build a dict of field values keyed by override lettercase and filtered by exclude predicate\n    kvs = {}\n    for field in fields(obj):\n        value = getattr(obj, field.name)\n        # Check exclude using overrides; if true skip field\n        field_override = overrides.get(field.name)\n        if field_override and field_override.exclude and field_override.exclude(value):\n            continue\n\n        # Determine output key with letter_case override if any\n        key = field.name\n        if field_override and field_override.letter_case:\n            key = field_override.letter_case(field.name)\n\n        # Use encoder if present on field override for the value\n        if field_override and field_override.encoder is not None:\n            value = field_override.encoder(value)\n        else:\n            value = _convert(value)\n\n        if encode_json:\n            value = _encode_json_type(value)\n\n        kvs[key] = value\n\n    return kvs", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 408, in <module>\n  File \"<string>\", line 407, in test_3\nAssertionError\n", "passed": false}
