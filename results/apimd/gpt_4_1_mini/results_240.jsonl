{"task_id": 240, "prediction_id": 0, "generation": "from ast import Constant, Subscript, Tuple, List, Set, Dict\nfrom typing import Sequence, Optional\nfrom apimd.parser import _type_name, _e_type\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    # Handle Constant node directly: return the qualified type name of its value\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n\n    # Handle container literals: Tuple, List, Set, Dict\n    if isinstance(node, Tuple):\n        # For Tuple, get types of all elements\n        return _e_type(node.elts)\n    elif isinstance(node, List):\n        # For List, get type of all elements as one sequence\n        return _e_type(node.elts)\n    elif isinstance(node, Set):\n        # For Set, get type of all elements as one sequence\n        return _e_type(node.elts)\n    elif isinstance(node, Dict):\n        # For Dict, get type of keys and values separately\n        return _e_type(node.keys, node.values)\n\n    # For any other node, return empty string signifying unknown type\n    return \"\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 643, in <module>\n  File \"<string>\", line 642, in test_0\nAssertionError\n", "passed": false}
{"task_id": 240, "prediction_id": 1, "generation": "from ast import Constant, expr\nfrom apimd.parser import _type_name\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    return \"\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 625, in <module>\n  File \"<string>\", line 624, in test_0\nAssertionError\n", "passed": false}
{"task_id": 240, "prediction_id": 2, "generation": "from ast import Constant, Expr, expr\nfrom apimd.parser import _type_name, _e_type\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    # The function infers the type name of the provided AST expr node representing a constant value.\n    # If the node is a Constant, return its type name using _type_name.\n    # If the node is not a Constant, check if it is a collection of constants (like a list, tuple, set, dict) \n    # and try to infer element types using _e_type.\n    # For dict, infer type from keys and values separately and combine them.\n    # For other nodes or unknown structures, fallback to returning 'Any'.\n\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n\n    # For containers with elements (List, Tuple, Set, Dict in ast)\n    # check element types\n    # We handle this by checking attributes .elts for list-like and tuple-like nodes or keys/values for dict.\n    # Because full AST class imports (like List, Tuple, Set, Dict) are not imported from ast,\n    # we use the class names from ast by string comparison to avoid importing them directly here.\n    typename = type(node).__qualname__\n\n    # Try to handle the common container types by name:\n    if typename in ('List', 'Tuple', 'Set'):\n        # These have an attribute 'elts' with the elements\n        elements = getattr(node, 'elts', None)\n        if elements is None:\n            return \"Any\"\n        return _e_type(elements) or \"Any\"\n\n    if typename == 'Dict':\n        keys = getattr(node, 'keys', None)\n        values = getattr(node, 'values', None)\n        if keys is None or values is None:\n            return \"Any\"\n        key_type = _e_type(keys)\n        value_type = _e_type(values)\n        if key_type and value_type:\n            return f\"Dict{key_type[:-1]}, {value_type[1:]}\"  # Compose \"Dict[key_type, value_type]\"\n        else:\n            return \"Any\"\n\n    # For any other node types, return \"Any\"\n    return \"Any\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 669, in <module>\n  File \"<string>\", line 668, in test_4\nAssertionError\n", "passed": false}
{"task_id": 240, "prediction_id": 3, "generation": "from ast import Constant, expr\nfrom apimd.parser import _type_name\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if not isinstance(node, Constant):\n        return \"\"\n    return _type_name(node.value)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 624, in <module>\n  File \"<string>\", line 623, in test_0\nAssertionError\n", "passed": false}
{"task_id": 240, "prediction_id": 4, "generation": "from ast import expr, Constant, List, Tuple, Set, Dict\nfrom typing import Sequence, Optional\n# Assuming _type_name and _e_type are accessible in the same module or imported accordingly.\n# Here re-define as per context function signatures for completeness.\n\ndef _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__\n\ndef _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (List, Tuple, Set)):\n        return _e_type(node.elts)\n    elif isinstance(node, Dict):\n        # Could attempt a basic dict type representation as \"dict\"\n        # or \"dict[key_type, value_type]\" if key and value elements are constants.\n        # To keep simple, just return \"dict\"\n        return \"dict\"\n    else:\n        # Unhandled or unknown expression node\n        return \"\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 660, in <module>\n  File \"<string>\", line 659, in test_0\nAssertionError\n", "passed": false}
