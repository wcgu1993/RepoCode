{"task_id": 240, "prediction_id": 0, "generation": "from typing import Union\nfrom ast import expr, Constant, List, Tuple, Set, Dict\nfrom apimd.parser import _type_name, _e_type\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    # Handle simple constant literal\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n\n    # Handle containers with elements of constant type\n    if isinstance(node, (List, Tuple, Set)):\n        # Extract elements and infer element types\n        element_type = _e_type(node.elts)\n        # If element_type is empty string, fallback to container type without brackets\n        if not element_type:\n            return type(node).__qualname__\n        return f\"{type(node).__qualname__}{element_type}\"\n\n    if isinstance(node, Dict):\n        # Dict keys and values types\n        key_type = _e_type(node.keys)\n        value_type = _e_type(node.values)\n        # If either key_type or value_type is empty, fallback to Dict\n        if not key_type or not value_type:\n            return \"Dict\"\n        return f\"Dict[{key_type[1:-1]}, {value_type[1:-1]}]\"  # Strip brackets from key_type and value_type to format Dict properly\n\n    # Fallback: if unknown expression, return empty string\n    return \"\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 646, in <module>\n  File \"<string>\", line 645, in test_0\nAssertionError\n", "passed": false}
{"task_id": 240, "prediction_id": 1, "generation": "from ast import Constant, expr\nfrom typing import Sequence, Optional\nfrom apimd.parser import _type_name, _e_type\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (List, Tuple, Set)):\n        # Extract elements for type checking\n        elements = node.elts  # type: ignore\n        # Use _e_type to infer the type string of the elements\n        return _e_type(elements)\n    elif isinstance(node, Dict):\n        # For dictionaries, infer key and value types\n        keys, values = node.keys, node.values  # type: ignore\n        key_type = _e_type(keys)\n        value_type = _e_type(values)\n        if key_type and value_type:\n            return f\"Dict{key_type[:-1]}, {value_type[1:]}\"\n        else:\n            return \"\"\n    else:\n        return \"\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 640, in <module>\n  File \"<string>\", line 639, in test_0\nAssertionError\n", "passed": false}
{"task_id": 240, "prediction_id": 2, "generation": "from ast import expr, Constant\nfrom typing import Sequence, Optional\nfrom apimd.parser import _type_name, _e_type\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    # Handle collections of constants: list, tuple, set, dict\n    # For containers, we inspect their elements and provide a composite type annotation.\n\n    # List or Tuple: elements are stored in 'elts' attribute\n    if hasattr(node, 'elts') and isinstance(node.elts, Sequence):\n        # node.elts is a sequence of elements (expr)\n        return _e_type(node.elts)\n\n    # Set: same as list and tuple, uses 'elts' attribute\n    if hasattr(node, 'elts') and isinstance(node.elts, Sequence):\n        return _e_type(node.elts)\n\n    # Dict: keys in node.keys, values in node.values\n    if hasattr(node, 'keys') and hasattr(node, 'values'):\n        key_type = _e_type(node.keys) if node.keys else \"\"\n        val_type = _e_type(node.values) if node.values else \"\"\n        if key_type and val_type:\n            return f\"Dict{key_type[:-1]}, {val_type[1:]}\"  # Remove trailing ']' and prepend '[' accordingly\n        elif key_type:\n            return f\"Dict{key_type}, Any\"\n        elif val_type:\n            return f\"Dict[Any, {val_type[1:]}\"\n        else:\n            return \"Dict[Any, Any]\"\n\n    # For all other cases where node is not constant or unknown structure\n    return \"\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 652, in <module>\n  File \"<string>\", line 651, in test_0\nAssertionError\n", "passed": false}
{"task_id": 240, "prediction_id": 3, "generation": "from typing import cast\nfrom ast import expr, Constant\nfrom apimd.parser import _type_name, _e_type\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    # If it's a Constant node, return the type name of its value\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n\n    # For tuple, list, set, dict nodes, infer element types if all elements are Constant\n    if hasattr(node, \"elts\"):\n        elts = cast(list[expr], getattr(node, \"elts\"))\n        return _e_type(elts)\n\n    if hasattr(node, \"keys\") and hasattr(node, \"values\"):\n        keys = cast(list[expr], getattr(node, \"keys\"))\n        values = cast(list[expr], getattr(node, \"values\"))\n        # Both keys and values should be constants sequences to get their types\n        return f\"dict{_e_type(keys, values)}\"\n\n    # For anything else, return an empty string\n    return \"\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 640, in <module>\n  File \"<string>\", line 639, in test_0\nAssertionError\n", "passed": false}
{"task_id": 240, "prediction_id": 4, "generation": "from ast import expr, Constant, Tuple, List, Set, Dict\nfrom typing import Sequence, Optional\nfrom apimd.parser import _type_name, _e_type\n\n\ndef const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, Tuple):\n        return \"Tuple\" + _e_type(node.elts)\n    elif isinstance(node, List):\n        return \"List\" + _e_type(node.elts)\n    elif isinstance(node, Set):\n        return \"Set\" + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        # For Dict, check types of keys and values separately\n        key_type = _e_type(node.keys)\n        value_type = _e_type(node.values)\n        if key_type and value_type:\n            return f\"Dict{key_type, value_type}\"\n        else:\n            return \"Dict\"\n    else:\n        return \"\"", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 641, in <module>\n  File \"<string>\", line 640, in test_0\nAssertionError\n", "passed": false}
