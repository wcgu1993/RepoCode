{"task_id": 331, "prediction_id": 0, "generation": "import typing\n\nfrom typesystem.fields import (\n    Array,\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Field,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n)\nfrom typesystem.schemas import SchemaDefinitions\nfrom typesystem.json_schema import from_json_schema\nfrom typesystem.json_schema import get_valid_types\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    # Get valid type strings and allow_null flag from the data\n    type_strings, allow_null = get_valid_types(data)\n\n    # If no type is specified (empty type_strings), default to Any (handled as no constraints)\n    if not type_strings:\n        # Defensive fallback in case get_valid_types returns empty set unexpectedly\n        from typesystem.fields import Any\n        return Any()\n\n    # If exactly one type string, build a single typed field\n    if len(type_strings) == 1:\n        type_string = next(iter(type_strings))\n        # Use from_json_schema_type to build the field for this type_string\n        from typesystem.json_schema import from_json_schema_type\n\n        # Build field with allow_null\n        field = from_json_schema_type(data, type_string, allow_null, definitions)\n        return field\n\n    # If multiple types, build a Choice field where choices are the allowed types as strings\n    # According to JSON Schema, multiple types means value can be any of those types\n    # We represent this as a Choice of type names (strings).\n    # However, more correct approach is to build a Union of fields for each type, but this function\n    # is responsible for building a typed field or union of typed fields, so Choice fits cases with enum of strings.\n    # Since the function doc is to \"Build a typed field or union of typed fields\", and multiple types is union,\n    # However, from the code context, it is better to build a Union of from_json_schema_type for each type.\n\n    # So we build a list of fields, one for each type in type_strings\n    from typesystem.fields import Union\n\n    fields = []\n    from typesystem.json_schema import from_json_schema_type\n\n    for type_string in sorted(type_strings):\n        f = from_json_schema_type(data, type_string, allow_null, definitions)\n        fields.append(f)\n\n    # If allow_null is True, then each field must allow_null=True; fields are constructed that way already.\n\n    # If only one field after all (should not happen here), return it directly\n    if len(fields) == 1:\n        return fields[0]\n\n    # Otherwise, return a Union of all fields\n    return Union(any_of=fields, default=data.get(\"default\"))  # default may be None or NO_DEFAULT", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 923, in <module>\n  File \"<string>\", line 922, in test_120\nAssertionError\n", "passed": false}
{"task_id": 331, "prediction_id": 1, "generation": "from typesystem.fields import Any, Array, Boolean, Integer, Number, Object, String, Float, Choice, Const, Union\nfrom typesystem.fields import Field\nfrom typesystem.schemas import SchemaDefinitions\nfrom typesystem.json_schema import from_json_schema, from_json_schema_type\nfrom typesystem.schemas import Reference\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    # Determine valid JSON schema types and if null is allowed\n    from typesystem.json_schema import get_valid_types\n\n    valid_types, allow_null = get_valid_types(data)\n\n    # If no types explicitly specified (empty set), allow all types with null handling\n    if not valid_types:\n        return Any(allow_null=allow_null, default=data.get(\"default\", NO_DEFAULT))\n\n    # If only one type is specified, return the corresponding typed field\n    if len(valid_types) == 1:\n        type_string = next(iter(valid_types))\n        return from_json_schema_type(data, type_string, allow_null, definitions)\n\n    # More than one type - build a Choice (union of types)\n    fields = []\n    for type_string in sorted(valid_types):\n        field = from_json_schema_type(data, type_string, allow_null=False, definitions=definitions)\n        fields.append(field)\n\n    # If allow_null is True, add an Any() that only allows null (i.e., None)\n    # But typically nullable is handled by allow_null=True in fields\n    # Here instead, we can create a Union of the fields allowing null for each,\n    # but since from_json_schema_type fields already have allow_null=False,\n    # we need to handle null allowance separately.\n\n    # One approach is to create a Choice that allows null as a valid option:\n    # We'll create a Choice with the fields plus a field allowing None (Any with allow_null True).\n    # But typesystem does not have a dedicated NoneType field.\n    # So best to add a custom Field allowing None only:\n    # Use Choice with allow_null handled by allowing None in the choices?\n\n    # However, generally in typesystem, allow_null on fields is used for nullability,\n    # so here we create Choice with each field having allow_null=False and also add None if needed.\n    # Better: create Union of these fields with allow_null=True on individual fields if needed.\n\n    # So here to reflect allow_null, set allow_null=True on each field\n    fields_with_null = []\n    for type_string in sorted(valid_types):\n        field = from_json_schema_type(data, type_string, allow_null=allow_null, definitions=definitions)\n        fields_with_null.append(field)\n\n    # If only one field with allow_null (already covered above), but here multiple:\n    # use Choice with these fields as choices\n    choices_values = []\n    for field in fields_with_null:\n        # If field is Choice itself, flatten its choices\n        if isinstance(field, Choice):\n            choices_values.extend(choice[0] for choice in field.choices)\n        else:\n            choices_values.append(field)\n\n    # But field.choices are tuples with (value, label) or (key, value)? The Choice from context expects tuples of (key, label)\n    # Wait, we built fields, not literal choice strings\n    # Actually, JSON schema \"type\" can only be simple types (\"string\", \"number\", etc),\n    # so the fields represent typed validators not choice strings.\n\n    # This means a Choice is not appropriate, but \"Union\" is better suited.\n\n    # The 'Union' field from typesystem.fields represents a union of multiple field validators.\n\n    from typesystem.fields import Union\n\n    return Union(any_of=fields_with_null, default=data.get(\"default\", NO_DEFAULT))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 929, in <module>\n  File \"<string>\", line 928, in test_120\nAssertionError\n", "passed": false}
{"task_id": 331, "prediction_id": 2, "generation": "import typing\n\nfrom typesystem.fields import Field, AllOf, Union, NeverMatch, Any\nfrom typesystem.schemas import SchemaDefinitions\nfrom typesystem.json_schema import get_valid_types, from_json_schema_type\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    # Extract valid type strings and whether null is allowed\n    type_strings, allow_null = get_valid_types(data)\n\n    # If \"boolean_schema\" is True, it means the schema is bool rather than dict.\n    # (But here data is dict since we get type_from_json_schema called only in that case.)\n\n    if not type_strings:\n        # No types specified -> Any (with allow_null if true)\n        # But JSON Schema expects something, default to Any allowing null if allowed.\n        return Any(allow_null=allow_null, default=data.get(\"default\", None))\n\n    fields: typing.List[Field] = []\n\n    # For each type string, build the corresponding Field using from_json_schema_type\n    for type_string in sorted(type_strings):\n        field = from_json_schema_type(data, type_string, allow_null, definitions)\n        fields.append(field)\n\n    # Compose the result:\n    if len(fields) == 1:\n        return fields[0]\n    else:\n        # Multiple types - Union of the fields\n        return Union(union=fields, allow_null=allow_null, default=data.get(\"default\", None))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 173, in <module>\nImportError: cannot import name 'AllOf' from 'typesystem.fields' (/input/test-apps/typesystem/typesystem/fields.py)\n", "passed": false}
{"task_id": 331, "prediction_id": 3, "generation": "import typing\n\nfrom typesystem.fields import (\n    Boolean,\n    Choice,\n    Const,\n    Decimal,\n    Float,\n    Integer,\n    Number,\n    Object,\n    String,\n    Array,\n)\nfrom typesystem.schemas import SchemaDefinitions\n\nfrom typesystem.json_schema import from_json_schema, from_json_schema_type, get_valid_types\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> typing.Optional[typing.Union[Boolean, Choice, Const, Decimal, Float, Integer, Number, Object, String, Array]]:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = get_valid_types(data)\n\n    # If no types specified, or only allow_null is True with no other types, return Any()\n    # But since Any() is not imported here and never directly used in this function,\n    # we'll just proceed if type_strings is empty with a fallback.\n    if not type_strings:\n        # fallback, no types given means accept any type => Any()\n        # But Any() isn't imported here, so fallback to from_json_schema\n        # But from_json_schema might call this recursively, so best to return Any()\n        # Since Any is imported in the file, let's import it here just in case.\n        from typesystem.fields import Any\n\n        return Any(allow_null=allow_null, default=data.get(\"default\"))\n\n    # For a single type, just build and return that type's Field\n    if len(type_strings) == 1:\n        type_string = next(iter(type_strings))\n        return from_json_schema_type(data, type_string, allow_null, definitions)\n\n    # For multiple types, create a Choice field enumerating the possible types as strings\n    # except that \"null\" type was removed from type_strings already\n    # Choice requires the valid choices, here we use the strings of types as choices.\n\n    # Special case: if \"integer\" and \"number\" are both specified, per get_valid_types\n    # \"number\" removes \"integer\" from the set, so no overlap for that.\n\n    # So the remaining type_strings e.g. {'string', 'boolean', 'object'}\n\n    # The Choice field expects a list of choices; we provide the type strings directly.\n\n    # The JSON Schema 'type' that is array means \"any of these types\", thus Choice may make sense.\n\n    # Provide default if present in data, else NO_DEFAULT\n    from typesystem.fields import Choice\n    from typesystem.fields import NO_DEFAULT\n\n    default = data.get(\"default\", NO_DEFAULT)\n\n    return Choice(choices=sorted(type_strings), allow_null=allow_null, default=default)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 665, in <module>\n  File \"<string>\", line 659, in test_12\nAssertionError\n", "passed": false}
{"task_id": 331, "prediction_id": 4, "generation": "import typing\nfrom typesystem.fields import Field, Union, Any\nfrom typesystem.schemas import SchemaDefinitions\nfrom typesystem.json_schema import from_json_schema_type\n\n\ndef type_from_json_schema(data: dict, definitions: SchemaDefinitions) -> Field:\n    \"\"\"\n    Build a typed field or union of typed fields from a JSON schema object.\n    \"\"\"\n    type_strings, allow_null = data.get(\"type\", []), False\n    if isinstance(type_strings, str):\n        type_strings = {type_strings}\n    else:\n        type_strings = set(type_strings)\n\n    if not type_strings:\n        type_strings = {\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"}\n\n    if \"number\" in type_strings:\n        type_strings.discard(\"integer\")\n\n    if \"null\" in type_strings:\n        allow_null = True\n        type_strings.remove(\"null\")\n\n    if len(type_strings) == 0:\n        # Only null was in the original type\n        if allow_null:\n            return Any(allow_null=True, default=data.get(\"default\", None))\n        else:\n            return Any(default=data.get(\"default\", None))\n\n    # Build fields for each type and combine if multiple\n    fields = [\n        from_json_schema_type(data, type_string, allow_null, definitions)\n        for type_string in sorted(type_strings)\n    ]\n\n    if len(fields) == 1:\n        return fields[0]\n    else:\n        # Wrap with Union, allow_null is handled by each type's field\n        return Union(union=fields, default=data.get(\"default\", None))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 647, in <module>\n  File \"<string>\", line 642, in test_12\n  File \"<string>\", line 214, in type_from_json_schema\nTypeError: Union.__init__() missing 1 required positional argument: 'any_of'\n", "passed": false}
