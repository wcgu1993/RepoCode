{"task_id": 123, "prediction_id": 0, "generation": "from typing import Iterable\nfrom colorama import Fore, Style\nfrom .exceptions import CompilationError\nfrom .messages import _format_line\n\n\ndef _get_lines_with_highlighted_error(e: CompilationError) -> Iterable[str]:\n    \"\"\"Format code with highlighted syntax error.\"\"\"\n    # Extract code and error position information from the exception\n    code = e.code\n    lineno = e.lineno  # 1-based line number of error\n    col_offset = e.col_offset  # 0-based column offset of error\n\n    lines = code.splitlines()\n    padding = len(str(len(lines)))\n\n    # Yield all lines formatted with line numbers\n    for i, line in enumerate(lines):\n        if i == lineno - 1:\n            # Highlight the error line\n            yield _format_line(line, i, padding)\n            # Highlight the error column with a caret (^) in red\n            # Compose a pointer line with spaces up to col_offset, then the caret\n            pointer = \" \" * (col_offset + padding + 4) + Fore.RED + \"^\" + Style.RESET_ALL\n            yield pointer\n        else:\n            yield _format_line(line, i, padding)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 39, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 123, "prediction_id": 1, "generation": "from typing import Iterable\nfrom colorama import Fore, Style\nfrom .exceptions import CompilationError\nfrom .messages import _format_line\n\n\ndef _get_lines_with_highlighted_error(e: CompilationError) -> Iterable[str]:\n    \"\"\"Format code with highlighted syntax error.\"\"\"\n    # Extract the source code lines from the CompilationError\n    # It is expected that e.source contains the code as a string\n    # and e.lineno and e.offset mark the line and column of the error.\n    # Highlight the error character in red with bright style.\n\n    source = e.source\n    lineno = e.lineno\n    offset = e.offset\n\n    # Defensive checks and adjustments\n    if source is None:\n        # If no source is provided, yield empty or fallback\n        yield f\"{Fore.RED}{Style.BRIGHT}No source code available to highlight error.{Style.RESET_ALL}\"\n        return\n\n    lines = source.splitlines()\n\n    # Determine padding based on total lines for line number width\n    padding = len(str(len(lines)))\n\n    # Prepare highlighted lines: show the line with the error plus maybe one line before and after if applicable\n    start_line = max(lineno - 2, 0)\n    end_line = min(lineno, len(lines))\n\n    for i in range(start_line, end_line):\n        line = lines[i]\n\n        if i == lineno - 1:\n            # Highlight the error character in the line if offset is valid\n            if offset is not None and 0 <= offset - 1 < len(line):\n                # Split line into before, error char, after\n                before = line[:offset - 1]\n                error_char = line[offset - 1]\n                after = line[offset:]\n                highlighted_line = before + Fore.RED + Style.BRIGHT + error_char + Style.RESET_ALL + after\n            else:\n                # No valid offset, print line as is\n                highlighted_line = line\n            yield _format_line(highlighted_line, i, padding)\n        else:\n            # Normal line without highlight\n            yield _format_line(line, i, padding)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 39, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 123, "prediction_id": 2, "generation": "from typing import Iterable\nfrom colorama import Fore, Style\nfrom .exceptions import CompilationError\nfrom .messages import _format_line\n\n\ndef _get_lines_with_highlighted_error(e: CompilationError) -> Iterable[str]:\n    \"\"\"Format code with highlighted syntax error.\"\"\"\n    # Extract relevant information from the CompilationError\n    # Expected to have: e.source (code as string),\n    # e.lineno (1-based line number of error),\n    # e.offset (1-based column number of error within the line)\n    # If any attribute missing, just fallback gracefully.\n\n    source = getattr(e, \"source\", None)\n    lineno = getattr(e, \"lineno\", None)\n    offset = getattr(e, \"offset\", None)\n\n    if not source or lineno is None or offset is None:\n        # Cannot highlight without source and position info,\n        # fallback returning just the error message\n        yield str(e)\n        return\n\n    # Split source code into lines\n    lines = source.splitlines()\n\n    # Calculate padding width for line numbers\n    padding = len(str(len(lines)))\n\n    # Determine lines to show: usually show error line and one line before and after if available\n    start = max(0, lineno - 2)\n    end = min(len(lines), lineno + 1)\n\n    # Format lines before the error line\n    for i in range(start, end):\n        line = lines[i]\n        # Highlight the error line specially, others normal\n        if i == lineno - 1:\n            # We'll highlight the character at offset-1 with red and bright\n            # Since offset is 1-based column number, convert to 0-based\n            col = offset - 1\n            if 0 <= col < len(line):\n                # Insert highlight around the error character\n                highlighted = (\n                    line[:col]\n                    + Fore.RED + Style.BRIGHT + line[col] + Style.RESET_ALL\n                    + line[col + 1:]\n                )\n            else:\n                # If offset invalid, do not highlight character\n                highlighted = line\n            yield _format_line(highlighted, i, padding)\n            # Add an indicator line under the error character\n            indicator = \" \" * col + Fore.RED + Style.BRIGHT + \"^\" + Style.RESET_ALL\n            yield \"   \" + indicator\n        else:\n            # Other lines, just format normally\n            yield _format_line(lines[i], i, padding)", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 39, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 123, "prediction_id": 3, "generation": "from typing import Iterable\nfrom colorama import Fore, Style\nfrom .exceptions import CompilationError\nfrom .messages import _format_line\n\n\ndef _get_lines_with_highlighted_error(e: CompilationError) -> Iterable[str]:\n    \"\"\"Format code with highlighted syntax error.\"\"\"\n    # Get the source lines where the error occurred\n    lines = e.lines\n    # Get the error line and column (0-based internally)\n    error_line_idx = e.line - 1 if e.line and e.line > 0 else None\n    error_col_idx = e.col - 1 if e.col and e.col > 0 else None\n\n    if not lines or error_line_idx is None or error_line_idx >= len(lines):\n        # If no lines or error line info, yield no lines\n        return\n\n    # Calculate padding width for line numbers\n    padding = len(str(len(lines)))\n\n    for i, line in enumerate(lines):\n        # Format the code line normally\n        formatted_line = _format_line(line, i, padding)\n        # If this is the error line, highlight the error column\n        if i == error_line_idx and error_col_idx is not None and 0 <= error_col_idx < len(line):\n            # We insert highlighting at the error column\n            # Build highlighted line with error character highlighted in red + bold\n            prefix = line[:error_col_idx]\n            error_char = line[error_col_idx]\n            suffix = line[error_col_idx + 1 :]\n            highlighted_line = (\n                prefix\n                + Fore.RED\n                + Style.BRIGHT\n                + error_char\n                + Style.RESET_ALL\n                + suffix\n            )\n            # Format this highlighted line\n            formatted_line = _format_line(highlighted_line, i, padding)\n\n        yield formatted_line", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 39, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 123, "prediction_id": 4, "generation": "from typing import Iterable\nfrom colorama import Fore, Style\nfrom .exceptions import CompilationError\nfrom .messages import _format_line\n\n\ndef _get_lines_with_highlighted_error(e: CompilationError) -> Iterable[str]:\n    \"\"\"Format code with highlighted syntax error.\"\"\"\n    # Extract code lines from the exception\n    if not e.code:\n        # No code available, return empty list\n        return []\n\n    lines = e.code.splitlines()\n    error_lineno = e.lineno - 1 if e.lineno else None  # zero-based index\n    \n    # Determine padding for line numbers\n    padding = len(str(len(lines)))\n    \n    for i, line in enumerate(lines):\n        # Format each line with dim style line number\n        formatted = _format_line(line, i, padding)\n        if i == error_lineno:\n            # Highlight the error line with bright red foreground\n            yield Fore.RED + Style.BRIGHT + formatted + Style.RESET_ALL\n        else:\n            yield formatted", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 39, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
