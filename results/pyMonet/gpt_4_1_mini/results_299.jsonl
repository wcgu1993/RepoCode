{"task_id": 299, "prediction_id": 0, "generation": "from typing import Callable, Any, List, Tuple\n\ndef memoize(fn: Callable, key=eq) -> Callable:\n    \"\"\"\n    Create a new function that, when invoked,\n    caches the result of calling fn for a given argument set and returns the result.\n    Subsequent calls to the memoized fn with the same argument set will not result in an additional call to fn;\n    instead, the cached result for that set of arguments will be returned.\n\n    :param fn: function to invoke\n    :type fn: Function(A) -> B\n    :param key: function to decide if result should be taken from cache\n    :type key: Function(A, A) -> Boolean\n    :returns: new function invoking old one\n    :rtype: Function(A) -> B\n    \"\"\"\n    cache: List[Tuple[Any, Any]] = []\n\n    def memoized_fn(*args):\n        # Search in cache for matching keys using the provided key function\n        for cached_args, cached_result in cache:\n            # cached_args is a tuple of arguments; check length to avoid mismatch\n            if len(cached_args) == len(args) and all(key(a, b) for a, b in zip(cached_args, args)):\n                return cached_result\n        # If not found, call the original function and cache the result\n        result = fn(*args)\n        cache.append((args, result))\n        return result\n\n    return memoized_fn", "message": "passed", "passed": true}
{"task_id": 299, "prediction_id": 1, "generation": "from typing import Callable, Any, List, Tuple\n\n\ndef memoize(fn: Callable, key=eq) -> Callable:\n    \"\"\"\n    Create a new function that, when invoked,\n    caches the result of calling fn for a given argument set and returns the result.\n    Subsequent calls to the memoized fn with the same argument set will not result in an additional call to fn;\n    instead, the cached result for that set of arguments will be returned.\n\n    :param fn: function to invoke\n    :type fn: Function(A) -> B\n    :param key: function to decide if result should be taken from cache\n    :type key: Function(A, A) -> Boolean\n    :returns: new function invoking old one\n    :rtype: Function(A) -> B\n    \"\"\"\n    cache: List[Tuple[Any, Any]] = []\n\n    def memoized(*args):\n        # Attempt to find cached result for args using the key function\n        for cached_args, cached_result in cache:\n            if len(cached_args) == len(args):\n                # Compare argument by argument using the key comparator\n                if all(key(arg, cached_arg) for arg, cached_arg in zip(args, cached_args)):\n                    return cached_result\n\n        # If not found, call fn, cache, and return result\n        result = fn(*args)\n        cache.append((args, result))\n        return result\n\n    return memoized", "message": "passed", "passed": true}
{"task_id": 299, "prediction_id": 2, "generation": "from typing import Callable, Any, List, Tuple\n\ndef memoize(fn: Callable, key=eq) -> Callable:\n    \"\"\"\n    Create a new function that, when invoked,\n    caches the result of calling fn for a given argument set and returns the result.\n    Subsequent calls to the memoized fn with the same argument set will not result in an additional call to fn;\n    instead, the cached result for that set of arguments will be returned.\n\n    :param fn: function to invoke\n    :type fn: Function(A) -> B\n    :param key: function to decide if result should be taken from cache\n    :type key: Function(A, A) -> Boolean\n    :returns: new function invoking old one\n    :rtype: Function(A) -> B\n    \"\"\"\n\n    cache: List[Tuple[Any, Any]] = []\n\n    def memoized(*args):\n        # Find cached value by comparing arguments using the key function\n        for cached_args, result in cache:\n            # Check if cached args and current args have the same length and all args match by key\n            if len(cached_args) == len(args) and all(key(ca, a) for ca, a in zip(cached_args, args)):\n                return result\n\n        # Not found in cache, call the original function and cache the result\n        result = fn(*args)\n        cache.append((args, result))\n        return result\n\n    return memoized", "message": "passed", "passed": true}
{"task_id": 299, "prediction_id": 3, "generation": "from typing import Callable, Any, List, Tuple\n\n\ndef memoize(fn: Callable, key=eq) -> Callable:\n    \"\"\"\n    Create a new function that, when invoked,\n    caches the result of calling fn for a given argument set and returns the result.\n    Subsequent calls to the memoized fn with the same argument set will not result in an additional call to fn;\n    instead, the cached result for that set of arguments will be returned.\n\n    :param fn: function to invoke\n    :type fn: Function(A) -> B\n    :param key: function to decide if result should be taken from cache\n    :type key: Function(A, A) -> Boolean\n    :returns: new function invoking old one\n    :rtype: Function(A) -> B\n    \"\"\"\n\n    cache: List[Tuple[Tuple[Any, ...], Any]] = []\n\n    def memoized_fn(*args):\n        # Search in cache for a matching args tuple using key function\n        for cached_args, cached_result in cache:\n            # Only compare if length matches to avoid mismatch\n            if len(cached_args) == len(args) and all(key(a, b) for a, b in zip(cached_args, args)):\n                return cached_result\n\n        # If not found, compute and cache result\n        result = fn(*args)\n        cache.append((args, result))\n        return result\n\n    return memoized_fn", "message": "passed", "passed": true}
{"task_id": 299, "prediction_id": 4, "generation": "from typing import Callable, Any, List, Tuple\n\n\ndef memoize(fn: Callable, key=eq) -> Callable:\n    \"\"\"\n    Create a new function that, when invoked,\n    caches the result of calling fn for a given argument set and returns the result.\n    Subsequent calls to the memoized fn with the same argument set will not result in an additional call to fn;\n    instead, the cached result for that set of arguments will be returned.\n\n    :param fn: function to invoke\n    :type fn: Function(A) -> B\n    :param key: function to decide if result should be taken from cache\n    :type key: Function(A, A) -> Boolean\n    :returns: new function invoking old one\n    :rtype: Function(A) -> B\n    \"\"\"\n    cache: List[Tuple[Tuple[Any, ...], Any]] = []\n\n    def memoized(*args):\n        # Find in cache an entry with matching args using the key function\n        for cached_args, cached_result in cache:\n            if len(cached_args) == len(args) and all(key(ca, a) for ca, a in zip(cached_args, args)):\n                return cached_result\n\n        # Not found in cache; compute and store result\n        result = fn(*args)\n        cache.append((args, result))\n        return result\n\n    return memoized", "message": "passed", "passed": true}
