{"task_id": 159, "prediction_id": 0, "generation": "import typing\nimport re\n\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../yeee'),\n    ('THISIS', '.../a/test'),\n    ('YOLO',\n    '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n\n    \"\"\"\n    if lines is None:\n        return\n\n    # Regex to parse lines like KEY=VALUE, skipping comments/empty lines\n    env_var_re = re.compile(\n        r'^\\s*'                 # Optional leading whitespace\n        r'([A-Za-z_][A-Za-z0-9_]*)'  # Key: variable name (similar to shell var rules)\n        r'\\s*=\\s*'              # Equals sign surrounded by optional whitespace\n        r'(.*)$'                # Value as the rest of the line (can be empty)\n    )\n\n    for line in lines:\n        line = line.strip()\n        if not line or line.startswith('#'):\n            # Ignore empty lines and comments\n            continue\n\n        match = env_var_re.match(line)\n        if not match:\n            # Line doesn't comply, skip it\n            continue\n        \n        key, value = match.group(1), match.group(2)\n\n        # Remove optional surrounding quotes from value (single or double)\n        if (value.startswith('\"') and value.endswith('\"')) or (value.startswith(\"'\") and value.endswith(\"'\")):\n            value = value[1:-1]\n\n        # Yield the (key, value) pair as is, no expansion here (expansion happens in load_env_file)\n        yield key, value", "message": "passed", "passed": true}
{"task_id": 159, "prediction_id": 1, "generation": "import typing\nimport re\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../yeee'),\n    ('THISIS', '.../a/test'),\n    ('YOLO',\n    '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n\n    \"\"\"\n\n    if lines is None:\n        return\n    # Pattern to parse lines like: KEY=VALUE, where VALUE can be quoted or unquoted\n    env_var_re = re.compile(\n        r\"\"\"\n        ^\\s*\n        ([\\w\\.]+)                    # key: word chars or dots\n        \\s*=\\s*\n        (?:                         # non-capturing group for value\n          '([^']*)'                 # single-quoted value (no escapes handled)\n          |                         # or\n          \"((?:[^\"\\\\]|\\\\.)*)\"       # double-quoted value, allowing escaped chars\n          |                         # or\n          ([^\\#\\n\\r]+?)             # unquoted value (stop at # or end)\n        )\n        \\s*(?:\\#.*)?$               # optional comment after value\n        \"\"\",\n        re.VERBOSE,\n    )\n\n    for line in lines:\n        line = line.strip()\n        if not line or line.startswith(\"#\"):\n            continue\n\n        m = env_var_re.match(line)\n        if not m:\n            # line doesn't match expected pattern, ignore it\n            continue\n\n        key = m.group(1)\n\n        if m.group(2) is not None:\n            # single quoted\n            val = m.group(2)\n        elif m.group(3) is not None:\n            # double quoted - need to handle escapes\n            val = m.group(3)\n            # unescape \\n, \\r, \\t, \\\\, \\\", \\', \\$\n            escaped_val = \"\"\n            i = 0\n            while i < len(val):\n                c = val[i]\n                if c == \"\\\\\" and i+1 < len(val):\n                    next_c = val[i+1]\n                    if next_c == \"n\":\n                        escaped_val += \"\\n\"\n                    elif next_c == \"r\":\n                        escaped_val += \"\\r\"\n                    elif next_c == \"t\":\n                        escaped_val += \"\\t\"\n                    elif next_c == \"\\\\\":\n                        escaped_val += \"\\\\\"\n                    elif next_c == \"\\\"\":\n                        escaped_val += \"\\\"\"\n                    elif next_c == \"$\":\n                        escaped_val += \"$\"\n                    else:\n                        # unknown escape, keep as-is (e.g. \\x)\n                        escaped_val += next_c\n                    i += 2\n                else:\n                    escaped_val += c\n                    i += 1\n            val = escaped_val\n        else:\n            # unquoted value - strip trailing spaces\n            val = m.group(4)\n            if val is not None:\n                val = val.strip()\n            else:\n                val = \"\"\n\n        yield key, val", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 186, in <module>\n  File \"<string>\", line 185, in test_5\nAssertionError\n", "passed": false}
{"task_id": 159, "prediction_id": 2, "generation": "import typing\nimport re\n\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../yeee'),\n    ('THISIS', '.../a/test'),\n    ('YOLO',\n    '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n\n    \"\"\"\n    if lines is None:\n        return\n    env_var_pattern = re.compile(\n        r'^\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*='  # key (variable name) = \n        r'(.*)$'                              # value (anything after equals)\n    )\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        if line.startswith('#'):\n            continue\n\n        m = env_var_pattern.match(line)\n        if not m:\n            continue\n        key = m.group(1)\n        val = m.group(2).strip()\n\n        # Remove surrounding quotes if present (single or double)\n        if (val.startswith('\"') and val.endswith('\"')) or (val.startswith(\"'\") and val.endswith(\"'\")):\n            val = val[1:-1]\n\n        yield key, val", "message": "passed", "passed": true}
{"task_id": 159, "prediction_id": 3, "generation": "import typing\nimport re\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../yeee'),\n    ('THISIS', '.../a/test'),\n    ('YOLO',\n    '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n\n    \"\"\"\n    # Pattern to parse lines like: KEY=VALUE or export KEY=VALUE, allowing spaces around equal sign\n    # We capture KEY and VALUE; comments and empty lines are ignored.\n    env_pattern = re.compile(\n        r'''\n        ^\\s*                           # Leading whitespace\n        (?:export\\s+)?                 # Optional export keyword\n        (?P<key>[A-Za-z_][A-Za-z0-9_]*) # Key: starts with letter/_ followed by alphanum/_\n        \\s*=\\s*                       # Equal sign with optional spaces\n        (?P<value>.*)                 # Value: rest of the line (including empty)\n        $                             # End of line\n        ''',\n        re.VERBOSE\n    )\n\n    if lines is None:\n        return\n        yield  # make this a generator even if empty\n\n    for lineno, line in enumerate(lines, 1):\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue  # Skip empty lines and comments\n\n        m = env_pattern.match(line)\n        if not m:\n            continue  # Skip lines that do not match KEY=VALUE pattern\n\n        key = m.group('key')\n        val = m.group('value')\n\n        # Remove surrounding quotes if any (single or double)\n        if (val.startswith('\"') and val.endswith('\"')) or (val.startswith(\"'\") and val.endswith(\"'\")):\n            val = val[1:-1]\n\n        yield key, val", "message": "passed", "passed": true}
{"task_id": 159, "prediction_id": 4, "generation": "import typing\nimport re\n\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../yeee'),\n    ('THISIS', '.../a/test'),\n    ('YOLO',\n    '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n\n    \"\"\"\n    if lines is None:\n        return\n    pattern = re.compile(\n        r'''^\\s*              # Optional leading whitespace\n            (?:export\\s+)?    # Optional 'export ' prefix\n            ([\\w\\.]+)         # Key: word characters or dot\n            \\s*=\\s*           # Equal sign with optional spaces around\n            (.*?)             # Value: non-greedy, anything\n            \\s*$              # Optional trailing whitespace till end of line\n        ''',\n        re.VERBOSE,\n    )\n\n    for line in lines:\n        # Remove any leading/trailing whitespace\n        line = line.strip()\n        # Ignore empty lines or comments\n        if not line or line.startswith('#'):\n            continue\n\n        match = pattern.match(line)\n        if not match:\n            continue\n        key, value = match.groups()\n\n        # Handle quotes around the value\n        if (value.startswith('\"') and value.endswith('\"')) or (value.startswith(\"'\") and value.endswith(\"'\")):\n            # Remove the surrounding quotes\n            value = value[1:-1]\n\n            # For double quotes, interpret escape sequences (like \\n, \\t, \\\", \\$, etc)\n            if value and value != '' and line.strip().startswith('export'):\n                # To better handle escape sequences only for double quotes and not for single quotes\n                # But as per usual behavior, only double quotes allow escape sequences\n                # We'll only replace escaped \\$ and \\\" properly.\n\n                # In .env files, usually only \\$, \\\" and \\\\ are escaped inside double quotes\n                # We can use python's decode string escape by encoding to latin1 and decoding unicode_escape\n                try:\n                    value = bytes(value, \"utf-8\").decode(\"unicode_escape\")\n                except Exception:\n                    # Fallback if decoding fails, just keep raw string\n                    pass\n\n        yield key, value", "message": "passed", "passed": true}
