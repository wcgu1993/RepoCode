{"task_id": 160, "prediction_id": 0, "generation": "import six\nimport warnings\n\ntry:\n    import pygments\n    import pygments.styles\n    import pygments.formatters\n    import pygments.lexers\n\n    __PP_STYLE = pygments.styles.get_style_by_name('monokai')\n    __PP_FORMATTER = pygments.formatters.get_formatter_by_name('console16m', style=__PP_STYLE)\n    __PP_LEXER_PYTHON = pygments.lexers.get_lexer_by_name('python{}'.format(six.PY3 and '3' or ''))\n\nexcept ImportError:\n    warnings.warn('Could not import `pygments`. Disabling syntax highlighting I guess.')\n    pygments = False\n\n\ndef pf(arg, lexer=__PP_LEXER_PYTHON, formatter=__PP_FORMATTER):\n    \"\"\"\n    Pretty formats with coloring.\n\n    Works in iPython, but not bpython as it does not write directly to term\n    and decodes it instead.\n    \"\"\"\n    import pprint\n\n    # Convert arg to formatted string using pprint\n    formatted = pprint.pformat(arg)\n\n    # If pygments is available, highlight the formatted string\n    if pygments:\n        try:\n            # pygments.highlight returns bytes when using console16m formatter,\n            # so decode to str if necessary (Python3)\n            highlighted = pygments.highlight(formatted, lexer, formatter)\n            if isinstance(highlighted, bytes):\n                highlighted = highlighted.decode(sys.stdout.encoding or 'utf-8', 'replace')\n            return highlighted\n        except Exception:\n            # fallback: just return the formatted string without highlighting\n            return formatted\n    else:\n        return formatted", "message": "passed", "passed": true}
{"task_id": 160, "prediction_id": 1, "generation": "from pygments import highlight\nfrom pygments.token import Token\n\ndef pf(arg, lexer=__PP_LEXER_PYTHON, formatter=__PP_FORMATTER):\n    \"\"\"\n    Pretty formats with coloring.\n\n    Works in iPython, but not bpython as it does not write directly to term\n    and decodes it instead.\n    \"\"\"\n    # Use pprint.pformat to get a nicely formatted string representation of arg\n    formatted_str = _pprint.pformat(arg)\n\n    # Use pygments to highlight the formatted string with the given lexer and formatter\n    colored_str = highlight(formatted_str, lexer, formatter)\n\n    return colored_str", "message": "passed", "passed": true}
{"task_id": 160, "prediction_id": 2, "generation": "import six\nimport warnings\n\ntry:\n    import pygments\n    import pygments.styles\n    import pygments.formatters\n    import pygments.lexers\n\n    __PP_STYLE = pygments.styles.get_style_by_name('monokai')\n    __PP_FORMATTER = pygments.formatters.get_formatter_by_name('console16m', style=__PP_STYLE)\n    __PP_LEXER_PYTHON = pygments.lexers.get_lexer_by_name('python{}'.format(six.PY3 and '3' or ''))\n\nexcept ImportError:\n    warnings.warn('Could not import `pygments`. Disabling syntax highlighting I guess.')\n    pygments = False\n\n\ndef pf(arg, lexer=__PP_LEXER_PYTHON, formatter=__PP_FORMATTER):\n    \"\"\"\n    Pretty formats with coloring.\n\n    Works in iPython, but not bpython as it does not write directly to term\n    and decodes it instead.\n    \"\"\"\n    if not pygments:\n        # If pygments is not available, fallback to simple repr\n        return repr(arg)\n\n    # Import pprint here to avoid circular dependency if any, and for pretty formatting\n    import pprint\n\n    # First, pretty format the object to a string with pprint.pformat\n    formatted = pprint.pformat(arg)\n\n    # Now colorize the formatted string using pygments with the given lexer and formatter\n    colored = pygments.highlight(formatted, lexer, formatter)\n\n    return colored", "message": "passed", "passed": true}
{"task_id": 160, "prediction_id": 3, "generation": "import six\nimport warnings\n\ntry:\n    import pygments\n    import pygments.styles\n    import pygments.formatters\n    import pygments.lexers\n\n    __PP_STYLE = pygments.styles.get_style_by_name('monokai')\n    __PP_FORMATTER = pygments.formatters.get_formatter_by_name('console16m', style=__PP_STYLE)\n    __PP_LEXER_PYTHON = pygments.lexers.get_lexer_by_name('python{}'.format(six.PY3 and '3' or ''))\n\nexcept ImportError:\n    warnings.warn('Could not import `pygments`. Disabling syntax highlighting I guess.')\n    pygments = False\n\n\ndef pf(arg, lexer=__PP_LEXER_PYTHON, formatter=__PP_FORMATTER):\n    \"\"\"\n    Pretty formats with coloring.\n\n    Works in iPython, but not bpython as it does not write directly to term\n    and decodes it instead.\n    \"\"\"\n    # If pygments is not available, fallback to repr\n    if not pygments:\n        return repr(arg)\n\n    # Import pprint inside function to avoid circular import or dependency if needed\n    import pprint\n\n    # Get the pretty-printed string representation of arg, with indentation for nested structures\n    pretty_str = pprint.pformat(arg)\n\n    # Highlight the pretty printed string using pygments with given lexer and formatter\n    try:\n        colored_str = pygments.highlight(pretty_str, lexer, formatter)\n    except Exception:\n        # On any exception fallback to plain repr string\n        colored_str = pretty_str\n\n    return colored_str", "message": "passed", "passed": true}
{"task_id": 160, "prediction_id": 4, "generation": "import six\nimport warnings\n\ntry:\n    import pygments\n    import pygments.styles\n    import pygments.formatters\n    import pygments.lexers\n\n    __PP_STYLE = pygments.styles.get_style_by_name('monokai')\n    __PP_FORMATTER = pygments.formatters.get_formatter_by_name('console16m', style=__PP_STYLE)\n    __PP_LEXER_PYTHON = pygments.lexers.get_lexer_by_name('python{}'.format(six.PY3 and '3' or ''))\n\nexcept ImportError:\n    warnings.warn('Could not import `pygments`. Disabling syntax highlighting I guess.')\n    pygments = False\n\n\ndef pf(arg, lexer=__PP_LEXER_PYTHON, formatter=__PP_FORMATTER):\n    \"\"\"\n    Pretty formats with coloring.\n\n    Works in iPython, but not bpython as it does not write directly to term\n    and decodes it instead.\n    \"\"\"\n    # If pygments is not available, fallback to pprint without coloring\n    if not pygments:\n        import pprint\n        return pprint.pformat(arg)\n\n    # Import pprint for fallback formatting with indentation and line wraps\n    import pprint\n\n    # Use pprint.pformat to generate a nice string representation first\n    pretty_str = pprint.pformat(arg)\n\n    try:\n        # Use pygments to apply syntax highlighting on the pretty-printed string\n        colored = pygments.highlight(pretty_str, lexer, formatter)\n    except Exception:\n        # If something goes wrong, fallback to plain pretty string\n        return pretty_str\n\n    # colored is bytes when using formatters for terminal, decode if needed\n    if isinstance(colored, bytes):\n        try:\n            colored = colored.decode('utf-8')\n        except Exception:\n            # Fallback to fallback string in case decode fails\n            return pretty_str\n\n    return colored", "message": "passed", "passed": true}
