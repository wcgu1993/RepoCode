{"task_id": 159, "prediction_id": 0, "generation": "import typing\nimport collections\nimport os\nimport re\n\n\ndef expand(val: str) -> str:\n    val = os.path.expandvars(val)\n    val = os.path.expanduser(val)\n    return val\n\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> list(parse_env_file_contents(lines))\n    [('TEST', '.../yeee'),\n    ('THISIS', '.../a/test'),\n    ('YOLO', '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')]\n\n    \"\"\"\n    if lines is None:\n        return\n    # Pattern matches lines like KEY=VALUE or KEY='VALUE' or KEY=\"VALUE\"\n    # Ignores lines starting with # (comments) or empty lines\n    pattern = re.compile(\n        r\"\"\"\n        ^\\s*                            # leading whitespace\n        ([A-Za-z_][A-Za-z0-9_]*)       # key\n        \\s*=\\s*                        # equal sign around optional whitespace\n        (?:                            # non-capturing group for value\n          '([^']*)'                    # single quoted value (capture inside quotes)\n          |                            # OR\n          \"((?:[^\"\\\\]|\\\\.)*)\"          # double quoted value (capture inside quotes, allow escapes)\n          |                            # OR\n          ([^\\#\\n\\r]*)                 # unquoted value up to comment or line end\n        )\n        (?:\\s*\\#.*)?                   # optional comment after value\n        $\n        \"\"\",\n        re.VERBOSE,\n    )\n\n    for line in lines:\n        line = line.strip()\n        if not line or line.startswith(\"#\"):\n            continue\n        m = pattern.match(line)\n        if not m:\n            continue  # ignore lines not matching pattern\n        key = m.group(1)\n\n        if m.group(2) is not None:  # single quoted\n            value = m.group(2)\n        elif m.group(3) is not None:  # double quoted with escapes\n            # Handle backslash escapes inside double quotes\n            value = bytes(m.group(3), \"utf-8\").decode(\"unicode_escape\")\n        else:\n            # unquoted value, stripped of trailing whitespace\n            value = m.group(4).strip() if m.group(4) else \"\"\n\n        # Expand environment variables and user (~)\n        value = expand(value)\n        yield key, value", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 148, in <module>\n  File \"<string>\", line 147, in test_4\nAssertionError\n", "passed": false}
{"task_id": 159, "prediction_id": 1, "generation": "import typing\nimport collections\nimport os\nimport re\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../yeee'),\n    ('THISIS', '.../a/test'),\n    ('YOLO',\n    '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n\n    \"\"\"\n    if lines is None:\n        return\n\n    # Regex to match lines like KEY=VALUE, ignoring lines starting with '#' or empty lines\n    # KEY: any non-whitespace, non-'=' characters; VALUE: anything after '='\n    line_re = re.compile(r'^\\s*([\\w\\.]+)\\s*=\\s*(.*)?\\s*$')\n\n    for line in lines:\n        # Strip comment and whitespace\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue\n\n        m = line_re.match(line)\n        if not m:\n            continue\n\n        key, val = m.groups()\n        if val is None:\n            val = ''\n        val = val.strip()\n\n        # Remove surrounding quotes if any (single or double), support escaping is minimal (only strip quotes)\n        if (val.startswith((\"'\", '\"')) and val.endswith((\"'\", '\"')) and len(val) > 1):\n            val = val[1:-1]\n\n        # Expand any environment variables and user home\n        val = os.path.expandvars(val)\n        val = os.path.expanduser(val)\n\n        yield key, val", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 130, in <module>\n  File \"<string>\", line 129, in test_4\nAssertionError\n", "passed": false}
{"task_id": 159, "prediction_id": 2, "generation": "import typing\nimport collections\nimport os\nimport re\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> list(parse_env_file_contents(lines))\n    [('TEST', os.path.expandvars(os.path.expanduser('${HOME}/yeee'))),\n     ('THISIS', os.path.expandvars(os.path.expanduser('~/a/test'))),\n     ('YOLO', os.path.expandvars(os.path.expanduser('~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')))]\n    \"\"\"\n    # Regular expression pattern to parse lines like KEY=VALUE, allowing optional quotes around VALUE\n    # Supports: KEY=VALUE, KEY=\"VALUE\", KEY='VALUE'\n    pattern = re.compile(\n        r\"\"\"\n        ^\\s*                             # Leading whitespace\n        (?P<key>[A-Za-z_][A-Za-z0-9_]*) # Key: letters, digits, underscores, no digits first char\n        \\s*=\\s*                         # '=' surrounded by optional whitespace\n        (?:                             # Start non-capturing group for value \n          (?P<quote>['\\\"])              # Optional quote capturing group\n          (?P<value_quoted>(?:\\\\.|[^\\\\\"'])*?) # Quoted value allowing escaped chars\n          (?P=quote)                   # Closing quote matching opening\n          |                             # OR\n          (?P<value_unquoted>[^#\\n]*)   # Unquoted value, stopping before '#' (comment) or newline\n        )\n        (?:\\s*#.*)?$                    # Optional trailing comment starting with #\n        \"\"\",\n        re.VERBOSE,\n    )\n\n    if lines is None:\n        return  # Nothing to yield\n\n    for line in lines:\n        # Strip trailing newline and whitespace\n        line = line.strip()\n        # Skip empty lines and comments\n        if not line or line.startswith(\"#\"):\n            continue\n\n        m = pattern.match(line)\n        if not m:\n            # Line does not match expected env file syntax, skip\n            continue\n\n        key = m.group(\"key\")\n        if m.group(\"value_quoted\") is not None:\n            # Unescape any escaped chars inside quoted values, then expand\n            raw_value = m.group(\"value_quoted\")\n            # Unescape sequences: \\\\, \\n, \\t, \\r, \\\", \\'\n            # Use bytes decode trick to handle standard escapes\n            try:\n                unescaped_value = bytes(raw_value, \"utf-8\").decode(\"unicode_escape\")\n            except Exception:\n                unescaped_value = raw_value  # fallback if decode fails\n            val = unescaped_value\n        else:\n            val = m.group(\"value_unquoted\").rstrip()\n\n        # Expand environment variables and user (~)\n        val = os.path.expandvars(val)\n        val = os.path.expanduser(val)\n\n        yield key, val", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 138, in <module>\n  File \"<string>\", line 137, in test_0\n  File \"<string>\", line 55, in parse_env_file_contents\n  File \"/usr/local/lib/python3.10/re.py\", line 251, in compile\n    return _compile(pattern, flags)\n  File \"/usr/local/lib/python3.10/re.py\", line 303, in _compile\n    p = sre_compile.compile(pattern, flags)\n  File \"/usr/local/lib/python3.10/sre_compile.py\", line 764, in compile\n    p = sre_parse.parse(p, flags)\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 948, in parse\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 443, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 836, in _parse\n    raise source.error(\"missing ), unterminated subpattern\",\nre.error: missing ), unterminated subpattern at position 711 (line 12, column 9)\n", "passed": false}
{"task_id": 159, "prediction_id": 3, "generation": "import typing\nimport collections\nimport os\nimport re\n\n\ndef expand(val: str) -> str:\n    val = os.path.expandvars(val)\n    val = os.path.expanduser(val)\n    return val\n\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> list(parse_env_file_contents(lines))  # doctest: +SKIP\n    [('TEST', '.../yeee'),\n    ('THISIS', '.../a/test'),\n    ('YOLO',\n    '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')]\n\n    \"\"\"\n    if lines is None:\n        return\n\n    # Regular expression to parse lines like KEY=VALUE (supports quoted values)\n    line_re = re.compile(\n        r\"\"\"^\\s*\n        ([A-Za-z_][A-Za-z0-9_]*)  # key\n        \\s*=\\s*\n        (?:\n          (?:'((?:[^']|\\\\')*)')  # single quoted value\n          |\n          (?:\"((?:[^\"]|\\\\\")*)\")  # double quoted value\n          |\n          ([^\\n#]+)              # unquoted value\n        )?\n        \\s*(?:#.*)?$\n        \"\"\",\n        re.VERBOSE,\n    )\n\n    for lineno, line in enumerate(lines, 1):\n        line = line.strip()\n        if not line or line.startswith(\"#\"):\n            continue\n\n        m = line_re.match(line)\n        if not m:\n            # Doesn't match key=value pattern, skip line silently (honcho behavior)\n            continue\n\n        key = m.group(1)\n        val = (\n            m.group(2)\n            or m.group(3)\n            or m.group(4)\n            or \"\"\n        )\n\n        # Unescape quotes inside quoted value\n        if m.group(2):  # single quoted\n            val = val.replace(\"\\\\'\", \"'\")\n        elif m.group(3):  # double quoted\n            val = val.replace('\\\\\"', '\"').replace(\"\\\\n\", \"\\n\").replace(\"\\\\r\", \"\\r\").replace(\"\\\\t\", \"\\t\")\n\n        # Expand environment variables and user home directory\n        val = expand(val)\n\n        yield key, val", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 142, in <module>\n  File \"<string>\", line 141, in test_0\n  File \"<string>\", line 66, in parse_env_file_contents\n  File \"/usr/local/lib/python3.10/re.py\", line 251, in compile\n    return _compile(pattern, flags)\n  File \"/usr/local/lib/python3.10/re.py\", line 303, in _compile\n    p = sre_compile.compile(pattern, flags)\n  File \"/usr/local/lib/python3.10/sre_compile.py\", line 764, in compile\n    p = sre_parse.parse(p, flags)\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 948, in parse\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 443, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 836, in _parse\n    raise source.error(\"missing ), unterminated subpattern\",\nre.error: missing ), unterminated subpattern at position 279 (line 11, column 12)\n", "passed": false}
{"task_id": 159, "prediction_id": 4, "generation": "import typing\nimport collections\nimport re\nimport os\n\n\ndef parse_env_file_contents(lines: typing.Iterable[str] = None) -> typing.Generator[typing.Tuple[str, str], None, None]:\n    \"\"\"\n    Parses env file content.\n\n    From honcho.\n\n    >>> lines = ['TEST=${HOME}/yeee', 'THISIS=~/a/test', 'YOLO=~/swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST']\n    >>> load_env_file(lines, write_environ=dict())\n    OrderedDict([('TEST', '.../yeee'),\n    ('THISIS', '.../a/test'),\n    ('YOLO',\n    '.../swaggins/$NONEXISTENT_VAR_THAT_DOES_NOT_EXIST')])\n\n    \"\"\"\n    # Pattern to parse lines with optional export keyword, variable name,\n    # equals sign, then variable value (possibly quoted)\n    env_line_re = re.compile(\n        r\"\"\"\n        ^\\s*(?:export\\s+)?       # optional export keyword\n        ([A-Za-z_][A-Za-z0-9_]*) # variable name\n        \\s*=\\s*                  # equals sign with optional spaces\n        (                       # start of value capture group\n            (?:'[^']*'           # single-quoted value\n            |\"[^\"]*\"             # double-quoted value\n            |[^\\s#]+             # unquoted value (non-space, non-# chars)\n            )?\n        )                       # end of value capture group\n        (?:\\s*#.*)?             # optional trailing comment\n        $                       # end of line\n        \"\"\",\n        re.VERBOSE,\n    )\n\n    # Helper to unquote and expand\n    def unquote_and_expand(val: str) -> str:\n        val = val.strip()\n        if not val:\n            return val\n        # Remove quotes if present (single or double)\n        if (val.startswith('\"') and val.endswith('\"')) or (val.startswith(\"'\") and val.endswith(\"'\")):\n            val = val[1:-1]\n        # Expand environment variables and ~ user home\n        val = os.path.expandvars(val)\n        val = os.path.expanduser(val)\n        return val\n\n    if lines is None:\n        return\n\n    for line in lines:\n        line = line.strip()\n        if not line or line.startswith(\"#\"):\n            # Ignore empty lines and full-line comments\n            continue\n        m = env_line_re.match(line)\n        if not m:\n            # If line doesn't match expected pattern, skip\n            continue\n        key, val = m.group(1), m.group(2)\n        val = val or \"\"\n        val_expanded = unquote_and_expand(val)\n        yield key, val_expanded", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 136, in <module>\n  File \"<string>\", line 135, in test_0\n  File \"<string>\", line 58, in parse_env_file_contents\n  File \"/usr/local/lib/python3.10/re.py\", line 251, in compile\n    return _compile(pattern, flags)\n  File \"/usr/local/lib/python3.10/re.py\", line 303, in _compile\n    p = sre_compile.compile(pattern, flags)\n  File \"/usr/local/lib/python3.10/sre_compile.py\", line 764, in compile\n    p = sre_parse.parse(p, flags)\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 948, in parse\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 443, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 836, in _parse\n    raise source.error(\"missing ), unterminated subpattern\",\nre.error: missing ), unterminated subpattern at position 509 (line 11, column 9)\n", "passed": false}
