{"task_id": 25, "prediction_id": 0, "generation": "import re\nfrom typing import Any\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str) or not input_string:\n        return False\n    \n    # Valid IPv6 regex pattern based on RFC 4291 with allowance for zero compression (::)\n    # It matches:\n    # - 8 groups of 1-4 hex digits separated by ':'\n    # - or omitted groups replaced by '::' once\n    # Here we use a comprehensive regex adapted from standard strict regexes for IPv6 validation.\n    IPV6_REGEX = (\n        r'^('\n        r'(([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|'                                     # 1:2:3:4:5:6:7:8\n        r'(([0-9A-Fa-f]{1,4}:){1,7}:)|'                                                      # 1::                              1:2:3:4:5:6:7::\n        r'(([0-9A-Fa-f]{1,4}:){1,6}:[0-9A-Fa-f]{1,4})|'                                      # 1::8             1:2:3:4:5:6::8\n        r'(([0-9A-Fa-f]{1,4}:){1,5}(:[0-9A-Fa-f]{1,4}){1,2})|'                               # 1::7:8           1:2:3:4:5::7:8\n        r'(([0-9A-Fa-f]{1,4}:){1,4}(:[0-9A-Fa-f]{1,4}){1,3})|'                               # 1::6:7:8         1:2:3:4::6:7:8\n        r'(([0-9A-Fa-f]{1,4}:){1,3}(:[0-9A-Fa-f]{1,4}){1,4})|'                               # 1::5:6:7:8       1:2:3::5:6:7:8\n        r'(([0-9A-Fa-f]{1,4}:){1,2}(:[0-9A-Fa-f]{1,4}){1,5})|'                               # 1::4:5:6:7:8     1:2::4:5:6:7:8\n        r'([0-9A-Fa-f]{1,4}:((:[0-9A-Fa-f]{1,4}){1,6}))|'                                    # 1::3:4:5:6:7:8   1::3:4:5:6:7:8\n        r'(:((:[0-9A-Fa-f]{1,4}){1,7}|:))|'                                                  # ::2:3:4:5:6:7:8  ::8              ::\n        r'fe80:(:[0-9A-Fa-f]{0,4}){0,4}%[0-9a-zA-Z]{1,}|'                                   # fe80::7:8%eth0   fe80::7:8%1\n        r'::(ffff(:0{1,4}){0,1}:){0,1}'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])|'                                             # ::255.255.255.255 ::ffff:255.255.255.255 ::ffff:0:255.255.255.255\n        r'([0-9A-Fa-f]{1,4}:){1,4}:'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])'\n        r')$'\n    )\n\n    pattern = re.compile(IPV6_REGEX, re.IGNORECASE)\n    return bool(pattern.match(input_string))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 769, in <module>\n  File \"<string>\", line 768, in test_20\nAssertionError\n", "passed": false}
{"task_id": 25, "prediction_id": 1, "generation": "import re\nfrom typing import Any\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n\n    if not isinstance(input_string, str) or not input_string:\n        return False\n\n    # An IPv6 address consists of eight groups of four hexadecimal digits,\n    # each group representing 16 bits.\n    # The groups are separated by colons (:).\n    # A group of consecutive zero value groups may be compressed to :: but only once.\n    # Leading zeros in a group can be omitted.\n    # Valid characters are hex digits (0-9, a-f, A-F) and colons.\n    # We use a regular expression to validate based on standard IPv6 format.\n\n    # This regex covers full form, zero-padding omission, and zero compression (::).\n    # Source adapted & simplified from common ipv6 regex patterns.\n\n    IPV6_REGEX = re.compile(\n        r'^('\n        r'([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|'                     # full address\n        r'([0-9A-Fa-f]{1,4}:){1,7}:|'                                 # :: with 1 to 7 groups\n        r'([0-9A-Fa-f]{1,4}:){1,6}:[0-9A-Fa-f]{1,4}|'                 # ending single segment after ::\n        r'([0-9A-Fa-f]{1,4}:){1,5}(:[0-9A-Fa-f]{1,4}){1,2}|'          # one or two segments after ::\n        r'([0-9A-Fa-f]{1,4}:){1,4}(:[0-9A-Fa-f]{1,4}){1,3}|'          # \n        r'([0-9A-Fa-f]{1,4}:){1,3}(:[0-9A-Fa-f]{1,4}){1,4}|'          # \n        r'([0-9A-Fa-f]{1,4}:){1,2}(:[0-9A-Fa-f]{1,4}){1,5}|'          # \n        r'[0-9A-Fa-f]{1,4}:((:[0-9A-Fa-f]{1,4}){1,6})|'               # \n        r':((:[0-9A-Fa-f]{1,4}){1,7}|:)|'                             # :: with 1 to 7 groups or ::\n        r'fe80:(:[0-9A-Fa-f]{0,4}){0,4}%[0-9a-zA-Z]{1,}|'             # link-local IPv6 with zone index\n        r'::(ffff(:0{1,4})?:)?((25[0-5]|(2[0-4]|1{0,1}[0-9])'\n        r'{0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|' # IPv4 mapped IPv6 addresses\n        r'([0-9A-Fa-f]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9])'\n        r'{0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])'\n        r')$'\n    )\n\n    if IPV6_REGEX.match(input_string):\n        return True\n    return False", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 771, in <module>\n  File \"<string>\", line 770, in test_20\nAssertionError\n", "passed": false}
{"task_id": 25, "prediction_id": 2, "generation": "import re\nfrom typing import Any\n\n# Using a regex pattern that loosely matches IPv6 addresses.\n# The exact regex is inspired by common IPv6 validation patterns.\n# We only accept valid hex digits and the colon format.\n# Compressed (::) and full notation are allowed.\n# This pattern does not fully validate all semantic IPv6 rules (like segments count),\n# but is a strong syntactic validator.\n_IP_V6_RE = re.compile(\n    r'^('\n    r'([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|'\n    r'([0-9a-fA-F]{1,4}:){1,7}:|'\n    r'([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|'\n    r'([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|'\n    r'([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|'\n    r'([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|'\n    r'([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|'\n    r'[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|'\n    r':((:[0-9a-fA-F]{1,4}){1,7}|:)|'\n    r'fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|'\n    r'::(ffff(:0{1,4}){0,1}:){0,1}'\n    r'((25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.){3,3}'\n    r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])|'\n    r'([0-9a-fA-F]{1,4}:){1,4}:'\n    r'((25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.){3,3}'\n    r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])'\n    r')$'\n)\n\ndef is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    return isinstance(input_string, str) and input_string.strip() != ''\n\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return _IP_V6_RE.match(input_string) is not None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 776, in <module>\n  File \"<string>\", line 775, in test_20\nAssertionError\n", "passed": false}
{"task_id": 25, "prediction_id": 3, "generation": "import re\nfrom typing import Any\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n\n    if not isinstance(input_string, str):\n        return False\n\n    # An IPv6 address consists of 8 groups of 1-4 hex digits (0-9, a-f, A-F) separated by colons.\n    # It may contain a double colon (::) once to compress consecutive zero groups.\n    # Also IPv6 can have leading zeros omitted.\n\n    # Define a regex to validate IPv6 addresses, accepting :: once and the valid hex groups.\n    # Regex adapted and simplified for validation purpose here:\n    IPV6_RE = re.compile(r'''\n        ^\n        (?:                                        # 8 groups of 1-4 hex digits separated by colons\n            (?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}                 # full form\n          | (?:                                       # or with zero-compression (::)\n            (?:[0-9a-fA-F]{1,4}:){1,7}:                    # 1 to 7 groups, then ::\n          | :(?:[0-9a-fA-F]{1,4}:){1,7}                    # :: then 1 to 7 groups\n          | (?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}\n          | (?:[0-9a-fA-F]{1,4}:){1,5}(?::[0-9a-fA-F]{1,4}){1,2}\n          | (?:[0-9a-fA-F]{1,4}:){1,4}(?::[0-9a-fA-F]{1,4}){1,3}\n          | (?:[0-9a-fA-F]{1,4}:){1,3}(?::[0-9a-fA-F]{1,4}){1,4}\n          | (?:[0-9a-fA-F]{1,4}:){1,2}(?::[0-9a-fA-F]{1,4}){1,5}\n          | [0-9a-fA-F]{1,4}:(?:(?::[0-9a-fA-F]{1,4}){1,6})\n          | :(?:(?::[0-9a-fA-F]{1,4}){1,7}|:)\n          )\n        )\n        $\n        ''', re.VERBOSE | re.IGNORECASE)\n\n    if not IPV6_RE.match(input_string):\n        return False\n\n    # Additional validation: each segment should be 1-4 digits hex\n    # Split by ':', filter empty strings for ::\n    parts = input_string.split(':')\n\n    # Count of parts varies due to ::\n    if '' in parts:\n        # Only one occurrence of empty part is allowed due to :: compression\n        if parts.count('') > 2:  # '' can appear twice with :: but not more\n            return False\n        # If starts or ends with '', remove them for counting parts correctly\n        if input_string.startswith('::'):\n            parts = parts[1:]\n        if input_string.endswith('::'):\n            parts = parts[:-1]\n\n    # After expansion to 8 groups, max 8 groups allowed\n    if len(parts) > 8:\n        return False\n\n    # Check hex digits for each non-empty group\n    for p in parts:\n        if p == '':\n            continue\n        if len(p) > 4 or not all(c in '0123456789abcdefABCDEF' for c in p):\n            return False\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 877, in <module>\n  File \"<string>\", line 876, in test_57\nAssertionError\n", "passed": false}
{"task_id": 25, "prediction_id": 4, "generation": "import re\nfrom typing import Any\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str) or not input_string:\n        return False\n\n    # Basic IPv6 regex pattern that covers:\n    # - full notation (8 groups of 1-4 hex digits)\n    # - shorthand with ::\n    # - optional embedded IPv4 at the end\n    \n    # This regex is adapted to match valid IPv6 addresses conservatively\n    IPV6_STD_PATTERN = (\n        r'('\n        r'([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}'          # 1:2:3:4:5:6:7:8\n        r'|'\n        r'([0-9a-fA-F]{1,4}:){1,7}:'\n        r'|'\n        r'([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}'\n        r'|'\n        r'([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}'\n        r'|'\n        r'([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}'\n        r'|'\n        r'([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}'\n        r'|'\n        r'([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}'\n        r'|'\n        r'[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})'\n        r'|'\n        r':((:[0-9a-fA-F]{1,4}){1,7}|:)'\n        r'|'\n        r'fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}'  # link-local IPv6 with zone index\n        r'|'\n        r'::(ffff(:0{1,4}){0,1}:){0,1}'                    # IPv4-mapped IPv6\n        r'((25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.){3}'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])'\n        r'|'\n        r'([0-9a-fA-F]{1,4}:){1,4}:'\n        r'((25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.){3}'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])'\n        r')'\n        r'$'\n    )\n\n    ip_v6_re = re.compile(IPV6_STD_PATTERN, re.IGNORECASE)\n    return ip_v6_re.match(input_string) is not None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 778, in <module>\n  File \"<string>\", line 777, in test_20\nAssertionError\n", "passed": false}
