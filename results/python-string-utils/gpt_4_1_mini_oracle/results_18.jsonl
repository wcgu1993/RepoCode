{"task_id": 18, "prediction_id": 0, "generation": "import re\nfrom typing import Any\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not (isinstance(input_string, str) and input_string.strip()):\n        return False\n\n    # Define an email regex pattern:\n    # This pattern attempts to reasonably validate emails per RFC3696 section 3,\n    # capturing local part rules and domain rules, disallowing empty local or domain parts.\n    #\n    # Local part: allows letters, digits, and these characters: !#$%&'*+/=?^_`{|}~-\n    # Also allows dots provided they are not at the start/end and not consecutive.\n    #\n    # Domain part: labels separated by dots, each label starts and ends with alphanumeric,\n    # hyphens allowed inside but not start/end. TLD at least 2 chars.\n    email_regex = re.compile(\n        r\"^(?P<local>[a-zA-Z0-9!#$%&'*+/=?^_`{|}~\\-]+(\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~\\-]+)*)\"  # local part\n        r\"@\"\n        r\"(?P<domain>([a-zA-Z0-9](?:[a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+\"  # domain labels\n        r\"[a-zA-Z]{2,})$\"\n    )\n\n    # Match the regex\n    match = email_regex.match(input_string)\n    if not match:\n        return False\n\n    # Additional check to ensure local part doesn't start/end with dot or have consecutive dots\n    local_part = match.group('local')\n    if local_part.startswith('.') or local_part.endswith('.') or '..' in local_part:\n        return False\n\n    # Domain is captured, but regex ensures validity, no further checks needed here\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 700, in <module>\n  File \"<string>\", line 699, in test_4\nAssertionError\n", "passed": false}
{"task_id": 18, "prediction_id": 1, "generation": "import re\nfrom typing import Any\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    # First, check basic validity of input_string: must be a non-empty string with non-space\n    if not (isinstance(input_string, str) and input_string.strip()):\n        return False\n\n    # Simple RFC 3696 section 3 approximation regex:\n    #\n    # General valid email pattern:\n    # local-part@domain\n    # local-part = allowed ASCII chars including dot (.), underscore (_), hyphen (-), plus (+)\n    # domain = domain labels separated by dots, labels start and end with alphanumeric characters,\n    # optionally hyphen inside.\n    #\n    # We will use a carefully crafted regex aligned with common email rules.\n    #\n    # This regex is not fully RFC compliant but covers the majority sensible use cases:\n    email_regex = re.compile(\n        r\"^(?P<local>[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*)\"  # local part\n        r\"@\"\n        r\"(?P<domain>(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+\"  # domain labels\n        r\"[a-zA-Z]{2,})$\"  # TLD\n    )\n\n    if not email_regex.match(input_string):\n        return False\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 695, in <module>\n  File \"<string>\", line 694, in test_4\nAssertionError\n", "passed": false}
{"task_id": 18, "prediction_id": 2, "generation": "import re\nfrom typing import Any\n\nfrom string_utils.validation import is_full_string\n\n# Reasonable RFC 3696 simplified regex pattern for emails.\n# Note: Comprehensive email validation with full RFC compliance is very complex,\n# this covers the most common valid emails and rejects obvious invalid ones.\nEMAIL_RE = re.compile(\n    r\"^(?P<local>[-!#$%&'*+/=?^_`{}|~0-9A-Za-z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Za-z]+)*)\"\n    r\"@\"\n    r\"(?P<domain>[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?\"\n    r\"(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)+)$\"\n)\n\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return EMAIL_RE.match(input_string) is not None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 686, in <module>\n  File \"<string>\", line 685, in test_4\nAssertionError\n", "passed": false}
{"task_id": 18, "prediction_id": 3, "generation": "import re\nfrom typing import Any\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str) or not input_string.strip():\n        return False\n\n    # RFC 3696 simplified email regex pattern that covers common cases:\n    # local-part@domain, local part can have alphanumeric and allowed special chars,\n    # domain consists of labels separated by dots, each label must start and end\n    # with alphanumeric, may contain hyphens, domain TLD at least 2 chars.\n    email_pattern = re.compile(\n        r\"^(?P<local>[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*)\"\n        r\"@\"\n        r\"(?P<domain>(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+\"\n        r\"[a-zA-Z]{2,})$\"\n    )\n\n    return bool(email_pattern.match(input_string))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 684, in <module>\n  File \"<string>\", line 683, in test_4\nAssertionError\n", "passed": false}
{"task_id": 18, "prediction_id": 4, "generation": "import re\nfrom typing import Any\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not (isinstance(input_string, str) and input_string and input_string.strip()):\n        return False\n\n    # Basic regex for validating an email address roughly following RFC3696 section 3\n    # Explanation:\n    #  - local part: 1 or more characters not including control chars, space, or specials, allows dots between but not starting or ending with dot\n    #  - domain part: one or more labels separated by dots, labels start and end with alphanumeric, may contain hyphens\n    # Note: Full RFC compliance regex is extremely complex, we approximate practical valid emails.\n    email_re = re.compile(\n        r\"^(?P<local>[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*)\"\n        r\"@\"\n        r\"(?P<domain>(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,})$\"\n    )\n\n    match = email_re.match(input_string)\n    return match is not None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 685, in <module>\n  File \"<string>\", line 684, in test_4\nAssertionError\n", "passed": false}
