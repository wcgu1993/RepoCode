{"task_id": 15, "prediction_id": 0, "generation": "import re\nfrom typing import Any\n\nfrom .errors import InvalidInputError\n\n# The regex pattern for integer numbers including optional sign and scientific notation with exponent integer only.\n# This pattern matches:\n#   - optional leading + or -\n#   - a sequence of digits\n#   - optionally, an exponent part: e or E followed by optional sign and digits (integer exponent)\nINTEGER_RE = re.compile(r'^[+-]?\\d+(?:[eE][+-]?\\d+)?$')\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    # Quick reject if it does not look like a number at all:\n    # Since there is is_number function, but it allows decimals.\n    # Here we ensure the string matches the integer pattern with optional scientific notation.\n\n    if INTEGER_RE.match(input_string) is None:\n        return False\n\n    # Additional check: prevent numbers with decimal point (eg. 42.0)\n    # The regex already disallows decimals.\n    # So no further checks are needed here.\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 163, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 15, "prediction_id": 1, "generation": "import re\nfrom typing import Any\n\nfrom .errors import InvalidInputError\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    # Pattern to match integers and integers in scientific notation:\n    # Examples of valid integers:\n    # 42, -42, +42, 42e0, -42e0, +42e0\n    # Not valid: 42.0, 42.1, 3.14e2\n    #\n    # Strategy:\n    # 1) Check if string matches a plain integer (with optional +/-)\n    # 2) Or matches an integer in scientific notation, where the mantissa is an integer (no decimal point),\n    #    e.g. \"42e2\", \"-42e-3\"\n    #\n    # Regex explanation:\n    # ^[+-]?      : optional sign\n    # \\d+         : one or more digits (integer part)\n    # (           : start optional exponent group\n    #    e[+-]?\\d+ : 'e' or 'E', optional sign, at least one digit\n    # )?          : exponent is optional\n    # $           : end of string\n\n    integer_sci_re = re.compile(r'^[+-]?\\d+(e[+-]?\\d+)?$', re.IGNORECASE)\n\n    return bool(integer_sci_re.match(input_string))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 163, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 15, "prediction_id": 2, "generation": "import re\nfrom typing import Any\nfrom .errors import InvalidInputError\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    # Regular expression to match an integer including scientific notation with integer base and exponent\n    # Pattern explanation:\n    # ^[\\+\\-]?        optional leading + or -\n    # \\d+             one or more digits (integer part)\n    # (e[\\+\\-]?\\d+)?  optional scientific notation e or E followed by optional sign and digits\n    # $               end of string\n    integer_scientific_re = re.compile(r'^[\\+\\-]?\\d+(e[\\+\\-]?\\d+)?$', re.IGNORECASE)\n\n    # Using the regex to verify the input\n    return integer_scientific_re.match(input_string) is not None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 162, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 15, "prediction_id": 3, "generation": "import re\nfrom typing import Any\n\nfrom .errors import InvalidInputError\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    # Use the is_number logic to verify it's a valid number first.\n    # Then check if it is an integer without fractional part.\n    # A valid integer can be:\n    # - signed decimal integer (e.g. -42, +42)\n    # - unsigned decimal integer (e.g. 42)\n    # - integer in scientific notation with zero fractional part (e.g. 4e1, -3e+2)\n    # But should not recognize floats with decimals like 42.0, 3.14, etc.\n\n    # We'll use a regex pattern to match integers and integers in scientific notation\n    # but not decimals.\n    # Simplify matching:\n\n    # Integer regex: optional sign + digits only\n    integer_pattern = re.compile(r'^[+-]?\\d+$')\n\n    # Scientific notation integer: optional sign, digits, 'e' or 'E', optional sign, digits\n    sci_integer_pattern = re.compile(r'^[+-]?\\d+[eE][+-]?\\d+$')\n\n    if integer_pattern.match(input_string):\n        return True\n\n    if sci_integer_pattern.match(input_string):\n        # We must ensure that the value corresponds to an integer.\n        # For example, \"1e3\" = 1000 integer, \"1e0\" = 1 integer\n        # So convert to float and check if integer\n        try:\n            val = float(input_string)\n            return val.is_integer()\n        except ValueError:\n            return False\n\n    return False", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 163, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 15, "prediction_id": 4, "generation": "import re\nfrom typing import Any\n\nfrom .errors import InvalidInputError\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    # Use the is_number function pattern logic indirectly:\n    # Validate the input string matches a number pattern (including scientific notation).\n    # Then verify specifically it represents an integer:\n    # - No decimal point allowed.\n    # - Scientific notation exponent must represent an integer power.\n    # - The mantissa (before e or E) must be an integer without a decimal point.\n\n    # Regex pattern matching integers with optional sign\n    int_pattern = re.compile(r\"^[+-]?\\d+$\")\n\n    # Regex to split scientific notation parts\n    sci_split = re.compile(r\"^([+-]?[\\d]+)([eE][+-]?\\d+)?$\")\n\n    # First, match the full pattern for integer or integer scientific notation\n    m = sci_split.match(input_string)\n    if not m:\n        return False\n\n    mantissa, exponent = m.groups()\n\n    # Mantissa must be a signed integer digits without decimal point\n    if not int_pattern.match(mantissa):\n        return False\n\n    if exponent is not None:\n        # Exponent is in form e[+-]?digits, digits must be integer (which they always are)\n        # just validate the exponent digits format\n        exponent_pattern = re.compile(r\"^[eE][+-]?\\d+$\")\n        if not exponent_pattern.match(exponent):\n            return False\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 163, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
