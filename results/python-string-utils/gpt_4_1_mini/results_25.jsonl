{"task_id": 25, "prediction_id": 0, "generation": "import ipaddress\nfrom typing import Any\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        return False\n    try:\n        # ipaddress.IPv6Address will raise a ValueError if input_string is not a valid IPv6\n        ipaddress.IPv6Address(input_string)\n        return True\n    except ValueError:\n        return False", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 742, in <module>\n  File \"<string>\", line 741, in test_20\nAssertionError\n", "passed": false}
{"task_id": 25, "prediction_id": 1, "generation": "from typing import Any\nimport re\n\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    # IPv6 regex pattern based on RFC 4291 format with allowance for zero compression (::).\n    # This regex matches the full IPv6 forms including abbreviated zeros and IPv4 mapped addresses.\n    if not isinstance(input_string, str):\n        return False\n\n    # A simplified but commonly used regex pattern for validating IPv6 addresses:\n    ipv6_pattern = re.compile(r'''\n        ^\n        (\n          ([0-9a-fA-F]{1,4}:){7}([0-9a-fA-F]{1,4}|:)|\n          ([0-9a-fA-F]{1,4}:){1,7}:|\n          ([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|\n          ([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|\n          ([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|\n          ([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|\n          ([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|\n          [0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|\n          :((:[0-9a-fA-F]{1,4}){1,7}|:)|\n          fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|\n          ::(ffff(:0{1,4}){0,1}:){0,1}\n          ((25[0-5]|(2[0-4][0-9])|(1[0-9]{2})|([1-9]?[0-9]))\\.){3}\n          (25[0-5]|(2[0-4][0-9])|(1[0-9]{2})|([1-9]?[0-9]))|\n          ([0-9a-fA-F]{1,4}:){1,4}:\n          ((25[0-5]|(2[0-4][0-9])|(1[0-9]{2})|([1-9]?[0-9]))\\.){3}\n          (25[0-5]|(2[0-4][0-9])|(1[0-9]{2})|([1-9]?[0-9]))\n        )\n        $\n        ''', re.VERBOSE | re.IGNORECASE)\n\n    return bool(ipv6_pattern.match(input_string))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 765, in <module>\n  File \"<string>\", line 764, in test_20\nAssertionError\n", "passed": false}
{"task_id": 25, "prediction_id": 2, "generation": "import re\nfrom typing import Any\n\n# Regex adapted for matching a valid IPv6 address (simplified but accurate pattern for validation)\nIPV6_RE = re.compile(\n    r'^('\n    r'(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4})|'                  # 1:2:3:4:5:6:7:8\n    r'(([0-9a-fA-F]{1,4}:){1,7}:)|'                               # 1::                              1:2:3:4:5:6:7::\n    r'(([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4})|'               # 1::8             1:2:3:4:5:6::8\n    r'(([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2})|'        # 1::7:8           1:2:3:4:5::7:8\n    r'(([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3})|'        # 1::6:7:8         1:2:3:4::6:7:8\n    r'(([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4})|'        # 1::5:6:7:8       1:2:3::5:6:7:8\n    r'(([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5})|'        # 1::4:5:6:7:8     1:2::4:5:6:7:8\n    r'([0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6}))|'             # 1::3:4:5:6:7:8   1::3:4:5:6:7:8\n    r'(:((:[0-9a-fA-F]{1,4}){1,7}|:))|'                           # ::2:3:4:5:6:7:8  ::8             ::\n    r'fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|'             # fe80::7:8%eth0   fe80::7:8%1\n    r'::(ffff(:0{1,4}){0,1}:){0,1}'\n    r'((25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.){3}'\n    r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])|'                      # ::255.255.255.255 ::ffff:255.255.255.255 ::ffff:0:255.255.255.255\n    r'([0-9a-fA-F]{1,4}:){1,4}:'\n    r'((25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.){3}'\n    r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])'\n    r')$'\n)\n\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        return False\n\n    input_string = input_string.strip()\n    if input_string == '':\n        return False\n\n    if IPV6_RE.match(input_string) is None:\n        return False\n\n    # Additional check: no invalid characters (only hex digits, colons and optionally dot-decimal notation allowed)\n    # The regex already covers this, but we do a simple guard here\n    valid_chars = set(\"0123456789abcdefABCDEF:.%\")\n    if not set(input_string).issubset(valid_chars):\n        return False\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 774, in <module>\n  File \"<string>\", line 773, in test_20\nAssertionError\n", "passed": false}
{"task_id": 25, "prediction_id": 3, "generation": "import re\nfrom typing import Any\n\nfrom string_utils.validation import is_full_string, is_string\n\n\n# A simplified regex for matching a valid IPv6 address. This regex covers the normal IPv6 notation,\n# with optional shorthand (::), hexadecimal digits grouping, and optional IPv4-mapped addresses at the end.\n# Note: This is a simplified regex and may not cover every edge case perfectly, but should be sufficient for common validation.\n\n_IP_V6_REGEX = re.compile(\n    r'^('\n    r'(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|'\n    r'([0-9a-fA-F]{1,4}:){1,7}:|'\n    r'([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|'\n    r'([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|'\n    r'([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|'\n    r'([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|'\n    r'([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|'\n    r'[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|'\n    r':((:[0-9a-fA-F]{1,4}){1,7}|:)|'\n    r'fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|'\n    r'::(ffff(:0{1,4}){0,1}:){0,1}'\n    r'((25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.){3,3}'\n    r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])|'\n    r'([0-9a-fA-F]{1,4}:){1,4}:'\n    r'((25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.){3,3}'\n    r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])'\n    r')$'\n)\n\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return _IP_V6_REGEX.match(input_string) is not None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 445, in <module>\n  File \"/usr/local/lib/python3.10/re.py\", line 251, in compile\n    return _compile(pattern, flags)\n  File \"/usr/local/lib/python3.10/re.py\", line 303, in _compile\n    p = sre_compile.compile(pattern, flags)\n  File \"/usr/local/lib/python3.10/sre_compile.py\", line 764, in compile\n    p = sre_parse.parse(p, flags)\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 948, in parse\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 443, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n  File \"/usr/local/lib/python3.10/sre_parse.py\", line 836, in _parse\n    raise source.error(\"missing ), unterminated subpattern\",\nre.error: missing ), unterminated subpattern at position 1\n", "passed": false}
{"task_id": 25, "prediction_id": 4, "generation": "import re\nfrom typing import Any\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str) or not input_string:\n        return False\n\n    # IPv6 has 8 groups of 1-4 hex digits, separated by :, but can have compressed zeros (::)\n    # We use a regex that fully validates IPv6 address formats including compressed zeros and embedded IPv4\n    \n    # Regex to match full or compressed IPv6 addresses:\n    ipv6_pattern = (\n        r'('\n        r'(([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|'                        # 1:2:3:4:5:6:7:8\n        r'(([0-9A-Fa-f]{1,4}:){1,7}:)|'                                       # 1::                              1:2:3:4:5:6:7::\n        r'(([0-9A-Fa-f]{1,4}:){1,6}:[0-9A-Fa-f]{1,4})|'                       # 1::8             1:2:3:4:5:6::8\n        r'(([0-9A-Fa-f]{1,4}:){1,5}(:[0-9A-Fa-f]{1,4}){1,2})|'                # 1::7:8           1:2:3:4:5::7:8\n        r'(([0-9A-Fa-f]{1,4}:){1,4}(:[0-9A-Fa-f]{1,4}){1,3})|'                # 1::6:7:8         1:2:3:4::6:7:8\n        r'(([0-9A-Fa-f]{1,4}:){1,3}(:[0-9A-Fa-f]{1,4}){1,4})|'                # 1::5:6:7:8       1:2:3::5:6:7:8\n        r'(([0-9A-Fa-f]{1,4}:){1,2}(:[0-9A-Fa-f]{1,4}){1,5})|'                # 1::4:5:6:7:8     1:2::4:5:6:7:8\n        r'([0-9A-Fa-f]{1,4}:((:[0-9A-Fa-f]{1,4}){1,6}))|'                     # 1::3:4:5:6:7:8   1::3:4:5:6:7:8\n        r'(:((:[0-9A-Fa-f]{1,4}){1,7}|:))|'                                   # ::2:3:4:5:6:7:8  ::8             ::\n        r'fe80:(:[0-9A-Fa-f]{0,4}){0,4}%[0-9a-zA-Z]{1,}|'                    # fe80::7:8%eth0   fe80::7:8%1\n        r'::(ffff(:0{1,4}){0,1}:){0,1}'                                       # ::ffff:192.0.2.128 or ::ffff:0:192.0.2.128\n        r'((25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.){3}'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])|'\n        r'([0-9A-Fa-f]{1,4}:){1,4}:'\n        r'((25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])\\.){3}'\n        r'(25[0-5]|(2[0-4]|1{0,1}[0-9])?[0-9])'\n        r')'\n    )\n    \n    pattern = re.compile(r'^' + ipv6_pattern + r'$')\n    \n    return bool(pattern.match(input_string))", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 765, in <module>\n  File \"<string>\", line 764, in test_20\nAssertionError\n", "passed": false}
