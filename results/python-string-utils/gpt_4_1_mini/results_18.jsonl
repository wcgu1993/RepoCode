{"task_id": 18, "prediction_id": 0, "generation": "import re\nfrom typing import Any\n\nfrom string_utils.validation import is_string, is_full_string\n\n# RFC 3696 recommends a fairly permissive pattern for emails.\n# We'll use a reasonably strict regex while not being overly complex.\n# This regex allows quoted local parts and fairly standard domain names.\n# Not fully RFC 5322 compliant, but practical for many use cases.\n\n_EMAIL_RE = re.compile(\n    r\"^(?P<local>(?:[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+\"\n    r\"(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"\n    r'\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|'\n    r'\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\"))@'\n    r\"(?P<domain>(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+\"\n    r\"[a-zA-Z]{2,63}|\"\n    r\"\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}\"\n    r\"(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|\\w*:)*\\])$\"\n)\n\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if not is_string(input_string):\n        return False\n\n    # Quick check for exactly one '@' symbol and no whitespace\n    if input_string.count('@') != 1 or any(c.isspace() for c in input_string):\n        return False\n\n    return _EMAIL_RE.match(input_string) is not None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 715, in <module>\n  File \"<string>\", line 714, in test_8\nAssertionError\n", "passed": false}
{"task_id": 18, "prediction_id": 1, "generation": "import re\nfrom typing import Any\n\nfrom string_utils.validation import is_full_string, is_string, contains_html\n\n\n# A simplified but effective email regex following RFC3696 section 3 reference.\n# It covers common valid email formats without going into excessive complexity.\n_EMAIL_RE = re.compile(\n    r\"^(?P<local>[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*)\"\n    r\"@\"\n    r\"(?P<domain>[a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?)+)$\"\n)\n\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if contains_html(input_string):\n        return False\n\n    if not _EMAIL_RE.match(input_string):\n        return False\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 691, in <module>\n  File \"<string>\", line 690, in test_4\nAssertionError\n", "passed": false}
{"task_id": 18, "prediction_id": 2, "generation": "import re\nfrom typing import Any\n\nfrom string_utils.validation import is_string, is_full_string\n\n# Precompiled regex for email validation based on RFC 3696 section 3 (simplified but robust)\n# Explanation:\n# - Local part: one or more of A-Z, a-z, 0-9, and allowed special characters except @ and quotes\n#   We accept dot-separated atoms, ensuring no dot at start or end or consecutive dots.\n# - Domain: labels separated by dots, each label at least one character, only letters, digits, hyphens (not starting or ending with hyphen)\n# - TLD: at least 2 letters\n# This regex avoids overly complex issues but catches standard emails well.\n\nEMAIL_RE = re.compile(\n    r\"^(?P<local>[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*)@\"\n    r\"(?P<domain>(?:[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?\\.)+[A-Za-z]{2,})$\"\n)\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if not is_string(input_string):\n        return False\n\n    # Match the regex\n    return EMAIL_RE.match(input_string) is not None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 692, in <module>\n  File \"<string>\", line 691, in test_4\nAssertionError\n", "passed": false}
{"task_id": 18, "prediction_id": 3, "generation": "import re\nfrom typing import Any\n\nfrom string_utils.validation import is_string, is_full_string\n\n# RFC 3696 section 3 email regex simplified for common validations\n# This regex matches most valid emails but is not fully RFC-compliant due to RFC complexity.\n# It requires at least one character before '@', domain with at least one dot, and valid characters around.\n_EMAIL_RE = re.compile(\n    r\"^(?P<local>[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*)\"\n    r\"@\"\n    r\"(?P<domain>(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,})$\"\n)\n\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    # Match via regex\n    return _EMAIL_RE.match(input_string) is not None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 686, in <module>\n  File \"<string>\", line 685, in test_4\nAssertionError\n", "passed": false}
{"task_id": 18, "prediction_id": 4, "generation": "import re\nfrom typing import Any\n\nfrom string_utils.validation import is_full_string, is_string\n\n# RFC 3696 simplified regex for email validation (general practical pattern)\n# This regex matches most common email formats without validating every RFC nuance.\n_EMAIL_RE = re.compile(\n    r\"^(?P<local>[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+)@(?P<domain>[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}\"\n    r\"[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+)$\"\n)\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    # Validate input type and that string is not empty or just spaces\n    if not is_full_string(input_string):\n        return False\n\n    # Use regex to validate the email format\n    return _EMAIL_RE.match(input_string) is not None", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 684, in <module>\n  File \"<string>\", line 683, in test_4\nAssertionError\n", "passed": false}
