{"task_id": 17, "prediction_id": 0, "generation": "from typing import Any, Optional, List\nfrom urllib.parse import urlparse\nfrom string_utils.validation import is_string\n\n\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_string(input_string):\n        return False\n\n    parsed = urlparse(input_string)\n\n    # A valid URL must have a scheme and a netloc\n    if not parsed.scheme or not parsed.netloc:\n        return False\n\n    if allowed_schemes is not None:\n        if parsed.scheme.lower() not in [scheme.lower() for scheme in allowed_schemes]:\n            return False\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 934, in <module>\n  File \"<string>\", line 933, in test_76\nAssertionError\n", "passed": false}
{"task_id": 17, "prediction_id": 1, "generation": "from typing import Any, Optional, List\nfrom urllib.parse import urlparse\n\nfrom string_utils.validation import is_string\n\n\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_string(input_string):\n        return False\n\n    parsed = urlparse(input_string)\n\n    # Check that scheme and netloc are present\n    if not parsed.scheme or not parsed.netloc:\n        return False\n\n    # If allowed_schemes is provided, check that scheme is in the list\n    if allowed_schemes is not None:\n        if parsed.scheme.lower() not in [scheme.lower() for scheme in allowed_schemes]:\n            return False\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 936, in <module>\n  File \"<string>\", line 935, in test_76\nAssertionError\n", "passed": false}
{"task_id": 17, "prediction_id": 2, "generation": "import re\nfrom typing import Any, Optional, List\nfrom urllib.parse import urlparse\n\nfrom string_utils.validation import is_string\n\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_string(input_string):\n        return False\n\n    # Parse the url components\n    parsed = urlparse(input_string)\n\n    # Validate scheme\n    scheme = parsed.scheme.lower()\n    if not scheme:\n        return False\n    if allowed_schemes is not None and scheme not in [s.lower() for s in allowed_schemes]:\n        return False\n\n    # Validate netloc (host)\n    netloc = parsed.netloc\n    if not netloc:\n        return False\n\n    # Further check for netloc:\n    # Sometimes URLs include username:password@host. We just need to confirm host presence.\n    # urlparse puts userinfo in netloc along with host/port.\n    # So safely parse netloc for host.\n\n    # netloc can be: [user:pass@]hostname[:port]\n    # We'll attempt to extract hostname part after '@' if present:\n    hostname_port = netloc\n    if '@' in netloc:\n        hostname_port = netloc.split('@', 1)[1]\n\n    # Extract host and port (port optional)\n    if ':' in hostname_port:\n        host = hostname_port.split(':', 1)[0]\n    else:\n        host = hostname_port\n\n    # Host must be non-empty, and must contain at least one dot or be a valid IP-like host\n    # However, the example '.mysite.com' is invalid (host starting with a dot).\n    # So host must:\n    #  - not start or end with dot\n    #  - not empty\n    #  - contain allowed characters (letters, digits, hyphen, dot)\n    #  - for simplicity, require at least one alphanumeric character\n\n    # Check host validity by regex (basic validation):\n    # Hostname rules simplified:\n    #  - labels separated by dots\n    #  - label: alphanumeric and hyphens, no leading/trailing hyphen\n    #  - overall no leading/trailing dot\n\n    # Reject if host starts or ends with dot\n    if host.startswith('.') or host.endswith('.'):\n        return False\n    if len(host) == 0:\n        return False\n\n    # Basic hostname regex for each label\n    label_re = re.compile(r'^[A-Za-z0-9]([A-Za-z0-9\\-]{0,61}[A-Za-z0-9])?$')\n\n    labels = host.split('.')\n    # Each label must match label_re\n    if any(not label_re.match(label) for label in labels):\n        return False\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 985, in <module>\n  File \"<string>\", line 984, in test_76\nAssertionError\n", "passed": false}
{"task_id": 17, "prediction_id": 3, "generation": "import re\nfrom typing import Any, Optional, List\nfrom urllib.parse import urlparse\n\nfrom string_utils.validation import is_string, is_ip\n\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_string(input_string):\n        return False\n\n    input_string = input_string.strip()\n    if input_string == '':\n        return False\n\n    # Parse the url using urllib.parse.urlparse\n    parsed = urlparse(input_string)\n\n    # Must have a scheme and netloc (domain/host)\n    if not parsed.scheme or not parsed.netloc:\n        return False\n\n    # Check scheme if allowed_schemes is provided\n    if allowed_schemes is not None:\n        if parsed.scheme.lower() not in [s.lower() for s in allowed_schemes]:\n            return False\n\n    # Check presence of only allowed characters in hostname (basic)\n    hostname = parsed.hostname\n    if hostname is None:\n        return False\n\n    # Hostname shouldn't start or end with '-'\n    if hostname.startswith('-') or hostname.endswith('-'):\n        return False\n\n    # Hostname components (labels) length and characters check (RFC1035)\n    # Allowed chars: letters, digits, hyphen, no leading or trailing hyphen in each label\n    # Also allow domain parts with unicode? For simplicity, ASCII only check here\n    labels = hostname.split('.')\n    if any(not label or not re.match(r'^[a-zA-Z0-9-]+$', label) or label.startswith('-') or label.endswith('-') for label in labels):\n        # Could be IP though, so check if ip:\n        if not is_ip(hostname):\n            return False\n\n    # If there's a port, ensure it is numeric and in valid range\n    if parsed.port is not None:\n        if not (0 < parsed.port < 65536):\n            return False\n\n    # For a valid URL, path, params, query, and fragment are optional and do not invalidate URL\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 966, in <module>\n  File \"<string>\", line 965, in test_76\n  File \"<string>\", line 254, in is_url\n  File \"/usr/local/lib/python3.10/urllib/parse.py\", line 178, in port\n    raise ValueError(message) from None\nValueError: Port could not be cast to integer value as 'abc'\n", "passed": false}
{"task_id": 17, "prediction_id": 4, "generation": "from typing import Any, Optional, List\nfrom urllib.parse import urlparse\n\nfrom string_utils.validation import is_string\n\n\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_string(input_string):\n        return False\n\n    parsed = urlparse(input_string)\n    scheme = parsed.scheme\n    netloc = parsed.netloc\n\n    # Basic checks: scheme and netloc must be non-empty\n    if not scheme or not netloc:\n        return False\n\n    # If allowed_schemes provided, scheme must be in allowed_schemes (case-insensitive compare)\n    if allowed_schemes is not None:\n        if scheme.lower() not in [s.lower() for s in allowed_schemes]:\n            return False\n\n    # Further hostname validation: netloc might contain username/password, port etc.\n    # Use parsed.hostname to get host portion only\n    hostname = parsed.hostname\n    if not hostname:\n        return False\n\n    # Reject hostname starting with dot (.) as per example '.mysite.com' => False\n    if hostname.startswith('.'):\n        return False\n\n    # Additional minimal check: hostname contains at least one '.' or is an IP address (basic heuristic)\n    # But problem examples don't insist on this; just rely on parsing\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 951, in <module>\n  File \"<string>\", line 950, in test_76\nAssertionError\n", "passed": false}
