{"task_id": 30, "prediction_id": 0, "generation": "from typing import Any\nfrom string_utils.validation import is_full_string\n\n\ndef is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    # A slug is lowercase, only contains letters, numbers, and separators,\n    # does not start or end with a separator, and does not contain spaces or other punctuation.\n\n    # Check for forbidden characters: only allow alphanumerics and the separator character\n    allowed_chars = set('abcdefghijklmnopqrstuvwxyz0123456789' + separator)\n    input_lower = input_string.lower()\n\n    # It should be exactly the lowercase representation, since slugify converts to lowercase\n    if input_string != input_lower:\n        return False\n\n    if any(ch not in allowed_chars for ch in input_string):\n        return False\n\n    # Cannot start or end with the separator\n    if input_string.startswith(separator) or input_string.endswith(separator):\n        return False\n\n    # There should be no consecutive separator characters\n    double_sep = separator * 2\n    if double_sep in input_string:\n        return False\n\n    # There should be at least one letter or number (slugify produces at least one word)\n    # Empty or only separators should return False (already handled by is_full_string)\n\n    return True", "message": "passed", "passed": true}
{"task_id": 30, "prediction_id": 1, "generation": "import re\nfrom typing import Any\n\nfrom string_utils.validation import is_full_string\nfrom string_utils.manipulation import slugify\n\n\ndef is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    # Generate the slug version of the input string with the given separator\n    try:\n        slugified_value = slugify(input_string, separator)\n    except Exception:\n        # If the input is not a string or slugify fails, return False\n        return False\n\n    return slugified_value == input_string", "message": "passed", "passed": true}
{"task_id": 30, "prediction_id": 2, "generation": "import re\nfrom typing import Any\n\nfrom .errors import InvalidInputError\nfrom ._regex import NO_LETTERS_OR_NUMBERS_RE, SPACES_RE\nfrom .manipulation import asciify\n\n\ndef is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not isinstance(input_string, str):\n        return False\n    if not input_string:\n        return False\n\n    # A slug must be lowercase ASCII, and only contain letters, numbers and the separator, no spaces.\n    # slugify() does:\n    # - lowercases input\n    # - replaces any non letter/number with spaces\n    # - replaces spaces with separator\n    # - removes duplicate separators\n    #\n    # So we validate that:\n    # 1) input_string is all ascii lowercase letters, digits, or separators\n    # 2) does not start or end with separator (slugify doesn't guarantee that? It usually strips)\n    # 3) no spaces in input_string\n\n    # early reject if spaces\n    if ' ' in input_string:\n        return False\n\n    # check ascii lowercase letters, digits, and separator only\n    allowed_chars_pattern = f'^[a-z0-9{re.escape(separator)}]+$'\n    if re.match(allowed_chars_pattern, input_string) is None:\n        return False\n\n    # no multiple consecutive separators allowed (slugify replaces multiple separators to a single one)\n    if re.search(re.escape(separator) + r'{2,}', input_string):\n        return False\n\n    # must not start or end with separator (slugify strips spaces, so we expect no leading or trailing separator)\n    if input_string.startswith(separator) or input_string.endswith(separator):\n        return False\n\n    # if after removing all separators the string is empty, it's not a valid slug\n    if input_string.replace(separator, '') == '':\n        return False\n\n    return True", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 552, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 30, "prediction_id": 3, "generation": "from typing import Any\nfrom string_utils.validation import is_full_string\nimport re\n\n\ndef is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    # Validate that input_string is a non-empty string\n    if not is_full_string(input_string):\n        return False\n\n    # Slugs must be lowercase\n    if input_string.lower() != input_string:\n        return False\n\n    # Slug only allows ascii letters, digits and the separator, no spaces or other punctuation\n    # Build regex pattern to match slug with given separator\n    # Slug: tokens separated by separator, tokens contain only ascii letters and digits, no empty tokens\n    sep_escaped = re.escape(separator)\n    pattern = (\n        r'^[a-z0-9]+(?:' + sep_escaped + r'[a-z0-9]+)*$'\n    )\n\n    return re.match(pattern, input_string) is not None", "message": "passed", "passed": true}
{"task_id": 30, "prediction_id": 4, "generation": "from typing import Any\nfrom string_utils.validation import is_full_string\n\n\ndef is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    # A slug is a non-empty string consisting only of lowercase letters, digits, and the separator\n    # It must not start or end with the separator, and separators must not occur consecutively.\n    if not is_full_string(input_string):\n        return False\n\n    if not isinstance(separator, str) or separator == '':\n        # Invalid separator makes it impossible to validate properly\n        return False\n\n    # Allowed characters: lowercase letters, digits, and the separator\n    # Build a regex pattern dynamically based on separator\n    import re\n\n    # Escape separator for regex pattern\n    sep_escaped = re.escape(separator)\n\n    # Pattern explanation:\n    # ^             : start of string\n    # [a-z0-9]+     : one or more lowercase letters or digits\n    # (sep [a-z0-9]+)* : zero or more groups of (separator + one or more lowercase letters or digits)\n    # $             : end of string\n    pattern = rf'^[a-z0-9]+({sep_escaped}[a-z0-9]+)*$'\n\n    return re.match(pattern, input_string) is not None", "message": "passed", "passed": true}
