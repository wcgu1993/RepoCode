{"task_id": 165, "prediction_id": 0, "generation": "import typing as T\nfrom collections import OrderedDict\nimport inspect\nimport re\n\n# Re-declare or import needed classes/types from the provided file context\nclass Docstring:\n    \"\"\"Placeholder for the actual Docstring class to hold parsed elements.\"\"\"\n\n    def __init__(self):\n        self.short_description: T.Optional[str] = None\n        self.long_description: T.Optional[str] = None\n        self.blank_after_short_description: bool = False\n        self.blank_after_long_description: bool = False\n        self.meta: T.List = []\n\nclass ParseError(Exception):\n    pass\n\nclass SectionType(int):\n    SINGULAR = 0\n    MULTIPLE = 1\n    SINGULAR_OR_MULTIPLE = 2\n\nclass Section(T.NamedTuple):\n    title: str\n    key: str\n    type: SectionType\n\n# Re-define DEFAULT_SECTIONS as per file content to align GoogleParser's defaults\nDEFAULT_SECTIONS = [\n    Section(\"Arguments\", \"param\", SectionType.MULTIPLE),\n    Section(\"Args\", \"param\", SectionType.MULTIPLE),\n    Section(\"Parameters\", \"param\", SectionType.MULTIPLE),\n    Section(\"Params\", \"param\", SectionType.MULTIPLE),\n    Section(\"Raises\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Exceptions\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Except\", \"raises\", SectionType.MULTIPLE),\n    Section(\"Attributes\", \"attribute\", SectionType.MULTIPLE),\n    Section(\"Example\", \"examples\", SectionType.SINGULAR),\n    Section(\"Examples\", \"examples\", SectionType.SINGULAR),\n    Section(\"Returns\", \"returns\", SectionType.SINGULAR_OR_MULTIPLE),\n    Section(\"Yields\", \"yields\", SectionType.SINGULAR_OR_MULTIPLE),\n]\n\n# Regular expressions copied from file content\nMULTIPLE_PATTERN = re.compile(r\"(\\s*[^:\\s]+:)|([^:]*\\]:.*)\")\n\nGOOGLE_TYPED_ARG_REGEX = re.compile(r\"\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)\")\nGOOGLE_ARG_DESC_REGEX = re.compile(r\".*\\. Defaults to (.+)\\.\")\n\nPARAM_KEYWORDS = {\"param\"}\nRAISES_KEYWORDS = {\"raises\"}\nRETURNS_KEYWORDS = {\"returns\"}\nYIELDS_KEYWORDS = {\"yields\"}\n\n# Minimal DocstringMeta and related classes as per file content's logic\nclass DocstringMeta:\n    def __init__(self, args, description):\n        self.args = args\n        self.description = description\n\nclass DocstringParam(DocstringMeta):\n    def __init__(self, args, description, arg_name, type_name, is_optional, default):\n        super().__init__(args, description)\n        self.arg_name = arg_name\n        self.type_name = type_name\n        self.is_optional = is_optional\n        self.default = default\n\nclass DocstringReturns(DocstringMeta):\n    def __init__(self, args, description, type_name=None, is_generator=False):\n        super().__init__(args, description)\n        self.type_name = type_name\n        self.is_generator = is_generator\n\nclass DocstringRaises(DocstringMeta):\n    def __init__(self, args, description, type_name=None):\n        super().__init__(args, description)\n        self.type_name = type_name\n\n\nclass GoogleParser:\n    def __init__(\n        self, sections: T.Optional[T.List[Section]] = None, title_colon=True\n    ):\n        if not sections:\n            sections = DEFAULT_SECTIONS\n        self.sections = {s.title: s for s in sections}\n        self.title_colon = title_colon\n        self._setup()\n\n    def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )\n\n    def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)\n\n    def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected parameter name.\")\n        return DocstringMeta(args=[section.key], description=desc)\n\n    def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)\n\n    def parse(self, text: str) -> Docstring:\n        ret = Docstring()\n        if not text:\n            return ret\n\n        text = inspect.cleandoc(text)\n\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start():]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\"\\n\")\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        for title, chunk in chunks.items():\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError(f\"Can't infer indent from \\\"{chunk}\\\"\")\n            indent = indent_match.group()\n\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(f'No specification for \"{title}\": \"{chunk}\"')\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    parser = GoogleParser()\n    return parser.parse(text)", "message": "passed", "passed": true}
{"task_id": 165, "prediction_id": 1, "generation": "from docstring_parser.google import GoogleParser\nfrom docstring_parser.common import Docstring\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    parser = GoogleParser()\n    return parser.parse(text)", "message": "passed", "passed": true}
{"task_id": 165, "prediction_id": 2, "generation": "from docstring_parser.google import GoogleParser\nfrom docstring_parser.common import Docstring\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    parser = GoogleParser()\n    return parser.parse(text)", "message": "passed", "passed": true}
{"task_id": 165, "prediction_id": 3, "generation": "from docstring_parser.google import GoogleParser\nfrom docstring_parser.common import Docstring\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    parser = GoogleParser()\n    return parser.parse(text)", "message": "passed", "passed": true}
{"task_id": 165, "prediction_id": 4, "generation": "from docstring_parser.google import GoogleParser\nfrom docstring_parser.common import Docstring\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    parser = GoogleParser()\n    return parser.parse(text)", "message": "passed", "passed": true}
