{"task_id": 166, "prediction_id": 0, "generation": "import re\nimport typing as T\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\nfrom .rest import _build_meta\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    if not text:\n        return Docstring(short_description=None, long_description=None, meta=[])\n\n    # Normalize line endings and split into lines\n    lines = text.expandtabs().splitlines()\n\n    # Separate short_description, long_description, and meta sections\n    # According to ReST conventions, short description is the first non-empty line or paragraph,\n    # then an optional blank line, then long description (paragraphs before any field list),\n    # followed by optional field lists (meta).\n\n    short_description = None\n    long_description_lines = []\n    meta_lines = []\n\n    # State machine: 0=collect short desc, 1=collect long desc, 2=collect meta\n    state = 0\n\n    # Helper to detect if a line starts a field list directive (e.g. \":param\")\n    field_list_re = re.compile(r\"^:(\\w+)(?:\\s+[^:]*)?:\")  # matches e.g. \":param foo:\", \":returns:\", \":raises Exception:\"\n\n    buffer = []  # buffer lines of current paragraph\n\n    def flush_buffer_to_long_description():\n        nonlocal long_description_lines, buffer\n        if buffer:\n            if long_description_lines:\n                long_description_lines.append(\"\")\n            long_description_lines.extend(buffer)\n            buffer = []\n\n    for i, line in enumerate(lines):\n        stripped = line.strip()\n\n        if state == 0:\n            # Skip blank lines at the start\n            if not stripped:\n                continue\n            # first paragraph is short description until blank line\n            buffer.append(stripped)\n            # Look ahead to see if next line is blank or absent - if yes, short desc done\n            next_is_blank = (i + 1 >= len(lines)) or (lines[i + 1].strip() == \"\")\n            if next_is_blank:\n                short_description = \" \".join(buffer)\n                buffer = []\n                state = 1\n            # else keep accumulating short description lines (if spread across multiple lines)\n        elif state == 1:\n            # Collect long description lines until blank line before meta\n            if not stripped:\n                # blank line indicates paragraph separation or end of long desc\n                if buffer:\n                    flush_buffer_to_long_description()\n                # After blank line, if next non-blank line starts with colon, start meta\n                # peek ahead\n                peek_j = i + 1\n                while peek_j < len(lines) and lines[peek_j].strip() == \"\":\n                    peek_j += 1\n                if peek_j < len(lines) and field_list_re.match(lines[peek_j].lstrip()):\n                    state = 2\n                else:\n                    # keep long description accumulating blank lines as paragraph separation\n                    # Long description can have multiple paragraphs separated by blank lines\n                    long_description_lines.append(\"\")\n            else:\n                # Check if this line is start of meta section (field list)\n                if field_list_re.match(line.lstrip()):\n                    if buffer:\n                        flush_buffer_to_long_description()\n                    state = 2\n                    meta_lines.append(line)\n                else:\n                    buffer.append(line)\n        else:\n            # state == 2, meta lines\n            meta_lines.append(line)\n\n    # If finished parsing but buffer non-empty and in long description\n    if state == 1 and buffer:\n        flush_buffer_to_long_description()\n\n    # Clean long_description text\n    long_description = None\n    if long_description_lines:\n        # Remove trailing blank lines\n        while long_description_lines and long_description_lines[-1].strip() == \"\":\n            long_description_lines.pop()\n        long_description = \"\\n\".join(long_description_lines) if long_description_lines else None\n\n    meta: T.List[DocstringMeta] = []\n\n    # Parse meta_lines into DocstringMeta objects\n    # Meta lines may contain multiple field entries.\n    # The format generally is:\n    #   :keyword [type] name: description...\n    # We must parse each directive line and collect continuation lines indented.\n\n    # Group meta lines by entries starting with ':keyword'\n    entries = []\n    current_entry_lines = []\n\n    for line in meta_lines:\n        if re.match(r\"^:\\w+\", line.lstrip()):\n            # new entry starts\n            if current_entry_lines:\n                entries.append(current_entry_lines)\n            current_entry_lines = [line]\n        else:\n            # continuation line for current meta entry (usually indented)\n            if current_entry_lines:\n                current_entry_lines.append(line)\n            else:\n                # strange case: continuation with no current entry - ignore or treat as normal?\n                # We ignore dangling lines outside meta entry\n                pass\n    if current_entry_lines:\n        entries.append(current_entry_lines)\n\n    # Helper to parse one meta entry block into args and description\n    for entry_lines in entries:\n        # The first line contains the field keyword and its arguments, e.g.\n        # \":param int foo: description\"\n        first_line = entry_lines[0].lstrip()\n\n        # match keyword and args up to colon\n        m = re.match(r\"^:(\\w+)(?:\\s+(.*?))?:\\s*(.*)$\", first_line)\n        if not m:\n            # Doesn't match expected pattern, ignore or treat as generic meta\n            # We'll store whole lines as description, with args = [first word]\n            args = [first_line[1:].split()[0]]\n            desc = \"\\n\".join(line.strip() for line in entry_lines[1:])\n            meta.append(DocstringMeta(args=args, description=desc))\n            continue\n\n        key_word = m.group(1)\n        args_str = m.group(2) or \"\"\n        initial_desc = m.group(3)\n\n        # Compose args list: key_word + split args_str by whitespace (but keep sequence intact)\n        args: T.List[str] = [key_word]\n        if args_str:\n            args.extend(args_str.split())\n\n        # Description possibly continues in subsequent indented lines\n        # Join description lines, stripping leading whitespace (usual reST indent is 3 or more)\n        continuation_desc = []\n        for cont_line in entry_lines[1:]:\n            # Strip at most 4 spaces from continuation lines (typical indent)\n            continuation_desc.append(cont_line.lstrip(\" \\t\"))\n        full_desc = initial_desc\n        if continuation_desc:\n            if full_desc:\n                full_desc += \"\\n\" + \"\\n\".join(continuation_desc)\n            else:\n                full_desc = \"\\n\".join(continuation_desc)\n\n        try:\n            meta_obj = _build_meta(args, full_desc)\n        except ParseError:\n            meta_obj = DocstringMeta(args=args, description=full_desc)\n\n        meta.append(meta_obj)\n\n    return Docstring(\n        short_description=short_description if short_description else None,\n        long_description=long_description,\n        meta=meta,\n    )", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 111, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 166, "prediction_id": 1, "generation": "import re\nfrom typing import List\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\nfrom .rest import _build_meta\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    if not text:\n        # Empty docstring, return empty Docstring object with no content\n        return Docstring(\"\", [], [], [], [])\n\n    lines = text.splitlines()\n\n    short_description_lines: List[str] = []\n    long_description_lines: List[str] = []\n    meta_blocks: List[str] = []\n\n    # States to track parsing phases\n    in_short_desc = True\n    in_long_desc = False\n    in_meta = False\n\n    # Regex to detect meta lines (e.g. :param int foo: description)\n    meta_line_re = re.compile(r\"^:(\\w+)\")  # start with colon + word\n\n    # We will gather meta blocks that start with colon-prefixed lines\n    # A meta block can be multiple lines: first line with \":param ...\" then indented description lines\n\n    i = 0\n    n = len(lines)\n\n    # Step 1: Extract short description: first non-empty lines until an empty line or a meta line\n    while i < n:\n        line = lines[i]\n        stripped = line.strip()\n        if stripped == \"\":\n            # blank line ends short description\n            i += 1\n            if short_description_lines:\n                # Only end short desc if we have contents\n                break\n            # else continue skipping leading blank lines\n        elif meta_line_re.match(stripped):\n            # meta section start before short description ends means no short description\n            break\n        else:\n            short_description_lines.append(stripped)\n            i += 1\n\n    # Step 2: Extract long description: lines after short desc until meta or EOF\n    # Skip any blank lines right after short desc\n    while i < n and lines[i].strip() == \"\":\n        i += 1\n\n    # Collect lines until next meta or end\n    while i < n:\n        line = lines[i]\n        stripped = line.strip()\n        if meta_line_re.match(stripped):\n            break\n        long_description_lines.append(line)\n        i += 1\n\n    # Step 3: Extract meta blocks lines (starting at i)\n    # Each meta block begins with a line starting with \":\" and continues with indented lines\n    meta_blocks_lines = []\n    while i < n:\n        line = lines[i]\n        if not line.strip():\n            # blank lines inside meta blocks separate them, keep as some empty line\n            meta_blocks_lines.append(\"\")\n            i += 1\n            continue\n\n        if meta_line_re.match(line.strip()):\n            # start of a new meta block\n            block = [line.strip()]\n            i += 1\n            # collect following lines that are indented (start with space or tab)\n            while i < n:\n                next_line = lines[i]\n                if next_line.strip() == \"\":\n                    block.append(\"\")\n                    i += 1\n                elif next_line.startswith(\" \") or next_line.startswith(\"\\t\"):\n                    # continuation line (description continuation)\n                    block.append(next_line.strip())\n                    i += 1\n                else:\n                    break\n            meta_blocks_lines.append(\"\\n\".join(block))\n        else:\n            # unexpected line not starting with \":\"\n            # May be continuation but no indent, just break\n            i += 1\n\n    # Parse meta blocks lines into DocstringMeta (DocstringParam, DocstringReturns, etc)\n    meta: List[DocstringMeta] = []\n    for block in meta_blocks_lines:\n        if not block.strip():\n            # skip empty blocks\n            continue\n        # The first line contains the metadata keyword and optional arguments and description after colon\n        # example: \":param int foo: the foo parameter\"\n        # Extract args inside \":param int foo:\" and description text after colon:\n        # Match pattern of form \":keyword [args...]: description\"\n        m = re.match(r\"^:(\\w+)\\s*(.*?)\\s*:(.*)$\", block, flags=re.DOTALL)\n        if not m:\n            raise ParseError(f\"Unable to parse meta directive: {block!r}\")\n\n        key = m.group(1)\n        args_str = m.group(2).strip()\n        desc = m.group(3).strip()\n\n        # The block may have continuation lines in desc, appended after first line's desc\n        # The block lines after first line are after first line's desc\n        # For now desc should contain all continuation lines joined by space or newlines.\n        # But since we stripped and joined lines with '\\n', let's preserve \\n in desc\n\n        # Actually desc may contain newlines due to the block join with \\n, so better to\n        # re-collect desc lines after colon line\n\n        desc_lines = [desc]\n        block_lines = block.splitlines()\n        # first line is \":keyword args: desc\"\n        # continuation lines start at line index 1\n        for cont_line in block_lines[1:]:\n            if cont_line.strip():\n                desc_lines.append(cont_line.strip())\n            else:\n                desc_lines.append(\"\")\n\n        full_desc = \"\\n\".join(desc_lines).strip()\n\n        # Arguments can be split by spaces, e.g. \"int foo\" -> ['int', 'foo']\n        # But the _build_meta expects a list with first element = key\n        # number of args depends on the key and format:\n        # param -> :param [type] name:\n        # returns -> :returns [type]:\n        # raises -> :raises [type]:\n        # yields -> :yields [type]:\n\n        # split args_str on spaces to get arguments (might be empty)\n        args = [key]\n        if args_str:\n            args.extend(args_str.split())\n\n        try:\n            meta_obj = _build_meta(args, full_desc)\n        except ParseError as e:\n            raise ParseError(f\"{e} (in meta block: {block!r})\") from e\n\n        meta.append(meta_obj)\n\n    short_description = \"\\n\".join(short_description_lines).strip() or None\n    long_description = \"\\n\".join(long_description_lines).strip() or None\n\n    return Docstring(\n        short_description=short_description,\n        long_description=long_description,\n        params=[m for m in meta if isinstance(m, DocstringParam)],\n        returns=next((m for m in meta if isinstance(m, DocstringReturns)), None),\n        raises=[m for m in meta if isinstance(m, DocstringRaises)],\n        meta=[m for m in meta if not isinstance(m, (DocstringParam, DocstringReturns, DocstringRaises))],\n    )", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 111, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 166, "prediction_id": 2, "generation": "import re\nfrom typing import List, Optional\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\nfrom .rest import _build_meta\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.expandtabs().splitlines()\n    lines = [line.rstrip() for line in lines]\n\n    short_descr_lines: List[str] = []\n    long_descr_lines: List[str] = []\n    meta_lines: List[str] = []\n\n    state = \"short_descr\"  # states: short_descr, blank_after_short_descr, long_descr, meta\n    meta_indent: Optional[int] = None\n\n    for index, line in enumerate(lines):\n        stripped = line.lstrip()\n        indent = len(line) - len(stripped)\n\n        # Detect meta lines which start with ':'\n        if stripped.startswith(\":\"):\n            state = \"meta\"\n            # Capture the indent level for meta lines to detect continuation lines\n            meta_indent = indent\n            meta_lines.append(line)\n            continue\n\n        if state == \"short_descr\":\n            if not line.strip():\n                state = \"blank_after_short_descr\"\n            else:\n                short_descr_lines.append(line)\n        elif state == \"blank_after_short_descr\":\n            if not line.strip():\n                # consecutive blank lines after short descr, continue waiting\n                continue\n            elif stripped.startswith(\":\"):\n                # first meta line after short descr\n                state = \"meta\"\n                meta_indent = indent\n                meta_lines.append(line)\n            else:\n                # non-meta line means start of long description\n                state = \"long_descr\"\n                long_descr_lines.append(line)\n        elif state == \"long_descr\":\n            if not line.strip():\n                long_descr_lines.append(line)\n            elif stripped.startswith(\":\"):\n                state = \"meta\"\n                meta_indent = indent\n                meta_lines.append(line)\n            else:\n                long_descr_lines.append(line)\n        elif state == \"meta\":\n            # Handle continuation lines indented more than meta_indent\n            if line.strip() == \"\":\n                # Blank lines inside meta treated as separation? Include to keep descriptions multi-line\n                meta_lines.append(line)\n            elif indent > meta_indent:\n                meta_lines.append(line)\n            else:\n                # New meta line or end\n                if stripped.startswith(\":\"):\n                    meta_indent = indent\n                    meta_lines.append(line)\n                else:\n                    # Not a meta line and not indented more - probably invalid or descriptive paragraph\n                    # In practice, this is ignored or treated as invalid meta, but we treat as meta line continuation if rare.\n                    meta_lines.append(line)\n\n    # Compose short and long descriptions, join lines preserving blank lines (empty lines)\n    # Strip trailing empty lines\n    while short_descr_lines and not short_descr_lines[-1].strip():\n        short_descr_lines.pop()\n    short_description = \"\\n\".join(short_descr_lines).strip()\n\n    while long_descr_lines and not long_descr_lines[-1].strip():\n        long_descr_lines.pop()\n    long_description = \"\\n\".join(long_descr_lines).strip()\n\n    # Parse meta lines into DocstringMeta objects\n    meta: List[DocstringMeta] = []\n    if meta_lines:\n        # Join meta lines into logical blocks\n        blocks: List[List[str]] = []\n        current_block: List[str] = []\n\n        for line in meta_lines:\n            stripped = line.lstrip()\n            if stripped.startswith(\":\"):\n                # Start of new block\n                if current_block:\n                    blocks.append(current_block)\n                current_block = [line]\n            else:\n                # continuation line, add to current block\n                if current_block:\n                    current_block.append(line)\n                else:\n                    # stray continuation line before any meta, ignore or start new (unlikely)\n                    current_block = [line]\n        if current_block:\n            blocks.append(current_block)\n\n        # Process each block\n        for block_lines in blocks:\n            # Merge block lines into a single string\n            # The first line starts with \":\" which introduces a field\n            first_line = block_lines[0].lstrip()\n            # Extract the key and args from the first line: pattern :key[arg1 arg2]: description\n            # We can match pattern: ^:(\\w+)([^\\:]*)\\:(.*)$\n            m = re.match(r\"^:(\\w+)([^:]*)\\:(.*)$\", first_line)\n            if not m:\n                raise ParseError(f\"Malformed field line: {first_line}\")\n\n            key = m.group(1)\n            args_part = m.group(2).strip()\n            desc_part = m.group(3).lstrip()\n\n            # Extract arguments separated by spaces (but keep quoted? No quotes used in ReST by default)\n            args = [key] + args_part.split() if args_part else [key]\n\n            # Description includes desc_part plus continuation lines unindented relative to first line\n            if len(block_lines) > 1:\n                # strip the indentation from continuation lines\n                continuation = []\n                # Determine minimum indentation of continuation lines (ignore empty lines)\n                cont_lines = block_lines[1:]\n                min_indent = None\n                for cont_line in cont_lines:\n                    if cont_line.strip():\n                        ind = len(cont_line) - len(cont_line.lstrip())\n                        if min_indent is None or ind < min_indent:\n                            min_indent = ind\n                if min_indent is None:\n                    min_indent = 0\n                for cont_line in cont_lines:\n                    # de-indent by min_indent\n                    if len(cont_line) >= min_indent:\n                        continuation.append(cont_line[min_indent:])\n                    else:\n                        continuation.append(cont_line.lstrip())\n                continuation_text = \"\\n\".join(continuation).rstrip()\n                if continuation_text:\n                    if desc_part:\n                        desc = desc_part + \"\\n\" + continuation_text\n                    else:\n                        desc = continuation_text\n                else:\n                    desc = desc_part\n            else:\n                desc = desc_part\n\n            # Build the meta object using _build_meta\n            meta_obj = _build_meta(args, desc)\n            meta.append(meta_obj)\n\n    return Docstring(\n        short_description=short_description,\n        long_description=long_description,\n        meta=meta,\n    )", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 111, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 166, "prediction_id": 3, "generation": "import re\nfrom typing import List\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    DocstringMeta,\n    ParseError,\n)\nfrom .rest import _build_meta\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    # Normalize line endings and split lines\n    lines = text.expandtabs().splitlines()\n    # Strip trailing and leading empty lines\n    while lines and lines[0].strip() == \"\":\n        lines.pop(0)\n    while lines and lines[-1].strip() == \"\":\n        lines.pop()\n\n    summary_lines = []\n    extended_desc_lines = []\n    meta_lines = []\n\n    # States for parsing\n    # 0 = parsing summary (first paragraph)\n    # 1 = parsing extended description (after first blank line)\n    # 2 = parsing meta block (lines starting with :keyword: etc)\n    state = 0\n\n    # We will join meta lines into blocks separated by blank lines\n    # to parse individual meta entries independently\n    # Accumulate meta blocks as lists of lines\n    meta_blocks = []\n    current_meta_block = []\n\n    # A regex to detect meta keywords lines like: \":param str name: ...\"\n    meta_re = re.compile(r\"^:([^:\\s]+)(?:\\s+([^:]*?))?(?:\\s+([^:]+?))?:\\s*(.*)\")\n\n    # Process lines to separate summary, extended desc and meta blocks\n    line_iter = iter(lines)\n    for line in line_iter:\n        stripped = line.strip()\n\n        if state == 0:\n            # Accumulate summary lines until first blank line\n            if stripped == \"\":\n                # blank line ends summary\n                state = 1\n            else:\n                summary_lines.append(line)\n        elif state == 1:\n            # After summary, accumulate extended description lines until blank line preceding meta or meta line\n            if stripped == \"\":\n                # blank line, continue extended description lines\n                extended_desc_lines.append(line)\n            elif meta_re.match(stripped):\n                # meta block starts\n                state = 2\n                current_meta_block.append(line)\n            else:\n                # Any other non-blank non-meta line belongs to extended description\n                extended_desc_lines.append(line)\n        else:  # state == 2 (parsing meta)\n            if stripped == \"\":\n                # blank line denotes end of current meta block\n                if current_meta_block:\n                    meta_blocks.append(current_meta_block)\n                    current_meta_block = []\n            else:\n                # continuation or new meta line\n                # if line starts with colon + keyword, it's a new meta entry\n                if meta_re.match(stripped):\n                    if current_meta_block:\n                        meta_blocks.append(current_meta_block)\n                    current_meta_block = [line]\n                else:\n                    # continuation line, indent or not, join to last meta block line\n                    current_meta_block.append(line)\n\n    # Append any remaining meta block\n    if current_meta_block:\n        meta_blocks.append(current_meta_block)\n\n    # Join summary and extended description\n    summary = \"\\n\".join(summary_lines).strip()\n    extended_description = \"\\n\".join(extended_desc_lines).strip()\n\n    params: List[DocstringParam] = []\n    returns = None\n    yields = None\n    raises: List[DocstringRaises] = []\n    metas: List[DocstringMeta] = []\n\n    # Helper to parse each meta block into DocstringMeta subclass\n    for block_lines in meta_blocks:\n        # Join block lines with newlines to a single string, then split first line for keys\n        first_line = block_lines[0]\n        m = meta_re.match(first_line.strip())\n        if not m:\n            # If no match, ignore this block (should not happen)\n            continue\n        keyword, arg1, arg2, desc = m.groups()\n        # Compose args list\n        args = [keyword]\n        if arg1 is not None and arg1 != \"\":\n            args.append(arg1)\n        if arg2 is not None and arg2 != \"\":\n            args.append(arg2)\n\n        # Join continuation lines into description\n        if len(block_lines) > 1:\n            # continuation lines: join them preserving newline and indentation\n            desc_lines = [desc] + [line.strip() for line in block_lines[1:]]\n            desc = \"\\n\".join(desc_lines).strip()\n        else:\n            desc = desc.strip()\n\n        # Use _build_meta to parse this entry\n        try:\n            meta = _build_meta(args, desc)\n        except ParseError:\n            # If parsing fails, treat as generic meta\n            meta = DocstringMeta(args=args, description=desc)\n\n        # Collect meta according to type\n        if isinstance(meta, DocstringParam):\n            params.append(meta)\n        elif isinstance(meta, DocstringReturns):\n            returns = meta\n        elif isinstance(meta, DocstringReturns) and meta.is_generator:\n            yields = meta\n        elif isinstance(meta, DocstringRaises):\n            raises.append(meta)\n        else:\n            metas.append(meta)\n\n    return Docstring(\n        short_description=summary,\n        long_description=extended_description if extended_description else None,\n        params=params,\n        returns=returns,\n        yields=yields,\n        raises=raises,\n        metas=metas,\n    )", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 111, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 166, "prediction_id": 4, "generation": "import re\nimport typing as T\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\nfrom .rest import _build_meta\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    lines = text.strip().splitlines()\n    short_description_lines = []\n    long_description_lines = []\n    metas: T.List[DocstringMeta] = []\n\n    # Stage tracking:\n    # 0 = before first blank line (short description)\n    # 1 = after first blank line (long description or metas)\n    # 2 = after metas started\n    stage = 0\n\n    # Buffer for lines belonging to a meta entry we are parsing\n    meta_lines: T.List[str] = []\n\n    def flush_meta():\n        \"\"\"Parse the buffered meta lines and add to metas if any.\"\"\"\n        if not meta_lines:\n            return\n        first_line = meta_lines[0]\n        # Meta lines start with ':' and have the form:\n        # :key [type] name: description\n        m = re.match(r\"^:([^:]+):\\s*(.*)$\", first_line)\n        if not m:\n            # Not a meta, ignore buffer\n            meta_lines.clear()\n            return\n        key_args_part = m.group(1).strip()  # e.g. \"param int foo\"\n        desc_part = m.group(2).strip()  # first line description part\n\n        # Split key_args_part by whitespace but respecting brackets and question marks in types\n        # Usually, these are like \"param int foo\" or \"param foo\"\n\n        # A simple split is ok if we assume no spaces inside type names\n        args = key_args_part.split()\n        # Append remaining description lines\n        if len(meta_lines) > 1:\n            desc_full = desc_part + \"\\n\" + \"\\n\".join(line.strip() for line in meta_lines[1:])\n        else:\n            desc_full = desc_part\n\n        try:\n            meta = _build_meta(args, desc_full)\n            metas.append(meta)\n        except ParseError:\n            # In case of parse error, ignore this meta\n            pass\n        meta_lines.clear()\n\n    for line in lines:\n        stripped = line.strip()\n        if stage == 0:\n            if stripped == \"\":\n                # End of short description\n                stage = 1\n            else:\n                short_description_lines.append(stripped)\n        elif stage == 1:\n            if stripped == \"\":\n                # Blank lines separate sections, continue gathering long description lines\n                long_description_lines.append(\"\")\n            elif stripped.startswith(\":\"):\n                # Meta entry starts\n                flush_meta()\n                meta_lines.append(line)\n                stage = 2\n            else:\n                long_description_lines.append(stripped)\n        else:  # stage == 2, parsing metas\n            if stripped.startswith(\":\"):\n                flush_meta()\n                meta_lines.append(line)\n            else:\n                # Continuation line for meta description (indented or blank line)\n                # Append original line preserving indentation for multi-line description\n                meta_lines.append(line)\n\n    # Flush any remaining meta lines after loop ends\n    flush_meta()\n\n    short_description = (\n        \" \".join(short_description_lines).strip() if short_description_lines else None\n    )\n    if long_description_lines:\n        # Normalize long description: join lines by newlines; preserve paragraphs as blank lines\n        long_description = \"\\n\".join(long_description_lines).strip()\n    else:\n        long_description = None\n\n    return Docstring(\n        short_description=short_description,\n        long_description=long_description,\n        meta=metas,\n    )", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 111, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
