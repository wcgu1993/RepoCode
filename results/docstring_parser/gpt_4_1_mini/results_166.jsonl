{"task_id": 166, "prediction_id": 0, "generation": "import typing as T\nfrom docstring_parser.common import Docstring, ParseError\nfrom docstring_parser.rest import _build_meta\nimport re\nimport inspect\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    # Normalize and split input text into lines\n    lines = text.expandtabs().splitlines()\n    lines = [line.rstrip() for line in lines]\n\n    docstring = Docstring()\n    docstring.meta = []\n\n    if not lines:\n        return docstring\n\n    # State variables\n    short_desc_lines = []\n    long_desc_lines = []\n    cur_meta_lines = []\n    cur_meta_args: T.Optional[T.List[str]] = None\n\n    # A line indicates metadata start if it starts with `:`\n    # For example: \":param arg: description\"\n    # Pattern to parse the metadata directive line (e.g. \":param int foo:\")\n    meta_line_re = re.compile(r\"^:(?P<key>[a-zA-Z0-9-]+)(?P<args>[^:]*)\\s*:(?P<desc>.*)$\")\n\n    # First pass: separate short description, long description, and meta blocks\n    # Convention:\n    # - Short description is the initial non-empty line(s) before first blank line\n    # - Long description starts from first blank line after short description till before meta section or end\n    # - Meta sections start at lines beginning with ':', may have indented continuation lines\n\n    # Find the line index where meta directives start (if any)\n    meta_start_idx = None\n    for idx, line in enumerate(lines):\n        if line.lstrip().startswith(\":\"):\n            meta_start_idx = idx\n            break\n\n    # If meta lines found, process different parts accordingly\n    if meta_start_idx is not None:\n        # Short and long description lines are everything before meta_start_idx\n        desc_block_lines = lines[:meta_start_idx]\n        meta_lines = lines[meta_start_idx:]\n    else:\n        # No meta lines, all is description\n        desc_block_lines = lines\n        meta_lines = []\n\n    # Extract short and long description from desc_block_lines\n    # Short description: lines from start up to first blank line\n    # Long description: lines after the first blank line (ignoring leading blank lines)\n    first_blank_idx = None\n    for i, line in enumerate(desc_block_lines):\n        if line.strip() == \"\":\n            first_blank_idx = i\n            break\n\n    if first_blank_idx is None:\n        # No blank line found, all lines form the short description\n        short_desc_lines = desc_block_lines\n        long_desc_lines = []\n    else:\n        short_desc_lines = desc_block_lines[:first_blank_idx]\n        long_desc_lines = desc_block_lines[first_blank_idx + 1 :]\n\n    # Assign short_description and long_description, stripping leading/trailing blanks and cleaning indent\n    if short_desc_lines:\n        docstring.short_description = \"\\n\".join(short_desc_lines).strip()\n    else:\n        docstring.short_description = None\n\n    # For long description, join lines, remove uniform indentation\n    if long_desc_lines:\n        # Use inspect.cleandoc to remove common indentation & trailing spaces\n        long_desc_text = \"\\n\".join(long_desc_lines)\n        long_desc_text = inspect.cleandoc(long_desc_text)\n        if long_desc_text.strip() != \"\":\n            docstring.long_description = long_desc_text\n        else:\n            docstring.long_description = None\n    else:\n        docstring.long_description = None\n\n    # Parse the meta lines (e.g. \":param x: description\")\n    # Meta lines may be multiline; lines indented relative to the first ':' line belong to previous meta entry\n\n    # We will group meta lines into blocks: each block starts with a line matching meta_line_re,\n    # and continues with subsequent indented lines (at least 1 space or tab)\n    meta_blocks: T.List[T.List[str]] = []\n\n    current_block: T.List[str] = []\n    for line in meta_lines:\n        if line.strip() == \"\":\n            # blank lines inside meta blocks are part of the previous block (append as is)\n            if current_block:\n                current_block.append(line)\n            continue\n\n        if meta_line_re.match(line):\n            # New meta block starts\n            if current_block:\n                meta_blocks.append(current_block)\n            current_block = [line]\n        else:\n            # Continuation line: must be indented relative to previous meta_line\n            # According to reST, continuation lines are indented (at least one space/tab)\n            if not current_block:\n                # malformed, a continuation line before any metadata line.\n                # Skip or treat as normal? We skip it\n                continue\n            # Check indentation (leading whitespace)\n            leading_ws = len(line) - len(line.lstrip())\n            if leading_ws > 0:\n                current_block.append(line)\n            else:\n                # Not indented, means probably a new meta start line without colon? \n                # Add current_block, start new?\n                # Best to append current block and restart\n                meta_blocks.append(current_block)\n                current_block = []\n                # This line doesn't start with colon and is not indented, ignore\n                # Or treat as an error? We'll skip it\n    if current_block:\n        meta_blocks.append(current_block)\n\n    # For each meta block, combine lines and parse key, args, description\n    for block_lines in meta_blocks:\n        # Join block lines; first line is :key arguments: description possibly multiline\n        # continuation lines are appended preserving new lines\n        # We'll reconstruct the entire block string by joining with newline, and strip trailing spaces\n        block_text = \"\\n\".join(block_lines)\n        # Split first line from continuation lines for parsing key and args\n        first_line = block_lines[0]\n        match = meta_line_re.match(first_line)\n        if not match:\n            # malformed, treat whole block as a generic meta with key=None and description all lines joined\n            docstring.meta.append(DocstringMeta(args=[], description=block_text))\n            continue\n        key = match.group(\"key\")\n        args_part = match.group(\"args\").strip()\n        first_desc_line = match.group(\"desc\").rstrip()\n\n        # Determine args list\n        # Args part might be empty or contain arguments, split on spaces\n        # Often like \"int foo\" or \"foo\"\n        args_list: T.List[str] = []\n        if args_part:\n            args_list = args_part.split()\n        # First argument is the key (e.g. param, returns, raises)\n        # The full args for _build_meta is [key] + args_list (or key + args + arg_name)\n        parsed_args = [key] + args_list\n\n        # The description lines after the first line (i.e. continuation lines) should be appended to the first_desc_line\n        if len(block_lines) > 1:\n            # continuation lines, join them with newlines preserving indentation as is\n            cont_lines = block_lines[1:]\n            cont_text = \"\\n\".join(cont_lines)\n            # Compose full description as first_desc_line + '\\n' + continuation\n            if first_desc_line:\n                full_desc = first_desc_line + \"\\n\" + inspect.cleandoc(cont_text)\n            else:\n                full_desc = inspect.cleandoc(cont_text)\n        else:\n            full_desc = first_desc_line\n\n        # Build the metadata object using _build_meta from rest module\n        try:\n            meta = _build_meta(parsed_args, full_desc)\n        except ParseError as e:\n            # If parsing fails, fallback to generic meta\n            meta = DocstringMeta(args=parsed_args, description=full_desc)\n        docstring.meta.append(meta)\n\n    return docstring", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 312, in <module>\n  File \"<string>\", line 311, in test_extra_10\nAssertionError\n", "passed": false}
{"task_id": 166, "prediction_id": 1, "generation": "import typing as T\nimport re\nimport inspect\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    # Normalize text and split into lines\n    lines = text.expandtabs().splitlines()\n\n    doc = Docstring()\n\n    # Strip leading and trailing blank lines\n    while lines and not lines[0].strip():\n        lines.pop(0)\n    while lines and not lines[-1].strip():\n        lines.pop()\n\n    if not lines:\n        return doc  # Empty docstring\n\n    # Extract short description\n    short_desc_lines = []\n    i = 0\n    while i < len(lines):\n        line = lines[i].strip()\n        if not line:\n            # blank line signals end of short description\n            break\n        if line.startswith(\":\"):\n            # tag line signals end of short description\n            break\n        short_desc_lines.append(line)\n        i += 1\n\n    doc.short_description = \" \".join(short_desc_lines) if short_desc_lines else None\n\n    # Determine if there's a blank line after short description\n    # Look ahead to next line if exists and is blank\n    if i < len(lines) and not lines[i].strip():\n        doc.blank_after_short_description = True\n        i += 1  # Skip blank line after short description\n    else:\n        doc.blank_after_short_description = False\n\n    # Extract long description lines until metadata starts (lines starting with ':')\n\n    long_desc_lines = []\n    while i < len(lines):\n        line = lines[i]\n        if line.strip().startswith(\":\"):\n            break\n        long_desc_lines.append(line)\n        i += 1\n\n    # Clean the long description using inspect.cleandoc to remove common indentation\n    long_desc_text = \"\\n\".join(long_desc_lines).rstrip()\n    if long_desc_text:\n        doc.long_description = inspect.cleandoc(long_desc_text)\n    else:\n        doc.long_description = None\n\n    # Determine if blank line after long description if any lines existed there\n    if long_desc_lines:\n        # Check if next line is blank\n        if i < len(lines) and not lines[i].strip():\n            doc.blank_after_long_description = True\n            i += 1\n        else:\n            doc.blank_after_long_description = False\n    else:\n        doc.blank_after_long_description = False\n\n    # Now parse metadata lines starting at i, which should be lines starting with ':' for meta entries\n    meta_lines = lines[i:]\n\n    # Parse the meta entries. Group lines by metadata entry starting with ':'\n    meta_entries = []  # List of tuples (start_line_index, line_content list)\n    current_entry_lines = []\n\n    for line in meta_lines:\n        if line.lstrip().startswith(\":\"):\n            # Start of a new meta entry\n            if current_entry_lines:\n                meta_entries.append(current_entry_lines)\n            current_entry_lines = [line]\n        else:\n            # continuation line, append if any\n            if current_entry_lines:\n                current_entry_lines.append(line)\n            # else ignore stray lines not belonging to meta entries\n\n    if current_entry_lines:\n        meta_entries.append(current_entry_lines)\n\n    # Parse each meta entry into DocstringMeta using _build_meta function from this file\n    # We must parse the key and args from the initial line, and collect description from rest lines\n\n    for entry_lines in meta_entries:\n        # First line should be like \":param int foo:\" or \":raises ValueError:\"\n        first_line = entry_lines[0].lstrip()\n        # Match pattern: :keyword (type)? argname? :\n        # The pattern: start with ':', then a key (sequence of letters), then possible args separated by spaces, then ':'\n        # e.g. \":param int foo:\", \":returns:\", \":raises ValueError:\"\n        m = re.match(r\":([^\\s:]+)\\s*([^:]*)\\s*:\", first_line)\n        if not m:\n            # fallback: treat entire line as key, no args, description empty for now\n            key = first_line[1:].rstrip(\":\").strip()\n            args = [key]\n            desc_lines = [line for line in entry_lines[1:]]\n            desc = \"\\n\".join(desc_lines).strip()\n            meta_obj = DocstringMeta(args=args, description=desc)\n            doc.meta.append(meta_obj)\n            continue\n\n        keyword = m.group(1)\n        args_text = m.group(2).strip()\n\n        # Split args by whitespace but keep complex types (like int foo)\n        # For param entries, args_text can be like \"int foo\" or \"foo\"\n        args = [keyword]\n        if args_text:\n            # further split args_text by spaces, but complication if args_text is \"int foo\"\n            # For ReST param, it's either:\n            # \":param foo:\"      -> args = ['param', 'foo']\n            # \":param int foo:\"  -> args = ['param', 'int', 'foo']\n            arg_parts = args_text.split()\n            args.extend(arg_parts)\n\n        # Rest lines after the first line form the description\n        desc_lines = entry_lines[1:]\n\n        # Also collect an initial description suffix on the first line after \":keyword args:\"\n        # For instance: \":param foo: description here\"\n        # The match above stops at the colon, but there may be description after, so check that:\n        after_colon_pos = first_line.find(\":\", m.end()-1)\n        desc_suffix = first_line[m.end():].strip()\n        if desc_suffix:\n            desc_lines = [desc_suffix] + desc_lines\n\n        # Combine description lines, dedent using inspect.cleandoc, preserving intentional indentations\n        desc_text = \"\\n\".join(desc_lines)\n        desc_cleaned = inspect.cleandoc(desc_text) if desc_text else \"\"\n\n        # Use _build_meta helper to build the right DocstringMeta subclass object\n        try:\n            meta_obj = _build_meta(args, desc_cleaned)\n        except ParseError:\n            # fallback: use generic DocstringMeta in case of parse errors\n            meta_obj = DocstringMeta(args=args, description=desc_cleaned)\n\n        doc.meta.append(meta_obj)\n\n    return doc", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 112, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 166, "prediction_id": 2, "generation": "import typing as T\nimport re\nimport inspect\n\nfrom .common import (\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    Docstring,\n    ParseError,\n)\nfrom .rest import _build_meta\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    # Normalize text: remove leading/trailing blank lines and unify line endings\n    if text is None:\n        text = \"\"\n    text = text.expandtabs().rstrip()\n\n    # Split text into lines for processing\n    lines = text.splitlines()\n\n    # Initialize the Docstring object\n    docstring = Docstring()\n\n    # States and containers\n    meta = []\n    short_desc_lines = []\n    long_desc_lines = []\n    current_section_lines = []\n    current_meta_key = None\n    current_meta_args = None\n    parsing_meta = False\n\n    # Patterns to identify metadata lines in ReST-style\n    # e.g. \":param foo:\", \":param int foo:\", \":raises ValueError:\", \":returns int:\"\n    meta_line_re = re.compile(\n        r\"^:(?P<key>\\w+)(?:\\s+(?P<type_or_name>[^:]+?))?(?:\\s+(?P<arg>[^:]+?))?:\\s*(?P<desc>.*)\"\n    )\n\n    # Actually, the above regex is too naive for multi-args keys like :param int foo:\n    # The rest docstring style is roughly :param <type> <arg_name>: desc\n    # Or :param <arg_name>: desc\n    # So we try two regex alternatives:\n    meta_line_re1 = re.compile(r\"^:(?P<key>\\w+)\\s+(?P<type_name>\\S+)\\s+(?P<arg_name>\\S+):\\s*(?P<desc>.*)\")\n    meta_line_re2 = re.compile(r\"^:(?P<key>\\w+)\\s+(?P<arg_name>\\S+):\\s*(?P<desc>.*)\")\n    meta_line_re3 = re.compile(r\"^:(?P<key>\\w+):\\s*(?P<desc>.*)\")\n\n    # Helper function to finish the current meta block and add it to meta list\n    def finish_meta_block():\n        nonlocal current_meta_key, current_meta_args, current_section_lines\n        if current_meta_key is not None and current_section_lines is not None:\n            desc_text = \"\\n\".join(current_section_lines).rstrip()\n            desc_text = inspect.cleandoc(desc_text)\n            try:\n                m = _build_meta(current_meta_args, desc_text)\n                meta.append(m)\n            except ParseError:\n                # fallback: add unparsed meta\n                meta.append(DocstringMeta(args=current_meta_args, description=desc_text))\n        current_meta_key = None\n        current_meta_args = None\n        current_section_lines = []\n\n    # First, we parse short description and long description:\n    # The short description is the first non-blank line(s) until a blank line appears\n    # Then the long description is the continuation until the first metadata line appears\n\n    # Step 1: extract short description lines\n    # We consider lines from start until first blank line or metadata line\n    i = 0\n    n = len(lines)\n    # Collect short description lines until a blank line or a metadata line is found\n    while i < n and lines[i].strip() == \"\":\n        i += 1\n    # Lines now at first non-empty line or end\n    while i < n:\n        line = lines[i]\n        if line.strip() == \"\":\n            # blank line ends short description\n            i += 1\n            break\n        # Check if line is a meta line start\n        if (meta_line_re1.match(line)\n                or meta_line_re2.match(line)\n                or meta_line_re3.match(line)):\n            break\n        short_desc_lines.append(line)\n        i += 1\n\n    # Step 2: extract long description lines until a meta line or end\n    while i < n:\n        line = lines[i]\n        if line.strip() == \"\":\n            long_desc_lines.append(line)\n            i += 1\n            continue\n        if (meta_line_re1.match(line)\n                or meta_line_re2.match(line)\n                or meta_line_re3.match(line)):\n            # start of meta section\n            break\n        long_desc_lines.append(line)\n        i += 1\n\n    # Set short_description and long_description\n    if short_desc_lines:\n        docstring.short_description = inspect.cleandoc(\"\\n\".join(short_desc_lines))\n    else:\n        docstring.short_description = None\n\n    if long_desc_lines:\n        longdesc = \"\\n\".join(long_desc_lines)\n        # long description may contain indented blocks, so use cleandoc\n        docstring.long_description = inspect.cleandoc(longdesc)\n    else:\n        docstring.long_description = None\n\n    # Count blank lines after short_description and long_description\n    # to set blank_after_short_description and blank_after_long_description flags\n    # by checking text after short_desc and long_desc sections\n    # Find the index in original lines where short_desc ends\n    sd_end_idx = 0\n    for j, line in enumerate(lines):\n        if line.strip() == \"\":\n            if j >= len(short_desc_lines):\n                sd_end_idx = j\n                break\n    else:\n        sd_end_idx = len(short_desc_lines)\n\n    # Blank after short description is if line at sd_end_idx is blank (should be True if it was a blank line)\n    docstring.blank_after_short_description = (\n        sd_end_idx < n and lines[sd_end_idx].strip() == \"\"\n    )\n\n    # Find if blank after long description exists\n    ld_end_idx = i  # line index where long description ended (start of meta)\n    # Check if the line at ld_end_idx (if any) is blank\n    docstring.blank_after_long_description = (\n        ld_end_idx < n and lines[ld_end_idx].strip() == \"\"\n    )\n\n    # Step 3: parse meta blocks from lines[i:] until end\n    # Meta blocks start with lines like :param ..., :raises ..., etc.\n    # Multi-line descriptions start indented lines after a meta line\n\n    # Iterate from current line until end\n    idx = i\n    current_meta_key = None\n    current_meta_args = None\n    current_section_lines = []\n\n    while idx < n:\n        line = lines[idx]\n        if line.strip() == \"\":\n            # blank line - separator or part of description of meta item\n            if current_meta_key is not None:\n                current_section_lines.append(line)\n            idx += 1\n            continue\n\n        # Check if line starts new meta block\n        m1 = meta_line_re1.match(line)\n        m2 = meta_line_re2.match(line)\n        m3 = meta_line_re3.match(line)\n\n        if m1:\n            # Finish previous block\n            finish_meta_block()\n            key = m1.group(\"key\")\n            type_name = m1.group(\"type_name\")\n            arg_name = m1.group(\"arg_name\")\n            desc = m1.group(\"desc\")\n            current_meta_key = key\n            # Following _build_meta expects args list with key and either arg_name or type_name and arg_name\n            # For param: key, type_name, arg_name\n            # For others, key + something else\n            # Use args accordingly:\n            if key in PARAM_KEYWORDS:\n                current_meta_args = [key, type_name, arg_name]\n            else:\n                # For raises, returns, yields, etc\n                # Just pass key and type_name as args\n                current_meta_args = [key, type_name]\n            current_section_lines = [desc] if desc else []\n            idx += 1\n            continue\n\n        elif m2:\n            finish_meta_block()\n            key = m2.group(\"key\")\n            arg_name = m2.group(\"arg_name\")\n            desc = m2.group(\"desc\")\n            current_meta_key = key\n            # args: key, arg_name\n            current_meta_args = [key, arg_name]\n            current_section_lines = [desc] if desc else []\n            idx += 1\n            continue\n\n        elif m3:\n            finish_meta_block()\n            key = m3.group(\"key\")\n            desc = m3.group(\"desc\")\n            current_meta_key = key\n            current_meta_args = [key]\n            current_section_lines = [desc] if desc else []\n            idx += 1\n            continue\n\n        # If line is indented (starts with space or tab), it continues the current meta description\n        if current_meta_key is not None and (line.startswith(\" \") or line.startswith(\"\\t\")):\n            current_section_lines.append(line)\n            idx += 1\n            continue\n\n        # If line is not recognized as meta and not indented for meta continuation, treat as stray line or end meta parsing\n        # We'll just append lines to long description as fallback if no meta_key active (unlikely here)\n        # Or break\n        break\n\n    # Finalize last meta block\n    finish_meta_block()\n\n    docstring.meta = meta\n\n    return docstring", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 112, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
{"task_id": 166, "prediction_id": 3, "generation": "import typing as T\nimport re\nimport inspect\n\nfrom docstring_parser.common import (\n    Docstring,\n    DocstringMeta,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    ParseError,\n)\nfrom docstring_parser.rest import _build_meta\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    # Initialize the Docstring object to fill\n    doc = Docstring()\n\n    # Normalize text by stripping leading/trailing blank lines\n    lines = text.expandtabs().splitlines()\n    while lines and lines[0].strip() == \"\":\n        lines.pop(0)\n    while lines and lines[-1].strip() == \"\":\n        lines.pop()\n    text = \"\\n\".join(lines)\n\n    # If the docstring is empty after stripping, return empty Docstring\n    if not text.strip():\n        return doc\n\n    # We want to parse ReST-style docstring structured with sections like:\n    # :param type name: description\n    # :raises ExceptionType: description\n    # :returns type: description\n    # etc.\n\n    # We'll parse line by line, grouping consecutive continuation lines of meta\n    # fields, and separate the short description, long description, and meta.\n\n    lines = text.splitlines()\n    n = len(lines)\n\n    short_description_lines = []\n    long_description_lines = []\n    meta_lines = []\n\n    # States:\n    #   0 - reading short description (first non-empty text cluster)\n    #   1 - reading long description (optional, after blank line following short desc)\n    #   2 - reading meta fields (lines starting with :keyword:)\n    state = 0\n\n    def is_meta_line(line: str) -> bool:\n        # Match lines starting with colon and keyword\n        return bool(re.match(r\"^\\s*:[^:]+?:\", line))\n\n    # For continuation lines (indented), detect by leading spaces > 0\n    def is_indented(line: str) -> bool:\n        return len(line) > 0 and (line[0] == \" \" or line[0] == \"\\t\")\n\n    i = 0\n    # Parse short description (continuous lines until first blank line)\n    while i < n:\n        line = lines[i]\n        if line.strip() == \"\":\n            # blank line means end of short description\n            i += 1\n            break\n        short_description_lines.append(line)\n        i += 1\n\n    # Parse long description (continuous until blank line before meta)\n    while i < n:\n        line = lines[i]\n        if is_meta_line(line):\n            # Start of meta section\n            state = 2\n            break\n        elif line.strip() == \"\":\n            # blank line: maybe separating long description paragraphs\n            long_description_lines.append(line)\n            i += 1\n            # Check if following lines are meta or not in next iteration\n            # If next line is meta, end long description parsing\n            if i < n and is_meta_line(lines[i]):\n                state = 2\n                break\n            continue\n        else:\n            long_description_lines.append(line)\n            i += 1\n\n    # For meta lines, group continuation lines with the initial meta line\n    # We'll collect blocks of lines, each block representing one meta element.\n\n    meta_blocks = []\n    current_block_lines = []\n\n    while i < n:\n        line = lines[i]\n        if is_meta_line(line):\n            # start new meta block\n            if current_block_lines:\n                meta_blocks.append(current_block_lines)\n            current_block_lines = [line]\n        else:\n            # continuation line or empty line within meta block\n            if current_block_lines and (line.strip() == \"\" or is_indented(line)):\n                current_block_lines.append(line)\n            else:\n                # If line isn't indented or empty and not meta line,\n                # treat as blank or ignore? According to ReST style,\n                # meta continuation lines must be indented or empty.\n                if current_block_lines:\n                    meta_blocks.append(current_block_lines)\n                    current_block_lines = []\n                # Else skip line or consider as error? We'll skip.\n        i += 1\n\n    # Append last collected meta block if any\n    if current_block_lines:\n        meta_blocks.append(current_block_lines)\n\n    # Fill short_description and long_description\n    short_description = \"\\n\".join(short_description_lines).strip() or None\n    long_description = inspect.cleandoc(\"\\n\".join(long_description_lines)).strip() or None\n\n    if long_description == \"\":\n        long_description = None\n\n    doc.short_description = short_description\n    doc.long_description = long_description\n\n    # Analyze blank lines after short and long description for flags\n    # According to the initial code, these are stored as boolean attributes:\n    # \"blank_after_short_description\" and \"blank_after_long_description\"\n    # We can detect them by checking if there's a blank line after short desc and long desc in the original text.\n\n    # Determine blank_after_short_description:\n    # The short description is lines[:len(short_description_lines)]\n    # After that, if next line(s) is blank, set flag True\n\n    if short_description_lines:\n        idx = len(short_description_lines)\n        if idx < len(lines) and lines[idx].strip() == \"\":\n            doc.blank_after_short_description = True\n\n    # Determine blank_after_long_description similarly\n    # Long description was extracted starting after short desc blank line, ends before meta or end.\n    # So blank line after long_description if exists.\n\n    if long_description_lines:\n        # Locate long desc start index: after short desc + 1 blank line\n        long_start = len(short_description_lines) + 1\n        # Long desc lines are from long_start to long_start + len(long_description_lines)\n        long_end = long_start + len(long_description_lines)\n        if long_end < len(lines) and lines[long_end].strip() == \"\":\n            doc.blank_after_long_description = True\n\n    # Now parse each meta block text into DocstringMeta objects using _build_meta helper\n    # Each block starts with a line like \":param int foo:\" or \":raises ValueError:\"\n    # The first line contains the key and arguments, and rest lines are continuation description.\n\n    # Parse meta blocks\n    for block in meta_blocks:\n        first_line = block[0]\n        # Pattern: :keyword optional_type? optional_arg_name?:\n        m = re.match(r\"^\\s*:(\\S+)\\s*(.*?)\\s*:\\s*(.*)$\", first_line)\n        if not m:\n            # If the line doesn't match meta pattern, skip or treat as normal meta?\n            # We'll skip to next block\n            continue\n\n        key_raw = m.group(1)  # e.g., param, raises, returns\n        after_key = m.group(2)  # e.g., int foo\n        first_desc_line = m.group(3)  # first line of description after colon\n\n        # Compose full description with continuation lines\n        desc_lines = [first_desc_line] + block[1:]\n        # Clean indentation of continuation description lines\n        # We want to cleandoc the description lines after joining with \"\\n\"\n        desc = \"\\n\".join(desc_lines)\n        desc = inspect.cleandoc(desc)\n\n        # Parse args from key and rest\n        # For rest, split by spaces but keep them combined for param type and argname (like \"int foo\")\n        args = [key_raw]\n        # Split after_key, but take care if it contains multiple parts (for example: \"int foo\" or just \"foo\")\n        # Because _build_meta expects args like [\"param\", \"int\", \"foo\"] or [\"param\", \"foo\"]\n        if after_key:\n            # Try to split type and name if possible\n            # Use regex to split type and name intelligently\n            # We will split after_key by whitespace maxsplit=1\n\n            parts = after_key.strip().split(None, 1)\n            if len(parts) == 2:\n                type_name, arg_name = parts\n                args.extend([type_name, arg_name])\n            else:\n                # Only one part (either type or arg_name)\n                # We need to decide which it is: for param, it's likely the arg_name alone\n                # For raises or returns, it could be type only\n                # We'll append as single argument after key\n                args.append(parts[0])\n        # else no extra args\n\n        # Build the DocstringMeta using _build_meta\n        try:\n            meta_obj = _build_meta(args, desc)\n        except ParseError:\n            # If parsing fails, create a generic DocstringMeta fallback\n            meta_obj = DocstringMeta(args=args, description=desc)\n\n        doc.meta.append(meta_obj)\n\n    return doc", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 359, in <module>\n  File \"<string>\", line 358, in test_extra_12\nIndexError: list index out of range\n", "passed": false}
{"task_id": 166, "prediction_id": 4, "generation": "import typing as T\nimport re\nimport inspect\n\nfrom .common import (\n    Docstring,\n    ParseError,\n    PARAM_KEYWORDS,\n    RAISES_KEYWORDS,\n    RETURNS_KEYWORDS,\n    YIELDS_KEYWORDS,\n    DocstringParam,\n    DocstringRaises,\n    DocstringReturns,\n    DocstringMeta,\n)\n\n\ndef parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n\n    # Strip leading/trailing whitespace and split into lines\n    lines = text.strip().splitlines()\n\n    doc = Docstring()\n    doc.meta = []\n\n    # Parse short description:\n    # The short description is the initial block of non-empty lines before\n    # - an empty line, or\n    # - a line starting a docstring field (e.g., \":param ...:\", \":returns:\", \":raises:\")\n\n    short_desc_lines = []\n    index = 0\n    n = len(lines)\n\n    # A regex to detect the start of a field directive line: e.g. \":param\", \":returns\", \":raises\"\n    field_start_re = re.compile(r\"^\\s*:(param|returns|raises|yields|meta|rtype|return|raise)\\b\")\n\n    while index < n:\n        line = lines[index]\n        if line.strip() == \"\":\n            # Stop at first blank line\n            break\n        if field_start_re.match(line):\n            # Stop if line starts with a recognized field\n            break\n        short_desc_lines.append(line)\n        index += 1\n\n    short_desc = \"\\n\".join(short_desc_lines).strip()\n    doc.short_description = short_desc if short_desc else None\n\n    # After short description, parse long description lines:\n    # The long description is the block of lines after short description and an empty line,\n    # up to the first field section.\n    # We'll skip empty lines immediately after short desc, then collect lines until a field starts.\n\n    # Move index forward skipping blank lines\n    while index < n and lines[index].strip() == \"\":\n        index += 1\n\n    long_desc_lines = []\n    while index < n:\n        line = lines[index]\n        if field_start_re.match(line):\n            break\n        long_desc_lines.append(line)\n        index += 1\n\n    long_desc = \"\\n\".join(long_desc_lines).strip()\n    doc.long_description = long_desc if long_desc else None\n\n    # Track if blank line after short/long desc to mark flags in Docstring\n    # (This is a minor feature, set flags accordingly)\n    # blank after short description if line after short desc is blank\n    # We only know the position after parsing short desc and before long desc\n    if short_desc_lines:\n        after_short_desc_line = len(short_desc_lines)\n        if after_short_desc_line < n:\n            doc.blank_after_short_description = (lines[after_short_desc_line].strip() == \"\")\n        else:\n            doc.blank_after_short_description = False\n    else:\n        doc.blank_after_short_description = False\n\n    if long_desc_lines:\n        after_long_desc_line = index\n        if after_long_desc_line < n:\n            doc.blank_after_long_description = (lines[after_long_desc_line].strip() == \"\")\n        else:\n            doc.blank_after_long_description = False\n    else:\n        doc.blank_after_long_description = False\n\n    # Now parse the meta fields (parameters, returns, raises, yields, meta, etc.)\n    #\n    # ReST fields start with colon `:field_name [args]: description`\n    # E.g.: \":param int foo: description\"\n    #       \":raises ValueError: description\"\n    #       \":return: description\"\n    #       \":returns int: description\"\n    #       \":yields int: description\"\n    #\n    # Multiline descriptions for a field are indented relative to the field line.\n    # We'll parse fields by scanning from current index to end.\n\n    meta_lines = lines[index:]\n    total = len(meta_lines)\n    i = 0\n\n    # Pattern to match a field line:\n    # starts with optional whitespace, colon, one keyword (param|raises|returns|yields|meta|...),\n    # then optional type and argument, then colon, then optional description\n    field_line_re = re.compile(\n        r\"\"\"\n        ^\\s*                             # optional leading whitespace\n        :(?P<key>\\w+)                   # field key (e.g. param, returns)\n        (?:\\s+                          # required space after key\n           (?P<type_and_arg>[^:]+?)     # non-greedy match of anything except colon, type_and_arg = type and/or arg name\n        )?\n        \\s*:                           # colon after key (and possible type_and_arg)\n        \\s*(?P<desc>.*)$               # optional description after colon\n        \"\"\",\n        re.VERBOSE,\n    )\n\n    current_field = None  # holds current field's info: (args_list, description_lines)\n    # args_list: list of args (e.g. [\"param\", \"int\", \"foo\"])\n    # For param, args are usually: [\"param\", \"type\", \"arg_name\"] or [\"param\", \"arg_name\"]\n    # For returns/raises/yields/meta keys, args usually have one element or two\n\n    def finish_field():\n        # Build DocstringMeta from current_field, append to doc.meta\n        if current_field is None:\n            return\n        args, desc_lines = current_field\n        desc = \"\\n\".join(desc_lines).strip()\n        # Use the _build_meta helper defined in rest.py (file content) to build proper meta\n        meta_item = _build_meta(args, desc)\n        doc.meta.append(meta_item)\n\n    while i < total:\n        line = meta_lines[i]\n        m = field_line_re.match(line)\n        if m:\n            # new field detected, finish previous field first\n            finish_field()\n\n            key = m.group(\"key\")\n            type_and_arg = m.group(\"type_and_arg\")\n            desc = m.group(\"desc\")\n\n            # Parse args for the key\n            # Rules from _build_meta:\n            # PARAM_KEYWORDS: args can be (param, type_name, arg_name) OR (param, arg_name)\n            # RETURNS_KEYWORDS/YIELDS_KEYWORDS/RAISES_KEYWORDS: args can be (key,) or (key, type_name)\n            # Others: just [key]\n\n            args_list: T.List[str] = []\n            key_lower = key.lower()\n\n            if key_lower in PARAM_KEYWORDS:\n                # type_and_arg might be:\n                # - \"int foo\"\n                # - \"foo\"\n                # we need to split on whitespace, if two parts => type and arg_name\n                # if one part => arg_name only\n                if type_and_arg:\n                    parts = type_and_arg.strip().split(None, 1)\n                    if len(parts) == 2:\n                        args_list = [key_lower, parts[0], parts[1]]\n                    else:\n                        args_list = [key_lower, parts[0]]\n                else:\n                    # no argument after param key is likely parse error, but allow param with no arg_name?\n                    args_list = [key_lower]\n            elif key_lower in RETURNS_KEYWORDS | YIELDS_KEYWORDS | RAISES_KEYWORDS:\n                # type_and_arg could be type name, e.g. \"int\"\n                if type_and_arg:\n                    args_list = [key_lower, type_and_arg.strip()]\n                else:\n                    args_list = [key_lower]\n            else:\n                # generic meta key\n                if type_and_arg:\n                    args_list = [key_lower, type_and_arg.strip()]\n                else:\n                    args_list = [key_lower]\n\n            current_field = (args_list, [desc] if desc else [])\n\n            # Now parse following indented lines as continuation of description\n            i += 1\n            while i < total:\n                next_line = meta_lines[i]\n                # continuation lines are indented (at least one space or tab)\n                if next_line.strip() == \"\":\n                    # Blank line can be part of description\n                    current_field[1].append(\"\")\n                    i += 1\n                    continue\n                if re.match(r\"^\\s\", next_line):\n                    current_field[1].append(next_line)\n                    i += 1\n                else:\n                    # next field or no indentation stops continuation\n                    break\n        else:\n            # Line not starting with :keyword: and not blank or indented - ignored (could be faulty docstring)\n            # Skip line, do not consume, or break?\n            # We cannot safely parse free text here, so skip it.\n            i += 1\n\n    # after loop ends, finish last field if any\n    finish_field()\n\n    return doc", "message": "failed: Traceback (most recent call last):\n  File \"/codegendata/human-eval/human_eval/execution.py\", line 57, in unsafe_execute\n    exec(check_program, exec_globals)\n  File \"<string>\", line 112, in <module>\nKeyError: \"'__name__' not in globals\"\n", "passed": false}
