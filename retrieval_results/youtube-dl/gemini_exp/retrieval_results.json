{"function": "aes_cbc_decrypt", "target_function_prompt": "def aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n", "f1_score": 0.10526315789473684, "recall": 0.3333333333333333, "precision": 0.0625, "context_size": 16, "target_api_invocations": ["aes_decrypt", "key_expansion", "xor"], "context": [{"fname": "urshift", "evidence": "Cryptographic algorithms, including AES, heavily rely on bitwise operations like shifts. This `urshift` utility could be invoked by the underlying AES block cipher implementation (e.g., `aes_encrypt` or `aes_decrypt` primitive) or by the `key_expansion` function that `aes_cbc_decrypt` would utilize, for precise bit manipulation."}, {"fname": "_ctypes_array", "evidence": "AES decryption, particularly in high-performance contexts, often involves calling underlying C libraries. If the core AES primitive (e.g., `aes_decrypt` or `aes_encrypt` called by `aes_cbc_decrypt`) is implemented in C and invoked via `ctypes`, then this function would be necessary to convert the Python `int[]` data, key, or IV into C-compatible `ctypes` arrays for passing to the native code."}, {"fname": "compat_struct_unpack", "evidence": "Although the primary inputs are `int[]`, `aes_cbc_decrypt` might internally need to parse or interpret specific byte sequences from within the `int[]` representation or from other sources (e.g., for handling padding, block reassembly, or specific header/footer processing if applicable). `compat_struct_unpack` provides a robust way to extract structured data from byte sequences for cross-version compatibility."}, {"fname": "compat_struct_pack", "evidence": "Similar to `unpack`, `compat_struct_pack` can be used to construct byte sequences from Python data types. `aes_cbc_decrypt` might need this to format intermediate data (e.g., to create a specific structure for an underlying AES primitive that expects raw bytes, or for manipulating and re-packing the IV/previous ciphertext block in a structured manner) before further processing."}, {"fname": "key_schedule_core", "evidence": "The target function `aes_cbc_decrypt` will perform AES decryption. AES requires key expansion to generate round keys, and this node describes a core function (`key_schedule_core`) essential for that key scheduling process. The `aes_ctr_decrypt` in the file content also explicitly calls `key_expansion`, implying a common dependency."}, {"fname": "rijndael_mul", "evidence": "The target function `aes_cbc_decrypt` will internally use an AES decryption primitive. AES decryption involves the inverse MixColumns transformation, which relies on multiplication in the Rijndael finite field (GF(2^8)). This function (`rijndael_mul`) is a fundamental building block for such operations, making its invocation highly probable via higher-level AES decryption functions."}, {"fname": "mix_column", "evidence": "The target function `aes_cbc_decrypt` will perform AES decryption, which includes the `InvMixColumns` step. Node 5, `mix_columns_inv`, directly provides this inverse transformation. The implementation of `mix_columns_inv` (Node 5) clearly shows it invokes `mix_columns` (Node 4), which in turn calls `mix_column`. Therefore, `mix_column` is an indirect but essential part of the AES decryption process."}, {"fname": "mix_columns", "evidence": "The target function `aes_cbc_decrypt` will perform AES decryption, which requires the `InvMixColumns` step. Node 5, `mix_columns_inv`, directly implements this inverse transformation, and its implementation explicitly calls `mix_columns` with the inverse matrix. Thus, `mix_columns` will be invoked as part of the `InvMixColumns` operation during AES decryption."}, {"fname": "mix_columns_inv", "evidence": "The target function `aes_cbc_decrypt` performs AES decryption. The description for `mix_columns_inv` explicitly states it 'reverses the diffusion step, primarily used in the decryption process of block ciphers such as AES.' This makes it a direct and necessary component for AES decryption in CBC mode."}, {"fname": "shift_rows_inv", "evidence": "The `shift_rows_inv` function performs the inverse ShiftRows transformation. This is a core step in the AES inverse cipher, which is applied repeatedly during the decryption process in AES CBC mode. Therefore, `aes_cbc_decrypt` would internally invoke this function as part of its block decryption logic."}, {"fname": "sub_bytes", "evidence": "The `sub_bytes` function performs byte substitution, which is a fundamental operation (specifically, InvSubBytes with an inverse S-box) within the AES decryption algorithm. It is highly probable that the core AES block decryption primitive, used by AES-CBC, would invoke such a function."}, {"fname": "hex_to_bytes", "evidence": "The `aes_cbc_decrypt` function expects its inputs (data, key, iv) in an integer list (byte) format. If these inputs were provided as hexadecimal strings, the `hex_to_bytes` utility would be necessary to convert them into the required binary representation before the decryption process can begin."}, {"fname": "xor", "evidence": "AES CBC decryption requires XORing blocks (the current ciphertext block with the previous ciphertext block or IV). The 'xor' function directly provides this essential bitwise operation on sequences of numbers."}, {"fname": "sub_bytes_inv", "evidence": "AES decryption algorithms, including CBC mode, specifically involve an 'Inverse Byte Substitution' step which uses an inverse S-box. The 'sub_bytes_inv' function directly implements this core cryptographic operation."}, {"fname": "bytes_to_intlist", "evidence": "The target function handles data, key, and IV as lists of integers (int[]). It is common in cryptographic implementations for underlying AES primitives or other helper functions to require or produce byte strings (bytes objects). This function would be invoked to convert intermediate byte strings back into integer lists for further processing or as final output, especially given its import from the utilities module in the file context."}, {"fname": "intlist_to_bytes", "evidence": "The target function receives data, key, and IV as lists of integers (int[]). If the core AES decryption primitive or any other internal helper function expects byte strings (bytes objects) as input for blocks or keys, this function would be invoked to convert the int[] inputs into bytes objects before passing them to those functions. Its import from the utilities module indicates its common use for byte conversions in the codebase."}]}
{"function": "aes_cbc_encrypt", "target_function_prompt": "def aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n", "f1_score": 0.25, "recall": 0.6666666666666666, "precision": 0.15384615384615385, "context_size": 12, "target_api_invocations": ["aes_encrypt", "key_expansion", "xor"], "context": [{"fname": "urshift", "evidence": "AES encryption algorithms, including key expansion and the various rounds of encryption, heavily rely on bitwise operations such as shifts, rotations, and XORs. A utility function like `urshift` (unsigned right shift) is a common building block for such cryptographic operations and could plausibly be invoked internally by the AES core or key expansion routines."}, {"fname": "aes_ctr_decrypt", "evidence": "The 'aes_ctr_decrypt' function's implementation reveals it invokes 'aes_encrypt' (for counter block encryption), 'key_expansion', and 'xor'. These are common underlying primitives for various AES modes, including CBC encryption, making it highly probable that 'aes_cbc_encrypt' would also invoke these or similar helper functions."}, {"fname": "aes_decrypt_text", "evidence": "The implementation of `aes_decrypt_text` within this node uses core AES functions like `key_expansion` and `aes_encrypt`. The target function `aes_cbc_encrypt` will almost certainly need to invoke these same fundamental building blocks for AES encryption and key management."}, {"fname": "key_schedule_core", "evidence": "The target function performs AES encryption, which requires key expansion. This node describes a core transformation 'essential for generating round keys in block ciphers like AES', indicating it would be invoked during the key expansion process for AES encryption."}, {"fname": "rijndael_mul", "evidence": "The target function performs AES encryption. Rijndael finite field multiplication is a 'fundamental operation in the AES encryption algorithm', specifically used within the MixColumns transformation. Therefore, this function would be invoked, likely indirectly, during the AES block encryption process."}, {"fname": "mix_column", "evidence": "The target function performs AES encryption. 'MixColumn' transformation is a crucial step for diffusion in AES, explicitly mentioned as 'crucial for diffusion in block ciphers like Rijndael'. This function would be invoked as part of the AES block encryption rounds."}, {"fname": "mix_columns", "evidence": "The target function performs AES encryption. 'MixColumns' is a standard round operation in AES, described as a 'common step in cryptographic algorithms like AES'. This function would be invoked to apply the column mixing transformation to data blocks during the AES encryption process."}, {"fname": "shift_rows", "evidence": "The target function performs AES encryption. The `shift_rows` function is explicitly described as a 'core step in the AES cipher', implying it will be invoked by the underlying AES block encryption primitive that `aes_cbc_encrypt` would call."}, {"fname": "key_expansion", "evidence": "AES encryption, including CBC mode, requires an expanded key schedule. The `key_expansion` function generates this, and other AES functions in the same file (e.g., `aes_cbc_decrypt`) already invoke it, indicating it's a prerequisite step."}, {"fname": "aes_encrypt", "evidence": "The target function `aes_cbc_encrypt` performs AES encryption in CBC mode. This mode involves encrypting individual data blocks using a core AES block encryption function. `aes_encrypt` is precisely this function, designed to encrypt a single 16-byte block."}, {"fname": "ror", "evidence": "The `ror` function performs a right bit rotation. Core AES block encryption, which `aes_cbc_encrypt` would internally invoke (e.g., `aes_encrypt`), often involves various bitwise operations like rotations and shifts as part of its sub-processes (e.g., MixColumns, S-box lookups, key scheduling). Therefore, it's highly plausible that `ror` would be used by the underlying AES primitive."}, {"fname": "intlist_to_bytes", "evidence": "The target function processes data as `int[]`. However, underlying low-level AES encryption primitives (like `aes_encrypt` which will be called) commonly operate on actual `bytes` objects. `intlist_to_bytes` provides the necessary conversion from `int[]` blocks to `bytes` objects, making it highly probable for use before passing data to the core AES encryption logic."}]}
{"function": "key_expansion", "target_function_prompt": "def key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n", "f1_score": 0.28571428571428575, "recall": 0.6666666666666666, "precision": 0.18181818181818182, "context_size": 11, "target_api_invocations": ["sub_bytes", "key_schedule_core", "xor"], "context": [{"fname": "urshift", "evidence": "The AES key expansion algorithm involves various bitwise operations, including logical (unsigned) right shifts on 32-bit words. The 'urshift' function provides this exact functionality, making it highly likely to be invoked for manipulating the key data during expansion."}, {"fname": "_ctypes_array", "evidence": "Cryptographic operations like key expansion are often performance-critical and may leverage C implementations via ctypes. This function directly converts Python lists of integers (like the 'data' parameter or intermediate results) into C-compatible ctypes arrays, making it highly plausible for delegating parts of the key expansion to a C library."}, {"fname": "compat_struct_unpack", "evidence": "Key expansion algorithms frequently involve packing and unpacking bytes into larger words or manipulating byte sequences. The `struct` module is a common Python tool for this, and this function provides a compatibility wrapper for `struct.unpack`. It is very likely that 'key_expansion' would use such a utility for byte-level interpretations or conversions during the key schedule generation."}, {"fname": "sub_bytes", "evidence": "The target function 'key_expansion' generates a key schedule, a core step in many block ciphers like AES. S-box substitutions are a fundamental component of key expansion algorithms. The 'sub_bytes' function directly implements such a substitution using a lookup table, making it highly probable to be invoked for transforming key data during expansion."}, {"fname": "obfuscate_key_aux", "evidence": "The description states this function 'produces obfuscated key components' by transforming a numerical sequence. Given that 'key_expansion' generates an expanded key (a larger numerical sequence derived from a cipher key), it's plausible that this auxiliary function could be used to generate or modify specific parts or 'components' of the expanded key, especially in a custom or non-standard key expansion algorithm."}, {"fname": "xor", "evidence": "Cryptographic key expansion algorithms, such as those used in AES, frequently employ bitwise XOR operations to combine different parts of the key or with round constants. The `xor` function provides this exact element-wise operation on sequences of numbers (bytes), making it highly likely to be invoked during key schedule generation."}, {"fname": "rotate", "evidence": "Key expansion in cryptographic algorithms like AES often involves cyclic shifts or rotations of key bytes or words. The `rotate` function performs a left rotation on a sequence, which is a common operation in generating a key schedule."}, {"fname": "inc", "evidence": "While not a direct cryptographic primitive, some steps in key schedule generation might involve incrementing parts of the key or derived values, especially if certain round constants or intermediate values are iteratively generated. The `inc` function's ability to increment a list of integers (representing bytes) with rollover logic could be utilized for such a purpose within the complex key expansion process."}, {"fname": "ror", "evidence": "Bitwise rotation is a fundamental operation in many cryptographic algorithms, including those for key schedule generation. The `ror` function provides a right bit rotation on an integer, which is highly relevant for manipulating key material at a bit level during the key expansion process to derive different round keys."}, {"fname": "bytes_to_intlist", "evidence": "The `bytes_to_intlist` function converts a sequence of bytes into a list of integers. While the target function `key_expansion` takes `int[]` as input, cryptographic key expansion often involves intermediate steps that might produce or consume raw `bytes` objects (e.g., when interacting with `compat_struct_pack` or other byte-oriented utilities in the same library context), requiring conversion back to the `int[]` format for further processing."}, {"fname": "intlist_to_bytes", "evidence": "The `intlist_to_bytes` function converts a list of integers (bytes) into a `bytes` object. Key expansion algorithms frequently manipulate 32-bit words, and if the implementation leverages functions like `compat_struct_pack` (common for word-level operations in Python's crypto libraries), it would need to convert segments of the `int[]` key into `bytes` before packing, making this function a likely invocation."}]}
{"function": "aes_encrypt", "target_function_prompt": "def aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n", "f1_score": 0.3333333333333333, "recall": 0.5, "precision": 0.25, "context_size": 8, "target_api_invocations": ["shift_rows", "sub_bytes", "mix_columns", "xor"], "context": [{"fname": "urshift", "evidence": "AES encryption, particularly operations like MixColumns and parts of key schedule generation, can involve bitwise manipulations and shifts (e.g., unsigned right shifts) when operating on word-sized data. This utility could be invoked for such internal bitwise calculations."}, {"fname": "_decrypt_xor_cipher", "evidence": "The `aes_encrypt` function, which performs AES block encryption, fundamentally relies on XOR operations for its AddRoundKey step. The provided `_decrypt_xor_cipher` function, despite its name, explicitly states it can perform 'XOR encryption or decryption' and provides a general XOR utility, making it a suitable candidate for invocation within `aes_encrypt` for the AddRoundKey operation."}, {"fname": "rijndael_mul", "evidence": "The `rijndael_mul` function performs finite field multiplication, which is a fundamental mathematical operation within the AES (Rijndael) algorithm, specifically used in the `MixColumns` step. Since `aes_encrypt` encrypts one block, it must perform the `MixColumns` transformation (in all but the last round), which would directly or indirectly invoke `rijndael_mul`."}, {"fname": "mix_column", "evidence": "The `mix_column` function performs a cryptographic 'MixColumn' transformation on a single column of data. The AES encryption process involves a `MixColumns` step that operates on the entire 16-byte block, often by processing each 4-byte column individually. Therefore, `aes_encrypt` is highly likely to invoke `mix_column` as part of its encryption rounds."}, {"fname": "mix_columns", "evidence": "The `mix_columns` function performs the column-mixing operation on an entire data block, which is a crucial diffusion step in the AES encryption algorithm. Since `aes_encrypt` is responsible for encrypting a single block, it would directly invoke `mix_columns` (for all but the last round) as one of its core transformations."}, {"fname": "shift_rows", "evidence": "The `aes_encrypt` function, which encrypts one block with AES, would necessarily invoke `shift_rows` as it is a fundamental transformation (a core step) within each round of the AES encryption algorithm."}, {"fname": "rotate", "evidence": "The AES algorithm's ShiftRows transformation involves cyclic shifts of bytes within the state. A generic `rotate` function on a sequence could be used as a low-level helper to implement such a transformation if the 'data' parameter to aes_encrypt is processed as a sequence of bytes or words that need to be cyclically shifted."}, {"fname": "ror", "evidence": "The AES algorithm involves various bitwise manipulations, especially in its SubBytes transformation (which often uses a substitution box derived from GF(2^8) operations) and potentially within its key schedule logic. A right bit rotation function (`ror`) is a low-level bitwise utility that could be invoked by `aes_encrypt` or its internal helper functions (like `sub_bytes` or elements of `key_schedule_core` if they are defined as separate steps within the AES block encryption process) to perform specific cryptographic operations."}]}
{"function": "aes_decrypt", "target_function_prompt": "def aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n", "f1_score": 0.36363636363636365, "recall": 0.5, "precision": 0.2857142857142857, "context_size": 7, "target_api_invocations": ["shift_rows_inv", "mix_columns_inv", "sub_bytes_inv", "xor"], "context": [{"fname": "urshift", "evidence": "AES decryption involves complex bitwise operations, especially within transformations like `InvMixColumns`. While `aes_decrypt` might call a higher-level function for this, that function could plausibly use a general utility like `urshift` to implement its low-level bit manipulations, leading to an indirect invocation."}, {"fname": "rijndael_mul", "evidence": "The `rijndael_mul` function performs finite field multiplication, which is a fundamental building block for the `mix_column` operation. Since `aes_decrypt` will perform an inverse mix columns transformation (via `mix_columns_inv`), and `mix_columns_inv` calls `mix_columns`, which in turn calls `mix_column`, and `mix_column` then calls `rijndael_mul`, it is indirectly invoked."}, {"fname": "mix_column", "evidence": "The `mix_column` function performs a core column mixing transformation. AES decryption requires an inverse mix columns step. Node 5, `mix_columns_inv`, calls `mix_columns` (with an inverse matrix). Thus, `aes_decrypt` will likely call `mix_columns_inv`, which then calls `mix_columns`, and `mix_columns` will then call `mix_column` for each column."}, {"fname": "mix_columns", "evidence": "The `mix_columns` function orchestrates the column mixing transformation by iterating through columns and calling `mix_column`. For decryption, the `mix_columns_inv` function (Node 5), which is explicitly designed for AES decryption, itself invokes `mix_columns` with the inverse matrix. Therefore, `aes_decrypt` will invoke `mix_columns_inv`, which then invokes `mix_columns`."}, {"fname": "mix_columns_inv", "evidence": "The docstring of `mix_columns_inv` explicitly states it 'reverses the diffusion step, primarily used in the decryption process'. The AES decryption algorithm inherently includes an 'InvMixColumns' step. Therefore, `aes_decrypt` will directly invoke `mix_columns_inv` as a crucial part of its decryption process."}, {"fname": "shift_rows_inv", "evidence": "AES decryption involves the inverse of the encryption steps. `shift_rows_inv` directly implements the inverse ShiftRows transformation, which is a required core step in the AES decryption algorithm."}, {"fname": "rotate", "evidence": "The `rotate` function performs a left rotation on a sequence. AES decryption (specifically the `InvShiftRows` step) involves cyclic shifts (rotations) of data within the state matrix. This `rotate` function is a fundamental low-level building block that could be used to implement the `InvShiftRows` operation required for AES decryption."}]}
{"function": "aes_decrypt_text", "target_function_prompt": "def aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 21, "target_api_invocations": ["aes_encrypt", "key_expansion", "bytes_to_intlist", "compat_b64decode", "inc", "intlist_to_bytes", "aes_ctr_decrypt"], "context": [{"fname": "urshift", "evidence": "Cryptographic algorithms, including AES and its key expansion routines, frequently rely on precise bitwise operations like unsigned right shifts for data manipulation within rounds and key schedule generation. While `aes_decrypt_text` is a high-level function, it will invoke lower-level AES primitives (e.g., `key_expansion`, `aes_encrypt`, or their internal helpers) that are highly likely to utilize such bitwise utility functions for correct algorithmic implementation."}, {"fname": "aes_ctr_decrypt", "evidence": "The target function's docstring explicitly states that the 'Mode of operation is 'counter'' for decryption. This node provides the exact function, `aes_ctr_decrypt`, which performs AES decryption in counter mode, making it a direct and essential invocation for the target function's core functionality."}, {"fname": "error_to_compat_str", "evidence": "Cryptographic operations like decryption can fail due to various reasons (e.g., invalid input, corrupted data, incorrect key size). This utility function converts error objects into a compatible string representation, which is a common pattern for robust error handling, logging, or preparing user-friendly exception messages within a function."}, {"fname": "key_schedule_core", "evidence": "The target function's docstring specifies that the cipher key is derived by 'encrypting' a password, which necessitates a key expansion process. The `key_expansion` function (present in the file content) is a core component of AES key setup and explicitly calls `key_schedule_core`. Therefore, `key_schedule_core` will be invoked as part of the key derivation required by `aes_decrypt_text`."}, {"fname": "rijndael_mul", "evidence": "The `rijndael_mul` function performs a fundamental finite field multiplication crucial for the `MixColumns` step in AES. The target function `aes_decrypt_text` uses AES in counter mode, which internally calls `aes_encrypt` (as seen in `aes_ctr_decrypt`). `aes_encrypt` calls `mix_columns`, and the provided Node 4 (`mix_column`) and Node 5 (`mix_columns`) implementations demonstrate a dependency on `rijndael_mul` for their operations. Thus, `rijndael_mul` will be invoked indirectly during the decryption process."}, {"fname": "mix_column", "evidence": "The target function `aes_decrypt_text` uses AES in counter mode, which relies on `aes_encrypt` to encrypt counter blocks. The `aes_encrypt` function (provided in the file content) uses the `mix_columns` operation in its rounds. Node 5, `mix_columns`, is implemented by iterating through columns and calling `mix_column` for each. Therefore, `mix_column` will be invoked as a sub-operation during the AES block encryption of counter blocks."}, {"fname": "mix_columns", "evidence": "The target function `aes_decrypt_text` explicitly uses AES in counter mode. The `aes_ctr_decrypt` function (defined in the file content) directly invokes `aes_encrypt` for each counter block. The `aes_encrypt` function (also in the file content) directly calls `mix_columns` as a core transformation step within its encryption rounds. Thus, `mix_columns` will be invoked during the encryption of counter blocks as part of the overall decryption process."}, {"fname": "shift_rows", "evidence": "The target function's docstring states that the cipher key is derived by 'encrypting the first 16 Byte of password'. This implies an `aes_encrypt` call for key derivation. Furthermore, `aes_decrypt_text` is specified to use 'counter' mode, which typically involves `aes_encrypt` of a counter block. Since `shift_rows` is a core transformation within `aes_encrypt`, it will be invoked."}, {"fname": "key_expansion", "evidence": "The target function performs AES decryption. AES operations, including those in counter mode (`aes_ctr_decrypt` which the target function implies using), always require an expanded key. Thus, `key_expansion` will be invoked to generate this key schedule from the derived cipher key."}, {"fname": "aes_encrypt", "evidence": "The target function's docstring explicitly states: 'The cipher key is retrieved by encrypting the first 16 Byte of 'password' with the first 'key_size_bytes' Bytes from 'password''. This process directly calls for an AES block encryption, for which `aes_encrypt` is perfectly suited. Additionally, the `aes_ctr_decrypt` function (which is the core decryption method for the target function) internally calls `aes_encrypt` to process the counter blocks."}, {"fname": "sub_bytes", "evidence": "The target function 'aes_decrypt_text' describes a key derivation step involving 'encrypting the first 16 Byte of password'. The provided file content shows 'aes_encrypt' which is a core AES block cipher function. 'sub_bytes' is a fundamental operation within AES encryption and decryption, as shown in the 'aes_encrypt' implementation from the file content (e.g., 'data = sub_bytes(data)'). Therefore, 'sub_bytes' will be invoked indirectly during the key derivation process or potentially within the final AES CTR decryption steps."}, {"fname": "xor", "evidence": "The `xor` function is a fundamental building block for AES operations, including encryption, decryption, and key expansion. Given that the target function `aes_decrypt_text` uses AES in 'counter' mode and performs key derivation via an encryption step, it will directly or indirectly invoke `xor` via calls to `aes_ctr_decrypt`, `aes_encrypt`, or `key_expansion`."}, {"fname": "b64decode", "evidence": "The target function's docstring explicitly states that the `data` parameter is a 'Base64 encoded string'. This `b64decode` function is designed to decode Base64-encoded strings to UTF-8, which is a necessary first step for the target function to process the input data."}, {"fname": "compat_b64decode", "evidence": "The target function's docstring explicitly states that the input 'data' is 'Base64 encoded string' and that 'The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter'. This makes base64 decoding an essential initial step, which 'compat_b64decode' perfectly provides."}, {"fname": "encode", "evidence": "The target function takes a 'password' as a string/unicode, which typically needs to be converted to bytes (e.g., via UTF-8 encoding) before being used in cryptographic operations like key derivation. The 'encode' method provides this capability, converting a string to bytes for consistent text handling."}, {"fname": "encode_elem", "evidence": "The target function's docstring explicitly states the `password` parameter 'will be encoded with utf-8'. The `encode_elem` function handles encoding `compat_str` types to bytes, making it a highly relevant candidate for preparing the password for cryptographic use."}, {"fname": "inc", "evidence": "The target function explicitly uses AES in 'counter' mode, and the `aes_ctr_decrypt` function expects a counter instance with a `next_value()` method. The `inc` function directly implements the logic for incrementing a list of integers, simulating a byte array counter, which is exactly what a counter object would do internally to generate the next counter block for CTR mode."}, {"fname": "compat_itertools_count", "evidence": "The target function `aes_decrypt_text` specifies decryption in 'counter' mode, which relies on a counter. The `aes_ctr_decrypt` function (from file context) requires a `counter` instance with a `next_value()` method. This node's description, 'Generates an infinite sequence of evenly spaced numbers, useful for creating endless counters,' indicates it can serve as a fundamental building block for such a counter, even if it requires a wrapper to provide the exact 16-byte block expected by `aes_ctr_decrypt`."}, {"fname": "long_to_bytes", "evidence": "The target function needs to construct a counter instance for AES-CTR mode. This counter often involves converting an incrementing numerical value (an integer) into its byte representation, for which 'long_to_bytes' is perfectly suited to form parts of the 16-byte counter block."}, {"fname": "bytes_to_intlist", "evidence": "The target function's input 'data' is Base64 encoded (requiring decoding to bytes) and 'password' is a string (requiring encoding to bytes). All core AES functions in the codebase operate on 'int[]' (list of integers). Therefore, 'bytes_to_intlist' is essential to convert these byte representations into the required integer list format for cryptographic operations."}, {"fname": "intlist_to_bytes", "evidence": "The 'aes_ctr_decrypt' function (likely invoked by the target function) returns data as an 'int[]'. The target function 'aes_decrypt_text' must return a string. 'intlist_to_bytes' is necessary to convert the 'int[]' decryption result back into a byte string, which can then be decoded to the final output string."}]}
