{"function": "aes_cbc_decrypt", "target_function_prompt": "def aes_cbc_decrypt(data, key, iv):\n    \"\"\"\n    Decrypt with aes in CBC mode\n\n    @param {int[]} data        cipher\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           decrypted data\n    \"\"\"\n", "f1_score": 0.5, "recall": 0.6666666666666666, "precision": 0.4, "context_size": 5, "target_api_invocations": ["key_expansion", "xor", "aes_decrypt"], "context": [{"fname": "key_schedule_core", "evidence": "key_schedule_core is a core helper function used internally for key expansion. While not directly evident that aes_cbc_decrypt calls it, any AES decrypt/encrypt involving CBC mode may indirectly use the key expansion process which calls this function. Hence, it could be invoked indirectly during key expansion."}, {"fname": "key_expansion", "evidence": "key_expansion expands the cipher key into a full expanded key schedule required for AES operations. The target function aes_cbc_decrypt will definitely need to generate the expanded key from the provided key before the CBC decryption process, so this function will be invoked."}, {"fname": "aes_cbc_encrypt", "evidence": "aes_cbc_encrypt is the encryption counterpart to the target function's CBC decryption. Although it's an encryption function, it's closely related and could share common subroutines or logic. However, it's more typical that the decrypt function works independently. Still, this function is part of the same mode CBC operations and could be used for reference or shared code paths."}, {"fname": "aes_encrypt", "evidence": "aes_encrypt performs AES encryption on a single 16-byte block using the expanded key. CBC decryption typically involves decrypting blocks using the AES block cipher operations. Although this function is for encryption, the internals of AES decryption sometimes use encryption rounds in reverse or use such block-level encryption functions. So it is plausible aes_cbc_decrypt calls aes_encrypt or its complement for block decryption."}, {"fname": "aes_decrypt", "evidence": "aes_cbc_decrypt performs AES decryption, likely on individual 16-byte blocks. This node, aes_decrypt, decrypts one 16-byte block given an expanded key, which matches the fundamental subtask needed within CBC decryption. Given that CBC mode decrypts blocks one by one, it is natural and necessary to invoke aes_decrypt to process each block."}]}
{"function": "aes_cbc_encrypt", "target_function_prompt": "def aes_cbc_encrypt(data, key, iv):\n    \"\"\"\n    Encrypt with aes in CBC mode. Using PKCS#7 padding\n\n    @param {int[]} data        cleartext\n    @param {int[]} key         16/24/32-Byte cipher key\n    @param {int[]} iv          16-Byte IV\n    @returns {int[]}           encrypted data\n    \"\"\"\n", "f1_score": 0.4444444444444444, "recall": 0.6666666666666666, "precision": 0.3333333333333333, "context_size": 6, "target_api_invocations": ["key_expansion", "xor", "aes_encrypt"], "context": [{"fname": "rijndael_mul", "evidence": "rijndael_mul is a core operation for AES MixColumns transformation used during AES block encryption, which aes_cbc_encrypt must use."}, {"fname": "mix_column", "evidence": "mix_column performs the finite field mixing on a single column, an essential step in AES encryption rounds used by aes_cbc_encrypt."}, {"fname": "mix_columns", "evidence": "mix_columns applies the MixColumns transformation to the entire AES state, integral to AES encryption blocks in aes_cbc_encrypt."}, {"fname": "key_expansion", "evidence": "key_expansion generates the expanded AES key schedule required for encryption, and aes_cbc_encrypt is expected to invoke it."}, {"fname": "aes_ctr_decrypt", "evidence": "aes_ctr_decrypt shares similarity in purpose (AES decryption) and uses key_expansion as well as block processing. For aes_cbc_encrypt, similar low-level operations and block handling are expected. Its use of xor and block iterations makes it likely aes_cbc_encrypt might invoke or follow patterns similar to aes_ctr_decrypt or reuse code from it."}, {"fname": "aes_encrypt", "evidence": "aes_encrypt performs AES block encryption on a single 16-byte block with an expanded key and standard AES rounds, sub_bytes, shift_rows, and mix_columns steps. Given the target function encrypts data in CBC mode at block-level, it is very likely to invoke this function to encrypt each block."}]}
{"function": "key_expansion", "target_function_prompt": "def key_expansion(data):\n    \"\"\"\n    Generate key schedule\n\n    @param {int[]} data  16/24/32-Byte cipher key\n    @returns {int[]}     176/208/240-Byte expanded key\n    \"\"\"\n", "f1_score": 0.8, "recall": 0.6666666666666666, "precision": 1.0, "context_size": 2, "target_api_invocations": ["xor", "key_schedule_core", "sub_bytes"], "context": [{"fname": "key_schedule_core", "evidence": "The target function key_expansion generates an expanded AES key schedule, which involves applying core transformations like rotation, substitution, and addition of round constants. The key_schedule_core function implements exactly this core transformation step used during key expansion, making it highly likely to be invoked."}, {"fname": "xor", "evidence": "The xor function is used repeatedly in the provided AES encryption and decryption functions for combining blocks and keys. Since key_expansion prepares keys for AES operations, it is plausible that xor is used either directly or indirectly during key derivation or validation within key expansion."}]}
{"function": "aes_encrypt", "target_function_prompt": "def aes_encrypt(data, expanded_key):\n    \"\"\"\n    Encrypt one block with aes\n\n    @param {int[]} data          16-Byte state\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte cipher\n    \"\"\"\n", "f1_score": 0.28571428571428575, "recall": 0.25, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["xor", "sub_bytes", "shift_rows", "mix_columns"], "context": [{"fname": "rijndael_mul", "evidence": "rijndael_mul performs finite field multiplication, a fundamental operation likely required during the AES encryption rounds (such as MixColumns and other transformations). Because aes_encrypt implements one block of AES encryption, it very likely needs finite field multiplication."}, {"fname": "mix_column", "evidence": "mix_column applies a mixing transformation on a 4-element vector using Rijndael finite field multiplication. AES encryption involves the MixColumns step which processes columns of the state matrix similarly, so this function is very likely to be invoked by aes_encrypt as part of that step."}, {"fname": "mix_columns", "evidence": "mix_columns processes the entire 16-byte state (4 columns of 4 bytes each) by invoking mix_column for each column, implementing the full MixColumns transformation. This is a standard step in AES encryption rounds, so aes_encrypt likely invokes this mix_columns function to perform that part of the cipher."}]}
{"function": "aes_decrypt", "target_function_prompt": "def aes_decrypt(data, expanded_key):\n    \"\"\"\n    Decrypt one block with aes\n\n    @param {int[]} data          16-Byte cipher\n    @param {int[]} expanded_key  176/208/240-Byte expanded key\n    @returns {int[]}             16-Byte state\n    \"\"\"\n", "f1_score": 0.4444444444444445, "recall": 0.5, "precision": 0.4, "context_size": 5, "target_api_invocations": ["mix_columns_inv", "xor", "sub_bytes_inv", "shift_rows_inv"], "context": [{"fname": "rijndael_mul", "evidence": "rijndael_mul is fundamental for finite field multiplication used in inverse mix columns during AES decryption."}, {"fname": "mix_column", "evidence": "mix_column is the core operation that applies finite field multiplication and is essential for the column mixing step in decryption."}, {"fname": "mix_columns", "evidence": "mix_columns performs column-wise mixing and is likely called by the inverse mix columns operation during decryption."}, {"fname": "shift_rows_inv", "evidence": "shift_rows_inv is the inverse row shift step essential to AES decryption to reverse encryption's row shifting."}, {"fname": "mix_columns_inv", "evidence": "mix_columns_inv applies the inverse column mixing transformation required in AES decryption rounds."}]}
{"function": "aes_decrypt_text", "target_function_prompt": "def aes_decrypt_text(data, password, key_size_bytes):\n    \"\"\"\n    Decrypt text\n    - The first 8 Bytes of decoded 'data' are the 8 high Bytes of the counter\n    - The cipher key is retrieved by encrypting the first 16 Byte of 'password'\n    with the first 'key_size_bytes' Bytes from 'password' (if necessary filled with 0's)\n    - Mode of operation is 'counter'\n\n    @param {str} data                    Base64 encoded string\n    @param {str,unicode} password        Password (will be encoded with utf-8)\n    @param {int} key_size_bytes          Possible values: 16 for 128-Bit, 24 for 192-Bit or 32 for 256-Bit\n    @returns {str}                       Decrypted data\n    \"\"\"\n", "f1_score": 0.3529411764705882, "recall": 0.42857142857142855, "precision": 0.3, "context_size": 9, "target_api_invocations": ["inc", "aes_ctr_decrypt", "key_expansion", "bytes_to_intlist", "compat_b64decode", "aes_encrypt", "intlist_to_bytes"], "context": [{"fname": "key_schedule_core", "evidence": "The target function involves deriving a cipher key by encrypting part of the password and thus may require constructing the key schedule. The key_schedule_core function performs a core step of key schedule generation, which is likely to be invoked directly or indirectly during key expansion."}, {"fname": "key_expansion", "evidence": "The target function needs to generate an expanded key from the password's key material. This function explicitly generates the full AES key schedule, making it essential for key derivation in the target function."}, {"fname": "aes_ctr_decrypt", "evidence": "The target function specifies the mode of operation as 'counter', and aes_ctr_decrypt implements decryption in counter mode. It directly matches the target function’s decryption mode and is highly likely to be invoked."}, {"fname": "aes_encrypt", "evidence": "aes_encrypt is necessary for block encryption steps, notably for encrypting parts of the password and counter blocks. The target function’s docstring mentions encrypting the first 16 bytes of the password, implying this block encryption function will be used."}, {"fname": "aes_decrypt", "evidence": "The target function performs AES decryption, so it may invoke aes_decrypt for decrypting AES blocks."}, {"fname": "decode_url", "evidence": "The target function needs to decode the base64 encoded 'data', which may be URL-encoded; this utility decodes URL-encoded base64 strings to UTF-8 text and matches that need."}, {"fname": "b64decode", "evidence": "The target function requires base64 decoding of input data to UTF-8 text, and this utility directly provides base64 and UTF-8 decoding, making it relevant."}, {"fname": "_decode", "evidence": "The target function requires base64 decoding of input data; this function implements a custom base64-like decoding that might be invoked for initial decoding."}, {"fname": "ds", "evidence": "This function performs complex base64-like and XOR decoding, which aligns with the target function’s need for specialized decoding of encoded input data."}]}
