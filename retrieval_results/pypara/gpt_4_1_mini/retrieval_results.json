{"function": "build_general_ledger", "target_function_prompt": "def build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n", "f1_score": 0.125, "recall": 1.0, "precision": 0.06666666666666667, "context_size": 15, "target_api_invocations": ["Ledger.add"], "context": [{"fname": "cntraccts", "evidence": "Counter accounts are essential for ledger entries and transaction balancing during ledger construction, so cntraccts is likely invoked."}, {"fname": "is_debit", "evidence": "Checking if a ledger entry is debit is important for classification and managing balances in the ledger; this property is likely used."}, {"fname": "is_debit", "evidence": "Determining whether individual postings are debit is necessary when processing postings into ledger entries, so this function is likely invoked."}, {"fname": "increments", "evidence": "Filtering increment postings in journal entries is probably needed to process relevant transaction types when building the ledger."}, {"fname": "decrements", "evidence": "Filtering decrement postings complements increment filtering and is likely used to process all relevant postings during ledger construction."}, {"fname": "add", "evidence": "The add method is central for adding ledger entries during ledger construction, which is the core task of build_general_ledger. The target function will likely call this method during iteration over journal entries."}, {"fname": "debits", "evidence": "The 'debits' function returns debit postings from a journal entry, which is likely useful while building the general ledger to segregate or process debit transactions specifically for ledger entries or balance calculations."}, {"fname": "credits", "evidence": "The 'credits' function yields credit postings from a journal entry. Similar to 'debits', this capability is critical when constructing ledgers to properly classify and process credit transactions."}, {"fname": "post", "evidence": "The target function build_general_ledger will likely interact with journal entries and postings; the post method records amount changes to accounts and is essential to construct ledger entries from journal data."}, {"fname": "validate", "evidence": "Validation of journal entries is important before building the ledger to ensure data integrity; the build_general_ledger function might invoke validate to check for balanced entries."}, {"fname": "is_credit", "evidence": "Determining if postings are credit or debit is crucial when processing journal entries into ledger entries; is_credit could be invoked to differentiate transaction types."}, {"fname": "_last_balance", "evidence": "The target function will need to determine prior balances when adding new entries; accessing the last balance is essential and thus _last_balance helper method of Ledger is likely invoked."}, {"fname": "of", "evidence": "The target function may need to create or validate monetary values and could invoke this factory method to safely instantiate Money instances."}, {"fname": "negative", "evidence": "Negating monetary amounts may be necessary during ledger construction, so the target function might call this method to support such operations."}, {"fname": "positive", "evidence": "Ensuring positive monetary values is plausible during ledger building, thus this method could be invoked to normalize amounts."}]}
{"function": "_last_payment_date", "target_function_prompt": "def _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n", "f1_score": 0.2857142857142857, "recall": 1.0, "precision": 0.16666666666666666, "context_size": 6, "target_api_invocations": ["_construct_date"], "context": [{"fname": "_next_payment_date", "evidence": "'_next_payment_date' calculates the next payment date based on frequency and optionally day-of-month, which aligns perfectly as a building block for finding the last payment date in '_last_payment_date'."}, {"fname": "_get_date_range", "evidence": "'_get_date_range' yields dates within a range and could be used to iterate over candidate payment dates or intervals during last payment date calculation."}, {"fname": "_has_leap_day", "evidence": "'_has_leap_day' determines whether a date range contains a leap day, potentially necessary for accurate date computations involving leap years in payment scheduling."}, {"fname": "_is_last_day_of_month", "evidence": "The target function's optional 'eom' parameter suggests end-of-month logic, so checking if a date is the last day of the month is likely necessary."}, {"fname": "_construct_date", "evidence": "Constructing dates safely avoiding invalid day errors is important when computing last payment dates, making this function a probable utility."}, {"fname": "dcfc_act_365_l", "evidence": "The dcfc_act_365_l function calculates day count fractions between dates considering leap years, which is highly relevant to date calculations. Since '_last_payment_date' involves computing coupon payment dates, which depend on date arithmetic and frequency, it might invoke this day count fraction calculator or rely on similar date computations."}]}
{"function": "dcc", "target_function_prompt": "def dcc(name: str, altnames: Optional[Set[str]] = None, ccys: Optional[Set[Currency]] = None) -> Callable[[DCFC], DCFC]:\n    \"\"\"\n    Registers a day count fraction calculator under the given names and alternative names (if any).\n\n    :param name: The name of the day count convention.\n    :param altnames: A set of alternative names of the day count convention, if any.\n    :param ccys: A set of currencies which are known to use this convention by default, if any.\n    :return: Registered day count fraction calculation function.\n    \"\"\"\n", "f1_score": 0.2857142857142857, "recall": 1.0, "precision": 0.16666666666666666, "context_size": 6, "target_api_invocations": ["DCCRegistryMachinery.register"], "context": [{"fname": "__hash__", "evidence": "The dcc function accepts a set of Currency instances and may manipulate this set, which implicitly invokes the __hash__ method of Currency for set operations."}, {"fname": "register", "evidence": "The dcc function is designed to register a day count convention, and the register method in DCCRegistryMachinery handles this registration, so it is very likely invoked."}, {"fname": "_is_registered", "evidence": "dcc must ensure that a name is not already registered before adding a new day count fraction calculator; _is_registered provides this exact check."}, {"fname": "registry", "evidence": "The registry() method provides access to the current registered DCC objects. The dcc function likely needs this to verify if the given name or alternative names are already registered before registering a new day count fraction calculator."}, {"fname": "dcfc_act_365_f", "evidence": "This node defines an actual day count fraction calculator function (Act/365F) that the dcc function is designed to register and potentially wrap or return, making it relevant to invocation or involvement."}, {"fname": "dcfc_30_e_360", "evidence": "This node is a specific day count fraction calculator function (30E/360), which the dcc function is intended to register, so it is relevant and likely to be invoked or otherwise involved."}]}
{"function": "dcfc_act_act", "target_function_prompt": "def dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n", "f1_score": 0.25, "recall": 1.0, "precision": 0.14285714285714285, "context_size": 8, "target_api_invocations": ["_get_date_range"], "context": [{"fname": "dcfc_act_act_icma", "evidence": "dcfc_act_act_icma, implementing Actual/Actual (ICMA), is a closely related day count fraction method. Since both use Actual/Actual concepts and manage accrual calculations with similar parameters, dcfc_act_act may invoke or reuse logic from this function to modularize or handle specific subcases of Actual/Actual."}, {"fname": "dcfc_act_365_a", "evidence": "The Act/365A convention also involves Actual days divided by either 365 or 366, considering leap years. Since dcfc_act_act must handle precise day count fractions and leap year considerations, it might invoke this utility function to reuse its leap-year-aware day fraction calculations."}, {"fname": "None", "evidence": "The summary node likely represents a collection of conventions or utility functions related to day count fractions for different conventions, including supporting functions that dcfc_act_act might invoke to compute fractions, validate dates, or handle special cases consistent with the Actual/Actual convention."}, {"fname": "_last_payment_date", "evidence": "The function calculates the last coupon payment date based on start date and frequency, which is necessary for determining coupon boundaries in the Act/Act fraction calculation."}, {"fname": "_next_payment_date", "evidence": "The function calculates the next coupon payment date relative to a start date and frequency, often used alongside the last payment date to determine accrual periods in Act/Act calculations."}, {"fname": "_get_actual_day_count", "evidence": "This utility function counts the actual number of days between two dates, a fundamental requirement for computing the day count fraction under the Act/Act convention."}, {"fname": "_get_date_range", "evidence": "Generating a date range for iteration is useful for evaluating day-by-day calculations required in detailed Act/Act day count fraction computations."}, {"fname": "_has_leap_day", "evidence": "The 'Act/Act' day count fraction computation commonly requires checking for leap days, and '_has_leap_day' directly provides this functionality, making it very likely invoked."}]}
{"function": "dcfc_act_act_icma", "target_function_prompt": "def dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n", "f1_score": 0.25, "recall": 1.0, "precision": 0.14285714285714285, "context_size": 7, "target_api_invocations": ["_get_actual_day_count"], "context": [{"fname": "_get_actual_day_count", "evidence": "Utility function to count actual days is a fundamental helper likely invoked to compute parts of the day count fraction in 'Act/Act (ICMA)'."}, {"fname": "_get_date_range", "evidence": "_get_date_range is commonly used in Act/Act calculations to iterate over date ranges, making it very probable to be invoked."}, {"fname": "_has_leap_day", "evidence": "_has_leap_day detects leap days in date ranges, a common requirement for day count fraction calculations like ICMA."}, {"fname": "_is_last_day_of_month", "evidence": "_is_last_day_of_month may be needed to handle month-end boundary conditions essential in ICMA convention calculations."}, {"fname": "_construct_date", "evidence": "_construct_date ensures safe creation of date objects, useful when adjusting dates during ICMA calculations."}, {"fname": "dcfc_act_365_f", "evidence": "The target function dcfc_act_act_icma computes a day count fraction for a day count convention similar to dcfc_act_365_f, which computes day count fraction for another Act/365-related convention. Given the similarity in purpose (computing day count fractions between dates), dcfc_act_365_f is a plausible function that might be invoked or used as reference for utility methods or parts of the calculation."}, {"fname": "isum", "evidence": "Summation utility 'isum' can be used to accumulate fractional parts which is a common need in day count fraction calculations."}]}
{"function": "dcfc_act_360", "target_function_prompt": "def dcfc_act_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/360\" convention.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.17222222222222')\n    >>> round(dcfc_act_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17500000000000')\n    >>> round(dcfc_act_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.10000000000000')\n    >>> round(dcfc_act_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.34722222222222')\n    \"\"\"\n", "f1_score": 0.25, "recall": 1.0, "precision": 0.14285714285714285, "context_size": 6, "target_api_invocations": ["_get_actual_day_count"], "context": [{"fname": "_get_actual_day_count", "evidence": "The target function needs to compute actual number of days between dates; the utility function _get_actual_day_count provides exactly this calculation."}, {"fname": "_get_date_range", "evidence": "_get_date_range generates a range of dates and is a common utility for iterating over date intervals. The 'Act/360' calculation may need to iterate over dates or utilize helper functions dealing with date ranges; this utility is a reasonable candidate for invocation."}, {"fname": "_has_leap_day", "evidence": "_has_leap_day checks if leap day is within a date range. Although 'Act/360' typically divides by 360 without leap day adjustment, the target function's docstring and test cases include leap years, and the function may check or consider leap days to accurately calculate day count fractions. Hence, it is plausible it calls this helper."}, {"fname": "dcfc_act_365_l", "evidence": "The target function dcfc_act_360 computes a day count fraction similar in purpose to dcfc_act_365_l, but for a different day count convention (Act/360 vs Act/365L). Such functions typically share helper utilities related to date difference calculations or may be used in conjunction or for reference. Given both calculate fractions of a period with similar input parameters, dcfc_act_365_l could be invoked or used as a reference or utility within the implementation to handle part of the fraction calculation."}, {"fname": "calculate_fraction", "evidence": "This method 'calculate_fraction' of the DCC class calculates a day count fraction after performing date validation and delegates to an underlying calculation method. Since dcfc_act_360 is itself a day count fraction calculator, it could be used as the underlying function that DCC.calculate_fraction calls, or the target function could call this method for validation and delegation. Thus, it is plausible that calculate_fraction might be invoked during or in relation to dcfc_act_360's use."}, {"fname": "dcc", "evidence": "The 'dcc' function is a decorator factory used to register day count fraction calculators like dcfc_act_360 under specified names and alternative names for lookup and management. Since dcfc_act_360 is decorated with @dcc, an invocation of this function is required to register the target function appropriately. Hence, it will be invoked during the implementation setup of dcfc_act_360."}]}
{"function": "dcfc_act_365_f", "target_function_prompt": "def dcfc_act_365_f(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365F\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 1, "target_api_invocations": ["_get_actual_day_count"], "context": [{"fname": "_get_actual_day_count", "evidence": "The utility function counting actual days between dates is essential for Act/365F calculations and is very likely invoked by the target function."}]}
{"function": "dcfc_act_365_a", "target_function_prompt": "def dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 4, "target_api_invocations": ["_get_actual_day_count", "_has_leap_day"], "context": [{"fname": "_get_actual_day_count", "evidence": "dcfc_act_365_a needs to compute the actual number of days between dates, which fits perfectly with the utility implemented by _get_actual_day_count."}, {"fname": "dcfc_nl_365", "evidence": "dcfc_nl_365 performs a closely related day count fraction calculation with leap day adjustment, which aligns with the likely logic needed for 'Act/365A' convention, making invocation plausible for reuse or delegation."}, {"fname": "_has_leap_day", "evidence": "_has_leap_day explicitly checks for leap day inclusion in the date range, which is critical for accurately computing 'Act/365A' day count fractions, making this function very likely to be invoked."}, {"fname": "dcfc_act_365_f", "evidence": "The 'Act/365F' day count fraction function is closely related and likely to be invoked or reused by the 'Act/365A' implementation due to their similar calculation domains."}]}
{"function": "dcfc_act_365_l", "target_function_prompt": "def dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n", "f1_score": 0.25, "recall": 1.0, "precision": 0.14285714285714285, "context_size": 7, "target_api_invocations": ["_get_actual_day_count"], "context": [{"fname": "dcfc_act_365_a", "evidence": "dcfc_act_365_a calculates the day count fraction for Act/365A convention, which is closely related conceptually to Act/365L since both deal with actual days and consider leap years differently. The target function might invoke dcfc_act_365_a or use a similar logic, or at least share similar processing concerns (e.g., deciding denominator based on leap years). Thus, invocation is possible."}, {"fname": "_get_actual_day_count", "evidence": "The function needs to compute the number of actual days between dates, and this utility provides exactly that."}, {"fname": "_get_date_range", "evidence": "The target function likely iterates over date ranges to handle day-level counting and leap days; this utility supports such iteration."}, {"fname": "_has_leap_day", "evidence": "Determining if a date range contains a leap day is important under 'Act/365L'; this utility provides that check."}, {"fname": "_is_last_day_of_month", "evidence": "The target function may check if a date is the last day of the month as part of the 'Act/365L' convention rules, so invocation is plausible."}, {"fname": "_construct_date", "evidence": "Safe date construction is often needed in day count calculations to handle invalid dates, making _construct_date likely used."}, {"fname": "dcfc_act_365_f", "evidence": "The 'Act/365L' convention may reuse or call the 'Act/365F' day count fraction calculation as part of its implementation."}]}
{"function": "dcfc_nl_365", "target_function_prompt": "def dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 4, "target_api_invocations": ["_get_actual_day_count", "_has_leap_day"], "context": [{"fname": "_get_actual_day_count", "evidence": "The target function needs to count the actual number of days between dates, a task performed by this utility function."}, {"fname": "_get_date_range", "evidence": "_get_date_range is a useful utility for iterating over date ranges, which is essential for day count fraction calculations like NL/365."}, {"fname": "_has_leap_day", "evidence": "_has_leap_day may be invoked to detect leap days in the date range to handle or ignore them as required by the 'No Leap Year' day count convention."}, {"fname": "_construct_date", "evidence": "_construct_date is a utility for safely creating valid dates, which may be needed by the target function for date calculations or adjustments."}]}
{"function": "dcfc_30_360_german", "target_function_prompt": "def dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n", "f1_score": 0.25, "recall": 1.0, "precision": 0.14285714285714285, "context_size": 7, "target_api_invocations": ["_is_last_day_of_month"], "context": [{"fname": "dcfc_act_act_icma", "evidence": "This is a related day count fraction function in the same domain and may be invoked for consistency, validation, or reuse of day count logic."}, {"fname": "dcfc_act_360", "evidence": "As a closely related day count fraction function, it could be invoked by the target function for reuse or partial computation."}, {"fname": "dcfc_act_365_a", "evidence": "Shares domain and utility dependency; the target function might invoke it to handle edge cases or for consistency."}, {"fname": "_get_actual_day_count", "evidence": "This utility function computes the actual number of days between two dates and is essential for day count fraction calculations, so the target function is likely to invoke it."}, {"fname": "_is_last_day_of_month", "evidence": "The 30/360 German convention hinges on accurately identifying if dates are month-end days because it adjusts day values based on month-end status. The function _is_last_day_of_month precisely provides this utility, making it highly plausible that dcfc_30_360_german calls it to implement date adjustments per the convention rules."}, {"fname": "_construct_date", "evidence": "The target function returns computed dates constructed from year, month, and day values that must be valid. _construct_date safely creates such dates, adjusting days downward if out of valid range. Given dcfc_30_360_german would need to produce a valid date for computation, it likely invokes _construct_date to ensure date correctness."}, {"fname": "dcfc_30_e_360", "evidence": "The '30/360 German' day count fraction is equivalent or very similar to the '30E/360' convention implemented in this function, with matching example outputs. It is likely that the target function invokes this function or reuses its logic."}]}
{"function": "dcfc_30_360_us", "target_function_prompt": "def dcfc_30_360_us(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["_is_last_day_of_month"], "context": [{"fname": "_get_actual_day_count", "evidence": "_get_actual_day_count is a foundational utility function for calculating day differences and is likely invoked by the 30/360 US calculation to compute parts of the day count."}, {"fname": "_is_last_day_of_month", "evidence": "The '30/360 US' convention involves special handling for dates falling on the last day of the month, making this utility likely to be invoked."}, {"fname": "_construct_date", "evidence": "The target function likely needs to safely construct adjusted dates during calculation, so this utility is probably invoked."}, {"fname": "dcfc_30_360_isda", "evidence": "The node implements the '30/360 ISDA' day count fraction calculation which is closely related to the '30/360 US' convention from the target function. Given the similarity in conventions and overlapping use cases in financial conventions, the target function might invoke or reuse logic from this implementation for shared calculations or structural similarity."}]}
