{"function": "_defaults", "target_function_prompt": "def _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 4, "target_api_invocations": ["code"], "context": [{"fname": "_type_name", "evidence": "The target function likely needs to identify the type of AST expression nodes to produce appropriate string literals, making this function useful for type introspection."}, {"fname": "_e_type", "evidence": "_e_type analyzes sequences of constant elements to derive combined type annotation strings or return 'Any' if types differ. Given that _defaults's docstring states 'Literals of the table,' it probably needs to infer or handle types of default literals. _e_type’s utility in determining element types of constant literals aligns closely with _defaults’s likely need to identify or represent types of default argument values. Thus, _defaults may invoke _e_type to determine or annotate the types corresponding to its default literal arguments."}, {"fname": "resolve", "evidence": "This function converts AST expression nodes into strings, which aligns with the target function's role of producing string literals from default argument expressions."}, {"fname": "const_type", "evidence": "This function infers types of constant expression nodes, which could assist the target function in processing and converting default literals."}]}
{"function": "is_public_family", "target_function_prompt": "def is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n", "f1_score": 0.33333333333333337, "recall": 1.0, "precision": 0.2, "context_size": 5, "target_api_invocations": ["is_magic"], "context": [{"fname": "is_public", "evidence": "The target function 'is_public_family' determines if a name is from public modules. The 'is_public' method in the Parser class checks if a name is public style or listed in '__all__', and directly calls 'is_public_family' within its implementation. This indicates a close relationship and likely invocation from 'is_public_family'."}, {"fname": "__is_immediate_family", "evidence": "The __is_immediate_family method checks if one name is an immediate family related to another based on prefix matching. Since is_public_family aims to check if a name comes from public modules or not, it might rely on family relationship logic to determine if a module name belongs to a public module family. Hence this function is relevant and likely to be invoked."}, {"fname": "__find_alias", "evidence": "The __find_alias method substitutes aliases with canonical names, maintaining consistent references among document structures. Since is_public_family checks if a name is from public modules, alias resolution might be necessary to resolve name aliases to their actual public module names, making this function likely to be invoked."}, {"fname": "_attr", "evidence": "The target function might need to access nested attributes of the given name or related objects to determine public module status, and this utility safely retrieves such nested attributes."}, {"fname": "is_magic", "evidence": "Checking if the name is a magic (dunder) method or attribute is directly relevant to distinguishing public from non-public names, so this utility is likely invoked."}]}
{"function": "table", "target_function_prompt": "def table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 4, "target_api_invocations": ["_table_split", "_table_cell"], "context": [{"fname": "esc_underscore", "evidence": "The target function creates tables with titles and rows that likely contain underscores, which need escaping for proper Markdown rendering. esc_underscore is designed to escape underscores in names, making it a useful helper to correctly format table cell contents."}, {"fname": "code", "evidence": "The target function outputs a Markdown table which may contain characters like '|' that need escaping to avoid Markdown parsing issues. The 'code' function escapes Markdown special characters and formats strings as inline code in Markdown, making it a valuable utility to ensure cell contents are safely rendered."}, {"fname": "_table_cell", "evidence": "The target function formats multi-column markdown tables. _table_cell converts a list of strings into a markdown table row with proper cell spacing and separators. This aligns directly with the target function’s need to format each row of items and the title row."}, {"fname": "_table_split", "evidence": "The target function’s docstring shows a table with a divider row between the header and body. _table_split generates the Markdown table divider line with alignment markers and minimum widths, which is exactly the required functionality to create the separator row in the output table."}]}
{"function": "_e_type", "target_function_prompt": "def _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n", "f1_score": 0.2222222222222222, "recall": 1.0, "precision": 0.125, "context_size": 8, "target_api_invocations": ["_type_name"], "context": [{"fname": "__get_const", "evidence": "__get_const retrieves and formats constant values and their types, likely useful for getting the type info of constants in _e_type."}, {"fname": "_type_name", "evidence": "_type_name returns the qualified type name of an object, which directly supports the task of getting element types in _e_type."}, {"fname": "esc_underscore", "evidence": "The function may return type names or element strings that require underscore escaping for proper representation or documentation."}, {"fname": "code", "evidence": "The function might format returned type strings as inline Markdown code, using this utility for escaping and formatting."}, {"fname": "_defaults", "evidence": "The target function processes sequences of optional expressions to generate string representations when types are constants; _defaults provides exactly this functionality by serializing expressions or substituting spaces for None."}, {"fname": "visit_Name", "evidence": "The target function may require resolving names to their underlying expressions or constants. This Resolver method handling name resolution with alias support is relevant and likely invoked."}, {"fname": "visit_Subscript", "evidence": "To correctly handle type annotations, the target function might invoke this method to translate legacy typing annotations into modern PEP585/PEP604 syntax before analyzing constant types."}, {"fname": "const_type", "evidence": "const_type infers and returns the type of a constant expression node and calls _e_type recursively for nested elements. Given _e_type's purpose to get element types of constant nodes, it is very likely to invoke const_type, which shares closely related responsibilities and is designed for constant type inference."}]}
{"function": "const_type", "target_function_prompt": "def const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n", "f1_score": 0.5714285714285715, "recall": 1.0, "precision": 0.4, "context_size": 5, "target_api_invocations": ["_type_name", "_e_type"], "context": [{"fname": "_type_name", "evidence": "This utility provides a qualified type name string for an object, which is likely used by const_type to convert a node's value type to a string."}, {"fname": "_e_type", "evidence": "This function infers and returns combined type strings from sequences of constant expressions, which directly aligns with the constant type inference task of the target function."}, {"fname": "visit_Name", "evidence": "The visit_Name method recursively resolves global names and aliases, supporting substitution which is useful in constant type inference to resolve type names represented as AST Name nodes."}, {"fname": "resolve", "evidence": "The resolve function returns string representations of resolved AST nodes, directly supporting the target function's need to produce string type names for constants."}, {"fname": "visit_Constant", "evidence": "The visit_Constant method tries to parse string constants as expressions and visit them recursively, enabling handling of string-literal constants that represent code, which aligns with constant type inference."}]}
