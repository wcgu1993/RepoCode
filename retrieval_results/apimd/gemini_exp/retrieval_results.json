{"function": "_defaults", "target_function_prompt": "def _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 5, "target_api_invocations": ["code"], "context": [{"fname": "_type_name", "evidence": "The target function processes `ast.expr` objects. While extracting literals, it might encounter various `expr` types. `_type_name` could be invoked for introspection, debugging, or logging the type of an expression node, especially if an unexpected or unhandled type is encountered during the literal extraction process. The docstring of `_type_name` explicitly mentions 'introspection or debugging' which aligns with potential needs for `_defaults` to understand or report on the types of AST nodes it is processing."}, {"fname": "_e_type", "evidence": "The target function `_defaults` takes `Sequence[Optional[expr]]` and is described as providing 'Literals of the table'. The `_e_type` function takes `Sequence[Optional[expr]]` (the same input type as `_defaults`) and 'determines and formats the types of constant values found within sequences of expressions'. It returns a string representation of these types. It is highly plausible that `_defaults`, when extracting 'literals' from expressions, might need to determine and format the types of these literals, a task perfectly aligned with `_e_type`'s functionality. Both are also internal helper functions (`_` prefix)."}, {"fname": "visit_Constant", "evidence": "The target function `_defaults` processes AST `expr` nodes to yield string literals. If an `expr` node is a `Constant` whose value is a string requiring further interpretation (as per `visit_Constant`'s description of resolving dynamically embedded code), this `visit_Constant` method (part of an AST `Resolver` often used in such contexts) would be invoked, likely indirectly via a higher-level resolution function."}, {"fname": "visit_Name", "evidence": "The target function `_defaults` processes AST `expr` nodes to yield string literals. If an `expr` node is a `Name` (e.g., a variable or a constant defined elsewhere), its value needs to be resolved to a literal string. `visit_Name` is specifically designed for name resolution and substitution within an AST context, and would be invoked, likely indirectly via a higher-level resolution function, when such a node is encountered."}, {"fname": "resolve", "evidence": "The target function `_defaults` takes `expr` nodes and returns an iterator of strings, implying a need to convert AST expressions into their string representations. The `resolve` function directly takes an `expr` node and returns its unparsed string representation after resolving global names. This aligns perfectly with the goal of extracting 'literals' from AST expressions for the 'table'."}]}
{"function": "is_public_family", "target_function_prompt": "def is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["is_magic"], "context": [{"fname": "is_magic", "evidence": "The target function 'is_public_family' aims to determine if a name is from public modules. It is a common convention that 'magic' or 'dunder' names (checked by 'is_magic') are typically considered internal or private, not public. Thus, 'is_public_family' would likely invoke 'is_magic' to exclude such names from its 'public' determination."}, {"fname": "_attr", "evidence": "If checking 'public modules' involves inspecting actual module or object properties based on the input name (e.g., by traversing `sys.modules`), `_attr` would be highly useful for safely retrieving nested attributes from objects corresponding to parts of the name."}, {"fname": "parent", "evidence": "Determining if a name 'comes from public modules' often requires checking the public/private status of its parent modules in the hierarchy. The `parent` function is ideal for extracting these parent names to perform such a check recursively or iteratively."}, {"fname": "_site_path", "evidence": "The target function aims to determine if a name originates from a 'public module'. A common indicator of a public module is its installation path, such as within 'site-packages'. The `_site_path` function directly provides this information by returning the installation directory if the module exists there, which is highly relevant for defining or checking 'public' status."}]}
{"function": "table", "target_function_prompt": "def table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 4, "target_api_invocations": ["_table_split", "_table_cell"], "context": [{"fname": "esc_underscore", "evidence": "The target function generates a Markdown table. Individual cell contents (from titles or items) might contain underscores that need to be escaped to prevent unintended Markdown formatting (e.g., italics), making this function useful for sanitization."}, {"fname": "code", "evidence": "The target function creates a Markdown table where '|' is a cell separator. The 'code' function explicitly handles escaping Markdown characters like '|' and can format content as inline code, which is highly relevant for ensuring table cell content does not break the table structure."}, {"fname": "_table_cell", "evidence": "The target function 'table' needs to construct individual rows of a table. '_table_cell' is explicitly designed to create a formatted table row from a sequence of strings, making it a direct and essential helper for the 'table' function's implementation."}, {"fname": "_table_split", "evidence": "The target function 'table' is required to create a Markdown table, which includes a separator line (e.g., '|:---:|'). '_table_split' is specifically designed to generate this exact Markdown table separator line, making it a crucial component for 'table'."}]}
{"function": "_e_type", "target_function_prompt": "def _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["_type_name"], "context": [{"fname": "_type_name", "evidence": "The target function's docstring explicitly states 'Get element type'. The `_type_name` function directly provides the fully qualified name of an object's type, which is exactly what the target function would need to identify the type of the input 'elements' to determine if they are 'constants'."}, {"fname": "const_type", "evidence": "The target function `_e_type` aims to 'Get element type if type is constants' from sequences of AST expressions. `const_type` performs 'Constant type inference' on a single AST expression. It is highly probable that `_e_type` would iterate through its input `elements` and call `const_type` on each individual `expr` node to determine its constant type."}, {"fname": "visit_Constant", "evidence": "The target function `_e_type` aims to determine the type of elements, specifically 'if type is constants'. `visit_Constant` is a method specifically designed to process AST `Constant` nodes and interpret their values, including dynamically embedded expressions. It is highly probable that `_e_type` will utilize this method or similar logic from a `Resolver` to correctly analyze the provided `expr` nodes when they are constants."}, {"fname": "resolve", "evidence": "The target function `_e_type` takes `expr` nodes and returns a string representing their type, especially if they are constants. The `resolve` function takes an `expr` node and returns its unparsed string representation after resolving global names. This is highly relevant because an input `expr` to `_e_type` might be a `Name` (e.g., a variable holding a constant) that needs to be resolved before its constant nature and type can be determined. The `resolve` function is perfectly suited to perform this resolution and provide the required string output."}]}
{"function": "const_type", "target_function_prompt": "def const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n", "f1_score": 0.5714285714285715, "recall": 1.0, "precision": 0.4, "context_size": 5, "target_api_invocations": ["_type_name", "_e_type"], "context": [{"fname": "_type_name", "evidence": "The target function needs to infer a constant's type and return its name. The `_type_name` function directly provides the capability to get the string name of any object's type, which is precisely what `const_type` would need after extracting the constant's value from the AST node."}, {"fname": "_e_type", "evidence": "The target function 'const_type' infers the type of constant values. '_e_type' is specifically designed to determine and format types of constant values within sequences of expressions, handling varying types (returning 'Any') and using '_type_name' to get the concrete type. This capability is directly applicable and likely to be invoked by 'const_type' when dealing with collection-type constant expressions (e.g., lists or tuples of constants)."}, {"fname": "visit_Constant", "evidence": "The target function 'const_type' performs 'Constant type inference' on an 'expr' node. This often involves interpreting string constants that might represent other Python expressions (e.g., '123' as an integer). Node 1's `visit_Constant` method explicitly handles this by parsing string constants and recursively visiting the resulting AST, which directly aligns with the deeper inference needed for `const_type`."}, {"fname": "visit_Name", "evidence": "The target function `const_type` takes an `expr` node. If this `expr` is an `ast.Name` node referring to a constant (e.g., `MY_CONST = 5`), then 'constant type inference' would require resolving that name to its value. Node 2's `visit_Name` method provides the functionality to replace `Name` nodes with their resolved expressions, a crucial step for `const_type` to correctly infer the type of named constants."}, {"fname": "resolve", "evidence": "The `const_type` function's goal of 'Constant type inference' on an 'expr' node could involve resolving complex expressions (like `Name` nodes or string constants representing other types) down to their underlying constant value. Node 3's `resolve` function provides a high-level service to resolve global names within an `expr` and return an unparsed string representation. `const_type` could invoke `resolve` to simplify the input `expr` to its constant form before determining its final type, especially given the presence of a dedicated `Resolver` class and related AST utilities in the codebase."}]}
