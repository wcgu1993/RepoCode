{"function": "reverse", "target_function_prompt": "def reverse(input_string: str) -> str:\n    \"\"\"\n    Returns the string with its chars reversed.\n\n    *Example:*\n\n    >>> reverse('hello') # returns 'olleh'\n\n    :param input_string: String to revert.\n    :type input_string: str\n    :return: Reversed string.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["is_string"], "context": []}
{"function": "camel_case_to_snake", "target_function_prompt": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n", "f1_score": 0.28571428571428575, "recall": 0.5, "precision": 0.2, "context_size": 5, "target_api_invocations": ["is_camel_case", "is_string"], "context": [{"fname": "snake_case_to_camel", "evidence": "The target function camel_case_to_snake converts camel case to snake case; it is common to rely on the inverse transformation (snake_case_to_camel) for verification, validation, or transformation logic. This utility might be invoked to check or help with conversions between naming conventions or to ensure round-trip consistency."}, {"fname": "is_camel_case", "evidence": "The target function deals with camel case strings and needs to verify validity. The is_camel_case function explicitly checks if a string is camel case, which the target function's docstring indicates is necessary to determine if the input is a valid camel case string. Thus, this validation function is very likely to be invoked."}, {"fname": "is_snake_case", "evidence": "The target function may use is_snake_case to check if the input string is already in snake case with the given separator, so it can return the input unchanged as per its docstring."}, {"fname": "format", "evidence": "The target function might use __StringFormatter.format() to normalize or prettify the input string before converting from camel case to snake case."}, {"fname": "__fix_saxon_genitive", "evidence": "The target function camel_case_to_snake converts camel case strings into snake case, involving string manipulation and formatting. The provided __fix_saxon_genitive method is a private helper designed to correct spacing issues related to the Saxon genitive in strings by removing spaces before the possessive apostrophe. Such a method could be relevant because canonicalizing or formatting string cases might require fixing spacing and punctuation issues, especially in natural language or human-readable strings. This private helper is part of the __StringFormatter class which appears designed for detailed string formatting tasks. Although the docstring of the target function does not explicitly mention possessive forms, the general task of conversion and formatting strings commonly involves ensuring proper spacing and punctuation, particularly if the conversion logic involves intermediate formatting steps or the use of a formatter class. Hence, this helper could realistically be invoked as part of the processing pipeline in camel_case_to_snake for correct spacing and cleaning up the output string."}]}
{"function": "snake_case_to_camel", "target_function_prompt": "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    \"\"\"\n    Convert a snake case string into a camel case one.\n    (The original string is returned if is not a valid snake case string)\n\n    *Example:*\n\n    >>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param upper_case_first: True to turn the first letter into uppercase (default).\n    :type upper_case_first: bool\n    :param separator: Sign to use as separator (default to \"_\").\n    :type separator: str\n    :return: Converted string\n    \"\"\"\n", "f1_score": 0.4, "recall": 0.6666666666666666, "precision": 0.2857142857142857, "context_size": 7, "target_api_invocations": ["is_snake_case", "is_full_string", "is_string"], "context": [{"fname": "camel_case_to_snake", "evidence": "The target function snake_case_to_camel converts snake case to camel case, which is a complementary operation to the camel_case_to_snake function. The camel_case_to_snake function is a natural candidate for invocation because the target might want to reuse or invert the logic, or validate conversions between cases given the similarity and naming pattern. The detailed implementation shows it operates on strings with validation, a pattern likely reusable."}, {"fname": "is_camel_case", "evidence": "The target function takes a flag upper_case_first (a bool) and likely needs to validate or interpret boolean flags. The utility function is_camel_case validates the camel case format, which is contextually relevant since the target converts to camel case and likely checks if input/output conforms to naming rules. This can be part of validation or branching. The implementation shows it relies on regex validation, which complements the target's purpose."}, {"fname": "booleanize", "evidence": "The target function receives an argument upper_case_first which controls casing behavior via a boolean. The booleanize function converts string inputs into boolean values and enforces validation. The target may invoke booleanize to interpret user or serialized input representing the upper_case_first parameter when input is flexible or loosely typed, ensuring robust handling of truthy/falsey values."}, {"fname": "is_snake_case", "evidence": "The target function snake_case_to_camel explicitly mentions in its docstring that it returns the original string if the input is not a valid snake case string. It thus likely performs validation of whether the input is valid snake case, which fits perfectly with the purpose of is_snake_case. This function provides precisely the validation logic needed to decide if a conversion should proceed or not. Hence, calling is_snake_case is very plausible during the implementation of the target function."}, {"fname": "is_full_string", "evidence": "The target function and some functions it relies on (like is_snake_case) use the is_full_string function to validate that input strings are non-empty and meaningful before processing. Since input validation is common and explicitly used in the code context, it is reasonable that snake_case_to_camel might invoke is_full_string to ensure input validity before proceeding with conversion, especially given the dependency noted in node 1's implementation."}, {"fname": "__uppercase_first_char", "evidence": "The function uppercases the first character of a matched group, fitting the capitalization step needed in converting snake_case segments to camelCase."}, {"fname": "__uppercase_first_letter_after_sign", "evidence": "This function uppercases the first letter after a specific sign, aligning with the need to uppercase letters following the separator in snake_case to camel_case conversion."}]}
{"function": "strip_html", "target_function_prompt": "def strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 7, "target_api_invocations": ["is_string"], "context": [{"fname": "slugify", "evidence": "slugify processes and cleans strings by removing spaces and punctuation and producing URL-safe slugs. While not directly described in strip_html's docstring, slugify shares the context of processing strings by removing or transforming characters. It's plausible strip_html could call slugify or similar utilities to sanitize the output string after HTML removal, e.g., to produce clean or normalized content."}, {"fname": "prettify", "evidence": "The prettify function reformats strings to correct spacing, punctuation, and formatting. After removing HTML tags, strip_html might invoke prettify to clean up spacing and punctuation in the resulting text to produce a nicely formatted output."}, {"fname": "format", "evidence": "The __StringFormatter.format method normalizes and cleans strings, which is likely used by strip_html to prettify the string after HTML tags removal."}, {"fname": "is_full_string", "evidence": "The is_full_string function is a utility that can be used by strip_html to validate input strings or intermediate content before processing."}, {"fname": "contains_html", "evidence": "The contains_html function directly relates to detecting HTML in strings, making it highly probable that strip_html invokes it before or during HTML removal."}, {"fname": "__ensure_right_space_only", "evidence": "Ensuring a single trailing space after substrings aligns with maintaining proper spacing when removing HTML tags or preserving their content, making invocation plausible."}, {"fname": "__ensure_spaces_around", "evidence": "Padding substrings with spaces on both sides helps maintain clear separation between words after tag removal, which fits the needs of strip_html for clean output formatting."}]}
{"function": "prettify", "target_function_prompt": "def prettify(input_string: str) -> str:\n    \"\"\"\n    Reformat a string by applying the following basic grammar and formatting rules:\n\n    - String cannot start or end with spaces\n    - The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n    - String cannot have multiple sequential spaces, empty lines or punctuation (except for \"?\", \"!\" and \".\")\n    - Arithmetic operators (+, -, /, \\\\*, =) must have one, and only one space before and after themselves\n    - One, and only one space should follow a dot, a comma, an exclamation or a question mark\n    - Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and \\\n    after quotes (foo\" bar\"baz -> foo \"bar\" baz)\n    - Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and \\\n    after brackets (\"foo(bar )baz\" -> \"foo (bar) baz\")\n    - Percentage sign (\"%\") cannot be preceded by a space if there is a number before (\"100 %\" -> \"100%\")\n    - Saxon genitive is correct (\"Dave' s dog\" -> \"Dave's dog\")\n\n    *Examples:*\n\n    >>> prettify(' unprettified string ,, like this one,will be\"prettified\" .it\\\\' s awesome! ')\n    >>> # -> 'Unprettified string, like this one, will be \"prettified\". It\\'s awesome!'\n\n    :param input_string: String to manipulate\n    :return: Prettified string.\n    \"\"\"\n", "f1_score": 0.19999999999999998, "recall": 1.0, "precision": 0.1111111111111111, "context_size": 9, "target_api_invocations": ["__StringFormatter.format"], "context": [{"fname": "format", "evidence": "This format method from __StringFormatter implements very similar grammar and formatting rules as described in prettify's docstring, including handling capitalization, spacing, punctuation, duplicates, and special cases like Saxon genitive. The alignment of goals and logic strongly indicates that prettify would invoke this method to perform its core formatting."}, {"fname": "__uppercase_first_char", "evidence": "The __uppercase_first_char method is used inside the format method to uppercase letters at appropriate places, matching prettify's requirement that first letters after punctuation be uppercase. This helper method is thus likely to be invoked indirectly in prettify's implementation."}, {"fname": "__remove_duplicates", "evidence": "This helper removes duplicate characters, supporting prettify's requirement to avoid multiple sequential punctuation. It is a likely internal utility to be invoked."}, {"fname": "__uppercase_first_letter_after_sign", "evidence": "This helper uppercases letters after punctuation marks, directly supporting the docstring rule about capitalization after '.', '!', and '?'. Very likely used by prettify."}, {"fname": "__ensure_left_space_only", "evidence": "This helper manages spacing on the left side, aligning with prettify's comprehensive spacing rules. It likely gets called for space normalization."}, {"fname": "__remove_internal_spaces", "evidence": "This helper strips internal spaces, which directly supports prettify's need to control spaces inside constructs like quotes and brackets. Likely called."}, {"fname": "__fix_saxon_genitive", "evidence": "This helper fixes Saxon genitives, a feature specifically mentioned in prettify's docstring. Highly likely invoked."}, {"fname": "__ensure_right_space_only", "evidence": "This method ensures exactly one space follows a matched substring, supporting prettify's requirement to normalize trailing spaces after punctuation or operators."}, {"fname": "__ensure_spaces_around", "evidence": "This method enforces exactly one space before and after a matched substring, enabling prettify to ensure correct spacing around quotes, brackets, and punctuation as specified in its formatting rules."}]}
{"function": "asciify", "target_function_prompt": "def asciify(input_string: str) -> str:\n    \"\"\"\n    Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n    (eg: ó -> o, Ë -> E, ç -> c...).\n\n    **Bear in mind**: Some chars may be lost if impossible to translate.\n\n    *Example:*\n\n    >>> asciify('èéùúòóäåëýñÅÀÁÇÌÍÑÓË') # returns 'eeuuooaaeynAAACIINOE'\n\n    :param input_string: String to convert\n    :return: Ascii utf-8 string\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["is_string"], "context": []}
{"function": "slugify", "target_function_prompt": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('Mönstér Mägnët') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 0.5, "precision": 1.0, "context_size": 1, "target_api_invocations": ["is_string", "asciify"], "context": [{"fname": "asciify", "evidence": "Slugify explicitly requires converting all characters to ASCII using asciify(), making invocation of asciify necessary."}]}
{"function": "booleanize", "target_function_prompt": "def booleanize(input_string: str) -> bool:\n    \"\"\"\n    Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\n    A positive boolean (True) is returned if the string value is one of the following:\n\n    - \"true\"\n    - \"1\"\n    - \"yes\"\n    - \"y\"\n\n    Otherwise False is returned.\n\n    *Examples:*\n\n    >>> booleanize('true') # returns True\n    >>> booleanize('YES') # returns True\n    >>> booleanize('nope') # returns False\n\n    :param input_string: String to convert\n    :type input_string: str\n    :return: True if the string contains a boolean-like positive value, false otherwise\n    \"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 1, "target_api_invocations": ["is_string"], "context": [{"fname": "is_string", "evidence": "The target function booleanize takes a string input and returns a boolean based on its content. The docstring shows it operates on string content and likely needs to ensure the input is a proper string before processing. The node function is_string provides exactly this utility to check if an object is a string, which fits the input validation or type-checking needs of booleanize. It is very plausible that booleanize would call is_string to confirm the input type or raise an error if the input is not a string."}]}
{"function": "strip_margin", "target_function_prompt": "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    *Example:*\n\n    >>> strip_margin('''\n    >>>                 line 1\n    >>>                 line 2\n    >>>                 line 3\n    >>> ''')\n    >>> # returns:\n    >>> '''\n    >>> line 1\n    >>> line 2\n    >>> line 3\n    >>> '''\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 1, "target_api_invocations": ["is_string"], "context": [{"fname": "__remove_internal_spaces", "evidence": "This method removes leading and trailing spaces from a regex match group, which is a likely step in stripping margins from multiline strings."}]}
{"function": "decompress", "target_function_prompt": "def decompress(input_string: str, encoding: str = 'utf-8') -> str:\n    \"\"\"\n    Restore a previously compressed string (obtained using `compress()`) back to its original state.\n\n    :param input_string: String to restore.\n    :type input_string: str\n    :param encoding: Original string encoding.\n    :type encoding: str\n    :return: Decompressed string.\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["__StringCompressor.decompress"], "context": [{"fname": "decompress", "evidence": "This node contains the actual implementation of string decompression invoked by the target function."}, {"fname": "__require_valid_input_and_encoding", "evidence": "Input validation for string type, non-empty input, and encoding is essential before decompression; this function performs those checks and is likely called."}, {"fname": "is_string", "evidence": "Type checking for string input is a fundamental requirement for decompress, making this utility function a likely candidate to be invoked."}]}
{"function": "roman_encode", "target_function_prompt": "def roman_encode(input_number: Union[str, int]) -> str:\n    \"\"\"\n    Convert the given number/string into a roman number.\n\n    The passed input must represents a positive integer in the range 1-3999 (inclusive).\n\n    Why this limit? You may be wondering:\n\n    1. zero is forbidden since there is no related representation in roman numbers\n    2. the upper bound 3999 is due to the limitation in the ascii charset\\\n    (the higher quantity sign displayable in ascii is \"M\" which is equal to 1000, therefore based on\\\n    roman numbers rules we can use 3 times M to reach 3000 but we can't go any further in thousands without\\\n    special \"boxed chars\").\n\n    *Examples:*\n\n    >>> roman_encode(37) # returns 'XXXVIII'\n    >>> roman_encode('2020') # returns 'MMXX'\n\n    :param input_number: An integer or a string to be converted.\n    :type input_number: Union[str, int]\n    :return: Roman number string.\n    \"\"\"\n", "f1_score": 0.33333333333333337, "recall": 1.0, "precision": 0.2, "context_size": 5, "target_api_invocations": ["__RomanNumbers.encode"], "context": [{"fname": "__encode_digit", "evidence": "__encode_digit is the fundamental utility that converts a single digit at a given place value into its Roman numeral string. Since roman_encode processes input digits individually to generate the whole roman numeral, it likely calls this helper method to encode each digit."}, {"fname": "encode", "evidence": "This encode method in the __RomanNumbers class matches exactly the target function's purpose and includes input validation and iterative digit encoding. The target function's implementation will almost certainly call this method or act as a thin wrapper calling it."}, {"fname": "validate", "evidence": "This validate function checks if a number is an integer within the allowed range 1-3999, which is exactly the validity criteria mentioned in the roman_encode docstring. The roman_encode function is expected to validate its input before conversion, so it is very plausible that it calls this validate utility."}, {"fname": "is_string", "evidence": "Checking if the input is a string is necessary to differentiate input types (str or int) and perform appropriate validation."}, {"fname": "is_integer", "evidence": "Integer validation is essential for input correctness, making this function a direct candidate for invocation."}]}
{"function": "roman_decode", "target_function_prompt": "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["__RomanNumbers.decode"], "context": [{"fname": "__index_for_sign", "evidence": "This utility finds the index of a Roman numeral sign, essential for decoding each symbol in the input string; it is likely invoked by roman_decode."}, {"fname": "decode", "evidence": "Node 1 describes and implements a decode function that matches exactly the task of roman_decode: decoding a Roman numeral string into an integer. It even internally calls reverse (which is in the file context) and performs all validation and parsing. This is directly relevant and will very likely be invoked or be the core of roman_decode."}, {"fname": "is_full_string", "evidence": "is_full_string provides essential validation to ensure the input is a non-empty meaningful string, a likely prerequisite check before decoding the roman numeral."}]}
{"function": "is_full_string", "target_function_prompt": "def is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n", "f1_score": 0.25, "recall": 1.0, "precision": 0.14285714285714285, "context_size": 7, "target_api_invocations": ["is_string"], "context": [{"fname": "snake_case_to_camel", "evidence": "The snake_case_to_camel function implementation calls is_full_string when filtering tokens to convert. This demonstrates that is_full_string can be invoked to check if substrings are considered non-empty. The target function's purpose is exactly such a check, so it is reasonable that other functions performing string case transformations (like snake_case_to_camel) could invoke is_full_string."}, {"fname": "is_camel_case", "evidence": "The is_camel_case function depends on the target function is_full_string for validation before matching regex. Its logic requires checking if input_string is non-empty and not just spaces, exactly what is_full_string does. Since this function invokes is_full_string directly, the target function could be used/invoked in this context."}, {"fname": "is_snake_case", "evidence": "The implementation of is_snake_case explicitly calls is_full_string to check if the input string is non-empty and has at least one non-space character. Since the target function is_full_string performs exactly that validation, it is directly invoked in the is_snake_case function."}, {"fname": "is_slug", "evidence": "The is_slug function uses is_full_string to verify that the input string is not empty or whitespace-only before proceeding with regex matching. This indicates that is_full_string is invoked within is_slug."}, {"fname": "is_isogram", "evidence": "is_isogram directly calls is_full_string in its implementation to ensure the string is not empty before checking its uniqueness property, demonstrating that is_full_string is used as a prerequisite validation."}, {"fname": "is_json", "evidence": "The implementation of is_json explicitly calls is_full_string to check if the input string is not empty before further JSON validation. Since is_json uses is_full_string, this function might be invoked during the implementation."}, {"fname": "is_string", "evidence": "The target function is is_full_string, which checks if a string is not empty. The is_string function determines if an object is a string at all, which is a natural prerequisite validation step before checking if it is a non-empty string. Thus, it is reasonable that is_full_string might invoke is_string."}]}
{"function": "is_integer", "target_function_prompt": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["is_number"], "context": [{"fname": "is_string", "evidence": "is_string is likely used to verify that the input is a string before integer format validation, making it essential in is_integer."}, {"fname": "is_number", "evidence": "The target function is_integer checks if a string represents an integer, which is a subset of a valid number. The is_number function determines whether a string is any valid number (integer, decimal, scientific notation), so it provides necessary broad validation that is_integer can build upon or use as a prerequisite."}, {"fname": "is_decimal", "evidence": "The target function is_integer needs to distinguish integers from decimals. The is_decimal function specifically checks if a string is a decimal (including scientific notation), which complements is_integer by identifying non-integers. It is reasonable that is_integer could use is_decimal internally to exclude decimal numbers after confirming the string is a number."}]}
{"function": "is_decimal", "target_function_prompt": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["is_number"], "context": [{"fname": "is_string", "evidence": "The is_string function is likely crucial because validating input as a string is a necessary prerequisite before checking its decimal format; the target function may invoke this to ensure the input is a valid string."}, {"fname": "is_number", "evidence": "The target function is_decimal needs to determine if a string is a decimal number, which inherently requires validating that the string is some kind of number first. The is_number function precisely provides this numeric validation, including decimals, signed numbers, and scientific notation. This makes it highly likely that is_decimal will invoke is_number to first confirm the string represents a number."}, {"fname": "is_integer", "evidence": "The docstring for is_decimal explicitly distinguishes decimals from integers, and the is_integer function checks if the string represents an integer excluding decimals. The implementation of is_integer itself uses is_number and checks that there's no decimal point. Given that is_decimal must confirm the string is numeric but not integer, it is very probable that is_decimal will invoke is_integer to exclude integer strings, thus accurately identifying decimals."}]}
{"function": "is_url", "target_function_prompt": "def is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 6, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_ip_v4", "evidence": "Validating IPv4 addresses is relevant for URL host validation; is_url likely calls is_ip_v4 for host checking."}, {"fname": "is_ip_v6", "evidence": "Validating IPv6 addresses is relevant for URL host validation; is_url likely calls is_ip_v6 for host checking."}, {"fname": "is_ip", "evidence": "URL validation commonly requires checking whether the host component is a valid IP address, so is_url might invoke is_ip."}, {"fname": "is_string", "evidence": "is_url will likely verify that the input is a string before further validation by invoking is_string."}, {"fname": "is_number", "evidence": "URL components such as port numbers are numeric and may require validation, so is_url might invoke is_number to check numeric parts."}, {"fname": "is_integer", "evidence": "Port numbers and other integral URL components need to be integers; is_url might invoke is_integer to validate such parts."}]}
{"function": "is_email", "target_function_prompt": "def is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_full_string", "evidence": "Ensuring the input is a non-empty string is a logical prerequisite for email validation."}, {"fname": "contains_html", "evidence": "Checking for presence of HTML tags is a reasonable validation step in email input validation to reject malformed input."}, {"fname": "is_string", "evidence": "Basic type-checking to confirm input is a string is fundamental and likely invoked before deeper validation."}]}
{"function": "is_credit_card", "target_function_prompt": "def is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 1, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_number", "evidence": "is_number checks if a string is a valid numeric representation. Credit card numbers are numeric strings with digit-only restrictions, so this function or similar numeric validations may be invoked to preliminarily validate input format."}]}
{"function": "is_camel_case", "target_function_prompt": "def is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 3, "target_api_invocations": ["is_full_string"], "context": [{"fname": "camel_case_to_snake", "evidence": "The function camel_case_to_snake directly calls is_camel_case to validate if the input string follows camel case format before conversion. Since the target function checks if a string is camel case, this utility logically relies on it and hence would invoke is_camel_case."}, {"fname": "is_snake_case", "evidence": "The target function is_camel_case checks string formatting style and includes conditions about string content and structure similar to snake case checking. The is_snake_case function is a closely related sibling utility that validates string format patterns (letter/digit composition, separators, no-leading-digit) similar to those needed for camel case checks. It also internally calls is_full_string, which is likely relevant to the target function's input validation. Therefore, is_camel_case may invoke is_snake_case or reuse components/logic from it to validate or contrast camel case formatting."}, {"fname": "is_string", "evidence": "The target function's docstring indicates it takes 'input_string' and checks its format rigorously. The is_string function provides a fundamental type check to verify if the input is a string, which is a natural and essential first step in the validation. This aligns perfectly with the initial requirement in the docstring that the input must be a string before further camel case checking proceeds."}]}
{"function": "is_snake_case", "target_function_prompt": "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 4, "target_api_invocations": ["is_full_string"], "context": [{"fname": "camel_case_to_snake", "evidence": "The target function is_snake_case checks if a string is snake case. Node 1 provides camel_case_to_snake, which relies on checking if a string is camel case (using is_camel_case) and string type validation, then transforms camel case to snake case. The conversion between camel and snake case is closely related to the concept of snake case detection, so is_snake_case might invoke camel_case_to_snake as part of verifying related conversions or for normalization scenarios. At minimum, the naming similarity and relevance to snake case imply potential invocation."}, {"fname": "is_camel_case", "evidence": "Node 3 provides is_camel_case, a validation function that checks if a string is in camel case format. The target function's docstring includes the requirement that the string should only contain certain character sets and start conditions, somewhat similar to camel case validation. Since camel case and snake case validations are related conceptually, is_snake_case might invoke is_camel_case to cross-check or help validate the input or ensure it is not camel case (for distinguishing) or to reuse the common validation code patterns. Also, the implementations in the codebase show these functions sharing input checks."}, {"fname": "is_slug", "evidence": "is_slug checks a similar string format with separators and could be reused or called by is_snake_case for validating snake case formatting."}, {"fname": "is_string", "evidence": "is_string provides input type validation, which is necessary to ensure input is a string before applying snake case checks."}]}
{"function": "is_json", "target_function_prompt": "def is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 2, "target_api_invocations": ["is_full_string"], "context": [{"fname": "strip_margin", "evidence": "Stripping leading indentation could be a useful preprocessing step before parsing multiline JSON strings."}, {"fname": "is_string", "evidence": "The function is_string provides a fundamental type check to confirm input is a string, which is a necessary prerequisite to safely parse JSON. Thus, is_json would likely invoke is_string to validate its input before JSON parsing."}]}
{"function": "is_ip_v4", "target_function_prompt": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_ip_v6", "evidence": "The is_ip_v6 function validates IPv6 addresses similarly to how is_ip_v4 validates IPv4 addresses. It is plausible that is_ip_v4 or related IP validation logic might invoke is_ip_v6 for complementary or fallback checking or shared validation patterns."}, {"fname": "is_full_string", "evidence": "The target function needs to validate that input is a non-empty string before IPv4 format checks; is_full_string is a natural validation helper."}, {"fname": "is_string", "evidence": "Ensuring the input is a string is an essential first step in the target function; is_string is likely invoked for this."}, {"fname": "is_number", "evidence": "The target function is_ip_v4 checks if a string is a valid IPv4 address which involves validating numeric components in the IP segments, so a utility that checks whether a string is a valid number is very likely to be invoked."}]}
{"function": "is_ip_v6", "target_function_prompt": "def is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_ip_v4", "evidence": "The is_ip_v6 function aims to validate an IP address, closely related to is_ip_v4 which validates IPv4 addresses. It is reasonable the IPv6 validator might reuse the IPv4 validation function to exclude IPv4 addresses or for shared validation utilities, or for common validation helper calls such as is_full_string. Given their conceptual and domain overlap, invocation is likely."}, {"fname": "is_full_string", "evidence": "is_ip_v6 should validate that input is a non-empty, non-space string before processing, making is_full_string a likely invocation."}, {"fname": "is_string", "evidence": "is_ip_v6 likely needs to confirm that input is a string; thus, invoking is_string directly or indirectly is a reasonable step."}]}
{"function": "is_ip", "target_function_prompt": "def is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n", "f1_score": 0.8, "recall": 1.0, "precision": 0.6666666666666666, "context_size": 3, "target_api_invocations": ["is_ip_v6", "is_ip_v4"], "context": [{"fname": "is_ip_v4", "evidence": "The target function 'is_ip' specifically checks if input is a valid IP, including IPv4. This node provides 'is_ip_v4', a direct and essential sub-check that 'is_ip' is highly likely to invoke to perform the IPv4 validation portion of its logic."}, {"fname": "is_ip_v6", "evidence": "Similarly, 'is_ip' needs to validate IPv6 addresses. The node 'is_ip_v6' supplies the IPv6 validation logic. Given the target function needs to check both IPv4 and IPv6, it will almost certainly invoke this function."}, {"fname": "is_string", "evidence": "is_ip likely needs to verify that input is a string before validation, so it would invoke is_string to check input type."}]}
{"function": "is_palindrome", "target_function_prompt": "def is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    *Examples:*\n\n    >>> is_palindrome('LOL') # returns true\n    >>> is_palindrome('Lol') # returns false\n    >>> is_palindrome('Lol', ignore_case=True) # returns true\n    >>> is_palindrome('ROTFL') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param ignore_spaces: False if white spaces matter (default), true otherwise.\n    :type ignore_spaces: bool\n    :param ignore_case: False if char case matters (default), true otherwise.\n    :type ignore_case: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\\\n    False otherwise\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 4, "target_api_invocations": ["is_full_string"], "context": [{"fname": "reverse", "evidence": "Reversing the string is a key step in checking palindrome property, and the implementation validates string input. The target function will likely call this to compare original and reversed strings."}, {"fname": "is_isogram", "evidence": "The target function is_palindrome checks properties of strings related to their characters and uniqueness. The is_isogram function also validates string character uniqueness and uses the is_full_string function for input validation, which could be relevant as a helper or validation subroutine when checking palindrome characteristics such as ignoring spaces or ensuring meaningful input."}, {"fname": "is_pangram", "evidence": "is_pangram analyzes complete alphabetic coverage in a string, involving substring manipulations and set membership checks similar to what is_palindrome might do when processing the string (e.g., via character filtering). The shared usage of is_full_string suggests this function or similar logic might be reused or invoked."}, {"fname": "__remove_internal_spaces", "evidence": "Removing leading and trailing spaces from parts of the string aligns with preparing the input when ignoring spaces in palindrome checks."}]}
{"function": "is_pangram", "target_function_prompt": "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["is_full_string"], "context": [{"fname": "slugify", "evidence": "slugify lowercases and removes punctuation from strings, providing useful normalization that is_pangram may invoke to preprocess the input before checking for pangram status."}, {"fname": "is_full_string", "evidence": "Validating that the input string is non-empty and meaningful is a necessary step for the pangram check, making this function likely to be invoked."}, {"fname": "__remove_internal_spaces", "evidence": "Removing internal spaces is important preprocessing for pangram detection to clean the string and focus on letters."}]}
{"function": "is_isogram", "target_function_prompt": "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 2, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_camel_case", "evidence": "is_camel_case checks if a string is formatted as camel case by validating its content. is_isogram requires verifying the string's characters and might invoke is_camel_case to test or pre-validate input styles or as part of conditional logic (e.g., ignoring certain formatting). Since is_camel_case handles string format validation and returns a boolean, it is plausible for is_isogram to call it to ensure input type or format."}, {"fname": "is_pangram", "evidence": "The pangram function uses set-based operations to analyze letters in a string, which is conceptually relevant to detecting duplicates for an isogram check, making invocation plausible."}]}
{"function": "is_slug", "target_function_prompt": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 5, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_camel_case", "evidence": "The target function might validate if input_string exhibits specific casing or formatting properties. Since is_slug checks if a string is a valid slug (usually lowercase and separator joined), it might internally use other casing validators like is_camel_case as part of broader checks or to exclude camel case strings. Moreover, is_camel_case shares a naming pattern consistent with the codebase for string format checks."}, {"fname": "slugify", "evidence": "slugify transforms arbitrary strings into slugs that are lowercase, punctuation-free, and separator-joined, exactly the kind of string that is_slug is designed to verify. Most likely, is_slug will compare the given string to the output of slugify or use slugify as a helper to check validity. The similar domain and matching functionality strongly support invocation."}, {"fname": "is_snake_case", "evidence": "The target function is_slug checks if a string is a slug using a separator. The is_snake_case function similarly checks if a string conforms to a separator-based formatted naming style. Since slugs are conceptually similar to snake_case but with different separator conventions (e.g., '-'), is_slug might invoke is_snake_case with the given separator to reuse existing validation logic for separator-based naming patterns."}, {"fname": "__ensure_left_space_only", "evidence": "Ensuring only a single leading space is plausible for input normalization before slug pattern validation, so this helper might be invoked."}, {"fname": "__remove_internal_spaces", "evidence": "Removing leading/trailing spaces from parts of the input is likely needed to clean the string prior to checking if it conforms to a slug pattern."}]}
{"function": "contains_html", "target_function_prompt": "def contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 2, "target_api_invocations": ["is_string"], "context": [{"fname": "strip_html", "evidence": "Stripping HTML tags is directly relevant; the target function can leverage this to detect if tags exist by comparing pre/post stripping strings."}, {"fname": "is_full_string", "evidence": "The target function likely calls is_full_string to validate that the input is a non-empty string containing at least one non-space character before checking for HTML tags."}]}
{"function": "words_count", "target_function_prompt": "def words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 1, "target_api_invocations": ["is_string"], "context": [{"fname": "is_full_string", "evidence": "Validating that input is a non-empty meaningful string before counting words is plausible and common practice."}]}
{"function": "is_isbn_10", "target_function_prompt": "def is_isbn_10(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 10 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_10('1506715214') # returns true\n    >>> is_isbn_10('150-6715214') # returns true\n    >>> is_isbn_10('150-6715214', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 10, false otherwise.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["__ISBNChecker.is_isbn_10"], "context": [{"fname": "is_number", "evidence": "Checking if parts of the input string are valid numeric values aligns with the need to validate digits in ISBN checksum calculation."}, {"fname": "is_integer", "evidence": "Verifying that portions of the string are integer digits is relevant to validate the ISBN 10 format."}, {"fname": "is_isbn_13", "evidence": "The ISBN-13 validation function is closely related and uses the same checker class, indicating likely coexistence or invocation in handling ISBN formats."}, {"fname": "is_isbn_10", "evidence": "The target function is_isbn_10 needs to check if a given string is a valid ISBN-10 number, optionally normalizing the input string by removing hyphens. The node's function is the core method __ISBNChecker.is_isbn_10() that performs the actual validation logic on a cleaned input string, including length check and checksum calculation. Therefore, the target function would likely instantiate __ISBNChecker with the normalized string and call this method to determine validity, making this node a clear internal API that would be invoked."}]}
{"function": "is_isbn_13", "target_function_prompt": "def is_isbn_13(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 13 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_13('9780312498580') # returns true\n    >>> is_isbn_13('978-0312498580') # returns true\n    >>> is_isbn_13('978-0312498580', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 13, false otherwise.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["__ISBNChecker.is_isbn_13"], "context": [{"fname": "is_number", "evidence": "is_number validates if a string represents a number, a necessary step to check that the normalized ISBN string contains only digits before checksum validation."}, {"fname": "is_isbn_10", "evidence": "The ISBN-10 validator shares significant logic or helper usage with the ISBN-13 validation, and the target function might invoke or share internal logic with it to assist in processing."}, {"fname": "is_isbn", "evidence": "The is_isbn function offers a utility that validates both ISBN-10 and ISBN-13 by normalizing input and calling respective validations; the target function might invoke it to reuse this logic or for input preprocessing."}, {"fname": "is_isbn_13", "evidence": "This method performs the core ISBN-13 validation by checking length and checksum, which the target function is very likely to invoke after input normalization."}]}
{"function": "is_isbn", "target_function_prompt": "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n", "f1_score": 0.4444444444444445, "recall": 1.0, "precision": 0.2857142857142857, "context_size": 7, "target_api_invocations": ["__ISBNChecker.is_isbn_13", "__ISBNChecker.is_isbn_10"], "context": [{"fname": "booleanize", "evidence": "The 'booleanize' utility might be invoked to convert input strings to boolean values for the 'normalize' parameter if needed."}, {"fname": "is_number", "evidence": "Numeric validation functions can be invoked by is_isbn to assert that the input consists mostly of digits, aiding the validation process."}, {"fname": "is_integer", "evidence": "Since ISBNs contain only digits (except possibly 'X'), the function may use integer validation to confirm numeric sections of the ISBN string."}, {"fname": "is_isbn_10", "evidence": "The target function is_isbn aims to check if a string represents a valid ISBN of either type 10 or 13. The detailed docstring and common practices suggest delegating the specific type checks to specialized functions is_isbn_10 and is_isbn_13."}, {"fname": "is_isbn_13", "evidence": "Same as node #3, is_isbn_13 validates ISBN-13 specifically. Given the target function covers both ISBN-10 and ISBN-13, it is very likely to invoke this function as part of the combined validation."}, {"fname": "is_isbn_13", "evidence": "The target function is_isbn checks if the input string is a valid ISBN of either type 10 or 13 by delegating the check to specialized validation functions for these types. Node 1's is_isbn_13 method of __ISBNChecker validates whether the input string is a proper ISBN-13 format. Given the docstring specifying that the function returns true if the string represents either ISBN-10 or ISBN-13, it is very likely that is_isbn will invoke is_isbn_13 internally to check that variant."}, {"fname": "is_isbn_10", "evidence": "Similarly, the target function aims to validate ISBN strings that may be of type 10. Node 2's is_isbn_10 method provides the required validation logic for ISBN-10 format. To fully implement is_isbn, the function needs to check for the ISBN-10 format as well. Hence, it is very plausible and consistent that is_isbn calls is_isbn_10 as part of its validation process for completeness."}]}
{"function": "roman_range", "target_function_prompt": "def roman_range(stop: int, start: int = 1, step: int = 1) -> Generator:\n    \"\"\"\n    Similarly to native Python's `range()`, returns a Generator object which generates a new roman number\n    on each iteration instead of an integer.\n\n    *Example:*\n\n    >>> for n in roman_range(7): print(n)\n    >>> # prints: I, II, III, IV, V, VI, VII\n    >>> for n in roman_range(start=7, stop=1, step=-1): print(n)\n    >>> # prints: VII, VI, V, IV, III, II, I\n\n    :param stop: Number at which the generation must stop (must be <= 3999).\n    :param start: Number at which the generation must start (must be >= 1).\n    :param step: Increment of each generation step (default to 1).\n    :return: Generator of roman numbers.\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["roman_encode"], "context": [{"fname": "roman_encode", "evidence": "The target function generates Roman numerals from integers and needs a conversion function; roman_encode exactly provides this functionality."}, {"fname": "validate", "evidence": "The validate function matches the target's need to check input parameters are integers within the valid range (1-3999), making it very likely to be invoked."}]}
