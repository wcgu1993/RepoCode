{"function": "reverse", "target_function_prompt": "def reverse(input_string: str) -> str:\n    \"\"\"\n    Returns the string with its chars reversed.\n\n    *Example:*\n\n    >>> reverse('hello') # returns 'olleh'\n\n    :param input_string: String to revert.\n    :type input_string: str\n    :return: Reversed string.\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_string"], "context": [{"fname": "is_string", "evidence": "The target function 'reverse' expects a string input. It is common practice in this codebase (as seen in `booleanize` and `__StringCompressor.compress` within the provided file content) to validate inputs using `is_string` to ensure they are of the expected type before proceeding with the core logic. Therefore, 'is_string' could be invoked for input validation."}, {"fname": "is_full_string", "evidence": "The `reverse` function takes a string as input. It is common practice for functions to validate their inputs. `is_full_string` can be invoked to ensure that the `input_string` provided to `reverse` is indeed a non-empty string with meaningful content before proceeding with the reversal logic, thus enhancing robustness or adhering to API contracts."}]}
{"function": "camel_case_to_snake", "target_function_prompt": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n", "f1_score": 0.8, "recall": 1.0, "precision": 0.6666666666666666, "context_size": 3, "target_api_invocations": ["is_string", "is_camel_case"], "context": [{"fname": "is_camel_case", "evidence": "The docstring for `camel_case_to_snake` explicitly states: 'The original string is returned if is not a valid camel case string'. This implies a validation step is required, and `is_camel_case` is precisely the function designed to perform this validation, making its invocation highly probable."}, {"fname": "is_string", "evidence": "The target function takes `input_string` as a parameter. It is a common and good practice, as well as a pattern observed in the provided file content (e.g., `reverse`, `__RomanNumbers`, `__StringCompressor` also use string validation), to validate function inputs. `is_string` would be used to ensure the `input_string` argument is indeed a string."}, {"fname": "is_full_string", "evidence": "The target function `camel_case_to_snake` processes an `input_string`. It is a common and good practice to validate input parameters to ensure they are non-empty and valid strings before performing operations. The `is_full_string` function perfectly fits this need by checking if the input is a meaningful (non-empty, non-whitespace-only) string, which is crucial for a string conversion function."}]}
{"function": "snake_case_to_camel", "target_function_prompt": "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    \"\"\"\n    Convert a snake case string into a camel case one.\n    (The original string is returned if is not a valid snake case string)\n\n    *Example:*\n\n    >>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param upper_case_first: True to turn the first letter into uppercase (default).\n    :type upper_case_first: bool\n    :param separator: Sign to use as separator (default to \"_\").\n    :type separator: str\n    :return: Converted string\n    \"\"\"\n", "f1_score": 0.4, "recall": 0.3333333333333333, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_snake_case", "is_string", "is_full_string"], "context": [{"fname": "__uppercase_first_char", "evidence": "The target function `snake_case_to_camel` inherently needs to convert parts of the input string to uppercase (e.g., the first letter of each segment). This helper function directly performs such an operation on a regex match, making it a highly relevant candidate if the conversion uses regex-based replacement with a callback."}, {"fname": "is_snake_case", "evidence": "The target function's docstring explicitly states, 'The original string is returned if is not a valid snake case string'. The `is_snake_case` function is perfectly designed to perform this exact validation on the input string, making its invocation highly probable."}]}
{"function": "strip_html", "target_function_prompt": "def strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n", "f1_score": 0.19999999999999998, "recall": 1.0, "precision": 0.1111111111111111, "context_size": 9, "target_api_invocations": ["is_string"], "context": [{"fname": "__placeholder_key", "evidence": "The 'strip_html' function might use temporary placeholders to protect and re-insert specific content (like 'keep_tag_content') during a multi-step HTML removal process, similar to how __StringFormatter handles special elements."}, {"fname": "__ensure_right_space_only", "evidence": "The `strip_html` function removes HTML code. After removing tags, the resulting string might contain inconsistent or excessive whitespace (e.g., from `<div> <span>` becoming ` `). `__ensure_right_space_only` is a whitespace normalization utility, and it is plausible that `strip_html` would invoke such a function for post-processing to ensure the final output string is clean and properly formatted."}, {"fname": "__ensure_left_space_only", "evidence": "Similar to `__ensure_right_space_only`, `__ensure_left_space_only` is a whitespace normalization utility. After removing HTML tags, the extracted or remaining content might require consistent leading spaces, making this function a plausible invocation for post-processing the output string."}, {"fname": "__ensure_spaces_around", "evidence": "The `__ensure_spaces_around` function is another whitespace normalization utility. As `strip_html` processes and removes HTML, it's common for text manipulation functions to clean up surrounding whitespace, ensuring the final output is well-formatted. This function serves that purpose for regex-matched segments."}, {"fname": "__remove_internal_spaces", "evidence": "When `keep_tag_content=True`, `strip_html` needs to extract the content from within HTML tags. This extracted content might have leading or trailing whitespace. `__remove_internal_spaces`, which strips whitespace from a regex-matched group, would be directly useful for cleaning up this extracted content before it's returned."}, {"fname": "prettify", "evidence": "After HTML tags are removed, the remaining plain text might require general formatting (e.g., spacing, capitalization) to improve readability. The `prettify` function offers such capabilities, making it a plausible post-processing step for the `strip_html` function."}, {"fname": "is_string", "evidence": "The `strip_html` function takes an `input_string` parameter. It is a common and good practice to validate input types, especially for public API functions. The `is_string` function provides exactly this capability for type checking the `input_string`."}, {"fname": "is_full_string", "evidence": "The `strip_html` function takes a string as input. It is a common and good practice to validate input arguments. The `is_full_string` function checks if a string is non-empty and contains meaningful content, which is a suitable validation step for `input_string` in the target function."}, {"fname": "contains_html", "evidence": "To 'remove html code' as per the target function's purpose, the function first needs to identify or detect HTML tags. The `contains_html` function is explicitly designed for this purpose, making it highly probable that `strip_html` would invoke it or leverage its underlying mechanism to find and subsequently remove HTML."}]}
{"function": "prettify", "target_function_prompt": "def prettify(input_string: str) -> str:\n    \"\"\"\n    Reformat a string by applying the following basic grammar and formatting rules:\n\n    - String cannot start or end with spaces\n    - The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n    - String cannot have multiple sequential spaces, empty lines or punctuation (except for \"?\", \"!\" and \".\")\n    - Arithmetic operators (+, -, /, \\\\*, =) must have one, and only one space before and after themselves\n    - One, and only one space should follow a dot, a comma, an exclamation or a question mark\n    - Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and \\\n    after quotes (foo\" bar\"baz -> foo \"bar\" baz)\n    - Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and \\\n    after brackets (\"foo(bar )baz\" -> \"foo (bar) baz\")\n    - Percentage sign (\"%\") cannot be preceded by a space if there is a number before (\"100 %\" -> \"100%\")\n    - Saxon genitive is correct (\"Dave' s dog\" -> \"Dave's dog\")\n\n    *Examples:*\n\n    >>> prettify(' unprettified string ,, like this one,will be\"prettified\" .it\\\\' s awesome! ')\n    >>> # -> 'Unprettified string, like this one, will be \"prettified\". It\\'s awesome!'\n\n    :param input_string: String to manipulate\n    :return: Prettified string.\n    \"\"\"\n", "f1_score": 0.15384615384615385, "recall": 1.0, "precision": 0.08333333333333333, "context_size": 12, "target_api_invocations": ["__StringFormatter.format"], "context": [{"fname": "__placeholder_key", "evidence": "The 'prettify' function needs to apply complex formatting rules while potentially preserving certain substrings (like URLs or emails) from being altered. A common technique for this is to temporarily replace such substrings with unique placeholders, apply transformations, and then restore the original content. This function generates precisely such a unique placeholder, making it highly likely to be invoked for this purpose."}, {"fname": "__uppercase_first_char", "evidence": "One of the explicit rules for 'prettify' is to capitalize the first letter of the string and letters after certain punctuation marks. This function specifically transforms a regex match into its uppercase equivalent, which is an ideal utility to be used as a replacement function in a regular expression substitution (re.sub) call to implement this capitalization rule."}, {"fname": "__remove_duplicates", "evidence": "The target function requires removing multiple sequential spaces or punctuation, which directly aligns with this helper's purpose of reducing duplicate characters captured by a regex, making it highly likely to be invoked as a regex replacement callback."}, {"fname": "__ensure_right_space_only", "evidence": "The target function specifies that 'One, and only one space should follow a dot, a comma, an exclamation or a question mark'. This helper function is designed to ensure exactly one trailing space after a regex match, perfectly fitting this requirement as a replacement callback."}, {"fname": "__ensure_left_space_only", "evidence": "The target function has rules like 'Arithmetic operators must have one, and only one space before' and similar rules for text within quotes/brackets. This helper is designed to ensure a single leading space, making it a suitable invocation as a regex replacement callback for such formatting."}, {"fname": "__ensure_spaces_around", "evidence": "The target function requires that 'Arithmetic operators must have one, and only one space before and after themselves' and similar spacing for quotes and brackets. This helper function directly achieves this by ensuring single spaces on both sides of a matched substring, making it highly relevant for invocation."}, {"fname": "__remove_internal_spaces", "evidence": "The target function specifies that 'Text inside double quotes cannot start or end with spaces' and similarly for round brackets. This helper function is designed to remove surrounding whitespace from a captured regex group, directly addressing these formatting rules for internal content."}, {"fname": "__fix_saxon_genitive", "evidence": "The target function's docstring explicitly lists 'Saxon genitive is correct' as a rule. This function, `__fix_saxon_genitive`, is specifically designed to normalize Saxon genitive forms, making it a direct candidate for invocation by `prettify`."}, {"fname": "format", "evidence": "The `__StringFormatter.format` method implements a comprehensive set of text normalization rules, including many specific formatting and grammar adjustments (e.g., spacing, capitalization, handling quotes, saxon genitive, preserving URLs/emails) that directly align with the detailed rules outlined in the `prettify` target function's docstring. It is highly probable that `prettify` serves as a public interface for this underlying formatting logic."}, {"fname": "is_string", "evidence": "The 'prettify' function accepts a string input. As seen in other public API functions in the same file, input validation using 'is_string' is a common pattern to ensure the input is of the expected type before proceeding with string manipulation."}, {"fname": "is_number", "evidence": "The 'prettify' function explicitly states a rule: 'Percentage sign ('%') cannot be preceded by a space if there is a number before'. To implement this rule, the function would need to identify numerical sequences within the string, which 'is_number' is designed to do."}, {"fname": "is_full_string", "evidence": "The 'prettify' function operates on an input string and would likely require initial validation to ensure it's a non-empty string, which 'is_full_string' specifically provides. The function's rules also imply dealing with string content rather than just empty strings or whitespace."}]}
{"function": "asciify", "target_function_prompt": "def asciify(input_string: str) -> str:\n    \"\"\"\n    Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n    (eg: ó -> o, Ë -> E, ç -> c...).\n\n    **Bear in mind**: Some chars may be lost if impossible to translate.\n\n    *Example:*\n\n    >>> asciify('èéùúòóäåëýñÅÀÁÇÌÍÑÓË') # returns 'eeuuooaaeynAAACIINOE'\n\n    :param input_string: String to convert\n    :return: Ascii utf-8 string\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_string"], "context": [{"fname": "is_string", "evidence": "The `asciify` function takes a string as input, and it is common practice for such functions to validate their input. The `is_string` utility is designed precisely for this type checking."}, {"fname": "is_full_string", "evidence": "The `asciify` function processes a string input, and a common first step for robust string manipulation functions is to validate that the input is indeed a non-empty string. The `is_full_string` function provides precisely this validation."}]}
{"function": "slugify", "target_function_prompt": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('Mönstér Mägnët') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n", "f1_score": 0.5, "recall": 0.5, "precision": 0.5, "context_size": 2, "target_api_invocations": ["asciify", "is_string"], "context": [{"fname": "is_string", "evidence": "The `slugify` function takes an `input_string: str` parameter. It is a common and robust practice for functions to validate their input types. `is_string` provides a direct utility for this purpose, ensuring the input is indeed a string before processing."}, {"fname": "is_full_string", "evidence": "Input validation is a common practice for functions that manipulate strings. The `slugify` function would likely validate its `input_string` to ensure it's a non-empty string before performing transformations, aligning with the `is_full_string` utility."}]}
{"function": "booleanize", "target_function_prompt": "def booleanize(input_string: str) -> bool:\n    \"\"\"\n    Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\n    A positive boolean (True) is returned if the string value is one of the following:\n\n    - \"true\"\n    - \"1\"\n    - \"yes\"\n    - \"y\"\n\n    Otherwise False is returned.\n\n    *Examples:*\n\n    >>> booleanize('true') # returns True\n    >>> booleanize('YES') # returns True\n    >>> booleanize('nope') # returns False\n\n    :param input_string: String to convert\n    :type input_string: str\n    :return: True if the string contains a boolean-like positive value, false otherwise\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_string"], "context": [{"fname": "is_string", "evidence": "The `booleanize` function explicitly takes a `str` as input. The codebase heavily utilizes `is_string` for initial input validation in similar string utility functions, making it highly probable that `booleanize` would invoke `is_string` to validate its `input_string` parameter."}, {"fname": "is_full_string", "evidence": "The `booleanize` function takes a string as input. It is good practice for such a function to first validate that the input is a non-empty string with meaningful content. `is_full_string` directly provides this capability, ensuring the input is valid before proceeding with the boolean conversion logic."}]}
{"function": "strip_margin", "target_function_prompt": "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    *Example:*\n\n    >>> strip_margin('''\n    >>>                 line 1\n    >>>                 line 2\n    >>>                 line 3\n    >>> ''')\n    >>> # returns:\n    >>> '''\n    >>> line 1\n    >>> line 2\n    >>> line 3\n    >>> '''\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_string"], "context": [{"fname": "is_string", "evidence": "The 'strip_margin' function takes a string as input, and it is a common practice within this codebase (as seen in other functions like 'reverse', 'camel_case_to_snake', etc.) to validate input types using 'is_string' at the beginning of the function."}, {"fname": "is_full_string", "evidence": "The `strip_margin` function takes a string as input and should validate that input to ensure it's a non-empty string. The `is_full_string` function directly provides this exact validation, checking if the input is a string and contains at least one non-space character, which is a common and necessary first step for string manipulation functions."}]}
{"function": "decompress", "target_function_prompt": "def decompress(input_string: str, encoding: str = 'utf-8') -> str:\n    \"\"\"\n    Restore a previously compressed string (obtained using `compress()`) back to its original state.\n\n    :param input_string: String to restore.\n    :type input_string: str\n    :param encoding: Original string encoding.\n    :type encoding: str\n    :return: Decompressed string.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["__StringCompressor.decompress"], "context": [{"fname": "__require_valid_input_and_encoding", "evidence": "The target function `decompress` needs to validate its input string and encoding before proceeding with decompression. This utility function `__require_valid_input_and_encoding` provides exactly this necessary validation, making it highly probable for invocation."}, {"fname": "decompress", "evidence": "The target function `decompress` is a public API function, and based on common patterns (as seen with the `compress` function calling `__StringCompressor.compress`), it is highly likely that the public `decompress` function will invoke this private class method `__StringCompressor.decompress` to perform the actual decompression logic."}, {"fname": "is_string", "evidence": "The target function `decompress` processes string inputs (`input_string` and `encoding`). It is common practice for such functions to validate their input types. The existing `__StringCompressor` class, which likely provides the core decompression logic, utilizes `__require_valid_input_and_encoding` which in turn calls `is_string` to validate parameters. Thus, `is_string` is highly probable to be invoked."}, {"fname": "is_full_string", "evidence": "The target function `decompress` needs to validate its `input_string` and `encoding` parameters are valid strings. Node 2, `is_full_string`, provides a common utility for validating that a string is not empty or composed solely of whitespace, which is a plausible validation requirement for the input to a decompression function."}]}
{"function": "roman_encode", "target_function_prompt": "def roman_encode(input_number: Union[str, int]) -> str:\n    \"\"\"\n    Convert the given number/string into a roman number.\n\n    The passed input must represents a positive integer in the range 1-3999 (inclusive).\n\n    Why this limit? You may be wondering:\n\n    1. zero is forbidden since there is no related representation in roman numbers\n    2. the upper bound 3999 is due to the limitation in the ascii charset\\\n    (the higher quantity sign displayable in ascii is \"M\" which is equal to 1000, therefore based on\\\n    roman numbers rules we can use 3 times M to reach 3000 but we can't go any further in thousands without\\\n    special \"boxed chars\").\n\n    *Examples:*\n\n    >>> roman_encode(37) # returns 'XXXVIII'\n    >>> roman_encode('2020') # returns 'MMXX'\n\n    :param input_number: An integer or a string to be converted.\n    :type input_number: Union[str, int]\n    :return: Roman number string.\n    \"\"\"\n", "f1_score": 0.25, "recall": 1.0, "precision": 0.14285714285714285, "context_size": 8, "target_api_invocations": ["__RomanNumbers.encode"], "context": [{"fname": "None", "evidence": "Given that 'roman_encode' is the public API for Roman numeral conversion, and its implementation in the file content explicitly calls '__RomanNumbers.encode', this summary node, if representing Roman number utilities, would logically include the core internal conversion logic that 'roman_encode' depends on and invokes."}, {"fname": "__encode_digit", "evidence": "The `__encode_digit` function is an internal helper specifically designed to convert a single decimal digit to its Roman numeral representation. The implementation of the `__RomanNumbers.encode` (which the target function `roman_encode` is expected to invoke as a wrapper, based on the surrounding file content's pattern) explicitly calls this `__encode_digit` method to build the final Roman numeral string."}, {"fname": "encode", "evidence": "The `encode` method of the `__RomanNumbers` class directly implements the core logic for converting integers to Roman numerals. Given the common pattern in this codebase (as seen with `compress` and `decompress` functions), the public `roman_encode` function is highly likely to be a thin wrapper that invokes this `__RomanNumbers.encode` method to perform its primary task."}, {"fname": "is_string", "evidence": "The target function accepts a Union[str, int] for input. `is_string` is a basic type validation utility that would be used to determine if the provided `input_number` is a string, which is a crucial first step for subsequent string-based validation or processing."}, {"fname": "is_number", "evidence": "The target function must handle string inputs that represent integers. `is_number` is a utility that validates if a given string represents a numeric value (including integers), which is a necessary validation step before attempting to convert the string to an integer for Roman numeral conversion."}, {"fname": "is_integer", "evidence": "The `roman_encode` function accepts string input which must be validated as an integer. This `is_integer` utility directly fulfills that validation requirement, as also seen in the internal `__RomanNumbers.encode` implementation."}, {"fname": "validate", "evidence": "The `roman_encode` function's docstring explicitly states the input must be an integer within the range 1-3999. The `validate` function directly implements this precise type and range validation logic, making it a highly relevant utility for the target function to invoke."}, {"fname": "is_full_string", "evidence": "The target function accepts string input. Before attempting to convert or validate a string as an integer, it is a good practice to ensure the string itself is not empty or composed solely of whitespace, which `is_full_string` provides as a preliminary validation step."}]}
{"function": "roman_decode", "target_function_prompt": "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n", "f1_score": 0.33333333333333337, "recall": 1.0, "precision": 0.2, "context_size": 5, "target_api_invocations": ["__RomanNumbers.decode"], "context": [{"fname": "reverse", "evidence": "The target function 'roman_decode' is shown in the provided file content to explicitly call 'reverse(input_string.upper())' as its first step to process the Roman numeral string from right to left, making this a direct invocation."}, {"fname": "__index_for_sign", "evidence": "The '__index_for_sign' function provides the positional index for a Roman numeral character, which is crucial for determining its value and applying the correct decoding rules within the 'roman_decode' function's logic."}, {"fname": "decode", "evidence": "The 'decode' function, from the '__RomanNumbers' class, performs the exact operation that the target 'roman_decode' function needs to accomplish, and the file context shows that 'roman_decode' directly invokes it for its implementation."}, {"fname": "is_string", "evidence": "The target function expects a string input, and its docstring implies validation ('if the provided string is valid'). This `is_string` function is a fundamental utility for type checking and validating that the input is indeed a string before proceeding with decoding."}, {"fname": "is_full_string", "evidence": "The `roman_decode` function takes a string as input. It is critical to validate that the input string is not empty or composed solely of whitespace to avoid unexpected errors during processing. The actual `__RomanNumbers.decode` implementation in the file content explicitly invokes `is_full_string` for this purpose."}]}
{"function": "is_full_string", "target_function_prompt": "def is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 1, "target_api_invocations": ["is_string"], "context": [{"fname": "is_string", "evidence": "The target function 'is_full_string' takes an 'Any' type as input, but its logic is specifically for strings (e.g., checking for emptiness or non-space characters). The example 'is_full_string(None) # returns false' strongly suggests an initial type check is needed. The 'is_string' function is perfectly suited to perform this validation, ensuring the input is indeed a string before further processing."}]}
{"function": "is_integer", "target_function_prompt": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["is_number"], "context": [{"fname": "is_string", "evidence": "The target function 'is_integer' expects a string input. It is common practice for functions, especially in this codebase (as seen in `__ISBNChecker` and `booleanize`), to validate their inputs. The 'is_string' function provides this exact capability to ensure the input is indeed a string before further processing."}, {"fname": "is_number", "evidence": "An integer is a specific type of number. The 'is_integer' function can leverage 'is_number' to first determine if the input string represents any valid number (including integers, decimals, or scientific notation) as a prerequisite, before applying further checks to confirm it's specifically an integer and not a decimal like '42.0'."}, {"fname": "is_decimal", "evidence": "The 'is_integer' docstring specifically states that '42.0' should return false, meaning it must distinguish between integer and decimal representations. The 'is_decimal' function directly identifies strings with a decimal point, making it a suitable helper to ensure the 'is_integer' function excludes decimal numbers."}, {"fname": "is_full_string", "evidence": "The `is_integer` function takes a string as input. It is a common and robust practice for functions that parse or validate string content to first ensure the input is indeed a non-empty, meaningful string. `is_full_string` serves this exact purpose, checking for an actual string that contains at least one non-whitespace character, which is a necessary prerequisite before attempting to determine if its content represents an integer."}]}
{"function": "is_decimal", "target_function_prompt": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["is_number"], "context": [{"fname": "is_string", "evidence": "The target function `is_decimal` takes `input_string: str` as an argument. It is a common pattern in this codebase, as seen in `is_number` and `booleanize`, to first validate if the input is indeed a string using `is_string`."}, {"fname": "is_number", "evidence": "For a string to represent a decimal, it must first be a valid number. The `is_number` function provides this foundational check, and the `is_decimal` function would likely invoke it as a prerequisite, similar to how `is_integer` uses `is_number`."}, {"fname": "is_integer", "evidence": "The `is_decimal` function's examples (e.g., '42.0' is true, '42' is false) indicate it needs to distinguish decimals from integers. `is_integer` checks precisely this distinction, so `is_decimal` could be implemented using `is_number` and then checking that the string is 'not an integer' or by using the same logic as `is_integer` but in reverse (i.e., `is_number` and `.` is present)."}, {"fname": "is_full_string", "evidence": "The 'is_decimal' function expects a string input and should validate its format. It is a common and robust practice for such validation functions to first ensure the input string is not empty or composed solely of whitespace before attempting more complex parsing logic. The 'is_full_string' function directly provides this initial input validation."}]}
{"function": "is_url", "target_function_prompt": "def is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n", "f1_score": 0.33333333333333337, "recall": 1.0, "precision": 0.2, "context_size": 5, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_ip_v4", "evidence": "A valid URL's network location (hostname) can be an IPv4 address (e.g., 'http://192.168.1.1/path'). During URL parsing and validation, if the hostname component is identified as a potential IP address, the 'is_url' function might delegate the specific validation of that component to 'is_ip_v4' to ensure it's a syntactically and numerically correct IPv4 address. This is a common sub-validation task within comprehensive URL validation."}, {"fname": "is_ip_v6", "evidence": "A robust URL validation function often needs to check if the host component is a valid IP address. While `is_url` validates the overall URL structure, it could delegate the specific validation of an IPv6 host to `is_ip_v6`."}, {"fname": "is_ip", "evidence": "Similar to `is_ip_v6`, `is_ip` provides a unified check for both IPv4 and IPv6 addresses. A URL can contain an IP address as its host, and `is_url` might use this function to validate that specific part of the URL."}, {"fname": "is_string", "evidence": "The target function `is_url` accepts an `input_string: Any`, indicating a need to validate that the input is indeed a string before processing. The `is_string` function directly provides this exact type-checking utility."}, {"fname": "is_full_string", "evidence": "The `is_url` function needs to validate its `input_string` parameter. A fundamental step in validating a URL string is to first ensure that the input is indeed a non-empty string with meaningful content, which is exactly what `is_full_string` provides. It's a common pattern to use such a utility for initial input validation before performing more complex parsing."}]}
{"function": "is_email", "target_function_prompt": "def is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_string", "evidence": "The `is_email` function takes `Any` as input, implying it might need to validate if the input is indeed a string before proceeding with email format checks. The `is_string` function is perfectly suited for this initial type validation, as seen in other functions in the file content like `is_full_string` and `is_url`."}, {"fname": "is_full_string", "evidence": "The 'is_full_string' function checks if an input is a non-empty string after stripping whitespace. This is a common and necessary first validation step for functions like 'is_email' to ensure the input is a meaningful string before attempting more complex pattern matching for email format. The file context also shows 'is_url' using 'is_full_string' for similar pre-validation."}]}
{"function": "is_credit_card", "target_function_prompt": "def is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["is_full_string"], "context": [{"fname": "reverse", "evidence": "The Luhn algorithm, a common checksum method for credit card validation, often involves processing digits from right to left. Reversing the input string is a direct way to facilitate this processing."}, {"fname": "is_string", "evidence": "The `is_credit_card` function accepts `input_string: Any`. It is a common and robust practice to first validate that an 'Any' input is indeed of the expected type (a string in this case). The `is_string` function is perfectly suited for this initial input validation step."}, {"fname": "is_number", "evidence": "Credit card numbers are fundamentally numeric strings. While they have specific format and checksum rules (e.g., Luhn algorithm), a foundational check often involves ensuring that the input string (or its cleaned version) consists entirely of digits. `is_number` provides a utility to confirm if a string represents a valid numeric value, which would be a logical prerequisite for further credit card specific numeric checks."}, {"fname": "is_full_string", "evidence": "The `is_credit_card` function receives an `input_string` of type `Any`. It is a standard practice for string validation functions to first ensure the input is indeed a non-empty string with meaningful content before proceeding with specific validation logic. `is_full_string` serves this exact purpose, checking if the input is a string and not merely empty or whitespace."}]}
{"function": "is_camel_case", "target_function_prompt": "def is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_string", "evidence": "The target function `is_camel_case` takes an `Any` type input, and its first logical step would be to validate that the input is indeed a string. The `is_string` function provides exactly this capability for type checking."}, {"fname": "is_full_string", "evidence": "The target function 'is_camel_case' checks string formatting and would likely first validate its input using 'is_full_string' to ensure it's a non-empty string before applying camel case specific rules. This is a common pattern for validation functions."}]}
{"function": "is_snake_case", "target_function_prompt": "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_string", "evidence": "The target function `is_snake_case` takes an `input_string` of `Any` type. A common first step in validation functions is to ensure the input is indeed a string before performing string-specific operations. The `is_string` function directly provides this exact capability."}, {"fname": "is_number", "evidence": "The target function's docstring states: 'it does not start with a number'. To implement this check, the `is_snake_case` function would likely need to examine the first character of the `input_string` and determine if it's a digit. The `is_number` function, which checks if a string represents a numeric value, could be invoked on the first character (e.g., `is_number(input_string[0])`) to fulfill this specific requirement."}, {"fname": "is_full_string", "evidence": "The target function `is_snake_case` needs to validate that its `input_string` parameter is a non-empty string before performing snake case specific checks. Node 1, `is_full_string`, is designed specifically for this purpose, checking if an object is a string and contains at least one non-space character. This is a common initial validation step for string-based utility functions in this codebase, as observed in the `is_camel_case` function which is a peer to `is_snake_case` and already uses `is_full_string`."}]}
{"function": "is_json", "target_function_prompt": "def is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_string", "evidence": "The `is_json` function takes an `Any` type for `input_string`. It's a common and good practice for functions that operate on string content to first validate that the input object is indeed a string. The `is_string` function provides this exact preliminary type check, aligning with existing patterns in the file content where `is_string` or `is_full_string` are used for input validation in other functions (e.g., `booleanize`, `is_url`, `is_email`)."}, {"fname": "is_full_string", "evidence": "The `is_json` function takes an `Any` type input and needs to ensure it's a meaningful string before attempting JSON parsing. The `is_full_string` function checks if an input is a non-empty string after stripping whitespace. It is a common and reasonable pre-validation step for `is_json` to first confirm its `input_string` parameter is a valid, non-empty string before attempting to load it as JSON, as an empty or whitespace-only string is not valid JSON and would likely lead to a parsing error that could be avoided with this preliminary check."}]}
{"function": "is_ip_v4", "target_function_prompt": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_string", "evidence": "The `is_ip_v4` function takes `Any` as input but expects a string. A common and robust practice for validation functions is to first verify that the input is of the expected type. The `is_string` function directly provides this essential input validation capability, as seen in other functions in the file like `is_full_string` and `booleanize`."}, {"fname": "is_number", "evidence": "An IPv4 address consists of four numeric octets separated by dots. The `is_number` function checks if a string represents a valid number. After splitting the IP string by dots, `is_ip_v4` would need to validate that each resulting segment is indeed a number before performing range checks (0-255). This function is directly useful for validating the numeric format of each octet."}, {"fname": "is_integer", "evidence": "IPv4 octets must be whole numbers (integers), not decimals. The `is_integer` function specifically checks if a string represents an integer. This is a more precise validation for an IP octet than `is_number` alone, as it ensures no decimal points are present, which is a requirement for IPv4 segments."}, {"fname": "is_full_string", "evidence": "The target function `is_ip_v4` expects a string input. It is a common pattern in validation functions to first verify that the input is a non-empty string before proceeding with more complex checks. This function provides exactly that initial validation step."}]}
{"function": "is_ip_v6", "target_function_prompt": "def is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_string", "evidence": "The target function `is_ip_v6` takes an `Any` type as input but expects a string. It is a common pattern in this codebase (as seen in `is_ip_v4`, `is_full_string`, `is_number`, etc.) to use `is_string` or a similar check to validate the input type before proceeding with string-specific logic."}, {"fname": "is_full_string", "evidence": "The `is_full_string` function checks if an input is a non-empty string after stripping whitespace. This is a common initial validation step for functions like `is_ip_v6` (as seen in `is_url`, `is_email`, `is_ip_v4` in the file content) to ensure the input is a valid and meaningful string before proceeding with complex regex or parsing logic for IPv6 validation."}]}
{"function": "is_ip", "target_function_prompt": "def is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 4, "target_api_invocations": ["is_ip_v6", "is_ip_v4"], "context": [{"fname": "is_ip_v4", "evidence": "The target function 'is_ip' aims to check for both IPv4 and IPv6 addresses. Invoking 'is_ip_v4' is the direct and logical way to determine if the input string is a valid IPv4 address as part of the overall IP validation."}, {"fname": "is_ip_v6", "evidence": "The target function 'is_ip' aims to check for both IPv4 and IPv6 addresses. Invoking 'is_ip_v6' is the direct and logical way to determine if the input string is a valid IPv6 address as part of the overall IP validation."}, {"fname": "is_string", "evidence": "The target function `is_ip` takes an `Any` type for `input_string`. It is a common pattern in this codebase (as seen in `is_number`, `is_url`, `is_email`, etc., in the file content) to first validate if the input is actually a string or a 'full string' using `is_string` or `is_full_string` before proceeding with specific string validations. Therefore, `is_string` would likely be invoked for initial input validation."}, {"fname": "is_full_string", "evidence": "The `is_ip` function is expected to validate a string input. It is a common pattern in the provided file content (e.g., `is_ip_v4`, `is_ip_v6`, `is_url`, `is_email`) to first use `is_full_string` to ensure the input is a non-empty string before performing more specific validation logic. Therefore, `is_ip` is highly likely to invoke `is_full_string` for initial input validation."}]}
{"function": "is_palindrome", "target_function_prompt": "def is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    *Examples:*\n\n    >>> is_palindrome('LOL') # returns true\n    >>> is_palindrome('Lol') # returns false\n    >>> is_palindrome('Lol', ignore_case=True) # returns true\n    >>> is_palindrome('ROTFL') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param ignore_spaces: False if white spaces matter (default), true otherwise.\n    :type ignore_spaces: bool\n    :param ignore_case: False if char case matters (default), true otherwise.\n    :type ignore_case: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\\\n    False otherwise\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["is_full_string"], "context": [{"fname": "reverse", "evidence": "The core logic of checking if a string is a palindrome involves comparing it to its reversed version. The 'reverse' function provides exactly this functionality and would be a direct invocation for the target function."}, {"fname": "__remove_internal_spaces", "evidence": "If the 'is_palindrome' function implements the 'ignore_spaces' logic using regular expressions (common in this codebase as seen from file content) and 're.sub' with a replacement function, this method could be invoked. When 're.sub' matches whitespace and passes it to this function as 'regex_match.group(1)', 'strip()' on that whitespace effectively returns an empty string, thereby removing the space."}, {"fname": "is_string", "evidence": "The `is_palindrome` function accepts an `Any` type for `input_string` but expects a string for its core logic. The `is_string` function provides a direct and common way to validate if the `input_string` is indeed a string before performing string manipulations (like stripping spaces or changing case), which is a standard practice visible in other functions in the provided file content."}, {"fname": "is_full_string", "evidence": "The 'is_palindrome' function operates on a string input. It is common practice for string-processing functions to first validate that the input is indeed a non-empty string. 'is_full_string' provides exactly this type of initial validation, ensuring the input is valid before proceeding with palindrome specific logic."}]}
{"function": "is_pangram", "target_function_prompt": "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n", "f1_score": 0.33333333333333337, "recall": 1.0, "precision": 0.2, "context_size": 5, "target_api_invocations": ["is_full_string"], "context": [{"fname": "words_count", "evidence": "While not part of the core pangram logic, `words_count` could be invoked for purposes like logging statistics about the input string or for an initial validation check (e.g., a string with zero words cannot be a pangram)."}, {"fname": "format", "evidence": "This method performs comprehensive string normalization, including handling capitalization and spacing. For a pangram check, the input string often needs to be pre-processed (e.g., converted to a consistent case and cleaned of non-essential characters) to accurately identify all alphabetic letters, a task this method is well-suited for."}, {"fname": "prettify", "evidence": "This function applies a comprehensive set of grammar and style rules, standardizing spacing, capitalization, and punctuation. Such string normalization is a crucial pre-processing step for a pangram check, as it simplifies the process of extracting and identifying unique alphabetic characters regardless of their initial formatting."}, {"fname": "is_string", "evidence": "The target function `is_pangram` expects a string input. As shown in other functions within the file content (e.g., `is_full_string`, `is_number`, `is_credit_card`), it is a common pattern in this codebase to validate input types using `is_string` before processing, especially when the input type is `Any`."}, {"fname": "is_full_string", "evidence": "The `is_pangram` function needs to ensure its input is a valid, non-empty string before proceeding with the pangram check. The `is_full_string` function is specifically designed to perform this initial validation by checking if the input is a string and contains at least one non-space character, which is a common prerequisite for string-based validation functions in this codebase (as seen in `is_palindrome`)."}]}
{"function": "is_isogram", "target_function_prompt": "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_full_string"], "context": [{"fname": "is_string", "evidence": "The 'is_isogram' function takes an input of type 'Any' and is expected to operate on strings. It is a common pattern in this codebase (as seen in `booleanize`, `is_number`, etc.) to validate input types using `is_string` before proceeding with string-specific logic, thus `is_string` is likely invoked for input validation."}, {"fname": "is_full_string", "evidence": "The 'is_isogram' function needs to process a string. It is highly probable that it would first validate its input to ensure it is indeed a full (non-empty, non-whitespace) string, which is exactly what 'is_full_string' provides. This is a common and necessary input validation step for string-based operations."}]}
{"function": "is_slug", "target_function_prompt": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n", "f1_score": 0.2857142857142857, "recall": 1.0, "precision": 0.16666666666666666, "context_size": 6, "target_api_invocations": ["is_full_string"], "context": [{"fname": "__remove_duplicates", "evidence": "The target function 'is_slug' checks if a string is a valid slug. Slugs, as created by 'slugify()', do not typically contain consecutive separators (e.g., 'my--post'). If 'is_slug' performs internal normalization to collapse such sequences (similar to 'is_isbn' replacing hyphens before validation), this helper could be used with `re.sub` to ensure only single separators remain, aligning the input string to a canonical slug form for validation."}, {"fname": "__remove_internal_spaces", "evidence": "A valid slug should not contain any spaces, including leading/trailing spaces within its 'words' or segments. If 'is_slug' uses regex to capture segments of the input string (e.g., words between separators), this helper could be invoked to ensure those captured segments are strictly free of surrounding whitespace as part of a robust validation or internal normalization step, similar to how other 'is_X' functions in the codebase perform internal cleanup."}, {"fname": "slugify", "evidence": "The target function `is_slug` explicitly states it checks if a string is 'as created by `slugify()`'. A common and robust way to implement such an `is_X` function is to invoke the `to_X` function (e.g., `slugify`) on the input and compare the result to the original, assuming `slugify` is idempotent for valid slugs. This direct relationship makes invocation highly probable for verification."}, {"fname": "is_snake_case", "evidence": "The `is_slug` function checks for a specific string format (kebab-case or snake-case with a custom separator). The `is_snake_case` function, which uses a configurable separator and regex-based validation for character sets and separator placement, provides highly relevant logic that can be directly applied or adapted to check for slug format."}, {"fname": "is_string", "evidence": "The `is_slug` function expects `input_string` to be a string. It is a common and good practice within this codebase (as observed in other functions provided in the file content) to perform an initial type check using `is_string` to ensure the input is of the correct type before proceeding with string-specific operations."}, {"fname": "is_full_string", "evidence": "A slug must be a non-empty string containing meaningful content. The `is_full_string` function is specifically designed to perform this exact validation by checking if the input is a string and not empty after stripping whitespace. This is a common and necessary initial check for string-based validation functions like `is_slug`, and its usage pattern is consistent with other `is_` functions in the codebase."}]}
{"function": "contains_html", "target_function_prompt": "def contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_string"], "context": [{"fname": "is_string", "evidence": "The target function `contains_html` accepts an `input_string` parameter. It is a common pattern in this codebase, as seen in other functions (e.g., `is_full_string`, `is_email`), to perform initial input validation using `is_string` to ensure the input is indeed a string before processing."}, {"fname": "is_full_string", "evidence": "The target function `contains_html` takes a string as input. It is common practice for functions processing string inputs to first validate that the input is indeed a non-empty string. `is_full_string` provides this exact capability, ensuring the input is a meaningful string before proceeding with HTML detection logic."}]}
{"function": "words_count", "target_function_prompt": "def words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["is_string"], "context": [{"fname": "is_string", "evidence": "The target function `words_count` expects `input_string: str`. It is a common and good practice in this codebase (as seen by other `is_*` functions and `InvalidInputError`) to validate input types. `is_string` is perfectly suited for this initial validation."}, {"fname": "is_number", "evidence": "The target function's docstring defines a 'word' as a 'sequence of one or more letter and/or numbers'. After segmenting the input string, `is_number` could be invoked to determine if a segment is a valid numeric word (e.g., '42', '1e3'), contributing to the word count, thus aligning with the definition of a 'word' including numbers."}, {"fname": "is_full_string", "evidence": "The `words_count` function needs to process a string, and it's a common practice for string processing functions to first validate if the input is a meaningful (non-empty, non-whitespace-only) string. `is_full_string` directly provides this capability, aligning with the implied need to handle inputs like empty strings or strings with only non-word characters, which should result in a zero word count."}, {"fname": "strip_html", "evidence": "The `words_count` function aims to count 'sequences of one or more letter and/or numbers'. If the input string could contain HTML, HTML tags themselves are not words and would interfere with an accurate count. `strip_html` (especially with `keep_tag_content=True`) would be a valuable preprocessing step to remove these non-word structural elements, allowing the core counting logic to operate on the true textual content."}]}
{"function": "is_isbn_10", "target_function_prompt": "def is_isbn_10(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 10 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_10('1506715214') # returns true\n    >>> is_isbn_10('150-6715214') # returns true\n    >>> is_isbn_10('150-6715214', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 10, false otherwise.\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["__ISBNChecker.is_isbn_10"], "context": [{"fname": "is_isbn_10", "evidence": "The target function (public API) is named identically and has the same core purpose as this `__ISBNChecker` class method. It is a common pattern for a public function to instantiate a helper class and delegate the core logic, including the specific ISBN-10 checksum calculation and length check, to an internal method like this one, handling the `normalize` parameter and initial string preparation."}, {"fname": "is_string", "evidence": "Input validation is a crucial step for robust functions. The target function takes a string input, and this `is_string` utility is perfectly suited to ensure the input is of the expected type before proceeding with ISBN validation. The `__ISBNChecker` class's `__init__` (visible in the file context) already uses `is_string`, indicating it's part of the standard validation flow for ISBN-related checks."}, {"fname": "is_full_string", "evidence": "The `is_isbn_10` function needs to perform initial validation on its `input_string` to ensure it is a non-empty string. The `is_full_string` function provides exactly this capability, which is a common first step in string-based validation routines."}]}
{"function": "is_isbn_13", "target_function_prompt": "def is_isbn_13(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 13 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_13('9780312498580') # returns true\n    >>> is_isbn_13('978-0312498580') # returns true\n    >>> is_isbn_13('978-0312498580', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 13, false otherwise.\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["__ISBNChecker.is_isbn_13"], "context": [{"fname": "is_isbn_13", "evidence": "The target function `is_isbn_13` is designed to validate ISBN-13 strings. Based on the file content's `is_isbn_10` implementation and the presence of `__ISBNChecker` class, it is highly probable that the public `is_isbn_13` function will instantiate `__ISBNChecker` and then invoke this specific `is_isbn_13` method from the class to perform the core validation logic."}, {"fname": "is_string", "evidence": "The `__ISBNChecker` class, which the target `is_isbn_13` function is expected to instantiate (as demonstrated by the `is_isbn_10` function in the file content), uses `is_string` within its `__init__` method for input validation. Therefore, `is_string` will be invoked indirectly when the target function creates an instance of `__ISBNChecker`."}, {"fname": "is_full_string", "evidence": "The `is_full_string` function ensures a string is not empty or composed solely of whitespace, which is a common initial validation step for any function processing string inputs like `is_isbn_13`. Reviewing other public validation functions in the provided file content (e.g., `is_url`, `is_email`), they frequently utilize `is_full_string` for this purpose, indicating a consistent codebase pattern. Therefore, it is highly probable that `is_isbn_13` would invoke `is_full_string` to validate its `input_string` before performing ISBN-specific checks."}]}
{"function": "is_isbn", "target_function_prompt": "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 6, "target_api_invocations": ["__ISBNChecker.is_isbn_13", "__ISBNChecker.is_isbn_10"], "context": [{"fname": "is_isbn_10", "evidence": "The target function `is_isbn` must determine if a string is a valid ISBN-10 or ISBN-13. This node describes and implements the `is_isbn_10` function, which directly performs the ISBN-10 validation required by the target function. It is highly likely to be invoked."}, {"fname": "is_isbn_13", "evidence": "The target function `is_isbn` must determine if a string is a valid ISBN-10 or ISBN-13. This node describes and implements the `is_isbn_13` function, which directly performs the ISBN-13 validation required by the target function. It is highly likely to be invoked."}, {"fname": "is_isbn_13", "evidence": "The target function `is_isbn` checks for ISBN-13 validity. This node describes the `is_isbn_13` method of the `__ISBNChecker` class, which contains the core ISBN-13 validation logic. While the public `is_isbn_13` function (Node 2) typically wraps this method, the target function *could* directly instantiate `__ISBNChecker` and invoke this method to perform the required ISBN-13 validation."}, {"fname": "is_isbn_10", "evidence": "The target function `is_isbn` checks for ISBN-10 validity. This node describes the `is_isbn_10` method of the `__ISBNChecker` class, which contains the core ISBN-10 validation logic. Similar to Node 4, the target function *could* directly instantiate `__ISBNChecker` and invoke this method to perform the required ISBN-10 validation."}, {"fname": "is_string", "evidence": "The target function expects a string input. Defensive programming and existing patterns in the file content (e.g., `__ISBNChecker`'s `is_string` check) suggest that `is_string` would likely be invoked for input validation."}, {"fname": "is_full_string", "evidence": "The 'is_full_string' function checks if an input is a non-empty string with meaningful content. The target function 'is_isbn' is a string validation function, and it is a common pattern in this codebase (as seen in other functions like 'is_url', 'is_email', 'is_ip_v4', etc. within the file context) to first validate that the input string is not empty or just whitespace before performing more complex checks. Therefore, 'is_isbn' would likely invoke 'is_full_string' for initial input validation."}]}
{"function": "roman_range", "target_function_prompt": "def roman_range(stop: int, start: int = 1, step: int = 1) -> Generator:\n    \"\"\"\n    Similarly to native Python's `range()`, returns a Generator object which generates a new roman number\n    on each iteration instead of an integer.\n\n    *Example:*\n\n    >>> for n in roman_range(7): print(n)\n    >>> # prints: I, II, III, IV, V, VI, VII\n    >>> for n in roman_range(start=7, stop=1, step=-1): print(n)\n    >>> # prints: VII, VI, V, IV, III, II, I\n\n    :param stop: Number at which the generation must stop (must be <= 3999).\n    :param start: Number at which the generation must start (must be >= 1).\n    :param step: Increment of each generation step (default to 1).\n    :return: Generator of roman numbers.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["roman_encode"], "context": [{"fname": "roman_encode", "evidence": "The 'roman_encode' function converts an integer to its Roman numeral string representation. The target function 'roman_range' explicitly states it 'generates a new roman number on each iteration', making 'roman_encode' essential for performing this conversion within the generator loop."}, {"fname": "encode", "evidence": "The `encode` function converts an integer into its corresponding Roman numeral string, handling values within the range 1-3999. The `roman_range` function's core task is to generate Roman numbers from integers within a similar range, making this `encode` function a direct fit for converting each integer in the range to its Roman numeral representation."}, {"fname": "generate", "evidence": "The target function's docstring specifies that it generates Roman numerals. This node describes and implements the core generator logic, explicitly showing an invocation of `roman_encode` which is essential for converting integers to Roman numerals as required by `roman_range`."}, {"fname": "validate", "evidence": "The `roman_range` docstring specifies constraints for `stop` (must be <= 3999) and `start` (must be >= 1). The `validate` function directly implements checks for an integer within the exact range 1-3999, which is a perfect match for validating the `start` and `stop` parameters."}]}
