{"function": "no_map_instance", "target_function_prompt": "def no_map_instance(instance: T) -> T:\n    r\"\"\"Register a container instance as `non-mappable`, i.e., it will be treated as a singleton object in\n    :func:`map_structure` and :func:`map_structure_zip`, its contents will not be traversed.\n\n    :param instance: The container instance.\n    \"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 1, "target_api_invocations": ["_no_map_type"], "context": [{"fname": "_no_map_type", "evidence": "No evidence provided"}]}
{"function": "map_structure", "target_function_prompt": "def map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["fn"], "context": []}
{"function": "map_structure_zip", "target_function_prompt": "def map_structure_zip(fn: Callable[..., R], objs: Sequence[Collection[T]]) -> Collection[R]:\n    r\"\"\"Map a function over tuples formed by taking one elements from each (possibly nested) collection. Each collection\n    must have identical structures.\n\n    .. note::\n    Although identical structures are required, it is not enforced by assertions. The structure of the first\n    collection is assumed to be the structure for all collections.\n\n    :param fn: The function to call on elements.\n    :param objs: The list of collections to map function over.\n    :return: A collection with the same structure, with elements mapped.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["fn"], "context": []}
{"function": "scanr", "target_function_prompt": "def scanr(func, iterable, *args):\n    r\"\"\"Computes the intermediate results of :py:func:`~functools.reduce` applied in reverse. Equivalent to Haskell's\n    ``scanr``. For example:\n\n    .. code:: python\n\n    >>> scanr(operator.add, [1, 2, 3, 4], 0)\n    [10, 9, 7, 4, 0]\n    >>> scanr(lambda s, x: x + s, ['a', 'b', 'c', 'd'])\n    ['abcd', 'bcd', 'cd', 'd']\n\n    Learn more at `Learn You a Haskell: Higher Order Functions <http://learnyouahaskell.com/higher-order-functions>`_.\n\n    :param func: The function to apply. This should be a binary function where the arguments are: the accumulator,\n    and the current element.\n    :param iterable: The list of elements to iteratively apply the function to.\n    :param initial: The initial value for the accumulator. If not supplied, the first element in the list is used.\n    :return: The intermediate results at each step, starting from the end.\n    \"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 1, "target_api_invocations": ["scanl"], "context": [{"fname": "scanl", "evidence": "No evidence provided"}]}
