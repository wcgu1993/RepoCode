{"function": "no_map_instance", "target_function_prompt": "def no_map_instance(instance: T) -> T:\n    r\"\"\"Register a container instance as `non-mappable`, i.e., it will be treated as a singleton object in\n    :func:`map_structure` and :func:`map_structure_zip`, its contents will not be traversed.\n\n    :param instance: The container instance.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["_no_map_type"], "context": []}
{"function": "map_structure", "target_function_prompt": "def map_structure(fn: Callable[[T], R], obj: Collection[T]) -> Collection[R]:\n    r\"\"\"Map a function over all elements in a (possibly nested) collection.\n\n    :param fn: The function to call on elements.\n    :param obj: The collection to map function over.\n    :return: The collection in the same structure, with elements mapped.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["fn"], "context": []}
{"function": "map_structure_zip", "target_function_prompt": "def map_structure_zip(fn: Callable[..., R], objs: Sequence[Collection[T]]) -> Collection[R]:\n    r\"\"\"Map a function over tuples formed by taking one elements from each (possibly nested) collection. Each collection\n    must have identical structures.\n\n    .. note::\n    Although identical structures are required, it is not enforced by assertions. The structure of the first\n    collection is assumed to be the structure for all collections.\n\n    :param fn: The function to call on elements.\n    :param objs: The list of collections to map function over.\n    :return: A collection with the same structure, with elements mapped.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 4, "target_api_invocations": ["fn"], "context": [{"fname": "__len__", "evidence": "The target function likely needs to retrieve the length of collections for iteration or validation, making invocation of __len__ likely."}, {"fname": "__getitem__", "evidence": "Accessing elements by index to create tuples for function application is central, so __getitem__ invocation is expected."}, {"fname": "map_structure", "evidence": "The target function likely invokes or reuses map_structure's recursive logic for traversing nested structures to apply the function."}, {"fname": "None", "evidence": "The target function map_structure_zip is designed to map a function over tuples formed by taking one element from each collection in a sequence of collections that have identical nested structures. This is conceptually similar to the related function map_structure described in the file content. Given that map_structure handles applying a function recursively through nested collections, it is highly plausible that map_structure_zip would invoke map_structure or reuse its logic for traversing and mapping over nested structures, but combining elements across multiple collections instead of just one. The close similarity of purpose, and especially the mention that the structure of the first collection is assumed (similar to map_structure), supports the idea that map_structure or functions with similar traversal and mapping behaviors would be called. Also, the file content shows map_structure is a core utility in this mapping context, likely to be integrated or reused for implementing map_structure_zip."}]}
{"function": "scanr", "target_function_prompt": "def scanr(func, iterable, *args):\n    r\"\"\"Computes the intermediate results of :py:func:`~functools.reduce` applied in reverse. Equivalent to Haskell's\n    ``scanr``. For example:\n\n    .. code:: python\n\n    >>> scanr(operator.add, [1, 2, 3, 4], 0)\n    [10, 9, 7, 4, 0]\n    >>> scanr(lambda s, x: x + s, ['a', 'b', 'c', 'd'])\n    ['abcd', 'bcd', 'cd', 'd']\n\n    Learn more at `Learn You a Haskell: Higher Order Functions <http://learnyouahaskell.com/higher-order-functions>`_.\n\n    :param func: The function to apply. This should be a binary function where the arguments are: the accumulator,\n    and the current element.\n    :param iterable: The list of elements to iteratively apply the function to.\n    :param initial: The initial value for the accumulator. If not supplied, the first element in the list is used.\n    :return: The intermediate results at each step, starting from the end.\n    \"\"\"\n", "f1_score": 0.19999999999999998, "recall": 1.0, "precision": 0.1111111111111111, "context_size": 11, "target_api_invocations": ["scanl"], "context": [{"fname": "__iter__", "evidence": "The target function scanr processes iterables by applying a function; if the iterable is a MapList, its __iter__ method is invoked to iterate and map the function."}, {"fname": "__getitem__", "evidence": "scanr likely needs index/slice access to iterate from the end; if the iterable is a MapList, __getitem__ would be called to retrieve elements for function application."}, {"fname": "__iter__", "evidence": "If the iterable is a LazyListIterator, its __iter__ method will be called to prepare iteration protocol when scanr iterates."}, {"fname": "__next__", "evidence": "scanr advances iteration via next(); if using LazyListIterator, __next__ is called to retrieve each element lazily until completion."}, {"fname": "__iter__", "evidence": "If the iterable is a LazyList, scanr invokes its __iter__ to get an iterator, either lazy or cached, to begin processing elements."}, {"fname": "_fetch_until", "evidence": "scanr needs to fetch iterable elements on demand or fully; _fetch_until is a lazy fetching helper that supports this requirement."}, {"fname": "__len__", "evidence": "Determining the length of the iterable after full consumption is necessary for reverse scanning; __len__ supports this behavior."}, {"fname": "__getitem__", "evidence": "Accessing individual elements by index is essential for accumulating results in scanr, so __getitem__ with int index would be called."}, {"fname": "__getitem__", "evidence": "Slicing of the iterable is useful for processing subranges in scanr, making __getitem__ with slice relevant."}, {"fname": "__getitem__", "evidence": "The core __getitem__ method handles both int and slice indexing with lazy loading (_fetch_until) which are fundamental for scanr operation."}, {"fname": "scanl", "evidence": "Node 3 provides the full implementation of scanl, which scanr might invoke to perform left-to-right scans internally for implementing right-to-left scans."}]}
