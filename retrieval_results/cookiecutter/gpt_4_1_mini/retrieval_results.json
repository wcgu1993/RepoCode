{"function": "get_user_config", "target_function_prompt": "def get_user_config(config_file=None, default_config=False):\n    \"\"\"Return the user config as a dict.\n\n    If ``default_config`` is True, ignore ``config_file`` and return default\n    values for the config parameters.\n\n    If a path to a ``config_file`` is given, that is different from the default\n    location, load the user config from that.\n\n    Otherwise look up the config file path in the ``COOKIECUTTER_CONFIG``\n    environment variable. If set, load the config from this path. This will\n    raise an error if the specified path is not valid.\n\n    If the environment variable is not set, try the default config file path\n    before falling back to the default config values.\n    \"\"\"\n", "f1_score": 0.2857142857142857, "recall": 1.0, "precision": 0.16666666666666666, "context_size": 6, "target_api_invocations": ["get_config"], "context": [{"fname": "prompt_for_config", "evidence": "The node describes a function prompting the user for configuration via an interactive approach and rendering variables with environment and context. The target function get_user_config might invoke such a prompt function to obtain configuration interactively if no default or environment config is loaded, given its docstring mentions looking up configuration from various sources, including potentially manually supplied values."}, {"fname": "cookiecutter", "evidence": "The cookiecutter function explicitly calls get_user_config as part of its operation to obtain config dicts before proceeding. Since cookiecutter would invoke get_user_config, it is plausible that get_user_config and cookiecutter have a parent-child calling relationship the other way around as well, or get_user_config shares utilities with cookiecutter. Also, get_user_config can be used by cookiecutter, but within this evaluation, the cookiecutter implementation references get_user_config, indicating they belong to the same domain and that the functions or utilities cookiecutter uses might be invoked in get_user_config to help load or validate config. Moreover, cookiecutter uses get_user_config but it might also share similar or helper calls. Because cookiecutter calls get_user_config, it's less likely get_user_config calls cookiecutter (avoid recursion). But cookiecutter shows the context in which get_user_config is used, thus it shares config management functionality. However, the implementation of cookiecutter calls get_user_config, not the inverse. Therefore, strictly for invocation by get_user_config, it is false. So correction: On closer analysis, cookiecutter calls get_user_config, not the other way around. So get_user_config probably does not call cookiecutter."}, {"fname": "_expand_path", "evidence": "_expand_path function expands environment variables and user home paths, which is essential for resolving config file paths in get_user_config."}, {"fname": "list_installed_templates", "evidence": "'list_installed_templates' calls 'get_user_config' to obtain configuration data, so the target function is likely invoked during its execution, indicating a dependency in that direction."}, {"fname": "merge_configs", "evidence": "Recursively merges default and user config dictionaries; essential for combining configs in get_user_config."}, {"fname": "get_config", "evidence": "Loads, validates, parses YAML config files, merges with defaults and expands paths; directly supports config loading in get_user_config."}]}
