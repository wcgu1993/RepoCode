{"function": "parse", "target_function_prompt": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 10, "target_api_invocations": ["GoogleParser.parse"], "context": [{"fname": "_pairwise", "evidence": "The implementation of the target function `GoogleParser.parse` involves iterating over a list of matches (e.g., `self.titles_re.finditer`, `re.finditer`) and processing them in consecutive pairs to determine start and end points for chunks. The `_pairwise` function directly provides an efficient and idiomatic way to achieve this pattern of processing items in overlapping pairs, making it a strong candidate for invocation."}, {"fname": "_clean_str", "evidence": "The target function `parse` extensively processes and cleans strings. The `_clean_str` function is a utility designed for string cleaning, specifically for stripping whitespace and returning None for empty results. It's plausible that parts of the `parse` method's string manipulation (e.g., cleaning `short_description` or `long_description` parts) could invoke this helper function for consistency or to enforce specific cleaning logic, even if the current provided implementation uses direct `str.strip` and `inspect.cleandoc`."}, {"fname": "_parse_item", "evidence": "The target `parse` function needs to process individual sections of a docstring and convert them into structured metadata objects (like `DocstringRaises`). This `_parse_item` function performs precisely such a sub-task, constructing a `DocstringRaises` object from key-value pairs, and could be invoked by `parse` or its internal helpers."}, {"fname": "_parse_item", "evidence": "Similar to Node 3, this `_parse_item` function is responsible for parsing a specific docstring component (return type and description) into a structured `DocstringReturns` object. The `parse` function would need to perform this operation for 'returns' sections, making this a suitable candidate for invocation as an internal helper."}, {"fname": "_build_meta", "evidence": "The target function 'parse' explicitly invokes the '_build_meta' method to construct individual docstring elements for each parsed section, as seen in the line 'ret.meta.append(self._build_meta(part, title))'."}, {"fname": "_build_single_meta", "evidence": "The '_build_single_meta' method is invoked by '_build_meta' (which is called by 'parse') when processing singular docstring sections like 'Returns' or 'Yields' that do not match the multiple pattern, or any section of type SINGULAR."}, {"fname": "_build_multi_meta", "evidence": "The '_build_multi_meta' method is invoked by '_build_meta' (which is called by 'parse') when processing multi-item docstring sections such as 'Parameters', 'Returns', 'Yields', or 'Raises' that adhere to a specific pattern indicating multiple entries."}, {"fname": "parse", "evidence": "The target function's primary goal is to parse Google-style docstrings into various components, including `DocstringMeta` objects. This node describes a method that specifically parses text into `DocstringMeta` objects, making it a highly relevant sub-task or helper that the target function could invoke to process specific parts of the docstring."}, {"fname": "_setup", "evidence": "The `parse` method relies heavily on `self.titles_re` being correctly initialized to find section boundaries. This `_setup` method is responsible for setting up that regular expression for Google-style sections. Although `_setup` is typically called in `__init__`, the `parse` method could potentially invoke it (e.g., if it needed to re-initialize or validate its internal state related to section titles) as part of its robust implementation."}, {"fname": "_parse_item", "evidence": "The 'parse' function is responsible for parsing an entire docstring. This includes breaking down sections and parsing individual items like parameters. '_parse_item' explicitly handles parsing a 'raw key-value pair from a docstring's parameter section' and creating a 'DocstringParam'. This granular task is a clear sub-component of the main 'parse' logic, making it highly probable that 'parse' (or an internal helper of 'parse') would invoke such a function to process individual parameter entries."}]}
{"function": "parse", "target_function_prompt": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n", "f1_score": 0.16666666666666669, "recall": 1.0, "precision": 0.09090909090909091, "context_size": 11, "target_api_invocations": ["_build_meta"], "context": [{"fname": "_pairwise", "evidence": "Parsing multi-line structures like docstrings often involves iterating over lines while considering the context of adjacent lines. The _pairwise function, which processes an iterable in consecutive, overlapping pairs, is a common utility pattern used for such line-by-line parsing to identify blocks or continuation lines within a docstring."}, {"fname": "_clean_str", "evidence": "The `parse` function will likely need to clean individual lines or extracted text segments (e.g., descriptions, types, names) from the raw docstring to remove leading/trailing whitespace, which is precisely what `_clean_str` does."}, {"fname": "_build_meta", "evidence": "The `_build_meta` function (Node 4) is specifically designed to construct structured `DocstringMeta` objects from raw arguments and descriptions of docstring fields (like parameters, returns, and raises). When parsing a ReST-style docstring, the main `parse` function would likely identify these keyword-prefixed lines, extract their content, and then invoke `_build_meta` to create the appropriate structured metadata objects for the final `Docstring` output."}, {"fname": "parse", "evidence": "The target `parse` function needs to parse various sections of a ReST-style docstring, including deprecation information. This specific `parse` method is designed to parse deprecation text and yield `DocstringDeprecated` objects, making it a highly likely candidate for invocation by the main `parse` function to handle the deprecation section."}, {"fname": "_parse_item", "evidence": "The target `parse` function must parse a full ReST-style docstring, which includes 'raises' sections. This `_parse_item` function specifically parses and constructs `DocstringRaises` objects for individual exception entries. It's highly probable the main `parse` function would delegate to this helper for processing each 'raises' entry."}, {"fname": "_parse_item", "evidence": "The target `parse` function needs to handle return/yield information from the docstring. This `_parse_item` function is designed to parse a return key and description into a structured `DocstringReturns` object, making it a suitable helper for the `parse` function to process the docstring's return section."}, {"fname": "parse", "evidence": "The target function needs to parse a docstring into a `Docstring` object, which includes a list of `DocstringMeta` objects. This node's `parse` method takes section body text and yields `DocstringMeta` objects, indicating it could be invoked by the target function to parse individual sections or elements of the ReST docstring."}, {"fname": "parse", "evidence": "The target function must parse structured elements (like `:param`, `:returns`) in ReST-style docstrings, which often appear as key-value sections. This node's `parse` method specifically extracts key-value sections using regex and yields `DocstringMeta` objects, making it a highly suitable candidate for a sub-task within the ReST docstring parsing process."}, {"fname": "title_pattern", "evidence": "The `parse` function needs to identify different sections within a ReST-style docstring (e.g., 'Parameters', 'Returns'). This `title_pattern` method provides a regular expression pattern for matching a section header, which the `parse` function would likely use to locate and extract such sections from the input text."}, {"fname": "title_pattern", "evidence": "The `parse` function is designed for ReST-style docstrings, which frequently incorporate Sphinx directives. This `title_pattern` method provides a regular expression pattern specifically for matching Sphinx section directives. The `parse` function would need such patterns to accurately identify and parse these structured elements within the docstring text."}, {"fname": "_parse_item", "evidence": "The target function 'parse' needs to extract structured information from the docstring. This function, '_parse_item', specifically parses a raw key-value pair from a docstring's parameter section into a 'DocstringParam' object, which is a sub-task directly relevant and likely invoked during the overall parsing process by 'parse'."}]}
{"function": "parse", "target_function_prompt": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 10, "target_api_invocations": ["NumpydocParser.parse"], "context": [{"fname": "_pairwise", "evidence": "The implementation of the `NumpydocParser.parse` method (the target function) in the provided file content explicitly calls the `_pairwise` function (`for match, nextmatch in _pairwise(self.titles_re.finditer(meta_chunk))`). Therefore, this function will be invoked."}, {"fname": "_clean_str", "evidence": "The `_clean_str` function is used by various `Section` subclasses (e.g., `_KVSection`, `DeprecationSection`) to clean extracted text components. Since the target `parse` method iterates through sections and calls `factory.parse(meta_chunk[start:end])`, `_clean_str` will be indirectly invoked by these section parsing methods during the execution of the target function."}, {"fname": "parse", "evidence": "The target function `NumpydocParser.parse` iterates through recognized sections and calls the `parse` method of the corresponding `Section` object. `DeprecationSection` is one of the `DEFAULT_SECTIONS` that the parser can recognize and process, meaning its `parse` method will be invoked if a 'deprecated' section is found in the docstring."}, {"fname": "_parse_item", "evidence": "The target function `NumpydocParser.parse` calls the `parse` method of various `Section` subclasses (e.g., `RaisesSection`). The `_KVSection.parse` method (which `RaisesSection` inherits) explicitly calls its `_parse_item` method. Therefore, if a 'Raises' section is present in the docstring, `NumpydocParser.parse` will indirectly invoke `RaisesSection._parse_item`."}, {"fname": "_parse_item", "evidence": "Similar to `RaisesSection._parse_item`, `NumpydocParser.parse` calls the `parse` method of `ReturnsSection` (or `YieldsSection`). The `_KVSection.parse` method (which `ReturnsSection` inherits) explicitly calls its `_parse_item` method. Thus, if a 'Returns' or 'Yields' section is found, `NumpydocParser.parse` will indirectly lead to the invocation of `ReturnsSection._parse_item`."}, {"fname": "parse", "evidence": "The `NumpydocParser.parse` method, as seen in the file content, explicitly calls `factory.parse()` where `factory` is an instance of `Section` or one of its subclasses. This `Section.parse` method is a direct candidate for invocation."}, {"fname": "parse", "evidence": "The `_KVSection.parse` method is an implementation of the `parse` method for a specific type of section (key-value sections). Since `NumpydocParser.parse` invokes the `parse` method polymorphically on various `Section` subclasses, this specific implementation will be called for all KV-style sections like Parameters, Raises, and Returns."}, {"fname": "title_pattern", "evidence": "The `parse` method's core functionality involves identifying different sections within a docstring using a pre-compiled regular expression (`self.titles_re`). This regex is constructed by invoking `title_pattern` on various `Section` instances during the parser's initialization via `_setup`. Therefore, `title_pattern` is an integral part of defining the patterns that enable the `parse` method to correctly identify and process docstring sections."}, {"fname": "title_pattern", "evidence": "This `title_pattern` implementation, specific to `_SphinxSection`, similarly contributes to the overall set of regular expressions used by the `NumpydocParser.parse` method for section identification. It defines how Sphinx-style sections are recognized, which is essential for the parsing process."}, {"fname": "_parse_item", "evidence": "The target function `NumpydocParser.parse` iterates through sections and calls `factory.parse()`. `factory` can be an instance of `ParamSection`, `RaisesSection`, `ReturnsSection`, or `YieldsSection`, all of which inherit from `_KVSection`. The `_KVSection.parse` method explicitly invokes `self._parse_item` to process individual key-value pairs within the docstring sections. Therefore, `_parse_item` is directly invoked as part of the parsing process initiated by the target function."}]}
