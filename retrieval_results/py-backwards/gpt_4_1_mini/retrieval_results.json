{"function": "_transform", "target_function_prompt": "def _transform(path: str, code: str, target: CompilationTarget) -> Tuple[str, List[str]]:\n    \"\"\"Applies all transformation for passed target.\"\"\"\n", "f1_score": 0.03636363636363636, "recall": 0.5, "precision": 0.018867924528301886, "context_size": 53, "target_api_invocations": ["tree", "debug"], "context": [{"fname": "_get_matched_rewrite", "evidence": "The target function _transform likely needs to apply various code transformations. The method _get_matched_rewrite returns rewrite rules for module names, which is essential for determining if an import statement needs rewriting during transformation."}, {"fname": "_replace_import", "evidence": "The method _replace_import replaces an import statement with a try/except block to support backward-compatible imports. Since _transform must apply transformations including import rewrites, it would likely invoke this to build rewritten import nodes."}, {"fname": "visit_Import", "evidence": "visit_Import checks for matching rewrite rules and either replaces the import or continues traversal. This function orchestrates import rewriting during AST node visits, which fits _transform's need to apply import-related transformations."}, {"fname": "_replace_import_from_module", "evidence": "The _replace_import_from_module method replaces import-from statements with try/except blocks similarly to _replace_import, but for 'from module import ...' forms. As _transform applies all transformations including import rewrites, this method would be invoked."}, {"fname": "_get_names_to_replace", "evidence": "_get_names_to_replace identifies specific import names/aliases to be replaced based on rewrite rules. This utility supports targeted rewriting of import statements, which is a necessary subtask likely called during the transformation steps in _transform."}, {"fname": "_replace_import_from_names", "evidence": "The method transforms 'from ... import ...' statements into try/except blocks as part of import rewriting, a subtask likely done during overall code transformations by _transform."}, {"fname": "_get_replaced_import_from_part", "evidence": "This helper returns replaced import-from nodes with changed module or alias names, used in import rewriting; likely invoked during transformation applied by _transform."}, {"fname": "visit_ImportFrom", "evidence": "This visitor method processes ImportFrom nodes to rewrite them based on mappings and handles replacements; _transform likely triggers such AST visitors to perform code transformations."}, {"fname": "visit_ImportFrom", "evidence": "This VariablesReplacer visitor method modifies import-from modules consistently during AST traversal; plausible that _transform invokes such visitors to apply transformations."}, {"fname": "visit_alias", "evidence": "This visitor method modifies alias nodes for imports by replacing module and alias names; _transform likely invokes this during AST rewriting using VariablesReplacer."}, {"fname": "_py_backwards_merge_dicts", "evidence": "The _py_backwards_merge_dicts function is a utility that merges dictionaries and is linked to the transformation process. Given that _transform applies all transformations, it may invoke this helper directly or indirectly to merge configuration or data dictionaries."}, {"fname": "visit_Dict", "evidence": "The _transform function applies transformations on AST nodes, which likely involves calling visitor methods such as visit_Dict. The visit_Dict function specifically transforms dictionary AST nodes and would be a core part of these transformations."}, {"fname": "visit_Call", "evidence": "The _transform function applies all transformations for a target, which probably includes transforming function call nodes. The visit_Call method processes ast.Call nodes to handle starred arguments, making it a probable invocation to handle relevant AST node types."}, {"fname": "_has_starred", "evidence": "The _has_starred method detects if any arguments are starred in an AST expression list. Since visit_Call uses _has_starred to decide if transformation is needed, it is an indirect but essential call during such transformations."}, {"fname": "_split_by_starred", "evidence": "The _split_by_starred method splits a list of AST expressions by starred elements, helping process starred unpacking. Since visit_Call and visit_Dict rely on splitting lists of expressions or keys/values, this utility is likely invoked to handle such subtasks in breaking down AST nodes."}, {"fname": "_prepare_lists", "evidence": "The _prepare_lists function wraps starred expressions and regular list elements uniformly for further processing. This method supports transforming AST list nodes, facilitating the transformations done by visit_Dict or visit_Call, thus it is likely called to prepare intermediate results."}, {"fname": "_merge_lists", "evidence": "_merge_lists is a key helper for merging list nodes during AST transformations, likely invoked directly or indirectly by the transformation pipeline applied by _transform."}, {"fname": "_to_sum_of_lists", "evidence": "_to_sum_of_lists orchestrates splitting and merging of starred and non-starred list elements, essential for list transformations and likely invoked during the transformation process."}, {"fname": "visit_List", "evidence": "visit_List is the core visitor method that transforms list AST nodes with starred elements; since _transform applies all transformations, it is very likely invoked."}, {"fname": "visit_FormattedValue", "evidence": "visit_FormattedValue transforms formatted string AST nodes into format calls and will be invoked during AST transformations applied by _transform."}, {"fname": "visit_JoinedStr", "evidence": "visit_JoinedStr transforms f-string AST nodes into join calls; as part of formatting transformations, it will likely be invoked by _transform."}, {"fname": "transform", "evidence": "The target function _transform applies all transformations for a given target; Node_1's transform method is described as the core method applying a transformation to an AST and returning results. This fundamental AST transformation capability aligns directly with _transform's purpose and is likely invoked during its implementation."}, {"fname": "transform", "evidence": "Node_2 also provides a transform method that applies transformation to an AST and returns detailed results including the transformed tree and change tracking, facilitating AST manipulation workflows. This detailed transformation utility fits naturally as a called function during _transform's process."}, {"fname": "visit_ClassDef", "evidence": "Node_3 implements visit_ClassDef to ensure classes explicitly inherit from 'object', a typical AST modification step within a transformer pipeline. Since _transform applies all transformations, it would likely invoke or run transformers that call this logic to handle class definitions."}, {"fname": "_replace_super_args", "evidence": "Node_4 provides a utility to rewrite zero-argument super() calls by injecting necessary arguments, essential for AST transformation that _transform encompasses. This helper function is plausibly invoked during transformation passes to handle explicit super() rewriting."}, {"fname": "visit_Call", "evidence": "Node_5 visits AST Call nodes to find and transform parameterless super() calls by invoking the helper in Node_4 and marking changes. Since _transform applies all needed transformations, calling this visitor method to handle super() adjustments is likely."}, {"fname": "visit_ClassDef", "evidence": "The target function _transform applies all transformations for a given target. Node 1 implements visit_ClassDef which dynamically adjusts class base inheritance in an AST node, a transformation likely relevant to _transform's role of applying transformations to ASTs."}, {"fname": "visit_Module", "evidence": "Node 2 implements visit_Module, which adds future imports to an AST module to enable Python 2 to 3 compatibility. This is a typical code transformation step that _transform may invoke to modify AST nodes as part of its transformation pipeline."}, {"fname": "transform", "evidence": "Node 3 implements a transformation converting annotated assignments into standard assignments with type comments. Since _transform applies all transformations, it may invoke this function to handle variable annotation transformations as part of its comprehensive transformation."}, {"fname": "transform", "evidence": "Node 4 replaces all identifiers named 'str' with 'unicode' in the AST, enabling compatibility transformations. Given _transform's docstring indicating it applies all transformations, this node's function is likely called to handle such AST node modifications."}, {"fname": "_transform", "evidence": "This node exactly matches the target function's signature and implementation, meaning _transform is a self-contained node and therefore the target function trivially invokes itself or this is the description of the target function itself."}, {"fname": "_compile_file", "evidence": "_compile_file calls _transform (the target function) to perform the transformation step, so the target function could be invoked during compilation of files as part of this process."}, {"fname": "compile_files", "evidence": "compile_files orchestrates multiple file compilations by calling _compile_file, which in turn calls the target function _transform; hence the target function could be indirectly invoked during this process."}, {"fname": "visit_ClassDef", "evidence": "_transform likely uses AST traversal and transformer visitors to modify nodes such as class definitions; hence, this method could be invoked during transformation."}, {"fname": "_emulate_yield_from", "evidence": "_transform applies code transformations that may include rewriting yield-from constructs; this internal transformation method is likely invoked during that process."}, {"fname": "debug", "evidence": "The _transform function likely uses debug messages during its transformation process for development or troubleshooting, so it may invoke the debug utility."}, {"fname": "find_variables", "evidence": "Finding and removing 'let' variables from the AST is a necessary transformation step, aligning with _transform's role to apply all transformations for the target."}, {"fname": "extend_tree", "evidence": "Replacing 'extend' calls with actual variable nodes is a direct AST transformation likely performed by _transform on the given code."}, {"fname": "replace", "evidence": "The replace class method in VariablesReplacer replaces all variables in an AST with unique names based on a provided mapping. Since _transform's purpose is to apply all transformations for a given target, including possibly variable substitutions and renamings in code ASTs, this core method is a likely candidate to be called to perform variable replacement tasks. It operates at the right abstraction level – a main method within VariablesReplacer – fitting well into code transformation workflows."}, {"fname": "let", "evidence": "This function marks variables for unique renaming during code transformations, which is likely invoked during applying all transformations."}, {"fname": "generate", "evidence": "This function generates unique variable names needed for renaming variables during transformations applied by _transform."}, {"fname": "_replace_field_or_node", "evidence": "This utility replaces specified fields or nodes in the AST with variable values, a core part of transformations likely used by _transform."}, {"fname": "visit_Name", "evidence": "This visitor method processes AST Name nodes for variable replacements, which the _transform function will invoke to traverse and modify the AST."}, {"fname": "visit_Attribute", "evidence": "This visitor method processes AST Attribute nodes for variable replacements, likely invoked during comprehensive transformations applied by _transform."}, {"fname": "visit_keyword", "evidence": "The target function applies transformations involving AST traversal and likely invokes visitor methods such as visit_keyword to replace keyword argument nodes."}, {"fname": "visit_arg", "evidence": "visit_arg processes function argument nodes during AST traversal, and is likely involved in the transformations applied by the target function."}, {"fname": "insert_at", "evidence": "insert_at is a fundamental utility to insert AST nodes, and transformations applied by the target function likely require inserting new nodes."}, {"fname": "replace_at", "evidence": "replace_at replaces AST nodes and is a common operation during code transformations applied by the target function."}, {"fname": "visit_FunctionDef", "evidence": "visit_FunctionDef modifies function definitions by removing return annotations and is likely one of the transformations applied by the target function."}, {"fname": "find", "evidence": "The find function enables searching the AST for nodes of a specific type, which is highly relevant for the _transform function that needs to apply transformations involving analysis of specific AST nodes. It is natural for _transform to invoke this utility to locate relevant tree nodes to transform."}, {"fname": "get_closest_parent_of", "evidence": "The get_closest_parent_of function helps locate a nearest ancestor of a specified type in the AST. Since _transform deals with AST transformations, it may need contextual information about node ancestry to apply transformations correctly, making this utility likely to be invoked."}, {"fname": "_build_parents", "evidence": "_build_parents is an internal helper that builds parent references within an AST. The get_parent function (Node 5) relies on it, and _transform may invoke get_parent or functions that depend on parent referencing. Consequently, _transform might indirectly or directly require _build_parents to maintain accurate AST structure during transformation."}, {"fname": "get_parent", "evidence": "The get_parent function retrieves the parent node of a given AST node and optionally rebuilds the parent map. Given _transform's need for traversing and modifying AST nodes, it is very plausible that it calls get_parent to navigate node relationships during transformations."}]}
{"function": "find_variables", "target_function_prompt": "def find_variables(tree: ast.AST) -> Iterable[str]:\n    \"\"\"Finds variables and remove `let` calls.\"\"\"\n", "f1_score": 0.28571428571428575, "recall": 0.6666666666666666, "precision": 0.18181818181818182, "context_size": 11, "target_api_invocations": ["find", "tree", "get_non_exp_parent_and_index"], "context": [{"fname": "visit_ClassDef", "evidence": "This visitor method handles AST node traversal and replacement related to variables, which is relevant for the target function's task of finding variables and removing let calls."}, {"fname": "debug", "evidence": "Debug utility may be invoked to output debugging information during AST traversal or transformations performed by the target function."}, {"fname": "visit_Attribute", "evidence": "The target function must traverse attribute nodes in the AST to find variables and possibly modify them, so this visitor method is likely invoked."}, {"fname": "visit_keyword", "evidence": "To remove let calls and find variables, the target function needs to process keyword nodes in the AST, making this visitor method relevant."}, {"fname": "visit_arg", "evidence": "Processing function argument nodes is essential for variable detection and transformation, so this visitor method is likely invoked."}, {"fname": "insert_at", "evidence": "Removing let calls may require inserting new AST nodes, so the insert_at utility is likely invoked during AST modifications."}, {"fname": "replace_at", "evidence": "Replacing AST nodes is necessary to remove let calls, thus the replace_at utility function is likely used."}, {"fname": "find", "evidence": "The target function needs to find variables in the AST, so an AST node finder utility like 'find' that yields nodes of a specific type is directly relevant and likely invoked."}, {"fname": "get_closest_parent_of", "evidence": "To remove or handle 'let' calls, the target might need to find the closest ancestor node of a given type, making this utility essential for contextual analysis in AST traversal."}, {"fname": "get_parent", "evidence": "Getting the direct parent node of a given AST node is fundamental for navigating and manipulating the AST, thus likely called directly during variable finding and 'let' removal."}, {"fname": "get_non_exp_parent_and_index", "evidence": "Identifying the closest non-expression parent with a body attribute and the target node's index enables structural modifications like removing 'let' calls; this makes it highly relevant for invocation."}]}
{"function": "_get_lines_with_highlighted_error", "target_function_prompt": "def _get_lines_with_highlighted_error(e: CompilationError) -> Iterable[str]:\n    \"\"\"Format code with highlighted syntax error.\"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["_format_line"], "context": [{"fname": "_format_line", "evidence": "The target function _get_lines_with_highlighted_error yields formatted lines of code, and the implementation explicitly calls _format_line to format individual lines consistently, so this function is clearly invoked."}, {"fname": "_get_lines_with_highlighted_error", "evidence": "This node is the target function itself, which logically calls itself recursively/yields lines formatted via _format_line and produces highlighted error lines as described in the docstring and implementation."}]}
{"function": "find", "target_function_prompt": "def find(tree: ast.AST, type_: Type[T]) -> Iterable[T]:\n    \"\"\"Finds all nodes with type T.\"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 2, "target_api_invocations": ["tree"], "context": [{"fname": "_build_parents", "evidence": "'_build_parents' is a foundational helper that sets up parent relationships; 'find' may call it to ensure parent data structures are prepared for AST navigation or validation."}, {"fname": "get_parent", "evidence": "'get_parent' provides parent access and ensures parents data is up to date; 'find' might invoke it if parent-related context is necessary for node filtering or further processing."}]}
