{"function": "_transform", "target_function_prompt": "def _transform(path: str, code: str, target: CompilationTarget) -> Tuple[str, List[str]]:\n    \"\"\"Applies all transformation for passed target.\"\"\"\n", "f1_score": 0.03125, "recall": 0.5, "precision": 0.016129032258064516, "context_size": 63, "target_api_invocations": ["debug", "tree"], "context": [{"fname": "visit_JoinedStr", "evidence": "The target function's purpose is to apply 'all transformation'. This function describes and implements a specific AST transformation (rewriting f-strings), which aligns directly with the target function's goal, likely as part of an AST visitor invoked by the _transform orchestration."}, {"fname": "transform", "evidence": "The target function's purpose is to apply 'all transformation'. This function explicitly describes and implements an AST transformation (replacing 'str' with 'unicode'), making it a direct candidate for invocation by _transform to achieve a specific compilation target."}, {"fname": "visit_FormattedValue", "evidence": "The target function's purpose is to apply 'all transformation'. This function describes and implements another specific AST transformation (de-sugaring f-string components), which is consistent with the type of transformations _transform is designed to apply, likely as part of an AST visitor."}, {"fname": "visit_arg", "evidence": "The target function's purpose is to apply 'all transformation'. This function describes and implements stripping type annotations, which is a common AST transformation that _transform might apply based on the specified 'target'."}, {"fname": "extend_tree", "evidence": "The target function's purpose is to apply 'all transformation'. This function explicitly performs a transformation on an AST (replacing 'extend' calls), making it a strong candidate for being one of the transformations invoked by _transform."}, {"fname": "transform", "evidence": "The target function 'Applies all transformation for passed target'. This node describes a specific AST transformation method, making it highly probable that the target function orchestrates and invokes such individual transformation methods."}, {"fname": "input_doesnt_exists", "evidence": "The target function takes a 'path' as input. It is a common pattern for functions processing files to validate the existence of the input path. If the path doesn't exist, this function provides a standardized error message that the target function could return or log."}, {"fname": "_format_line", "evidence": "The target function returns `Tuple[str, List[str]]`. The `List[str]` could contain messages, warnings, or detailed error information. If an error occurs during transformation, or for debugging purposes, `_transform` might use this utility to format specific lines of code for display in the returned list or for internal logging."}, {"fname": "_get_lines_with_highlighted_error", "evidence": "The target function applies transformations and may encounter compilation errors. This utility formats code segments to highlight errors, which would be essential for creating detailed error messages returned by or logged from the _transform function."}, {"fname": "syntax_error", "evidence": "The target function is responsible for code transformation, a process prone to syntax errors. This function specifically formats CompilationError objects into human-readable strings, which would be crucial for the _transform function to report such errors effectively as part of its List[str] return value or for logging."}, {"fname": "debug", "evidence": "Complex functions like _transform often include debug logging to trace execution, identify issues, or provide verbose output. This 'debug' utility offers a structured and conditional way to add such messages, making it highly probable for invocation within _transform."}, {"fname": "warn", "evidence": "During code transformation, non-critical issues (warnings) may arise that don't halt execution but should be reported. The target function's return type includes a list of strings, which could contain such warnings. This 'warn' utility provides a standard way to issue these non-critical notifications."}, {"fname": "warn", "evidence": "The target function `_transform` returns a list of strings, which could contain warning messages generated during the transformation process. The `warn` function is specifically designed to format such messages for clear output."}, {"fname": "debug", "evidence": "Complex transformation processes like the one implied by `_transform` often utilize debug logging for tracing execution and identifying issues. The `debug` function provides a formatted way to generate these messages, which could be logged or even included in the returned list of strings for verbose output."}, {"fname": "visit_ClassDef", "evidence": "The target function applies 'all transformations' for a given target. This node describes an AST transformation that ensures class definitions explicitly inherit from `object`, which is a common code standardization or compatibility transformation, making it highly likely to be invoked."}, {"fname": "_replace_super_args", "evidence": "The target function applies 'all transformations'. This node performs an AST transformation on `super()` calls to make them explicit. This kind of code modification is a direct fit for the 'transformation' task of the target function."}, {"fname": "visit_Call", "evidence": "The target function applies 'all transformations'. This node identifies and transforms argument-less `super()` calls in the AST, which directly aligns with the 'transformation' purpose of the target function, likely as part of an AST visitor pattern."}, {"fname": "visit_ClassDef", "evidence": "The target function applies 'all transformations'. This node modifies an AST by renaming class definition nodes. Programmatic renaming of classes is a specific type of code transformation that could be required based on the `CompilationTarget`."}, {"fname": "visit_ClassDef", "evidence": "The target function '_transform' applies all transformations for a given target. This node describes an AST transformation (`visit_ClassDef`) that modifies class definitions. It is highly probable that '_transform' would instantiate and run AST transformers which contain such methods, effectively invoking this transformation logic as part of its overall process."}, {"fname": "visit_Module", "evidence": "The target function '_transform' is described as applying 'all transformations'. This node describes an AST transformation (`visit_Module`) that prepends `__future__` import statements, which is a common compatibility transformation. It is highly probable that '_transform' would orchestrate the execution of such AST visitors/transformers as part of its full transformation pipeline."}, {"fname": "visit_Module", "evidence": "Similar to Node 3, this node describes an AST transformation (`visit_Module`) that inserts `six` compatibility imports. Given that '_transform' applies 'all transformations' for a target, and Python 2/3 compatibility (often involving `six`) is a common transformation target, it's very likely that `_transform` would involve a transformer that calls this method."}, {"fname": "_get_rewrites", "evidence": "This generator function provides mappings for `six.moves` compatibility, which are essential data for rewriting code paths for Python 2/3 compatibility. While it doesn't perform the transformation directly, a transformer invoked by `_transform` would likely call `_get_rewrites()` to obtain the necessary data to perform actual code rewrites, making it an invoked utility for a transformation sub-task."}, {"fname": "visit_FunctionDef", "evidence": "The target function '_transform' applies transformations. This method is an AST visitor that removes return type annotations, a specific type of transformation which the target function is likely to orchestrate or apply as part of its 'all transformations' goal."}, {"fname": "transform", "evidence": "The target function '_transform' applies transformations. This 'transform' method directly performs a specific AST transformation (removing type annotations from assignments), which aligns perfectly with the target function's responsibility to apply various transformations."}, {"fname": "_get_replaced_import_from_part", "evidence": "The target function '_transform' applies transformations, which may include modifying import statements. This method is a helper that transforms an `ImportFrom` node by replacing module or alias parts, and would be invoked by an AST transformer that '_transform' itself would apply."}, {"fname": "visit_ImportFrom", "evidence": "The target function '_transform' applies transformations. This method is an AST visitor that modifies `ImportFrom` statements, which is a common code transformation that '_transform' would likely include as part of its 'all transformations'."}, {"fname": "visit_alias", "evidence": "The target function '_transform' applies transformations. This method is an AST visitor that modifies `alias` nodes within import statements, a specific transformation that '_transform' would likely apply or orchestrate as part of its 'all transformations'."}, {"fname": "visit_ImportFrom", "evidence": "The target function '_transform' applies 'all transformations' to code. This node describes a method for modifying 'from ... import ...' statements in an AST, which is a common and specific type of code transformation. If '_transform' utilizes an AST visitor or transformer pattern, this method would be invoked as part of processing 'ImportFrom' nodes."}, {"fname": "_replace_import", "evidence": "The target function '_transform' applies 'all transformations'. This node describes a method for transforming import statements into try-except blocks, a specific and complex code transformation. It is highly probable that such a specialized import rewrite mechanism would be part of the 'all transformations' applied by the target function."}, {"fname": "visit_Import", "evidence": "The target function '_transform' applies 'all transformations'. This node describes a method for intercepting and rewriting 'import' statements in an AST, which is a direct form of code transformation. Similar to `visit_ImportFrom`, if '_transform' uses an AST visitor, this method would be called when an 'Import' node is encountered."}, {"fname": "_replace_import_from_module", "evidence": "The target function '_transform' applies 'all transformations'. This node describes a specific utility for rewriting 'import from' module paths with a try/except fallback, which is a detailed AST transformation. It's a plausible sub-task within the broader 'all transformations' applied by the target function, especially given it's called by `visit_ImportFrom` (Node 1)."}, {"fname": "_replace_import_from_names", "evidence": "The target function '_transform' applies 'all transformations'. This node describes a core utility for transforming 'import from' statements by replacing specific names with a try/except block. This is another highly specific AST transformation that would logically be part of the 'all transformations' applied by the target function, being called by `visit_ImportFrom` (Node 1)."}, {"fname": "visit_Dict", "evidence": "The target function `_transform`'s docstring states it 'Applies all transformation for passed target.' `visit_Dict` specifically describes an AST transformation, converting dictionary unpacking syntax. If `_transform` processes code via its Abstract Syntax Tree (AST), it would likely invoke specific AST visitor methods or transformation functions like `visit_Dict` to modify the AST according to the compilation target."}, {"fname": "_replace_module", "evidence": "The target function `_transform` applies transformations based on a `CompilationTarget`. If these transformations involve resolving or rewriting module import paths or references within the code (e.g., adapting to different module structures for the target), then `_replace_module` could be invoked to dynamically update module path strings as part of the transformation process."}, {"fname": "find", "evidence": "The target function `_transform` is responsible for applying transformations to source code, which involves working with Abstract Syntax Trees (ASTs). The `find` function traverses an AST to locate specific node types. This utility could be invoked by `_transform` for various sub-tasks, such as identifying nodes to transform, verifying transformations, or performing static analysis before or after modifications."}, {"fname": "visit_Call", "evidence": "The target function `_transform` applies 'all transformation for passed target'. `visit_Call` is a method that performs a specific AST transformation on `ast.Call` nodes. While `_transform` itself would not directly call `visit_Call`, it would likely instantiate and invoke an `ast.NodeTransformer` (or similar mechanism) that, in turn, calls `visit_Call` as part of its AST traversal and modification process. Thus, `visit_Call` is an integral part of the transformation pipeline orchestrated by `_transform`."}, {"fname": "transformation_error", "evidence": "The target function `_transform` applies code transformations, which are prone to errors. The `transformation_error` function is specifically designed to format `TransformationError` instances into human-readable messages. Given that `_transform` returns a `Tuple[str, List[str]]` where the list likely contains messages or errors, it is highly probable that `_transform` would catch `TransformationError` and use this function to format error details for its return value or for logging."}, {"fname": "visit_keyword", "evidence": "Similar to `visit_Call`, `visit_keyword` is a method that performs a specific AST transformation on `ast.keyword` nodes. As `_transform` is responsible for applying 'all transformation', it would orchestrate a process where this `visit_keyword` method (as part of an `ast.NodeTransformer`) is invoked when `ast.keyword` nodes are encountered during AST traversal."}, {"fname": "visit_Attribute", "evidence": "Similar to `visit_Call` and `visit_keyword`, `visit_Attribute` is a method that performs a specific AST transformation on `ast.Attribute` nodes. As `_transform`'s role is to apply comprehensive transformations, it would initiate an AST traversal that could lead to the invocation of this method when `ast.Attribute` nodes require modification based on the specified `CompilationTarget`."}, {"fname": "generate", "evidence": "The `_transform` function applies transformations. Many transformations involve renaming variables to avoid conflicts. This `generate` function provides a utility for creating unique names, which could be invoked by a transformer component orchestrated by `_transform`."}, {"fname": "find_variables", "evidence": "The `_transform` function is responsible for applying 'all transformations'. This `find_variables` function performs a specific transformation: identifying and removing 'let' calls from an AST and extracting variable names. This is a direct AST manipulation task that is highly likely to be part of the overall transformation pipeline `_transform` orchestrates."}, {"fname": "_get_variables", "evidence": "The target function `_transform` applies transformations to code. Many transformations, especially those related to variable renaming, scope analysis, or code generation, require gathering and managing variable names. `_get_variables` directly provides this capability by extracting variable names from an AST, making it a highly relevant utility function that `_transform` could invoke as part of its transformation pipeline."}, {"fname": "extend", "evidence": "The target function `_transform` is responsible for applying transformations. The `extend` function explicitly states its purpose is to 'extend code' by inserting dynamic variable assignments, which is a direct form of code transformation. If the transformation logic requires injecting or modifying variable assignments within the code, `_transform` could invoke `extend` to achieve this."}, {"fname": "replace", "evidence": "The target function `_transform` is responsible for applying all transformations to an AST. `replace` is a class method specifically designed to perform a significant and common AST transformation: replacing all variables within a given tree. This aligns perfectly with the `_transform` function's role of orchestrating and applying various transformations to achieve the desired compilation target."}, {"fname": "_merge_lists", "evidence": "The target function `_transform` applies 'all transformations.' If one of the required transformations for a given `CompilationTarget` involves combining multiple list expressions or handling sequence concatenation, this utility function, which transforms AST list expressions into a summation, could be directly invoked or used by a higher-level transformation step orchestrated by `_transform`."}, {"fname": "_prepare_splitted", "evidence": "The target function `_transform` applies 'all transformations.' This function prepares structured data into AST nodes for subsequent transformations related to dictionary unpacking. As an orchestrator of transformations, `_transform` might involve an initial data preparation step, and this utility could be directly called to prepare the AST nodes required for such transformations."}, {"fname": "_merge_dicts", "evidence": "The target function `_transform` applies 'all transformations.' If a transformation involves programmatically merging dictionary expressions (e.g., related to dictionary unpacking or `**kwargs` handling), `_transform` could invoke this utility to generate the necessary AST node representing the dictionary merge operation as part of the overall transformation process."}, {"fname": "_has_starred", "evidence": "The target function '_transform' applies all transformations. If any transformation involves desugaring starred unpacking in ASTs (as suggested by the other nodes), this helper function '_has_starred' would be invoked to check for the presence of such expressions before applying specific transformations."}, {"fname": "_split_by_starred", "evidence": "The target function '_transform' applies all transformations. If a transformation involves processing AST expressions by splitting them based on 'ast.Starred' nodes, this specific utility '_split_by_starred' would be directly useful and could be invoked by a transformer or directly by '_transform' as part of the AST manipulation pipeline."}, {"fname": "_prepare_lists", "evidence": "The target function '_transform' applies all transformations. If standardizing AST representations, particularly for starred expressions and list elements, is part of the transformation process, this helper method '_prepare_lists' would be a direct candidate for invocation by a transformer or by '_transform' itself."}, {"fname": "_to_sum_of_lists", "evidence": "The target function '_transform' is described as applying 'all transformation'. This function '_to_sum_of_lists' performs a significant AST transformation by normalizing starred unpacking. It's highly probable that '_transform' (or a transformer it uses) would invoke this function to achieve part of its 'all transformation' goal."}, {"fname": "visit_List", "evidence": "The target function '_transform' applies 'all transformation for passed target'. This node explicitly states it's 'part of the StarredUnpackingTransformer' and describes a specific AST transformation logic for list nodes. It's very likely that '_transform' instantiates and utilizes various 'transformers' (as suggested by the file imports) which include methods like 'visit_List' to perform the actual AST manipulation, thus leading to its invocation."}, {"fname": "get_body", "evidence": "The target function 'Applies all transformation' to code. Transforming code often starts by parsing it into an AST. 'get_body' specifically retrieves the AST body, processes it by replacing variables, and prepares it for further manipulation, making it highly relevant as a preliminary step in a transformation pipeline."}, {"fname": "insert_at", "evidence": "The target function 'Applies all transformation'. Code transformations frequently involve adding new code elements. 'insert_at' directly supports this by allowing the programmatic insertion of AST nodes into a parent's body, which is a common operation during code transformation."}, {"fname": "replace_at", "evidence": "The target function 'Applies all transformation'. A core aspect of code transformation is replacing existing code with new structures. 'replace_at' directly facilitates this by allowing an AST node to be replaced by one or more new nodes, which is a fundamental transformation operation."}, {"fname": "_build_parents", "evidence": "The target function orchestrates transformations that operate on ASTs. Many complex AST transformations require knowledge of a node's parent for contextual analysis (e.g., determining if a variable is defined within a specific scope). '_build_parents' is essential for establishing this parent-child relationship mapping within the AST, making it a likely helper function for preparing the AST for transformation."}, {"fname": "get_parent", "evidence": "The target function 'Applies all transformation', which inherently involves navigating and manipulating an AST. Knowing the parent of a given AST node is crucial for contextual analysis and making informed transformation decisions. 'get_parent' provides this capability, and thus would likely be invoked by `_transform` itself or by the transformer functions it calls, to understand the AST structure during transformation."}, {"fname": "get_non_exp_parent_and_index", "evidence": "The target function applies transformations, which often involves modifying the Abstract Syntax Tree (AST). This function is critical for AST manipulation, allowing identification of statement container parents and their child indices for inserting or removing nodes during transformations."}, {"fname": "get_closest_parent_of", "evidence": "The target function's purpose is to apply transformations to code, which likely involves navigating an AST. This function provides a common utility to find specific types of ancestor nodes, which is frequently needed during AST traversal and modification for various transformation rules."}, {"fname": "_find_generator_returns", "evidence": "The target function `_transform` applies transformations. This node specifically identifies `return` statements with values in generator functions 'for transformation', indicating it's a preparatory step for a specific type of code transformation that `_transform` might orchestrate or perform."}, {"fname": "_replace_return", "evidence": "This function directly performs an AST modification by replacing a `return` statement with other code. As `_transform` 'applies all transformation', it's highly probable that it would invoke such a function to implement a concrete transformation rule, particularly given its tight coupling with `_find_generator_returns` (Node 3)."}, {"fname": "visit_FunctionDef", "evidence": "This function explicitly describes itself as transforming a function's AST by replacing return statements in generator contexts. Since the target function `_transform` is responsible for applying 'all transformations', it is highly likely that it would either directly call this function or, more probably, instantiate a transformer class (of which this method is a part) and apply it to the AST."}, {"fname": "visit", "evidence": "This function is described as the 'Core method of an AST transformer' and its implementation orchestrates specific transformations by calling other handling methods. The target function '_transform' 'Applies all transformation for passed target'. It is highly probable that '_transform' would iterate through a list of such transformer objects and call their 'visit' methods on the AST to apply the necessary transformations."}]}
{"function": "find_variables", "target_function_prompt": "def find_variables(tree: ast.AST) -> Iterable[str]:\n    \"\"\"Finds variables and remove `let` calls.\"\"\"\n", "f1_score": 0.2, "recall": 0.6666666666666666, "precision": 0.11764705882352941, "context_size": 17, "target_api_invocations": ["find", "tree", "get_non_exp_parent_and_index"], "context": [{"fname": "extend_tree", "evidence": "The target function needs to 'remove `let` calls', which implies finding specific call nodes and modifying the AST. This function demonstrates exactly this pattern: it uses `find` to traverse the AST, identifies a specific function call ('extend'), and uses `get_non_exp_parent_and_index` and `replace_at` to modify the tree. These utilities and the overall approach are highly relevant and likely to be invoked by `find_variables` to achieve its 'remove `let` calls' objective."}, {"fname": "transform", "evidence": "The target function's docstring indicates it needs to 'remove `let` calls', which implies an AST transformation. The `transform` method in this node specifically applies AST transformations, making it a likely candidate to be invoked for this purpose."}, {"fname": "eager", "evidence": "The target function `find_variables` is explicitly decorated with `@eager` in the provided file content. This means the `eager` function is invoked by the Python interpreter during the definition of `find_variables` to modify its behavior, making it an integral part of the `find_variables`'s overall implementation."}, {"fname": "wrapped", "evidence": "The `wrapped` function is returned by the `@eager` decorator (Node 2) and *becomes* the actual callable for `find_variables`. Therefore, when `find_variables` is invoked by any caller, it is this `wrapped` function that is executed, making it a direct invocation during the target function's runtime."}, {"fname": "transform", "evidence": "The implementation of this node demonstrates key operations relevant to the target function: it uses `find` to locate specific nodes in the AST and manipulates the AST by removing and inserting nodes (`pop`, `insert_at`). The target function 'finds variables' (likely requiring a 'find' utility) and 'removes `let` calls' (which would involve similar AST manipulation)."}, {"fname": "find", "evidence": "The `find_variables` function needs to 'find variables' within an `ast.AST`. The `find` function is specifically designed to traverse an AST and yield nodes of a specified type, which is precisely the mechanism `find_variables` would use to locate variable nodes (e.g., `ast.Name`) or `let` call nodes."}, {"fname": "visit_Call", "evidence": "The `find_variables` function's second objective is to 'remove `let` calls'. If `let` calls are represented as `ast.Call` nodes, an AST transformation is likely involved. The `visit_Call` method exemplifies an AST visitor pattern for transforming `ast.Call` nodes, making it highly plausible that `find_variables` (or an underlying AST transformer) would invoke or implement similar `visit_` methods to achieve this removal."}, {"fname": "visit_keyword", "evidence": "The target function `find_variables` needs to traverse an AST to identify variables. This node describes a method `visit_keyword` which is part of an AST traversal mechanism (`self.generic_visit`) and specifically handles `ast.keyword` nodes, including replacing variables within their 'arg' field. This aligns directly with the need to find and potentially transform variables during AST processing."}, {"fname": "visit_Attribute", "evidence": "The target function `find_variables` needs to traverse an AST to identify variables. This node describes a method `visit_Attribute` which is part of an AST traversal mechanism (`self.generic_visit`) and specifically handles `ast.Attribute` nodes, enabling renaming or substituting variable attributes. This is relevant to both finding variables in attribute contexts and to the 'remove `let` calls' task if such calls involve attribute transformations."}, {"fname": "generate", "evidence": "The target function explicitly states it 'remove `let` calls'. As demonstrated by the example in Node 5, `let(x)` results in a uniquely named variable (e.g., `_py_backwards_x_0`). This node's `generate` function provides the exact capability to create such unique, non-conflicting names for variables. Therefore, `find_variables` would very likely invoke `generate` to perform this renaming as part of 'removing' `let` calls."}, {"fname": "visit_ExceptHandler", "evidence": "The target function aims to 'remove `let` calls', implying AST modification. `VariablesReplacer` (of which `visit_ExceptHandler` is a method) is designed for modifying variable names in the AST. It is highly plausible that `find_variables` would utilize a `VariablesReplacer` instance or its static methods, which would then internally call `visit_ExceptHandler` if an `ast.ExceptHandler` node is encountered during the AST traversal for modification."}, {"fname": "insert_at", "evidence": "The target function needs to 'remove `let` calls', which implies modifying the AST. If a `let` call is replaced by its contents or new nodes, `insert_at` would be used to add these nodes to the AST, either directly or indirectly via `replace_at`."}, {"fname": "replace_at", "evidence": "The primary way to 'remove' or transform a specific AST node (like a `let` call) is by replacing it. `replace_at` is designed precisely for this purpose, allowing a node to be replaced by zero or more new nodes, effectively removing it if replaced by an empty list."}, {"fname": "_build_parents", "evidence": "To modify an AST by removing or replacing a node, the parent of that node must be known. `_build_parents` is a helper function that populates the necessary parent mapping. While `find_variables` might not call it directly, it would be invoked by `get_parent` (Node 4) which is highly likely to be called."}, {"fname": "get_parent", "evidence": "To 'remove `let` calls', the function will need to modify the AST. AST modification functions like `replace_at` require knowledge of a node's parent and its index within the parent's body. `get_parent` is essential for retrieving this crucial contextual information."}, {"fname": "get_non_exp_parent_and_index", "evidence": "When 'removing `let` calls', especially if `let` represents a specialized expression or statement, it might be necessary to locate its nearest enclosing statement container to perform a correct transformation or removal. `get_non_exp_parent_and_index` is specifically designed to find this crucial parent and index for programmatic AST modification at the statement level."}, {"fname": "get_closest_parent_of", "evidence": "The target function needs to traverse and manipulate an Abstract Syntax Tree (AST) to find variables and remove 'let' calls. Understanding the hierarchical context of AST nodes is critical for this task. `get_closest_parent_of` directly supports navigating the AST to identify the type of parent a node belongs to, which could be necessary to correctly identify variables within a specific scope or to perform a safe removal of 'let' calls by interacting with their parent nodes."}]}
{"function": "_get_lines_with_highlighted_error", "target_function_prompt": "def _get_lines_with_highlighted_error(e: CompilationError) -> Iterable[str]:\n    \"\"\"Format code with highlighted syntax error.\"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 1, "target_api_invocations": ["_format_line"], "context": [{"fname": "_format_line", "evidence": "The target function's purpose is to 'Format code with highlighted syntax error'. This involves processing individual lines of code. The `_format_line` function is specifically designed to format a single line of code with line numbers and styling, which is a direct sub-task required by the target function. The implementation of Node 5 (which is the target function) explicitly calls this function."}]}
{"function": "find", "target_function_prompt": "def find(tree: ast.AST, type_: Type[T]) -> Iterable[T]:\n    \"\"\"Finds all nodes with type T.\"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["tree"], "context": []}
