{"function": "_decode_dict_keys", "target_function_prompt": "def _decode_dict_keys(key_type, xs, infer_missing):\n    \"\"\"\n    Because JSON object keys must be strs, we need the extra step of decoding\n    them back into the user's chosen python type\n    \"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 1, "target_api_invocations": ["_decode_items"], "context": [{"fname": "_decode_items", "evidence": "No evidence provided"}]}
{"function": "_decode_items", "target_function_prompt": "def _decode_items(type_arg, xs, infer_missing):\n    \"\"\"\n    This is a tricky situation where we need to check both the annotated\n    type info (which is usually a type from `typing`) and check the\n    value's type directly using `type()`.\n\n    If the type_arg is a generic we can use the annotated type, but if the\n    type_arg is a typevar we need to extract the reified type information\n    hence the check of `is_dataclass(vs)`\n    \"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 3, "target_api_invocations": ["_decode_generic", "_is_supported_generic", "_decode_dataclass"], "context": [{"fname": "_decode_generic", "evidence": "No evidence provided"}, {"fname": "_is_supported_generic", "evidence": "No evidence provided"}, {"fname": "_decode_dataclass", "evidence": "No evidence provided"}]}
{"function": "_asdict", "target_function_prompt": "def _asdict(obj, encode_json=False):\n    \"\"\"\n    A re-implementation of `asdict` (based on the original in the `dataclasses`\n    source) to support arbitrary Collection and Mapping types.\n    \"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 3, "target_api_invocations": ["_handle_undefined_parameters_safe", "_encode_overrides", "_user_overrides_or_exts"], "context": [{"fname": "_handle_undefined_parameters_safe", "evidence": "No evidence provided"}, {"fname": "_encode_overrides", "evidence": "No evidence provided"}, {"fname": "_user_overrides_or_exts", "evidence": "No evidence provided"}]}
{"function": "dataclass_json", "target_function_prompt": "def dataclass_json(_cls=None, *, letter_case=None,\n                   undefined: Optional[Union[str, Undefined]] = None):\n    \"\"\"\n    Based on the code in the `dataclasses` module to handle optional-parens\n    decorators. See example below:\n\n    @dataclass_json\n    @dataclass_json(letter_case=LetterCase.CAMEL)\n    class Example:\n    ...\n    \"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 1, "target_api_invocations": ["_process_class"], "context": [{"fname": "_process_class", "evidence": "No evidence provided"}]}
