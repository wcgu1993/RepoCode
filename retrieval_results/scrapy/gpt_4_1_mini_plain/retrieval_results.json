{"function": "flatten", "target_function_prompt": "def flatten(x):\n    \"\"\"flatten(sequence) -> list\n\n    Returns a single, flat list which contains all elements retrieved\n    from the sequence and all recursively contained sub-sequences\n    (iterables).\n\n    Examples:\n    >>> [1, 2, [3,4], (5,6)]\n    [1, 2, [3, 4], (5, 6)]\n    >>> flatten([[[1,2,3], (42,None)], [4,5], [6], 7, (8,9,10)])\n    [1, 2, 3, 42, None, 4, 5, 6, 7, 8, 9, 10]\n    >>> flatten([\"foo\", \"bar\"])\n    ['foo', 'bar']\n    >>> flatten([\"foo\", [\"baz\", 42], \"bar\"])\n    ['foo', 'baz', 42, 'bar']\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["iflatten"], "context": []}
{"function": "to_native_str", "target_function_prompt": "def to_native_str(text, encoding=None, errors='strict'):\n    \"\"\" Return str representation of ``text``. \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["to_unicode"], "context": []}
{"function": "get_spec", "target_function_prompt": "def get_spec(func):\n    \"\"\"Returns (args, kwargs) tuple for a function\n    >>> import re\n    >>> get_spec(re.match)\n    (['pattern', 'string'], {'flags': 0})\n\n    >>> class Test:\n    ...     def __call__(self, val):\n    ...         pass\n    ...     def method(self, val, flags=0):\n    ...         pass\n\n    >>> get_spec(Test)\n    (['self', 'val'], {})\n\n    >>> get_spec(Test.method)\n    (['self', 'val'], {'flags': 0})\n\n    >>> get_spec(Test().method)\n    (['self', 'val'], {'flags': 0})\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["_getargspec_py23"], "context": []}
{"function": "request_fingerprint", "target_function_prompt": "def request_fingerprint(\n    request: Request,\n    include_headers: Optional[Iterable[Union[bytes, str]]] = None,\n    keep_fragments: bool = False,\n):\n    \"\"\"\n    Return the request fingerprint.\n\n    The request fingerprint is a hash that uniquely identifies the resource the\n    request points to. For example, take the following two urls:\n\n    http://www.example.com/query?id=111&cat=222\n    http://www.example.com/query?cat=222&id=111\n\n    Even though those are two different URLs both point to the same resource\n    and are equivalent (i.e. they should return the same response).\n\n    Another example are cookies used to store session ids. Suppose the\n    following page is only accessible to authenticated users:\n\n    http://www.example.com/members/offers.html\n\n    Lot of sites use a cookie to store the session id, which adds a random\n    component to the HTTP Request and thus should be ignored when calculating\n    the fingerprint.\n\n    For this reason, request headers are ignored by default when calculating\n    the fingeprint. If you want to include specific headers use the\n    include_headers argument, which is a list of Request headers to include.\n\n    Also, servers usually ignore fragments in urls when handling requests,\n    so they are also ignored by default when calculating the fingerprint.\n    If you want to include them, set the keep_fragments argument to True\n    (for instance when handling requests with a headless browser).\n\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["to_bytes"], "context": []}
{"function": "request_httprepr", "target_function_prompt": "def request_httprepr(request: Request) -> bytes:\n    \"\"\"Return the raw HTTP representation (as bytes) of the given request.\n    This is provided only for reference since it's not the actual stream of\n    bytes that will be send when performing the request (that's controlled\n    by Twisted).\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["urlparse_cached", "to_bytes"], "context": []}
{"function": "referer_str", "target_function_prompt": "def referer_str(request: Request) -> Optional[str]:\n    \"\"\" Return Referer HTTP header suitable for logging. \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["to_unicode"], "context": []}
{"function": "gunzip", "target_function_prompt": "def gunzip(data):\n    \"\"\"Gunzip the given data and return as much data as possible.\n\n    This is resilient to CRC checksum errors.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["f"], "context": []}
{"function": "csviter", "target_function_prompt": "def csviter(obj, delimiter=None, headers=None, encoding=None, quotechar=None):\n    \"\"\" Returns an iterator of dictionaries from the given csv object\n\n    obj can be:\n    - a Response object\n    - a unicode string\n    - a string encoded as utf-8\n\n    delimiter is the character used to separate fields on the given obj.\n\n    headers is an iterable that when provided offers the keys\n    for the returned dictionaries, if not the first row is used.\n\n    quotechar is the character used to enclosure fields on the given obj.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["_body_or_str", "to_unicode"], "context": []}
{"function": "create_deprecated_class", "target_function_prompt": "def create_deprecated_class(\n    name,\n    new_class,\n    clsdict=None,\n    warn_category=ScrapyDeprecationWarning,\n    warn_once=True,\n    old_class_path=None,\n    new_class_path=None,\n    subclass_warn_message=\"{cls} inherits from deprecated class {old}, please inherit from {new}.\",\n    instance_warn_message=\"{cls} is deprecated, instantiate {new} instead.\"\n):\n    \"\"\"\n    Return a \"deprecated\" class that causes its subclasses to issue a warning.\n    Subclasses of ``new_class`` are considered subclasses of this class.\n    It also warns when the deprecated class is instantiated, but do not when\n    its subclasses are instantiated.\n\n    It can be used to rename a base class in a library. For example, if we\n    have\n\n    class OldName(SomeClass):\n    # ...\n\n    and we want to rename it to NewName, we can do the following::\n\n    class NewName(SomeClass):\n    # ...\n\n    OldName = create_deprecated_class('OldName', NewName)\n\n    Then, if user class inherits from OldName, warning is issued. Also, if\n    some code uses ``issubclass(sub, OldName)`` or ``isinstance(sub(), OldName)``\n    checks they'll still return True if sub is a subclass of NewName instead of\n    OldName.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["_clspath"], "context": []}
{"function": "_load_policy_class", "target_function_prompt": "def _load_policy_class(policy, warning_only=False):\n    \"\"\"\n    Expect a string for the path to the policy class,\n    otherwise try to interpret the string as a standard value\n    from https://www.w3.org/TR/referrer-policy/#referrer-policies\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["load_object"], "context": []}
{"function": "response_status_message", "target_function_prompt": "def response_status_message(status: Union[bytes, float, int, str]) -> str:\n    \"\"\"Return status code plus status text descriptive message\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["to_unicode"], "context": []}
{"function": "response_httprepr", "target_function_prompt": "def response_httprepr(response: Response) -> bytes:\n    \"\"\"Return raw HTTP representation (as bytes) of the given response. This\n    is provided only for reference, since it's not the exact stream of bytes\n    that was received (that's not exposed by Twisted).\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["to_bytes"], "context": []}
{"function": "build_component_list", "target_function_prompt": "def build_component_list(compdict, custom=None, convert=update_classpath):\n    \"\"\"Compose a component list from a { class: order } dictionary.\"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["without_none_values", "BaseSettings.getpriority", "BaseSettings.set"], "context": []}
{"function": "mustbe_deferred", "target_function_prompt": "def mustbe_deferred(f, *args, **kw):\n    \"\"\"Same as twisted.internet.defer.maybeDeferred, but delay calling\n    callback/errback to next reactor loop\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["defer_fail", "defer_result", "f"], "context": []}
{"function": "deferred_from_coro", "target_function_prompt": "def deferred_from_coro(o):\n    \"\"\"Converts a coroutine into a Deferred, or returns the object as is if it isn't a coroutine\"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["is_asyncio_reactor_installed"], "context": []}
{"function": "deferred_f_from_coro_f", "target_function_prompt": "def deferred_f_from_coro_f(coro_f):\n    \"\"\" Converts a coroutine function into a function that returns a Deferred.\n\n    The coroutine function will be called at the time when the wrapper is called. Wrapper args will be passed to it.\n    This is useful for callback chains, as callback functions are called with the previous callback result.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["deferred_from_coro"], "context": []}
{"function": "maybeDeferred_coro", "target_function_prompt": "def maybeDeferred_coro(f, *args, **kw):\n    \"\"\" Copy of defer.maybeDeferred that also converts coroutines to Deferreds. \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["deferred_from_coro", "f"], "context": []}
{"function": "get_crawler", "target_function_prompt": "def get_crawler(spidercls=None, settings_dict=None):\n    \"\"\"Return an unconfigured Crawler object. If settings_dict is given, it\n    will be used to populate the crawler settings with a project level\n    priority.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["CrawlerRunner.create_crawler"], "context": []}
{"function": "get_testenv", "target_function_prompt": "def get_testenv():\n    \"\"\"Return a OS environment dict suitable to fork processes that need to import\n    this installation of Scrapy, instead of a system installed one.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["get_pythonpath"], "context": []}
{"function": "url_is_from_any_domain", "target_function_prompt": "def url_is_from_any_domain(url, domains):\n    \"\"\"Return True if the url belongs to any of the given domains\"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["parse_url"], "context": []}
{"function": "parse_url", "target_function_prompt": "def parse_url(url, encoding=None):\n    \"\"\"Return urlparsed url from the given argument (which could be an already\n    parsed url)\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["to_unicode"], "context": []}
{"function": "guess_scheme", "target_function_prompt": "def guess_scheme(url):\n    \"\"\"Add an URL scheme if missing: file:// for filepath-like input or\n    http:// otherwise.\"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["_is_filesystem_path", "add_http_if_no_scheme"], "context": []}
{"function": "extract_regex", "target_function_prompt": "def extract_regex(regex, text, encoding='utf-8'):\n    \"\"\"Extract a list of unicode strings from the given text/encoding using the following policies:\n\n    * if the regex contains a named group called \"extract\" that will be returned\n    * if the regex contains multiple numbered groups, all those will be returned (flattened)\n    * if the regex doesn't contain any group the entire regex matching is returned\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["flatten", "regex", "to_unicode"], "context": []}
{"function": "_parse", "target_function_prompt": "def _parse(url):\n    \"\"\" Return tuple of (scheme, netloc, host, port, path),\n    all in bytes except for port which is int.\n    Assume url is from Request.url, which was passed via safe_url_string\n    and is ascii-only.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["_parsed_url_args"], "context": []}
{"function": "request_to_dict", "target_function_prompt": "def request_to_dict(request, spider=None):\n    \"\"\"Convert Request object to a dict.\n\n    If a spider is given, it will try to find out the name of the spider method\n    used in the callback and store that as the callback.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["_find_method", "to_unicode"], "context": []}
{"function": "curl_to_request_kwargs", "target_function_prompt": "def curl_to_request_kwargs(curl_command, ignore_unknown_options=True):\n    \"\"\"Convert a cURL command syntax to Request kwargs.\n\n    :param str curl_command: string containing the curl command\n    :param bool ignore_unknown_options: If true, only a warning is emitted when\n    cURL options are unknown. Otherwise\n    raises an error. (default: True)\n    :return: dictionary of Request kwargs\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["_parse_headers_and_cookies"], "context": []}
