{"function": "bump_version", "target_function_prompt": "def bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n", "f1_score": 0.8571428571428571, "recall": 1.0, "precision": 0.75, "context_size": 4, "target_api_invocations": ["_build_version_info", "_build_version_bump_type", "_build_version_bump_position"], "context": [{"fname": "_build_version_bump_position", "evidence": "The target function `bump_version` takes a 'position' argument that needs validation and normalization. This function directly performs that task, including handling negative positions and raising a `ValueError` for out-of-range inputs, aligning with the target function's documented error handling."}, {"fname": "_build_version_bump_type", "evidence": "The `bump_version` function needs to determine the specific type of version increment (e.g., major, minor, alpha, beta) based on the provided 'position' and 'pre_release' arguments. This function encapsulates the complex logic and validation for this decision, including raising `ValueError` for invalid 'pre_release' values or attempts to pre-release a major version, which are explicitly mentioned in the target function's docstring."}, {"fname": "_each_version_part", "evidence": "To modify a version string, `bump_version` must first break down the input version into its constituent parts (major, minor, patch, pre-release). This `_each_version_part` function provides the necessary 'granular access' by generating structured representations of each component, which is a fundamental step for performing the version bump."}, {"fname": "_build_version_info", "evidence": "The `bump_version` function receives a version as a string and needs to parse it into a structured object for manipulation. This `_build_version_info` function is explicitly designed for this purpose, converting a version string into a `_VersionInfo` object, and implicitly handles initial version string validation (e.g., via `StrictVersion`), which aligns with the target function's `ValueError` for invalid version numbers."}]}
{"function": "to_namedtuple", "target_function_prompt": "def to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 7, "target_api_invocations": ["_to_namedtuple"], "context": [{"fname": "has_any_attrs", "evidence": "The target function `to_namedtuple` handles various input types (Mapping, SimpleNamespace, NamedTuple, etc.). `has_any_attrs` could be invoked to dynamically check for the presence of specific attributes or methods (e.g., 'keys', 'items' for mapping-like behavior, or generic attributes for SimpleNamespace) to determine how to process the input object, rather than relying solely on `isinstance`."}, {"fname": "is_list_like", "evidence": "The target function explicitly handles 'list' and 'tuple' differently by recursively converting their items. 'is_list_like' is a utility designed to identify such sequence-like objects, making it a suitable candidate for performing or assisting with this type-check branch."}, {"fname": "is_subclass_of_any", "evidence": "The target function's logic heavily relies on identifying the type of the input 'obj' (e.g., List, Mapping, NamedTuple, SimpleNamespace, Tuple, OrderedDict) to apply the correct conversion strategy. 'is_subclass_of_any' is a direct utility for performing such flexible type/class checks, making it highly relevant for the conditional logic within 'to_namedtuple'."}, {"fname": "validate_identifier", "evidence": "The target function's docstring specifies that keys from mappings must be 'proper identifiers' and 'Any identifier... that starts with an underscore cannot be used as a NamedTuple attribute.' This function directly validates identifiers, including a specific check for leading underscores when `allow_underscore` is False, which perfectly matches the requirements for namedtuple attributes."}, {"fname": "_validate_attr_identifier", "evidence": "The target function's docstring states that 'keys that can be proper identifiers will become attributes on the returned NamedTuple'. This function specifically validates if a string is a 'valid and safe Python attribute identifier' by checking against keywords, built-in names, and special dunder names. This is crucial for ensuring valid and safe namedtuple attribute names derived from input object keys."}, {"fname": "_", "evidence": "This function converts mappings to namedtuples, handles key filtering/validation (e.g., `validate_identifier`), sorts keys, and performs recursive conversion via `_to_namedtuple`. These behaviors directly align with the `to_namedtuple` function's stated requirements for handling `Mapping` inputs, including recursive conversion and identifier constraints."}, {"fname": "_", "evidence": "This function processes sequences (lists, tuples, namedtuples) for conversion, rebuilds namedtuple objects, and performs recursive conversion via `_to_namedtuple` while preserving container types. These actions are explicitly described in the `to_namedtuple` function's docstring for handling `list`, `tuple`, and `NamedTuple` inputs."}]}
{"function": "_expand_attr_map_item", "target_function_prompt": "def _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n", "f1_score": 0.5, "recall": 1.0, "precision": 0.3333333333333333, "context_size": 3, "target_api_invocations": ["_validate_attr_identifier"], "context": [{"fname": "convert_escaped_utf8_literal", "evidence": "The target function takes a 'foreign_name' string, whose format is externally defined. Node 5's implementation specifically handles 'raw string inputs from sources like environment variables' that may contain escaped UTF-8 hexadecimal sequences. It is plausible that the 'foreign_name' string could originate from such raw input, requiring this conversion to interpret names correctly before parsing and validation, especially if the attribute or module names themselves contain special characters that are escaped in the input string."}, {"fname": "validate_identifier", "evidence": "The target function parses a 'foreign_name' string into attribute identifiers (`attr_name`, `mod_attr_name`). It is crucial to validate these extracted identifiers for Python naming compliance (keywords, built-ins, valid format). `validate_identifier` is precisely designed for this purpose, making its invocation highly probable to ensure data integrity and prevent runtime errors."}, {"fname": "_validate_attr_identifier", "evidence": "The target function `_expand_attr_map_item` extracts `attr_name` and `mod_attr_name` from the `foreign_name` string, both of which are stated to be 'attribute identifiers'. `_validate_attr_identifier` is specifically designed to ensure that these extracted strings are valid and safe Python attribute names, checking against keywords, built-ins, and dunders. Its presence in the file content alongside the target function makes its invocation very likely for internal validation."}]}
{"function": "_expand_attr_map", "target_function_prompt": "def _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["_expand_attr_map_item"], "context": [{"fname": "convert_escaped_utf8_literal", "evidence": "The target function processes 'specially formatted strings'. If these strings originate from sources like environment variables (as hinted by this function's docstring) and can contain escaped UTF-8 literal characters, this function could be invoked to normalize or clean the input strings before further parsing and validation, ensuring correct handling of Unicode characters in identifiers or module names."}, {"fname": "validate_identifier", "evidence": "The target function _expand_attr_map expands 'foreign-name' strings, which involves validating identifier components. The file content shows that its likely helper, _expand_attr_map_item, calls _validate_attr_identifier, which performs identifier validation. The provided 'validate_identifier' function serves this exact purpose and could be invoked by _validate_attr_identifier or a similar internal validation step."}, {"fname": "_validate_attr_identifier", "evidence": "The target function `_expand_attr_map` is described as a generator that expands 'foreign-name' strings into `_AttrMapping` named tuples. The `_AttrMapping` tuple contains fields like `attr_name` and `mod_attr_name`, which are attribute identifiers. Node 1, `_validate_attr_identifier`, is specifically designed to validate such identifiers. It is highly probable that during the expansion process, the target function will need to validate the extracted attribute names using this utility function, either directly or by calling another function that uses it (e.g., `_expand_attr_map_item` shown in the file content, which indeed uses `_validate_attr_identifier`)."}, {"fname": "_expand_attr_map_item", "evidence": "The target function `_expand_attr_map` takes a tuple of 'foreign-name' strings and yields `_AttrMapping` named tuples. This function, `_expand_attr_map_item`, is explicitly designed to parse a single 'foreign-name' string and return an `_AttrMapping` instance. It perfectly matches the core transformation required for each item in the input tuple, making it highly probable that the target function will iterate over its input and call this function for each string."}]}
{"function": "convert_escaped_utf8_literal", "target_function_prompt": "def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 3, "target_api_invocations": ["register_codecs"], "context": [{"fname": "decode", "evidence": "This 'decode' function directly addresses the target function's core task. Its description states it 'Converts bytes representing escaped UTF-8 hexadecimal sequences into a standard string'. If the target function's string input is first encoded (e.g., `text.encode()`), the resulting bytes `b'test\\\\xc2\\\\xa9'` can be passed to this 'decode' function, which then correctly performs the `decode('unicode_escape').encode('latin1').decode('utf-8')` sequence to yield the desired string 'test©'. This function offers a complete solution for the target function's purpose."}, {"fname": "register", "evidence": "The target function `convert_escaped_utf8_literal` is designed to convert strings containing escaped UTF-8 hexadecimal. This strongly implies the use of a custom codec (e.g., 'raw_utf8_escape' as hinted by the example in the target function's docstring). For such a custom codec to be usable with Python's `codecs` module, it must be registered. It's a common pattern for functions or their containing modules to ensure the necessary codecs are registered by invoking a registration function like `register()` upon initialization or first use, to ensure the conversion can proceed."}, {"fname": "register_codecs", "evidence": "Similar to Node 3, the `register_codecs` function explicitly calls `raw_utf8_escape.register()`, which is the specific registration required for the codec likely used by `convert_escaped_utf8_literal`. Therefore, it is highly plausible that the target function or its surrounding module would invoke `register_codecs` to ensure the required custom codec for UTF-8 escape conversion is available in the Python `codecs` registry."}]}
{"function": "get_os_group", "target_function_prompt": "def get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["get_os_user"], "context": [{"fname": "is_subclass_of_any", "evidence": "The 'get_os_group' function needs to determine if its 'name' argument is a string or an integer to call the appropriate underlying OS function (e.g., grp.getgrnam or grp.getgrgid). 'is_subclass_of_any' is a generic type validation utility that can be used to perform such checks on an object's class, making its invocation plausible for input validation within 'get_os_group'."}, {"fname": "get_os_user", "evidence": "The target function `get_os_group` defaults to returning the current user's group if no name is provided. The `get_os_user` function is designed to retrieve current user information (including their primary group ID), making it highly likely to be invoked by `get_os_group` to determine the default group when its `name` parameter is None."}]}
{"function": "encode", "target_function_prompt": "def encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["_each_utf8_hex"], "context": [{"fname": "convert_escaped_utf8_literal", "evidence": "The target function's input 'text' may contain existing escaped UTF-8 hexadecimal sequences. The 'convert_escaped_utf8_literal' function is designed to interpret and convert these exact literal escape sequences into proper Unicode characters. This could be an essential preprocessing or normalization step within the `encode` function to ensure consistent handling of the input string before converting it to the desired escaped byte output."}, {"fname": "convert_escaped_unicode_literal", "evidence": "The target function's docstring states its input 'may contain escaped utf8 hexadecimal'. This implies that sequences like '\\\\xNN' or '\\\\uNNNN' in the input string need to be interpreted as their actual characters before the final encoding. `convert_escaped_unicode_literal` explicitly decodes such Python-style Unicode escapes within a string, making it a plausible first step to normalize the input for the target function."}, {"fname": "_each_utf8_hex", "evidence": "The target function's goal is to convert a string to 'bytes of escaped utf8 hexadecimal'. This function, `_each_utf8_hex`, generates an escaped representation where non-ASCII or non-printable ASCII characters are converted to their UTF-8 byte equivalents, formatted as '\\xNN' hexadecimal escapes. This output format is precisely what the target function needs to then encode into bytes."}, {"fname": "as_escaped_utf8_literal", "evidence": "The target function `encode` needs to convert an input string into a byte representation of escaped UTF-8 hexadecimal. The `as_escaped_utf8_literal` function directly provides the utility to convert a standard string into its escaped UTF-8 hexadecimal *string* representation (e.g., 'A' becomes '\\x41'), which can then be encoded into the required bytes format by `encode`."}]}
{"function": "has_any_callables", "target_function_prompt": "def has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["has_any_attrs"], "context": []}
{"function": "is_list_like", "target_function_prompt": "def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["is_subclass_of_any"], "context": [{"fname": "has_attrs", "evidence": "The target function's docstring specifies that a list-like object 'acts like a list and is iterable'. While it lists specific types, the 'is iterable' aspect can be robustly checked by verifying the presence of the `__iter__` attribute. The `has_attrs` function can be used to perform this check (e.g., `has_attrs(obj, '__iter__')`), making it a plausible invocation for comprehensive iterability validation."}, {"fname": "is_subclass_of_any", "evidence": "The target function `is_list_like` needs to determine if an object's type is one of several predefined 'list-like' types. The `is_subclass_of_any` function directly provides this capability by checking if an object's class is a subclass of any given classes, which perfectly aligns with the target function's requirement to validate against a list of acceptable types (e.g., list, set, tuple, deque, Iterator, etc.)."}]}
