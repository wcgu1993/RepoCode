{"function": "bump_version", "target_function_prompt": "def bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n    version (str): The version number to be bumped.\n    position (int, optional): The position (starting with zero) of the\n    version number component to be increased.  Defaults to: ``2``\n    pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n    create or increase an alpha version number.  A value of ``b`` or\n    ``beta`` will create or increase a beta version number.\n\n    Raises:\n    ValueError: if the given ``version`` is an invalid version number.\n    ValueError: if the given ``position`` does not exist.\n    ValueError: if the given ``prerelease`` is not in:\n    ``a, alpha, b, beta``\n    ValueError: if trying to 'major' part, of a version number, to\n    a pre-release version.\n\n    :rtype:\n    :obj:`str`\n\n    * The increased version number.\n\n    Examples:\n    >>> from flutils.packages import bump_version\n    >>> bump_version('1.2.2')\n    '1.2.3'\n    >>> bump_version('1.2.3', position=1)\n    '1.3'\n    >>> bump_version('1.3.4', position=0)\n    '2.0'\n    >>> bump_version('1.2.3', prerelease='a')\n    '1.2.4a0'\n    >>> bump_version('1.2.4a0', pre_release='a')\n    '1.2.4a1'\n    >>> bump_version('1.2.4a1', pre_release='b')\n    '1.2.4b0'\n    >>> bump_version('1.2.4a1')\n    '1.2.4'\n    >>> bump_version('1.2.4b0')\n    '1.2.4'\n    >>> bump_version('2.1.3', position=1, pre_release='a')\n    '2.2a0'\n    >>> bump_version('1.2b0', position=2)\n    '1.2.1'\n\n    \"\"\"\n", "f1_score": 0.8571428571428571, "recall": 1.0, "precision": 0.75, "context_size": 4, "target_api_invocations": ["_build_version_info", "_build_version_bump_type", "_build_version_bump_position"], "context": [{"fname": "_each_version_part", "evidence": "The target function needs to analyze detailed version parts including prerelease data; this utility processes the StrictVersion to yield those parts, making it essential or likely invoked."}, {"fname": "_build_version_info", "evidence": "This function builds a structured version info object from a version string by utilizing _each_version_part; it is a natural helper called by bump_version to obtain comprehensive version data for manipulation."}, {"fname": "_build_version_bump_position", "evidence": "The target function must validate and convert the provided bump position to an absolute index within expected bounds; this function precisely performs that validation and normalization."}, {"fname": "_build_version_bump_type", "evidence": "Determining the bump type, especially with pre-release considerations and rules, is required by the target function; this node encapsulates that logic distinctly, making it a plausible invoked function."}]}
{"function": "to_namedtuple", "target_function_prompt": "def to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n    obj: The object to be converted (or have it's contents converted) to\n    a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n    :obj:`list`\n\n    A list with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`tuple`\n\n    A tuple with any of it's values converted to a\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n    >>> from flutils.namedtupleutils import to_namedtuple\n    >>> dic = {'a': 1, 'b': 2}\n    >>> to_namedtuple(dic)\n    NamedTuple(a=1, b=2)\n    \"\"\"\n", "f1_score": 0.33333333333333337, "recall": 1.0, "precision": 0.2, "context_size": 7, "target_api_invocations": ["_to_namedtuple"], "context": [{"fname": "None", "evidence": "This summary node is unspecified but is positioned third, presumably summarizing functions related to recursive conversion or related utilities. Given the highly recursive, complex nature of to_namedtuple, a summary node here likely includes conversion helpers or utility functions related to the main conversion process, increasing invocation potential."}, {"fname": "_to_namedtuple", "evidence": "The _to_namedtuple function acts as a validator and gatekeeper that raises a TypeError if the input object is not a list, tuple, or dict; the target function's docstring states it operates recursively on those types. This internal validator aligns well with the target's implementation logic, so invocation is highly probable."}, {"fname": "_", "evidence": "This internal utility function converts valid mapping keys and their values into nested NamedTuples, preserving order in OrderedDicts and filtering keys properly. This closely matches the core operation described in the target function's docstring about converting mappings recursively into NamedTuples and is thus very likely to be called within the main implementation."}, {"fname": "validate_identifier", "evidence": "validate_identifier is a utility that ensures identifiers are valid Python identifiers and can optionally disallow leading underscores. The to_namedtuple function docstring explicitly states that keys starting with underscores cannot become namedtuple attributes, indicating identifier validation is necessary. Thus, validate_identifier is likely invoked to enforce these rules."}, {"fname": "_validate_attr_identifier", "evidence": "_validate_attr_identifier similarly validates attribute identifiers and checks for keywords, builtins, and dunder names. The to_namedtuple docstring refers to filtering out keys starting with underscores and ensuring only valid keys become attributes, so this function very likely supports internal validation within to_namedtuple."}, {"fname": "is_list_like", "evidence": "The target function to_namedtuple deals with converting list- or tuple-like objects recursively. Determining whether an object is list-like is essential to decide if the function should iterate over it and convert each element. The is_list_like function directly enables this check by identifying if an object behaves like a list or sequence for recursive conversion."}, {"fname": "is_subclass_of_any", "evidence": "The is_subclass_of_any function is used in the implementation of is_list_like to determine if an object's class inherits from any given classes. Since the to_namedtuple function will likely need to distinguish the type of the input object (list, tuple, Mapping, etc.) via subclass checks, this utility could be invoked directly or indirectly to validate the object's type before conversion steps."}]}
{"function": "_expand_attr_map_item", "target_function_prompt": "def _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n    set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n    cherry-picked module that will be bound to the ``attr_name``.\n    An empty str value indicates that the entire module will be used.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["_validate_attr_identifier"], "context": [{"fname": "_expand_attr_map", "evidence": "The function `_expand_attr_map` directly uses `_expand_attr_map_item` with a map() call to parse each foreign-name string into an `_AttrMapping` named tuple."}, {"fname": "_parse_attr_map", "evidence": "`_parse_attr_map` calls `_expand_attr_map` which internally maps `_expand_attr_map_item`, so it indirectly invokes the target function as part of its parsing process."}, {"fname": "validate_identifier", "evidence": "validate_identifier checks if a string is a valid Python identifier and raises errors if not. The target function _expand_attr_map_item, which parses foreign module attribute names to be used as identifiers, would likely invoke such a validation function to ensure names are suitable for attribute assignment."}, {"fname": "_validate_attr_identifier", "evidence": "_validate_attr_identifier is directly responsible for validating that attribute identifiers conform to rules (not keywords, not builtins, not dunders). Given the similar validation purpose and that _expand_attr_map_item deals with attribute names, it is likely to invoke this function to validate identifiers before returning the named tuple."}]}
{"function": "_expand_attr_map", "target_function_prompt": "def _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n", "f1_score": 0.6666666666666666, "recall": 1.0, "precision": 0.5, "context_size": 2, "target_api_invocations": ["_expand_attr_map_item"], "context": [{"fname": "_expand_attr_map_item", "evidence": "_expand_attr_map_item parses and validates individual foreign-names into _AttrMapping tuples, which _expand_attr_map yields; thus it must be invoked."}, {"fname": "_validate_attr_identifier", "evidence": "_validate_attr_identifier is explicitly invoked by _expand_attr_map_item to validate each identifier component before expansion, so it is indirectly called by the target function."}]}
{"function": "convert_escaped_utf8_literal", "target_function_prompt": "def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n    text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n    UnicodeDecodeError: if any of the escaped hexadecimal characters\n    are not proper UTF8 bytes.\n\n    :rtype:\n    :obj:`str`\n\n    A string with each escaped UTF8 hexadecimal character converted\n    into the proper character.\n\n    Examples:\n\n    Basic usage:\n\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n\n    This function is intended for cases when the value of an environment\n    variable contains escaped UTF-8 literal characters (bytes) that need\n    to be converted to proper characters::\n\n    $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n    $ python\n\n    ::\n\n    >>> import os\n    >>> from flutils.strutils import convert_raw_utf8_escape\n    >>> a = os.getenv('TEST')\n    >>> a\n    'test\\\\\\\\xc2\\\\\\\\xa9'\n    >>> convert_escaped_utf8_literal(a)\n    'test©'\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 1, "target_api_invocations": ["register_codecs"], "context": [{"fname": "decode", "evidence": "This 'decode' function converts escaped UTF-8 hexadecimal bytes into strings, matching the target function's primary purpose and error handling closely, making invocation highly likely."}]}
{"function": "get_os_group", "target_function_prompt": "def get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n    name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n    Defaults to the current users's group.\n\n    Raises:\n    OSError: If the given ``name`` does not exist as a \"group\n    name\" for this operating system.\n    OSError: If the given ``name`` is a ``gid`` and it does not\n    exist.\n\n    :rtype:\n    :obj:`struct_group <grp>`\n\n    * A tuple like object.\n\n    Example:\n    >>> from flutils.pathutils import get_os_group\n    >>> get_os_group('bar')\n    grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n    gr_mem=['foo'])\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["get_os_user"], "context": []}
{"function": "encode", "target_function_prompt": "def encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n    text (str or :obj:`~UserString`): The string input.\n    errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n    bytes: The given ``text`` converted into escaped utf8 bytes.\n    int: The number of given ``text`` characters consumed\n\n    Raises:\n    UnicodeEncodeError: if the given ``text`` contains escaped\n    utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 5, "target_api_invocations": ["_each_utf8_hex"], "context": [{"fname": "get_encoding", "evidence": "The target function is encoding text and may need to validate or obtain a valid encoding codec name. The get_encoding utility provides encoding validation and fallback, likely useful internally for ensuring a proper encoding name."}, {"fname": "as_escaped_utf8_literal", "evidence": "This function converts text into escaped UTF-8 hexadecimal byte literals, which closely aligns with the encode function's task of producing escaped UTF-8 hexadecimal sequences for the input text."}, {"fname": "_each_utf8_hex", "evidence": "This generator function yields escaped UTF-8 hexadecimal byte strings or printable characters per input character, directly supporting the encode function's need to iterate and convert text characters into escaped UTF-8 hexadecimal bytes."}, {"fname": "decode", "evidence": "The target function 'encode' converts a string containing escaped utf8 hexadecimal to bytes with escaped utf8 hexadecimal, i.e., it encodes text as escaped utf8 bytes. Node 2's 'decode' function performs the inverse operation, converting escaped utf8 hex bytes back to a string. Given the complementary nature, 'encode' might invoke 'decode' logically for validation, round-trip checks, or error handling, although the main action is encoding. Also, they share the same naming and signature pattern, suggesting related codec operations."}, {"fname": "convert_escaped_utf8_literal", "evidence": "Node 5's 'convert_escaped_utf8_literal' function converts strings containing escaped UTF-8 hexadecimal into proper Unicode characters. Since the target 'encode' function deals with converting strings that may contain escaped utf8 hexadecimal into bytes of escaped utf8 hexadecimal, it is plausible that during implementation it calls this function to normalize or convert parts of the text before encoding, or for some kind of validation or pre-processing step. The description and example strongly relate to how escaped utf8 hex sequences are handled, matching the target function's domain closely."}]}
{"function": "has_any_callables", "target_function_prompt": "def has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n    *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n    and ANY are callable;\n    * :obj:`False` otherwise.\n\n    Example:\n    >>> from flutils.objutils import has_any_callables\n    >>> has_any_callables(dict(),'get','keys','items','values','foo')\n    True\n    \"\"\"\n", "f1_score": 1.0, "recall": 1.0, "precision": 1.0, "context_size": 1, "target_api_invocations": ["has_any_attrs"], "context": [{"fname": "has_any_attrs", "evidence": "This function checks if any of the given attributes exist on the object, which directly satisfies the first condition the target function needs. It is logical the target function invokes this to verify attribute existence before checking callability."}]}
{"function": "is_list_like", "target_function_prompt": "def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n    obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n    :obj:`bool`\n\n    * :obj:`True` if the given ``obj`` is list-like; :\n    * :obj:`False` otherwise.\n\n    Examples:\n    >>> from flutils.objutils import is_list_like\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like(reversed([1, 2, 4]))\n    True\n    >>> is_list_like('hello')\n    False\n    >>> is_list_like(sorted('hello'))\n    True\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 4, "target_api_invocations": ["is_subclass_of_any"], "context": [{"fname": "has_attrs", "evidence": "has_attrs is useful to verify that the object has all required attributes typical of list-like objects, supporting attribute-based checks in is_list_like."}, {"fname": "has_callables", "evidence": "has_callables helps verify that required attributes are callable, ensuring the object behaves like a list through methods like __iter__, matching the is_list_like intent."}, {"fname": "has_any_attrs", "evidence": "has_any_attrs allows checking if the object has at least one of several attributes indicative of list-likeness, facilitating flexible checks in is_list_like."}, {"fname": "is_subclass_of_any", "evidence": "is_subclass_of_any enables checking if the object's class fits within known list-like classes, directly supporting type-based determination in is_list_like."}]}
