{"function": "externalize", "target_function_prompt": "def externalize(taskclass_or_taskobject):\n    \"\"\"\n    Returns an externalized version of a Task. You may both pass an\n    instantiated task object or a task class. Some examples:\n\n    .. code-block:: python\n\n    class RequiringTask(luigi.Task):\n    def requires(self):\n    task_object = self.clone(MyTask)\n    return externalize(task_object)\n\n    ...\n\n    Here's mostly equivalent code, but ``externalize`` is applied to a task\n    class instead.\n\n    .. code-block:: python\n\n    @luigi.util.requires(externalize(MyTask))\n    class RequiringTask(luigi.Task):\n    pass\n    ...\n\n    Of course, it may also be used directly on classes and objects (for example\n    for reexporting or other usage).\n\n    .. code-block:: python\n\n    MyTask = externalize(MyTask)\n    my_task_2 = externalize(MyTask2(param='foo'))\n\n    If you however want a task class to be external from the beginning, you're\n    better off inheriting :py:class:`ExternalTask` rather than :py:class:`Task`.\n\n    This function tries to be side-effect free by creating a copy of the class\n    or the object passed in and then modify that object. In particular this\n    code shouldn't do anything.\n\n    .. code-block:: python\n\n    externalize(MyTask)  # BAD: This does nothing (as after luigi 2.4.0)\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["_task_wraps"], "context": []}
{"function": "flatten", "target_function_prompt": "def flatten(struct):\n    \"\"\"\n    Creates a flat list of all all items in structured output (dicts, lists, items):\n\n    .. code-block:: python\n\n    >>> sorted(flatten({'a': 'foo', 'b': 'bar'}))\n    ['bar', 'foo']\n    >>> sorted(flatten(['foo', ['bar', 'troll']]))\n    ['bar', 'foo', 'troll']\n    >>> flatten('foo')\n    ['foo']\n    >>> flatten(42)\n    [42]\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 0, "target_api_invocations": ["result"], "context": []}
{"function": "flatten_output", "target_function_prompt": "def flatten_output(task):\n    \"\"\"\n    Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 29, "target_api_invocations": ["flatten"], "context": [{"fname": "_get_set_of_params", "evidence": "This utility function _get_set_of_params collects unique parameter values from a list of tasks. Since flatten_output involves recursively walking tasks that might be wrappers without outputs, it might need to analyze parameters of tasks or groups of tasks to process or distinguish them. Access to a utility that aggregates parameter sets from tasks is potentially useful and may be invoked for internal subtasks analysis or to manage task collections."}, {"fname": "_group_tasks_by_name_and_status", "evidence": "Grouping tasks by task family can aid flatten_output in efficiently processing and recursively walking output-less wrapper tasks."}, {"fname": "output", "evidence": "The target function recursively lists output targets and would invoke output() methods like this to obtain a task's outputs."}, {"fname": "output", "evidence": "Same as Node 2, flatten_output needs to call output() to get output targets."}, {"fname": "output", "evidence": "Same as Node 2, flatten_output will invoke output() to retrieve outputs."}, {"fname": "output", "evidence": "Same as Node 2, the output() method is a key function flatten_output will call to list output targets."}, {"fname": "output", "evidence": "flatten_output needs to call output() on tasks to obtain their output targets; this function implements output(), so it might be invoked."}, {"fname": "output", "evidence": "This output() returns a target for a task and could be called by flatten_output to get outputs, as part of recursively walking tasks."}, {"fname": "output", "evidence": "As an output() function implementation returning task output targets, it is potentially invoked by flatten_output."}, {"fname": "output", "evidence": "Similar to Node 2, this output() method could be invoked by flatten_output to retrieve the output targets of tasks."}, {"fname": "output", "evidence": "This output() function returns a local target for a task, likely invoked by flatten_output to list outputs while traversing tasks."}, {"fname": "output", "evidence": "The target function must call a task's output() method to get the output targets. This node implements an output() method returning such targets."}, {"fname": "output", "evidence": "The target function must call a task's output() method to obtain its outputs. This node provides an implementation of such an output() method."}, {"fname": "output", "evidence": "The target function needs to call output() to gather task outputs, and this node implements such an output() method."}, {"fname": "requires", "evidence": "To recursively walk output-less tasks, the target function needs to access dependencies via requires(). This node implements such a requires() method."}, {"fname": "requires", "evidence": "Same as node 4, this node defines a requires() method to get task dependencies, which the target function would invoke to traverse tasks."}, {"fname": "requires", "evidence": "flatten_output needs to recursively get dependent tasks by invoking requires() on wrapper tasks, and Node 1 defines a requires() method providing such dependencies."}, {"fname": "requires", "evidence": "flatten_output will call requires() on tasks without output to recurse; Node 2 provides such a requires() method with dependencies."}, {"fname": "requires", "evidence": "Node 3's requires() method returns dependent tasks, which flatten_output is expected to invoke when traversing output-less tasks."}, {"fname": "requires", "evidence": "Node 4's requires() method returning a dependent task is relevant because flatten_output invokes requires() to get dependencies of wrapper tasks."}, {"fname": "output", "evidence": "flatten_output calls output() to check if the task has outputs; Node 5 defines the output() method returning output targets necessary to this process."}, {"fname": "output", "evidence": "The target function recursively lists outputs by calling task.output(), and this function implements a task.output() returning a mocked target."}, {"fname": "output", "evidence": "This output() implementation returns a local target that the target function would retrieve when listing a task's outputs."}, {"fname": "output", "evidence": "This output() function returns a remote target, and the target function would invoke output() to get all types of outputs recursively."}, {"fname": "deps", "evidence": "Flatten_output recursively walks tasks, so it may invoke this deps() method to recursively gather all dependent tasks to traverse."}, {"fname": "input", "evidence": "This input() method returns outputs of all required tasks, assisting in retrieving outputs during recursive walking, thus likely invoked."}, {"fname": "find_deps", "evidence": "The target function flatten_output aims to list all output targets by recursively walking through output-less (wrapper) tasks. Such recursion and dependency traversal strongly suggests that it would need functionality very similar to find_deps, which finds all dependencies on paths from a task. Since find_deps yields all dependent tasks, flatten_output might invoke this to collect or traverse tasks to flatten their outputs."}, {"fname": "_requires", "evidence": "_requires is a core internal method that returns dependencies by flattening requires(). Since flatten_output must recursively walk outputs through tasks, and wrapper tasks may introduce non-input dependencies, flatten_output would likely need to call _requires to properly retrieve all dependencies of a task, including non-input ones, for correct recursive traversal."}, {"fname": "dfs_paths", "evidence": "dfs_paths performs a depth-first traversal of tasks along dependency paths, yielding tasks matching a given family or all tasks. This behavior aligns directly with the need of flatten_output to recursively traverse output-less wrapper tasks and gather all their outputs. Implementing flatten_output probably relies on dfs_paths to walk through task dependencies."}]}
{"function": "run", "target_function_prompt": "def run(*args, **kwargs):\n    \"\"\"\n    Please dont use. Instead use `luigi` binary.\n\n    Run from cmdline using argparse.\n\n    :param use_dynamic_argparse: Deprecated and ignored\n    \"\"\"\n", "f1_score": 0.025641025641025647, "recall": 1.0, "precision": 0.012987012987012988, "context_size": 77, "target_api_invocations": ["_run"], "context": [{"fname": "create_subprocess", "evidence": "create_subprocess creates a subprocess with detailed signal handling and pipe setup. The run function is designed to run the command line interface via argparse, which would reasonably involve launching subprocesses. Creating subprocesses with controlled signal handling aligns with the likely implementation of run's command execution responsibilities."}, {"fname": "check_output", "evidence": "check_output executes a shell command and returns its output, raising errors on failure. The run function potentially needs to run commands programmatically and capture output or errors for CLI tasks invoked. This utility method is appropriate for run function usage when executing commands and handling results."}, {"fname": "_server_already_running", "evidence": "The run function likely needs to check if a server is already running to avoid multiple scheduler instances, and this utility exactly performs that check."}, {"fname": "getpcmd", "evidence": "Managing running processes involves retrieving command line info by PID; thus, the run function may invoke this utility to verify or obtain process details."}, {"fname": "get_info", "evidence": "As the run function needs to handle PID files and process identification, this utility returning PID, command, and pidfile path is likely invoked."}, {"fname": "_read_pids_file", "evidence": "_read_pids_file is a utility for reading pid files that run might use to check existing process locks or instances."}, {"fname": "_write_pids_file", "evidence": "_write_pids_file writes pid files and sets permissions; run might invoke it to manage process locking or tracking."}, {"fname": "check_pid", "evidence": "check_pid is used to verify if a process for a given pidfile is alive, likely used by run to avoid duplicate runs."}, {"fname": "write_pid", "evidence": "write_pid writes the current process id to a file, which is often part of CLI run to signal active process; thus run might invoke it."}, {"fname": "luigi_run", "evidence": "luigi_run runs the Luigi pipeline and is the natural candidate function invoked by the CLI run function to execute tasks."}, {"fname": "build", "evidence": "The build function programmatically runs Luigi tasks internally, bypassing command-line parsing but performing task scheduling and execution with environment parameters. Given the target run function is a CLI entry point invoking luigi tasks and the docstring instructs to use the luigi binary which likely calls into this internal machinery, it is plausible that run internally calls build or similarly structured functions to execute tasks programmatically after parsing arguments. Therefore, build is very likely to be invoked during run's implementation."}, {"fname": "run_with_retcodes", "evidence": "The run_with_retcodes function runs Luigi tasks invoking command-line parsing and raises SystemExit with proper return codes after execution. The target run function is described as running Luigi from cmdline using argparse, which aligns with the functionality of run_with_retcodes. It is reasonable that run would delegate to or call run_with_retcodes internally to parse argv and perform execution with proper exit code management, making this node likely invoked."}, {"fname": "add", "evidence": "The 'run' function (based on the file context and typical luigi design) orchestrates worker creation and scheduling. The 'add' method of the Worker class is a core method that schedules and runs tasks, which aligns strongly with what 'run' initiates. Given 'run' triggers task execution, it is highly likely to invoke this or similar methods on worker instances to schedule tasks."}, {"fname": "_add", "evidence": "The run function coordinates task execution, which requires adding tasks to the schedule with dependencies via this method."}, {"fname": "_get_work", "evidence": "Fetching new tasks from the scheduler is essential for running tasks; therefore, run calls this method to obtain work."}, {"fname": "_run_task", "evidence": "To execute scheduled tasks, run must start or run tasks using this method that manages task execution."}, {"fname": "run", "evidence": "The top-level run function delegates core running logic to Worker.run(), managing task execution lifecycle."}, {"fname": "acquire_for", "evidence": "acquire_for is a locking utility to prevent multiple simultaneous runs of the same command, which fits the CLI run() function purpose of controlled process execution. It is very likely invoked for concurrency control."}, {"fname": "update_resources", "evidence": "The run function likely configures the scheduler before starting tasks, which could involve updating multiple resource settings via update_resources."}, {"fname": "update_resource", "evidence": "The run function may update individual resource quantities during scheduler setup, making invocation of update_resource likely."}, {"fname": "get_work", "evidence": "`get_work` is the core Scheduler method for assigning work to workers; it is very likely invoked during task execution orchestrated by `run`."}, {"fname": "add_task", "evidence": "`add_task` is a fundamental Scheduler API to add or update tasks; it is likely called or triggered during orchestration of task runs by `run`."}, {"fname": "create_local_scheduler", "evidence": "create_local_scheduler instantiates the local scheduler needed to schedule tasks, a core step during run execution."}, {"fname": "create_worker", "evidence": "create_worker creates worker instances to run scheduled tasks, a necessary step when running luigi programmatically."}, {"fname": "get_task_obj", "evidence": "get_task_obj returns an instance of a configured task based on command line arguments. The run function, which runs tasks programmatically from parsed args, is likely to call this method to obtain a task instance to execute."}, {"fname": "_get_task_cls", "evidence": "_get_task_cls is a utility method returning the task class for the root task. Since get_task_obj calls this method to instantiate tasks, and run() delegates execution of tasks, run() may indirectly or directly invoke this method as part of task resolution."}, {"fname": "parse", "evidence": "run must convert command line task names into task classes; this parse function fetches the class from a registry and fits that need exactly."}, {"fname": "load_task", "evidence": "run needs to dynamically load tasks using module and task name from CLI input; this function imports and instantiates task objects and so likely invoked by run."}, {"fname": "dfs_paths", "evidence": "run must resolve task dependencies before execution; this DFS helper enumerates dependent tasks and thus is likely invoked during task scheduling."}, {"fname": "find_deps_cli", "evidence": "This function parses CLI arguments and finds all dependent tasks, which aligns directly with run's purpose as CLI entrypoint."}, {"fname": "externalize", "evidence": "The CLI run function may need to treat some task classes or instances as external dependencies by disabling their run methods, so it is plausible that it invokes the externalize utility."}, {"fname": "main", "evidence": "The function main() is a natural candidate to be called by the CLI run function to discover tasks, gather dependencies, generate output descriptions, and print task details, matching the expected CLI workflow."}, {"fname": "dep_graph", "evidence": "The run function likely needs to query the dependency graph to understand task relationships for scheduling and execution, so it may invoke dep_graph to obtain this graph structure."}, {"fname": "inverse_dep_graph", "evidence": "Complementing dep_graph, inverse_dep_graph provides the inverse dependency relations useful for the CLI runner to analyze impact and dependencies, making it plausible for run() to invoke this routine."}, {"fname": "get_active_queue", "evidence": "`get_active_queue` might be invoked if the CLI run function submits jobs to job queues and needs to select one."}, {"fname": "serialize", "evidence": "The serialize method may be invoked by 'run' to convert optional parameters to string during CLI argument or environment parameter handling."}, {"fname": "main", "evidence": "The main() function sets up logging, validates an argument representing a directory, and initiates a work process—this aligns with run() which uses argparse for cmdline running and likely delegates to such entry-point functions handling work execution and logging setup."}, {"fname": "daemonize", "evidence": "daemonize() runs commands as daemon processes, managing logging and PID files; since run() is a command line entry point, it might invoke daemonize or functions like it to run services or commands in the background consistent with CLI usage patterns."}, {"fname": "_value_iterator", "evidence": "The target function runs from command line and will need to retrieve parameters and configurations; this utility supports that core functionality."}, {"fname": "subprocess_setup", "evidence": "subprocess_setup configures the subprocess environment by resetting SIGPIPE handler which is relevant for launching subprocesses and integration handling often done in a CLI run context. The run() function that executes from the command line might spawn subprocesses and thus could invoke subprocess_setup to properly configure signals."}, {"fname": "batchable", "evidence": "Since run manages task execution and batchable tasks can be handled differently, run might invoke batch checks to enable batch processing features."}, {"fname": "tasks_str", "evidence": "run might invoke tasks_str to display or log the available Luigi tasks during command line execution or help display."}, {"fname": "_editdistance", "evidence": "run might invoke _editdistance to implement typo correction or similarity-based suggestions for task names or command line inputs."}, {"fname": "parameters", "evidence": "run might invoke parameters to retrieve or set task parameters when preparing batch tasks for execution."}, {"fname": "has_task_history", "evidence": "Checks scheduler config for task history recording, which run may need to consult while configuring or interacting with scheduler components."}, {"fname": "_get_unique_param_keys", "evidence": "_get_unique_param_keys helps identify parameters with multiple values, which aligns with argument parsing likely performed by the run function."}, {"fname": "is_error_5xx", "evidence": "The run function may involve network or RPC calls when interfacing with schedulers, making HTTP 5xx error detection relevant for error handling."}, {"fname": "_get_task_kwargs", "evidence": "Parsing command-line arguments and preparing task keyword arguments is a fundamental step in running tasks from CLI; this helper directly addresses that."}, {"fname": "_init_local", "evidence": "_init_local prepares the local environment and dependencies for task execution, which is a typical part of task running and likely called by run."}, {"fname": "run", "evidence": "This run method represents task execution logic; the top-level run function likely invokes task run methods like this to execute tasks."}, {"fname": "_setup_remote", "evidence": "_setup_remote prepares remote execution environment for tasks; the run function likely triggers such setup when running remote or distributed tasks."}, {"fname": "_root_task", "evidence": "The `run` function orchestrates worker creation and scheduling; it may invoke `_root_task(worker)` to extract the root task for diagnostics or reporting."}, {"fname": "_validate_task", "evidence": "run involves task scheduling where validating that inputs are proper Task instances is essential; thus _validate_task is likely invoked."}, {"fname": "_get_work_task_id", "evidence": "run manages workers and scheduling, which handle work responses requiring task ID retrieval and loading; _get_work_task_id is likely invoked."}, {"fname": "get_task_requires", "evidence": "run or the worker it creates must resolve all prerequisite tasks; get_task_requires provides this dependency resolution and is likely invoked."}, {"fname": "requires", "evidence": "To determine which Tasks to run, run must check their dependencies via requires(), a fundamental Task API method, thus it is likely invoked."}, {"fname": "deps", "evidence": "run involves internal scheduling which requires flattened dependencies; deps() provides this flattened list and is likely invoked during task orchestrations."}, {"fname": "initialized", "evidence": "Checking if a Task is initialized by verifying task_id attribute is likely part of task validation before execution in run()."}, {"fname": "output", "evidence": "This function provides the task output target as a local file path, which the run function likely invokes to manage or verify task outputs upon execution."}, {"fname": "get_target", "evidence": "This helper constructs LocalTarget objects from URL components and parameters, which the run function might invoke when dynamically creating or resolving task targets during CLI execution."}, {"fname": "output", "evidence": "This output function for remote files over SSH is a common pattern for task outputs, and the run function could invoke it to manage tasks producing remote outputs."}, {"fname": "ecs_task_ids", "evidence": "Retrieving ECS task IDs is useful for managing distributed ECS tasks; the run function may invoke this to handle task lifecycle or tracking during execution."}, {"fname": "_forward_attributes", "evidence": "The context manager forwarding task status attributes supports task execution status management, which the run function might use to propagate and reset execution context attributes."}, {"fname": "run", "evidence": "The run function is a CLI entrypoint that likely triggers controlled execution of tasks, which aligns with invoking context-managed run methods like this one."}, {"fname": "no_unpicklable_properties", "evidence": "The run function may invoke code paths requiring task serialization, for which this context-managed removal of unpicklable properties is useful."}, {"fname": "run", "evidence": "The target run function is an entry point for running Luigi tasks, which includes invoking task run() methods such as this Dynamic class core method."}, {"fname": "run", "evidence": "Similar to Node 1, this task run() method could be invoked when Luigi runs a DateTask via the CLI entry point."}, {"fname": "run", "evidence": "This function manages task running lifecycle and is likely called as part of running tasks triggered by the CLI run function."}, {"fname": "output", "evidence": "Task output() methods are checked by Luigi internals when deciding to run a task; thus indirectly invoked during the CLI run invocation."}, {"fname": "_populate_unknown_statuses", "evidence": "This helper function updates task statuses for upstream dependencies and pending states, which is necessary when preparing task execution in command line runs."}, {"fname": "_filter_done", "evidence": "Filtering completed tasks to identify pending or unknown ones is a fundamental operation in scheduling tasks and will likely be used during command line task execution."}, {"fname": "_format_input_args", "evidence": "The run() function triggers task execution, which may indirectly call this method in BeamDataflowJobTask instances to format input arguments for the Dataflow job."}, {"fname": "_format_output_args", "evidence": "Similarly, run() may indirectly invoke this method in BeamDataflowJobTask instances during task execution to format output arguments for downstream job processing."}, {"fname": "__exit__", "evidence": "The '__exit__' method of the Worker class ensures proper resource cleanup upon exiting a context. Since the 'run' function uses the Worker in a 'with' statement (per the file content comments), it can trigger this '__exit__' method when exiting the context, making invocation highly probable."}, {"fname": "_schedule_and_run", "evidence": "The _schedule_and_run function orchestrates scheduling and executing tasks with worker and scheduler management, which aligns directly with the target run function's role to run tasks programmatically. It is highly likely to be invoked."}, {"fname": "_run", "evidence": "_run is a flexible internal helper that prepares command line arguments, optionally sets task classes and schedulers, and calls _schedule_and_run. Given the target run function is a command line entry point, it would likely invoke this helper to handle argument parsing and task execution."}, {"fname": "create_remote_scheduler", "evidence": "The target function 'run' is described as a command line entry point using argparse and responsible for running Luigi tasks. Given the _WorkerSchedulerFactory class example and the create_remote_scheduler method's purpose to create a remote scheduler, it is very plausible that 'run' invokes 'create_remote_scheduler' to set up the scheduler connection required to execute tasks remotely. The description and implementation align with typical command line scheduling functionality."}]}
{"function": "build", "target_function_prompt": "def build(tasks, worker_scheduler_factory=None, detailed_summary=False, **env_params):\n    \"\"\"\n    Run internally, bypassing the cmdline parsing.\n\n    Useful if you have some luigi code that you want to run internally.\n    Example:\n\n    .. code-block:: python\n\n    luigi.build([MyTask1(), MyTask2()], local_scheduler=True)\n\n    One notable difference is that `build` defaults to not using\n    the identical process lock. Otherwise, `build` would only be\n    callable once from each process.\n\n    :param tasks:\n    :param worker_scheduler_factory:\n    :param env_params:\n    :return: True if there were no scheduling errors, even if tasks may fail.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 30, "target_api_invocations": ["_schedule_and_run"], "context": [{"fname": "task_history", "evidence": "The build function orchestrates running tasks and may access the Scheduler's task history to report or monitor the scheduling outcomes."}, {"fname": "add", "evidence": "`build` needs to schedule and run provided tasks; invoking the Worker's `add` method is the natural way to perform this core functionality."}, {"fname": "_run_task", "evidence": "_run_task is a core Worker method to execute scheduled tasks; since build runs tasks internally, this method will be invoked directly or indirectly."}, {"fname": "run", "evidence": "The build function manages task execution and will call the Worker's run() method to execute tasks until completion."}, {"fname": "acquire_for", "evidence": "build runs tasks internally and may invoke acquire_for to manage process locking, as locking is relevant to prevent concurrent runs."}, {"fname": "update_resources", "evidence": "build may invoke update_resources to configure scheduler resource limits dynamically based on environment parameters before running tasks."}, {"fname": "_rank", "evidence": "Ranking tasks based on priority and time is essential for scheduling; the build function is likely to invoke this method to determine task order."}, {"fname": "get_work", "evidence": "get_work is the core method assigning tasks to workers based on priority, resources, and dependencies, which the build function must invoke to schedule and run tasks."}, {"fname": "_update_priority", "evidence": "Priority management is essential to correct scheduling. As build internally runs tasks via the scheduler, it likely causes priority updates of tasks by invoking this method."}, {"fname": "add_task", "evidence": "Adding or updating tasks in the scheduler state is fundamental for scheduling within build. This method manages task lifecycle, dependencies, and status, so it is very likely invoked during internal task running."}, {"fname": "create_local_scheduler", "evidence": "Build needs to create scheduler instances for internal task running. This factory method to create a local scheduler fits the scenario and is likely invoked."}, {"fname": "create_worker", "evidence": "The target function `build` involves creating and running workers to execute the given tasks. Node 1's function `create_worker` directly creates Worker instances configured with scheduler, worker processes, and assistant flag. This is relevant because `build` likely needs to instantiate workers to run tasks internally."}, {"fname": "_remove_workers_from_tasks", "evidence": "Managing worker assignments to tasks is relevant during internal task execution; this method removes workers from tasks dynamically."}, {"fname": "disable_workers", "evidence": "Disabling workers affects worker availability/state; such management operations are likely invoked during internal runs."}, {"fname": "_reset_orphaned_batch_running_tasks", "evidence": "Resetting batch-running orphaned tasks to pending helps maintain accurate task states, useful during internal scheduling and recovering runs."}, {"fname": "_prune_tasks", "evidence": "Pruning stale or dead tasks maintains a clean task state, necessary before or after running builds internally."}, {"fname": "update_status", "evidence": "Updating task statuses for retries, removals, or re-enablement is fundamental to task lifecycle management during internal running of tasks."}, {"fname": "set_batch_running", "evidence": "Since build involves running tasks, it likely invokes or triggers task state changes marking tasks as running, making this function potentially invoked during execution."}, {"fname": "before_get", "evidence": "Because build deals with internal run parameters, it may invoke environment interpolation utilities to resolve configuration dynamically, making invocation likely."}, {"fname": "check_complete", "evidence": "Checking task completion is a fundamental part of running tasks and determining success; this utility function would likely be invoked by build or its components."}, {"fname": "fail_dead_worker_task", "evidence": "Handling of tasks assigned to dead or disconnected workers is integral to task execution; build’s internal orchestration likely leads to this function being called for robust task state management."}, {"fname": "_purge_children", "evidence": "Detection and handling of failed or timed-out tasks are essential when running tasks; this worker utility is plausibly invoked during build’s task execution process."}, {"fname": "requires", "evidence": "The requires() method defining task dependencies will be invoked during scheduling of tasks run by build."}, {"fname": "requires", "evidence": "Similarly, requires() of other tasks is invoked to construct the full task dependency graph used by build."}, {"fname": "deps", "evidence": "The deps() method provides comprehensive dependency resolution key for scheduling, and would be invoked in the process of running tasks via build."}, {"fname": "_get_reg", "evidence": "build may need to retrieve all registered task classes to validate or resolve tasks it is supposed to run, making _get_reg invocation plausible."}, {"fname": "task_names", "evidence": "Listing registered task names supports build's possible need to introspect available tasks for validation or diagnostics."}, {"fname": "get_task_cls", "evidence": "Resolving a task class by name safely is critical for build to validate and execute tasks, making get_task_cls a likely called API."}, {"fname": "__eq__", "evidence": "The __eq__ method defines equality comparisons for Task instances. The build function handles lists of tasks, and it is plausible that it or its underlying components perform equality checks to detect duplicates or for task management. Such checks would implicitly invoke __eq__, so this method might be called during build execution."}, {"fname": "__hash__", "evidence": "The __hash__ method enables Task instances to be used in sets and dicts. Since build likely manages tasks internally using data structures requiring hashing (to avoid duplicates or for efficient lookup), __hash__ would be implicitly called. Thus, it might be invoked during the build process."}]}
{"function": "parse_results", "target_function_prompt": "def parse_results(fields, data):\n    \"\"\"\n    Traverses ordered dictionary, calls _traverse_results() to recursively read into the dictionary depth of data\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 2, "target_api_invocations": ["ensure_utf", "_traverse_results"], "context": [{"fname": "parse", "evidence": "parse_results traverses ordered dictionaries and may need to parse JSON-formatted strings into ordered dictionaries; this node's parse function converts JSON strings with ordered dict preservation, fitting this need."}, {"fname": "parse", "evidence": "Given parse_results deals with recursive reading of complex structures, it may need to parse nested tuple representations from strings; this node’s parse method supports that, making invocation plausible."}]}
{"function": "_get_per_location_glob", "target_function_prompt": "def _get_per_location_glob(tasks, outputs, regexes):\n    \"\"\"\n    Builds a glob listing existing output paths.\n\n    Esoteric reverse engineering, but worth it given that (compared to an\n    equivalent contiguousness guarantee by naive complete() checks)\n    requests to the filesystem are cut by orders of magnitude, and users\n    don't even have to retrofit existing tasks anyhow.\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 11, "target_api_invocations": ["most_common"], "context": [{"fname": "_list_existing", "evidence": "The target function _get_per_location_glob aims to build a glob listing existing output paths. The node _list_existing (Node 1) provides a function that lists and returns a set of existing paths matching constrained globs on a given filesystem. This functionality closely aligns with the target's purpose, so it is highly likely that _get_per_location_glob would invoke _list_existing to retrieve existing paths."}, {"fname": "_constrain_glob", "evidence": "The target function likely needs to refine glob patterns to efficiently query existing paths. Node 2's _constrain_glob refines a glob pattern by producing specific globs that still cover all relevant paths but reduce excessive directory listings. Given that _list_existing calls _constrain_glob and the target builds glob listings, invoking _constrain_glob directly or indirectly is very plausible during implementation."}, {"fname": "listdir", "evidence": "Node 3 provides an implementation of listdir that lists all paths recursively from Dropbox storage using API calls. The target function deals with output paths and likely needs to query underlying filesystems for existing files. Because the codebase shows multiple filesystem target implementations, and _get_per_location_glob probably works on abstract filesystems, it is plausible that it might invoke such listdir implementations depending on the filesystem passed, including this Dropbox-specific listdir."}, {"fname": "listdir", "evidence": "Node 4's listdir implementation provides a prefix-based directory listing for a mock filesystem environment. Since the target is building glob listings from outputs (which could be in test or mock environments), it might invoke this listdir when operating on such mock filesystems. This aligns with the need to list files filtered by prefix to inform glob expansions."}, {"fname": "listdir", "evidence": "Node 5 offers a listdir method for S3 buckets, returning files with optional time filters and formats. Because the target function deals with outputs and existing file paths, it may be used in contexts involving S3 filesystems. Hence, invoking this listdir implementation to enumerate files in an S3 bucket path to build the final glob listing is plausible."}, {"fname": "list", "evidence": "Lists items at an S3 path providing relative/full keys, matching the need to build glob listings of output paths."}, {"fname": "listdir", "evidence": "Lists objects within a GCS path providing relative paths, similarly needed to enumerate existing outputs for glob building."}, {"fname": "_add_path_delimiter", "evidence": "The target function handles output paths and may need to ensure S3 keys have consistent trailing slashes for globbing, so this helper could be invoked."}, {"fname": "_exists", "evidence": "Checking if an S3 object exists is essential for validating which outputs exist before building globs, so this method is likely invoked."}, {"fname": "_path_to_bucket_and_key", "evidence": "The function must parse GCS URIs into bucket and key components to build accurate globs, so this parsing utility is likely used."}, {"fname": "_path_to_bucket_and_key", "evidence": "Parsing S3 URL paths into bucket and key for correct glob construction is required, so this helper is likely invoked by the target function."}]}
{"function": "_list_existing", "target_function_prompt": "def _list_existing(filesystem, glob, paths):\n    \"\"\"\n    Get all the paths that do in fact exist. Returns a set of all existing paths.\n\n    Takes a luigi.target.FileSystem object, a str which represents a glob and\n    a list of strings representing paths.\n    \"\"\"\n", "f1_score": 0.25, "recall": 1.0, "precision": 0.14285714285714285, "context_size": 7, "target_api_invocations": ["_constrain_glob"], "context": [{"fname": "_constrain_glob", "evidence": "The function refines globs to more specific patterns based on actual path digits, optimizing expensive filesystem queries. This is directly useful for the target's goal of efficiently determining existing paths matching a glob and path list."}, {"fname": "listdir", "evidence": "This listing method returns all files and folders under a Dropbox path recursively, which is exactly the kind of functionality the target function needs to discover existing paths on Dropbox filesystems."}, {"fname": "listdir", "evidence": "This method lists filesystem entries matching a prefix within a mock filesystem, aligning with the target function's need to find actual existing paths in a filesystem-agnostic manner."}, {"fname": "fs", "evidence": "The target function might need to call this method to obtain the filesystem object from RemoteTarget instances when accessing the file system to check path existence."}, {"fname": "fs", "evidence": "Similarly, this method returns the filesystem associated with AtomicFtpFile, which could be invoked by the target function if it handles those file objects to get their filesystem."}, {"fname": "open", "evidence": "_list_existing likely invokes open() to access or resolve resources matching the glob pattern before checking path existence."}, {"fname": "get_opener", "evidence": "get_opener() is a utility used to retrieve protocol-specific openers, likely called by open() and thereby involved in _list_existing's operations."}]}
{"function": "find_deps", "target_function_prompt": "def find_deps(task, upstream_task_family):\n    '''\n    Finds all dependencies that start with the given task and have a path\n    to upstream_task_family\n\n    Returns all deps on all paths between task and upstream\n    '''\n", "f1_score": 0.2222222222222222, "recall": 1.0, "precision": 0.125, "context_size": 8, "target_api_invocations": ["dfs_paths"], "context": [{"fname": "requires", "evidence": "The target function find_deps traverses dependencies and likely invokes tasks' requires() methods such as this one to gather prerequisite tasks."}, {"fname": "requires", "evidence": "Similar to Node 1, this requires() implementation returns a dependent task that would likely be queried by find_deps during dependency resolution."}, {"fname": "requires", "evidence": "This requires() method returns direct dependencies which find_deps will need to explore task dependency paths."}, {"fname": "requires", "evidence": "This requires() method returns prerequisite subtasks; find_deps will invoke such methods to explore dependencies."}, {"fname": "deps", "evidence": "The deps() method returns a flattened list of all dependencies and subtasks, directly aiding find_deps in gathering full dependency paths."}, {"fname": "_requires", "evidence": "The _requires() method aggregates a task's dependencies and is likely used to retrieve dependencies during dependency traversal in find_deps."}, {"fname": "dfs_paths", "evidence": "dfs_paths implements the depth-first traversal required to find all dependency paths, matching the core functionality of find_deps."}, {"fname": "inverse_dep_graph", "evidence": "The inverse_dep_graph function generates an inverse dependency graph that shows which tasks depend on the given task—that is, it provides upstream dependency information. Since find_deps needs to find all dependencies along paths from a start task to an upstream family, it must explore upstream tasks. The inverse_dep_graph supports this by capturing the 'inverse' dependencies and can be traversed to find all active upstream tasks. Therefore, inverse_dep_graph is highly relevant and might be invoked/called during find_deps implementation."}]}
{"function": "get_config", "target_function_prompt": "def get_config(parser=PARSER):\n    \"\"\"Get configs singleton for parser\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 5, "target_api_invocations": ["_check_parser"], "context": [{"fname": "instance", "evidence": "This singleton getter implementation matches the need to provide a singleton parser instance as described in get_config's docstring 'Get configs singleton for parser.' It creates or returns the singleton instance, reloads config once, and logs loading—exactly the kind of function that get_config would invoke to return the singleton parser."}, {"fname": "add_config_path", "evidence": "This add_config_path class method appends a path to _config_paths of a parser class and triggers a reload. Since get_config returns a parser instance which may require config paths to reload, this function could be invoked indirectly or internally during setup or reload. It is plausible get_config might invoke this or rely on this for parser state management."}, {"fname": "getintdict", "evidence": "The target function get_config is designed to get a configuration singleton for a parser. Node 1's getintdict method operates on a configuration parser (LuigiConfigParser) and retrieves typed configuration data from a section. While not the main function, such utility functions related to configuration retrieval could be used internally or during configuration handling. Thus, there is a reasonable possibility get_config might invoke or utilize this method or similar ones as part of accessing or processing config data."}, {"fname": "get", "evidence": "Node 3's get method is a core retrieval utility in LuigiTomlParser for accessing configuration values with a default fallback. Since get_config is responsible for obtaining configuration singleton for parser (which can be a LuigiTomlParser), this method is highly relevant and would likely be invoked to retrieve values from the parsed configuration data."}, {"fname": "getboolean", "evidence": "Node 4's getboolean is a straightforward accessor built on top of Node 3's get method, tailored to retrieve boolean options from configuration. Given that configuration retrieval often requires boolean options, and get_config manages config parser instances, it is plausible that get_config or functions it calls rely on this method for boolean config data access."}]}
{"function": "_get_run_by_other_worker", "target_function_prompt": "def _get_run_by_other_worker(worker):\n    \"\"\"\n    This returns a set of the tasks that are being run by other worker\n    \"\"\"\n", "f1_score": 0.0, "recall": 0.0, "precision": 0.0, "context_size": 9, "target_api_invocations": ["_get_external_workers"], "context": [{"fname": "_build_results", "evidence": "This function builds summarized results including job status and dependencies. The target function may require similar logic to analyze tasks and their dependencies, especially for understanding if a task is run by another worker, which involves task relationships and statuses."}, {"fname": "status_search", "evidence": "This function filters jobs by status using JSON data potentially sourced from the dependency graph. The target function might invoke such status-based filtering to identify tasks that are run by other workers, making it relevant."}, {"fname": "_get_work", "evidence": "The _get_work method obtains information about running and pending tasks from the scheduler, which aligns with the target function's purpose of finding tasks run by other workers."}, {"fname": "_update_worker", "evidence": "This node updates and returns a worker object and manages worker state, which is aligned with the target function that analyzes tasks associated with a worker. Accessing and updating the worker is likely prerequisite to identifying tasks run by other workers."}, {"fname": "assistant", "evidence": "This accessor method reads worker info which might be used to filter or identify other workers when retrieving their tasks."}, {"fname": "_add_task", "evidence": "Node 4 (_add_task) is an internal Worker method managing tasks and their scheduling state, including appending tasks and their statuses to _add_task_history. Since _get_run_by_other_worker returns tasks run by other workers, it likely examines or processes data structures such as _add_task_history that track task statuses and execution info. Therefore, _add_task contributes to the state _get_run_by_other_worker needs and might be invoked to manipulate or access task info."}, {"fname": "dfs_paths", "evidence": "The target function needs to identify tasks run by other workers from a worker object. The dfs_paths function performs a depth-first search over task dependencies, which could be useful within _get_run_by_other_worker to traverse task graphs and collect relevant tasks. The presence of traversal mechanisms aligns with the target function's likely logic."}, {"fname": "dep_graph", "evidence": "Dependency graph retrieval is likely needed to find related tasks and their statuses, supporting the identification of tasks run by other workers."}, {"fname": "inverse_dep_graph", "evidence": "Inverse dependency graph helps identify tasks depending on a given task, useful for finding tasks run by other workers."}]}
{"function": "summary", "target_function_prompt": "def summary(worker):\n    \"\"\"\n    Given a worker, return a human readable summary of what the worker have\n    done.\n    \"\"\"\n", "f1_score": 0.09523809523809525, "recall": 0.3333333333333333, "precision": 0.05555555555555555, "context_size": 18, "target_api_invocations": ["_summary_dict", "_summary_format", "_summary_wrap"], "context": [{"fname": "__repr__", "evidence": "The __repr__ method provides a concise string representation of LuigiRunResult including status and worker details, which may be used for debugging or string output during summary generation."}, {"fname": "_get_str", "evidence": "The _get_str function formats grouped tasks status dictionaries into readable strings, directly supporting the summary's goal of producing a human readable task status summary."}, {"fname": "_plural_format", "evidence": "Correct pluralization of counts in the summary string is important for readability, so the plural format helper is likely used when summarizing quantities of tasks."}, {"fname": "_get_comments", "evidence": "_get_comments generates human-readable comments and task counts for different task statuses, essential for summarizing worker activity, which aligns directly with the summary function's goal to produce a readable summary of worker actions."}, {"fname": "_create_one_line_summary", "evidence": "_create_one_line_summary produces a concise one-line summary string from a status code, which is highly relevant for summary since summary includes a status overview; thus, it likely invokes this to create the final summary line."}, {"fname": "_summary_wrap", "evidence": "_summary_wrap formats a full string output by enclosing it in labeled header/footer blocks, exactly suited for preparing a printable execution summary output. Summary function’s docstring and context indicate returning a human readable summary, so this wrapping function is likely called to produce the final formatted string."}, {"fname": "_get_len_of_params", "evidence": "The target function summary(worker) returns a human readable summary about the worker's tasks. Node 1 (_get_len_of_params) calculates lengths of task parameter names, a utility likely used in formatting or summarizing task representations, thus it might be invoked for concise task info in the summary."}, {"fname": "_get_str_ranging_multiple_parameters", "evidence": "Node 2 (_get_str_ranging_multiple_parameters) builds a formatted string showing parameter ranges for tasks. Given that summary aims for a human readable summary and may need to represent ranges of task parameters compactly, this helper is directly relevant for formatting portions of the summary output."}, {"fname": "pretty_id", "evidence": "The target function summary aims to produce a human-readable summary of what the worker has done, which involves presenting task information clearly. pretty_id returns a formatted string identifying a task by family name and parameters, making it very relevant for formatting task display in the summary."}, {"fname": "__repr__", "evidence": "The __repr__ method returns a string representation of a Task instance including its family and significant parameters, useful for readable identification and debugging. Since summary produces a human-readable summary of tasks, it may use __repr__ to convert tasks to readable strings in the output."}, {"fname": "task_search", "evidence": "task_search is a core method to search active tasks by substring match, returning tasks grouped by status. A summary of worker activity could reasonably involve retrieving tasks matching certain criteria or all active tasks. Thus, invoking task_search to gather tasks for inclusion in the summary is plausible."}, {"fname": "task_list", "evidence": "task_list queries and optionally limits/filter tasks based on status and other parameters. Since summary produces an overview of worker workload and progress, it likely needs a method to retrieve sets of tasks by status or filters. task_list provides such functionality and is thus a plausible invocation."}, {"fname": "get", "evidence": "The target function summary(worker) returns a human-readable summary of a worker's progress, which likely involves aggregating and displaying tasks associated with that worker. The get(self, name) function from ByNameHandler fetches tasks by name from scheduler's task history, which aligns with the summary's need to access task data for display or summarization. This node's functionality potentially supports collecting relevant tasks to build the summary."}, {"fname": "find_all_by_parameters", "evidence": "The find_all_by_parameters method is capable of querying tasks with specific names and parameters from the task history database. Given that the summary function requires a detailed overview of the worker’s executed tasks, including filtering or grouping by parameters, this functionality supports such filtered task lookups and so is probably invoked during the summary creation process."}, {"fname": "find_all_events", "evidence": "The find_all_events function fetches all task events regardless of status, which is useful for comprehensive task tracking. The summary function likely needs to know all tasks and their states/events related to the worker to produce a meaningful summary, making this function a probable dependency."}, {"fname": "find_all_runs", "evidence": "The target function 'summary' aims to produce a human-readable summary of what the worker has done. Retrieving all task records with updates (as done in 'find_all_runs') can provide foundational data about tasks executed by the worker, which is relevant and likely invoked to assemble this summary."}, {"fname": "num_pending_tasks", "evidence": "The target function summary generates a human readable summary of worker tasks, which likely requires getting counts of pending tasks to describe progress or pending work. num_pending_tasks directly provides such counts of PENDING and RUNNING tasks, so it is likely invoked in summary to support summary details about active or incomplete tasks."}, {"fname": "get_active_task_count_for_status", "evidence": "summary needs to provide a summary of worker state potentially filtered by task status. get_active_task_count_for_status provides a way to count tasks by status or overall. This facilitates building aggregated statistics about tasks in different states, which fits well with the summary's purpose."}]}
{"function": "send_email", "target_function_prompt": "def send_email(subject, message, sender, recipients, image_png=None):\n    \"\"\"\n    Decides whether to send notification. Notification is cancelled if there are\n    no recipients or if stdout is onto tty or if in debug mode.\n\n    Dispatches on config value email.method.  Default is 'smtp'.\n    \"\"\"\n", "f1_score": 0.4, "recall": 1.0, "precision": 0.25, "context_size": 8, "target_api_invocations": ["_prefix", "_email_disabled_reason"], "context": [{"fname": "_email_recipients", "evidence": "This utility function prepares the list of email recipients, combining the configured main receiver and any additional recipients. The target function send_email would need to determine recipients before sending, so invoking this function is likely."}, {"fname": "send_email_ses", "evidence": "This function sends email via AWS SES. The target function dispatches email sending based on email.method config which includes 'ses', so this function could be invoked when SES is the configured sending method."}, {"fname": "send_email_sendgrid", "evidence": "This function sends email via SendGrid service. Similarly, as send_email dispatches on email.method config, this function could be invoked for the 'sendgrid' method to send notifications."}, {"fname": "send_email_sns", "evidence": "The target function dispatches sending email notifications based on email.method configuration. This function directly implements sending notifications through AWS SNS, matching the dispatch behavior described in the target function. Therefore, it is likely invoked when email.method is set to 'sns'."}, {"fname": "_prefix", "evidence": "The target function needs to prepare email subjects possibly including a configured prefix for consistency. The _prefix function encapsulates this logic to prepend a subject prefix based on configuration, which fits the behavior expected in constructing the final email subject before sending. Thus, it is likely invoked to format the subject."}, {"fname": "send_email_smtp", "evidence": "The target function dispatches sending emails via different methods, with default 'smtp'. This function implements the SMTP sending mechanism, including building the email, connecting to SMTP, and sending the message. Given the default method and the description, it is very likely to be invoked by the target function when the method is 'smtp'."}, {"fname": "_email_disabled_reason", "evidence": "The target function's docstring states it cancels notification sending if stdout is a TTY or in debug mode or no recipients. The _email_disabled_reason function determines why email sending might be disabled based on email format, force_send, and whether stdout is a TTY, providing exactly the kind of check implied by the target function's docstring. Hence, it is very likely called to decide whether sending proceeds."}, {"fname": "_email_task_failure", "evidence": "The target function send_email decides whether to send notification emails based on config and dispatches the sending method according to email.method config. The node _email_task_failure involves sending an email notification on task failure including formatted traceback, indicating it would need to send an email through send_email or similar methods. Therefore, _email_task_failure might invoke send_email as a lower-level function or participate in the email sending flow. Although the node's snippet doesn't show the full implementation, logically sending an email notification upon failure involves dispatching actual sending, which is the responsibility of send_email."}]}
{"function": "format_task_error", "target_function_prompt": "def format_task_error(headline, task, command, formatted_exception=None):\n    \"\"\"\n    Format a message body for an error email related to a luigi.task.Task\n\n    :param headline: Summary line for the message\n    :param task: `luigi.task.Task` instance where this error occurred\n    :param formatted_exception: optional string showing traceback\n\n    :return: message body\n    \"\"\"\n", "f1_score": 0.10526315789473684, "recall": 1.0, "precision": 0.05555555555555555, "context_size": 19, "target_api_invocations": ["wrap_traceback"], "context": [{"fname": "serialize", "evidence": "Converting values to strings aligns with formatting a message body; the target function likely needs to serialize parameters as strings."}, {"fname": "_get_default", "evidence": "Handles returning a default value when input is None; useful for optional parameters like formatted_exception."}, {"fname": "_get_str_one_parameter", "evidence": "Provides concise formatted strings of task parameters, useful for inclusion in error message bodies related to tasks."}, {"fname": "_serialize_first_param", "evidence": "Serializes the first task parameter to a string, likely needed for including parameter values in the error message."}, {"fname": "_get_str_ranging_multiple_parameters", "evidence": "Generates formatted parameter summaries across multiple tasks, useful for constructing detailed and concise error representations."}, {"fname": "to_str_params", "evidence": "Converts task parameters to a filtered string dictionary, facilitating readable and controlled parameter representation in error messages."}, {"fname": "_get_param_visibilities", "evidence": "The function retrieves serialized visibility states of a Task's parameters, likely useful for including detailed parameter info in the task error message formatted by the target function."}, {"fname": "__repr__", "evidence": "This __repr__ for Task provides a string representation of the task’s attributes, useful for debugging or including task info in error messages, making invocation likely."}, {"fname": "pretty_id", "evidence": "Provides a nicely formatted string of the task identity, likely used by format_task_error to describe the failing task in the email message."}, {"fname": "__repr__", "evidence": "Returns a detailed string representation of the Task instance, which format_task_error might call to identify the task in the error message body."}, {"fname": "__str__", "evidence": "Converts detailed PigJobError information to a string, useful for including error details in the formatted error message."}, {"fname": "__str__", "evidence": "Provides detailed string output for ExternalProgramRunError that includes command and environment info, potentially included in the formatted error email for debugging."}, {"fname": "__str__", "evidence": "Returns the error message string of a HadoopJobError, likely used to generate part of the formatted error message."}, {"fname": "__str__", "evidence": "The overridden __str__ method provides concise string formatting of remote command errors, which the target function may invoke when formatting error messages that include command failures."}, {"fname": "_format_expl", "evidence": "This function formats error explanation strings into HTML or indented plain text, fitting the target function's need to format exception or error tracebacks for the email body."}, {"fname": "_expl_body", "evidence": "This helper function formats a list of error explanations into a single string body, which may be invoked by the target function to build a detailed message body if multiple error explanations exist."}, {"fname": "wrap_traceback", "evidence": "The target function needs to format exception tracebacks into HTML or plain text suitable for email bodies; this function provides the exact functionality for formatting tracebacks based on email format."}, {"fname": "_prefix", "evidence": "_prefix formats an email subject line by adding a configured prefix. Given the target function formats an email message body related to a task error, it is reasonable the implementation might invoke _prefix to obtain a standardized subject prefix or related string parts for eventual email composition."}, {"fname": "_email_task_failure", "evidence": "The target function 'format_task_error' is designed to format a message body for an error email related to a luigi.task.Task. A function like '_email_task_failure', which sends an email notification including error details and task information, would reasonably invoke 'format_task_error' to construct the email body before sending. The node's function name and description align perfectly as it handles failure notifications and error formatting. The provided '_email_task_failure' method references emailing on task failures with formatted tracebacks, which fits exactly with the purpose of formatting task error messages. Therefore, this node is likely invoked during the implementation of the target function."}]}
