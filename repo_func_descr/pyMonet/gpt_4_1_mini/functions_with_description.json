[{"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "__eq__", "line_number": 17, "body": "def __eq__(self, other: object) -> bool:\n        return isinstance(other, Either) and\\\n            self.value == other.value and\\\n            self.is_right() == other.is_right()", "is_method": true, "class_name": "Either", "function_description": "Equality comparison method for Either instances, checking if both the contained value and the side (right or left) match. It enables reliable equivalence testing between Either objects in functional error handling or result contexts."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "case", "line_number": 22, "body": "def case(self, error: Callable[[T], U], success: Callable[[T], U]) -> U:\n        \"\"\"\n        Take 2 functions call only one of then with either value and return her result.\n\n        :params error: function to call when Either is Left\n        :type error: Function(A) -> B\n        :params success: function to call when Either is Right\n        :type success: Function(A) -> B\n        :returns: result of success handler when Eihter is Right, result of error handler when Eihter is Left\n        :rtpye: B\n        \"\"\"\n        if self.is_right():\n            return success(self.value)\n        return error(self.value)", "is_method": true, "class_name": "Either", "function_description": "Method of the Either class that executes one of two provided functions depending on whether the instance represents an error (Left) or success (Right), returning the corresponding function's result. It enables handling different outcomes within a uniform interface."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "ap", "line_number": 37, "body": "def ap(self, applicative):\n        \"\"\"\n        Applies the function inside the Either[A] structure to another applicative type.\n\n        :param applicative: applicative contains function\n        :type applicative: Either[B]\n        :returns: new Either with result of contains function\n        :rtype: Either[A(B)]\n        \"\"\"\n        return applicative.map(self.value)", "is_method": true, "class_name": "Either", "function_description": "Core method of the Either class that applies a function contained in one Either instance to the value inside another, supporting functional programming patterns for composing computations with error handling."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "to_box", "line_number": 48, "body": "def to_box(self):\n        \"\"\"\n        Transform Either to Box.\n\n        :returns: Box monad with previous value\n        :rtype: Box[A]\n        \"\"\"\n        from pymonet.box import Box\n\n        return Box(self.value)", "is_method": true, "class_name": "Either", "function_description": "Converts the current Either instance into a Box monad containing the same value, facilitating interoperability between these monadic types."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "to_try", "line_number": 59, "body": "def to_try(self):\n        \"\"\"\n        Transform Either to Try.\n\n        :returns: resolved Try monad with previous value. Right is resolved successfully, Left not.\n        :rtype: Box[A]\n        \"\"\"\n        from pymonet.monad_try import Try\n\n        return Try(self.value, is_success=self.is_right())", "is_method": true, "class_name": "Either", "function_description": "Converts an Either monad into a Try monad, representing success for Right values and failure for Left values. This facilitates error handling by bridging two functional programming abstractions."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "to_lazy", "line_number": 70, "body": "def to_lazy(self):\n        \"\"\"\n        Transform Either to Try.\n\n        :returns: Lazy monad with function returning previous value\n        :rtype: Lazy[Function() -> A]\n        \"\"\"\n        from pymonet.lazy import Lazy\n\n        return Lazy(lambda: self.value)", "is_method": true, "class_name": "Either", "function_description": "Core method of the Either class that converts its stored value into a Lazy monad, enabling deferred computation by wrapping the value in a function for later execution."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "map", "line_number": 88, "body": "def map(self, _: Callable[[Any], Any]) -> 'Left[T]':\n        \"\"\"\n        Take mapper function and return new instance of Left with the same value.\n\n        :returns: Copy of self\n        :rtype: Left[A]\n        \"\"\"\n        return Left(self.value)", "is_method": true, "class_name": "Left", "function_description": "Utility method of the Left class that ignores the provided mapper function and returns a new Left instance containing the same original value. It maintains Left's immutability while preserving its wrapped value."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "bind", "line_number": 97, "body": "def bind(self, _) -> 'Left[T]':\n        \"\"\"\n        Take mapper function and return value of Left.\n\n        :returns: Stored value\n        :rtype: A\n        \"\"\"\n        return self", "is_method": true, "class_name": "Left", "function_description": "Returns the current Left instance unchanged, ignoring any mapping functions. This supports functional chaining where Left signifies failure or an unaltered state."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "ap", "line_number": 106, "body": "def ap(self, monad):\n        \"\"\"\n        :returns: Copy of self\n        :rtype: Left[A]\n        \"\"\"\n        return Left(self.value)", "is_method": true, "class_name": "Left", "function_description": "Returns a copy of the current Left instance, preserving its value. Useful for maintaining Left values in functional programming contexts without modification."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "is_left", "line_number": 113, "body": "def is_left(self) -> bool:\n        \"\"\"\n        :returns: True\n        :rtype: Boolean\n        \"\"\"\n        return True", "is_method": true, "class_name": "Left", "function_description": "Method of the Left class that always indicates the instance represents a left value by returning True. It provides a simple way to identify this class's left-sided objects in code."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "is_right", "line_number": 120, "body": "def is_right(self) -> bool:\n        \"\"\"\n        :returns: False\n        :rtype: Boolean\n        \"\"\"\n        return False", "is_method": true, "class_name": "Left", "function_description": "This method in the Left class explicitly indicates that an instance is not \"right,\" providing a boolean check that can distinguish Left objects in contexts requiring left/right identification."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "to_maybe", "line_number": 127, "body": "def to_maybe(self):\n        \"\"\"\n        Transform Either to Maybe.\n\n        :returns: Empty Maybe\n        :rtype: Maybe[None]\n        \"\"\"\n        from pymonet.maybe import Maybe\n\n        return Maybe.nothing()", "is_method": true, "class_name": "Left", "function_description": "Converts an Either type instance into an empty Maybe, providing a way to represent the absence of a value within the Maybe context."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "to_validation", "line_number": 138, "body": "def to_validation(self):\n        \"\"\"\n        Transform Box into Validation.\n\n        :returns: failed Validation monad with previous value as error\n        :rtype: Validation[None, [A]]\n        \"\"\"\n        from pymonet.validation import Validation\n\n        return Validation.fail([self.value])", "is_method": true, "class_name": "Left", "function_description": "Transforms the Left instance into a failed Validation monad containing the Left's value as the error, facilitating error handling in validation workflows."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "map", "line_number": 153, "body": "def map(self, mapper: Callable[[T], U]) -> Either[U]:\n        \"\"\"\n        Take mapper function and return new instance of Right with mapped value.\n\n        :param mapper: function to apply on Right value\n        :type mapper: Function(A) -> B\n        :returns: new Right with result of mapper\n        :rtype: Right[B]\n        \"\"\"\n        return Right(mapper(self.value))", "is_method": true, "class_name": "Right", "function_description": "Provides a way to apply a transformation function to the contained value of a Right instance, returning a new Right with the transformed result. Useful for chaining computations in an Either context that represents successful outcomes."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "bind", "line_number": 164, "body": "def bind(self, mapper: Callable[[T], U]) -> U:\n        \"\"\"\n        Take mapper function and returns result of them called with Right value.\n\n        :param mapper: function to apply on Right value\n        :type mapper: Function(A) -> Either[B]\n        :returns: result of mapper\n        :rtype: Either[B]\n        \"\"\"\n        return mapper(self.value)", "is_method": true, "class_name": "Right", "function_description": "Core method of the Right class that applies a given function to its stored value and returns the function's result, enabling transformation within an Either monadic context."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "is_right", "line_number": 175, "body": "def is_right(self) -> bool:\n        \"\"\"\n        :returns: True\n        :rtype: Boolean\n        \"\"\"\n        return True", "is_method": true, "class_name": "Right", "function_description": "This method confirms that an instance represents a \"right\" value, consistently returning True to indicate that status within a bifurcated data structure or computation."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "is_left", "line_number": 182, "body": "def is_left(self) -> bool:\n        \"\"\"\n        :returns: False\n        :rtype: Boolean\n        \"\"\"\n        return False", "is_method": true, "class_name": "Right", "function_description": "Simple method of the Right class that consistently indicates the instance is not a Left type by returning False, supporting type or variant checks in applications using Left-Right distinctions."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "to_maybe", "line_number": 189, "body": "def to_maybe(self):\n        \"\"\"\n        Transform Either to Maybe.\n\n        :returns: Maybe with previous value\n        :rtype: Maybe[A]\n        \"\"\"\n        from pymonet.maybe import Maybe\n\n        return Maybe.just(self.value)", "is_method": true, "class_name": "Right", "function_description": "Utility method of the Right class that converts an Either instance into a Maybe instance containing the same value, facilitating interoperability between these two types."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/either.py", "function": "to_validation", "line_number": 200, "body": "def to_validation(self):\n        \"\"\"\n        Transform Either into Validation.\n\n        :returns: successfull Validation monad with previous value\n        :rtype: Validation[A, []]\n        \"\"\"\n        from pymonet.validation import Validation\n\n        return Validation.success(self.value)", "is_method": true, "class_name": "Right", "function_description": "Utility method of the Right class that converts an Either instance into a successful Validation monad containing the same value. This enables interoperability between two functional programming abstractions."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "__eq__", "line_number": 19, "body": "def __eq__(self, other: object) -> bool:\n        return isinstance(other, Maybe) and \\\n            self.is_nothing == other.is_nothing and \\\n            (self.is_nothing or self.value == other.value)", "is_method": true, "class_name": "Maybe", "function_description": "Equality method for the Maybe class that determines if two instances represent the same state and value, supporting comparisons between optional values. It enables clear equality checks for wrapped or empty values."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "just", "line_number": 25, "body": "def just(cls, value: T) -> 'Maybe[T]':\n        \"\"\"\n        Create not empty maybe.\n\n        :param mapper: value to store in Maybe\n        :type mapper: Any\n        :returns: Maybe[Any]\n        \"\"\"\n        return Maybe(value, False)", "is_method": true, "class_name": "Maybe", "function_description": "Factory method of the Maybe class that creates an instance containing a provided non-empty value, representing the presence of a meaningful result."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "nothing", "line_number": 36, "body": "def nothing(cls) -> 'Maybe[None]':\n        \"\"\"\n        Create empty maybe.\n\n        :returns: Maybe[None]\n        \"\"\"\n        return Maybe(None, True)", "is_method": true, "class_name": "Maybe", "function_description": "Core method in the Maybe class that creates an empty Maybe instance representing the absence of a value, useful for signaling missing or undefined data in a type-safe way."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "map", "line_number": 44, "body": "def map(self, mapper: Callable[[T], U]) -> Union['Maybe[U]', 'Maybe[None]']:\n        \"\"\"\n        If Maybe is empty return new empty Maybe, in other case\n        takes mapper function and returns new instance of Maybe\n        with result of mapper.\n\n        :param mapper: function to call with Maybe value\n        :type mapper: Function(A) -> B\n        :returns: Maybe[B | None]\n        \"\"\"\n        if self.is_nothing:\n            return Maybe.nothing()\n        return Maybe.just(\n            mapper(self.value)\n        )", "is_method": true, "class_name": "Maybe", "function_description": "Provides a way to transform the encapsulated value inside a Maybe instance using a mapper function, returning a new Maybe with the result or an empty Maybe if no value exists. Useful for safely applying transformations without explicit null checks."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "bind", "line_number": 60, "body": "def bind(self, mapper: Callable[[T], 'Maybe[U]']) -> Union['Maybe[U]', 'Maybe[None]']:\n        \"\"\"\n        If Maybe is empty return new empty Maybe, in other case\n        takes mapper function and returns result of mapper.\n\n        :param mapper: function to call with Maybe.value\n        :type mapper: Function(A) -> Maybe[B]\n        :returns: Maybe[B | None]\n        \"\"\"\n        if self.is_nothing:\n            return Maybe.nothing()\n        return mapper(self.value)", "is_method": true, "class_name": "Maybe", "function_description": "Core method of the Maybe class that applies a function returning a Maybe to the contained value if present, propagating emptiness otherwise. It enables chaining of computations that may yield optional results."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "ap", "line_number": 73, "body": "def ap(self, applicative):\n        \"\"\"\n        Applies the function inside the Maybe[A] structure to another applicative type for notempty Maybe.\n        For empty returns copy of itself\n\n        :param applicative: applicative contains function\n        :type applicative: Maybe[B]\n        :returns: new Maybe with result of contains function\n        :rtype: Maybe[A(B) | None]\n        \"\"\"\n        if self.is_nothing:\n            return Maybe.nothing()\n        return applicative.map(self.value)", "is_method": true, "class_name": "Maybe", "function_description": "Core method of the Maybe class that applies a contained function to another Maybe instance, returning a new Maybe with the result or an empty Maybe if the original is empty. It facilitates functional application within the Maybe context."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "filter", "line_number": 87, "body": "def filter(self, filterer: Callable[[T], bool]) -> Union['Maybe[T]', 'Maybe[None]']:\n        \"\"\"\n        If Maybe is empty or filterer returns False return default_value, in other case\n        return new instance of Maybe with the same value.\n\n        :param filterer:\n        :type filterer: Function(A) -> Boolean\n        :returns: copy of self when filterer returns True, in other case empty Maybe\n        :rtype: Maybe[A] | Maybe[None]\n        \"\"\"\n        if self.is_nothing or not filterer(self.value):\n            return Maybe.nothing()\n        return Maybe.just(self.value)", "is_method": true, "class_name": "Maybe", "function_description": "Core method of the Maybe class that conditionally retains its value if a provided predicate returns True, otherwise returns an empty Maybe instance. It enables safe, functional-style filtering of optional values."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "get_or_else", "line_number": 101, "body": "def get_or_else(self, default_value: U) -> Union[T, U]:\n        \"\"\"\n        If Maybe is empty return default_value, in other case.\n\n        :param default_value: value to return if Maybe is empty\n        :type default_value: Any\n        :returns: value of Maybe or default_value\n        :rtype: A\n        \"\"\"\n        if self.is_nothing:\n            return default_value\n        return self.value", "is_method": true, "class_name": "Maybe", "function_description": "Method of the Maybe class that returns the stored value if present, or a provided default if the Maybe is empty, facilitating safe access to optional values without raising errors."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "to_either", "line_number": 114, "body": "def to_either(self):\n        \"\"\"\n        Transform Maybe to Either.\n\n        :returns: Right monad with previous value when Maybe is not empty, in other case Left with None\n        :rtype: Either[A | None]\n        \"\"\"\n        from pymonet.either import Left, Right\n\n        if self.is_nothing:\n            return Left(None)\n        return Right(self.value)", "is_method": true, "class_name": "Maybe", "function_description": "Utility method in the Maybe class that converts its instance into an Either type, returning a Right with its value if present, or a Left with None if empty, facilitating interoperable monad transformations."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "to_box", "line_number": 127, "body": "def to_box(self):\n        \"\"\"\n        Transform Maybe to Box.\n\n        :returns: Box monad with previous value when Maybe is not empty, in other case Box with None\n        :rtype: Box[A | None]\n        \"\"\"\n        from pymonet.box import Box\n\n        if self.is_nothing:\n            return Box(None)\n        return Box(self.value)", "is_method": true, "class_name": "Maybe", "function_description": "Converts a Maybe monad instance into a Box monad, carrying over its value if present or None if empty, facilitating interoperability between these monadic types."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "to_lazy", "line_number": 140, "body": "def to_lazy(self):\n        \"\"\"\n        Transform Maybe to Try.\n\n        :returns: Lazy monad with function returning previous value in other case Left with None\n        :rtype: Lazy[Function() -> (A | None)]\n        \"\"\"\n        from pymonet.lazy import Lazy\n\n        if self.is_nothing:\n            return Lazy(lambda: None)\n        return Lazy(lambda: self.value)", "is_method": true, "class_name": "Maybe", "function_description": "Converts a Maybe instance into a Lazy monad that, when evaluated, yields the stored value or None if empty. This enables deferred computation while preserving the presence or absence of a value."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "to_try", "line_number": 153, "body": "def to_try(self):\n        \"\"\"\n        Transform Maybe to Try.\n\n        :returns: successfully Try with previous value when Maybe is not empty, othercase not successfully Try with None\n        :rtype: Try[A]\n        \"\"\"\n        from pymonet.monad_try import Try\n\n        if self.is_nothing:\n            return Try(None, is_success=False)\n        return Try(self.value, is_success=True)", "is_method": true, "class_name": "Maybe", "function_description": "Provides a conversion from a Maybe monad to a Try monad, producing a successful Try if a value exists or a failed Try with None if empty. Useful for interchanging error-handling abstractions in functional programming."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/maybe.py", "function": "to_validation", "line_number": 166, "body": "def to_validation(self):\n        \"\"\"\n        Transform Maybe into Validation.\n\n        :returns: successfull Validation monad with previous value or None when Maybe is empty\n        :rtype: Validation[A, []]\n        \"\"\"\n        from pymonet.validation import Validation\n\n        if self.is_nothing:\n            return Validation.success(None)\n        return Validation.success(self.value)", "is_method": true, "class_name": "Maybe", "function_description": "Converts a Maybe monad into a Validation monad, producing a successful Validation with the contained value or None if empty. Useful for integrating optional values into validation workflows."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/task.py", "function": "of", "line_number": 15, "body": "def of(cls, value):\n        \"\"\"\n        Return resolved Task with stored value argument.\n\n        :param value: value to store in Task\n        :type value: A\n        :returns: resolved Task\n        :rtype: Task[Function(_, resolve) -> A]\n        \"\"\"\n        return Task(lambda _, resolve: resolve(value))", "is_method": true, "class_name": "Task", "function_description": "Core method of the Task class that creates a resolved Task instance encapsulating a given value. It provides a way to represent completed asynchronous computations with a predefined result."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/task.py", "function": "reject", "line_number": 27, "body": "def reject(cls, value):\n        \"\"\"\n        Return rejected Task with stored value argument.\n\n        :param value: value to store in Task\n        :type value: A\n        :returns: rejected Task\n        :rtype: Task[Function(reject, _) -> A]\n        \"\"\"\n        return Task(lambda reject, _: reject(value))", "is_method": true, "class_name": "Task", "function_description": "Utility class method of Task that creates a rejected Task instance containing a specified value, enabling consistent representation of failure states in asynchronous or functional workflows."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/task.py", "function": "map", "line_number": 38, "body": "def map(self, fn):\n        \"\"\"\n        Take function, store it and call with Task value during calling fork function.\n        Return new Task with result of called.\n\n        :param fn: mapper function\n        :type fn: Function(value) -> B\n        :returns: new Task with mapped resolve attribute\n        :rtype: Task[Function(resolve, reject -> A | B]\n        \"\"\"\n        def result(reject, resolve):\n            return self.fork(\n                lambda arg: reject(arg),\n                lambda arg: resolve(fn(arg))\n            )\n\n        return Task(result)", "is_method": true, "class_name": "Task", "function_description": "Provides a way to transform the result of a Task by applying a given function to its resolved value, returning a new Task representing the mapped outcome for use in asynchronous workflows."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/task.py", "function": "bind", "line_number": 56, "body": "def bind(self, fn):\n        \"\"\"\n        Take function, store it and call with Task value during calling fork function.\n        Return result of called.\n\n        :param fn: mapper function\n        :type fn: Function(value) -> Task[reject, mapped_value]\n        :returns:  new Task with mapper resolve attribute\n        :rtype: Task[reject, mapped_value]\n        \"\"\"\n        def result(reject, resolve):\n            return self.fork(\n                lambda arg: reject(arg),\n                lambda arg: fn(arg).fork(reject, resolve)\n            )\n\n        return Task(result)", "is_method": true, "class_name": "Task", "function_description": "Core method of the Task class that composes asynchronous operations by chaining a function to be applied after the current Task resolves, enabling sequential task execution with proper error propagation."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/task.py", "function": "result", "line_number": 48, "body": "def result(reject, resolve):\n            return self.fork(\n                lambda arg: reject(arg),\n                lambda arg: resolve(fn(arg))\n            )", "is_method": true, "class_name": "Task", "function_description": "Core method of the Task class that chains asynchronous computations by applying a transformation function upon success and forwarding errors, enabling composable task result handling with custom resolution and rejection behaviors."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/task.py", "function": "result", "line_number": 66, "body": "def result(reject, resolve):\n            return self.fork(\n                lambda arg: reject(arg),\n                lambda arg: fn(arg).fork(reject, resolve)\n            )", "is_method": true, "class_name": "Task", "function_description": "Core utility method of the Task class that processes an asynchronous computation's result by chaining rejection handling and further resolution through a provided function, enabling composable and nested task workflows."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "__str__", "line_number": 24, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'Lazy[fn={}, value={}, is_evaluated={}]'.format(self.constructor_fn, self.value, self.is_evaluated)", "is_method": true, "class_name": "Lazy", "function_description": "Provides a string representation of the Lazy instance showing its constructor function, current value, and evaluation status for easier debugging and inspection."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "__eq__", "line_number": 27, "body": "def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Two Lazy are equals where both are evaluated both have the same value and constructor functions.\n        \"\"\"\n        return (\n            isinstance(other, Lazy)\n            and self.is_evaluated == other.is_evaluated\n            and self.value == other.value\n            and self.constructor_fn == other.constructor_fn\n        )", "is_method": true, "class_name": "Lazy", "function_description": "Provides an equality comparison between two Lazy instances by checking if both are evaluated and have identical values and constructor functions. This supports accurate equality checks for Lazy objects."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "of", "line_number": 39, "body": "def of(cls, value: U) -> 'Lazy[T, U]':\n        \"\"\"\n        Returns Lazy with function returning argument.\n\n        :param value: value to return by Lazy constructor_fn\n        :type value: Any\n        :returns: Lazy with function returning argument\n        :rtype: Lazy[Function() -> A]\n        \"\"\"\n        return Lazy(lambda *args: value)", "is_method": true, "class_name": "Lazy", "function_description": "Static method of the Lazy class that creates a Lazy instance wrapping a function which always returns the given value. This enables deferred evaluation of a fixed value within Lazy computations."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "_compute_value", "line_number": 50, "body": "def _compute_value(self, *args):\n        self.is_evaluated = True\n        self.value = self.constructor_fn(*args)\n\n        return self.value", "is_method": true, "class_name": "Lazy", "function_description": "Internal method of the Lazy class that evaluates and caches the result of a constructor function when called, supporting deferred computation and memoization."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "map", "line_number": 56, "body": "def map(self, mapper: Callable[[U], W]) -> 'Lazy[T, W]':\n        \"\"\"\n        Take function Function(A) -> B and returns new Lazy with mapped result of Lazy constructor function.\n        Both mapper end constructor will be called only during calling fold method.\n\n        :param mapper: mapper function\n        :type mapper: Function(A) -> B\n        :returns: Lazy with mapped value\n        :rtype: Lazy[Function() -> B)]\n        \"\"\"\n        return Lazy(lambda *args: mapper(self.constructor_fn(*args)))", "is_method": true, "class_name": "Lazy", "function_description": "Provides a new Lazy instance that applies a transformation function to the original Lazy value, enabling deferred and composable computations evaluated only upon folding."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "ap", "line_number": 68, "body": "def ap(self, applicative):\n        \"\"\"\n        Applies the function inside the Lazy[A] structure to another applicative type for notempty Lazy.\n        For empty returns copy of itself\n\n        :param applicative: applicative contains function\n        :type applicative: Lazy[Function(A) -> B]\n        :returns: new Lazy with result of contains function\n        :rtype: Lazy[B]\n        \"\"\"\n        return Lazy(lambda *args: self.constructor_fn(applicative.get(*args)))", "is_method": true, "class_name": "Lazy", "function_description": "Core method of the Lazy class that applies a function wrapped in another Lazy instance to the current Lazy's value, producing a new Lazy with the result. It supports functional composition in lazy evaluation contexts."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "bind", "line_number": 80, "body": "def bind(self, fn: 'Callable[[U], Lazy[U, W]]') -> 'Lazy[T, W]':\n        \"\"\"\n        Take function and call constructor function passing returned value to fn function.\n\n        It's only way to call function store in Lazy\n        :param fn: Function(constructor_fn) -> B\n        :returns: result od folder function\n        :rtype: B\n        \"\"\"\n        def lambda_fn(*args):\n            computed_value = self._compute_value(*args)\n            return fn(computed_value).constructor_fn\n\n        return Lazy(lambda_fn)", "is_method": true, "class_name": "Lazy", "function_description": "Core method of the Lazy class that composes computations by applying a function to the stored lazy value, enabling chaining of deferred computations while preserving laziness."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "get", "line_number": 95, "body": "def get(self, *args):\n        \"\"\"\n        Evaluate function and memoize her output or return memoized value when function was evaluated.\n\n        :returns: result of function in Lazy\n        :rtype: A\n        \"\"\"\n        if self.is_evaluated:\n            return self.value\n        return self._compute_value(*args)", "is_method": true, "class_name": "Lazy", "function_description": "Core method of the Lazy class that returns a memoized function result or computes and stores it on first invocation, enabling efficient repeated access to expensive computations without redundant evaluations."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "to_box", "line_number": 106, "body": "def to_box(self, *args):\n        \"\"\"\n        Transform Lazy into Box with constructor_fn result.\n\n        :returns: Box monad with constructor_fn result\n        :rtype: Box[A]\n        \"\"\"\n        from pymonet.box import Box\n\n        return Box(self.get(*args))", "is_method": true, "class_name": "Lazy", "function_description": "Utility method in the Lazy class that transforms its contained value by applying the stored function and wraps the result into a Box monad for functional programming usage."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "to_either", "line_number": 117, "body": "def to_either(self, *args):\n        \"\"\"\n        Transform Lazy into Either (Right) with constructor_fn result.\n\n        :returns: Right monad with constructor_fn result\n        :rtype: Right[A]\n        \"\"\"\n        from pymonet.either import Right\n\n        return Right(self.get(*args))", "is_method": true, "class_name": "Lazy", "function_description": "Converts the Lazy instance into a Right Either monad wrapping the evaluated result of Lazy's computation, facilitating functional error handling or chaining in monadic workflows."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "to_maybe", "line_number": 128, "body": "def to_maybe(self, *args):\n        \"\"\"\n        Transform Lazy into not empty Maybe with constructor_fn result.\n\n        :returns: not empty Maybe monad with constructor_fn result\n        :rtype: Maybe[A]\n        \"\"\"\n        from pymonet.maybe import Maybe\n\n        return Maybe.just(self.get(*args))", "is_method": true, "class_name": "Lazy", "function_description": "Utility method of the Lazy class that converts its deferred computation result into a non-empty Maybe monad, enabling safer handling of potentially absent values in functional programming contexts."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "to_try", "line_number": 139, "body": "def to_try(self, *args):\n        \"\"\"\n        Transform Lazy into Try with constructor_fn result.\n        Try will be successful only when constructor_fn not raise anything.\n\n        :returns: Try with constructor_fn result\n        :rtype: Try[A] | Try[Error]\n        \"\"\"\n        from pymonet.monad_try import Try\n\n        return Try.of(self.constructor_fn, *args)", "is_method": true, "class_name": "Lazy", "function_description": "Converts the Lazy instance into a Try monad by executing its constructor function, encapsulating success or failure based on whether the function raises an exception. Useful for safely handling potentially error-throwing computations."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/lazy.py", "function": "to_validation", "line_number": 151, "body": "def to_validation(self, *args):\n        \"\"\"\n        Transform Lazy into successful Validation with constructor_fn result.\n\n        :returns: successfull Validation monad with previous value\n        :rtype: Validation[A, []]\n        \"\"\"\n        from pymonet.validation import Validation\n\n        return Validation.success(self.get(*args))", "is_method": true, "class_name": "Lazy", "function_description": "Converts the Lazy instance into a successful Validation monad containing the evaluated result, facilitating error-safe computation chains in functional programming contexts."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/box.py", "function": "__eq__", "line_number": 20, "body": "def __eq__(self, other: object) -> bool:\n        return isinstance(other, Box) and self.value == other.value", "is_method": true, "class_name": "Box", "function_description": "Checks if another object is a Box instance with the same value, enabling equality comparison between Box objects."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/box.py", "function": "__str__", "line_number": 23, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'Box[value={}]'.format(self.value)", "is_method": true, "class_name": "Box", "function_description": "String representation method of the Box class that returns a formatted description including the box's current value. It provides a human-readable summary useful for debugging and logging."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/box.py", "function": "map", "line_number": 26, "body": "def map(self, mapper: Callable[[T], U]) -> 'Box[U]':\n        \"\"\"\n        Take function (A) -> b and applied this function on current box value and returns new box with mapped value.\n\n        :param mapper: mapper function\n        :type mapper: Function(A) -> B\n        :returns: new box with mapped value\n        :rtype: Box[B]\n        \"\"\"\n        return Box(mapper(self.value))", "is_method": true, "class_name": "Box", "function_description": "Method of the Box class that applies a given function to its current value and returns a new Box containing the transformed result, supporting value transformation within the Box container."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/box.py", "function": "bind", "line_number": 37, "body": "def bind(self, mapper: Callable[[T], U]) -> U:\n        \"\"\"\n        Take function and applied this function on current box value and returns mapped value.\n\n        :param mapper: mapper function\n        :type mapper: Function(A) -> B\n        :returns: new box with mapped value\n        :rtype: B\n        \"\"\"\n        return mapper(self.value)", "is_method": true, "class_name": "Box", "function_description": "Service method of the Box class that applies a provided function to its contained value and returns the resulting mapped value. It enables functional transformations of the Box's content."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/box.py", "function": "ap", "line_number": 48, "body": "def ap(self, applicative):\n        \"\"\"\n        Applies the function inside the Box[A] structure to another applicative type.\n\n        :param applicative: applicative contains function\n        :type applicative: Box[B]\n        :returns: new Box with result of contains function\n        :rtype: Box[A(B)]\n        \"\"\"\n        return applicative.map(self.value)", "is_method": true, "class_name": "Box", "function_description": "Utility method of the Box class that applies a function contained in one Box to the value inside another Box, enabling function application within the Box context for functional programming workflows."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/box.py", "function": "to_maybe", "line_number": 59, "body": "def to_maybe(self):\n        \"\"\"\n        Transform Box into not empty Maybe.\n\n        :returns: non empty Maybe monad with previous value\n        :rtype: Maybe[A]\n        \"\"\"\n        from pymonet.maybe import Maybe\n\n        return Maybe.just(self.value)", "is_method": true, "class_name": "Box", "function_description": "Converts the Box instance into a non-empty Maybe monad containing the Box's current value. This allows seamless integration with functions expecting a Maybe type."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/box.py", "function": "to_either", "line_number": 70, "body": "def to_either(self):\n        \"\"\"\n        Transform Box into Right either.\n\n        :returns: right Either monad with previous value\n        :rtype: Right[A]\n        \"\"\"\n        from pymonet.either import Right\n\n        return Right(self.value)", "is_method": true, "class_name": "Box", "function_description": "Returns the Box object's value wrapped in a Right Either monad, facilitating functional error handling and monadic composition within the Box class context."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/box.py", "function": "to_lazy", "line_number": 81, "body": "def to_lazy(self):\n        \"\"\"\n        Transform Box into Lazy with returning value function.\n\n        :returns: not folded Lazy monad with function returning previous value\n        :rtype: Lazy[Function(() -> A)]\n        \"\"\"\n        from pymonet.lazy import Lazy\n\n        return Lazy(lambda: self.value)", "is_method": true, "class_name": "Box", "function_description": "Utility method of the Box class that converts its stored value into a lazy-evaluated function wrapped in a Lazy monad, enabling deferred computation or retrieval of the value when needed."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/box.py", "function": "to_try", "line_number": 92, "body": "def to_try(self):\n        \"\"\"\n        Transform Box into successfull Try.\n\n        :returns: successfull Try monad with previous value\n        :rtype: Try[A]\n        \"\"\"\n        from pymonet.monad_try import Try\n\n        return Try(self.value, is_success=True)", "is_method": true, "class_name": "Box", "function_description": "Core method of the Box class that converts its current value into a successful Try monad, facilitating functional error handling by encapsulating the value as a successful computation result."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/box.py", "function": "to_validation", "line_number": 103, "body": "def to_validation(self):\n        \"\"\"\n        Transform Box into Validation.\n\n        :returns: successfull Validation monad with previous value\n        :rtype: Validation[A, []]\n        \"\"\"\n        from pymonet.validation import Validation\n\n        return Validation.success(self.value)", "is_method": true, "class_name": "Box", "function_description": "Transforms the Box instance into a successful Validation monad containing the same value, facilitating seamless integration between Box and Validation types for error handling or validation workflows."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/monad_try.py", "function": "__eq__", "line_number": 14, "body": "def __eq__(self, other) -> bool:\n        return isinstance(other, type(self))\\\n            and self.value == other.value\\\n            and self.is_success == other.is_success", "is_method": true, "class_name": "Try", "function_description": "Equality comparison method of the Try class that determines if two instances have the same type, value, and success status, enabling accurate equivalence checks between Try objects."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/monad_try.py", "function": "__str__", "line_number": 19, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'Try[value={}, is_success={}]'.format(self.value, self.is_success)", "is_method": true, "class_name": "Try", "function_description": "Returns a string representation of the Try instance showing its value and success status, facilitating readable output for debugging or logging purposes."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/monad_try.py", "function": "of", "line_number": 23, "body": "def of(cls, fn: Callable, *args):\n        \"\"\"\n        Call argument function with args in try-catch.\n        when function don't raise exception, not successfully when raise.\n\n        :params fn: function to call and store in monad\n        :type fn: Function(*args) -> A\n        :params *args:\n        :type fn: List\n        :retruns: Successfully monad Try when function don't raise exception, not successfully when raise\n        :rtype: Try[A]\n        \"\"\"\n        try:\n            return cls(fn(*args), True)\n        except Exception as e:\n            return cls(e, False)", "is_method": true, "class_name": "Try", "function_description": "Provides a safe execution wrapper that runs a function with given arguments and returns a Try monad indicating success with the result or failure with the caught exception. This enables error handling without interrupting program flow."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/monad_try.py", "function": "map", "line_number": 40, "body": "def map(self, mapper):\n        \"\"\"\n        Take function and applied this function with monad value and returns new monad with mapped value.\n\n        :params mapper: function to apply on monad value\n        :type mapper: Function(A) -> B\n        :returns: for successfully new Try with mapped value, othercase copy of self\n        :rtype: Try[B]\n        \"\"\"\n        if self.is_success:\n            return Try(mapper(self.value), True)\n        return Try(self.value, False)", "is_method": true, "class_name": "Try", "function_description": "Core method of the Try class that applies a given function to the contained success value, returning a new Try instance with the mapped result or preserving the failure state unchanged. It enables functional transformation within the Try monadic context."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/monad_try.py", "function": "bind", "line_number": 53, "body": "def bind(self, binder):\n        \"\"\"\n        Take function and applied this function with monad value and returns function result.\n\n        :params binder: function to apply on monad value\n        :type binder: Function(A) -> Try[B]\n        :returns: for successfully result of binder, othercase copy of self\n        :rtype: Try[B]\n        \"\"\"\n        if self.is_success:\n            return binder(self.value)\n        return self", "is_method": true, "class_name": "Try", "function_description": "Core method of the Try class that applies a provided function to its successful value and returns the function's result, or returns itself unchanged if it represents a failure. It enables chaining operations on wrapped success values safely."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/monad_try.py", "function": "on_success", "line_number": 66, "body": "def on_success(self, success_callback):\n        \"\"\"\n        Call success_callback function with monad value when monad is successfully.\n\n        :params success_callback: function to apply with monad value.\n        :type success_callback: Function(A)\n        :returns: self\n        :rtype: Try[A]\n        \"\"\"\n        if self.is_success:\n            success_callback(self.value)\n        return self", "is_method": true, "class_name": "Try", "function_description": "Utility method of the Try class that applies a given callback function to the stored value only if the monad represents a successful computation, facilitating side effects on success outcomes."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/monad_try.py", "function": "on_fail", "line_number": 79, "body": "def on_fail(self, fail_callback):\n        \"\"\"\n        Call success_callback function with monad value when monad is not successfully.\n\n        :params fail_callback: function to apply with monad value.\n        :type fail_callback: Function(A)\n        :returns: self\n        :rtype: Try[A]\n        \"\"\"\n        if not self.is_success:\n            fail_callback(self.value)\n        return self", "is_method": true, "class_name": "Try", "function_description": "Method of the Try class that invokes a callback function with the stored value when the monad represents a failure, facilitating custom failure handling in chained operations."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/monad_try.py", "function": "filter", "line_number": 92, "body": "def filter(self, filterer):\n        \"\"\"\n        Take filterer function, when monad is successfully call filterer with monad value.\n        When filterer returns True method returns copy of monad, othercase\n        not successfully Try with previous value.\n\n        :params filterer: function to apply on monad value\n        :type filterer: Function(A) -> Boolean\n        :returns: Try with previous value\n        :rtype: Try[A]\n        \"\"\"\n        if self.is_success and filterer(self.value):\n            return Try(self.value, True)\n        return Try(self.value, False)", "is_method": true, "class_name": "Try", "function_description": "Provides a way to conditionally retain a successful Try instance based on a predicate function, returning a new Try with the original value if the predicate passes; otherwise, returns a failed Try preserving the value. Useful for validating Try results within monadic chains."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/monad_try.py", "function": "get", "line_number": 107, "body": "def get(self):\n        \"\"\"\n        Return monad value.\n\n        :returns: monad value\n        :rtype: A\n        \"\"\"\n        return self.value", "is_method": true, "class_name": "Try", "function_description": "Utility method of the Try class that retrieves the underlying value held by the monad, enabling access to the contained result for further processing or inspection."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/monad_try.py", "function": "get_or_else", "line_number": 116, "body": "def get_or_else(self, default_value):\n        \"\"\"\n        Return monad value when is successfully.\n        Othercase return default_value argument.\n\n        :params default_value: value to return when monad is not successfully.\n        :type default_value: B\n        :returns: monad value\n        :rtype: A | B\n        \"\"\"\n        if self.is_success:\n            return self.value\n        return default_value", "is_method": true, "class_name": "Try", "function_description": "Core method of the Try class that returns the contained successful value or a provided default if the operation failed, enabling safe fallback behavior in error-prone computations."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "__eq__", "line_number": 8, "body": "def __eq__(self, other):\n        \"\"\"\n        Two Validations are equals when values and errors lists are equal.\n        \"\"\"\n        return (isinstance(other, Validation) and\n                self.errors == other.errors and\n                self.value == other.value)", "is_method": true, "class_name": "Validation", "function_description": "Method of the Validation class that determines equality by comparing both the value and error lists of two Validation instances for exact match."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "__str__", "line_number": 16, "body": "def __str__(self):  # pragma: no cover\n        if self.is_success():\n            return 'Validation.success[{}]'.format(self.value)\n        return 'Validation.fail[{}, {}]'.format(self.value, self.errors)", "is_method": true, "class_name": "Validation", "function_description": "Provides a readable string representation of a Validation instance, indicating success with its value or failure with corresponding errors. Useful for logging or displaying validation results clearly."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "success", "line_number": 22, "body": "def success(cls, value=None):\n        \"\"\"\n        Returns successful Validation with value and empty errors list.\n\n        :params value: value to store in Validation\n        :type value: A\n        :returns: Successful Validation\n        :rtype: Validation[A, []]\n        \"\"\"\n        return Validation(value, [])", "is_method": true, "class_name": "Validation", "function_description": "Factory method in Validation class that creates a successful Validation instance containing a given value and no errors. It is used to represent and propagate successful validation results."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "fail", "line_number": 34, "body": "def fail(cls, errors=[]):\n        \"\"\"\n        Returns failed Validation with None as value and errors list.\n\n        :params errors: list of errors to store\n        :type value: List[E]\n        :returns: Failed Validation\n        :rtype: Validation[None, List[E]]\n        \"\"\"\n        return Validation(None, errors)", "is_method": true, "class_name": "Validation", "function_description": "Utility method in Validation class that creates a failed validation instance with no value and an optional list of errors to indicate validation failure details."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "is_success", "line_number": 45, "body": "def is_success(self):\n        \"\"\"\n        Returns True when errors list are empty.\n\n        :returns: True for empty errors list\n        :rtype: Boolean\n        \"\"\"\n        return len(self.errors) == 0", "is_method": true, "class_name": "Validation", "function_description": "Checks if the Validation instance has no errors recorded, indicating a successful validation state. Useful for quickly determining whether validation passed without issues."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "is_fail", "line_number": 54, "body": "def is_fail(self):\n        \"\"\"\n        Returns True when errors list are not empty.\n\n        :returns: True for empty errors not list\n        :rtype: Boolean\n        \"\"\"\n        return len(self.errors) != 0", "is_method": true, "class_name": "Validation", "function_description": "Core method of the Validation class that checks if any validation errors exist by verifying whether the errors list is non-empty. It helps determine validation failure status."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "map", "line_number": 63, "body": "def map(self, mapper):\n        \"\"\"\n        Take function (A) -> B and applied this function on current Validation value.\n\n        :param mapper: mapper function\n        :type mapper: Function(A) -> B\n        :returns: new Validation with mapped value and previous errors\n        :rtype: Validation[B, List[E]]\n        \"\"\"\n        return Validation(mapper(self.value), self.errors)", "is_method": true, "class_name": "Validation", "function_description": "Core method of the Validation class that applies a given function to its current value while preserving existing errors, enabling transformation of valid data without losing error context."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "bind", "line_number": 74, "body": "def bind(self, folder):\n        \"\"\"\n        Take function and applied this function on current Validation value and returns folder result.\n\n        :param mapper: mapper function\n        :type mapper: Function(A) -> Validation[B, E]\n        :returns: new Validation with mapped value\n        :rtype: Validation[B, E]\n        \"\"\"\n        return folder(self.value)", "is_method": true, "class_name": "Validation", "function_description": "Core method in the Validation class that applies a provided function to the stored value and returns the function\u2019s result, enabling chaining of validation transformations or computations."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "ap", "line_number": 85, "body": "def ap(self, fn):\n        \"\"\"\n        It takes as a parameter function returning another Validation.\n        Function is called with Validation value and returns new Validation with previous value\n        and concated new and old errors.\n\n        :param monad: monad contains function\n        :type monad: Function(A) -> Validation[Any, List[E]]\n        :returns: new validation with stored errors\n        :rtype: Validation[A, List[E]]\n        \"\"\"\n        return Validation(self.value, self.errors + fn(self.value).errors)", "is_method": true, "class_name": "Validation", "function_description": "Combines the current Validation's value and errors with those from another Validation returned by a provided function, accumulating all errors for comprehensive validation results."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "to_either", "line_number": 98, "body": "def to_either(self):\n        \"\"\"\n        Transform Validation to Either.\n\n        :returns: Right monad with previous value when Validation has no errors, in other case Left with errors list\n        :rtype: Right[A] | Left[E]\n        \"\"\"\n        from pymonet.either import Left, Right\n\n        if self.is_success():\n            return Right(self.value)\n        return Left(self.errors)", "is_method": true, "class_name": "Validation", "function_description": "Method of the Validation class that converts its result into an Either monad, returning a Right with the value if successful or a Left with errors if not, facilitating functional error handling."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "to_maybe", "line_number": 111, "body": "def to_maybe(self):\n        \"\"\"\n        Transform Validation to Maybe.\n\n        :returns: Maybe with Validation Value when Validation has no errors, in other case empty Maybe\n        :rtype: Maybe[A | None]\n        \"\"\"\n        from pymonet.maybe import Maybe\n\n        if self.is_success():\n            return Maybe.just(self.value)\n        return Maybe.nothing()", "is_method": true, "class_name": "Validation", "function_description": "Converts a Validation instance to a Maybe type, returning a Maybe containing the value if successful, or an empty Maybe if there are errors. This enables optional-style handling of validation results."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "to_box", "line_number": 124, "body": "def to_box(self):\n        \"\"\"\n        Transform Validation to Box.\n\n        :returns: Box with Validation value\n        :rtype: Box[A]\n        \"\"\"\n        from pymonet.box import Box\n\n        return Box(self.value)", "is_method": true, "class_name": "Validation", "function_description": "Method of the Validation class that converts a Validation instance into a Box object containing the same value, facilitating interoperability between these two data structures."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "to_lazy", "line_number": 135, "body": "def to_lazy(self):\n        \"\"\"\n        Transform Validation to Try.\n\n        :returns: Lazy monad with function returning Validation value\n        :rtype: Lazy[Function() -> (A | None)]\n        \"\"\"\n        from pymonet.lazy import Lazy\n\n        return Lazy(lambda: self.value)", "is_method": true, "class_name": "Validation", "function_description": "Converts a Validation instance into a lazy computation that defers returning its value until explicitly evaluated, enabling delayed validation result handling within lazy evaluation workflows."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/validation.py", "function": "to_try", "line_number": 146, "body": "def to_try(self):\n        \"\"\"\n        Transform Validation to Try.\n\n        :returns: successfully Try with Validation value value. Try is successful when Validation has no errors\n        :rtype: Try[A]\n        \"\"\"\n        from pymonet.monad_try import Try\n\n        return Try(self.value, is_success=self.is_success())", "is_method": true, "class_name": "Validation", "function_description": "Method of the Validation class that converts a Validation instance into a Try object, representing a successful Try when the Validation contains no errors. Useful for transitioning between validation and error-handling monads in functional workflows."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "curry", "line_number": 9, "body": "def curry(x, args_count=None):\n    \"\"\"\n    In mathematics and computer science, currying is the technique of translating the evaluation of a function.\n    It that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions.\n    each with a single argument.\n    \"\"\"\n    if args_count is None:\n        args_count = x.__code__.co_argcount\n\n    def fn(*args):\n        if len(args) == args_count:\n            return x(*args)\n        return curry(lambda *args1: x(*(args + args1)), args_count - len(args))\n    return fn", "is_method": false, "function_description": "Utility function that transforms a multi-argument function into a nested sequence of single-argument functions, enabling partial application of arguments through currying."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "identity", "line_number": 25, "body": "def identity(value: T) -> T:\n    \"\"\"\n    Return first argument.\n\n    :param value:\n    :type value: Any\n    :returns:\n    :rtype: Any\n    \"\"\"\n    return value", "is_method": false, "function_description": "Utility function that returns its input unchanged, useful as a default or placeholder function in higher-order programming contexts."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "increase", "line_number": 37, "body": "def increase(value: int) -> int:\n    \"\"\"\n    Return increased by 1 argument.\n\n    :param value:\n    :type value: Int\n    :returns:\n    :rtype: Int\n    \"\"\"\n    return value + 1", "is_method": false, "function_description": "Function that returns an integer incremented by one, useful for simple count or index incrementation tasks."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "eq", "line_number": 50, "body": "def eq(value, value1) -> bool:\n    return value == value1", "is_method": false, "function_description": "Utility function that checks if two values are equal, returning a boolean result. It provides a straightforward comparison service for any two inputs."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "curried_map", "line_number": 55, "body": "def curried_map(mapper, collection):\n    return [mapper(item) for item in collection]", "is_method": false, "function_description": "Function that applies a given mapping function to each item in a collection and returns the resulting list. It provides a concise way to transform collections using a specified operation."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "curried_filter", "line_number": 60, "body": "def curried_filter(filterer, collection):\n    return [item for item in collection if filterer(item)]", "is_method": false, "function_description": "Utility function that filters items in a collection based on a provided filtering function, returning only those elements that satisfy the filter condition."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "find", "line_number": 65, "body": "def find(collection: List[T], key: Callable[[T], bool]):\n    \"\"\"\n    Return the first element of the list which matches the keys, or None if no element matches.\n\n    :param collection: collection to search\n    :type collection: List[A]\n    :param key: function to decide witch element should be found\n    :type key: Function(A) -> Boolean\n    :returns: element of collection or None\n    :rtype: A | None\n    \"\"\"\n    for item in collection:\n        if key(item):\n            return item", "is_method": false, "function_description": "Function that searches a list and returns the first element satisfying a given condition, or None if no such element exists. It enables conditional retrieval from collections based on custom criteria."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "compose", "line_number": 81, "body": "def compose(value, *functions):\n    \"\"\"\n    Perform right-to-left function composition.\n\n    :param value: argument of first applied function\n    :type value: Any\n    :param functions: list of functions to applied from right-to-left\n    :type functions: List[Function]\n    :returns: result of all functions\n    :rtype: Any\n    \"\"\"\n    return reduce(\n        lambda current_value, function: function(current_value),\n        functions[::-1],\n        value\n    )", "is_method": false, "function_description": "Function that applies multiple functions in sequence from right to left to an initial value, returning the final result. Useful for composing complex transformations through successive function calls."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "pipe", "line_number": 99, "body": "def pipe(value, *functions):\n    \"\"\"\n    Perform left-to-right function composition.\n\n    :param value: argument of first applied function\n    :type value: Any\n    :param functions: list of functions to applied from left-to-right\n    :type functions: List[Function]\n    :returns: result of all functions\n    :rtype: Any\n    \"\"\"\n    return reduce(\n        lambda current_value, function: function(current_value),\n        functions,\n        value\n    )", "is_method": false, "function_description": "Function that applies a sequence of functions to an initial value in left-to-right order, returning the final transformed result. It enables streamlined chaining of operations for data processing or transformation pipelines."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "cond", "line_number": 117, "body": "def cond(condition_list: List[Tuple[\n    Callable[[T], bool],\n    Callable,\n]]):\n    \"\"\"\n    Function for return function depended on first function argument\n    cond get list of two-item tuples,\n    first is condition_function, second is execute_function.\n    Returns this execute_function witch first condition_function return truly value.\n\n    :param condition_list: list of two-item tuples (condition_function, execute_function)\n    :type condition_list: List[(Function, Function)]\n    :returns: Returns this execute_function witch first condition_function return truly value\n    :rtype: Function\n    \"\"\"\n    def result(*args):\n        for (condition_function, execute_function) in condition_list:\n            if condition_function(*args):\n                return execute_function(*args)\n\n    return result", "is_method": false, "function_description": "Utility function that returns a callable which executes the first function whose associated condition function evaluates to true for given arguments. Useful for conditional function dispatch without explicit branching."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "memoize", "line_number": 140, "body": "def memoize(fn: Callable, key=eq) -> Callable:\n    \"\"\"\n    Create a new function that, when invoked,\n    caches the result of calling fn for a given argument set and returns the result.\n    Subsequent calls to the memoized fn with the same argument set will not result in an additional call to fn;\n    instead, the cached result for that set of arguments will be returned.\n\n    :param fn: function to invoke\n    :type fn: Function(A) -> B\n    :param key: function to decide if result should be taken from cache\n    :type key: Function(A, A) -> Boolean\n    :returns: new function invoking old one\n    :rtype: Function(A) -> B\n    \"\"\"\n    cache: List[Any] = []\n\n    def memoized_fn(argument):\n        cached_result = find(cache, lambda cacheItem: key(cacheItem[0], argument))\n        if cached_result is not None:\n            return cached_result[1]\n        fn_result = fn(argument)\n        cache.append((argument, fn_result))\n\n        return fn_result\n\n    return memoized_fn", "is_method": false, "function_description": "Function that creates a memoized version of a given single-argument function, caching results to avoid repeated computations for identical inputs. It enhances performance for expensive or frequently called functions with repeated arguments."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "fn", "line_number": 18, "body": "def fn(*args):\n        if len(args) == args_count:\n            return x(*args)\n        return curry(lambda *args1: x(*(args + args1)), args_count - len(args))", "is_method": false, "function_description": "This function provides automatic currying for a function by returning partially applied versions until the required number of arguments is met, enabling flexible function invocation with argument accumulation."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/utils.py", "function": "result", "line_number": 132, "body": "def result(*args):\n        for (condition_function, execute_function) in condition_list:\n            if condition_function(*args):\n                return execute_function(*args)", "is_method": false, "function_description": "Utility function that evaluates conditions sequentially and executes the corresponding function for the first true condition, enabling dynamic conditional processing based on input arguments."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "__eq__", "line_number": 18, "body": "def __eq__(self, other: object) -> bool:\n        return isinstance(other, ImmutableList) \\\n            and self.head == other.head\\\n            and self.tail == other.tail\\\n            and self.is_empty == other.is_empty", "is_method": true, "class_name": "ImmutableList", "function_description": "Defines equality comparison for ImmutableList instances by checking if another object has the same type and identical head, tail, and emptiness state. This enables reliable value-based equality checks between ImmutableList objects."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "__str__", "line_number": 24, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'ImmutableList{}'.format(self.to_list())", "is_method": true, "class_name": "ImmutableList", "function_description": "Returns a string representation of the ImmutableList's contents, showing its elements in list format. This aids in readable display or logging of the immutable sequence."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "__add__", "line_number": 27, "body": "def __add__(self, other: 'ImmutableList[T]') -> 'ImmutableList[T]':\n        \"\"\"\n        If Maybe is empty return new empty Maybe, in other case\n        takes mapper function and returns result of mapper.\n\n        :param mapper: function to call with Maybe.value\n        :type mapper: Function(A) -> Maybe[B]\n        :returns: Maybe[B | None]\n        \"\"\"\n        if not isinstance(other, ImmutableList):\n            raise ValueError('ImmutableList: you can not add any other instace than ImmutableList')\n\n        if self.tail is None:\n            return ImmutableList(self.head, other)\n\n        return ImmutableList(\n            self.head,\n            self.tail.__add__(other)\n        )", "is_method": true, "class_name": "ImmutableList", "function_description": "Provides concatenation of two ImmutableList instances, returning a new ImmutableList combining their elements without modifying the originals, enabling safe, immutable list extension."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "__len__", "line_number": 47, "body": "def __len__(self):\n        if self.head is None:\n            return 0\n\n        if self.tail is None:\n            return 1\n\n        return len(self.tail) + 1", "is_method": true, "class_name": "ImmutableList", "function_description": "Returns the number of elements in the ImmutableList, providing its length as an integer."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "of", "line_number": 57, "body": "def of(cls, head: T, *elements) -> 'ImmutableList[T]':\n        if len(elements) == 0:\n            return ImmutableList(head)\n\n        return ImmutableList(\n            head,\n            ImmutableList.of(elements[0], *elements[1:])\n        )", "is_method": true, "class_name": "ImmutableList", "function_description": "Creates an ImmutableList starting with a specified head element followed by any additional elements, enabling convenient construction of immutable linked lists from multiple items."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "empty", "line_number": 67, "body": "def empty(cls):\n        return ImmutableList(is_empty=True)", "is_method": true, "class_name": "ImmutableList", "function_description": "Creates and returns a new ImmutableList instance representing an empty list. This method provides a standardized way to obtain an empty immutable list."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "to_list", "line_number": 71, "body": "def to_list(self):\n        if self.tail is None:\n            return [self.head]\n\n        return [self.head, *self.tail.to_list()]", "is_method": true, "class_name": "ImmutableList", "function_description": "Method of ImmutableList that converts the immutable linked list into a standard Python list, providing an easy way to access all elements sequentially. It enables interoperability with list-based operations or APIs."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "append", "line_number": 77, "body": "def append(self, new_element: T) -> 'ImmutableList[T]':\n        \"\"\"\n        Returns new ImmutableList with elements from previous one\n        and argument value on the end of list\n\n        :param new_element: element to append on the end of list\n        :type fn: A\n        :returns: ImmutableList[A]\n        \"\"\"\n        return self + ImmutableList(new_element)", "is_method": true, "class_name": "ImmutableList", "function_description": "ImmutableList method that returns a new list with an additional element appended, preserving immutability. It enables safe list extension without modifying the original instance."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "unshift", "line_number": 88, "body": "def unshift(self, new_element: T) -> 'ImmutableList[T]':\n        \"\"\"\n        Returns new ImmutableList with argument value on the begin of list\n        and other list elements after it\n\n        :param new_element: element to append on the begin of list\n        :type fn: A\n        :returns: ImmutableList[A]\n        \"\"\"\n        return ImmutableList(new_element) + self", "is_method": true, "class_name": "ImmutableList", "function_description": "ImmutableList method that prepends a new element, returning a new list with the element placed at the beginning while preserving immutability. It enables building updated lists without modifying the original."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "map", "line_number": 99, "body": "def map(self, fn: Callable[[Optional[T]], U]) -> 'ImmutableList[U]':\n        \"\"\"\n        Returns new ImmutableList with each element mapped into\n        result of argument called with each element of ImmutableList\n\n        :param fn: function to call with ImmutableList value\n        :type fn: Function(A) -> B\n        :returns: ImmutableList[B]\n        \"\"\"\n        if self.tail is None:\n            return ImmutableList(fn(self.head))\n\n        return ImmutableList(fn(self.head), self.tail.map(fn))", "is_method": true, "class_name": "ImmutableList", "function_description": "Returns a new ImmutableList where each element is transformed by applying the given function, enabling functional-style element-wise mapping without altering the original list."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "filter", "line_number": 113, "body": "def filter(self, fn: Callable[[Optional[T]], bool]) -> 'ImmutableList[T]':\n        \"\"\"\n        Returns new ImmutableList with only this elements that passed\n        info argument returns True\n\n        :param fn: function to call with ImmutableList value\n        :type fn: Function(A) -> bool\n        :returns: ImmutableList[A]\n        \"\"\"\n        if self.tail is None:\n            if fn(self.head):\n                return ImmutableList(self.head)\n            return ImmutableList(is_empty=True)\n\n        if fn(self.head):\n            return ImmutableList(self.head, self.tail.filter(fn))\n\n        return self.tail.filter(fn)", "is_method": true, "class_name": "ImmutableList", "function_description": "Provides a filtered version of the ImmutableList containing only elements that satisfy the given condition function, enabling selective retrieval without modifying the original list."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "find", "line_number": 132, "body": "def find(self, fn: Callable[[Optional[T]], bool]) -> Optional[T]:\n        \"\"\"\n        Returns first element of ImmutableList that passed\n        info argument returns True\n\n        :param fn: function to call with ImmutableList value\n        :type fn: Function(A) -> bool\n        :returns: A\n        \"\"\"\n        if self.head is None:\n            return None\n\n        if self.tail is None:\n            return self.head if fn(self.head) else None\n\n        if fn(self.head):\n            return self.head\n\n        return self.tail.find(fn)", "is_method": true, "class_name": "ImmutableList", "function_description": "Core method of ImmutableList that returns the first element satisfying a given condition, enabling efficient element retrieval based on custom predicates within an immutable linked structure."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/immutable_list.py", "function": "reduce", "line_number": 152, "body": "def reduce(self, fn: Callable[[U, T], U], acc: U) -> U:\n        \"\"\"\n        Method executes a reducer function\n        on each element of the array, resulting in a single output value.\n\n        :param fn: function to call with ImmutableList value\n        :type fn: Function(A, B) -> A\n        :returns: A\n        \"\"\"\n        if self.head is None:\n            return acc\n\n        if self.tail is None:\n            return fn(self.head, acc)\n\n        \n        return self.tail.reduce(fn, fn(acc, self.head))", "is_method": true, "class_name": "ImmutableList", "function_description": "Provides a way to aggregate or combine all elements of an ImmutableList into a single cumulative value using a specified reducer function and initial accumulator. Useful for calculating summaries or transformations over the list's items."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "__eq__", "line_number": 13, "body": "def __eq__(self, other) -> bool:\n        return self.value == other.value", "is_method": true, "class_name": "Semigroup", "function_description": "Compares two Semigroup instances for equality based on their stored values. This enables direct comparison of semigroup objects in code."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "fold", "line_number": 16, "body": "def fold(self, fn):\n        return fn(self.value)", "is_method": true, "class_name": "Semigroup", "function_description": "Core utility method of the Semigroup class that applies a provided function to its stored value, enabling transformation or reduction of the value through function application."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "neutral", "line_number": 20, "body": "def neutral(cls):\n        return cls(cls.neutral_element)", "is_method": true, "class_name": "Semigroup", "function_description": "Creates and returns the neutral (identity) element of the semigroup, enabling operations that require an identity value associated with the algebraic structure."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "__str__", "line_number": 31, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'Sum[value={}]'.format(self.value)", "is_method": true, "class_name": "Sum", "function_description": "String representation method of the Sum class that returns a formatted string displaying the current stored value. It enables clear and readable output for instances of the Sum class."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "concat", "line_number": 34, "body": "def concat(self, semigroup: 'Sum') -> 'Sum':\n        \"\"\"\n        :param semigroup: other semigroup to concat\n        :type semigroup: Sum[B]\n        :returns: new Sum with sum of concat semigroups values\n        :rtype: Sum[A]\n        \"\"\"\n        return Sum(self.value + semigroup.value)", "is_method": true, "class_name": "Sum", "function_description": "Concatenates two Sum instances by returning a new Sum with the combined value of both, supporting additive aggregation of semigroup values."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "__str__", "line_number": 51, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'All[value={}]'.format(self.value)", "is_method": true, "class_name": "All", "function_description": "Returns a string representation of the All class instance showing its internal value, useful for readable output and debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "concat", "line_number": 54, "body": "def concat(self, semigroup: 'All') -> 'All':\n        \"\"\"\n        :param semigroup: other semigroup to concat\n        :type semigroup: All[B]\n        :returns: new All with last truly value or first falsy\n        :rtype: All[A | B]\n        \"\"\"\n        return All(self.value and semigroup.value)", "is_method": true, "class_name": "All", "function_description": "Concatenates two All semigroup instances by combining their boolean values using logical AND, producing a new All instance that reflects the combined truthiness. Useful for aggregating multiple boolean conditions in a semigroup context."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "__str__", "line_number": 71, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'One[value={}]'.format(self.value)", "is_method": true, "class_name": "One", "function_description": "Provides a string representation of an instance of the One class, displaying its stored value for readability and debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "concat", "line_number": 74, "body": "def concat(self, semigroup):\n        \"\"\"\n        :param semigroup: other semigroup to concat\n        :type semigroup: One[B]\n        :returns: new One with first truly value or last falsy\n        :rtype: One[A | B]\n        \"\"\"\n        return One(self.value or semigroup.value)", "is_method": true, "class_name": "One", "function_description": "Utility method in the One class that combines two One instances by returning a new One containing the first truthy value or the last falsy value. Useful for prioritized value selection in chained operations."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "__str__", "line_number": 89, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'Fist[value={}]'.format(self.value)", "is_method": true, "class_name": "First", "function_description": "String representation method of the First class that returns a formatted string displaying the stored value. It provides a readable summary of the instance\u2019s content for debugging or logging."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "concat", "line_number": 92, "body": "def concat(self, semigroup):\n        \"\"\"\n        :param semigroup: other semigroup to concat\n        :type semigroup: First[B]\n        :returns: new First with first value\n        :rtype: First[A]\n        \"\"\"\n        return First(self.value)", "is_method": true, "class_name": "First", "function_description": "Returns a new First instance preserving the original value, effectively ignoring the provided semigroup. This method supports combining First semigroups by retaining the first value in the sequence."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "__str__", "line_number": 107, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'Last[value={}]'.format(self.value)", "is_method": true, "class_name": "Last", "function_description": "String representation method of the Last class that returns a formatted string displaying the stored value for easier readability and debugging."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "concat", "line_number": 110, "body": "def concat(self, semigroup):\n        \"\"\"\n        :param semigroup: other semigroup to concat\n        :type semigroup: Last[B]\n        :returns: new Last with last value\n        :rtype: Last[A]\n        \"\"\"\n        return Last(semigroup.value)", "is_method": true, "class_name": "Last", "function_description": "Concatenates with another Last semigroup by returning a new Last containing the latter's value, effectively preserving the most recent element. This supports combining Last instances by prioritizing the last provided value."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "__str__", "line_number": 125, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'Map[value={}]'.format(self.value)", "is_method": true, "class_name": "Map", "function_description": "Returns a string representation of the Map object displaying its current value for easy readability and debugging."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "concat", "line_number": 128, "body": "def concat(self, semigroup):\n        \"\"\"\n        :param semigroup: other semigroup to concat\n        :type semigroup: Map[B]\n        :returns: new Map with concated all values\n        :rtype: Map[A]\n        \"\"\"\n        return Map(\n            {key: value.concat(semigroup.value[key]) for key, value in self.value.items()}\n        )", "is_method": true, "class_name": "Map", "function_description": "Concatenates two Map objects by merging their corresponding values using each value's concat method, returning a new Map with combined entries. This function supports aggregation of data stored in Map instances with semigroup behavior."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "__str__", "line_number": 147, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'Max[value={}]'.format(self.value)", "is_method": true, "class_name": "Max", "function_description": "Returns a string representation of the Max instance showing its current value, useful for readable display or debugging of Max objects."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "concat", "line_number": 150, "body": "def concat(self, semigroup):\n        \"\"\"\n        :param semigroup: other semigroup to concat\n        :type semigroup: Max[B]\n        :returns: new Max with largest value\n        :rtype: Max[A | B]\n        \"\"\"\n        return Max(self.value if self.value > semigroup.value else semigroup.value)", "is_method": true, "class_name": "Max", "function_description": "Utility method of the Max class that combines two Max instances and returns a new one holding the larger of their values, supporting value comparison and aggregation within a semigroup context."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "__str__", "line_number": 167, "body": "def __str__(self) -> str:  # pragma: no cover\n        return 'Min[value={}]'.format(self.value)", "is_method": true, "class_name": "Min", "function_description": "Returns a string representation of the Min instance showing its stored value, useful for readable display and debugging."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/pymonet/semigroups.py", "function": "concat", "line_number": 170, "body": "def concat(self, semigroup):\n        \"\"\"\n        :param semigroup: other semigroup to concat\n        :type semigroup: Min[B]\n        :returns: new Min with smallest value\n        :rtype: Min[A | B]\n        \"\"\"\n        return Min(self.value if self.value <= semigroup.value else semigroup.value)", "is_method": true, "class_name": "Min", "function_description": "Core method of the Min class that combines two Min instances, returning a new Min holding the smallest value between them. It enables value comparison and aggregation within semigroup operations."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_law_tester.py", "function": "_assert", "line_number": 13, "body": "def _assert(self, x, y):\n        assert self.get_fn(x) == self.get_fn(y)", "is_method": true, "class_name": "MonadLawTester", "function_description": "Internal method of MonadLawTester that verifies two inputs satisfy a monadic law by asserting their transformed values are equal."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_law_tester.py", "function": "associativity_test", "line_number": 16, "body": "def associativity_test(self):\n        x = self.monad(self.value).bind(self.mapper1).bind(self.mapper2)\n        y = self.monad(self.value).bind(lambda value: self.mapper2(value).bind(self.mapper1))\n\n        self._assert(x, y)", "is_method": true, "class_name": "MonadLawTester", "function_description": "Provides a test to verify the associativity law for the monad instance, ensuring that sequential binds behave consistently and satisfy the monad's associativity property within the MonadLawTester context."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_law_tester.py", "function": "left_unit_test", "line_number": 22, "body": "def left_unit_test(self):\n        self._assert(self.monad(self.value).bind(self.mapper1), self.mapper1(self.value))", "is_method": true, "class_name": "MonadLawTester", "function_description": "Core testing method of the MonadLawTester class that verifies the left unit law of monads, ensuring that binding a monadic value with a function is equivalent to applying the function directly."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_law_tester.py", "function": "right_unit_test", "line_number": 25, "body": "def right_unit_test(self):\n        self._assert(self.monad(self.value).bind(lambda value: self.monad(value)), self.monad(self.value))", "is_method": true, "class_name": "MonadLawTester", "function_description": "Tests the right unit law for a monad by verifying that binding a monadic value to a function that returns the same monad is equivalent to the original monadic value."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_law_tester.py", "function": "test", "line_number": 28, "body": "def test(self, run_associativity_law_test=True, run_left_law_test=True, run_right_law_test=True):\n        if run_associativity_law_test:\n            self.associativity_test()\n        if run_left_law_test:\n            self.left_unit_test()\n        if run_right_law_test:\n            self.right_unit_test()", "is_method": true, "class_name": "MonadLawTester", "function_description": "Core method of the MonadLawTester class that runs specified monad law tests\u2014associativity, left unit, and right unit\u2014based on given flags, facilitating comprehensive validation of monadic behavior."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/semigroup_law_tester.py", "function": "associativity_test", "line_number": 10, "body": "def associativity_test(self):\n\n        x = self.semigroup(self.value1)\\\n                .concat(self.semigroup(self.value2))\\\n                .concat(self.semigroup(self.value3))\n\n        y = self.semigroup(self.value1).concat(\n                self.semigroup(self.value2).concat(self.semigroup(self.value3))\n            )\n\n        assert x == y == self.result", "is_method": true, "class_name": "SemigroupLawTester", "function_description": "Core method of SemigroupLawTester that verifies the associativity law of a semigroup by asserting that different groupings of concatenations yield the same result. This ensures conformity to a fundamental semigroup property for given test values."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/semigroup_law_tester.py", "function": "test", "line_number": 22, "body": "def test(self):\n        self.associativity_test()", "is_method": true, "class_name": "SemigroupLawTester", "function_description": "Core method of the SemigroupLawTester class that runs the associativity test to verify if the semigroup law holds."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monoid_law_tester.py", "function": "left_identity_test", "line_number": 7, "body": "def left_identity_test(self):\n        monoid = self.monoid(self.value)\n        assert monoid.concat(monoid.neutral()) == monoid", "is_method": true, "class_name": "MonoidLawTester", "function_description": "Core utility of MonoidLawTester that verifies the monoid's left identity law by asserting concatenation with the neutral element returns the original monoid instance. It ensures the monoid behavior correctness in algebraic structures."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monoid_law_tester.py", "function": "right_identity_test", "line_number": 11, "body": "def right_identity_test(self):\n        monoid = self.monoid(self.value)\n        assert monoid.neutral().concat(monoid) == monoid", "is_method": true, "class_name": "MonoidLawTester", "function_description": "Utility method in MonoidLawTester that verifies the right identity property of a monoid by asserting the monoid combined with its neutral element on the left remains unchanged."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monoid_law_tester.py", "function": "test", "line_number": 15, "body": "def test(self):\n        self.left_identity_test()\n        self.right_identity_test()", "is_method": true, "class_name": "MonoidLawTester", "function_description": "Runs tests to verify both left and right identity properties in a monoid, ensuring the monoid law compliance. It provides a simple interface to validate key algebraic structure requirements."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/applicative_law_tester.py", "function": "_assert", "line_number": 13, "body": "def _assert(self, x, y):\n        assert self.get_fn(x) == self.get_fn(y)", "is_method": true, "class_name": "ApplicativeLawTester", "function_description": "Private helper method of the ApplicativeLawTester class that asserts two inputs produce the same result when passed through a specific function, supporting validation of function consistency."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/applicative_law_tester.py", "function": "identity_test", "line_number": 16, "body": "def identity_test(self):\n        x = self.applicative(identity).ap(self.applicative(self.value))\n        y = self.applicative(self.value)\n\n        self._assert(x, y)", "is_method": true, "class_name": "ApplicativeLawTester", "function_description": "Core method of ApplicativeLawTester that verifies the identity law for applicatives by checking if applying the identity function preserves the original value. It ensures applicative implementations behave according to functional programming laws."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/applicative_law_tester.py", "function": "composition_test", "line_number": 22, "body": "def composition_test(self):\n        def lambda_fn(fn1):\n            return lambda fn2: lambda value: fn1(fn2(value))\n\n        x = self.applicative(lambda_fn)\\\n                .ap(self.applicative(self.mapper1))\\\n                .ap(self.applicative(self.mapper2))\\\n                .ap(self.applicative(self.value))\n        y = self.applicative(self.mapper1).ap(\n            self.applicative(self.mapper2).ap(self.applicative(self.value))\n            )\n\n        self._assert(x, y)", "is_method": true, "class_name": "ApplicativeLawTester", "function_description": "Core method of ApplicativeLawTester that verifies the applicative composition law by testing function composition equivalence within the applicative context, ensuring the applicative instance complies with expected composition behavior."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/applicative_law_tester.py", "function": "homomorphism_test", "line_number": 36, "body": "def homomorphism_test(self):\n        x = self.applicative(self.mapper1).ap(self.applicative(self.value))\n        y = self.applicative(\n            self.mapper1(self.value)\n        )\n        self._assert(x, y)", "is_method": true, "class_name": "ApplicativeLawTester", "function_description": "Core method of ApplicativeLawTester that verifies the homomorphism law by comparing the application of a mapped function within an applicative context to the direct application of the function's result, ensuring correct applicative behavior."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/applicative_law_tester.py", "function": "interchange_test", "line_number": 43, "body": "def interchange_test(self):\n        x = self.applicative(self.mapper1).ap(self.applicative(self.value))\n        y = self.applicative(lambda fn: fn(self.value)).ap(\n            self.applicative(self.mapper1)\n        )\n        self._assert(x, y)", "is_method": true, "class_name": "ApplicativeLawTester", "function_description": "Checks whether the applicative functor satisfies the interchange law by comparing two equivalent applicative expressions, ensuring correctness of its implementation."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/applicative_law_tester.py", "function": "test", "line_number": 50, "body": "def test(self):\n        self.identity_test()\n        self.composition_test()\n        self.homomorphism_test()\n        self.interchange_test()", "is_method": true, "class_name": "ApplicativeLawTester", "function_description": "Core method of the ApplicativeLawTester class that runs a suite of tests verifying fundamental applicative functor laws, ensuring the correctness of applicative implementations."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/applicative_law_tester.py", "function": "lambda_fn", "line_number": 23, "body": "def lambda_fn(fn1):\n            return lambda fn2: lambda value: fn1(fn2(value))", "is_method": true, "class_name": "ApplicativeLawTester", "function_description": "Utility method in ApplicativeLawTester that constructs a nested lambda function to compose two functions and apply them sequentially to a value, facilitating functional composition testing scenarios."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_transform_tester.py", "function": "to_box_test", "line_number": 15, "body": "def to_box_test(self):\n        assert self.monad(self.value).to_box() == Box(self.value)", "is_method": true, "class_name": "MonadTransformTester", "function_description": "Test method in MonadTransformTester that verifies whether wrapping a value with the monad and converting it to a box produces the expected boxed value."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_transform_tester.py", "function": "to_maybe_test", "line_number": 18, "body": "def to_maybe_test(self):\n        if self.is_fail:\n            assert self.monad(self.value).to_maybe() == Maybe.nothing()\n        else:\n            assert self.monad(self.value).to_maybe() == Maybe.just(self.value)", "is_method": true, "class_name": "MonadTransformTester", "function_description": "This method verifies that a monad correctly converts its value to an optional (Maybe) type, asserting failure or success cases accordingly. It provides a test utility to validate monad-to-Maybe transformations within the MonadTransformTester class."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_transform_tester.py", "function": "to_either_test", "line_number": 24, "body": "def to_either_test(self):\n        if self.is_fail:\n            assert self.monad(self.value).to_either() == Left(self.value)\n        else:\n            assert self.monad(self.value).to_either() == Right(self.value)", "is_method": true, "class_name": "MonadTransformTester", "function_description": "Testing method that verifies if the monad correctly converts its value to an Either type, producing Left on failure and Right on success. It ensures the monad's to_either behavior aligns with expected success or failure states."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_transform_tester.py", "function": "to_lazy_test", "line_number": 30, "body": "def to_lazy_test(self):\n        assert self.monad(self.value).to_lazy().get() == self.value", "is_method": true, "class_name": "MonadTransformTester", "function_description": "This function verifies that converting a value to a lazy monadic form and retrieving it returns the original value, serving as a correctness check for the monad's lazy behavior. It supports testing the monad transformation consistency."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_transform_tester.py", "function": "to_try_test", "line_number": 33, "body": "def to_try_test(self):\n        assert self.monad(self.value).to_try() == Try(self.value, is_success=not self.is_fail)", "is_method": true, "class_name": "MonadTransformTester", "function_description": "Test method in MonadTransformTester that verifies if converting a monad-wrapped value to a Try object correctly reflects its success or failure state."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_transform_tester.py", "function": "to_validation_test", "line_number": 36, "body": "def to_validation_test(self):\n        if self.is_fail:\n            assert self.monad(self.value).to_validation() == Validation.fail([self.value])\n        else:\n            assert self.monad(self.value).to_validation() == Validation.success(self.value)", "is_method": true, "class_name": "MonadTransformTester", "function_description": "Test method in MonadTransformTester that verifies the monad's conversion to a Validation object correctly reflects failure or success states based on its current value. It ensures the monad's validation transformation behaves as expected."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/monad_transform_tester.py", "function": "test", "line_number": 42, "body": "def test(\n        self,\n        run_to_box_test=True,\n        run_to_maybe_test=True,\n        run_to_either_test=True,\n        run_to_lazy_test=True,\n        run_to_try_test=True,\n        run_to_validation_test=True\n    ):\n        if run_to_box_test:\n            self.to_box_test()\n        if run_to_maybe_test:\n            self.to_maybe_test()\n        if run_to_either_test:\n            self.to_either_test()\n        if run_to_lazy_test:\n            self.to_lazy_test()\n        if run_to_try_test:\n            self.to_try_test()\n        if run_to_validation_test:\n            self.to_validation_test()", "is_method": true, "class_name": "MonadTransformTester", "function_description": "Utility method in MonadTransformTester that conditionally runs a series of monad transformation tests based on provided flags, facilitating comprehensive verification of different monadic behaviors in one call."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/functor_law_tester.py", "function": "_assert", "line_number": 12, "body": "def _assert(self, x, y):\n        assert self.get_fn(x) == self.get_fn(y)", "is_method": true, "class_name": "FunctorLawTester", "function_description": "Private method of FunctorLawTester that asserts two inputs produce equal results when passed through the functor\u2019s function, enabling verification of functor laws and consistency checks."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/functor_law_tester.py", "function": "identity_law_test", "line_number": 15, "body": "def identity_law_test(self):\n        x = self.functor.map(identity)\n        y = self.functor\n\n        self._assert(x, y)", "is_method": true, "class_name": "FunctorLawTester", "function_description": "Tests whether applying the identity function via the functor\u2019s map method preserves the functor\u2019s original structure, ensuring compliance with the identity functor law."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/functor_law_tester.py", "function": "composition_law_test", "line_number": 21, "body": "def composition_law_test(self):\n        mapped_functor1 = self.functor.map(self.mapper1).map(self.mapper2)\n        mapped_fuctor2 = self.functor.map(lambda value: self.mapper2(self.mapper1(value)))\n        self._assert(mapped_functor1, mapped_fuctor2)", "is_method": true, "class_name": "FunctorLawTester", "function_description": "Core method of FunctorLawTester that verifies the composition law of functors by ensuring two different mapping sequences produce equivalent results, validating functor behavior for functional correctness."}, {"file": "./dataset/RepoExec/test-apps/pyMonet/testers/functor_law_tester.py", "function": "test", "line_number": 26, "body": "def test(self, run_identity_law_test=True, run_composition_law_test=True):\n        if run_identity_law_test:\n            self.identity_law_test()\n        if run_composition_law_test:\n            self.composition_law_test()", "is_method": true, "class_name": "FunctorLawTester", "function_description": "Utility method in FunctorLawTester that executes identity and composition law tests for functors, allowing selective verification of these fundamental properties in functional programming contexts."}]