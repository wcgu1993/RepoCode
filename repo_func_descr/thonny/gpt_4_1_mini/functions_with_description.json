[{"file": "./dataset/RepoExec/test-apps/thonny/setup.py", "function": "recursive_files", "line_number": 6, "body": "def recursive_files(directory):\n    paths = []\n    for (path, _, filenames) in os.walk(directory):\n        for filename in filenames:\n            paths.append(os.path.join('..', path, filename))\n    return paths", "is_method": false, "function_description": "Function that recursively collects and returns relative file paths from a directory and all its subdirectories, facilitating comprehensive file listings for processing or analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "which", "line_number": 18, "body": "def which(cmd, mode=os.F_OK | os.X_OK, path=None):\n    \"\"\"Given a command, mode, and a PATH string, return the path which\n    conforms to the given mode on the PATH, or None if there is no such\n    file.\n\n    `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n    of os.environ.get(\"PATH\"), or can be overridden with a custom search\n    path.\n    (Copied from Python 3.5 shutil)\n    \"\"\"\n    # Check that a given file can be accessed with the correct mode.\n    # Additionally check that `file` is not a directory, as on Windows\n    # directories pass the os.access check.\n    def _access_check(fn, mode):\n        return os.path.exists(fn) and os.access(fn, mode) and not os.path.isdir(fn)\n\n    # If we're given a path with a directory part, look it up directly rather\n    # than referring to PATH directories. This includes checking relative to the\n    # current directory, e.g. ./script\n    if os.path.dirname(cmd):\n        if _access_check(cmd, mode):\n            return cmd\n        return None\n\n    if path is None:\n        path = os.environ.get(\"PATH\", os.defpath)\n    if not path:\n        return None\n    path = path.split(os.pathsep)\n\n    files = [cmd]\n\n    seen = set()\n    for dir_ in path:\n        normdir = os.path.normcase(dir_)\n        if not normdir in seen:\n            seen.add(normdir)\n            for thefile in files:\n                name = os.path.join(dir_, thefile)\n                if _access_check(name, mode):\n                    return name\n    return None", "is_method": false, "function_description": "Function that locates an executable file on the system PATH (or custom path) matching a given command name and access mode, returning its full path or None if not found. Useful for verifying command availability before execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "create_launcher", "line_number": 62, "body": "def create_launcher(source_filename, target_filename, replacements={}):\n    target_dir = os.path.dirname(target_filename)\n    if not os.path.exists(target_dir):\n        os.makedirs(target_dir)\n\n    with open(source_filename) as f:\n        content = f.read()\n\n    with open(target_filename, mode=\"w\") as f:\n        for from_str in replacements:\n            to_str = replacements[from_str]\n            content = content.replace(from_str, to_str)\n        f.write(content)\n\n    # Seems that even desktop files have to be executable\n    # https://help.ubuntu.com/community/UnityLaunchersAndDesktopFiles\n    os.chmod(target_filename, 0o755)", "is_method": false, "function_description": "Function that creates a launcher script by copying a source file to a target location, applying string replacements, and setting executable permissions. Useful for dynamically generating customized executable launchers."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "try_to_refresh_desktop_and_menus", "line_number": 81, "body": "def try_to_refresh_desktop_and_menus(menu_dir):\n    \"\"\"In KDE, the .destop files are not taken into account immediately\"\"\"\n    for cmd in [\"kbuildsycoca5\", \"kbuildsycoca4\", \"kbuildsycoca\"]:\n        if which(cmd):\n            subprocess.call([cmd])\n            break\n\n    udd = \"update-desktop-database\"\n    if which(udd):\n        subprocess.call([udd, menu_dir])", "is_method": false, "function_description": "This function refreshes KDE desktop and menu caches by running available system commands, ensuring that changes to desktop files and menu directories are immediately recognized. It is useful for updating the user interface after modifying related files."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "print_task", "line_number": 106, "body": "def print_task(desc):\n    print((desc + \" \").ljust(70, \".\") + \" \", end=\"\")", "is_method": false, "function_description": "Function that formats and prints a task description padded with dots to a fixed width, useful for consistent console logging or status updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "get_desktop_path", "line_number": 110, "body": "def get_desktop_path():\n    try:\n        return subprocess.check_output([\"xdg-user-dir\", \"DESKTOP\"]).strip().decode()\n    except:\n        return os.path.expanduser(\"~/Desktop\")", "is_method": false, "function_description": "Function that returns the current user's desktop directory path on Linux systems, using system utilities when available and falling back to a default path otherwise. Useful for applications needing to locate the user's desktop reliably."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "_access_check", "line_number": 31, "body": "def _access_check(fn, mode):\n        return os.path.exists(fn) and os.access(fn, mode) and not os.path.isdir(fn)", "is_method": false, "function_description": "Utility function that verifies a file's existence, accessibility with a specified mode, and ensures it is not a directory. It enables safe checks before file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "get_statement_of_position", "line_number": 10, "body": "def get_statement_of_position(node, pos):\n    import jedi.parser_utils\n\n    func = getattr(\n        jedi.parser_utils, \"get_statement_of_position\", _copy_of_get_statement_of_position\n    )\n    return func(node, pos)", "is_method": false, "function_description": "This function returns the statement node corresponding to a given position within a syntax tree node, facilitating precise code analysis or manipulation at specific positions in the source code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "_copy_of_get_statement_of_position", "line_number": 20, "body": "def _copy_of_get_statement_of_position(node, pos):\n    # https://github.com/davidhalter/jedi/commit/9f3a2f93c48eda24e2dcc25e54eb7cc10aa73848\n    from parso.python import tree\n\n    for c in node.children:\n        if c.start_pos <= pos <= c.end_pos:\n            if (\n                c.type\n                not in (\n                    \"decorated\",\n                    \"simple_stmt\",\n                    \"suite\",\n                    \"async_stmt\",\n                    \"async_funcdef\",\n                )\n                and not isinstance(c, (tree.Flow, tree.ClassOrFunc))\n            ):\n                return c\n            else:\n                try:\n                    return _copy_of_get_statement_of_position(c, pos)\n                except AttributeError:\n                    pass  # Must be a non-scope\n    return None", "is_method": false, "function_description": "Utility function that finds and returns the smallest syntax node at a given position within a parse tree, skipping certain statement and scope types for precise code analysis or manipulation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "parse_source", "line_number": 46, "body": "def parse_source(source):\n    import parso\n\n    return parso.parse(source)", "is_method": false, "function_description": "Function that parses Python source code into an abstract syntax tree representation, enabling further analysis or manipulation of the code structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "get_script_completions", "line_number": 52, "body": "def get_script_completions(source: str, row: int, column: int, filename: str, sys_path=None):\n    import jedi\n\n    if _using_older_jedi(jedi):\n        try:\n            script = jedi.Script(source, row, column, filename, sys_path=sys_path)\n        except Exception as e:\n            logger.info(\"Could not get completions with given sys_path\", exc_info=e)\n            script = jedi.Script(source, row, column, filename)\n\n        completions = script.completions()\n    else:\n        script = jedi.Script(code=source, path=filename, project=_get_new_jedi_project(sys_path))\n        completions = script.complete(line=row, column=column)\n\n    return _tweak_completions(completions)", "is_method": false, "function_description": "Function that provides code completion suggestions at a specific position in a source file, supporting different Jedi versions and customizable import paths for enhanced autocompletion in Python editors or tools."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "get_interpreter_completions", "line_number": 70, "body": "def get_interpreter_completions(source: str, namespaces: List[Dict], sys_path=None):\n    import jedi\n\n    if _using_older_jedi(jedi):\n        try:\n            interpreter = jedi.Interpreter(source, namespaces, sys_path=sys_path)\n        except Exception as e:\n            logger.info(\"Could not get completions with given sys_path\", exc_info=e)\n            interpreter = jedi.Interpreter(source, namespaces)\n    else:\n        # NB! Can't send project for Interpreter in 0.18\n        # https://github.com/davidhalter/jedi/pull/1734\n        interpreter = jedi.Interpreter(source, namespaces)\n    if hasattr(interpreter, \"completions\"):\n        # up to jedi 0.17\n        return _tweak_completions(interpreter.completions())\n    else:\n        return _tweak_completions(interpreter.complete())", "is_method": false, "function_description": "Utility function that uses the Jedi library to provide code completion suggestions based on the given source code and execution namespaces, supporting compatibility across different Jedi versions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "_get_new_jedi_project", "line_number": 90, "body": "def _get_new_jedi_project(sys_path):\n    if not sys_path:\n        return None\n    else:\n        import jedi\n\n        return jedi.Project(path=sys_path[0], added_sys_path=sys_path)", "is_method": false, "function_description": "Creates and returns a new Jedi Project for code analysis based on the given system path list, or None if the path is empty. This supports initializing Jedi's static analysis environment with custom search paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "_tweak_completions", "line_number": 99, "body": "def _tweak_completions(completions):\n    # In jedi before 0.16, the name attribute did not contain trailing '=' for argument completions,\n    # since 0.16 it does. Need to ensure similar result for all supported versions.\n    result = []\n    for completion in completions:\n        name = completion.name\n        complete = completion.complete\n        if complete.endswith(\"=\") and not name.endswith(\"=\"):\n            name += \"=\"\n\n        result.append(\n            ThonnyCompletion(\n                name=name,\n                complete=complete,\n                type=completion.type,\n                description=completion.description,\n                parent=completion.parent,\n                full_name=completion.full_name,\n            )\n        )\n\n    return result", "is_method": false, "function_description": "Internal utility function that normalizes code completion entries by ensuring consistent trailing \"=\" in argument names across different Jedi library versions. It helps maintain uniform autocomplete behavior in code editors or IDE features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "get_definitions", "line_number": 123, "body": "def get_definitions(source: str, row: int, column: int, filename: str):\n    import jedi\n\n    if _using_older_jedi(jedi):\n        script = jedi.Script(source, row, column, filename)\n        return script.goto_definitions()\n    else:\n        script = jedi.Script(code=source, path=filename)\n        return script.infer(line=row, column=column)", "is_method": false, "function_description": "This function provides code definitions or type inference at a given position in the source code using Jedi, facilitating features like code navigation and autocompletion in development tools."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "_using_older_jedi", "line_number": 134, "body": "def _using_older_jedi(jedi):\n    return jedi.__version__[:4] in [\"0.13\", \"0.14\", \"0.15\", \"0.16\", \"0.17\"]", "is_method": false, "function_description": "Utility function to check if the Jedi library version is within a specific set of older releases, enabling conditional handling based on version compatibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "__getitem__", "line_number": 147, "body": "def __getitem__(self, key):\n        return self.__dict__[key]", "is_method": true, "class_name": "ThonnyCompletion", "function_description": "Returns the value associated with a given key from the object's internal dictionary, enabling dictionary-like access to the instance attributes of ThonnyCompletion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "advertise_ready", "line_number": 226, "body": "def advertise_ready(self):\n        self.event_generate(\"WorkbenchReady\")\n        self.ready = True", "is_method": true, "class_name": "Workbench", "function_description": "Signals that the Workbench is ready by generating a \"WorkbenchReady\" event and updating its readiness status. This function is useful for notifying other components when the Workbench is prepared for interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_make_sanity_checks", "line_number": 230, "body": "def _make_sanity_checks(self):\n        home_dir = os.path.expanduser(\"~\")\n        bad_home_msg = None\n        if home_dir == \"~\":\n            bad_home_msg = \"Can not find your home directory.\"\n        elif not os.path.exists(home_dir):\n            bad_home_msg = \"Reported home directory (%s) does not exist.\" % home_dir\n        if bad_home_msg:\n            messagebox.showwarning(\n                \"Problems with home directory\",\n                bad_home_msg + \"\\nThis may cause problems for Thonny.\",\n                master=self,\n            )", "is_method": true, "class_name": "Workbench", "function_description": "Performs checks to validate the user's home directory and warns if it is missing or invalid, helping prevent configuration issues in the Workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_try_action", "line_number": 244, "body": "def _try_action(self, action: Callable) -> None:\n        try:\n            action()\n        except Exception:\n            self.report_exception()", "is_method": true, "class_name": "Workbench", "function_description": "Private method of the Workbench class that attempts to execute a given action and reports any exceptions raised, ensuring error handling without interrupting the workflow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_configuration", "line_number": 250, "body": "def _init_configuration(self) -> None:\n        self._configuration_manager = try_load_configuration(thonny.CONFIGURATION_FILE)\n        self._configuration_pages = []  # type: List[Tuple[str, str, Type[tk.Widget]]]\n\n        self.set_default(\"general.single_instance\", thonny.SINGLE_INSTANCE_DEFAULT)\n        self.set_default(\"general.ui_mode\", \"simple\" if running_on_rpi() else \"regular\")\n        self.set_default(\"general.debug_mode\", False)\n        self.set_default(\"general.disable_notification_sound\", False)\n        self.set_default(\"general.scaling\", \"default\")\n        self.set_default(\"general.language\", languages.BASE_LANGUAGE_CODE)\n        self.set_default(\"general.font_scaling_mode\", \"default\")\n        self.set_default(\"general.environment\", [])\n        self.set_default(\"file.avoid_zenity\", False)\n        self.set_default(\"run.working_directory\", os.path.expanduser(\"~\"))\n        self.update_debug_mode()", "is_method": true, "class_name": "Workbench", "function_description": "Initializes the Workbench's configuration system by loading settings, preparing configuration pages, and setting default values for various general and runtime options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_tweak_environment", "line_number": 266, "body": "def _tweak_environment(self):\n        for entry in self.get_option(\"general.environment\"):\n            if \"=\" in entry:\n                key, val = entry.split(\"=\", maxsplit=1)\n                os.environ[key] = os.path.expandvars(val)\n            else:\n                logger.warning(\"No '=' in environment entry '%s'\", entry)", "is_method": true, "class_name": "Workbench", "function_description": "Private method of Workbench that updates the system environment variables based on configured key-value pairs, allowing dynamic customization of the runtime environment. It warns if entries are malformed, supporting flexible environment setup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "update_debug_mode", "line_number": 274, "body": "def update_debug_mode(self):\n        os.environ[\"THONNY_DEBUG\"] = str(self.get_option(\"general.debug_mode\", False))\n        thonny.set_logging_level()", "is_method": true, "class_name": "Workbench", "function_description": "Updates the environment debug flag based on the current debug mode setting and adjusts the logging level accordingly. It enables dynamic control of debugging behavior within the Workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_language", "line_number": 278, "body": "def _init_language(self) -> None:\n        \"\"\"Initialize language.\"\"\"\n        languages.set_language(self.get_option(\"general.language\"))", "is_method": true, "class_name": "Workbench", "function_description": "Private method of Workbench that initializes the language setting based on the current configuration options, ensuring the application uses the correct language environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_window", "line_number": 282, "body": "def _init_window(self) -> None:\n        self.title(\"Thonny\")\n\n        self.set_default(\"layout.zoomed\", False)\n        self.set_default(\"layout.top\", 15)\n        self.set_default(\"layout.left\", 150)\n        if self.in_simple_mode():\n            self.set_default(\"layout.width\", 1050)\n            self.set_default(\"layout.height\", 700)\n        else:\n            self.set_default(\"layout.width\", 800)\n            self.set_default(\"layout.height\", 650)\n        self.set_default(\"layout.w_width\", 200)\n        self.set_default(\"layout.e_width\", 200)\n        self.set_default(\"layout.s_height\", 200)\n\n        # I don't actually need saved options for Full screen/maximize view,\n        # but it's easier to create menu items, if I use configuration manager's variables\n        self.set_default(\"view.full_screen\", False)\n        self.set_default(\"view.maximize_view\", False)\n\n        # In order to avoid confusion set these settings to False\n        # even if they were True when Thonny was last run\n        self.set_option(\"view.full_screen\", False)\n        self.set_option(\"view.maximize_view\", False)\n\n        self.geometry(\n            \"{0}x{1}+{2}+{3}\".format(\n                min(max(self.get_option(\"layout.width\"), 320), self.winfo_screenwidth()),\n                min(max(self.get_option(\"layout.height\"), 240), self.winfo_screenheight()),\n                min(max(self.get_option(\"layout.left\"), 0), self.winfo_screenwidth() - 200),\n                min(max(self.get_option(\"layout.top\"), 0), self.winfo_screenheight() - 200),\n            )\n        )\n\n        if self.get_option(\"layout.zoomed\"):\n            ui_utils.set_zoomed(self, True)\n\n        self.protocol(\"WM_DELETE_WINDOW\", self._on_close)\n        self.bind(\"<Configure>\", self._on_configure, True)", "is_method": true, "class_name": "Workbench", "function_description": "Initializes the main application window's title, size, position, and layout settings based on mode and saved configurations. It also sets up window event handlers and ensures consistent startup display options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_statusbar", "line_number": 323, "body": "def _init_statusbar(self):\n        self._statusbar = ttk.Frame(self)", "is_method": true, "class_name": "Workbench", "function_description": "Private method of the Workbench class that initializes the status bar component in the user interface. It sets up the UI frame but does not configure its content or behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_icon", "line_number": 326, "body": "def _init_icon(self) -> None:\n        # Window icons\n        if running_on_linux() and ui_utils.get_tk_version_info() >= (8, 6):\n            self.iconphoto(True, self.get_image(\"thonny.png\"))\n        else:\n            icon_file = os.path.join(self.get_package_dir(), \"res\", \"thonny.ico\")\n            try:\n                self.iconbitmap(icon_file, default=icon_file)\n            except Exception:\n                try:\n                    # seems to work in mac\n                    self.iconbitmap(icon_file)\n                except Exception:\n                    pass", "is_method": true, "class_name": "Workbench", "function_description": "Private method of the Workbench class that sets the application window icon appropriately based on the operating system and toolkit version. It ensures consistent icon display across Linux, Windows, and macOS environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_menu", "line_number": 341, "body": "def _init_menu(self) -> None:\n        self.option_add(\"*tearOff\", tk.FALSE)\n        if lookup_style_option(\"Menubar\", \"custom\", False):\n            self._menubar = ui_utils.CustomMenubar(\n                self\n            )  # type: Union[tk.Menu, ui_utils.CustomMenubar]\n            if self.get_ui_mode() != \"simple\":\n                self._menubar.grid(row=0, sticky=\"nsew\")\n        else:\n            opts = get_style_configuration(\"Menubar\")\n            if \"custom\" in opts:\n                del opts[\"custom\"]\n            self._menubar = tk.Menu(self, **opts)\n            if self.get_ui_mode() != \"simple\":\n                self[\"menu\"] = self._menubar\n        self._menus = {}  # type: Dict[str, tk.Menu]\n        self._menu_item_specs = (\n            {}\n        )  # type: Dict[Tuple[str, str], MenuItem] # key is pair (menu_name, command_label)\n\n        # create standard menus in correct order\n        self.get_menu(\"file\", tr(\"File\"))\n        self.get_menu(\"edit\", tr(\"Edit\"))\n        self.get_menu(\"view\", tr(\"View\"))\n        self.get_menu(\"run\", tr(\"Run\"))\n        self.get_menu(\"tools\", tr(\"Tools\"))\n        self.get_menu(\"help\", tr(\"Help\"))", "is_method": true, "class_name": "Workbench", "function_description": "Private method of the Workbench class that initializes and configures the main application menu bar with standard menus, adapting to style settings and UI mode for consistent user interface layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_load_plugins", "line_number": 369, "body": "def _load_plugins(self) -> None:\n        # built-in plugins\n        import thonny.plugins  # pylint: disable=redefined-outer-name\n\n        self._load_plugins_from_path(thonny.plugins.__path__, \"thonny.plugins.\")  # type: ignore\n\n        # 3rd party plugins from namespace package\n        try:\n            import thonnycontrib  # @UnresolvedImport\n        except ImportError:\n            # No 3rd party plugins installed\n            pass\n        else:\n            self._load_plugins_from_path(thonnycontrib.__path__, \"thonnycontrib.\")", "is_method": true, "class_name": "Workbench", "function_description": "Internal method of the Workbench class that loads built-in and third-party plugins, enabling the application to extend its functionality dynamically through modular components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_load_plugins_from_path", "line_number": 384, "body": "def _load_plugins_from_path(self, path: List[str], prefix: str) -> None:\n        load_function_name = \"load_plugin\"\n\n        modules = []\n        for _, module_name, _ in sorted(pkgutil.iter_modules(path, prefix), key=lambda x: x[2]):\n            if module_name in OBSOLETE_PLUGINS:\n                logging.debug(\"Skipping plug-in %s\", module_name)\n            else:\n                try:\n                    m = importlib.import_module(module_name)\n                    if hasattr(m, load_function_name):\n                        modules.append(m)\n                except Exception:\n                    logging.exception(\"Failed loading plugin '\" + module_name + \"'\")\n\n        def module_sort_key(m):\n            return getattr(m, \"load_order_key\", m.__name__)\n\n        for m in sorted(modules, key=module_sort_key):\n            getattr(m, load_function_name)()", "is_method": true, "class_name": "Workbench", "function_description": "Core utility method of the Workbench class that dynamically discovers, imports, and loads valid plugins from specified paths, supporting plugin management with filtering and ordered initialization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_fonts", "line_number": 405, "body": "def _init_fonts(self) -> None:\n        # set up editor and shell fonts\n        self.set_default(\"view.io_font_family\", \"Courier\" if running_on_mac_os() else \"Courier New\")\n\n        default_editor_family = \"Courier New\"\n        families = tk_font.families()\n\n        for family in [\"Consolas\", \"Ubuntu Mono\", \"Menlo\", \"DejaVu Sans Mono\"]:\n            if family in families:\n                default_editor_family = family\n                break\n\n        self.set_default(\"view.editor_font_family\", default_editor_family)\n\n        if running_on_mac_os():\n            self.set_default(\"view.editor_font_size\", 14)\n            self.set_default(\"view.io_font_size\", 12)\n        elif self.in_simple_mode():\n            self.set_default(\"view.editor_font_size\", 12)\n            self.set_default(\"view.io_font_size\", 12)\n        else:\n            self.set_default(\"view.editor_font_size\", 13)\n            self.set_default(\"view.io_font_size\", 11)\n\n        default_font = tk_font.nametofont(\"TkDefaultFont\")\n\n        if running_on_linux():\n            heading_font = tk_font.nametofont(\"TkHeadingFont\")\n            heading_font.configure(weight=\"normal\")\n            caption_font = tk_font.nametofont(\"TkCaptionFont\")\n            caption_font.configure(weight=\"normal\", size=default_font.cget(\"size\"))\n\n        small_link_ratio = 0.8 if running_on_windows() else 0.7\n        self._fonts = [\n            tk_font.Font(\n                name=\"SmallLinkFont\",\n                family=default_font.cget(\"family\"),\n                size=int(default_font.cget(\"size\") * small_link_ratio),\n                underline=True,\n            ),\n            tk_font.Font(name=\"IOFont\", family=self.get_option(\"view.io_font_family\")),\n            tk_font.Font(\n                name=\"BoldIOFont\", family=self.get_option(\"view.io_font_family\"), weight=\"bold\"\n            ),\n            tk_font.Font(\n                name=\"UnderlineIOFont\",\n                family=self.get_option(\"view.io_font_family\"),\n                underline=True,\n            ),\n            tk_font.Font(\n                name=\"ItalicIOFont\", family=self.get_option(\"view.io_font_family\"), slant=\"italic\"\n            ),\n            tk_font.Font(\n                name=\"BoldItalicIOFont\",\n                family=self.get_option(\"view.io_font_family\"),\n                weight=\"bold\",\n                slant=\"italic\",\n            ),\n            tk_font.Font(name=\"EditorFont\", family=self.get_option(\"view.editor_font_family\")),\n            tk_font.Font(name=\"SmallEditorFont\", family=self.get_option(\"view.editor_font_family\")),\n            tk_font.Font(\n                name=\"BoldEditorFont\",\n                family=self.get_option(\"view.editor_font_family\"),\n                weight=\"bold\",\n            ),\n            tk_font.Font(\n                name=\"ItalicEditorFont\",\n                family=self.get_option(\"view.editor_font_family\"),\n                slant=\"italic\",\n            ),\n            tk_font.Font(\n                name=\"BoldItalicEditorFont\",\n                family=self.get_option(\"view.editor_font_family\"),\n                weight=\"bold\",\n                slant=\"italic\",\n            ),\n            tk_font.Font(\n                name=\"TreeviewFont\",\n                family=default_font.cget(\"family\"),\n                size=default_font.cget(\"size\"),\n            ),\n            tk_font.Font(\n                name=\"BoldTkDefaultFont\",\n                family=default_font.cget(\"family\"),\n                size=default_font.cget(\"size\"),\n                weight=\"bold\",\n            ),\n            tk_font.Font(\n                name=\"ItalicTkDefaultFont\",\n                family=default_font.cget(\"family\"),\n                size=default_font.cget(\"size\"),\n                slant=\"italic\",\n            ),\n            tk_font.Font(\n                name=\"UnderlineTkDefaultFont\",\n                family=default_font.cget(\"family\"),\n                size=default_font.cget(\"size\"),\n                underline=1,\n            ),\n        ]\n\n        self.update_fonts()", "is_method": true, "class_name": "Workbench", "function_description": "Initializes and configures a comprehensive set of fonts tailored for the Workbench's editor and shell interfaces, adapting font families and sizes based on the operating system and interface mode. Provides consistent and platform-optimized typography settings for the application's UI components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_start_runner", "line_number": 508, "body": "def _start_runner(self) -> None:\n        try:\n            self.update_idletasks()  # allow UI to complete\n            thonny._runner = self._runner\n            self._runner.start()\n            self._update_toolbar()\n        except Exception:\n            self.report_exception(\"Error when initializing backend\")", "is_method": true, "class_name": "Workbench", "function_description": "Core utility of the Workbench class that initiates the backend runner process, updates the UI accordingly, and handles exceptions during startup to ensure smooth operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_check_init_server_loop", "line_number": 517, "body": "def _check_init_server_loop(self) -> None:\n        \"\"\"Socket will listen requests from newer Thonny instances,\n        which try to delegate opening files to older instance\"\"\"\n\n        if not self.get_option(\"general.single_instance\") or os.path.exists(\n            thonny.get_ipc_file_path()\n        ):\n            self._ipc_requests = None\n            return\n\n        self._ipc_requests = queue.Queue()  # type: queue.Queue[bytes]\n        server_socket, actual_secret = self._create_server_socket()\n        server_socket.listen(10)\n\n        def server_loop():\n            while True:\n                logging.debug(\"Waiting for next client\")\n                (client_socket, _) = server_socket.accept()\n                try:\n                    data = bytes()\n                    while True:\n                        new_data = client_socket.recv(1024)\n                        if len(new_data) > 0:\n                            data += new_data\n                        else:\n                            break\n                    proposed_secret, args = ast.literal_eval(data.decode(\"UTF-8\"))\n                    if proposed_secret == actual_secret:\n                        self._ipc_requests.put(args)\n                        # respond OK\n                        client_socket.sendall(SERVER_SUCCESS.encode(encoding=\"utf-8\"))\n                        client_socket.shutdown(socket.SHUT_WR)\n                        logging.debug(\"AFTER NEW REQUEST %s\", client_socket)\n                    else:\n                        client_socket.shutdown(socket.SHUT_WR)\n                        raise PermissionError(\"Wrong secret\")\n\n                except Exception as e:\n                    logger.exception(\"Error in ipc server loop\", exc_info=e)\n\n        Thread(target=server_loop, daemon=True).start()", "is_method": true, "class_name": "Workbench", "function_description": "Internal Workbench method that sets up a socket server loop to accept file opening requests from newer Thonny instances, enabling single-instance coordination and inter-process communication via authenticated IPC messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_create_server_socket", "line_number": 559, "body": "def _create_server_socket(self):\n        if running_on_windows():\n            server_socket = socket.socket(socket.AF_INET)  # @UndefinedVariable\n            server_socket.bind((\"127.0.0.1\", 0))\n\n            # advertise the port and secret\n            port = server_socket.getsockname()[1]\n            import uuid\n\n            secret = str(uuid.uuid4())\n\n            with open(thonny.get_ipc_file_path(), \"w\") as fp:\n                fp.write(str(port) + \"\\n\")\n                fp.write(secret + \"\\n\")\n\n        else:\n            server_socket = socket.socket(socket.AF_UNIX)  # @UndefinedVariable\n            server_socket.bind(thonny.get_ipc_file_path())\n            secret = \"\"\n\n        os.chmod(thonny.get_ipc_file_path(), 0o600)\n        return server_socket, secret", "is_method": true, "class_name": "Workbench", "function_description": "Utility method within Workbench that creates and binds a local server socket, handling platform-specific details and generating a secret for secure inter-process communication setup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_commands", "line_number": 582, "body": "def _init_commands(self) -> None:\n\n        self.add_command(\n            \"exit\",\n            \"file\",\n            tr(\"Exit\"),\n            self._on_close,\n            default_sequence=select_sequence(\"<Alt-F4>\", \"<Command-q>\", \"<Control-q>\"),\n            extra_sequences=[\"<Alt-F4>\"]\n            if running_on_linux()\n            else [\"<Control-q>\"]\n            if running_on_windows()\n            else [],\n        )\n\n        self.add_command(\"show_options\", \"tools\", tr(\"Options...\"), self.show_options, group=180)\n        self.createcommand(\"::tk::mac::ShowPreferences\", self.show_options)\n        self.createcommand(\"::tk::mac::Quit\", self._mac_quit)\n\n        self.add_command(\n            \"increase_font_size\",\n            \"view\",\n            tr(\"Increase font size\"),\n            lambda: self._change_font_size(1),\n            default_sequence=select_sequence(\"<Control-plus>\", \"<Command-Shift-plus>\"),\n            extra_sequences=[\"<Control-KP_Add>\"],\n            group=60,\n        )\n\n        self.add_command(\n            \"decrease_font_size\",\n            \"view\",\n            tr(\"Decrease font size\"),\n            lambda: self._change_font_size(-1),\n            default_sequence=select_sequence(\"<Control-minus>\", \"<Command-minus>\"),\n            extra_sequences=[\"<Control-KP_Subtract>\"],\n            group=60,\n        )\n\n        self.bind(\"<Control-MouseWheel>\", self._cmd_zoom_with_mouse, True)\n\n        self.add_command(\n            \"focus_editor\",\n            \"view\",\n            tr(\"Focus editor\"),\n            self._cmd_focus_editor,\n            default_sequence=select_sequence(\"<Alt-e>\", \"<Command-Alt-e>\"),\n            group=70,\n        )\n\n        self.add_command(\n            \"focus_shell\",\n            \"view\",\n            tr(\"Focus shell\"),\n            self._cmd_focus_shell,\n            default_sequence=select_sequence(\"<Alt-s>\", \"<Command-Alt-s>\"),\n            group=70,\n        )\n\n        if self.get_ui_mode() == \"expert\":\n\n            self.add_command(\n                \"toggle_maximize_view\",\n                \"view\",\n                tr(\"Maximize view\"),\n                self._cmd_toggle_maximize_view,\n                flag_name=\"view.maximize_view\",\n                default_sequence=None,\n                group=80,\n            )\n            self.bind_class(\"TNotebook\", \"<Double-Button-1>\", self._maximize_view, True)\n            self.bind(\"<Escape>\", self._unmaximize_view, True)\n\n            self.add_command(\n                \"toggle_maximize_view\",\n                \"view\",\n                tr(\"Full screen\"),\n                self._cmd_toggle_full_screen,\n                flag_name=\"view.full_screen\",\n                default_sequence=select_sequence(\"<F11>\", \"<Command-Shift-F>\"),\n                group=80,\n            )\n\n        if self.in_simple_mode():\n            self.add_command(\n                \"font\",\n                \"tools\",\n                tr(\"Change font size\"),\n                caption=tr(\"Zoom\"),\n                handler=self._toggle_font_size,\n                image=\"zoom\",\n                include_in_toolbar=True,\n            )\n\n            self.add_command(\n                \"quit\",\n                \"help\",\n                tr(\"Exit Thonny\"),\n                self._on_close,\n                image=\"quit\",\n                caption=tr(\"Quit\"),\n                include_in_toolbar=True,\n                group=101,\n            )\n\n        if thonny.in_debug_mode():\n            self.bind_all(\"<Control-Shift-Alt-D>\", self._print_state_for_debugging, True)", "is_method": true, "class_name": "Workbench", "function_description": "Initializes and registers user interface commands and their keyboard shortcuts within the Workbench, configuring actions like exiting, font size adjustments, view focus, and mode-specific UI behaviors. This setup enables consistent command handling and user interaction across the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_print_state_for_debugging", "line_number": 690, "body": "def _print_state_for_debugging(self, event) -> None:\n        print(get_runner()._postponed_commands)", "is_method": true, "class_name": "Workbench", "function_description": "Private debugging method in the Workbench class that outputs the current list of postponed runner commands for inspection during development or troubleshooting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_containers", "line_number": 693, "body": "def _init_containers(self) -> None:\n\n        margin = 10\n        # Main frame functions as\n        # - a background behind padding of main_pw, without this OS X leaves white border\n        # - a container to be hidden, when a view is maximized and restored when view is back home\n        main_frame = ttk.Frame(self)  #\n        self._main_frame = main_frame\n        main_frame.grid(row=1, column=0, sticky=tk.NSEW)\n        self.columnconfigure(0, weight=1)\n        self.rowconfigure(1, weight=1)\n        self._maximized_view = None  # type: Optional[tk.Widget]\n\n        self._toolbar = ttk.Frame(main_frame, padding=0)\n        self._toolbar.grid(column=0, row=0, sticky=tk.NSEW, padx=margin, pady=(5, 0))\n\n        self.set_default(\"layout.west_pw_width\", self.scale(150))\n        self.set_default(\"layout.east_pw_width\", self.scale(150))\n\n        self.set_default(\"layout.s_nb_height\", self.scale(150))\n        self.set_default(\"layout.nw_nb_height\", self.scale(150))\n        self.set_default(\"layout.sw_nb_height\", self.scale(150))\n        self.set_default(\"layout.ne_nb_height\", self.scale(150))\n        self.set_default(\"layout.se_nb_height\", self.scale(150))\n\n        self._main_pw = AutomaticPanedWindow(main_frame, orient=tk.HORIZONTAL)\n\n        self._main_pw.grid(column=0, row=1, sticky=tk.NSEW, padx=margin, pady=(margin, 0))\n        main_frame.columnconfigure(0, weight=1)\n        main_frame.rowconfigure(1, weight=1)\n\n        self._west_pw = AutomaticPanedWindow(\n            self._main_pw,\n            1,\n            orient=tk.VERTICAL,\n            preferred_size_in_pw=self.get_option(\"layout.west_pw_width\"),\n        )\n        self._center_pw = AutomaticPanedWindow(self._main_pw, 2, orient=tk.VERTICAL)\n        self._east_pw = AutomaticPanedWindow(\n            self._main_pw,\n            3,\n            orient=tk.VERTICAL,\n            preferred_size_in_pw=self.get_option(\"layout.east_pw_width\"),\n        )\n\n        self._view_notebooks = {\n            \"nw\": AutomaticNotebook(\n                self._west_pw, 1, preferred_size_in_pw=self.get_option(\"layout.nw_nb_height\")\n            ),\n            \"w\": AutomaticNotebook(self._west_pw, 2),\n            \"sw\": AutomaticNotebook(\n                self._west_pw, 3, preferred_size_in_pw=self.get_option(\"layout.sw_nb_height\")\n            ),\n            \"s\": AutomaticNotebook(\n                self._center_pw, 3, preferred_size_in_pw=self.get_option(\"layout.s_nb_height\")\n            ),\n            \"ne\": AutomaticNotebook(\n                self._east_pw, 1, preferred_size_in_pw=self.get_option(\"layout.ne_nb_height\")\n            ),\n            \"e\": AutomaticNotebook(self._east_pw, 2),\n            \"se\": AutomaticNotebook(\n                self._east_pw, 3, preferred_size_in_pw=self.get_option(\"layout.se_nb_height\")\n            ),\n        }\n\n        for nb_name in self._view_notebooks:\n            self.set_default(\"layout.notebook_\" + nb_name + \"_visible_view\", None)\n\n        self._editor_notebook = EditorNotebook(self._center_pw)\n        self._editor_notebook.position_key = 1\n        self._center_pw.insert(\"auto\", self._editor_notebook)\n\n        self._statusbar = ttk.Frame(main_frame)\n        self._statusbar.grid(column=0, row=2, sticky=\"nsew\", padx=margin, pady=(0))\n        self._statusbar.columnconfigure(2, weight=2)\n        self._status_label = ttk.Label(self._statusbar, text=\"\")\n        self._status_label.grid(row=1, column=1, sticky=\"w\")\n\n        self._init_backend_switcher()", "is_method": true, "class_name": "Workbench", "function_description": "Initializes and configures the main container widgets and layout structure of the Workbench interface, setting up panes, notebooks, toolbar, and status bar for organizing and managing the GUI's primary interactive areas."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_backend_switcher", "line_number": 773, "body": "def _init_backend_switcher(self):\n\n        # Set up the menu\n        self._backend_conf_variable = tk.StringVar(value=\"{}\")\n        self._backend_menu = tk.Menu(self._statusbar, tearoff=False)\n\n        # Set up the button\n        self._backend_button = ttk.Button(self._statusbar, text=\"\", style=\"Toolbutton\")\n\n        self._backend_button.grid(row=1, column=3, sticky=\"e\")\n        self._backend_button.configure(command=self._post_backend_menu)", "is_method": true, "class_name": "Workbench", "function_description": "Initializes the user interface components for switching backend configurations within the Workbench, setting up a menu and button linked to backend selection functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_post_backend_menu", "line_number": 785, "body": "def _post_backend_menu(self):\n        menu_font = tk_font.nametofont(\"TkMenuFont\")\n\n        def choose_backend():\n            backend_conf = ast.literal_eval(self._backend_conf_variable.get())\n            assert isinstance(backend_conf, dict), \"backend conf is %r\" % backend_conf\n            for name, value in backend_conf.items():\n                self.set_option(name, value)\n            get_runner().restart_backend(False)\n\n        self._backend_menu.delete(0, \"end\")\n        max_description_width = 0\n        button_text_width = menu_font.measure(self._backend_button.cget(\"text\"))\n\n        num_entries = 0\n        for backend in sorted(self.get_backends().values(), key=lambda x: x.sort_key):\n            entries = backend.proxy_class.get_switcher_entries()\n\n            if not entries:\n                continue\n\n            if len(entries) == 1:\n                self._backend_menu.add_radiobutton(\n                    label=backend.description,\n                    command=choose_backend,\n                    variable=self._backend_conf_variable,\n                    value=repr(entries[0][0]),\n                )\n            else:\n                submenu = tk.Menu(self._backend_menu, tearoff=False)\n                for conf, label in entries:\n                    submenu.add_radiobutton(\n                        label=label,\n                        command=choose_backend,\n                        variable=self._backend_conf_variable,\n                        value=repr(conf),\n                    )\n                self._backend_menu.add_cascade(label=backend.description, menu=submenu)\n\n            max_description_width = max(\n                menu_font.measure(backend.description), max_description_width\n            )\n        num_entries += 1\n\n        # self._backend_conf_variable.set(value=self.get_option(\"run.backend_name\"))\n\n        self._backend_menu.add_separator()\n        self._backend_menu.add_command(\n            label=tr(\"Configure interpreter...\"),\n            command=lambda: self.show_options(\"interpreter\"),\n        )\n\n        post_x = self._backend_button.winfo_rootx()\n        post_y = self._backend_button.winfo_rooty()\n\n        if self.winfo_screenwidth() / self.winfo_screenheight() > 2:\n            # Most likely several monitors.\n            # Tk will adjust x properly with single monitor, but when Thonny is maximized\n            # on a monitor, which has another monitor to its right, the menu can be partially\n            # displayed on another monitor (at least in Ubuntu).\n            width_diff = max_description_width - button_text_width\n            post_x -= width_diff + menu_font.measure(\"mmm\")\n\n        if running_on_mac_os():\n            # won't be good location otherwise\n            popup_entry = num_entries + 4\n        else:\n            popup_entry = \"\"\n\n        # print(post_x, post_y)\n        try:\n            self._backend_menu.tk_popup(post_x, post_y, entry=popup_entry)\n        except tk.TclError as e:\n            if not 'unknown option \"-state\"' in str(e):\n                logger.warning(\"Problem with switcher popup\", exc_info=e)", "is_method": true, "class_name": "Workbench", "function_description": "Constructs and displays a dynamic backend selection menu allowing users to choose and configure execution backends; it updates options and restarts the backend accordingly, supporting multiple entries and platform-specific menu positioning."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_backend_restart", "line_number": 861, "body": "def _on_backend_restart(self, event):\n        proxy = get_runner().get_backend_proxy()\n        if proxy:\n            desc = proxy.get_clean_description()\n            self._backend_conf_variable.set(value=repr(proxy.get_current_switcher_configuration()))\n        else:\n            backend_conf = self._backends.get(self.get_option(\"run.backend_name\"), None)\n            if backend_conf:\n                desc = backend_conf.description\n            else:\n                desc = \"<no backend>\"\n        self._backend_button.configure(text=desc)", "is_method": true, "class_name": "Workbench", "function_description": "Updates the Workbench UI to reflect the current backend status and configuration after a backend restart event, ensuring the displayed backend description is accurate and up-to-date."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_theming", "line_number": 874, "body": "def _init_theming(self) -> None:\n        self._style = ttk.Style()\n        self._ui_themes = (\n            {}\n        )  # type: Dict[str, Tuple[Optional[str], FlexibleUiThemeSettings, Dict[str, str]]] # value is (parent, settings, images)\n        self._syntax_themes = (\n            {}\n        )  # type: Dict[str, Tuple[Optional[str], FlexibleSyntaxThemeSettings]] # value is (parent, settings)\n        self.set_default(\"view.ui_theme\", ui_utils.get_default_theme())", "is_method": true, "class_name": "Workbench", "function_description": "Private method in Workbench that initializes UI and syntax theming settings with default values, preparing the application\u2019s theme infrastructure for user interface customization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_command", "line_number": 884, "body": "def add_command(\n        self,\n        command_id: str,\n        menu_name: str,\n        command_label: str,\n        handler: Optional[Callable[[], None]] = None,\n        tester: Optional[Callable[[], bool]] = None,\n        default_sequence: Optional[str] = None,\n        extra_sequences: Sequence[str] = [],\n        flag_name: Optional[str] = None,\n        skip_sequence_binding: bool = False,\n        accelerator: Optional[str] = None,\n        group: int = 99,\n        position_in_group=\"end\",\n        image: Optional[str] = None,\n        caption: Optional[str] = None,\n        alternative_caption: Optional[str] = None,\n        include_in_menu: bool = True,\n        include_in_toolbar: bool = False,\n        submenu: Optional[tk.Menu] = None,\n        bell_when_denied: bool = True,\n        show_extra_sequences=False,\n    ) -> None:\n        \"\"\"Registers an item to be shown in specified menu.\n\n        Args:\n            menu_name: Name of the menu the command should appear in.\n                Standard menu names are \"file\", \"edit\", \"run\", \"view\", \"help\".\n                If a menu with given name doesn't exist, then new menu is created\n                (with label=name).\n            command_label: Label for this command\n            handler: Function to be called when the command is invoked.\n                Should be callable with one argument (the event or None).\n            tester: Function to be called for determining if command is available or not.\n                Should be callable with one argument (the event or None).\n                Should return True or False.\n                If None then command is assumed to be always available.\n            default_sequence: Default shortcut (Tk style)\n            flag_name: Used for toggle commands. Indicates the name of the boolean option.\n            group: Used for grouping related commands together. Value should be int.\n                Groups with smaller numbers appear before.\n\n        Returns:\n            None\n        \"\"\"\n\n        # Temporary solution for plug-ins made for versions before 3.2\n        if menu_name == \"device\":\n            menu_name = \"tools\"\n            group = 150\n\n        # store command to be published later\n        self._commands.append(\n            dict(\n                command_id=command_id,\n                menu_name=menu_name,\n                command_label=command_label,\n                handler=handler,\n                tester=tester,\n                default_sequence=default_sequence,\n                extra_sequences=extra_sequences,\n                flag_name=flag_name,\n                skip_sequence_binding=skip_sequence_binding,\n                accelerator=accelerator,\n                group=group,\n                position_in_group=position_in_group,\n                image=image,\n                caption=caption,\n                alternative_caption=alternative_caption,\n                include_in_menu=include_in_menu,\n                include_in_toolbar=include_in_toolbar,\n                submenu=submenu,\n                bell_when_denied=bell_when_denied,\n                show_extra_sequences=show_extra_sequences,\n            )\n        )", "is_method": true, "class_name": "Workbench", "function_description": "Method of the Workbench class that registers a command with associated menu placement, label, and optional callbacks, enabling dynamic extension of menus, toolbars, and shortcuts within the application interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_publish_commands", "line_number": 961, "body": "def _publish_commands(self) -> None:\n        for cmd in self._commands:\n            self._publish_command(**cmd)", "is_method": true, "class_name": "Workbench", "function_description": "Internal helper method of the Workbench class that iterates over stored commands and publishes each one by invoking a separate publish action."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_publish_command", "line_number": 965, "body": "def _publish_command(\n        self,\n        command_id: str,\n        menu_name: str,\n        command_label: str,\n        handler: Optional[Callable[[], None]],\n        tester: Optional[Callable[[], bool]] = None,\n        default_sequence: Optional[str] = None,\n        extra_sequences: Sequence[str] = [],\n        flag_name: Optional[str] = None,\n        skip_sequence_binding: bool = False,\n        accelerator: Optional[str] = None,\n        group: int = 99,\n        position_in_group=\"end\",\n        image: Optional[str] = None,\n        caption: Optional[str] = None,\n        alternative_caption: Optional[str] = None,\n        include_in_menu: bool = True,\n        include_in_toolbar: bool = False,\n        submenu: Optional[tk.Menu] = None,\n        bell_when_denied: bool = True,\n        show_extra_sequences: bool = False,\n    ) -> None:\n        def dispatch(event=None):\n            if not tester or tester():\n                denied = False\n                handler()\n            else:\n                denied = True\n                logging.debug(\"Command '\" + command_id + \"' execution denied\")\n                if bell_when_denied:\n                    self.bell()\n\n            self.event_generate(\"UICommandDispatched\", command_id=command_id, denied=denied)\n\n        def dispatch_if_caps_lock_is_on(event):\n            if caps_lock_is_on(event.state) and not shift_is_pressed(event.state):\n                dispatch(event)\n\n        sequence_option_name = \"shortcuts.\" + command_id\n        self.set_default(sequence_option_name, default_sequence)\n        sequence = self.get_option(sequence_option_name)\n\n        if sequence:\n            if not skip_sequence_binding:\n                self.bind_all(sequence, dispatch, True)\n                # work around caps-lock problem\n                # https://github.com/thonny/thonny/issues/1347\n                # Unfortunately the solution doesn't work with sequences involving Shift\n                # (in Linux with the expected solution Shift sequences did not come through\n                # with Caps Lock, and in Windows, the shift handlers started to react\n                # on non-shift keypresses)\n                # Python 3.7 on Mac seems to require lower letters for shift sequences.\n                parts = sequence.strip(\"<>\").split(\"-\")\n                if len(parts[-1]) == 1 and parts[-1].islower() and \"Shift\" not in parts:\n                    lock_sequence = \"<%s-Lock-%s>\" % (\"-\".join(parts[:-1]), parts[-1].upper())\n                    self.bind_all(lock_sequence, dispatch_if_caps_lock_is_on, True)\n\n            # register shortcut even without binding\n            register_latin_shortcut(self._latin_shortcuts, sequence, handler, tester)\n\n        for extra_sequence in extra_sequences:\n            self.bind_all(extra_sequence, dispatch, True)\n            if \"greek_\" not in extra_sequence.lower() or running_on_linux():\n                # Use greek alternatives only on Linux\n                # (they are not required on Mac\n                # and cause double events on Windows)\n                register_latin_shortcut(self._latin_shortcuts, sequence, handler, tester)\n\n        menu = self.get_menu(menu_name)\n\n        if image:\n            _image = self.get_image(image)  # type: Optional[tk.PhotoImage]\n            _disabled_image = self.get_image(image, disabled=True)\n        else:\n            _image = None\n            _disabled_image = None\n\n        if not accelerator and sequence:\n            accelerator = sequence_to_accelerator(sequence)\n            \"\"\"\n            # Does not work on Mac\n            if show_extra_sequences:\n                for extra_seq in extra_sequences:\n                    accelerator += \" or \" + sequence_to_accelerator(extra_seq)\n            \"\"\"\n\n        if include_in_menu:\n\n            def dispatch_from_menu():\n                # I don't like that Tk menu toggles checbutton variable\n                # automatically before calling the handler.\n                # So I revert the toggle before calling the actual handler.\n                # This way the handler doesn't have to worry whether it\n                # needs to toggle the variable or not, and it can choose to\n                # decline the toggle.\n                if flag_name is not None:\n                    var = self.get_variable(flag_name)\n                    var.set(not var.get())\n\n                dispatch(None)\n\n            if _image and lookup_style_option(\"OPTIONS\", \"icons_in_menus\", True):\n                menu_image = _image  # type: Optional[tk.PhotoImage]\n            elif flag_name:\n                # no image or black next to a checkbox\n                menu_image = None\n            else:\n                menu_image = self.get_image(\"16x16-blank\")\n\n            # remember the details that can't be stored in Tkinter objects\n            self._menu_item_specs[(menu_name, command_label)] = MenuItem(\n                group, position_in_group, tester\n            )\n\n            menu.insert(\n                self._find_location_for_menu_item(menu_name, command_label),\n                \"checkbutton\" if flag_name else \"cascade\" if submenu else \"command\",\n                label=command_label,\n                accelerator=accelerator,\n                image=menu_image,\n                compound=tk.LEFT,\n                variable=self.get_variable(flag_name) if flag_name else None,\n                command=dispatch_from_menu if handler else None,\n                menu=submenu,\n            )\n\n        if include_in_toolbar:\n            toolbar_group = self._get_menu_index(menu) * 100 + group\n            assert caption is not None\n            self._add_toolbar_button(\n                command_id,\n                _image,\n                _disabled_image,\n                command_label,\n                caption,\n                caption if alternative_caption is None else alternative_caption,\n                accelerator,\n                handler,\n                tester,\n                toolbar_group,\n            )", "is_method": true, "class_name": "Workbench", "function_description": "Registers and binds a user interface command with optional keyboard shortcuts, menu and toolbar integration, and conditional execution logic, enabling consistent command management and interaction within the Workbench application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_view", "line_number": 1108, "body": "def add_view(\n        self,\n        cls: Type[tk.Widget],\n        label: str,\n        default_location: str,\n        visible_by_default: bool = False,\n        default_position_key: Optional[str] = None,\n    ) -> None:\n        \"\"\"Adds item to \"View\" menu for showing/hiding given view.\n\n        Args:\n            view_class: Class or constructor for view. Should be callable with single\n                argument (the master of the view)\n            label: Label of the view tab\n            location: Location descriptor. Can be \"nw\", \"sw\", \"s\", \"se\", \"ne\"\n\n        Returns: None\n        \"\"\"\n        view_id = cls.__name__\n        if default_position_key == None:\n            default_position_key = label\n\n        self.set_default(\"view.\" + view_id + \".visible\", visible_by_default)\n        self.set_default(\"view.\" + view_id + \".location\", default_location)\n        self.set_default(\"view.\" + view_id + \".position_key\", default_position_key)\n\n        if self.in_simple_mode():\n            visibility_flag = tk.BooleanVar(value=view_id in SIMPLE_MODE_VIEWS)\n        else:\n            visibility_flag = cast(tk.BooleanVar, self.get_variable(\"view.\" + view_id + \".visible\"))\n\n        self._view_records[view_id] = {\n            \"class\": cls,\n            \"label\": label,\n            \"location\": self.get_option(\"view.\" + view_id + \".location\"),\n            \"position_key\": self.get_option(\"view.\" + view_id + \".position_key\"),\n            \"visibility_flag\": visibility_flag,\n        }\n\n        # handler\n        def toggle_view_visibility():\n            if visibility_flag.get():\n                self.hide_view(view_id)\n            else:\n                self.show_view(view_id, True)\n\n        self.add_command(\n            \"toggle_\" + view_id,\n            menu_name=\"view\",\n            command_label=label,\n            handler=toggle_view_visibility,\n            flag_name=\"view.\" + view_id + \".visible\",\n            group=10,\n            position_in_group=\"alphabetic\",\n        )", "is_method": true, "class_name": "Workbench", "function_description": "Method of the Workbench class that registers a view component with visibility controls and menu integration, enabling users to toggle its display through the \"View\" menu with configurable default location and state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_configuration_page", "line_number": 1164, "body": "def add_configuration_page(\n        self, key: str, title: str, page_class: Type[tk.Widget], order: int\n    ) -> None:\n        self._configuration_pages.append((key, title, page_class, order))", "is_method": true, "class_name": "Workbench", "function_description": "Adds a new configuration page to the Workbench's list, identified by a key, title, widget class, and display order for UI organization purposes. This enables dynamic extension of configuration options in the Workbench interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_content_inspector", "line_number": 1169, "body": "def add_content_inspector(self, inspector_class: Type) -> None:\n        self.content_inspector_classes.append(inspector_class)", "is_method": true, "class_name": "Workbench", "function_description": "Adds a content inspector class to the Workbench, enabling it to include additional content analysis or validation capabilities through dynamically specified inspectors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_backend", "line_number": 1172, "body": "def add_backend(\n        self,\n        name: str,\n        proxy_class: Type[BackendProxy],\n        description: str,\n        config_page_constructor,\n        sort_key=None,\n    ) -> None:\n        self._backends[name] = BackendSpec(\n            name,\n            proxy_class,\n            description,\n            config_page_constructor,\n            sort_key if sort_key is not None else description,\n        )\n\n        # assing names to related classes\n        proxy_class.backend_name = name  # type: ignore\n        proxy_class.backend_description = description  # type: ignore\n        if not getattr(config_page_constructor, \"backend_name\", None):\n            config_page_constructor.backend_name = name", "is_method": true, "class_name": "Workbench", "function_description": "Adds and registers a new backend to the Workbench, associating it with metadata and configuration details for later use and identification within the system. This enables dynamic backend integration and management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_ui_theme", "line_number": 1194, "body": "def add_ui_theme(\n        self,\n        name: str,\n        parent: Union[str, None],\n        settings: FlexibleUiThemeSettings,\n        images: Dict[str, str] = {},\n    ) -> None:\n        if name in self._ui_themes:\n            warn(tr(\"Overwriting theme '%s'\") % name)\n\n        self._ui_themes[name] = (parent, settings, images)", "is_method": true, "class_name": "Workbench", "function_description": "Adds or updates a UI theme by specifying its name, optional parent theme, settings, and associated images, allowing customization and extension of the application's visual appearance within the Workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_syntax_theme", "line_number": 1206, "body": "def add_syntax_theme(\n        self, name: str, parent: Optional[str], settings: FlexibleSyntaxThemeSettings\n    ) -> None:\n        if name in self._syntax_themes:\n            warn(tr(\"Overwriting theme '%s'\") % name)\n\n        self._syntax_themes[name] = (parent, settings)", "is_method": true, "class_name": "Workbench", "function_description": "Adds or updates a syntax highlighting theme by name, optionally inheriting from a parent theme, to customize code appearance within the Workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_usable_ui_theme_names", "line_number": 1214, "body": "def get_usable_ui_theme_names(self) -> Sequence[str]:\n        return sorted([name for name in self._ui_themes if self._ui_themes[name][0] is not None])", "is_method": true, "class_name": "Workbench", "function_description": "Returns a sorted list of UI theme names currently available for use, filtering out any themes that lack usable configurations. This enables interface components to present only valid, selectable themes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_syntax_theme_names", "line_number": 1217, "body": "def get_syntax_theme_names(self) -> Sequence[str]:\n        return sorted(self._syntax_themes.keys())", "is_method": true, "class_name": "Workbench", "function_description": "Returns a sorted list of available syntax theme names in the Workbench, supporting UI customization or theming features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_ui_mode", "line_number": 1220, "body": "def get_ui_mode(self) -> str:\n        return self._active_ui_mode", "is_method": true, "class_name": "Workbench", "function_description": "Returns the current active user interface mode of the Workbench, allowing other components to adapt their behavior or presentation accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "in_simple_mode", "line_number": 1223, "body": "def in_simple_mode(self) -> bool:\n        return self.get_ui_mode() == \"simple\"", "is_method": true, "class_name": "Workbench", "function_description": "Determines if the current user interface mode of the Workbench is set to \"simple\". This can guide functionality that depends on UI complexity or feature availability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "scale", "line_number": 1226, "body": "def scale(self, value: Union[int, float]) -> int:\n        if isinstance(value, (int, float)):\n            # using int instead of round so that thin lines will stay\n            # one pixel even with scaling_factor 1.67\n            result = int(self._scaling_factor * value)\n            if result == 0 and value > 0:\n                # don't lose thin lines because of scaling\n                return 1\n            else:\n                return result\n        else:\n            raise NotImplementedError(\"Only numeric dimensions supported at the moment\")", "is_method": true, "class_name": "Workbench", "function_description": "Utility method of the Workbench class that scales numeric values by a scaling factor, ensuring no positive values scale down to zero. It supports consistent dimension scaling, especially for thin graphical elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_register_ui_theme_as_tk_theme", "line_number": 1239, "body": "def _register_ui_theme_as_tk_theme(self, name: str) -> None:\n        # collect settings from all ancestors\n        total_settings = []  # type: List[FlexibleUiThemeSettings]\n        total_images = {}  # type: Dict[str, str]\n        temp_name = name\n        while True:\n            parent, settings, images = self._ui_themes[temp_name]\n            total_settings.insert(0, settings)\n            for img_name in images:\n                total_images.setdefault(img_name, images[img_name])\n\n            if parent is not None:\n                temp_name = parent\n            else:\n                # reached start of the chain\n                break\n\n        assert temp_name in self._style.theme_names()\n        # only root of the ancestors is relevant for theme_create,\n        # because the method actually doesn't take parent settings into account\n        # (https://mail.python.org/pipermail/tkinter-discuss/2015-August/003752.html)\n        self._style.theme_create(name, temp_name)\n        self._image_mapping_by_theme[name] = total_images\n\n        # load images\n        self.get_image(\"tab-close\", \"img_close\")\n        self.get_image(\"tab-close-active\", \"img_close_active\")\n\n        # apply settings starting from root ancestor\n        for settings in total_settings:\n            if callable(settings):\n                settings = settings()\n\n            if isinstance(settings, dict):\n                self._style.theme_settings(name, settings)\n            else:\n                for subsettings in settings:\n                    self._style.theme_settings(name, subsettings)", "is_method": true, "class_name": "Workbench", "function_description": "Registers a custom UI theme in the Tkinter style system by aggregating settings and images from inherited themes, then creating and applying the combined theme for consistent styling within the Workbench application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_apply_ui_theme", "line_number": 1278, "body": "def _apply_ui_theme(self, name: str) -> None:\n        self._current_theme_name = name\n        if name not in self._style.theme_names():\n            self._register_ui_theme_as_tk_theme(name)\n\n        self._style.theme_use(name)\n\n        # https://wiki.tcl.tk/37973#pagetocfe8b22ab\n        for setting in [\"background\", \"foreground\", \"selectBackground\", \"selectForeground\"]:\n            value = self._style.lookup(\"Listbox\", setting)\n            if value:\n                self.option_add(\"*TCombobox*Listbox.\" + setting, value)\n                self.option_add(\"*Listbox.\" + setting, value)\n\n        text_opts = self._style.configure(\"Text\")\n        if text_opts:\n            for key in text_opts:\n                self.option_add(\"*Text.\" + key, text_opts[key])\n\n        if hasattr(self, \"_menus\"):\n            # if menus have been initialized, ie. when theme is being changed\n            for menu in self._menus.values():\n                menu.configure(get_style_configuration(\"Menu\"))\n\n        self.update_fonts()", "is_method": true, "class_name": "Workbench", "function_description": "Sets and applies a specified UI theme to the Workbench, updating the styling of widgets and menus to reflect the selected look and feel. It ensures consistent appearance by configuring theme-related options and refreshing fonts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_apply_syntax_theme", "line_number": 1304, "body": "def _apply_syntax_theme(self, name: str) -> None:\n        def get_settings(name):\n            try:\n                parent, settings = self._syntax_themes[name]\n            except KeyError:\n                self.report_exception(\"Can't find theme '%s'\" % name)\n                return {}\n\n            if callable(settings):\n                settings = settings()\n\n            if parent is None:\n                return settings\n            else:\n                result = get_settings(parent)\n                for key in settings:\n                    if key in result:\n                        result[key].update(settings[key])\n                    else:\n                        result[key] = settings[key]\n                return result\n\n        from thonny import codeview\n\n        codeview.set_syntax_options(get_settings(name))", "is_method": true, "class_name": "Workbench", "function_description": "Applies a named syntax highlighting theme by retrieving and merging its settings, then updating the editor's syntax options accordingly to customize code appearance in the Workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "reload_themes", "line_number": 1330, "body": "def reload_themes(self) -> None:\n        preferred_theme = self.get_option(\"view.ui_theme\")\n        available_themes = self.get_usable_ui_theme_names()\n\n        if preferred_theme in available_themes:\n            self._apply_ui_theme(preferred_theme)\n        elif \"Enhanced Clam\" in available_themes:\n            self._apply_ui_theme(\"Enhanced Clam\")\n        elif \"Windows\" in available_themes:\n            self._apply_ui_theme(\"Windows\")\n\n        self._apply_syntax_theme(self.get_option(\"view.syntax_theme\"))", "is_method": true, "class_name": "Workbench", "function_description": "Reloads and applies the user\u2019s preferred UI and syntax themes, falling back to default themes if the preferred UI theme is unavailable to ensure consistent visual appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "uses_dark_ui_theme", "line_number": 1343, "body": "def uses_dark_ui_theme(self) -> bool:\n\n        name = self._style.theme_use()\n        while True:\n            if \"dark\" in name.lower():\n                return True\n\n            name, _, _ = self._ui_themes[name]\n            if name is None:\n                # reached start of the chain\n                break\n\n        return False", "is_method": true, "class_name": "Workbench", "function_description": "Checks whether the current or any parent UI theme in the Workbench uses a dark color scheme, enabling components to adapt their appearance accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_program_arguments_frame", "line_number": 1357, "body": "def _init_program_arguments_frame(self) -> None:\n        self.set_default(\"view.show_program_arguments\", False)\n        self.set_default(\"run.program_arguments\", \"\")\n        self.set_default(\"run.past_program_arguments\", [])\n\n        visibility_var = self.get_variable(\"view.show_program_arguments\")\n        content_var = self.get_variable(\"run.program_arguments\")\n\n        frame = ttk.Frame(self._toolbar)\n        col = 1000\n        self._toolbar.columnconfigure(col, weight=1)\n\n        label = ttk.Label(frame, text=tr(\"Program arguments:\"))\n        label.grid(row=0, column=0, sticky=\"nse\", padx=5)\n\n        self.program_arguments_box = ttk.Combobox(\n            frame,\n            width=80,\n            height=15,\n            textvariable=content_var,\n            values=[\"\"] + self.get_option(\"run.past_program_arguments\"),\n        )\n        self.program_arguments_box.grid(row=0, column=1, sticky=\"nsew\", padx=5)\n\n        frame.columnconfigure(1, weight=1)\n\n        def update_visibility():\n            if visibility_var.get():\n                if not frame.winfo_ismapped():\n                    frame.grid(row=0, column=col, sticky=\"nse\")\n            else:\n                if frame.winfo_ismapped():\n                    frame.grid_remove()\n\n        def toggle():\n            visibility_var.set(not visibility_var.get())\n            update_visibility()\n\n        self.add_command(\n            \"viewargs\",\n            \"view\",\n            tr(\"Program arguments\"),\n            toggle,\n            flag_name=\"view.show_program_arguments\",\n            group=11,\n        )\n\n        update_visibility()", "is_method": true, "class_name": "Workbench", "function_description": "Initializes and manages a toolbar frame in Workbench that displays and toggles the visibility of a program arguments input with history, enabling users to enter, recall, and control command-line arguments during program execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_regular_mode_link", "line_number": 1406, "body": "def _init_regular_mode_link(self):\n        if self.get_ui_mode() != \"simple\":\n            return\n\n        label = ttk.Label(\n            self._toolbar,\n            text=tr(\"Switch to\\nregular\\nmode\"),\n            justify=\"right\",\n            font=\"SmallLinkFont\",\n            style=\"Url.TLabel\",\n            cursor=\"hand2\",\n        )\n        label.grid(row=0, column=1001, sticky=\"ne\")\n\n        def on_click(event):\n            self.set_option(\"general.ui_mode\", \"regular\")\n            tk.messagebox.showinfo(\n                tr(\"Regular mode\"),\n                tr(\n                    \"Configuration has been updated. \"\n                    + \"Restart Thonny to start working in regular mode.\\n\\n\"\n                    + \"(See 'Tools \u2192 Options \u2192 General' if you change your mind later.)\"\n                ),\n                master=self,\n            )\n\n        label.bind(\"<1>\", on_click, True)", "is_method": true, "class_name": "Workbench", "function_description": "Utility method in Workbench that adds an interactive label allowing users in simple UI mode to switch to regular mode, guiding them through the configuration update and restart process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "log_program_arguments_string", "line_number": 1443, "body": "def log_program_arguments_string(self, arg_str: str) -> None:\n        arg_str = arg_str.strip()\n        self.set_option(\"run.program_arguments\", arg_str)\n\n        if arg_str == \"\":\n            # empty will be handled differently\n            return\n\n        past_args = self.get_option(\"run.past_program_arguments\")\n\n        if arg_str in past_args:\n            past_args.remove(arg_str)\n\n        past_args.insert(0, arg_str)\n        past_args = past_args[:10]\n\n        self.set_option(\"run.past_program_arguments\", past_args)\n        self.program_arguments_box.configure(values=[\"\"] + past_args)", "is_method": true, "class_name": "Workbench", "function_description": "Utility method of the Workbench class that records and manages a history of program argument strings, ensuring recent arguments are tracked and accessible for reuse or selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_show_views", "line_number": 1462, "body": "def _show_views(self) -> None:\n        for view_id in self._view_records:\n            if self._view_records[view_id][\"visibility_flag\"].get():\n                try:\n                    self.show_view(view_id, False)\n                except Exception:\n                    self.report_exception(\"Problem showing \" + view_id)", "is_method": true, "class_name": "Workbench", "function_description": "Core internal method of the Workbench class that displays all currently visible views, handling exceptions to ensure continuous operation during the rendering process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "update_image_mapping", "line_number": 1470, "body": "def update_image_mapping(self, mapping: Dict[str, str]) -> None:\n        \"\"\"Was used by thonny-pi. Not recommended anymore\"\"\"\n        self._default_image_mapping.update(mapping)", "is_method": true, "class_name": "Workbench", "function_description": "Updates the default image mapping dictionary with new key-value pairs, maintaining the association between image identifiers and their corresponding paths or names. Primarily used for managing image references within the Workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_backends", "line_number": 1474, "body": "def get_backends(self) -> Dict[str, BackendSpec]:\n        return self._backends", "is_method": true, "class_name": "Workbench", "function_description": "Returns the dictionary of backend specifications managed by the Workbench, providing access to all available backend configurations for further use or inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_option", "line_number": 1477, "body": "def get_option(self, name: str, default=None) -> Any:\n        # Need to return Any, otherwise each typed call site needs to cast\n        return self._configuration_manager.get_option(name, default)", "is_method": true, "class_name": "Workbench", "function_description": "Utility method in Workbench that retrieves a configuration option by name, returning a default value if the option is not set. It provides flexible access to configuration settings for other components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "set_option", "line_number": 1481, "body": "def set_option(self, name: str, value: Any) -> None:\n        self._configuration_manager.set_option(name, value)", "is_method": true, "class_name": "Workbench", "function_description": "Sets or updates a configuration option within the Workbench's configuration manager, allowing customization of Workbench behavior or settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_local_cwd", "line_number": 1484, "body": "def get_local_cwd(self) -> str:\n        cwd = self.get_option(\"run.working_directory\")\n        if os.path.exists(cwd):\n            return normpath_with_actual_case(cwd)\n        else:\n            return normpath_with_actual_case(os.path.expanduser(\"~\"))", "is_method": true, "class_name": "Workbench", "function_description": "Provides the current working directory for the Workbench, returning a configured path if valid or the user's home directory as a fallback. This supports consistent environment setup for running tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "set_local_cwd", "line_number": 1491, "body": "def set_local_cwd(self, value: str) -> None:\n        if self.get_option(\"run.working_directory\") != value:\n            self.set_option(\"run.working_directory\", value)\n            if value:\n                self.event_generate(\"LocalWorkingDirectoryChanged\", cwd=value)", "is_method": true, "class_name": "Workbench", "function_description": "Sets and updates the local working directory if changed, triggering an event to notify other components about the update. Useful for managing and synchronizing the execution environment's current directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "set_default", "line_number": 1497, "body": "def set_default(self, name: str, default_value: Any) -> None:\n        \"\"\"Registers a new option.\n\n        If the name contains a period, then the part left to the (first) period\n        will become the section of the option and rest will become name under that\n        section.\n\n        If the name doesn't contain a period, then it will be added under section\n        \"general\".\n        \"\"\"\n        self._configuration_manager.set_default(name, default_value)", "is_method": true, "class_name": "Workbench", "function_description": "Registers a default configuration option by assigning it to a section based on its name format, enabling organized and hierarchical management of settings within the Workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_variable", "line_number": 1509, "body": "def get_variable(self, name: str) -> tk.Variable:\n        return self._configuration_manager.get_variable(name)", "is_method": true, "class_name": "Workbench", "function_description": "Utility method of the Workbench class that retrieves a stored tkinter variable by name from the configuration manager. It enables access to GUI-related state or configuration values for other functions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_menu", "line_number": 1512, "body": "def get_menu(self, name: str, label: Optional[str] = None) -> tk.Menu:\n        \"\"\"Gives the menu with given name. Creates if not created yet.\n\n        Args:\n            name: meant to be used as not translatable menu name\n            label: translated label, used only when menu with given name doesn't exist yet\n        \"\"\"\n\n        # For compatibility with plug-ins\n        if name in [\"device\", \"tempdevice\"] and label is None:\n            label = tr(\"Device\")\n\n        if name not in self._menus:\n            if running_on_mac_os():\n                conf = {}\n            else:\n                conf = get_style_configuration(\"Menu\")\n\n            menu = tk.Menu(self._menubar, **conf)\n            menu[\"postcommand\"] = lambda: self._update_menu(menu, name)\n            self._menubar.add_cascade(label=label if label else name, menu=menu)\n\n            self._menus[name] = menu\n            if label:\n                self._menus[label] = menu\n\n        return self._menus[name]", "is_method": true, "class_name": "Workbench", "function_description": "Provides or creates a tkinter menu by name, assigning a translated label if given, and caches it for reuse. This enables dynamic menu retrieval and on-demand creation within the Workbench GUI framework."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_view", "line_number": 1540, "body": "def get_view(self, view_id: str, create: bool = True) -> tk.Widget:\n        if \"instance\" not in self._view_records[view_id]:\n            if not create:\n                raise RuntimeError(\"View %s not created\" % view_id)\n            class_ = self._view_records[view_id][\"class\"]\n            location = self._view_records[view_id][\"location\"]\n            master = self._view_notebooks[location]\n\n            # create the view\n            view = class_(self)  # View's master is workbench to allow making it maximized\n            view.position_key = self._view_records[view_id][\"position_key\"]\n            self._view_records[view_id][\"instance\"] = view\n\n            # create the view home_widget to be added into notebook\n            view.home_widget = ttk.Frame(master)\n            view.home_widget.columnconfigure(0, weight=1)\n            view.home_widget.rowconfigure(0, weight=1)\n            view.home_widget.maximizable_widget = view  # type: ignore\n            view.home_widget.close = lambda: self.hide_view(view_id)  # type: ignore\n            if hasattr(view, \"position_key\"):\n                view.home_widget.position_key = view.position_key  # type: ignore\n\n            # initially the view will be in it's home_widget\n            view.grid(row=0, column=0, sticky=tk.NSEW, in_=view.home_widget)\n            view.hidden = True\n\n        return self._view_records[view_id][\"instance\"]", "is_method": true, "class_name": "Workbench", "function_description": "Utility method of the Workbench class that retrieves an existing view widget by ID or creates it if missing, facilitating dynamic management and display of GUI views within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_editor_notebook", "line_number": 1568, "body": "def get_editor_notebook(self) -> EditorNotebook:\n        assert self._editor_notebook is not None\n        return self._editor_notebook", "is_method": true, "class_name": "Workbench", "function_description": "Returns the current EditorNotebook instance managed by the Workbench, providing access to the active notebook for editing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_package_dir", "line_number": 1572, "body": "def get_package_dir(self):\n        \"\"\"Returns thonny package directory\"\"\"\n        return os.path.dirname(sys.modules[\"thonny\"].__file__)", "is_method": true, "class_name": "Workbench", "function_description": "Utility method of the Workbench class that returns the file system directory path of the 'thonny' package installation. It enables other components to locate package resources or files dynamically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_image", "line_number": 1576, "body": "def get_image(\n        self, filename: str, tk_name: Optional[str] = None, disabled=False\n    ) -> tk.PhotoImage:\n\n        if filename in self._image_mapping_by_theme[self._current_theme_name]:\n            filename = self._image_mapping_by_theme[self._current_theme_name][filename]\n\n        if filename in self._default_image_mapping:\n            filename = self._default_image_mapping[filename]\n\n        # if path is relative then interpret it as living in res folder\n        if not os.path.isabs(filename):\n            filename = os.path.join(self.get_package_dir(), \"res\", filename)\n            if not os.path.exists(filename):\n                if os.path.exists(filename + \".png\"):\n                    filename = filename + \".png\"\n                elif os.path.exists(filename + \".gif\"):\n                    filename = filename + \".gif\"\n\n        if disabled:\n            filename = os.path.join(\n                os.path.dirname(filename), \"_disabled_\" + os.path.basename(filename)\n            )\n            if not os.path.exists(filename):\n                return None\n\n        # are there platform-specific variants?\n        plat_filename = filename[:-4] + \"_\" + platform.system() + \".png\"\n        if os.path.exists(plat_filename):\n            filename = plat_filename\n\n        if self._scaling_factor >= 2.0:\n            scaled_filename = filename[:-4] + \"_2x.png\"\n            if os.path.exists(scaled_filename):\n                filename = scaled_filename\n            else:\n                img = tk.PhotoImage(file=filename)\n                # can't use zoom method, because this doesn't allow name\n                img2 = tk.PhotoImage(tk_name)\n                self.tk.call(\n                    img2,\n                    \"copy\",\n                    img.name,\n                    \"-zoom\",\n                    int(self._scaling_factor),\n                    int(self._scaling_factor),\n                )\n                self._images.add(img2)\n                return img2\n\n        img = tk.PhotoImage(tk_name, file=filename)\n        self._images.add(img)\n        return img", "is_method": true, "class_name": "Workbench", "function_description": "Utility method of the Workbench class that loads and returns a Tkinter PhotoImage object for a given filename, applying theme, platform, scaling, and disabled state adjustments to support dynamic UI image retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "show_view", "line_number": 1630, "body": "def show_view(self, view_id: str, set_focus: bool = True) -> Union[bool, tk.Widget]:\n        \"\"\"View must be already registered.\n\n        Args:\n            view_id: View class name\n            without package name (eg. 'ShellView')\"\"\"\n\n        if view_id == \"MainFileBrowser\":\n            # Was renamed in 3.1.1\n            view_id = \"FilesView\"\n\n        # NB! Don't forget that view.home_widget is added to notebook, not view directly\n        # get or create\n        view = self.get_view(view_id)\n        notebook = view.home_widget.master  # type: ignore\n\n        if hasattr(view, \"before_show\") and view.before_show() == False:  # type: ignore\n            return False\n\n        if view.hidden:  # type: ignore\n            notebook.insert(\n                \"auto\", view.home_widget, text=self._view_records[view_id][\"label\"]  # type: ignore\n            )\n            view.hidden = False  # type: ignore\n            if hasattr(view, \"on_show\"):  # type: ignore\n                view.on_show()\n\n        # switch to the tab\n        notebook.select(view.home_widget)  # type: ignore\n\n        # add focus\n        if set_focus:\n            view.focus_set()\n\n        self.set_option(\"view.\" + view_id + \".visible\", True)\n        self.event_generate(\"ShowView\", view=view, view_id=view_id)\n        return view", "is_method": true, "class_name": "Workbench", "function_description": "Provides functionality to display a registered view in the Workbench interface, optionally setting focus and handling visibility state changes, enabling dynamic management of UI components and user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "hide_view", "line_number": 1668, "body": "def hide_view(self, view_id: str) -> Union[bool, None]:\n        # NB! Don't forget that view.home_widget is added to notebook, not view directly\n\n        if \"instance\" in self._view_records[view_id]:\n            # TODO: handle the case, when view is maximized\n            view = self._view_records[view_id][\"instance\"]\n            if view.hidden:\n                return True\n\n            if hasattr(view, \"before_hide\") and view.before_hide() == False:\n                return False\n\n            view.home_widget.master.forget(view.home_widget)\n            self.set_option(\"view.\" + view_id + \".visible\", False)\n\n            self.event_generate(\"HideView\", view=view, view_id=view_id)\n            view.hidden = True\n\n        return True", "is_method": true, "class_name": "Workbench", "function_description": "Core method of the Workbench class that hides a specified view by removing its widget from the interface and updating its visibility state, supporting UI management and customization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "event_generate", "line_number": 1688, "body": "def event_generate(self, sequence: str, event: Optional[Record] = None, **kwargs) -> None:\n        \"\"\"Uses custom event handling when sequence doesn't start with <.\n        In this case arbitrary attributes can be added to the event.\n        Otherwise forwards the call to Tk's event_generate\"\"\"\n        # pylint: disable=arguments-differ\n        if sequence.startswith(\"<\"):\n            assert event is None\n            tk.Tk.event_generate(self, sequence, **kwargs)\n        else:\n            if sequence in self._event_handlers:\n                if event is None:\n                    event = WorkbenchEvent(sequence, **kwargs)\n                else:\n                    event.update(kwargs)\n\n                # make a copy of handlers, so that event handler can remove itself\n                # from the registry during iteration\n                # (or new handlers can be added)\n                for handler in sorted(self._event_handlers[sequence].copy(), key=str):\n                    try:\n                        handler(event)\n                    except Exception:\n                        self.report_exception(\"Problem when handling '\" + sequence + \"'\")\n\n        if not self._closing:\n            self._update_toolbar()", "is_method": true, "class_name": "Workbench", "function_description": "Custom event generator for the Workbench class that triggers user-defined handlers for non-< sequences, while forwarding standard events to Tkinter\u2019s event system. It supports event attribute customization and safely manages dynamic handler modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "bind", "line_number": 1715, "body": "def bind(self, sequence: str, func: Callable, add: bool = None) -> None:  # type: ignore\n        \"\"\"Uses custom event handling when sequence doesn't start with <.\n        Otherwise forwards the call to Tk's bind\"\"\"\n        # pylint: disable=signature-differs\n\n        if not add:\n            logging.warning(\n                \"Workbench.bind({}, ..., add={}) -- did you really want to replace existing bindings?\".format(\n                    sequence, add\n                )\n            )\n\n        if sequence.startswith(\"<\"):\n            tk.Tk.bind(self, sequence, func, add)\n        else:\n            if sequence not in self._event_handlers or not add:\n                self._event_handlers[sequence] = set()\n\n            self._event_handlers[sequence].add(func)", "is_method": true, "class_name": "Workbench", "function_description": "Provides a method to register event handlers by differentiating between standard Tkinter events and custom events, allowing flexible binding and management of function callbacks in the Workbench GUI environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "unbind", "line_number": 1735, "body": "def unbind(self, sequence: str, func=None) -> None:\n        # pylint: disable=arguments-differ\n        if sequence.startswith(\"<\"):\n            tk.Tk.unbind(self, sequence, funcid=func)\n        else:\n            try:\n                self._event_handlers[sequence].remove(func)\n            except Exception:\n                logger.exception(\"Can't remove binding for '%s' and '%s'\", sequence, func)", "is_method": true, "class_name": "Workbench", "function_description": "Unbind method in Workbench removes an event handler for a given event sequence, handling both widget-level and internal bindings. It enables dynamic management of event-function associations within the Workbench UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "in_heap_mode", "line_number": 1745, "body": "def in_heap_mode(self) -> bool:\n        # TODO: add a separate command for enabling the heap mode\n        # untie the mode from HeapView\n\n        return self._configuration_manager.has_option(\"view.HeapView.visible\") and self.get_option(\n            \"view.HeapView.visible\"\n        )", "is_method": true, "class_name": "Workbench", "function_description": "Returns whether the Workbench is currently configured to display the HeapView mode, indicating if the heap visualization feature is enabled."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "in_debug_mode", "line_number": 1753, "body": "def in_debug_mode(self) -> bool:\n        return (\n            os.environ.get(\"THONNY_DEBUG\", False)\n            in [\n                \"1\",\n                1,\n                \"True\",\n                True,\n                \"true\",\n            ]\n            or self.get_option(\"general.debug_mode\", False)\n        )", "is_method": true, "class_name": "Workbench", "function_description": "Checks whether the Workbench is running in debug mode by inspecting environment variables or configuration options, enabling conditional debugging behaviors within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_scaling", "line_number": 1766, "body": "def _init_scaling(self) -> None:\n        self._default_scaling_factor = self.tk.call(\"tk\", \"scaling\")\n        if self._default_scaling_factor > 10:\n            # it may be infinity in eg. Fedora\n            self._default_scaling_factor = 1.33\n\n        scaling = self.get_option(\"general.scaling\")\n        if scaling in [\"default\", \"auto\"]:  # auto was used in 2.2b3\n            self._scaling_factor = self._default_scaling_factor\n        else:\n            self._scaling_factor = float(scaling)\n\n        MAC_SCALING_MODIFIER = 1.7\n        if running_on_mac_os():\n            self._scaling_factor *= MAC_SCALING_MODIFIER\n\n        self.tk.call(\"tk\", \"scaling\", self._scaling_factor)\n\n        font_scaling_mode = self.get_option(\"general.font_scaling_mode\")\n\n        if (\n            running_on_linux()\n            and font_scaling_mode in [\"default\", \"extra\"]\n            and scaling not in [\"default\", \"auto\"]\n        ):\n            # update system fonts which are given in pixel sizes\n            for name in tk_font.names():\n                f = tk_font.nametofont(name)\n                orig_size = f.cget(\"size\")\n                # According to do documentation, absolute values of negative font sizes\n                # should be interpreted as pixel sizes (not affected by \"tk scaling\")\n                # and positive values are point sizes, which are supposed to scale automatically\n                # http://www.tcl.tk/man/tcl8.6/TkCmd/font.htm#M26\n\n                # Unfortunately it seems that this cannot be relied on\n                # https://groups.google.com/forum/#!msg/comp.lang.tcl/ZpL6tq77M4M/GXImiV2INRQJ\n\n                # My experiments show that manually changing negative font sizes\n                # doesn't have any effect -- fonts keep their default size\n                # (Tested in Raspbian Stretch, Ubuntu 18.04 and Fedora 29)\n                # On the other hand positive sizes scale well (and they don't scale automatically)\n\n                # convert pixel sizes to point_size\n                if orig_size < 0:\n                    orig_size = -orig_size / self._default_scaling_factor\n\n                # scale\n                scaled_size = round(\n                    orig_size * (self._scaling_factor / self._default_scaling_factor)\n                )\n                f.configure(size=scaled_size)\n\n        elif running_on_mac_os() and scaling not in [\"default\", \"auto\"]:\n            # see http://wiki.tcl.tk/44444\n            # update system fonts\n            for name in tk_font.names():\n                f = tk_font.nametofont(name)\n                orig_size = f.cget(\"size\")\n                assert orig_size > 0\n                f.configure(size=int(orig_size * self._scaling_factor / MAC_SCALING_MODIFIER))", "is_method": true, "class_name": "Workbench", "function_description": "Initializes and applies a UI scaling factor based on system defaults, user options, and platform specifics to adjust overall interface and font sizes within the Workbench application for consistent visual appearance across environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "update_fonts", "line_number": 1827, "body": "def update_fonts(self) -> None:\n        editor_font_size = self._guard_font_size(self.get_option(\"view.editor_font_size\"))\n        editor_font_family = self.get_option(\"view.editor_font_family\")\n\n        io_font_size = self._guard_font_size(self.get_option(\"view.io_font_size\"))\n        io_font_family = self.get_option(\"view.io_font_family\")\n        for io_name in [\n            \"IOFont\",\n            \"BoldIOFont\",\n            \"UnderlineIOFont\",\n            \"ItalicIOFont\",\n            \"BoldItalicIOFont\",\n        ]:\n            tk_font.nametofont(io_name).configure(family=io_font_family, size=io_font_size)\n\n        try:\n            shell = self.get_view(\"ShellView\", create=False)\n        except Exception:\n            # shell may be not created yet\n            pass\n        else:\n            shell.update_tabs()\n\n        tk_font.nametofont(\"EditorFont\").configure(family=editor_font_family, size=editor_font_size)\n        tk_font.nametofont(\"SmallEditorFont\").configure(\n            family=editor_font_family, size=editor_font_size - 2\n        )\n        tk_font.nametofont(\"BoldEditorFont\").configure(\n            family=editor_font_family, size=editor_font_size\n        )\n        tk_font.nametofont(\"ItalicEditorFont\").configure(\n            family=editor_font_family, size=editor_font_size\n        )\n        tk_font.nametofont(\"BoldItalicEditorFont\").configure(\n            family=editor_font_family, size=editor_font_size\n        )\n\n        if self.get_ui_mode() == \"simple\":\n            default_size_factor = max(0.7, 1 - (editor_font_size - 10) / 25)\n            small_size_factor = max(0.6, 0.8 - (editor_font_size - 10) / 25)\n\n            tk_font.nametofont(\"TkDefaultFont\").configure(\n                size=round(editor_font_size * default_size_factor)\n            )\n            tk_font.nametofont(\"TkHeadingFont\").configure(\n                size=round(editor_font_size * default_size_factor)\n            )\n            tk_font.nametofont(\"SmallLinkFont\").configure(\n                size=round(editor_font_size * small_size_factor)\n            )\n\n        # Update Treeview font and row height\n        if running_on_mac_os():\n            treeview_font_size = int(editor_font_size * 0.7 + 4)\n        else:\n            treeview_font_size = int(editor_font_size * 0.7 + 2)\n\n        treeview_font = tk_font.nametofont(\"TreeviewFont\")\n        treeview_font.configure(size=treeview_font_size)\n        rowheight = round(treeview_font.metrics(\"linespace\") * 1.2)\n\n        style = ttk.Style()\n        style.configure(\"Treeview\", rowheight=rowheight)\n\n        if self._editor_notebook is not None:\n            self._editor_notebook.update_appearance()", "is_method": true, "class_name": "Workbench", "function_description": "Updates and applies font families and sizes across the Workbench UI components, including editors, I/O panes, and treeviews, ensuring consistent appearance and adapting to user settings and platform specifics."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_get_menu_index", "line_number": 1894, "body": "def _get_menu_index(self, menu: tk.Menu) -> int:\n        for i in range(len(self._menubar.winfo_children())):\n            if menu == self._menubar.winfo_children()[i]:\n                return i\n\n        raise RuntimeError(\"Couldn't find menu\")", "is_method": true, "class_name": "Workbench", "function_description": "Utility method in Workbench that finds the position index of a given menu within the menubar's children, raising an error if the menu is not found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_add_toolbar_button", "line_number": 1901, "body": "def _add_toolbar_button(\n        self,\n        command_id: str,\n        image: Optional[tk.PhotoImage],\n        disabled_image: Optional[tk.PhotoImage],\n        command_label: str,\n        caption: str,\n        alternative_caption: str,\n        accelerator: Optional[str],\n        handler: Callable[[], None],\n        tester: Optional[Callable[[], bool]],\n        toolbar_group: int,\n    ) -> None:\n\n        assert caption is not None and len(caption) > 0, (\n            \"Missing caption for '%s'. Toolbar commands must have caption.\" % command_label\n        )\n        slaves = self._toolbar.grid_slaves(0, toolbar_group)\n        if len(slaves) == 0:\n            group_frame = ttk.Frame(self._toolbar)\n            if self.in_simple_mode():\n                padx = 0  # type: Union[int, Tuple[int, int]]\n            else:\n                padx = (0, 10)\n            group_frame.grid(row=0, column=toolbar_group, padx=padx)\n        else:\n            group_frame = slaves[0]\n\n        if self.in_simple_mode():\n            screen_width = self.winfo_screenwidth()\n            if screen_width >= 1280:\n                button_width = max(7, len(caption), len(alternative_caption))\n            elif screen_width >= 1024:\n                button_width = max(6, len(caption), len(alternative_caption))\n            else:\n                button_width = max(5, len(caption), len(alternative_caption))\n        else:\n            button_width = None\n\n        if disabled_image is not None:\n            image_spec = [image, \"disabled\", disabled_image]\n        else:\n            image_spec = image\n\n        button = ttk.Button(\n            group_frame,\n            image=image_spec,\n            style=\"Toolbutton\",\n            state=tk.NORMAL,\n            text=caption,\n            compound=\"top\" if self.in_simple_mode() else None,\n            pad=(10, 0) if self.in_simple_mode() else None,\n            width=button_width,\n        )\n\n        def toolbar_handler(*args):\n            handler(*args)\n            self._update_toolbar()\n            if self.focus_get() == button:\n                # previously selected widget would be better candidate, but this is\n                # better than button\n                self._editor_notebook.focus_set()\n\n        button.configure(command=toolbar_handler)\n\n        button.pack(side=tk.LEFT)\n        button.tester = tester  # type: ignore\n        tooltip_text = command_label\n        if self.get_ui_mode() != \"simple\":\n            if accelerator and lookup_style_option(\n                \"OPTIONS\", \"shortcuts_in_tooltips\", default=True\n            ):\n                tooltip_text += \" (\" + accelerator + \")\"\n            create_tooltip(button, tooltip_text)\n\n        self._toolbar_buttons[command_id] = button", "is_method": true, "class_name": "Workbench", "function_description": "Method of the Workbench class that adds a command button to a toolbar group, configuring its appearance, behavior, and tooltip; it supports dynamic enabling via a tester and adapts layout for simple or normal UI modes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_toolbar_button", "line_number": 1978, "body": "def get_toolbar_button(self, command_id):\n        return self._toolbar_buttons[command_id]", "is_method": true, "class_name": "Workbench", "function_description": "Utility method in Workbench that retrieves a toolbar button by its command identifier, enabling access to specific UI controls for command execution or manipulation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_update_toolbar", "line_number": 1981, "body": "def _update_toolbar(self, event=None) -> None:\n        if self._destroyed or not hasattr(self, \"_toolbar\"):\n            return\n\n        if self._toolbar.winfo_ismapped():\n            for group_frame in self._toolbar.grid_slaves(0):\n                for button in group_frame.pack_slaves():\n                    if thonny._runner is None or button.tester and not button.tester():\n                        button[\"state\"] = tk.DISABLED\n                    else:\n                        button[\"state\"] = tk.NORMAL", "is_method": true, "class_name": "Workbench", "function_description": "Private method of the Workbench class that updates the enabled or disabled state of toolbar buttons based on the current runtime conditions, ensuring the toolbar reflects the application's active status appropriately."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_cmd_zoom_with_mouse", "line_number": 1993, "body": "def _cmd_zoom_with_mouse(self, event) -> None:\n        if event.delta > 0:\n            self._change_font_size(1)\n        else:\n            self._change_font_size(-1)", "is_method": true, "class_name": "Workbench", "function_description": "Utility method in Workbench that adjusts font size based on mouse scroll direction, enabling intuitive zooming via mouse wheel events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_toggle_font_size", "line_number": 1999, "body": "def _toggle_font_size(self) -> None:\n        current_size = self.get_option(\"view.editor_font_size\")\n\n        if self.winfo_screenwidth() < 1024:\n            # assuming 32x32 icons\n            small_size = 10\n            medium_size = 12\n            large_size = 14\n        elif self.winfo_screenwidth() < 1280:\n            # assuming 32x32 icons\n            small_size = 12\n            medium_size = 14\n            large_size = 18\n        else:\n            small_size = 12\n            medium_size = 16\n            large_size = 20\n\n        widths = {10: 800, 12: 1050, 14: 1200, 16: 1300, 18: 1400, 20: 1650}\n\n        if current_size < small_size or current_size >= large_size:\n            new_size = small_size\n        elif current_size < medium_size:\n            new_size = medium_size\n        else:\n            new_size = large_size\n\n        self._change_font_size(new_size - current_size)\n\n        new_width = min(widths[new_size], self.winfo_screenwidth())\n        geo = re.findall(r\"\\d+\", self.wm_geometry())\n        self.geometry(\"{0}x{1}+{2}+{3}\".format(new_width, geo[1], geo[2], geo[3]))", "is_method": true, "class_name": "Workbench", "function_description": "Private method of the Workbench class that cycles through predefined font sizes based on screen width, adjusting the editor's font size and window geometry to optimize display readability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_change_font_size", "line_number": 2032, "body": "def _change_font_size(self, delta: int) -> None:\n\n        if delta != 0:\n            editor_font_size = self.get_option(\"view.editor_font_size\")\n            editor_font_size += delta\n            self.set_option(\"view.editor_font_size\", self._guard_font_size(editor_font_size))\n            io_font_size = self.get_option(\"view.io_font_size\")\n            io_font_size += delta\n            self.set_option(\"view.io_font_size\", self._guard_font_size(io_font_size))\n            self.update_fonts()", "is_method": true, "class_name": "Workbench", "function_description": "Private method of the Workbench class that adjusts editor and I/O font sizes by a given amount, ensuring sizes stay within allowed limits and updating the display accordingly. It supports dynamic font size modifications in the UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_guard_font_size", "line_number": 2043, "body": "def _guard_font_size(self, size: int) -> int:\n        # https://bitbucket.org/plas/thonny/issues/164/negative-font-size-crashes-thonny\n        MIN_SIZE = 4\n        MAX_SIZE = 200\n        if size < MIN_SIZE:\n            return MIN_SIZE\n        elif size > MAX_SIZE:\n            return MAX_SIZE\n        else:\n            return size", "is_method": true, "class_name": "Workbench", "function_description": "Internal method of the Workbench class that ensures a font size stays within a defined minimum and maximum range, preventing invalid or out-of-bounds font size values."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_check_update_window_width", "line_number": 2054, "body": "def _check_update_window_width(self, delta: int) -> None:\n        if not ui_utils.get_zoomed(self):\n            self.update_idletasks()\n            # TODO: shift to left if right edge goes away from screen\n            # TODO: check with screen width\n            new_geometry = \"{0}x{1}+{2}+{3}\".format(\n                self.winfo_width() + delta, self.winfo_height(), self.winfo_x(), self.winfo_y()\n            )\n\n            self.geometry(new_geometry)", "is_method": true, "class_name": "Workbench", "function_description": "Private method of the Workbench class that adjusts the window's width by a given amount unless the UI is zoomed, updating the window geometry to reflect the size change."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_maximize_view", "line_number": 2065, "body": "def _maximize_view(self, event=None) -> None:\n        if self._maximized_view is not None:\n            return\n\n        # find the widget that can be relocated\n        widget = self.focus_get()\n        if isinstance(widget, (EditorNotebook, AutomaticNotebook)):\n            current_tab = widget.get_current_child()\n            if current_tab is None:\n                return\n\n            if not hasattr(current_tab, \"maximizable_widget\"):\n                return\n\n            widget = current_tab.maximizable_widget\n\n        while widget is not None:\n            if hasattr(widget, \"home_widget\"):\n                # if widget is view, then widget.master is workbench\n                widget.grid(row=1, column=0, sticky=tk.NSEW, in_=widget.master)  # type: ignore\n                # hide main_frame\n                self._main_frame.grid_forget()\n                self._maximized_view = widget\n                self.get_variable(\"view.maximize_view\").set(True)\n                break\n            else:\n                widget = widget.master", "is_method": true, "class_name": "Workbench", "function_description": "Utility method of Workbench that maximizes the currently focused view widget, hiding other interface elements to provide an expanded workspace for focused content display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_unmaximize_view", "line_number": 2093, "body": "def _unmaximize_view(self, event=None) -> None:\n        if self._maximized_view is None:\n            return\n\n        # restore main_frame\n        self._main_frame.grid(row=1, column=0, sticky=tk.NSEW, in_=self)\n        # put the maximized view back to its home_widget\n        self._maximized_view.grid(\n            row=0, column=0, sticky=tk.NSEW, in_=self._maximized_view.home_widget  # type: ignore\n        )\n        self._maximized_view = None\n        self.get_variable(\"view.maximize_view\").set(False)", "is_method": true, "class_name": "Workbench", "function_description": "Restores the user interface from a maximized view to its original layout by repositioning the main frame and the previously maximized component within the Workbench. Useful for toggling view states in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "show_options", "line_number": 2106, "body": "def show_options(self, page_key=None):\n        dlg = ConfigurationDialog(self, self._configuration_pages)\n        if page_key:\n            dlg.select_page(page_key)\n\n        ui_utils.show_dialog(dlg)\n\n        if dlg.backend_restart_required:\n            get_runner().restart_backend(False)", "is_method": true, "class_name": "Workbench", "function_description": "Method of the Workbench class that displays a configuration dialog, optionally focusing on a specific page, and triggers a backend restart if required after changes. It facilitates user configuration management within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_cmd_focus_editor", "line_number": 2116, "body": "def _cmd_focus_editor(self) -> None:\n        self.get_editor_notebook().focus_set()", "is_method": true, "class_name": "Workbench", "function_description": "Private method of the Workbench class that sets input focus to the editor notebook, ensuring user interaction is directed there. It supports UI navigation by programmatically focusing the editor component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_cmd_focus_shell", "line_number": 2119, "body": "def _cmd_focus_shell(self) -> None:\n        self.show_view(\"ShellView\", True)\n        shell = get_shell()\n        # go to the end of any current input\n        shell.text.mark_set(\"insert\", \"end\")\n        shell.text.see(\"insert\")", "is_method": true, "class_name": "Workbench", "function_description": "Private method in Workbench that activates and focuses the shell view, positioning the cursor at the end of the current input to prepare for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_cmd_toggle_full_screen", "line_number": 2126, "body": "def _cmd_toggle_full_screen(self) -> None:\n        \"\"\"\n        TODO: For mac\n        http://wiki.tcl.tk/44444\n\n        Switching a window to fullscreen mode\n        (Normal Difference)\n        To switch a window to fullscreen mode, the window must first be withdrawn.\n              # For Linux/Mac OS X:\n\n              set cfs [wm attributes $w -fullscreen]\n              if { $::tcl_platform(os) eq \"Darwin\" } {\n                if { $cfs == 0 } {\n                  # optional: save the window geometry\n                  set savevar [wm geometry $w]\n                }\n                wm withdraw $w\n              }\n              wm attributes $w -fullscreen [expr {1-$cfs}]\n              if { $::tcl_platform(os) eq \"Darwin\" } {\n                wm deiconify $w\n                if { $cfs == 1 } {\n                  after idle [list wm geometry $w $savevar]\n                }\n              }\n\n        \"\"\"\n        var = self.get_variable(\"view.full_screen\")\n        var.set(not var.get())\n        self.attributes(\"-fullscreen\", var.get())", "is_method": true, "class_name": "Workbench", "function_description": "Private method of the Workbench class that toggles the application window between fullscreen and normal display modes. It manages fullscreen state changes, including special handling for macOS environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_cmd_toggle_maximize_view", "line_number": 2157, "body": "def _cmd_toggle_maximize_view(self) -> None:\n        if self._maximized_view is not None:\n            self._unmaximize_view()\n        else:\n            self._maximize_view()", "is_method": true, "class_name": "Workbench", "function_description": "Toggles the Workbench's view between maximized and normal states, allowing users to switch focus on the workspace display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_update_menu", "line_number": 2163, "body": "def _update_menu(self, menu: tk.Menu, menu_name: str) -> None:\n        if menu.index(\"end\") is None:\n            return\n\n        for i in range(menu.index(\"end\") + 1):\n            item_data = menu.entryconfigure(i)\n            if \"label\" in item_data:\n                command_label = menu.entrycget(i, \"label\")\n                if (menu_name, command_label) not in self._menu_item_specs:\n                    continue\n                tester = self._menu_item_specs[(menu_name, command_label)].tester\n\n                enabled = not tester\n                if tester:\n                    try:\n                        enabled = tester()\n                    except Exception as e:\n                        logging.exception(\n                            \"Could not check command tester for '%s'\", item_data, exc_info=e\n                        )\n                        traceback.print_exc()\n                        enabled = False\n\n                if enabled:\n                    menu.entryconfigure(i, state=tk.NORMAL)\n                else:\n                    menu.entryconfigure(i, state=tk.DISABLED)", "is_method": true, "class_name": "Workbench", "function_description": "Updates the enabled/disabled state of menu items based on their associated tester functions, ensuring the menu reflects current conditions dynamically in the Workbench interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_find_location_for_menu_item", "line_number": 2191, "body": "def _find_location_for_menu_item(self, menu_name: str, command_label: str) -> Union[str, int]:\n\n        menu = self.get_menu(menu_name)\n\n        if menu.index(\"end\") == None:  # menu is empty\n            return \"end\"\n\n        specs = self._menu_item_specs[(menu_name, command_label)]\n\n        this_group_exists = False\n        for i in range(0, menu.index(\"end\") + 1):\n            data = menu.entryconfigure(i)\n            if \"label\" in data:\n                # it's a command, not separator\n                sibling_label = menu.entrycget(i, \"label\")\n                sibling_group = self._menu_item_specs[(menu_name, sibling_label)].group\n\n                if sibling_group == specs.group:\n                    this_group_exists = True\n                    if specs.position_in_group == \"alphabetic\" and sibling_label > command_label:\n                        return i\n\n                if sibling_group > specs.group:\n                    assert (\n                        not this_group_exists\n                    )  # otherwise we would have found the ending separator\n                    menu.insert_separator(i)\n                    return i\n            else:\n                # We found a separator\n                if this_group_exists:\n                    # it must be the ending separator for this group\n                    return i\n\n        # no group was bigger, ie. this should go to the end\n        if not this_group_exists:\n            menu.add_separator()\n\n        return \"end\"", "is_method": true, "class_name": "Workbench", "function_description": "Determines the appropriate position to insert a menu item within a menu based on grouping and alphabetical order. This enables organized, context-aware menu construction in the Workbench interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_poll_ipc_requests", "line_number": 2231, "body": "def _poll_ipc_requests(self) -> None:\n        try:\n            if self._ipc_requests.empty():\n                return\n\n            while not self._ipc_requests.empty():\n                args = self._ipc_requests.get()\n                try:\n                    for filename in args:\n                        if os.path.isfile(filename):\n                            self.get_editor_notebook().show_file(filename)\n\n                except Exception as e:\n                    logger.exception(\"Problem processing ipc request\", exc_info=e)\n\n            self.become_active_window()\n        finally:\n            self.after(50, self._poll_ipc_requests)", "is_method": true, "class_name": "Workbench", "function_description": "Continuously processes inter-process communication requests by opening valid files in the editor and reactivating the window, supporting seamless external file loading within the Workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_close", "line_number": 2250, "body": "def _on_close(self) -> None:\n        if self._editor_notebook and not self._editor_notebook.check_allow_closing():\n            return\n\n        self._closing = True\n        try:\n            self._save_layout()\n            self._editor_notebook.remember_open_files()\n            self.event_generate(\"WorkbenchClose\")\n            self._configuration_manager.save()\n            temp_dir = self.get_temp_dir(create_if_doesnt_exist=False)\n            if os.path.exists(temp_dir):\n                try:\n                    shutil.rmtree(temp_dir)\n                except Exception as e:\n                    logger.error(\"Could not remove temp dir\", exc_info=e)\n        except Exception:\n            self.report_exception()\n\n        self.destroy()\n        self._destroyed = True", "is_method": true, "class_name": "Workbench", "function_description": "Handles the Workbench's shutdown process by saving state, closing resources, generating a close event, and cleaning temporary files. It ensures orderly cleanup and prevents closure if ongoing editor checks fail."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_all_key_presses", "line_number": 2272, "body": "def _on_all_key_presses(self, event):\n        if running_on_windows():\n            ui_utils.handle_mistreated_latin_shortcuts(self._latin_shortcuts, event)", "is_method": true, "class_name": "Workbench", "function_description": "Private method in Workbench that processes key press events on Windows to correct Latin shortcut handling, supporting consistent keyboard input behavior across platforms."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_focus_in", "line_number": 2276, "body": "def _on_focus_in(self, event):\n        if self._lost_focus:\n            self._lost_focus = False\n            self.event_generate(\"WindowFocusIn\")", "is_method": true, "class_name": "Workbench", "function_description": "Private method in Workbench that handles focus events by detecting when the window regains focus and triggering a corresponding focus-in event for further processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_focus_out", "line_number": 2281, "body": "def _on_focus_out(self, event):\n        if self.focus_get() is None:\n            if not self._lost_focus:\n                self._lost_focus = True\n                self.event_generate(\"WindowFocusOut\")", "is_method": true, "class_name": "Workbench", "function_description": "Handles the loss of focus in the Workbench window by detecting when no widget is focused and triggering a \"WindowFocusOut\" event once per focus loss."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "focus_get", "line_number": 2287, "body": "def focus_get(self) -> Optional[tk.Widget]:\n        try:\n            return tk.Tk.focus_get(self)\n        except Exception:\n            # This may give error in Ubuntu\n            return None", "is_method": true, "class_name": "Workbench", "function_description": "Returns the currently focused Tkinter widget within the Workbench. It provides a safe way to identify focus ownership, handling platform-specific exceptions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "destroy", "line_number": 2294, "body": "def destroy(self) -> None:\n        try:\n            if self._is_server() and os.path.exists(thonny.get_ipc_file_path()):\n                os.remove(thonny.get_ipc_file_path())\n\n            self._closing = True\n\n            # Tk clipboard gets cleared on exit and won't end up in system clipboard\n            # https://bugs.python.org/issue1207592\n            # https://stackoverflow.com/questions/26321333/tkinter-in-python-3-4-on-windows-dont-post-internal-clipboard-data-to-the-windo\n            try:\n                clipboard_data = self.clipboard_get()\n                if len(clipboard_data) < 1000 and all(\n                    map(os.path.exists, clipboard_data.splitlines())\n                ):\n                    # Looks like the clipboard contains file name(s)\n                    # Most likely this means actual file cut/copy operation\n                    # was made outside of Thonny.\n                    # Don't want to replace this with simple string data of file names.\n                    pass\n                else:\n                    copy_to_clipboard(clipboard_data)\n            except Exception:\n                pass\n\n        except Exception:\n            logging.exception(\"Error while destroying workbench\")\n\n        finally:\n            try:\n                super().destroy()\n            finally:\n                runner = get_runner()\n                if runner != None:\n                    runner.destroy_backend()", "is_method": true, "class_name": "Workbench", "function_description": "Cleans up resources and state when closing the Workbench, including removing IPC files, preserving clipboard contents, and properly shutting down associated runner backends for a graceful application exit."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_configure", "line_number": 2330, "body": "def _on_configure(self, event) -> None:\n        # called when window is moved or resized\n        if (\n            hasattr(self, \"_maximized_view\")  # configure may happen before the attribute is defined\n            and self._maximized_view  # type: ignore\n        ):\n            # grid again, otherwise it acts weird\n            self._maximized_view.grid(\n                row=1, column=0, sticky=tk.NSEW, in_=self._maximized_view.master  # type: ignore\n            )", "is_method": true, "class_name": "Workbench", "function_description": "Handles window resize or move events to maintain the layout of a maximized view within the Workbench, ensuring consistent UI behavior during window configuration changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_tk_exception", "line_number": 2341, "body": "def _on_tk_exception(self, exc, val, tb) -> None:\n        # copied from tkinter.Tk.report_callback_exception with modifications\n        # see http://bugs.python.org/issue22384\n        sys.last_type = exc\n        sys.last_value = val\n        sys.last_traceback = tb\n        self.report_exception()", "is_method": true, "class_name": "Workbench", "function_description": "Internal error handler for the Workbench class that captures and logs exceptions occurring in Tkinter callbacks, enabling customized exception reporting and debugging support."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "report_exception", "line_number": 2349, "body": "def report_exception(self, title: str = \"Internal error\") -> None:\n        logging.exception(title)\n        if tk._default_root and not self._closing:  # type: ignore\n            (typ, value, _) = sys.exc_info()\n            assert typ is not None\n            if issubclass(typ, UserError):\n                msg = str(value)\n            else:\n                msg = traceback.format_exc()\n\n            dlg = ui_utils.LongTextDialog(title, msg, parent=self)\n            ui_utils.show_dialog(dlg, self)", "is_method": true, "class_name": "Workbench", "function_description": "Provides a user-facing error reporting mechanism that logs exceptions and shows detailed error dialogs within a GUI environment, enhancing debugging and user feedback during runtime failures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_open_views", "line_number": 2362, "body": "def _open_views(self) -> None:\n        for nb_name in self._view_notebooks:\n            view_name = self.get_option(\"layout.notebook_\" + nb_name + \"_visible_view\")\n            if view_name != None:\n                if view_name == \"GlobalsView\":\n                    # was renamed in 2.2b5\n                    view_name = \"VariablesView\"\n\n                if (\n                    self.get_ui_mode() != \"simple\" or view_name in SIMPLE_MODE_VIEWS\n                ) and view_name in self._view_records:\n                    self.show_view(view_name)\n\n        # make sure VariablesView is at least loaded\n        # otherwise it may miss globals events\n        # and will show empty table on open\n        self.get_view(\"VariablesView\")\n\n        if (\n            self.get_option(\"assistance.open_assistant_on_errors\")\n            or self.get_option(\"assistance.open_assistant_on_warnings\")\n        ) and (self.get_ui_mode() != \"simple\" or \"AssistantView\" in SIMPLE_MODE_VIEWS):\n            self.get_view(\"AssistantView\")", "is_method": true, "class_name": "Workbench", "function_description": "Method of the Workbench class that opens and configures interface views based on user settings and UI mode, ensuring essential views like VariablesView and AssistantView are loaded and displayed as needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_save_layout", "line_number": 2386, "body": "def _save_layout(self) -> None:\n        self.update_idletasks()\n        self.set_option(\"layout.zoomed\", ui_utils.get_zoomed(self))\n\n        for nb_name in self._view_notebooks:\n            widget = self._view_notebooks[nb_name].get_visible_child()\n            if hasattr(widget, \"maximizable_widget\"):\n                view = widget.maximizable_widget\n                view_name = type(view).__name__\n                self.set_option(\"layout.notebook_\" + nb_name + \"_visible_view\", view_name)\n            else:\n                self.set_option(\"layout.notebook_\" + nb_name + \"_visible_view\", None)\n\n        if not ui_utils.get_zoomed(self) or running_on_mac_os():\n            # can't restore zoom on mac without setting actual dimensions\n            gparts = re.findall(r\"\\d+\", self.wm_geometry())\n            self.set_option(\"layout.width\", int(gparts[0]))\n            self.set_option(\"layout.height\", int(gparts[1]))\n            self.set_option(\"layout.left\", int(gparts[2]))\n            self.set_option(\"layout.top\", int(gparts[3]))\n\n        self.set_option(\"layout.west_pw_width\", self._west_pw.preferred_size_in_pw)\n        self.set_option(\"layout.east_pw_width\", self._east_pw.preferred_size_in_pw)\n        for key in [\"nw\", \"sw\", \"s\", \"se\", \"ne\"]:\n            self.set_option(\n                \"layout.%s_nb_height\" % key, self._view_notebooks[key].preferred_size_in_pw\n            )", "is_method": true, "class_name": "Workbench", "function_description": "Saves the current UI layout settings of the Workbench, including zoom state, visible notebook views, window size, position, and pane widths. This enables consistent restoration of the workbench interface between sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "update_title", "line_number": 2414, "body": "def update_title(self, event=None) -> None:\n        editor = self.get_editor_notebook().get_current_editor()\n        if self._is_portable:\n            title_text = \"Portable Thonny\"\n        else:\n            title_text = \"Thonny\"\n        if editor != None:\n            title_text += \"  -  \" + editor.get_long_description()\n\n        self.title(title_text)", "is_method": true, "class_name": "Workbench", "function_description": "Utility method of the Workbench class that updates the application window title to reflect the current editor's description and whether the environment is portable, enhancing user context visibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "become_active_window", "line_number": 2425, "body": "def become_active_window(self, force=True) -> None:\n        # Looks like at least on Windows all following is required\n        # for ensuring the window gets focus\n        # (deiconify, ..., iconify, deiconify)\n        self.deiconify()\n\n        if force:\n            self.attributes(\"-topmost\", True)\n            self.after_idle(self.attributes, \"-topmost\", False)\n            self.lift()\n\n            if not running_on_linux():\n                # http://stackoverflow.com/a/13867710/261181\n                self.iconify()\n                self.deiconify()\n\n        editor = self.get_editor_notebook().get_current_editor()\n        if editor is not None:\n            # This method is meant to be called when new file is opened, so it's safe to\n            # send the focus to the editor\n            editor.focus_set()\n        else:\n            self.focus_set()", "is_method": true, "class_name": "Workbench", "function_description": "Ensures the Workbench window becomes the active, focused window, optionally forcing it to the front, and sets focus to the current editor if available. Useful for managing window focus after opening new files or user actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "open_url", "line_number": 2449, "body": "def open_url(self, url):\n        m = re.match(r\"^thonny-editor://(.*?)(#(\\d+)(:(\\d+))?)?$\", url)\n        if m is not None:\n            filename = m.group(1).replace(\"%20\", \" \")\n            lineno = None if m.group(3) is None else int(m.group(3))\n            col_offset = None if m.group(5) is None else int(m.group(5))\n            if lineno is None:\n                self.get_editor_notebook().show_file(filename)\n            else:\n                self.get_editor_notebook().show_file_at_line(filename, lineno, col_offset)\n\n            return\n\n        m = re.match(r\"^thonny-help://(.*?)(#(.+))?$\", url)\n        if m is not None:\n            topic = m.group(1)\n            fragment = m.group(3)\n            self.show_view(\"HelpView\").load_topic(topic, fragment)\n            return\n\n        if url.endswith(\".rst\") and not url.startswith(\"http\"):\n            parts = url.split(\"#\", maxsplit=1)\n            topic = parts[0][:-4]\n            if len(parts) == 2:\n                fragment = parts[1]\n            else:\n                fragment = None\n\n            self.show_view(\"HelpView\").load_topic(topic, fragment)\n            return\n\n        # Fallback\n        import webbrowser\n\n        webbrowser.open(url, False, True)", "is_method": true, "class_name": "Workbench", "function_description": "Handles custom URL schemes to open files at specified locations or help topics within the Workbench, defaulting to a web browser for other URLs. This enables seamless integration of editor navigation and help viewing from URLs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "open_help_topic", "line_number": 2485, "body": "def open_help_topic(self, topic, fragment=None):\n        self.show_view(\"HelpView\").load_topic(topic, fragment)", "is_method": true, "class_name": "Workbench", "function_description": "Utility method of the Workbench class that opens a specified help topic and optionally navigates to a specific fragment within it, facilitating user access to contextual help documentation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "bell", "line_number": 2488, "body": "def bell(self, displayof=0):\n        if not self.get_option(\"general.disable_notification_sound\"):\n            super().bell(displayof=displayof)", "is_method": true, "class_name": "Workbench", "function_description": "Method of the Workbench class that triggers a notification sound unless the user has disabled notification sounds in settings. It provides conditional audible alerts to enhance user notifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_mac_quit", "line_number": 2492, "body": "def _mac_quit(self, *args):\n        self._on_close()", "is_method": true, "class_name": "Workbench", "function_description": "Internal method of the Workbench class that handles application quit events on macOS by triggering the standard close procedure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_is_server", "line_number": 2495, "body": "def _is_server(self):\n        return self._ipc_requests is not None", "is_method": true, "class_name": "Workbench", "function_description": "Private method of the Workbench class that determines whether the instance is acting as a server by checking the presence of IPC request handling. It supports internal logic based on server or client role identification."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_toolbar", "line_number": 2498, "body": "def get_toolbar(self):\n        return self._toolbar", "is_method": true, "class_name": "Workbench", "function_description": "Returns the toolbar component associated with the Workbench, providing access to its interface elements for further interaction or customization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_temp_dir", "line_number": 2501, "body": "def get_temp_dir(self, create_if_doesnt_exist=True):\n        path = os.path.join(THONNY_USER_DIR, \"temp\")\n        if create_if_doesnt_exist:\n            os.makedirs(path, exist_ok=True)\n        return path", "is_method": true, "class_name": "Workbench", "function_description": "Provides the path to the user's temporary directory, optionally creating it if missing. This utility supports managing temporary files within the Workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "module_sort_key", "line_number": 399, "body": "def module_sort_key(m):\n            return getattr(m, \"load_order_key\", m.__name__)", "is_method": true, "class_name": "Workbench", "function_description": "Utility function in Workbench that determines a module's sorting key based on its load order or name, supporting ordered module processing or loading operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "server_loop", "line_number": 531, "body": "def server_loop():\n            while True:\n                logging.debug(\"Waiting for next client\")\n                (client_socket, _) = server_socket.accept()\n                try:\n                    data = bytes()\n                    while True:\n                        new_data = client_socket.recv(1024)\n                        if len(new_data) > 0:\n                            data += new_data\n                        else:\n                            break\n                    proposed_secret, args = ast.literal_eval(data.decode(\"UTF-8\"))\n                    if proposed_secret == actual_secret:\n                        self._ipc_requests.put(args)\n                        # respond OK\n                        client_socket.sendall(SERVER_SUCCESS.encode(encoding=\"utf-8\"))\n                        client_socket.shutdown(socket.SHUT_WR)\n                        logging.debug(\"AFTER NEW REQUEST %s\", client_socket)\n                    else:\n                        client_socket.shutdown(socket.SHUT_WR)\n                        raise PermissionError(\"Wrong secret\")\n\n                except Exception as e:\n                    logger.exception(\"Error in ipc server loop\", exc_info=e)", "is_method": true, "class_name": "Workbench", "function_description": "Continuously listens for client connections, verifies a secret for authentication, processes incoming requests, and queues them for handling, enabling secure inter-process communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "choose_backend", "line_number": 788, "body": "def choose_backend():\n            backend_conf = ast.literal_eval(self._backend_conf_variable.get())\n            assert isinstance(backend_conf, dict), \"backend conf is %r\" % backend_conf\n            for name, value in backend_conf.items():\n                self.set_option(name, value)\n            get_runner().restart_backend(False)", "is_method": true, "class_name": "Workbench", "function_description": "Configures and activates a backend by loading settings from a stored configuration and restarting the backend runner to apply these options within the Workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "dispatch_if_caps_lock_is_on", "line_number": 1000, "body": "def dispatch_if_caps_lock_is_on(event):\n            if caps_lock_is_on(event.state) and not shift_is_pressed(event.state):\n                dispatch(event)", "is_method": true, "class_name": "Workbench", "function_description": "Utility method in the Workbench class that dispatches an event only if Caps Lock is active and Shift is not pressed, enabling conditional event handling based on keyboard state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_settings", "line_number": 1305, "body": "def get_settings(name):\n            try:\n                parent, settings = self._syntax_themes[name]\n            except KeyError:\n                self.report_exception(\"Can't find theme '%s'\" % name)\n                return {}\n\n            if callable(settings):\n                settings = settings()\n\n            if parent is None:\n                return settings\n            else:\n                result = get_settings(parent)\n                for key in settings:\n                    if key in result:\n                        result[key].update(settings[key])\n                    else:\n                        result[key] = settings[key]\n                return result", "is_method": true, "class_name": "Workbench", "function_description": "Core method of Workbench that retrieves and merges syntax theme settings by name, supporting inheritance and dynamic configuration for customizable editor themes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "update_visibility", "line_number": 1383, "body": "def update_visibility():\n            if visibility_var.get():\n                if not frame.winfo_ismapped():\n                    frame.grid(row=0, column=col, sticky=\"nse\")\n            else:\n                if frame.winfo_ismapped():\n                    frame.grid_remove()", "is_method": true, "class_name": "Workbench", "function_description": "Toggles the visibility of a UI frame in the Workbench based on a control variable, showing or hiding the frame dynamically to manage interface layout and user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "toggle", "line_number": 1391, "body": "def toggle():\n            visibility_var.set(not visibility_var.get())\n            update_visibility()", "is_method": true, "class_name": "Workbench", "function_description": "Core method of the Workbench class that toggles a visibility state variable and updates the interface accordingly, enabling dynamic show/hide functionality for UI elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "on_click", "line_number": 1420, "body": "def on_click(event):\n            self.set_option(\"general.ui_mode\", \"regular\")\n            tk.messagebox.showinfo(\n                tr(\"Regular mode\"),\n                tr(\n                    \"Configuration has been updated. \"\n                    + \"Restart Thonny to start working in regular mode.\\n\\n\"\n                    + \"(See 'Tools \u2192 Options \u2192 General' if you change your mind later.)\"\n                ),\n                master=self,\n            )", "is_method": true, "class_name": "Workbench", "function_description": "Handles a user interface event to switch the application to regular mode, notifying the user that a restart is needed for the change to take effect."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "run_in_terminal", "line_number": 8, "body": "def run_in_terminal(cmd, cwd, env_overrides={}, keep_open=True, title=None):\n    from thonny.running import get_environment_with_overrides\n\n    env = get_environment_with_overrides(env_overrides)\n\n    if not cwd or not os.path.exists(cwd):\n        cwd = os.getcwd()\n\n    if platform.system() == \"Windows\":\n        _run_in_terminal_in_windows(cmd, cwd, env, keep_open, title)\n    elif platform.system() == \"Linux\":\n        _run_in_terminal_in_linux(cmd, cwd, env, keep_open)\n    elif platform.system() == \"Darwin\":\n        _run_in_terminal_in_macos(cmd, cwd, env_overrides, keep_open)\n    else:\n        raise RuntimeError(\"Can't launch terminal in \" + platform.system())", "is_method": false, "function_description": "Utility function to execute a shell command in a system terminal with optional environment overrides, working directory, and terminal window settings, adapting behavior based on the operating system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "open_system_shell", "line_number": 26, "body": "def open_system_shell(cwd, env_overrides={}):\n    from thonny.running import get_environment_with_overrides\n\n    env = get_environment_with_overrides(env_overrides)\n\n    if platform.system() == \"Darwin\":\n        _run_in_terminal_in_macos([], cwd, env_overrides, True)\n    elif platform.system() == \"Windows\":\n        cmd = \"start cmd\"\n        subprocess.Popen(cmd, cwd=cwd, env=env, shell=True)\n    elif platform.system() == \"Linux\":\n        cmd = _get_linux_terminal_command()\n        subprocess.Popen(cmd, cwd=cwd, env=env, shell=True)\n    else:\n        raise RuntimeError(\"Can't launch terminal in \" + platform.system())", "is_method": false, "function_description": "Function that launches a system shell or terminal window in a specified directory with optional environment variable overrides, adapting the command to the operating system for interactive command execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_add_to_path", "line_number": 43, "body": "def _add_to_path(directory, path):\n    # Always prepending to path may seem better, but this could mess up other things.\n    # If the directory contains only one Python distribution executables, then\n    # it probably won't be in path yet and therefore will be prepended.\n    if (\n        directory in path.split(os.pathsep)\n        or platform.system() == \"Windows\"\n        and directory.lower() in path.lower().split(os.pathsep)\n    ):\n        return path\n    else:\n        return directory + os.pathsep + path", "is_method": false, "function_description": "Utility function that conditionally prepends a directory to a system PATH string if it's not already included, ensuring efficient executable resolution without duplications or platform conflicts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_run_in_terminal_in_windows", "line_number": 57, "body": "def _run_in_terminal_in_windows(cmd, cwd, env, keep_open, title=None):\n    if keep_open:\n        # Yes, the /K argument has weird quoting. Can't explain this, but it works\n        quoted_args = \" \".join(map(lambda s: s if s == \"&\" else '\"' + s + '\"', cmd))\n        cmd_line = \"\"\"start {title} /D \"{cwd}\" /W cmd /K \"{quoted_args}\" \"\"\".format(\n            cwd=cwd, quoted_args=quoted_args, title='\"' + title + '\"' if title else \"\"\n        )\n\n        subprocess.Popen(cmd_line, cwd=cwd, env=env, shell=True)\n    else:\n        subprocess.Popen(cmd, creationflags=subprocess.CREATE_NEW_CONSOLE, cwd=cwd, env=env)", "is_method": false, "function_description": "Utility function that runs a given command in a new Windows terminal, optionally keeping the terminal open with a custom title and working directory. Useful for executing subprocesses interactively or in the background on Windows systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_run_in_terminal_in_linux", "line_number": 70, "body": "def _run_in_terminal_in_linux(cmd, cwd, env, keep_open):\n    def _shellquote(s):\n        return subprocess.list2cmdline([s])\n\n    term_cmd = _get_linux_terminal_command()\n\n    if isinstance(cmd, list):\n        cmd = \" \".join(map(_shellquote, cmd))\n\n    if keep_open:\n        # http://stackoverflow.com/a/4466566/261181\n        core_cmd = \"{cmd}; exec bash -i\".format(cmd=cmd)\n        in_term_cmd = \"bash -c {core_cmd}\".format(core_cmd=_shellquote(core_cmd))\n    else:\n        in_term_cmd = cmd\n\n    if term_cmd == \"lxterminal\":\n        # https://www.raspberrypi.org/forums/viewtopic.php?t=221490\n        whole_cmd = \"{term_cmd} --command={in_term_cmd}\".format(\n            term_cmd=term_cmd, in_term_cmd=_shellquote(in_term_cmd)\n        )\n    else:\n        whole_cmd = \"{term_cmd} -e {in_term_cmd}\".format(\n            term_cmd=term_cmd, in_term_cmd=_shellquote(in_term_cmd)\n        )\n\n    if term_cmd == \"terminator\" and \"PYTHONPATH\" in env:\n        # it is written in Python 2 and the PYTHONPATH of Python 3 will confuse it\n        # https://github.com/thonny/thonny/issues/1129\n        del env[\"PYTHONPATH\"]\n\n    subprocess.Popen(whole_cmd, cwd=cwd, env=env, shell=True)", "is_method": false, "function_description": "Utility function that executes a given command inside a new Linux terminal window with options for working directory, environment variables, and whether to keep the terminal open after the command finishes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_run_in_terminal_in_macos", "line_number": 104, "body": "def _run_in_terminal_in_macos(cmd, cwd, env_overrides, keep_open):\n    _shellquote = shlex.quote\n\n    cmds = \"clear; cd \" + _shellquote(cwd)\n    # osascript \"tell application\" won't change Terminal's env\n    # (at least when Terminal is already active)\n    # At the moment I just explicitly set some important variables\n    for key in env_overrides:\n        if env_overrides[key] is None:\n            cmds += \"; unset \" + key\n        else:\n            value = env_overrides[key]\n            if key == \"PATH\":\n                value = _normalize_path(value)\n\n            cmds += \"; export {key}={value}\".format(key=key, value=_shellquote(value))\n\n    if cmd:\n        if isinstance(cmd, list):\n            cmd = \" \".join(map(_shellquote, cmd))\n        cmds += \"; \" + cmd\n\n    if not keep_open:\n        cmds += \"; exit\"\n\n    # try to shorten to avoid too long line https://github.com/thonny/thonny/issues/1529\n\n    common_prefix = os.path.normpath(sys.prefix).rstrip(\"/\")\n    cmds = (\n        \"export THOPR=\" + common_prefix + \" ; \" + cmds.replace(common_prefix + \"/\", \"$THOPR\" + \"/\")\n    )\n    print(cmds)\n\n    # The script will be sent to Terminal with 'do script' command, which takes a string.\n    # We'll prepare an AppleScript string literal for this\n    # (http://stackoverflow.com/questions/10667800/using-quotes-in-a-applescript-string):\n    cmd_as_apple_script_string_literal = (\n        '\"' + cmds.replace(\"\\\\\", \"\\\\\\\\\").replace('\"', '\\\\\"').replace(\"$\", \"\\\\$\") + '\"'\n    )\n\n    # When Terminal is not open, then do script opens two windows.\n    # do script ... in window 1 would solve this, but if Terminal is already\n    # open, this could run the script in existing terminal (in undesirable env on situation)\n    # That's why I need to prepare two variations of the 'do script' command\n    doScriptCmd1 = \"\"\"        do script %s \"\"\" % cmd_as_apple_script_string_literal\n    doScriptCmd2 = \"\"\"        do script %s in window 1 \"\"\" % cmd_as_apple_script_string_literal\n\n    # The whole AppleScript will be executed with osascript by giving script\n    # lines as arguments. The lines containing our script need to be shell-quoted:\n    quotedCmd1 = subprocess.list2cmdline([doScriptCmd1])\n    quotedCmd2 = subprocess.list2cmdline([doScriptCmd2])\n\n    # Now we can finally assemble the osascript command line\n    cmd_line = (\n        \"osascript\"\n        + \"\"\" -e 'if application \"Terminal\" is running then ' \"\"\"\n        + \"\"\" -e '    tell application \"Terminal\"           ' \"\"\"\n        + \"\"\" -e \"\"\"\n        + quotedCmd1\n        + \"\"\" -e '        activate                          ' \"\"\"\n        + \"\"\" -e '    end tell                              ' \"\"\"\n        + \"\"\" -e 'else                                      ' \"\"\"\n        + \"\"\" -e '    tell application \"Terminal\"           ' \"\"\"\n        + \"\"\" -e \"\"\"\n        + quotedCmd2\n        + \"\"\" -e '        activate                          ' \"\"\"\n        + \"\"\" -e '    end tell                              ' \"\"\"\n        + \"\"\" -e 'end if                                    ' \"\"\"\n    )\n\n    subprocess.Popen(cmd_line, cwd=cwd, shell=True)", "is_method": false, "function_description": "Utility function for macOS that runs a shell command in the Terminal app with customizable environment variables, working directory, and option to keep the terminal open after execution. Useful for programmatically launching terminal commands with controlled environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_get_linux_terminal_command", "line_number": 177, "body": "def _get_linux_terminal_command():\n    import shutil\n\n    xte = shutil.which(\"x-terminal-emulator\")\n    if xte:\n        if os.path.realpath(xte).endswith(\"/lxterminal\") and shutil.which(\"lxterminal\"):\n            # need to know exact program, because it needs special treatment\n            return \"lxterminal\"\n        elif os.path.realpath(xte).endswith(\"/terminator\") and shutil.which(\"terminator\"):\n            # https://github.com/thonny/thonny/issues/1129\n            return \"terminator\"\n        else:\n            return \"x-terminal-emulator\"\n    # Older konsole didn't pass on the environment\n    elif shutil.which(\"konsole\"):\n        if (\n            shutil.which(\"gnome-terminal\")\n            and \"gnome\" in os.environ.get(\"DESKTOP_SESSION\", \"\").lower()\n        ):\n            return \"gnome-terminal\"\n        else:\n            return \"konsole\"\n    elif shutil.which(\"gnome-terminal\"):\n        return \"gnome-terminal\"\n    elif shutil.which(\"xfce4-terminal\"):\n        return \"xfce4-terminal\"\n    elif shutil.which(\"lxterminal\"):\n        return \"lxterminal\"\n    elif shutil.which(\"xterm\"):\n        return \"xterm\"\n    else:\n        raise RuntimeError(\"Don't know how to open terminal emulator\")", "is_method": false, "function_description": "Helper function that determines the most appropriate Linux terminal emulator command available on the system, facilitating consistent terminal launching across diverse Linux environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_normalize_path", "line_number": 211, "body": "def _normalize_path(s):\n    parts = s.split(os.pathsep)\n    return os.pathsep.join([os.path.normpath(part) for part in parts])", "is_method": false, "function_description": "Utility function that normalizes each path component in a path string separated by the OS path separator, ensuring consistent and standardized path formatting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_shellquote", "line_number": 71, "body": "def _shellquote(s):\n        return subprocess.list2cmdline([s])", "is_method": false, "function_description": "Utility function that safely quotes a string for shell command usage, ensuring correct parsing when passed to subprocesses or shell environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_ends_with_incomplete_ansi_code", "line_number": 1164, "body": "def _ends_with_incomplete_ansi_code(data):\n    pos = data.rfind(\"\\033\")\n    if pos == -1:\n        return False\n\n    # note ANSI_CODE_TERMINATOR also includes [\n    params_and_terminator = data[pos + 2 :]\n    return not ANSI_CODE_TERMINATOR.search(params_and_terminator)", "is_method": false, "function_description": "Utility function that checks if a string ends with a partial or incomplete ANSI escape sequence, useful for ensuring valid terminal control code formatting in text processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_bundled_python", "line_number": 1174, "body": "def is_bundled_python(executable):\n    return os.path.exists(os.path.join(os.path.dirname(executable), \"thonny_python.ini\"))", "is_method": false, "function_description": "Returns True if the given Python executable is part of a bundled Thonny Python environment by checking for a specific configuration file. Useful for identifying Thonny-distributed Python instances."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "create_backend_python_process", "line_number": 1178, "body": "def create_backend_python_process(\n    args, stdin=None, stdout=subprocess.PIPE, stderr=subprocess.STDOUT\n):\n    \"\"\"Used for running helper commands (eg. pip) on CPython backend.\n    Assumes current backend is CPython.\"\"\"\n\n    # TODO: if backend == frontend, then delegate to create_frontend_python_process\n\n    python_exe = get_runner().get_local_executable()\n\n    env = get_environment_for_python_subprocess(python_exe)\n    env[\"PYTHONIOENCODING\"] = \"utf-8\"\n    env[\"PYTHONUNBUFFERED\"] = \"1\"\n\n    # TODO: remove frontend python from path and add backend python to it\n\n    return _create_python_process(python_exe, args, stdin, stdout, stderr, env=env)", "is_method": false, "function_description": "Utility function that launches a Python subprocess on the CPython backend to run helper commands, configured with appropriate environment settings for consistent input/output behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "create_frontend_python_process", "line_number": 1197, "body": "def create_frontend_python_process(\n    args, stdin=None, stdout=subprocess.PIPE, stderr=subprocess.STDOUT\n):\n    \"\"\"Used for running helper commands (eg. for installing plug-ins on by the plug-ins)\"\"\"\n    if _console_allocated:\n        python_exe = get_interpreter_for_subprocess().replace(\"pythonw.exe\", \"python.exe\")\n    else:\n        python_exe = get_interpreter_for_subprocess().replace(\"python.exe\", \"pythonw.exe\")\n    env = get_environment_for_python_subprocess(python_exe)\n    env[\"PYTHONIOENCODING\"] = \"utf-8\"\n    env[\"PYTHONUNBUFFERED\"] = \"1\"\n    return _create_python_process(python_exe, args, stdin, stdout, stderr)", "is_method": false, "function_description": "Creates and launches a Python subprocess configured for frontend helper commands, such as plugin installation, ensuring appropriate interpreter and environment settings for communication with the main application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_create_python_process", "line_number": 1211, "body": "def _create_python_process(\n    python_exe,\n    args,\n    stdin=None,\n    stdout=subprocess.PIPE,\n    stderr=subprocess.STDOUT,\n    shell=False,\n    env=None,\n    universal_newlines=True,\n):\n\n    cmd = [python_exe] + args\n\n    if running_on_windows():\n        creationflags = subprocess.CREATE_NEW_PROCESS_GROUP\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n    else:\n        startupinfo = None\n        creationflags = 0\n\n    proc = subprocess.Popen(\n        cmd,\n        stdin=stdin,\n        stdout=stdout,\n        stderr=stderr,\n        shell=shell,\n        env=env,\n        universal_newlines=universal_newlines,\n        startupinfo=startupinfo,\n        creationflags=creationflags,\n    )\n\n    proc.cmd = cmd\n    return proc", "is_method": false, "function_description": "Creates and starts a Python subprocess with specified arguments and environment, handling platform-specific settings for process creation. This enables customized execution of Python code in isolated processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_venv_interpreter_of_current_interpreter", "line_number": 1254, "body": "def is_venv_interpreter_of_current_interpreter(executable):\n    for location in [\".\", \"..\"]:\n        cfg_path = os.path.join(location, \"pyvenv.cfg\")\n        if os.path.isfile(cfg_path):\n            with open(cfg_path) as fp:\n                content = fp.read()\n            for line in content.splitlines():\n                if line.replace(\" \", \"\").startswith(\"home=\"):\n                    _, home = line.split(\"=\", maxsplit=1)\n                    home = home.strip()\n                    if os.path.isdir(home) and os.path.samefile(home, sys.prefix):\n                        return True\n    return False", "is_method": false, "function_description": "Function checks if a given executable belongs to a virtual environment whose base interpreter is the current Python interpreter. It helps determine virtual environment relationships relative to the running interpreter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_environment_for_python_subprocess", "line_number": 1269, "body": "def get_environment_for_python_subprocess(target_executable):\n    overrides = get_environment_overrides_for_python_subprocess(target_executable)\n    return get_environment_with_overrides(overrides)", "is_method": false, "function_description": "Utility function that constructs the environment variables for running a Python subprocess, applying necessary overrides tailored to the target executable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_environment_with_overrides", "line_number": 1274, "body": "def get_environment_with_overrides(overrides):\n    env = os.environ.copy()\n    for key in overrides:\n        if overrides[key] is None and key in env:\n            del env[key]\n        else:\n            assert isinstance(overrides[key], str)\n            if key.upper() == \"PATH\":\n                update_system_path(env, overrides[key])\n            else:\n                env[key] = overrides[key]\n    return env", "is_method": false, "function_description": "Function that returns a modified copy of the current environment variables, applying string-based overrides and special handling for the PATH variable, facilitating customized environment configurations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_environment_overrides_for_python_subprocess", "line_number": 1288, "body": "def get_environment_overrides_for_python_subprocess(target_executable):\n    \"\"\"Take care of not not confusing different interpreter\n    with variables meant for bundled interpreter\"\"\"\n\n    # At the moment I'm tweaking the environment only if current\n    # exe is bundled for Thonny.\n    # In remaining cases it is user's responsibility to avoid\n    # calling Thonny with environment which may be confusing for\n    # different Pythons called in a subprocess.\n\n    this_executable = sys.executable.replace(\"pythonw.exe\", \"python.exe\")\n    target_executable = target_executable.replace(\"pythonw.exe\", \"python.exe\")\n\n    interpreter_specific_keys = [\n        \"TCL_LIBRARY\",\n        \"TK_LIBRARY\",\n        \"LD_LIBRARY_PATH\",\n        \"DYLD_LIBRARY_PATH\",\n        \"SSL_CERT_DIR\",\n        \"SSL_CERT_FILE\",\n        \"PYTHONHOME\",\n        \"PYTHONPATH\",\n        \"PYTHONNOUSERSITE\",\n        \"PYTHONUSERBASE\",\n    ]\n\n    result = {}\n\n    if os.path.samefile(\n        target_executable, this_executable\n    ) or is_venv_interpreter_of_current_interpreter(target_executable):\n        # bring out some important variables so that they can\n        # be explicitly set in macOS Terminal\n        # (If they are set then it's most likely because current exe is in Thonny bundle)\n        for key in interpreter_specific_keys:\n            if key in os.environ:\n                result[key] = os.environ[key]\n\n        # never pass some variables to different interpreter\n        # (even if it's venv or symlink to current one)\n        if not is_same_path(target_executable, this_executable):\n            for key in [\"PYTHONPATH\", \"PYTHONHOME\", \"PYTHONNOUSERSITE\", \"PYTHONUSERBASE\"]:\n                if key in os.environ:\n                    result[key] = None\n    else:\n        # interpreters are not related\n        # interpreter specific keys most likely would confuse other interpreter\n        for key in interpreter_specific_keys:\n            if key in os.environ:\n                result[key] = None\n\n    # some keys should be never passed\n    for key in [\n        \"PYTHONSTARTUP\",\n        \"PYTHONBREAKPOINT\",\n        \"PYTHONDEBUG\",\n        \"PYTHONNOUSERSITE\",\n        \"PYTHONASYNCIODEBUG\",\n    ]:\n        if key in os.environ:\n            result[key] = None\n\n    # venv may not find (correct) Tk without assistance (eg. in Ubuntu)\n    if is_venv_interpreter_of_current_interpreter(target_executable):\n        try:\n            if \"TCL_LIBRARY\" not in os.environ or \"TK_LIBRARY\" not in os.environ:\n                result[\"TCL_LIBRARY\"] = get_workbench().tk.exprstring(\"$tcl_library\")\n                result[\"TK_LIBRARY\"] = get_workbench().tk.exprstring(\"$tk_library\")\n        except Exception:\n            logging.exception(\"Can't compute Tcl/Tk library location\")\n\n    return result", "is_method": false, "function_description": "Provides environment variable overrides for running a Python subprocess, ensuring interpreter-specific settings avoid conflicts between bundled, virtual environment, or unrelated Python executables. Useful for launching subprocesses with correct and non-conflicting Python environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "construct_cd_command", "line_number": 1362, "body": "def construct_cd_command(path) -> str:\n    return construct_cmd_line([\"%cd\", path])", "is_method": false, "function_description": "Utility function that generates a command-line string to change the current directory to a specified path, facilitating directory navigation commands in interactive or scripted environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "generate_command_id", "line_number": 1369, "body": "def generate_command_id():\n    global _command_id_counter\n    _command_id_counter += 1\n    return \"cmd_\" + str(_command_id_counter)", "is_method": false, "function_description": "Generates a unique command identifier by incrementing a global counter and prefixing it with \"cmd_\". Useful for tracking or referencing commands uniquely within an application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_frontend_python", "line_number": 1473, "body": "def get_frontend_python():\n    # TODO: deprecated (name can be misleading)\n    warnings.warn(\"get_frontend_python is deprecated\")\n    return get_interpreter_for_subprocess(sys.executable)", "is_method": false, "function_description": "Returns a Python interpreter configured for frontend subprocesses but is deprecated and should be avoided in favor of updated methods."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_interpreter_for_subprocess", "line_number": 1479, "body": "def get_interpreter_for_subprocess(candidate=None):\n    if candidate is None:\n        candidate = sys.executable\n\n    pythonw = candidate.replace(\"python.exe\", \"pythonw.exe\")\n    if not _console_allocated and os.path.exists(pythonw):\n        return pythonw\n    else:\n        return candidate.replace(\"pythonw.exe\", \"python.exe\")", "is_method": false, "function_description": "Function that selects an appropriate Python interpreter executable for subprocesses, preferring a GUI version when no console is allocated. It helps ensure subprocesses run with the correct interpreter type depending on the environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_remove_obsolete_jedi_copies", "line_number": 98, "body": "def _remove_obsolete_jedi_copies(self) -> None:\n        # Thonny 2.1 used to copy jedi in order to make it available\n        # for the backend. Get rid of it now\n        for item in os.listdir(THONNY_USER_DIR):\n            if item.startswith(\"jedi_0.\"):\n                import shutil\n\n                shutil.rmtree(os.path.join(THONNY_USER_DIR, item), True)", "is_method": true, "class_name": "Runner", "function_description": "Private maintenance method of the Runner class that cleans up outdated Jedi library copies from a specific user directory to prevent legacy clutter and potential conflicts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "start", "line_number": 107, "body": "def start(self) -> None:\n        global _console_allocated\n        try:\n            self._check_alloc_console()\n            _console_allocated = True\n        except Exception:\n            logger.exception(\"Problem allocating console\")\n            _console_allocated = False\n\n        self.restart_backend(False, True)\n        # temporary\n        self._remove_obsolete_jedi_copies()", "is_method": true, "class_name": "Runner", "function_description": "Utility method of Runner that initializes the runtime environment by allocating a console, restarting the backend, and cleaning up obsolete resources to prepare for task execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_init_commands", "line_number": 120, "body": "def _init_commands(self) -> None:\n        global RUN_COMMAND_CAPTION, RUN_COMMAND_LABEL\n\n        RUN_COMMAND_LABEL = tr(\"Run current script\")\n        RUN_COMMAND_CAPTION = tr(\"Run\")\n\n        get_workbench().set_default(\"run.run_in_terminal_python_repl\", False)\n        get_workbench().set_default(\"run.run_in_terminal_keep_open\", True)\n\n        try:\n            import thonny.plugins.debugger  # @UnusedImport\n\n            debugger_available = True\n        except ImportError:\n            debugger_available = False\n\n        get_workbench().add_command(\n            \"run_current_script\",\n            \"run\",\n            RUN_COMMAND_LABEL,\n            caption=RUN_COMMAND_CAPTION,\n            handler=self.cmd_run_current_script,\n            default_sequence=\"<F5>\",\n            extra_sequences=[select_sequence(\"<Control-r>\", \"<Command-r>\")],\n            tester=self.cmd_run_current_script_enabled,\n            group=10,\n            image=\"run-current-script\",\n            include_in_toolbar=not (get_workbench().in_simple_mode() and debugger_available),\n            show_extra_sequences=True,\n        )\n\n        get_workbench().add_command(\n            \"run_current_script_in_terminal\",\n            \"run\",\n            tr(\"Run current script in terminal\"),\n            caption=\"RunT\",\n            handler=self._cmd_run_current_script_in_terminal,\n            default_sequence=\"<Control-t>\",\n            extra_sequences=[\"<<CtrlTInText>>\"],\n            tester=self._cmd_run_current_script_in_terminal_enabled,\n            group=35,\n            image=\"terminal\",\n        )\n\n        get_workbench().add_command(\n            \"restart\",\n            \"run\",\n            tr(\"Stop/Restart backend\"),\n            caption=tr(\"Stop\"),\n            handler=self.cmd_stop_restart,\n            default_sequence=\"<Control-F2>\",\n            group=100,\n            image=\"stop\",\n            include_in_toolbar=True,\n        )\n\n        get_workbench().add_command(\n            \"interrupt\",\n            \"run\",\n            tr(\"Interrupt execution\"),\n            handler=self._cmd_interrupt,\n            tester=self._cmd_interrupt_enabled,\n            default_sequence=INTERRUPT_SEQUENCE,\n            skip_sequence_binding=True,  # Sequence will be bound differently\n            group=100,\n            bell_when_denied=False,\n        )\n        get_workbench().bind(INTERRUPT_SEQUENCE, self._cmd_interrupt_with_shortcut, True)\n\n        get_workbench().add_command(\n            \"ctrld\",\n            \"run\",\n            tr(\"Send EOF / Soft reboot\"),\n            self.ctrld,\n            self.ctrld_enabled,\n            group=100,\n            default_sequence=\"<Control-d>\",\n            extra_sequences=[\"<<CtrlDInText>>\"],\n        )\n\n        get_workbench().add_command(\n            \"disconnect\",\n            \"run\",\n            tr(\"Disconnect\"),\n            self.disconnect,\n            self.disconnect_enabled,\n            group=100,\n        )", "is_method": true, "class_name": "Runner", "function_description": "Initializes and registers various run-related commands within the Runner class, configuring their labels, handlers, keyboard shortcuts, and availability based on environment and mode settings. This setup enables script execution control and backend management features in the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_state", "line_number": 209, "body": "def get_state(self) -> str:\n        \"\"\"State is one of \"running\", \"waiting_debugger_command\", \"waiting_toplevel_command\" \"\"\"\n        return self._state", "is_method": true, "class_name": "Runner", "function_description": "Utility method of the Runner class that returns the current execution state, indicating whether it is running or waiting for debugger or toplevel commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_set_state", "line_number": 213, "body": "def _set_state(self, state: str) -> None:\n        if self._state != state:\n            logging.debug(\"Runner state changed: %s ==> %s\" % (self._state, state))\n            self._state = state", "is_method": true, "class_name": "Runner", "function_description": "Internal method of the Runner class that updates its state and logs any changes, providing state tracking and debugging support."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_running", "line_number": 218, "body": "def is_running(self):\n        return self._state == \"running\"", "is_method": true, "class_name": "Runner", "function_description": "Checks whether the Runner instance is currently in the \"running\" state, providing a simple status query for operational flow control."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_waiting", "line_number": 221, "body": "def is_waiting(self):\n        return self._state.startswith(\"waiting\")", "is_method": true, "class_name": "Runner", "function_description": "Checks if the Runner instance is currently in any waiting state by examining its internal status. This helps other components decide if the runner is paused or pending an action."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_waiting_toplevel_command", "line_number": 224, "body": "def is_waiting_toplevel_command(self):\n        return self._state == \"waiting_toplevel_command\"", "is_method": true, "class_name": "Runner", "function_description": "Checks if the Runner instance is currently in a state waiting for a top-level command, enabling conditional logic based on its operational status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_waiting_debugger_command", "line_number": 227, "body": "def is_waiting_debugger_command(self):\n        return self._state == \"waiting_debugger_command\"", "is_method": true, "class_name": "Runner", "function_description": "Utility method of the Runner class that checks if the current execution state is waiting for a debugger command, enabling control flow management during debugging sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_sys_path", "line_number": 230, "body": "def get_sys_path(self) -> List[str]:\n        return self._proxy.get_sys_path()", "is_method": true, "class_name": "Runner", "function_description": "Utility method of the Runner class that retrieves the current system module search paths, aiding dynamic module loading or environment introspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_command", "line_number": 233, "body": "def send_command(self, cmd: CommandToBackend) -> None:\n        if self._proxy is None:\n            return\n\n        if self._publishing_events:\n            # allow all event handlers to complete before sending the commands\n            # issued by first event handlers\n            self._postpone_command(cmd)\n            return\n\n        # First sanity check\n        if (\n            isinstance(cmd, ToplevelCommand)\n            and not self.is_waiting_toplevel_command()\n            and cmd.name not in [\"Reset\", \"Run\", \"Debug\"]\n            or isinstance(cmd, DebuggerCommand)\n            and not self.is_waiting_debugger_command()\n        ):\n            get_workbench().bell()\n            logging.warning(\n                \"RUNNER: Command %s was attempted at state %s\" % (cmd, self.get_state())\n            )\n            return\n\n        # Attach extra info\n        if \"debug\" in cmd.name.lower():\n            cmd[\"breakpoints\"] = get_current_breakpoints()\n\n        if \"id\" not in cmd:\n            cmd[\"id\"] = generate_command_id()\n\n        cmd[\"local_cwd\"] = get_workbench().get_local_cwd()\n\n        # Offer the command\n        logging.debug(\"RUNNER Sending: %s, %s\", cmd.name, cmd)\n        response = self._proxy.send_command(cmd)\n\n        if response == \"discard\":\n            return None\n        elif response == \"postpone\":\n            self._postpone_command(cmd)\n            return\n        else:\n            assert response is None\n            get_workbench().event_generate(\"CommandAccepted\", command=cmd)\n\n        if isinstance(cmd, (ToplevelCommand, DebuggerCommand)):\n            self._set_state(\"running\")\n\n        if cmd.name[0].isupper():\n            # This may be only logical restart, which does not look like restart to the runner\n            get_workbench().event_generate(\"BackendRestart\", full=False)", "is_method": true, "class_name": "Runner", "function_description": "Handles sending commands to a backend proxy, managing command validity, postponement, and event notifications to coordinate execution states and debug information within the Runner context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_command_and_wait", "line_number": 286, "body": "def send_command_and_wait(self, cmd: CommandToBackend, dialog_title: str) -> MessageFromBackend:\n        dlg = InlineCommandDialog(get_workbench(), cmd, title=dialog_title + \" ...\")\n        show_dialog(dlg)\n        return dlg.response", "is_method": true, "class_name": "Runner", "function_description": "Utility method of the Runner class that displays a command dialog to the user, sends a command to the backend, and waits for a response, facilitating interactive backend communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_postpone_command", "line_number": 291, "body": "def _postpone_command(self, cmd: CommandToBackend) -> None:\n        # in case of InlineCommands, discard older same type command\n        if isinstance(cmd, InlineCommand):\n            for older_cmd in self._postponed_commands:\n                if older_cmd.name == cmd.name:\n                    self._postponed_commands.remove(older_cmd)\n\n        if len(self._postponed_commands) > 10:\n            logging.warning(\"Can't pile up too many commands. This command will be just ignored\")\n        else:\n            self._postponed_commands.append(cmd)", "is_method": true, "class_name": "Runner", "function_description": "Internal method of the Runner class that queues commands for later execution, ensuring only the most recent inline command of the same type is kept and limiting the queue size to avoid overload."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_send_postponed_commands", "line_number": 303, "body": "def _send_postponed_commands(self) -> None:\n        todo = self._postponed_commands\n        self._postponed_commands = []\n\n        for cmd in todo:\n            logging.debug(\"Sending postponed command: %s\", cmd)\n            self.send_command(cmd)", "is_method": true, "class_name": "Runner", "function_description": "Internal method of the Runner class that processes and sends all commands previously postponed, ensuring deferred operations are executed in sequence."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_program_input", "line_number": 311, "body": "def send_program_input(self, data: str) -> None:\n        assert self.is_running()\n        self._proxy.send_program_input(data)", "is_method": true, "class_name": "Runner", "function_description": "Sends input data to a currently running program instance managed by the Runner class, facilitating interaction or data feeding during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "execute_script", "line_number": 315, "body": "def execute_script(\n        self,\n        script_path: str,\n        args: List[str],\n        working_directory: Optional[str] = None,\n        command_name: str = \"Run\",\n    ) -> None:\n\n        if self._proxy.get_cwd() != working_directory:\n            # create compound command\n            # start with %cd\n            cd_cmd_line = construct_cd_command(working_directory) + \"\\n\"\n        else:\n            # create simple command\n            cd_cmd_line = \"\"\n\n        rel_filename = universal_relpath(script_path, working_directory)\n        cmd_parts = [\"%\" + command_name, rel_filename] + args\n        exe_cmd_line = construct_cmd_line(cmd_parts, [EDITOR_CONTENT_TOKEN]) + \"\\n\"\n\n        # submit to shell (shell will execute it)\n        get_shell().submit_magic_command(cd_cmd_line + exe_cmd_line)", "is_method": true, "class_name": "Runner", "function_description": "Utility function of the Runner class that executes a script with given arguments in an optional working directory by submitting the appropriate command to the interactive shell environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "execute_editor_content", "line_number": 338, "body": "def execute_editor_content(self, command_name, args):\n        get_shell().submit_magic_command(\n            construct_cmd_line(\n                [\"%\" + command_name, \"-c\", EDITOR_CONTENT_TOKEN] + args, [EDITOR_CONTENT_TOKEN]\n            )\n        )", "is_method": true, "class_name": "Runner", "function_description": "Utility method of the Runner class that executes a specific magic command with content from the editor, allowing dynamic command execution with supplied arguments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "execute_current", "line_number": 345, "body": "def execute_current(self, command_name: str) -> None:\n        \"\"\"\n        This method's job is to create a command for running/debugging\n        current file/script and submit it to shell\n        \"\"\"\n\n        if not self.is_waiting_toplevel_command():\n            self.restart_backend(True, False, 2)\n\n        filename = get_saved_current_script_filename()\n\n        if not filename:\n            # user has cancelled file saving\n            return\n\n        if (\n            is_remote_path(filename)\n            and not self._proxy.can_run_remote_files()\n            or is_local_path(filename)\n            and not self._proxy.can_run_local_files()\n        ):\n            self.execute_editor_content(command_name, self._get_active_arguments())\n        else:\n            if get_workbench().get_option(\"run.auto_cd\") and command_name[0].isupper():\n                working_directory = get_target_dirname_from_editor_filename(filename)\n            else:\n                working_directory = self._proxy.get_cwd()\n\n            if is_local_path(filename):\n                target_path = filename\n            else:\n                target_path = extract_target_path(filename)\n            self.execute_script(\n                target_path, self._get_active_arguments(), working_directory, command_name\n            )", "is_method": true, "class_name": "Runner", "function_description": "Service method of the Runner class that runs or debugs the currently active script, handling local or remote execution contexts and working directory setup based on user and environment settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_get_active_arguments", "line_number": 381, "body": "def _get_active_arguments(self):\n        if get_workbench().get_option(\"view.show_program_arguments\"):\n            args_str = get_workbench().get_option(\"run.program_arguments\")\n            get_workbench().log_program_arguments_string(args_str)\n            return shlex.split(args_str)\n        else:\n            return []", "is_method": true, "class_name": "Runner", "function_description": "Utility method in Runner that retrieves and parses active program arguments from configuration when enabled, facilitating access to runtime parameters for program execution or debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "cmd_run_current_script_enabled", "line_number": 389, "body": "def cmd_run_current_script_enabled(self) -> bool:\n        return (\n            get_workbench().get_editor_notebook().get_current_editor() is not None\n            and \"run\" in get_runner().get_supported_features()\n        )", "is_method": true, "class_name": "Runner", "function_description": "Method of the Runner class that checks if running the current script is possible by verifying an active editor and supported 'run' feature availability. Useful for enabling or disabling run actions in an interactive environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_cmd_run_current_script_in_terminal_enabled", "line_number": 395, "body": "def _cmd_run_current_script_in_terminal_enabled(self) -> bool:\n        return (\n            self._proxy\n            and \"run_in_terminal\" in self._proxy.get_supported_features()\n            and self.cmd_run_current_script_enabled()\n        )", "is_method": true, "class_name": "Runner", "function_description": "Checks if running the current script in a terminal is supported and enabled, combining proxy capabilities and command availability within the Runner class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "cmd_run_current_script", "line_number": 402, "body": "def cmd_run_current_script(self) -> None:\n        if get_workbench().in_simple_mode():\n            get_workbench().hide_view(\"VariablesView\")\n        self.execute_current(\"Run\")", "is_method": true, "class_name": "Runner", "function_description": "Runs the currently active script within the Runner, adjusting the workbench UI by hiding the variables view in simple mode before execution. It provides a convenient way to execute code with appropriate interface updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_cmd_run_current_script_in_terminal", "line_number": 407, "body": "def _cmd_run_current_script_in_terminal(self) -> None:\n        filename = get_saved_current_script_filename()\n        if not filename:\n            return\n\n        self._proxy.run_script_in_terminal(\n            filename,\n            self._get_active_arguments(),\n            get_workbench().get_option(\"run.run_in_terminal_python_repl\"),\n            get_workbench().get_option(\"run.run_in_terminal_keep_open\"),\n        )", "is_method": true, "class_name": "Runner", "function_description": "Utility method of the Runner class that executes the currently saved script in a terminal, passing active arguments and respecting user-configured options for REPL usage and window persistence."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_cmd_interrupt", "line_number": 419, "body": "def _cmd_interrupt(self) -> None:\n        if self._proxy is not None:\n            if _console_allocated:\n                self._proxy.interrupt()\n            else:\n                messagebox.showerror(\n                    \"No console\",\n                    \"Can't interrupt as console was not allocated.\\n\\nUse Stop/Restart instead.\",\n                    master=self,\n                )\n        else:\n            logging.warning(\"User tried interrupting without proxy\")", "is_method": true, "class_name": "Runner", "function_description": "Internal method of Runner that attempts to interrupt an ongoing process via a proxy, providing user notification if interruption is unavailable or no proxy is set."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_cmd_interrupt_with_shortcut", "line_number": 432, "body": "def _cmd_interrupt_with_shortcut(self, event=None):\n        if not self._cmd_interrupt_enabled():\n            return None\n\n        if not running_on_mac_os():  # on Mac Ctrl+C is not used for Copy.\n            # Disable Ctrl+C interrupt in editor and shell, when some text is selected\n            # (assuming user intended to copy instead of interrupting)\n            widget = get_workbench().focus_get()\n            if isinstance(widget, tk.Text):\n                if len(widget.tag_ranges(\"sel\")) > 0:\n                    # this test is reliable, unlike selection_get below\n                    return None\n            elif isinstance(widget, (tk.Listbox, ttk.Entry, tk.Entry, tk.Spinbox)):\n                try:\n                    selection = widget.selection_get()\n                    if isinstance(selection, str) and len(selection) > 0:\n                        # Assuming user meant to copy, not interrupt\n                        # (IDLE seems to follow same logic)\n\n                        # NB! This is not perfect, as in Linux the selection can be in another app\n                        # ie. there may be no selection in Thonny actually.\n                        # In other words, Ctrl+C interrupt may be dropped without reason\n                        # when given inside the widgets listed above.\n                        return None\n                except Exception:\n                    # widget either doesn't have selection_get or it\n                    # gave error (can happen without selection on Ubuntu)\n                    pass\n\n        self._cmd_interrupt()\n        return \"break\"", "is_method": true, "class_name": "Runner", "function_description": "Method of the Runner class that triggers a command interrupt via shortcut, intelligently ignoring the interrupt when a text or widget selection suggests the user intends to copy instead."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_cmd_interrupt_enabled", "line_number": 464, "body": "def _cmd_interrupt_enabled(self) -> bool:\n        return self._proxy and self._proxy.is_connected()", "is_method": true, "class_name": "Runner", "function_description": "Internal method of the Runner class that checks if command interruption is possible by verifying the presence and connection status of a proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "cmd_stop_restart", "line_number": 467, "body": "def cmd_stop_restart(self) -> None:\n        if get_workbench().in_simple_mode():\n            get_workbench().hide_view(\"VariablesView\")\n\n        self.restart_backend(True)", "is_method": true, "class_name": "Runner", "function_description": "Terminates and restarts the backend process, hiding the variable view first if in simple mode; useful for resetting the execution environment cleanly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "disconnect", "line_number": 473, "body": "def disconnect(self):\n        proxy = self.get_backend_proxy()\n        assert hasattr(proxy, \"disconnect\")\n        proxy.disconnect()", "is_method": true, "class_name": "Runner", "function_description": "Convenience method in Runner that disconnects the current backend proxy, facilitating clean termination of backend connections or sessions when needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "disconnect_enabled", "line_number": 478, "body": "def disconnect_enabled(self):\n        return hasattr(self.get_backend_proxy(), \"disconnect\")", "is_method": true, "class_name": "Runner", "function_description": "Checks if the backend proxy supports a disconnect operation, indicating whether disconnection functionality is available for use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "ctrld", "line_number": 481, "body": "def ctrld(self):\n        proxy = self.get_backend_proxy()\n        if not proxy:\n            return\n\n        if get_shell().has_pending_input():\n            messagebox.showerror(\n                \"Can't perform this action\",\n                \"Ctrl+D only has effect on an empty line / prompt.\\n\"\n                + \"Submit current input (press ENTER) and try again\",\n                master=self,\n            )\n            return\n\n        proxy.send_command(EOFCommand())\n        self._set_state(\"running\")", "is_method": true, "class_name": "Runner", "function_description": "Method of the Runner class that sends an end-of-file command to the backend proxy when the input is empty, signaling termination of input and updating the runner's state accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "ctrld_enabled", "line_number": 498, "body": "def ctrld_enabled(self):\n        proxy = self.get_backend_proxy()\n        return proxy and proxy.is_connected()", "is_method": true, "class_name": "Runner", "function_description": "Checks if the Runner's backend proxy is connected, indicating whether control features are enabled. Useful for verifying connectivity before executing dependent operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_poll_backend_messages", "line_number": 502, "body": "def _poll_backend_messages(self) -> None:\n        \"\"\"I chose polling instead of event_generate in listener thread,\n        because event_generate across threads is not reliable\n        http://www.thecodingforums.com/threads/more-on-tk-event_generate-and-threads.359615/\n        \"\"\"\n        self._polling_after_id = None\n        if self._pull_backend_messages() is False:\n            return\n\n        self._polling_after_id = get_workbench().after(20, self._poll_backend_messages)", "is_method": true, "class_name": "Runner", "function_description": "Internal method of the Runner class that repeatedly polls backend messages at short intervals to handle asynchronous communication without relying on unreliable cross-thread events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_pull_backend_messages", "line_number": 513, "body": "def _pull_backend_messages(self):\n        # Don't process too many messages in single batch, allow screen updates\n        # and user actions between batches.\n        # Mostly relevant when backend prints a lot quickly.\n        msg_count = 0\n        max_msg_count = 10\n        while self._proxy is not None and msg_count < max_msg_count:\n            try:\n                msg = self._proxy.fetch_next_message()\n                if not msg:\n                    break\n                logging.debug(\n                    \"RUNNER GOT: %s, %s in state: %s\", msg.event_type, msg, self.get_state()\n                )\n\n                msg_count += 1\n            except BackendTerminatedError as exc:\n                self._report_backend_crash(exc)\n                self.destroy_backend()\n                return False\n\n            if msg.get(\"SystemExit\", False):\n                self.restart_backend(True)\n                return False\n\n            # change state\n            if isinstance(msg, ToplevelResponse):\n                self._set_state(\"waiting_toplevel_command\")\n            elif isinstance(msg, DebuggerResponse):\n                self._set_state(\"waiting_debugger_command\")\n            else:\n                \"other messages don't affect the state\"\n\n            # Publish the event\n            # NB! This may cause another command to be sent before we get to postponed commands.\n            try:\n                self._publishing_events = True\n                class_event_type = type(msg).__name__\n                get_workbench().event_generate(class_event_type, event=msg)  # more general event\n                if msg.event_type != class_event_type:\n                    # more specific event\n                    get_workbench().event_generate(msg.event_type, event=msg)\n            finally:\n                self._publishing_events = False\n\n            # TODO: is it necessary???\n            # https://stackoverflow.com/a/13520271/261181\n            # get_workbench().update()\n\n        self._send_postponed_commands()", "is_method": true, "class_name": "Runner", "function_description": "Process up to ten incoming backend messages per batch, updating the Runner's state accordingly and generating corresponding events, while handling backend errors and ensuring responsiveness between message batches."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_report_backend_crash", "line_number": 564, "body": "def _report_backend_crash(self, exc: Exception) -> None:\n        returncode = getattr(exc, \"returncode\", \"?\")\n        err = \"Backend terminated or disconnected.\"\n\n        try:\n            faults_file = os.path.join(THONNY_USER_DIR, \"backend_faults.log\")\n            if os.path.exists(faults_file):\n                with open(faults_file, encoding=\"ASCII\") as fp:\n                    err += fp.read()\n        except Exception:\n            logging.exception(\"Failed retrieving backend faults\")\n\n        err = err.strip() + \" Use 'Stop/Restart' to restart.\\n\"\n\n        if returncode != EXPECTED_TERMINATION_CODE:\n            get_workbench().event_generate(\"ProgramOutput\", stream_name=\"stderr\", data=\"\\n\" + err)\n\n        get_workbench().become_active_window(False)", "is_method": true, "class_name": "Runner", "function_description": "Utility method in the Runner class that logs and reports backend crashes by reading fault logs and notifying the user, aiding in backend error diagnosis and recovery."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "restart_backend", "line_number": 583, "body": "def restart_backend(self, clean: bool, first: bool = False, wait: float = 0) -> None:\n        \"\"\"Recreate (or replace) backend proxy / backend process.\"\"\"\n\n        if not first:\n            get_shell().restart()\n            get_shell().update_idletasks()\n\n        self.destroy_backend()\n        backend_name = get_workbench().get_option(\"run.backend_name\")\n        if backend_name not in get_workbench().get_backends():\n            raise UserError(\n                \"Can't find backend '{}'. Please select another backend from options\".format(\n                    backend_name\n                )\n            )\n\n        backend_class = get_workbench().get_backends()[backend_name].proxy_class\n        self._set_state(\"running\")\n        self._proxy = None\n        self._proxy = backend_class(clean)\n\n        self._poll_backend_messages()\n\n        if wait:\n            start_time = time.time()\n            while not self.is_waiting_toplevel_command() and time.time() - start_time <= wait:\n                # self._pull_backend_messages()\n                get_workbench().update()\n                sleep(0.01)\n\n        get_workbench().event_generate(\"BackendRestart\", full=True)", "is_method": true, "class_name": "Runner", "function_description": "Method of the Runner class that restarts or replaces the backend process or proxy, optionally cleaning and waiting for readiness. It ensures backend availability and triggers appropriate events for backend restart handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "destroy_backend", "line_number": 615, "body": "def destroy_backend(self) -> None:\n        if self._polling_after_id is not None:\n            get_workbench().after_cancel(self._polling_after_id)\n            self._polling_after_id = None\n\n        self._postponed_commands = []\n        if self._proxy:\n            self._proxy.destroy()\n            self._proxy = None\n\n        get_workbench().event_generate(\"BackendTerminated\")", "is_method": true, "class_name": "Runner", "function_description": "Method of Runner that terminates backend processes, cancels ongoing tasks, clears pending commands, and signals the system of backend termination to ensure clean shutdown and resource release."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_local_executable", "line_number": 627, "body": "def get_local_executable(self) -> Optional[str]:\n        if self._proxy is None:\n            return None\n        else:\n            return self._proxy.get_local_executable()", "is_method": true, "class_name": "Runner", "function_description": "Method of the Runner class that returns the path to a local executable via its proxy, or None if no proxy is set. It provides access to local executable information when available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_backend_proxy", "line_number": 633, "body": "def get_backend_proxy(self) -> \"BackendProxy\":\n        return self._proxy", "is_method": true, "class_name": "Runner", "function_description": "Provides access to the Runner's backend proxy instance, enabling other components to interact with backend services or operations through this proxy object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_check_alloc_console", "line_number": 636, "body": "def _check_alloc_console(self) -> None:\n        if sys.executable.endswith(\"pythonw.exe\"):\n            # These don't have console allocated.\n            # Console is required for sending interrupts.\n\n            # AllocConsole would be easier but flashes console window\n\n            import ctypes\n\n            kernel32 = ctypes.WinDLL(\"kernel32\", use_last_error=True)\n\n            exe = sys.executable.replace(\"pythonw.exe\", \"python.exe\")\n\n            cmd = [exe, \"-c\", \"print('Hi!'); input()\"]\n            child = subprocess.Popen(\n                cmd,\n                stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                shell=True,\n            )\n            child.stdout.readline()\n            result = kernel32.AttachConsole(child.pid)\n            if not result:\n                err = ctypes.get_last_error()\n                logging.info(\"Could not allocate console. Error code: \" + str(err))\n            child.stdin.write(b\"\\n\")\n            try:\n                child.stdin.flush()\n            except Exception:\n                # May happen eg. when installation path has \"&\" in it\n                # See https://bitbucket.org/plas/thonny/issues/508/cant-allocate-windows-console-when\n                # Without flush the console window becomes visible, but Thonny can be still used\n                logger.exception(\"Problem with finalizing console allocation\")", "is_method": true, "class_name": "Runner", "function_description": "Internal method of the Runner class that ensures a console is allocated on Windows when running under pythonw.exe, enabling proper handling of interrupt signals. It facilitates console attachment without showing a visible console window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "ready_for_remote_file_operations", "line_number": 671, "body": "def ready_for_remote_file_operations(self, show_message=False):\n        if not self._proxy or not self.supports_remote_files():\n            return False\n\n        ready = self._proxy.ready_for_remote_file_operations()\n\n        if not ready and show_message:\n            if not self._proxy.is_connected():\n                msg = \"Device is not connected\"\n            else:\n                msg = (\n                    \"Device is busy -- can't perform this action now.\"\n                    + \"\\nPlease wait or cancel current work and try again!\"\n                )\n            messagebox.showerror(\"Can't complete\", msg, master=get_workbench())\n\n        return ready", "is_method": true, "class_name": "Runner", "function_description": "Checks if the Runner\u2019s proxy device is prepared for remote file operations, optionally showing error messages if not ready or disconnected. Useful for validating remote file access before performing file-related tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_supported_features", "line_number": 689, "body": "def get_supported_features(self) -> Set[str]:\n        if self._proxy is None:\n            return set()\n        else:\n            return self._proxy.get_supported_features()", "is_method": true, "class_name": "Runner", "function_description": "Utility method of the Runner class that returns the set of features supported by its proxy component, enabling feature discovery or capability checks before executing tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "supports_remote_files", "line_number": 695, "body": "def supports_remote_files(self):\n        if self._proxy is None:\n            return False\n        else:\n            return self._proxy.supports_remote_files()", "is_method": true, "class_name": "Runner", "function_description": "Checks if the Runner supports handling remote files by querying its proxy component. This informs whether remote file operations can be performed through the Runner."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "supports_remote_directories", "line_number": 701, "body": "def supports_remote_directories(self):\n        if self._proxy is None:\n            return False\n        else:\n            return self._proxy.supports_remote_directories()", "is_method": true, "class_name": "Runner", "function_description": "Utility method in the Runner class that checks if the current proxy supports accessing remote directories, enabling features dependent on remote file system operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_node_label", "line_number": 707, "body": "def get_node_label(self):\n        if self._proxy is None:\n            return \"Back-end\"\n        else:\n            return self._proxy.get_node_label()", "is_method": true, "class_name": "Runner", "function_description": "Returns the label of the node, either from an associated proxy or a default \"Back-end\" label, providing a unified way to identify the node in different runtime contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "using_venv", "line_number": 713, "body": "def using_venv(self) -> bool:\n        from thonny.plugins.cpython import CPythonProxy\n\n        return isinstance(self._proxy, CPythonProxy) and self._proxy._in_venv", "is_method": true, "class_name": "Runner", "function_description": "Determines if the Runner instance is executing within a Python virtual environment by checking its proxy type and environment status. Useful for adapting behavior based on whether code runs inside a virtual environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_sys_path", "line_number": 752, "body": "def get_sys_path(self):\n        \"backend's sys.path\"\n        return []", "is_method": true, "class_name": "BackendProxy", "function_description": "This method returns the backend's sys.path list, representing module search paths. It provides access to the backend's Python environment paths but currently returns an empty list."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_backend_name", "line_number": 756, "body": "def get_backend_name(self):\n        return type(self).backend_name", "is_method": true, "class_name": "BackendProxy", "function_description": "Returns the name of the backend associated with this proxy instance, identifying the backend implementation in use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_connected", "line_number": 772, "body": "def is_connected(self):\n        return True", "is_method": true, "class_name": "BackendProxy", "function_description": "Returns the connection status of the backend, always indicating it is connected. This method can be used to confirm availability in proxy interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_local_executable", "line_number": 775, "body": "def get_local_executable(self):\n        \"\"\"Return system command for invoking current interpreter\"\"\"\n        return None", "is_method": true, "class_name": "BackendProxy", "function_description": "Returns None indicating that retrieving the system command for the current Python interpreter is not implemented in this BackendProxy method."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_supported_features", "line_number": 779, "body": "def get_supported_features(self):\n        return {\"run\"}", "is_method": true, "class_name": "BackendProxy", "function_description": "Method of BackendProxy that returns the set of features supported by the backend, currently indicating support for running operations. This enables clients to query capabilities before execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_node_label", "line_number": 782, "body": "def get_node_label(self):\n        \"\"\"Used as files caption if back-end has separate files\"\"\"\n        return \"Back-end\"", "is_method": true, "class_name": "BackendProxy", "function_description": "Returns a label identifying the backend node, typically used as a caption for backend files in related interfaces or displays."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_full_label", "line_number": 786, "body": "def get_full_label(self):\n        \"\"\"Used in pip GUI title\"\"\"\n        return self.get_node_label()", "is_method": true, "class_name": "BackendProxy", "function_description": "Returns the full label of the backend proxy, typically used for display in the GUI title."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "supports_remote_files", "line_number": 790, "body": "def supports_remote_files(self):\n        \"\"\"Whether remote file browser should be presented with this back-end\"\"\"\n        return False", "is_method": true, "class_name": "BackendProxy", "function_description": "Indicates if the backend supports browsing remote files, guiding whether a remote file browser should be made available in the interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "uses_local_filesystem", "line_number": 794, "body": "def uses_local_filesystem(self):\n        \"\"\"Whether it runs code from local files\"\"\"\n        return True", "is_method": true, "class_name": "BackendProxy", "function_description": "Indicates if the backend proxy executes code from the local filesystem, informing components about the environment's file execution context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "supports_remote_directories", "line_number": 798, "body": "def supports_remote_directories(self):\n        return False", "is_method": true, "class_name": "BackendProxy", "function_description": "Indicates that the backend does not support operations on remote directories. This function helps determine compatibility with remote directory features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "supports_trash", "line_number": 801, "body": "def supports_trash(self):\n        return True", "is_method": true, "class_name": "BackendProxy", "function_description": "Indicates whether the backend supports trash functionality, allowing other components to adapt behavior based on this capability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "ready_for_remote_file_operations", "line_number": 810, "body": "def ready_for_remote_file_operations(self):\n        return False", "is_method": true, "class_name": "BackendProxy", "function_description": "Returns a boolean indicating if the backend proxy supports remote file operations; used to determine available capabilities for file handling in remote environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_clean_description", "line_number": 816, "body": "def get_clean_description(self):\n        return self.backend_description", "is_method": true, "class_name": "BackendProxy", "function_description": "Returns the stored description of the backend. It provides access to the backend's descriptive information for use in configuration or logging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_current_switcher_configuration", "line_number": 820, "body": "def get_current_switcher_configuration(cls):\n        \"\"\"returns the dict of configuration entries that distinguish current backend conf from other\n        items in the backend switcher\"\"\"\n        return {\"run.backend_name\": cls.backend_name}", "is_method": true, "class_name": "BackendProxy", "function_description": "Returns a dictionary highlighting the current backend configuration key that differentiates it within a backend switcher system. Useful for identifying or selecting the active backend setup in multi-backend environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_switcher_entries", "line_number": 826, "body": "def get_switcher_entries(cls):\n        \"\"\"\n        Each returned entry creates one item in the backend switcher menu.\n        \"\"\"\n        return [(cls.get_current_switcher_configuration(), cls.backend_description)]", "is_method": true, "class_name": "BackendProxy", "function_description": "Provides backend switcher menu items with current configuration and description, enabling dynamic backend selection in the BackendProxy class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "has_custom_system_shell", "line_number": 832, "body": "def has_custom_system_shell(self):\n        return False", "is_method": true, "class_name": "BackendProxy", "function_description": "Indicates whether the backend uses a custom system shell. This function can be used to determine shell compatibility or customization requirements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_get_environment", "line_number": 871, "body": "def _get_environment(self):\n        env = get_environment_for_python_subprocess(self._executable)\n        # variables controlling communication with the back-end process\n        env[\"PYTHONIOENCODING\"] = \"utf-8\"\n\n        # because cmd line option -u won't reach child processes\n        # see https://github.com/thonny/thonny/issues/808\n        env[\"PYTHONUNBUFFERED\"] = \"1\"\n\n        # Let back-end know about plug-ins\n        env[\"THONNY_USER_DIR\"] = THONNY_USER_DIR\n        env[\"THONNY_FRONTEND_SYS_PATH\"] = repr(sys.path)\n\n        env[\"THONNY_LANGUAGE\"] = get_workbench().get_option(\"general.language\")\n\n        if thonny.in_debug_mode():\n            env[\"THONNY_DEBUG\"] = \"1\"\n        elif \"THONNY_DEBUG\" in env:\n            del env[\"THONNY_DEBUG\"]\n        return env", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Generates and returns a customized environment dictionary for a Python subprocess, configuring encoding, buffering, and Thonny-specific variables to ensure proper communication and plugin integration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_start_background_process", "line_number": 892, "body": "def _start_background_process(self, clean=None, extra_args=[]):\n        # deque, because in one occasion I need to put messages back\n        self._response_queue = collections.deque()\n\n        if not os.path.exists(self._executable):\n            raise UserError(\n                \"Interpreter (%s) not found. Please recheck corresponding option!\"\n                % self._executable\n            )\n\n        cmd_line = (\n            [\n                self._executable,\n                \"-u\",  # unbuffered IO\n                \"-B\",  # don't write pyo/pyc files\n                # (to avoid problems when using different Python versions without write permissions)\n            ]\n            + self._get_launcher_with_args()\n            + extra_args\n        )\n\n        creationflags = 0\n        if running_on_windows():\n            creationflags = subprocess.CREATE_NEW_PROCESS_GROUP\n\n        debug(\"Starting the backend: %s %s\", cmd_line, get_workbench().get_local_cwd())\n\n        extra_params = {}\n        if sys.version_info >= (3, 6):\n            extra_params[\"encoding\"] = \"utf-8\"\n\n        self._proc = subprocess.Popen(\n            cmd_line,\n            bufsize=0,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            cwd=self._get_launch_cwd(),\n            env=self._get_environment(),\n            universal_newlines=True,\n            creationflags=creationflags,\n            **extra_params\n        )\n\n        # setup asynchronous output listeners\n        self._terminated_readers = 0\n        Thread(target=self._listen_stdout, args=(self._proc.stdout,), daemon=True).start()\n        Thread(target=self._listen_stderr, args=(self._proc.stderr,), daemon=True).start()", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Starts and manages a background subprocess with configured environment and unbuffered IO, enabling asynchronous communication via stdout and stderr streams for inter-process messaging. It ensures proper process setup and message handling in the SubprocessProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_get_launch_cwd", "line_number": 941, "body": "def _get_launch_cwd(self):\n        return self.get_cwd() if self.uses_local_filesystem() else None", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Returns the working directory path to use when launching a subprocess, based on whether the local filesystem is utilized. This helps configure subprocess execution environments appropriately."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_command", "line_number": 947, "body": "def send_command(self, cmd: CommandToBackend) -> Optional[str]:\n        \"\"\"Send the command to backend. Return None, 'discard' or 'postpone'\"\"\"\n        if isinstance(cmd, ToplevelCommand) and cmd.name[0].isupper():\n            self._clear_environment()\n\n        if isinstance(cmd, ToplevelCommand):\n            # required by SshCPythonBackend for creating fresh target process\n            cmd[\"expected_cwd\"] = self._cwd\n\n        method_name = \"_cmd_\" + cmd.name\n\n        if hasattr(self, method_name):\n            getattr(self, method_name)(cmd)\n        else:\n            self._send_msg(cmd)", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Method of SubprocessProxy that dispatches a command to the backend, handling environment setup and custom processing based on the command type, with support for deferred or discarded execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_send_msg", "line_number": 963, "body": "def _send_msg(self, msg):\n        self._proc.stdin.write(serialize_message(msg) + \"\\n\")\n        self._proc.stdin.flush()", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Internal method of SubprocessProxy that sends a serialized message to the subprocess's standard input stream to facilitate communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_program_input", "line_number": 970, "body": "def send_program_input(self, data):\n        self._send_msg(InputSubmission(data))", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Utility method of SubprocessProxy that sends input data to a subprocess, enabling dynamic interaction or command submission during subprocess execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "process_is_alive", "line_number": 973, "body": "def process_is_alive(self):\n        return self._proc is not None and self._proc.poll() is None", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Checks whether the subprocess managed by SubprocessProxy is currently running. This helps other functions determine the subprocess's active status for flow control or monitoring purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_terminated", "line_number": 976, "body": "def is_terminated(self):\n        return not self.process_is_alive()", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Checks whether the subprocess managed by SubprocessProxy has ended by determining if its underlying process is no longer alive. This function helps monitor and control subprocess lifecycle status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_connected", "line_number": 979, "body": "def is_connected(self):\n        return self.process_is_alive()", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Checks whether the subprocess managed by SubprocessProxy is currently active and running."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_sys_path", "line_number": 982, "body": "def get_sys_path(self):\n        return self._sys_path", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Returns the system path stored within the SubprocessProxy instance. This enables other components to access the subprocess's Python environment path information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "destroy", "line_number": 985, "body": "def destroy(self):\n        self._close_backend()", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Method of the SubprocessProxy class that cleanly terminates and releases resources associated with the subprocess backend. It provides a controlled way to shut down subprocesses managed by the proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_close_backend", "line_number": 988, "body": "def _close_backend(self):\n        if self._proc is not None and self._proc.poll() is None:\n            self._proc.kill()\n\n        self._proc = None\n        self._response_queue = None", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Private method of SubprocessProxy that terminates the managed subprocess if running and clears related internal references to ensure proper cleanup of resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_listen_stdout", "line_number": 995, "body": "def _listen_stdout(self, stdout):\n        # debug(\"... started listening to stdout\")\n        # will be called from separate thread\n\n        # allow self._response_queue to be replaced while processing\n        message_queue = self._response_queue\n\n        def publish_as_msg(data):\n            msg = parse_message(data)\n            if \"cwd\" in msg:\n                self.cwd = msg[\"cwd\"]\n            message_queue.append(msg)\n\n            if len(message_queue) > 10:\n                # Probably backend runs an infinite/long print loop.\n                # Throttle message throughput in order to keep GUI thread responsive.\n                while len(message_queue) > 0:\n                    sleep(0.005)\n\n        while True:\n            try:\n                data = stdout.readline()\n            except IOError:\n                sleep(0.1)\n                continue\n\n            # debug(\"... read some stdout data\", repr(data))\n            if data == \"\":\n                break\n            else:\n                try:\n                    publish_as_msg(data)\n                except Exception:\n                    # Can mean the line was from subprocess,\n                    # which can't be captured by stream faking.\n                    # NB! If subprocess printed it without linebreak,\n                    # then the suffix can be thonny message\n\n                    parts = data.rsplit(common.MESSAGE_MARKER, maxsplit=1)\n\n                    # print first part as it is\n                    message_queue.append(\n                        BackendEvent(\"ProgramOutput\", data=parts[0], stream_name=\"stdout\")\n                    )\n\n                    if len(parts) == 2:\n                        second_part = common.MESSAGE_MARKER + parts[1]\n                        try:\n                            publish_as_msg(second_part)\n                        except Exception:\n                            # just print ...\n                            message_queue.append(\n                                BackendEvent(\n                                    \"ProgramOutput\", data=second_part, stream_name=\"stdout\"\n                                )\n                            )\n\n        self._terminated_readers += 1", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Continuously reads and processes standard output from a subprocess, converting output lines into structured messages for asynchronous handling while managing message flow to keep the interface responsive."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_listen_stderr", "line_number": 1054, "body": "def _listen_stderr(self, stderr):\n        # stderr is used only for debugger debugging\n        while True:\n            data = stderr.readline()\n            if data == \"\":\n                break\n            else:\n                self._response_queue.append(\n                    BackendEvent(\"ProgramOutput\", stream_name=\"stderr\", data=data)\n                )\n\n        self._terminated_readers += 1", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Internal method of SubprocessProxy that continuously reads and queues standard error output from a subprocess for debugging and logging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_store_state_info", "line_number": 1067, "body": "def _store_state_info(self, msg):\n        if \"cwd\" in msg:\n            self._cwd = msg[\"cwd\"]\n            self._publish_cwd(msg[\"cwd\"])\n\n        if msg.get(\"welcome_text\"):\n            self._welcome_text = msg[\"welcome_text\"]\n\n        if \"in_venv\" in msg:\n            self._in_venv = msg[\"in_venv\"]\n\n        if \"sys_path\" in msg:\n            self._sys_path = msg[\"sys_path\"]\n\n        if \"usersitepackages\" in msg:\n            self._usersitepackages = msg[\"usersitepackages\"]\n\n        if \"prefix\" in msg:\n            self._sys_prefix = msg[\"prefix\"]\n\n        if \"exe_dirs\" in msg:\n            self._exe_dirs = msg[\"exe_dirs\"]\n\n        if msg.get(\"executable\"):\n            self._reported_executable = msg[\"executable\"]", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Stores various environment and state details from a given message, updating the subprocess proxy's internal context such as current directory, virtual environment status, and system paths for later use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_publish_cwd", "line_number": 1093, "body": "def _publish_cwd(self, cwd):\n        if self.uses_local_filesystem():\n            get_workbench().set_local_cwd(cwd)", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Private method in SubprocessProxy that updates the local working directory in the workbench if the subprocess uses the local filesystem. It supports synchronizing directory context for subprocess operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_supported_features", "line_number": 1097, "body": "def get_supported_features(self):\n        return {\"run\"}", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Core method of the SubprocessProxy class that identifies and returns the set of supported subprocess operations, currently indicating it supports the \"run\" feature."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_site_packages", "line_number": 1100, "body": "def get_site_packages(self):\n        # NB! site.sitepackages may not be present in virtualenv\n        for d in self._sys_path:\n            if (\"site-packages\" in d or \"dist-packages\" in d) and path_startswith(\n                d, self._sys_prefix\n            ):\n                return d\n\n        return None", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Utility method of SubprocessProxy that locates and returns the path to the Python site-packages or dist-packages directory within the subprocess environment, aiding dependency and package management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_user_site_packages", "line_number": 1110, "body": "def get_user_site_packages(self):\n        return self._usersitepackages", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Returns the user-specific site-packages directory path stored in the SubprocessProxy instance, enabling access to the Python environment's user-level package installation location."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_cwd", "line_number": 1113, "body": "def get_cwd(self):\n        return self._cwd", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Returns the current working directory stored within the SubprocessProxy instance, allowing other components to access or reference the subprocess's execution path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_exe_dirs", "line_number": 1116, "body": "def get_exe_dirs(self):\n        return self._exe_dirs", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Returns the list of executable directories managed by the SubprocessProxy instance. This method provides access to the configured search paths for locating executable files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "fetch_next_message", "line_number": 1119, "body": "def fetch_next_message(self):\n        if not self._response_queue or len(self._response_queue) == 0:\n            if self.is_terminated() and self._terminated_readers == 2:\n                raise BackendTerminatedError(self._proc.returncode if self._proc else None)\n            else:\n                return None\n\n        msg = self._response_queue.popleft()\n        self._store_state_info(msg)\n        if msg.event_type == \"ProgramOutput\":\n            # combine available small output messages to one single message,\n            # in order to put less pressure on UI code\n\n            wait_time = 0.01\n            total_wait_time = 0\n            while True:\n                if len(self._response_queue) == 0:\n                    if _ends_with_incomplete_ansi_code(msg[\"data\"]) and total_wait_time < 0.1:\n                        # Allow reader to send the remaining part\n                        sleep(wait_time)\n                        total_wait_time += wait_time\n                        continue\n                    else:\n                        return msg\n                else:\n                    next_msg = self._response_queue.popleft()\n                    if (\n                        next_msg.event_type == \"ProgramOutput\"\n                        and next_msg[\"stream_name\"] == msg[\"stream_name\"]\n                        and (\n                            len(msg[\"data\"]) + len(next_msg[\"data\"]) <= OUTPUT_MERGE_THRESHOLD\n                            and (\"\\n\" not in msg[\"data\"] or not io_animation_required)\n                            or _ends_with_incomplete_ansi_code(msg[\"data\"])\n                        )\n                    ):\n                        msg[\"data\"] += next_msg[\"data\"]\n                    else:\n                        # not to be sent in the same block, put it back\n                        self._response_queue.appendleft(next_msg)\n                        return msg\n\n        else:\n            return msg", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Core method of SubprocessProxy that retrieves and combines the next available output or event message from an internal queue, optimizing output chunks for streamlined downstream processing or UI handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_title", "line_number": 1400, "body": "def get_title(self):\n        return self._title", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Returns the title of the InlineCommandDialog instance. This method provides access to the dialog's current title for display or processing purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_instructions", "line_number": 1403, "body": "def get_instructions(self) -> Optional[str]:\n        return self._instructions or self._cmd.get(\"description\", \"Working...\")", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Provides descriptive instructions or a fallback status message for the InlineCommandDialog, helping users understand the current command or dialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_on_response", "line_number": 1406, "body": "def _on_response(self, response):\n        if response.get(\"command_id\") == getattr(self._cmd, \"id\"):\n            logger.debug(\"Dialog got response: %s\", response)\n            self.response = response\n            self.returncode = response.get(\"returncode\", None)\n            success = (\n                not self.returncode and not response.get(\"error\") and not response.get(\"errors\")\n            )\n            if success:\n                self.set_action_text(\"Done!\")\n            else:\n                self.set_action_text(\"Error\")\n                if response.get(\"error\"):\n                    self.append_text(\"Error %s\\n\" % response[\"error\"], stream_name=\"stderr\")\n                if response.get(\"errors\"):\n                    self.append_text(\"Errors %s\\n\" % response[\"errors\"], stream_name=\"stderr\")\n                if self.returncode:\n                    self.append_text(\n                        \"Process returned with code %s\\n\" % self.returncode, stream_name=\"stderr\"\n                    )\n\n            self.report_done(success)", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Handles and processes a command response by updating dialog status, displaying success or error messages, and reporting completion based on the response\u2019s return code and error information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_on_progress", "line_number": 1429, "body": "def _on_progress(self, msg):\n        if msg.get(\"command_id\") != getattr(self._cmd, \"id\"):\n            return\n\n        if msg.get(\"value\", None) is not None and msg.get(\"maximum\", None) is not None:\n            self.report_progress(msg[\"value\"], msg[\"maximum\"])\n        if msg.get(\"description\"):\n            self.set_action_text(msg[\"description\"])", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Private method in InlineCommandDialog that updates progress and status text based on messages related to the current command's execution progress. It filters messages by command ID and reports progress with optional descriptive updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_on_output", "line_number": 1438, "body": "def _on_output(self, msg):\n        stream_name = msg.get(\"stream_name\", \"stdout\")\n        self.append_text(msg[\"data\"], stream_name)\n        self.set_action_text_smart(msg[\"data\"])", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Internal handler of InlineCommandDialog that processes output messages by appending their text to the dialog and updating action text accordingly based on the message stream."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "start_work", "line_number": 1443, "body": "def start_work(self):\n        self.send_command_to_backend()", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Starts the dialog's workflow by sending a command to the backend system. This function initiates the primary interaction process within the InlineCommandDialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_command_to_backend", "line_number": 1446, "body": "def send_command_to_backend(self):\n        if not isinstance(self._cmd, CommandToBackend):\n            # it was a lazy definition\n            try:\n                self._cmd = self._cmd()\n            except Exception as e:\n                logger.error(\"Could not produce command for backend\", self._cmd)\n                self.set_action_text(\"Error!\")\n                self.append_text(\"Could not produce command for backend\\n\")\n                self.append_text(\"\".join(traceback.format_exc()) + \"\\n\")\n                self.report_done(False)\n                return\n\n        logger.debug(\"Starting command in dialog: %s\", self._cmd)\n        get_runner().send_command(self._cmd)", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Method of InlineCommandDialog that prepares and sends a backend command, handling lazy initialization and error reporting to ensure command execution triggers properly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "cancel_work", "line_number": 1462, "body": "def cancel_work(self):\n        super(InlineCommandDialog, self).cancel_work()\n        get_runner()._cmd_interrupt()", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Cancels the current work or command in progress within the InlineCommandDialog and interrupts the running command process to halt its execution immediately."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "close", "line_number": 1466, "body": "def close(self):\n        get_workbench().unbind(\"InlineResponse\", self._on_response)\n        get_workbench().unbind(\"InlineProgress\", self._on_progress)\n        super(InlineCommandDialog, self).close()\n        get_shell().set_ignore_program_output(False)", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Method of InlineCommandDialog that closes the dialog, unbinds related response and progress events, and restores normal program output handling. It ensures proper cleanup when the dialog is dismissed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "format_object_id", "line_number": 14, "body": "def format_object_id(object_id):\n    # this format aligns with how Python shows memory addresses\n    if object_id is None:\n        return None\n    else:\n        return \"0x\" + hex(object_id)[2:]", "is_method": false, "function_description": "Utility function that formats an integer object ID as a hexadecimal string prefixed with \"0x\", matching Python\u2019s typical memory address representation style."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "parse_object_id", "line_number": 22, "body": "def parse_object_id(object_id_repr):\n    return int(object_id_repr, base=16)", "is_method": false, "function_description": "Converts a hexadecimal string representation of an object ID into its integer form. Useful for interpreting or processing IDs stored as hex strings in various systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "stop_debugging", "line_number": 34, "body": "def stop_debugging(self):\n        self._clear_tree()", "is_method": true, "class_name": "MemoryFrame", "function_description": "Utility method in MemoryFrame that stops any ongoing debugging process by clearing its associated data structures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "show_selected_object_info", "line_number": 37, "body": "def show_selected_object_info(self):\n        object_id = self.get_object_id()\n        if object_id is not None:\n            get_workbench().event_generate(\"ObjectSelect\", object_id=object_id)", "is_method": true, "class_name": "MemoryFrame", "function_description": "Method in MemoryFrame that triggers an event to broadcast information about the currently selected object, facilitating interaction or updates in connected components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "get_object_id", "line_number": 42, "body": "def get_object_id(self):\n        iid = self.tree.focus()\n        if iid != \"\":\n            # NB! Assuming id is second column!\n            id_str = self.tree.item(iid)[\"values\"][1]\n            if id_str in [\"\", None, \"None\"]:\n                return None\n\n            return parse_object_id(id_str)\n\n        return None", "is_method": true, "class_name": "MemoryFrame", "function_description": "Returns the parsed object ID associated with the currently selected item in the MemoryFrame's tree, or None if no valid selection exists. Useful for identifying or retrieving specific objects from the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "destroy", "line_number": 76, "body": "def destroy(self):\n        MemoryFrame.destroy(self)\n        get_workbench().unbind(\"ShowView\", self._update_memory_model)\n        get_workbench().unbind(\"HideView\", self._update_memory_model)", "is_method": true, "class_name": "VariablesFrame", "function_description": "Service method of VariablesFrame that performs cleanup by destroying the memory frame and unbinding associated view update handlers from the workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "_update_memory_model", "line_number": 81, "body": "def _update_memory_model(self, event=None):\n        if get_workbench().in_heap_mode():\n            self.tree.configure(displaycolumns=(\"name\", \"id\"))\n            # self.tree.columnconfigure(1, weight=1, width=400)\n            # self.tree.columnconfigure(2, weight=0)\n        else:\n            self.tree.configure(displaycolumns=(\"name\", \"value\"))", "is_method": true, "class_name": "VariablesFrame", "function_description": "Updates the display columns of the VariablesFrame's tree view based on the current workbench mode, toggling between showing variable names and IDs or names and values."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "update_variables", "line_number": 91, "body": "def update_variables(self, all_variables):\n        self._clear_tree()\n\n        if not all_variables:\n            return\n\n        if isinstance(all_variables, list):\n            groups = all_variables\n        else:\n            groups = [(\"\", all_variables)]\n\n        for group_title, variables in groups:\n            if group_title:\n                node_id = self.tree.insert(\"\", \"end\", tags=(\"group_title\",))\n                self.tree.set(node_id, \"name\", group_title)\n\n            for name in sorted(variables.keys()):\n\n                if not name.startswith(\"__\"):\n                    node_id = self.tree.insert(\"\", \"end\", tags=\"item\")\n                    self.tree.set(node_id, \"name\", name)\n                    if isinstance(variables[name], ValueInfo):\n                        description = variables[name].repr\n                        id_str = variables[name].id\n                    else:\n                        description = variables[name]\n                        id_str = None\n\n                    self.tree.set(node_id, \"id\", format_object_id(id_str))\n                    self.tree.set(node_id, \"value\", description)", "is_method": true, "class_name": "VariablesFrame", "function_description": "Updates the VariablesFrame display by clearing and repopulating it with a new set of variables, optionally grouped and sorted, to reflect the current variable names and their descriptions or metadata."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "on_select", "line_number": 122, "body": "def on_select(self, event):\n        self.show_selected_object_info()", "is_method": true, "class_name": "VariablesFrame", "function_description": "Handles selection events by displaying information about the currently selected object in the VariablesFrame context, facilitating user interaction and object inspection within the interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "get_text_font", "line_number": 1136, "body": "def get_text_font(text):\n    font = text[\"font\"]\n    if isinstance(font, str):\n        return tkfont.nametofont(font)\n    else:\n        return font", "is_method": false, "function_description": "Returns the actual font object associated with a text element, handling both named font strings and font objects. This utility helps standardize font retrieval for text rendering or styling tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "classifyws", "line_number": 1144, "body": "def classifyws(s, tabwidth):\n    raw = effective = 0\n    for ch in s:\n        if ch == \" \":\n            raw = raw + 1\n            effective = effective + 1\n        elif ch == \"\\t\":\n            raw = raw + 1\n            effective = (effective // tabwidth + 1) * tabwidth\n        else:\n            break\n    return raw, effective", "is_method": false, "function_description": "Function that calculates the number of leading whitespace characters in a string, counting tabs as variable-width, and returns both the raw count and effective width. Useful for parsing or measuring indentation levels in text processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "index2line", "line_number": 1158, "body": "def index2line(index):\n    return int(float(index))", "is_method": false, "function_description": "Converts a given index value, potentially in float or string form, into an integer line number. This function standardizes index inputs to integer line identifiers for consistent line-based operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "line2index", "line_number": 1162, "body": "def line2index(line):\n    return str(float(line))", "is_method": false, "function_description": "Convert a given line string to its floating-point representation and return it as a string. This function standardizes numerical line data for further processing or comparison."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "fixwordbreaks", "line_number": 1166, "body": "def fixwordbreaks(root):\n    # Adapted from idlelib.EditorWindow (Python 3.4.2)\n    # Modified to include non-ascii chars\n\n    # Make sure that Tk's double-click and next/previous word\n    # operations use our definition of a word (i.e. an identifier)\n    root.tk.call(\"tcl_wordBreakAfter\", \"a b\", 0)  # make sure word.tcl is loaded\n    root.tk.call(\"set\", \"tcl_wordchars\", r\"\\w\")\n    root.tk.call(\"set\", \"tcl_nonwordchars\", r\"\\W\")", "is_method": false, "function_description": "Function fixwordbreaks configures the Tkinter text widget to use customized word boundaries including non-ASCII characters for word selection operations. It ensures word-based navigation and text selection behave according to a defined word character set."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "rebind_control_a", "line_number": 1177, "body": "def rebind_control_a(root):\n    # Tk 8.6 has <<SelectAll>> event but 8.5 doesn't\n    # http://stackoverflow.com/questions/22907200/remap-default-keybinding-in-tkinter\n    def control_a(event):\n        widget = event.widget\n        if isinstance(widget, tk.Text):\n            widget.tag_remove(\"sel\", \"1.0\", \"end\")\n            widget.tag_add(\"sel\", \"1.0\", \"end\")\n\n    root.bind_class(\"Text\", \"<Control-a>\", control_a)", "is_method": false, "function_description": "Function that binds the Control-A keyboard shortcut to select all text in Tkinter Text widgets, ensuring consistent behavior across different Tk versions supporting this shortcut."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_running_on_mac", "line_number": 1189, "body": "def _running_on_mac():\n    return tk._default_root.call(\"tk\", \"windowingsystem\") == \"aqua\"", "is_method": false, "function_description": "Utility function that detects whether the current Tkinter application is running on a macOS system by checking the windowing system in use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_running_on_x11", "line_number": 1193, "body": "def _running_on_x11():\n    return tk._default_root.call(\"tk\", \"windowingsystem\") == \"x11\"", "is_method": false, "function_description": "This function checks if the current Tkinter graphical environment is using the X11 windowing system. It helps other functions adapt their behavior based on the windowing backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "get_keyboard_language", "line_number": 1197, "body": "def get_keyboard_language():\n    # https://stackoverflow.com/a/42047820/261181\n    if platform.system() != \"Windows\":\n        raise NotImplementedError(\"Can provide keyboard language only on Windows\")\n\n    import ctypes\n\n    user32 = ctypes.WinDLL(\"user32\", use_last_error=True)\n    curr_window = user32.GetForegroundWindow()\n    thread_id = user32.GetWindowThreadProcessId(curr_window, 0)\n    # Made up of 0xAAABBBB, AAA = HKL (handle object) & BBBB = language ID\n    klid = user32.GetKeyboardLayout(thread_id)\n    # Language ID -> low 10 bits, Sub-language ID -> high 6 bits\n    # Extract language ID from KLID\n    lid = klid & (2 ** 16 - 1)\n\n    return lid", "is_method": false, "function_description": "Function that retrieves the current keyboard input language ID on Windows systems, enabling applications to adapt to or identify the active keyboard layout in real-time."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_register_tk_proxy_function", "line_number": 33, "body": "def _register_tk_proxy_function(self, operation, function):\n        self._tk_proxies[operation] = function\n        setattr(self, operation, function)\n\n        def original_function(*args):\n            self.tk.call((self._original_widget_name, operation) + args)\n\n        return original_function", "is_method": true, "class_name": "TweakableText", "function_description": "Private method of TweakableText that registers a proxy function for a given operation, replacing the original operation with a new callable while preserving access to the original functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_dispatch_tk_operation", "line_number": 42, "body": "def _dispatch_tk_operation(self, operation, *args):\n        f = self._tk_proxies.get(operation)\n        try:\n            if f:\n                return f(*args)\n            else:\n                return self.tk.call((self._original_widget_name, operation) + args)\n\n        except TclError as e:\n            # Some Tk internal actions (eg. paste and cut) can cause this error\n            if (\n                str(e).lower() == '''text doesn't contain any characters tagged with \"sel\"'''\n                and operation in [\"delete\", \"index\", \"get\"]\n                and args in [(\"sel.first\", \"sel.last\"), (\"sel.first\",)]\n            ):\n                pass\n            # Don't worry about hitting ends of undo/redo stacks\n            elif (\n                operation == \"edit\"\n                and args in [(\"undo\",), (\"redo\",)]\n                and str(e).lower() == \"nothing to \" + args[0]\n            ):\n                pass\n            else:\n                exception(\n                    \"[_dispatch_tk_operation] operation: \" + operation + \", args:\" + repr(args)\n                )\n                # traceback.print_exc()\n\n            return \"\"", "is_method": true, "class_name": "TweakableText", "function_description": "Dispatches a text widget operation to either a proxy function or the original Tk widget, handling specific Tkinter TclError exceptions gracefully. It enables reliable execution of widget operations with error management for common edge cases."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_read_only", "line_number": 73, "body": "def set_read_only(self, value):\n        self._read_only = value", "is_method": true, "class_name": "TweakableText", "function_description": "Sets the read-only status of the TweakableText instance, controlling whether its content can be modified. This method enables toggling edit permissions on the text object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "is_read_only", "line_number": 76, "body": "def is_read_only(self):\n        return self._read_only", "is_method": true, "class_name": "TweakableText", "function_description": "Simple accessor method in TweakableText that returns whether the instance is in a read-only state, useful for controlling edit permissions or conditional modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_content", "line_number": 79, "body": "def set_content(self, chars):\n        self.direct_delete(\"1.0\", tk.END)\n        self.direct_insert(\"1.0\", chars)", "is_method": true, "class_name": "TweakableText", "function_description": "Sets the content of the TweakableText widget by replacing its entire text with the given characters. This function enables quick and complete text updates within the widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_insertwidth", "line_number": 83, "body": "def set_insertwidth(self, new_width):\n        \"\"\"Change cursor width\n\n        NB! Need to be careful with setting text[\"insertwidth\"]!\n        My first straightforward solution caused unexplainable\n        infinite loop of insertions and deletions in the text\n        (Repro: insert a line and a word, select that word and then do Ctrl-Z).\n\n        This solution seems safe but be careful!\n        \"\"\"\n        if self._suppress_events:\n            return\n\n        if self[\"insertwidth\"] != new_width:\n            old_suppress = self._suppress_events\n            try:\n                self._suppress_events = True\n                self.config(insertwidth=new_width)\n            finally:\n                self._suppress_events = old_suppress", "is_method": true, "class_name": "TweakableText", "function_description": "Provides a safe way to change the text cursor width in TweakableText, preventing event-related issues or infinite loops during text editing operations. Useful for customizing cursor appearance without disrupting text event handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "intercept_mark", "line_number": 104, "body": "def intercept_mark(self, *args):\n        self.direct_mark(*args)", "is_method": true, "class_name": "TweakableText", "function_description": "Calls an internal method to apply a mark or annotation at specified positions in the text, facilitating customized text modifications within TweakableText."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "intercept_insert", "line_number": 107, "body": "def intercept_insert(self, index, chars, tags=None, **kw):\n        assert isinstance(chars, str)\n        if chars >= \"\\uf704\" and chars <= \"\\uf70d\":  # Function keys F1..F10 in Mac cause these\n            pass\n        elif self.is_read_only():\n            self.bell()\n        else:\n            self.direct_insert(index, chars, tags, **kw)", "is_method": true, "class_name": "TweakableText", "function_description": "Method of TweakableText that conditionally inserts characters at a given index, preventing input when the text is read-only and handling special function key inputs on Mac systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "intercept_delete", "line_number": 116, "body": "def intercept_delete(self, index1, index2=None, **kw):\n        if index1 == \"sel.first\" and index2 == \"sel.last\" and not self.has_selection():\n            return\n\n        if self.is_read_only():\n            self.bell()\n        elif self._is_erroneous_delete(index1, index2):\n            pass\n        else:\n            self.direct_delete(index1, index2, **kw)", "is_method": true, "class_name": "TweakableText", "function_description": "Method of TweakableText that manages text deletion requests, enforcing read-only restrictions and selection validity before performing or blocking the delete operation. It ensures controlled and context-aware text removal behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_is_erroneous_delete", "line_number": 127, "body": "def _is_erroneous_delete(self, index1, index2):\n        \"\"\"Paste can cause deletes where index1 is sel.start but text has no selection. This would cause errors\"\"\"\n        return index1.startswith(\"sel.\") and not self.has_selection()", "is_method": true, "class_name": "TweakableText", "function_description": "Private method in TweakableText identifying delete operations caused by paste actions that would error due to a missing text selection, supporting robust text manipulation error handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "direct_mark", "line_number": 131, "body": "def direct_mark(self, *args):\n        self._original_mark(*args)\n\n        if args[:2] == (\"set\", \"insert\") and not self._suppress_events:\n            self.event_generate(\"<<CursorMove>>\")", "is_method": true, "class_name": "TweakableText", "function_description": "Method in TweakableText that triggers a cursor movement event when text is inserted, enabling responsive UI updates or event-driven behaviors during text modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "index_sel_first", "line_number": 137, "body": "def index_sel_first(self):\n        # Tk will give error without this check\n        if self.tag_ranges(\"sel\"):\n            return self.index(\"sel.first\")\n        else:\n            return None", "is_method": true, "class_name": "TweakableText", "function_description": "Returns the position of the start of the current text selection if any exists; otherwise, returns None. This method helps manage and identify user-selected text regions in a TweakableText widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "index_sel_last", "line_number": 144, "body": "def index_sel_last(self):\n        if self.tag_ranges(\"sel\"):\n            return self.index(\"sel.last\")\n        else:\n            return None", "is_method": true, "class_name": "TweakableText", "function_description": "Returns the index of the last selected text segment if any selection exists; otherwise, it returns None. This supports text selection handling within the TweakableText class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "has_selection", "line_number": 150, "body": "def has_selection(self):\n        return len(self.tag_ranges(\"sel\")) > 0", "is_method": true, "class_name": "TweakableText", "function_description": "Method of TweakableText that checks if there is an active text selection and returns True if any text is currently selected. It enables functionality that depends on verifying user text selection within the text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "get_selection_indices", "line_number": 153, "body": "def get_selection_indices(self):\n        # If a selection is defined in the text widget, return (start,\n        # end) as Tkinter text indices, otherwise return (None, None)\n        if self.has_selection():\n            return self.index(\"sel.first\"), self.index(\"sel.last\")\n        else:\n            return None, None", "is_method": true, "class_name": "TweakableText", "function_description": "Returns the start and end indices of the current text selection if one exists; otherwise, returns None values. This method helps identify selected text ranges for further processing or manipulation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "direct_insert", "line_number": 161, "body": "def direct_insert(self, index, chars, tags=None, **kw):\n        self._original_insert(index, chars, tags, **kw)\n        if not self._suppress_events:\n            self.event_generate(\"<<TextChange>>\")", "is_method": true, "class_name": "TweakableText", "function_description": "Method of TweakableText that inserts characters at a specified index and triggers a text change event unless event suppression is enabled, facilitating dynamic text updates with event notifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "direct_delete", "line_number": 166, "body": "def direct_delete(self, index1, index2=None, **kw):\n        self._original_delete(index1, index2, **kw)\n        if not self._suppress_events:\n            self.event_generate(\"<<TextChange>>\")", "is_method": true, "class_name": "TweakableText", "function_description": "Method of TweakableText that deletes text between given indices and triggers a text change event unless event suppression is enabled. It provides a controlled way to remove text while notifying listeners of updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "should_indent_with_tabs", "line_number": 215, "body": "def should_indent_with_tabs(self):\n        return True", "is_method": true, "class_name": "EnhancedText", "function_description": "Returns a configuration setting indicating that indentation should use tabs. This informs text formatting or editing behaviors in the EnhancedText context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_mouse_aids", "line_number": 218, "body": "def _bind_mouse_aids(self):\n        if _running_on_mac():\n            self.bind(\"<Button-2>\", self.on_secondary_click)\n            self.bind(\"<Control-Button-1>\", self.on_secondary_click)\n        else:\n            self.bind(\"<Button-3>\", self.on_secondary_click)", "is_method": true, "class_name": "EnhancedText", "function_description": "Private method in EnhancedText that configures mouse button event bindings for secondary clicks, adapting controls based on the operating system environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_editing_aids", "line_number": 225, "body": "def _bind_editing_aids(self):\n        def if_not_readonly(fun):\n            def dispatch(event):\n                if not self.is_read_only():\n                    return fun(event)\n                else:\n                    return \"break\"\n\n            return dispatch\n\n        self.bind(\"<Control-BackSpace>\", if_not_readonly(self.delete_word_left), True)\n        self.bind(\"<Control-Delete>\", if_not_readonly(self.delete_word_right), True)\n        self.bind(\"<Control-d>\", self._redirect_ctrld, True)\n        self.bind(\"<Control-t>\", self._redirect_ctrlt, True)\n        self.bind(\"<BackSpace>\", if_not_readonly(self.perform_smart_backspace), True)\n        self.bind(\"<Return>\", if_not_readonly(self.perform_return), True)\n        self.bind(\"<KP_Enter>\", if_not_readonly(self.perform_return), True)\n        self.bind(\"<Tab>\", if_not_readonly(self.perform_tab), True)\n        try:\n            # Is needed on eg. Ubuntu with Estonian keyboard\n            self.bind(\"<ISO_Left_Tab>\", if_not_readonly(self.perform_tab), True)\n        except Exception:\n            pass\n\n        if platform.system() == \"Windows\":\n            self.bind(\"<KeyPress>\", self._insert_untypable_characters_on_windows, True)", "is_method": true, "class_name": "EnhancedText", "function_description": "Service method of the EnhancedText class that binds keyboard shortcuts to editing functions, enforcing read-only checks and adapting behavior for different platforms and key inputs. It enables customized, context-sensitive text editing interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_keypad", "line_number": 252, "body": "def _bind_keypad(self):\n        \"\"\"Remap keypad movement events to non-keypad equivalents\"\"\"\n        # https://github.com/thonny/thonny/issues/1106\n        kmap = {\n            \"<KP_Left>\": \"<Left>\",\n            \"<KP_Right>\": \"<Right>\",\n            \"<KP_Up>\": \"<Up>\",\n            \"<KP_Down>\": \"<Down>\",\n            \"<KP_Home>\": \"<Home>\",\n            \"<KP_End>\": \"<End>\",\n            \"<KP_Next>\": \"<Next>\",\n            \"<KP_Prior>\": \"<Prior>\",\n            \"<KP_Enter>\": \"<Return>\",\n        }\n        for from_key in kmap:\n\n            def mfunc(event, key=from_key):\n                self.event_generate(kmap[key], **{\"state\": event.state})\n                return \"break\"\n\n            try:\n                self.bind(from_key, mfunc)\n            except TclError:\n                pass", "is_method": true, "class_name": "EnhancedText", "function_description": "Core utility method of the EnhancedText class that remaps keypad-specific movement and action keys to their standard keyboard equivalents, ensuring consistent event handling across different key inputs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_movement_aids", "line_number": 277, "body": "def _bind_movement_aids(self):\n        self.bind(\"<Home>\", self.perform_smart_home, True)\n        self.bind(\"<Left>\", self.move_to_edge_if_selection(0), True)\n        self.bind(\"<Right>\", self.move_to_edge_if_selection(1), True)\n        self.bind(\"<Next>\", self.perform_page_down, True)\n        self.bind(\"<Prior>\", self.perform_page_up, True)", "is_method": true, "class_name": "EnhancedText", "function_description": "Internal method of the EnhancedText class that binds keyboard events to enhanced cursor movement functions, improving navigation behavior within the text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_selection_aids", "line_number": 284, "body": "def _bind_selection_aids(self):\n        self.bind(\"<Command-a>\" if _running_on_mac() else \"<Control-a>\", self.select_all, True)", "is_method": true, "class_name": "EnhancedText", "function_description": "Binds the standard \"select all\" keyboard shortcut (Cmd+A on Mac, Ctrl+A otherwise) to the select_all method for the EnhancedText widget, enhancing user text selection experience."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_undo_aids", "line_number": 287, "body": "def _bind_undo_aids(self):\n        self.bind(\"<<Undo>>\", self._on_undo, True)\n        self.bind(\"<<Redo>>\", self._on_redo, True)\n        self.bind(\"<<Cut>>\", self._on_cut, True)\n        self.bind(\"<<Copy>>\", self._on_copy, True)\n        self.bind(\"<<Paste>>\", self._on_paste, True)\n        self.bind(\"<FocusIn>\", self._on_get_focus, True)\n        self.bind(\"<FocusOut>\", self._on_lose_focus, True)\n        self.bind(\"<Key>\", self._on_key_press, True)\n        self.bind(\"<1>\", self._on_mouse_click, True)\n        self.bind(\"<2>\", self._on_mouse_click, True)\n        self.bind(\"<3>\", self._on_mouse_click, True)\n\n        if _running_on_x11() or _running_on_mac():\n\n            def custom_redo(event):\n                self.event_generate(\"<<Redo>>\")\n                return \"break\"\n\n            self.bind(\"<Control-y>\", custom_redo, True)", "is_method": true, "class_name": "EnhancedText", "function_description": "Private method in EnhancedText that sets up event bindings for common editing actions and input events, ensuring consistent undo, redo, clipboard, focus, keypress, and mouse click handling across platforms."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_redirect_ctrld", "line_number": 308, "body": "def _redirect_ctrld(self, event):\n        # I want to disable the deletion effect of Ctrl-D in the text but still\n        # keep the event for other purposes\n        self.event_generate(\"<<CtrlDInText>>\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Intercepts the Ctrl-D key event to prevent text deletion while still triggering a custom event for other uses within EnhancedText. This enables customized handling of Ctrl-D without its default behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_redirect_ctrlt", "line_number": 314, "body": "def _redirect_ctrlt(self, event):\n        # I want to disable the swap effect of Ctrl-T in the text but still\n        # keep the event for other purposes\n        self.event_generate(\"<<CtrlTInText>>\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Private method in EnhancedText that intercepts the Ctrl-T key event to disable its default swap behavior while still triggering a custom event for other handlers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "tag_reset", "line_number": 320, "body": "def tag_reset(self, tag_name):\n        empty_conf = {key: \"\" for key in self.tag_configure(tag_name)}\n        self.tag_configure(empty_conf)", "is_method": true, "class_name": "EnhancedText", "function_description": "Resets all configuration options of a specified text tag to empty values, effectively clearing its styling or behavior settings within the EnhancedText context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "select_lines", "line_number": 324, "body": "def select_lines(self, first_line, last_line):\n        self.tag_remove(\"sel\", \"1.0\", tk.END)\n        self.tag_add(\"sel\", \"%s.0\" % first_line, \"%s.end\" % last_line)", "is_method": true, "class_name": "EnhancedText", "function_description": "Method of the EnhancedText class that selects and highlights a range of lines between given start and end line numbers within the text widget for further operations or user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "delete_word_left", "line_number": 328, "body": "def delete_word_left(self, event):\n        self.event_generate(\"<Meta-Delete>\")\n        self.edit_separator()\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Method of the EnhancedText class that triggers deletion of the word to the left of the cursor and marks an edit boundary for undo grouping in a text editing context. It facilitates custom word-deletion behavior in the text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "delete_word_right", "line_number": 333, "body": "def delete_word_right(self, event):\n        self.event_generate(\"<Meta-d>\")\n        self.edit_separator()\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Method of the EnhancedText class that deletes the word to the right of the cursor and manages edit history, typically used in text editing interfaces to support word deletion shortcuts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_smart_backspace", "line_number": 338, "body": "def perform_smart_backspace(self, event):\n        self._log_keypress_for_undo(event)\n\n        text = self\n        first, last = self.get_selection_indices()\n        if first and last:\n            text.delete(first, last)\n            text.mark_set(\"insert\", first)\n            return \"break\"\n        # Delete whitespace left, until hitting a real char or closest\n        # preceding virtual tab stop.\n        chars = text.get(\"insert linestart\", \"insert\")\n        if chars == \"\":\n            if text.compare(\"insert\", \">\", \"1.0\"):\n                # easy: delete preceding newline\n                text.delete(\"insert-1c\")\n            else:\n                text.bell()  # at start of buffer\n            return \"break\"\n\n        if (\n            chars.strip() != \"\"\n        ):  # there are non-whitespace chars somewhere to the left of the cursor\n            # easy: delete preceding real char\n            text.delete(\"insert-1c\")\n            self._log_keypress_for_undo(event)\n            return \"break\"\n\n        # Ick.  It may require *inserting* spaces if we back up over a\n        # tab character!  This is written to be clear, not fast.\n        have = len(chars.expandtabs(self.tabwidth))\n        assert have > 0\n        want = ((have - 1) // self.indent_width) * self.indent_width\n        # Debug prompt is multilined....\n        # if self.context_use_ps1:\n        #    last_line_of_prompt = sys.ps1.split('\\n')[-1]\n        # else:\n        last_line_of_prompt = \"\"\n        ncharsdeleted = 0\n        while 1:\n            if chars == last_line_of_prompt:\n                break\n            chars = chars[:-1]\n            ncharsdeleted = ncharsdeleted + 1\n            have = len(chars.expandtabs(self.tabwidth))\n            if have <= want or chars[-1] not in \" \\t\":\n                break\n        text.delete(\"insert-%dc\" % ncharsdeleted, \"insert\")\n        if have < want:\n            text.insert(\"insert\", \" \" * (want - have))\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Core method of the EnhancedText class that smartly handles backspace key events by deleting selected text, preceding whitespace, or characters while maintaining indentation and tab stops for consistent text editing experience."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_midline_tab", "line_number": 390, "body": "def perform_midline_tab(self, event=None):\n        \"autocompleter can put its magic here\"\n        # by default\n        return self.perform_dumb_tab(event)", "is_method": true, "class_name": "EnhancedText", "function_description": "Method of EnhancedText that delegates tab key handling to a default implementation, allowing autocompleter extensions to override for customized tab behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_dumb_tab", "line_number": 395, "body": "def perform_dumb_tab(self, event=None):\n        self._log_keypress_for_undo(event)\n        self.insert(\"insert\", \"\\t\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "In the EnhancedText class, this method inserts a tab character at the current cursor position while logging the action for undo functionality. It supports custom tab insertion handling during user input events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_smart_tab", "line_number": 400, "body": "def perform_smart_tab(self, event=None):\n        self._log_keypress_for_undo(event)\n\n        # if intraline selection:\n        #     delete it\n        # elif multiline selection:\n        #     do indent-region\n        # else:\n        #     indent one level\n\n        first, last = self.get_selection_indices()\n        if first and last:\n            if index2line(first) != index2line(last):\n                return self.indent_region(event)\n            self.delete(first, last)\n            self.mark_set(\"insert\", first)\n        prefix = self.get(\"insert linestart\", \"insert\")\n        raw, effective = classifyws(prefix, self.tabwidth)\n        if raw == len(prefix):\n            # only whitespace to the left\n            self._reindent_to(effective + self.indent_width)\n        else:\n            # tab to the next 'stop' within or to right of line's text:\n            if self.should_indent_with_tabs():\n                pad = \"\\t\"\n            else:\n                effective = len(prefix.expandtabs(self.tabwidth))\n                n = self.indent_width\n                pad = \" \" * (n - effective % n)\n            self.insert(\"insert\", pad)\n        self.see(\"insert\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Provides smart tabbing behavior within EnhancedText by handling indentation or replacement based on selection and cursor position, supporting consistent code formatting and flexible tab/space insertion during text editing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "get_cursor_position", "line_number": 433, "body": "def get_cursor_position(self):\n        return map(int, self.index(\"insert\").split(\".\"))", "is_method": true, "class_name": "EnhancedText", "function_description": "Returns the current cursor position as a tuple of integers representing line and column indices within the text. Useful for text editing features needing precise cursor tracking."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "get_line_count", "line_number": 436, "body": "def get_line_count(self):\n        return list(map(int, self.index(\"end-1c\").split(\".\")))[0]", "is_method": true, "class_name": "EnhancedText", "function_description": "Returns the total number of lines in the EnhancedText content, enabling other functions to understand or manipulate text based on its length."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_return", "line_number": 439, "body": "def perform_return(self, event):\n        self.insert(\"insert\", \"\\n\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Returns a control signal to interrupt further event processing after inserting a newline in the text. This enables customized handling of specific input events within the EnhancedText context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_page_down", "line_number": 443, "body": "def perform_page_down(self, event):\n        # if last line is visible then go to last line\n        # (by default it doesn't move then)\n        try:\n            last_visible_idx = self.index(\"@0,%d\" % self.winfo_height())\n            row, _ = map(int, last_visible_idx.split(\".\"))\n            line_count = self.get_line_count()\n\n            if row == line_count or row == line_count - 1:  # otherwise tk doesn't show last line\n                self.mark_set(\"insert\", \"end\")\n        except Exception as e:\n            logger.exception(\"Could not perform page down\", exc_info=e)", "is_method": true, "class_name": "EnhancedText", "function_description": "Provides an enhanced page-down action ensuring the view moves to the last line if it is already visible, improving text navigation within the EnhancedText widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_page_up", "line_number": 456, "body": "def perform_page_up(self, event):\n        # if first line is visible then go there\n        # (by default it doesn't move then)\n        try:\n            first_visible_idx = self.index(\"@0,0\")\n            row, _ = map(int, first_visible_idx.split(\".\"))\n            if row == 1:\n                self.mark_set(\"insert\", \"1.0\")\n        except Exception as e:\n            logger.exception(\"Could not perform page up\", exc_info=e)", "is_method": true, "class_name": "EnhancedText", "function_description": "Method of EnhancedText that ensures the cursor moves to the start of the text when a page-up event occurs and the first visible line is already at the top, improving navigation behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "compute_smart_home_destination_index", "line_number": 467, "body": "def compute_smart_home_destination_index(self):\n        \"\"\"Is overridden in shell\"\"\"\n\n        line = self.get(\"insert linestart\", \"insert lineend\")\n        for insertpt in range(len(line)):\n            if line[insertpt] not in (\" \", \"\\t\"):\n                break\n        else:\n            insertpt = len(line)\n\n        lineat = int(self.index(\"insert\").split(\".\")[1])\n        if insertpt == lineat:\n            insertpt = 0\n        return \"insert linestart+\" + str(insertpt) + \"c\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Calculates an optimal cursor position within the current line by finding the first non-whitespace character, aiding text insertion or navigation in the EnhancedText context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_smart_home", "line_number": 482, "body": "def perform_smart_home(self, event):\n        if (event.state & 4) != 0 and event.keysym == \"Home\":\n            # state&4==Control. If <Control-Home>, use the Tk binding.\n            return None\n\n        dest = self.compute_smart_home_destination_index()\n\n        if (event.state & 1) == 0:\n            # shift was not pressed\n            self.tag_remove(\"sel\", \"1.0\", \"end\")\n        else:\n            if not self.index_sel_first():\n                # there was no previous selection\n                self.mark_set(\"my_anchor\", \"insert\")\n            else:\n                if self.compare(self.index_sel_first(), \"<\", self.index(\"insert\")):\n                    self.mark_set(\"my_anchor\", \"sel.first\")  # extend back\n                else:\n                    self.mark_set(\"my_anchor\", \"sel.last\")  # extend forward\n            first = self.index(dest)\n            last = self.index(\"my_anchor\")\n            if self.compare(first, \">\", last):\n                first, last = last, first\n            self.tag_remove(\"sel\", \"1.0\", \"end\")\n            self.tag_add(\"sel\", first, last)\n        self.mark_set(\"insert\", dest)\n        self.see(\"insert\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Method of EnhancedText that handles smart cursor movement and text selection when the Home key is pressed, supporting Shift for selection extension and Control for default behavior, enhancing text navigation and editing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "move_to_edge_if_selection", "line_number": 511, "body": "def move_to_edge_if_selection(self, edge_index):\n        \"\"\"Cursor move begins at start or end of selection\n\n        When a left/right cursor key is pressed create and return to Tkinter a\n        function which causes a cursor move from the associated edge of the\n        selection.\n        \"\"\"\n\n        def move_at_edge(event):\n            if (\n                self.has_selection() and (event.state & 5) == 0\n            ):  # no shift(==1) or control(==4) pressed\n                try:\n                    self.mark_set(\"insert\", (\"sel.first+1c\", \"sel.last-1c\")[edge_index])\n                except tk.TclError:\n                    pass\n\n        return move_at_edge", "is_method": true, "class_name": "EnhancedText", "function_description": "Provides a callable that moves the cursor to the start or end edge of the current text selection when no shift or control keys are pressed, aiding precise cursor navigation within selected text in an EnhancedText widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_tab", "line_number": 530, "body": "def perform_tab(self, event=None):\n        self._log_keypress_for_undo(event)\n        if event.state & 0x0001:  # shift is pressed (http://stackoverflow.com/q/32426250/261181)\n            return self.dedent_region(event)\n        else:\n            # check whether there are letters before cursor on this line\n            index = self.index(\"insert\")\n            left_text = self.get(index + \" linestart\", index)\n            if left_text.strip() == \"\" or self.has_selection():\n                return self.perform_smart_tab(event)\n            else:\n                return self.perform_midline_tab(event)", "is_method": true, "class_name": "EnhancedText", "function_description": "Method of the EnhancedText class that handles tab key actions, providing shift-tab dedentation, smart indentation when at line start or with selection, and midline tabbing otherwise for improved text editing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "indent_region", "line_number": 543, "body": "def indent_region(self, event=None):\n        return self._change_indentation(True)", "is_method": true, "class_name": "EnhancedText", "function_description": "Method of the EnhancedText class that increases indentation for a selected text region, facilitating code formatting or text structuring."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "dedent_region", "line_number": 546, "body": "def dedent_region(self, event=None):\n        return self._change_indentation(False)", "is_method": true, "class_name": "EnhancedText", "function_description": "Method of the EnhancedText class that removes indentation from a selected text region, supporting text formatting and editing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_change_indentation", "line_number": 549, "body": "def _change_indentation(self, increase=True):\n        head, tail, chars, lines = self._get_region()\n\n        # Text widget plays tricks if selection ends on last line\n        # and content doesn't end with empty line,\n        text_last_line = index2line(self.index(\"end-1c\"))\n        sel_last_line = index2line(tail)\n        if sel_last_line >= text_last_line:\n            while not self.get(head, \"end\").endswith(\"\\n\\n\"):\n                self.insert(\"end\", \"\\n\")\n\n        for pos in range(len(lines)):\n            line = lines[pos]\n            if line:\n                raw, effective = classifyws(line, self.tabwidth)\n                if increase:\n                    effective = effective + self.indent_width\n                else:\n                    effective = max(effective - self.indent_width, 0)\n                lines[pos] = self._make_blanks(effective) + line[raw:]\n        self._set_region(head, tail, chars, lines)\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Utility method of the EnhancedText class that adjusts the indentation of the selected text region, increasing or decreasing it by a predefined width to facilitate text formatting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "select_all", "line_number": 572, "body": "def select_all(self, event):\n        self.tag_remove(\"sel\", \"1.0\", tk.END)\n        self.tag_add(\"sel\", \"1.0\", tk.END)", "is_method": true, "class_name": "EnhancedText", "function_description": "Method of the EnhancedText class that selects all text content within the text widget, enabling operations like copy or formatting to be applied to the entire text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_read_only", "line_number": 576, "body": "def set_read_only(self, value):\n        if value == self.is_read_only():\n            return\n\n        TweakableText.set_read_only(self, value)\n        self._reload_theme_options()\n        if self._should_tag_current_line:\n            self._tag_current_line()", "is_method": true, "class_name": "EnhancedText", "function_description": "Sets the text object's read-only state and updates related visual options and line tagging accordingly. Useful for toggling edit permissions while maintaining consistent appearance and behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_reindent_to", "line_number": 585, "body": "def _reindent_to(self, column):\n        # Delete from beginning of line to insert point, then reinsert\n        # column logical (meaning use tabs if appropriate) spaces.\n        if self.compare(\"insert linestart\", \"!=\", \"insert\"):\n            self.delete(\"insert linestart\", \"insert\")\n        if column:\n            self.insert(\"insert\", self._make_blanks(column))", "is_method": true, "class_name": "EnhancedText", "function_description": "Internal helper method of the EnhancedText class that adjusts the indentation of the current line to a specified column, using appropriate spacing or tabs. It supports consistent code or text formatting by realigning line starts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_get_region", "line_number": 593, "body": "def _get_region(self):\n        first, last = self.get_selection_indices()\n        if first and last:\n            head = self.index(first + \" linestart\")\n            tail = self.index(last + \"-1c lineend +1c\")\n        else:\n            head = self.index(\"insert linestart\")\n            tail = self.index(\"insert lineend +1c\")\n        chars = self.get(head, tail)\n        lines = chars.split(\"\\n\")\n        return head, tail, chars, lines", "is_method": true, "class_name": "EnhancedText", "function_description": "Internal method of the EnhancedText class that identifies and extracts the text region spanning the current selection or insertion point, returning the boundary indices, character content, and line list for further processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_set_region", "line_number": 605, "body": "def _set_region(self, head, tail, chars, lines):\n        newchars = \"\\n\".join(lines)\n        if newchars == chars:\n            self.bell()\n            return\n        self.tag_remove(\"sel\", \"1.0\", \"end\")\n        self.mark_set(\"insert\", head)\n        self.delete(head, tail)\n        self.insert(head, newchars)\n        self.tag_add(\"sel\", head, \"insert\")", "is_method": true, "class_name": "EnhancedText", "function_description": "Private method of the EnhancedText class that replaces a specified text region with new content while preserving cursor and selection state, signaling no change by triggering an alert."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_log_keypress_for_undo", "line_number": 616, "body": "def _log_keypress_for_undo(self, e):\n        if e is None:\n            return\n\n        # NB! this may not execute if the event is cancelled in another handler\n        event_kind = self._get_event_kind(e)\n\n        if (\n            event_kind != self._last_event_kind\n            or e.char in (\"\\r\", \"\\n\", \" \", \"\\t\")\n            or e.keysym in [\"Return\", \"KP_Enter\"]\n            or time.time() - self._last_key_time > 2\n        ):\n            self.edit_separator()\n\n        self._last_event_kind = event_kind\n        self._last_key_time = time.time()", "is_method": true, "class_name": "EnhancedText", "function_description": "Internal method of the EnhancedText class that logs keypress events to determine when to create undo breakpoints, helping manage undo history granularity based on typing activity and event timing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_get_event_kind", "line_number": 634, "body": "def _get_event_kind(self, event):\n        if event.keysym in (\"BackSpace\", \"Delete\"):\n            return \"delete\"\n        elif event.char:\n            return \"insert\"\n        else:\n            # eg. e.keysym in (\"Left\", \"Up\", \"Right\", \"Down\", \"Home\", \"End\", \"Prior\", \"Next\"):\n            return \"other_key\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Internal method of EnhancedText that categorizes keyboard events as text insertion, deletion, or other navigation keys for processing user input."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_make_blanks", "line_number": 643, "body": "def _make_blanks(self, n):\n        # Make string that displays as n leading blanks.\n        if self.should_indent_with_tabs():\n            ntabs, nspaces = divmod(n, self.tabwidth)\n            return \"\\t\" * ntabs + \" \" * nspaces\n        else:\n            return \" \" * n", "is_method": true, "class_name": "EnhancedText", "function_description": "Utility method in EnhancedText that generates a string of leading whitespace composed of tabs or spaces based on indentation settings, useful for consistent text formatting and alignment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_undo", "line_number": 651, "body": "def _on_undo(self, e):\n        self._last_event_kind = \"undo\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Internal method of the EnhancedText class that records the last action as an undo event for tracking user actions or state changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_redo", "line_number": 654, "body": "def _on_redo(self, e):\n        self._last_event_kind = \"redo\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Internal event handler in EnhancedText that marks the last action as a redo operation, useful for tracking or managing undo/redo states."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_cut", "line_number": 657, "body": "def _on_cut(self, e):\n        self._last_event_kind = \"cut\"\n        self.edit_separator()", "is_method": true, "class_name": "EnhancedText", "function_description": "Internal handler of EnhancedText that marks the last event as a cut action and inserts an edit separator, helping to track text changes for undo/redo functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_copy", "line_number": 661, "body": "def _on_copy(self, e):\n        self._last_event_kind = \"copy\"\n        self.edit_separator()", "is_method": true, "class_name": "EnhancedText", "function_description": "Private method in EnhancedText that tracks when a copy event occurs and marks an edit boundary for undo/redo management. It helps manage event states during text editing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_paste", "line_number": 665, "body": "def _on_paste(self, e):\n        if self.is_read_only():\n            return\n\n        try:\n            if self.has_selection():\n                self.direct_delete(\"sel.first\", \"sel.last\")\n        except Exception:\n            pass\n\n        self._last_event_kind = \"paste\"\n        self.edit_separator()\n        self.see(\"insert\")\n        self.after_idle(lambda: self.see(\"insert\"))", "is_method": true, "class_name": "EnhancedText", "function_description": "Handles paste events in the EnhancedText widget by deleting the current selection if editable and updating the view to reflect the pasted content position."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_get_focus", "line_number": 680, "body": "def _on_get_focus(self, e):\n        self._last_event_kind = \"get_focus\"\n        self.edit_separator()", "is_method": true, "class_name": "EnhancedText", "function_description": "Private method in EnhancedText that handles focus retrieval events by marking the event type and initiating an edit separator to manage undo/redo boundaries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_lose_focus", "line_number": 684, "body": "def _on_lose_focus(self, e):\n        self._last_event_kind = \"lose_focus\"\n        self.edit_separator()", "is_method": true, "class_name": "EnhancedText", "function_description": "Private method in EnhancedText that handles losing input focus by recording the event and inserting an edit separator, likely to track or manage changes when editing ends."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_key_press", "line_number": 688, "body": "def _on_key_press(self, e):\n        return self._log_keypress_for_undo(e)", "is_method": true, "class_name": "EnhancedText", "function_description": "Private method in EnhancedText that logs keypress events to support undo functionality during text editing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_mouse_click", "line_number": 691, "body": "def _on_mouse_click(self, event):\n        self.edit_separator()", "is_method": true, "class_name": "EnhancedText", "function_description": "Private event handler in EnhancedText that triggers text editing operations upon mouse clicks, supporting interactive text modification within the component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_tag_current_line", "line_number": 694, "body": "def _tag_current_line(self, event=None):\n        self.tag_remove(\"current_line\", \"1.0\", \"end\")\n\n        # Let's show current line only with readable text\n        # (this fits well with Thonny debugger,\n        # otherwise debugger focus box and current line interact in an ugly way)\n        if self._should_tag_current_line and not self.is_read_only():\n            # we may be on the same line as with prev event but tag needs extension\n            lineno = int(self.index(\"insert\").split(\".\")[0])\n            self.tag_add(\"current_line\", str(lineno) + \".0\", str(lineno + 1) + \".0\")", "is_method": true, "class_name": "EnhancedText", "function_description": "Core method of EnhancedText that highlights the line where the cursor currently is, improving user interface responsiveness during text editing and debugging sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "on_secondary_click", "line_number": 705, "body": "def on_secondary_click(self, event=None):\n        \"Use this for invoking context menu\"\n        self.focus_set()\n        if event:\n            self.mark_set(\"insert\", \"@%d,%d\" % (event.x, event.y))", "is_method": true, "class_name": "EnhancedText", "function_description": "Provides functionality to handle secondary (right) mouse clicks by focusing the text widget and positioning the cursor at the click location, facilitating context menu invocation in the EnhancedText widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_reload_theme_options", "line_number": 711, "body": "def _reload_theme_options(self, event=None):\n\n        style = ttk.Style()\n\n        states = []\n        if self.is_read_only():\n            states.append(\"readonly\")\n\n        # Following crashes when a combobox is focused\n        # if self.focus_get() == self:\n        #    states.append(\"focus\")\n\n        if \"background\" not in self._initial_configuration:\n            background = style.lookup(self._style, \"background\", states)\n            if background:\n                self.configure(background=background)\n\n        if \"foreground\" not in self._initial_configuration:\n            foreground = style.lookup(self._style, \"foreground\", states)\n            if foreground:\n                self.configure(foreground=foreground)\n                self.configure(insertbackground=foreground)", "is_method": true, "class_name": "EnhancedText", "function_description": "Private method of EnhancedText that updates widget color options (background, foreground, insert cursor) based on the current theme and read-only state. It ensures the widget's appearance matches style settings dynamically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_insert_untypable_characters_on_windows", "line_number": 734, "body": "def _insert_untypable_characters_on_windows(self, event):\n        if event.state == 131084:  # AltGr or Ctrl+Alt\n            lang_id = get_keyboard_language()\n            char = _windows_altgr_chars_by_lang_id_and_keycode.get(lang_id, {}).get(\n                event.keycode, None\n            )\n            if char is not None:\n                self.insert(\"insert\", char)", "is_method": true, "class_name": "EnhancedText", "function_description": "Handles insertion of special characters typed using AltGr or Ctrl+Alt keys on Windows, supporting language-specific input in the EnhancedText component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "destroy", "line_number": 743, "body": "def destroy(self):\n        self.unbind(\"<<ThemeChanged>>\", self._ui_theme_change_binding)\n        super().destroy()", "is_method": true, "class_name": "EnhancedText", "function_description": "Method of the EnhancedText class that cleans up event bindings related to theme changes before destroying the widget, ensuring proper resource release and preventing residual callbacks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "direct_insert", "line_number": 747, "body": "def direct_insert(self, index, chars, tags=None, **kw):\n        super().direct_insert(index, chars, tags, **kw)", "is_method": true, "class_name": "EnhancedText", "function_description": "Directly inserts characters and optional tags at a specified position in the text, extending base insertion functionality within the EnhancedText class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "focus_set", "line_number": 811, "body": "def focus_set(self):\n        self.text.focus_set()", "is_method": true, "class_name": "TextFrame", "function_description": "Sets input focus to the TextFrame's text widget, allowing immediate user interaction or text entry. This method is useful for UI components managing text input focus behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_vertical_scrollbar_update", "line_number": 814, "body": "def _vertical_scrollbar_update(self, *args):\n        if not hasattr(self, \"_vbar\"):\n            return\n\n        self._vbar.set(*args)\n        self.text.event_generate(\"<<VerticalScroll>>\")", "is_method": true, "class_name": "TextFrame", "function_description": "Private method in TextFrame that updates the vertical scrollbar position and triggers a vertical scroll event, ensuring the scrollbar state reflects the current text view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_horizontal_scrollbar_update", "line_number": 821, "body": "def _horizontal_scrollbar_update(self, *args):\n        self._hbar.set(*args)", "is_method": true, "class_name": "TextFrame", "function_description": "Internal helper method in TextFrame that updates the horizontal scrollbar's position or properties based on given parameters; primarily supports UI scrolling behavior management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_vertical_scroll", "line_number": 824, "body": "def _vertical_scroll(self, *args):\n        self.text.yview(*args)\n        self.text.event_generate(\"<<VerticalScroll>>\")", "is_method": true, "class_name": "TextFrame", "function_description": "Private method in TextFrame that updates vertical scroll position and triggers a scroll event notification. It enables synchronized scrolling behavior within the text display component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_horizontal_scroll", "line_number": 828, "body": "def _horizontal_scroll(self, *args):\n        self.text.xview(*args)", "is_method": true, "class_name": "TextFrame", "function_description": "Internal method of the TextFrame class that scrolls the text horizontally based on given parameters, enabling horizontal navigation within the text content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "destroy", "line_number": 834, "body": "def destroy(self):\n        self.unbind(\"<<ThemeChanged>>\", self._ui_theme_change_binding)\n        super().destroy()", "is_method": true, "class_name": "TextFrame", "function_description": "Method of the TextFrame class that cleans up event bindings before destroying the instance, ensuring proper resource release and preventing side effects from theme change events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_gutter_visibility", "line_number": 932, "body": "def set_gutter_visibility(self, value):\n        if value and not self._gutter_is_gridded:\n            self._gutter.grid(row=0, column=0, sticky=tk.NSEW)\n            self._gutter_is_gridded = True\n        elif not value and self._gutter_is_gridded:\n            self._gutter.grid_forget()\n            self._gutter_is_gridded = False\n        else:\n            return\n\n        \"\"\"\n        # insert first line number (NB! Without trailing linebreak. See update_gutter)\n        self._gutter.config(state=\"normal\")\n        self._gutter.delete(\"1.0\", \"end\")\n        for content, tags in self.compute_gutter_line(self._first_line_number):\n            self._gutter.insert(\"end\", content, (\"content\",) + tags)\n        self._gutter.config(state=\"disabled\")\n        \"\"\"\n        self.update_gutter(True)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Toggles the visibility of the gutter area in the EnhancedTextFrame, managing its display state and updating its content accordingly. This enables dynamic show/hide behavior for line numbers or markers in the text frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_line_length_margin", "line_number": 952, "body": "def set_line_length_margin(self, value):\n        self._recommended_line_length = value\n        self.update_margin_line()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Sets the recommended line length margin for the text frame and updates the visual margin accordingly. This function helps maintain consistent text formatting within the EnhancedTextFrame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_gutter_scroll", "line_number": 956, "body": "def _gutter_scroll(self, *args):\n        if not hasattr(self, \"_vbar\"):\n            return\n\n        try:\n            self._vbar.set(*args)\n            self.text.yview(tk.MOVETO, args[0])\n        except TclError:\n            pass", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Internal method of EnhancedTextFrame that synchronizes vertical scrolling between a gutter element and the main text area to ensure their scroll positions stay aligned."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_text_changed", "line_number": 966, "body": "def _text_changed(self, event):\n        self.update_gutter()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Private method in EnhancedTextFrame that triggers gutter update when the text content changes, supporting visual synchronization with text modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_cursor_moved", "line_number": 969, "body": "def _cursor_moved(self, event):\n        self._update_gutter_active_line()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Private method in EnhancedTextFrame that updates the line highlight in the gutter when the text cursor moves, supporting visual feedback for the active line."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "update_gutter", "line_number": 972, "body": "def update_gutter(self, clean=False):\n        if clean:\n            self._gutter.config(state=\"normal\")\n            self._gutter.delete(\"1.0\", \"end\")\n            # need to add first item separately, because Text can't report 0 rows\n            for content, tags in self.compute_gutter_line(self._first_line_number):\n                self._gutter.insert(\"end-1c\", content, tags + (\"content\",))\n\n            self._gutter.config(state=\"disabled\")\n\n        text_line_count = int(self.text.index(\"end\").split(\".\")[0])\n        gutter_line_count = int(self._gutter.index(\"end\").split(\".\")[0])\n\n        if text_line_count != gutter_line_count:\n            self._gutter.config(state=\"normal\")\n\n            # NB! Text acts weird with last symbol\n            # (don't really understand whether it automatically keeps a newline there or not)\n            # Following seems to ensure both Text-s have same height\n            if text_line_count > gutter_line_count:\n                delta = text_line_count - gutter_line_count\n                start = gutter_line_count + self._first_line_number - 1\n\n                if not clean and text_line_count > 10 and gutter_line_count < 3:\n                    # probably initial load, do bulk insert\n                    parts = []\n                    for i in range(start, start + delta):\n                        parts.append(\"\\n\")\n                        for content, tags in self.compute_gutter_line(i, plain=True):\n                            parts.append(content)\n\n                    self._gutter.insert(\"end-1c\", \"\".join(parts), (\"content\",) + tags)\n                else:\n                    for i in range(start, start + delta):\n                        self._gutter.insert(\"end-1c\", \"\\n\", (\"content\",))\n                        for content, tags in self.compute_gutter_line(i):\n                            self._gutter.insert(\"end-1c\", content, (\"content\",) + tags)\n            else:\n                self._gutter.delete(line2index(text_line_count) + \"-1c\", \"end-1c\")\n\n            self._gutter.config(state=\"disabled\")\n\n        # synchronize gutter scroll position with text\n        # https://mail.python.org/pipermail/tkinter-discuss/2010-March/002197.html\n        first, _ = self.text.yview()\n        self._gutter.yview_moveto(first)\n        self._update_gutter_active_line()\n\n        if text_line_count > 9998:\n            self._gutter.configure(width=7)\n        elif text_line_count > 998:\n            self._gutter.configure(width=6)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Updates the line number gutter of the EnhancedTextFrame to match the main text's line count, optionally clearing it first. It keeps line numbers synchronized visually and adjusts gutter width based on total lines for consistent user interface alignment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_update_gutter_active_line", "line_number": 1025, "body": "def _update_gutter_active_line(self):\n        self._gutter.tag_remove(\"active\", \"1.0\", \"end\")\n        insert = self.text.index(\"insert\")\n        self._gutter.tag_add(\"active\", insert + \" linestart\", insert + \" lineend\")", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Private method of EnhancedTextFrame that highlights the gutter line corresponding to the current cursor position, assisting in visual tracking of the active text line."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "compute_gutter_line", "line_number": 1030, "body": "def compute_gutter_line(self, lineno, plain=False):\n        yield str(lineno), ()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Returns a line number label for a text line, optionally formatted plainly, serving as a simple generator for gutter line display in text rendering contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "update_margin_line", "line_number": 1033, "body": "def update_margin_line(self):\n        if self._recommended_line_length == 0:\n            self._margin_line.place_forget()\n        else:\n            try:\n                self.text.update_idletasks()\n                # How far left has text been scrolled\n                first_visible_idx = self.text.index(\"@0,0\")\n                first_visible_col = int(first_visible_idx.split(\".\")[1])\n                bbox = self.text.bbox(first_visible_idx)\n                first_visible_col_x = bbox[0]\n\n                margin_line_visible_col = self._recommended_line_length - first_visible_col\n                delta = first_visible_col_x\n            except Exception:\n                # fall back to ignoring scroll position\n                margin_line_visible_col = self._recommended_line_length\n                delta = 0\n\n            if margin_line_visible_col > -1:\n                x = (\n                    get_text_font(self.text).measure((margin_line_visible_col - 1) * \"M\")\n                    + delta\n                    + self.text[\"padx\"]\n                )\n            else:\n                x = -10\n\n            # print(first_visible_col, first_visible_col_x)\n\n            self._margin_line.place(y=-10, x=x)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Updates the position and visibility of a margin line in a text frame based on the recommended line length and current scroll offset, helping to visually indicate text width limits for better formatting guidance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "on_gutter_click", "line_number": 1065, "body": "def on_gutter_click(self, event=None):\n        try:\n            linepos = self._gutter.index(\"@%s,%s\" % (event.x, event.y)).split(\".\")[0]\n            self.text.mark_set(\"insert\", \"%s.0\" % linepos)\n            self._gutter.mark_set(\"gutter_selection_start\", \"%s.0\" % linepos)\n            if (\n                event.type == \"4\"\n            ):  # In Python 3.6 you can use tk.EventType.ButtonPress instead of \"4\"\n                self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n        except tk.TclError:\n            exception(\"on_gutter_click\")", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Handles mouse click events on the gutter area of EnhancedTextFrame, updating the text cursor position and managing selection states based on the click. Useful for interacting with line numbers or markers beside the text content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "on_gutter_double_click", "line_number": 1077, "body": "def on_gutter_double_click(self, event=None):\n        try:\n            self._gutter.mark_unset(\"gutter_selection_start\")\n            self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n            self._gutter.tag_remove(\"sel\", \"1.0\", \"end\")\n        except tk.TclError:\n            exception(\"on_gutter_click\")", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Handles double-click events on the gutter by clearing any existing selection highlights in the text and gutter areas. This supports user interface interactions related to text selection in EnhancedTextFrame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "on_gutter_motion", "line_number": 1085, "body": "def on_gutter_motion(self, event=None):\n        try:\n            if \"gutter_selection_start\" not in self._gutter.mark_names():\n                return\n            linepos = int(self._gutter.index(\"@%s,%s\" % (event.x, event.y)).split(\".\")[0])\n            gutter_selection_start = int(self._gutter.index(\"gutter_selection_start\").split(\".\")[0])\n            self.text.select_lines(\n                min(gutter_selection_start, linepos), max(gutter_selection_start - 1, linepos - 1)\n            )\n            self.text.mark_set(\"insert\", \"%s.0\" % linepos)\n            self.text.focus_set()\n        except tk.TclError:\n            exception(\"on_gutter_motion\")", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Handles the event of mouse motion within the gutter to update and extend the text selection lines accordingly, supporting interactive line selection in the EnhancedTextFrame widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_vertical_scrollbar_update", "line_number": 1099, "body": "def _vertical_scrollbar_update(self, *args):\n        if not hasattr(self, \"_vbar\"):\n            return\n\n        super()._vertical_scrollbar_update(*args)\n        self._gutter.yview(tk.MOVETO, args[0])", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Internal method of EnhancedTextFrame that updates the vertical scrollbar position and synchronizes a related gutter view accordingly during scrolling events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_horizontal_scrollbar_update", "line_number": 1106, "body": "def _horizontal_scrollbar_update(self, *args):\n        super()._horizontal_scrollbar_update(*args)\n        self.update_margin_line()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Updates the horizontal scrollbar state and refreshes the margin line display accordingly within the EnhancedTextFrame, ensuring synchronized visual components during scroll events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_vertical_scroll", "line_number": 1110, "body": "def _vertical_scroll(self, *args):\n        super()._vertical_scroll(*args)\n        self._gutter.yview(*args)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Private method in EnhancedTextFrame that ensures vertical scrolling synchronizes both the main text area and its associated gutter, maintaining aligned views during scroll events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_horizontal_scroll", "line_number": 1114, "body": "def _horizontal_scroll(self, *args):\n        super()._horizontal_scroll(*args)\n        self.update_margin_line()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Internal method of EnhancedTextFrame that extends horizontal scrolling behavior by updating the margin line display after the scroll event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_reload_theme_options", "line_number": 1118, "body": "def _reload_theme_options(self, event=None):\n        super()._reload_theme_options(event)\n        if self._gutter is not None:\n            self._reload_gutter_theme_options(event)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Private method of EnhancedTextFrame that refreshes theme settings and updates gutter-related themes if present, ensuring consistent visual styling after theme changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_reload_gutter_theme_options", "line_number": 1123, "body": "def _reload_gutter_theme_options(self, event=None):\n\n        style = ttk.Style()\n        background = style.lookup(\"GUTTER\", \"background\")\n        if background:\n            self._gutter.configure(background=background, selectbackground=background)\n            self._margin_line.configure(background=background)\n\n        foreground = style.lookup(\"GUTTER\", \"foreground\")\n        if foreground:\n            self._gutter.configure(foreground=foreground, selectforeground=foreground)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Updates the gutter area's visual styles based on the current theme settings, ensuring its background and foreground colors remain consistent with the application's look and feel."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "control_a", "line_number": 1180, "body": "def control_a(event):\n        widget = event.widget\n        if isinstance(widget, tk.Text):\n            widget.tag_remove(\"sel\", \"1.0\", \"end\")\n            widget.tag_add(\"sel\", \"1.0\", \"end\")", "is_method": false, "function_description": "This function selects all text within a Tkinter Text widget in response to an event, enabling a \"select all\" keyboard shortcut behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "if_not_readonly", "line_number": 226, "body": "def if_not_readonly(fun):\n            def dispatch(event):\n                if not self.is_read_only():\n                    return fun(event)\n                else:\n                    return \"break\"\n\n            return dispatch", "is_method": true, "class_name": "EnhancedText", "function_description": "Decorator method in EnhancedText that conditionally executes a function based on the object's read-only status, preventing operations when the instance is read-only."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "move_at_edge", "line_number": 519, "body": "def move_at_edge(event):\n            if (\n                self.has_selection() and (event.state & 5) == 0\n            ):  # no shift(==1) or control(==4) pressed\n                try:\n                    self.mark_set(\"insert\", (\"sel.first+1c\", \"sel.last-1c\")[edge_index])\n                except tk.TclError:\n                    pass", "is_method": true, "class_name": "EnhancedText", "function_description": "Core method of the EnhancedText class that adjusts the text cursor position near selection edges when no shift or control keys are pressed, supporting precise cursor movement during text selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "mfunc", "line_number": 268, "body": "def mfunc(event, key=from_key):\n                self.event_generate(kmap[key], **{\"state\": event.state})\n                return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Function in EnhancedText that triggers a mapped event based on a key from an input event, preventing further event propagation. It facilitates custom event handling tied to specific key mappings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "custom_redo", "line_number": 302, "body": "def custom_redo(event):\n                self.event_generate(\"<<Redo>>\")\n                return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Handles a redo keyboard event by triggering the \"Redo\" command and stopping further event propagation, enabling custom redo functionality within the EnhancedText component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/languages.py", "function": "get_button_padding", "line_number": 52, "body": "def get_button_padding():\n    code = get_workbench().get_option(\"general.language\")\n    if code in BUTTON_PADDING_SIZES:\n        return BUTTON_PADDING_SIZES[code] * \" \"\n    else:\n        return \"\"", "is_method": false, "function_description": "Function that returns a language-specific button padding string based on the current workbench language setting, enabling UI elements to adjust spacing dynamically for different languages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/languages.py", "function": "get_language_code_by_name", "line_number": 60, "body": "def get_language_code_by_name(name):\n    for code in LANGUAGES_DICT:\n        if LANGUAGES_DICT[code] == name:\n            return code\n\n    raise RuntimeError(\"Unknown language name '%s'\" % name)", "is_method": false, "function_description": "Function that returns the language code corresponding to a given language name from a predefined dictionary, raising an error if the name is not found. It facilitates language code lookup by human-readable names."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/languages.py", "function": "tr", "line_number": 68, "body": "def tr(message: str) -> str:\n    return _translation.gettext(message)", "is_method": false, "function_description": "Utility function that translates a given message string using a predefined translation service, supporting internationalization and localization in applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/languages.py", "function": "set_language", "line_number": 72, "body": "def set_language(language_code: str) -> None:\n    global _translation\n    try:\n        path = os.path.join(os.path.dirname(__file__), \"locale\")\n        _translation = gettext.translation(\"thonny\", path, [language_code])\n    except Exception as e:\n        logger.exception(\"Could not set language to '%s\", language_code, exc_info=e)\n        _translation = gettext.NullTranslations()", "is_method": false, "function_description": "Sets the application's language for localization by loading the corresponding translation files, enabling multilingual support. If loading fails, it defaults to no translation while logging the error."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "set_data", "line_number": 33, "body": "def set_data(self, data_rows):\n        # self.data_rows.update(data_rows) # dict version\n        self.data_rows = data_rows\n        self.data_row_count = len(data_rows)\n        self.update_screen_data()", "is_method": true, "class_name": "GridTable", "function_description": "Service method of the GridTable class that updates the table's data rows and row count, then refreshes the displayed content accordingly. It enables dynamic replacement of table data for display or processing purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "update_header_rows", "line_number": 39, "body": "def update_header_rows(self):\n        for row_no in range(self.header_row_count):\n            for col_no in range(self.column_count):\n                w = self.get_header_widget(self.screen_row_count, col_no)\n                w.grid(row=row_no, column=col_no, sticky=\"nsew\", pady=(0, 1), padx=(0, 1))\n                w.configure(text=self.get_header_value(row_no, col_no))\n\n        self.screen_row_count = self.header_row_count", "is_method": true, "class_name": "GridTable", "function_description": "This method updates the table's header rows by configuring and placing header widgets with current header values, ensuring the grid reflects the correct header layout and count for display purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "get_data_widget", "line_number": 48, "body": "def get_data_widget(self, screen_row_no, col_no):\n        if (screen_row_no, col_no) not in self.data_widgets:\n            self.data_widgets[(screen_row_no, col_no)] = self.create_data_widget(col_no)\n\n        return self.data_widgets[(screen_row_no, col_no)]", "is_method": true, "class_name": "GridTable", "function_description": "Retrieves the data widget at a specific grid position, creating and caching it if not already present. This facilitates efficient access and management of cell-specific widgets within the GridTable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "get_header_widget", "line_number": 54, "body": "def get_header_widget(self, row_no, col_no):\n        if (row_no, col_no) not in self.header_widgets:\n            self.header_widgets[(row_no, col_no)] = self.create_header_widget(col_no)\n\n        return self.header_widgets[(row_no, col_no)]", "is_method": true, "class_name": "GridTable", "function_description": "Utility method of the GridTable class that retrieves an existing header widget by row and column or creates and stores one if it doesn't exist, facilitating header management in grid structures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "create_data_widget", "line_number": 60, "body": "def create_data_widget(self, col_no):\n        if col_no < self.frozen_column_count:\n            background = None\n        else:\n            background = \"white\"\n\n        return tk.Label(self, background=background, anchor=\"e\", padx=7, text=\"\")", "is_method": true, "class_name": "GridTable", "function_description": "Creates and returns a labeled widget representing a data cell in the grid, with visual distinction for frozen versus unfrozen columns. Useful for constructing and displaying grid table cells with appropriate styling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "create_header_widget", "line_number": 68, "body": "def create_header_widget(self, col_no):\n        return tk.Label(self, anchor=\"e\", padx=7, text=\"\")", "is_method": true, "class_name": "GridTable", "function_description": "Creates and returns a right-aligned, padded label widget to serve as a header for a specified column in the grid table. Useful for adding column headers in a GUI table interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "set_first_visible_data_row_no", "line_number": 71, "body": "def set_first_visible_data_row_no(self, n):\n        self.first_visible_data_row_no = max(min(n, self.data_row_count), 0)\n        self.update_screen_data()", "is_method": true, "class_name": "GridTable", "function_description": "Sets the index of the first visible data row within valid bounds and refreshes the displayed screen data accordingly. This method controls which part of the data grid is currently shown to users."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "_clear_screen_row", "line_number": 75, "body": "def _clear_screen_row(self, row_no):\n        for widget in self.grid_slaves(row=row_no):\n            widget.grid_remove()", "is_method": true, "class_name": "GridTable", "function_description": "Utility method in GridTable that removes all widgets displayed in a specified row, effectively clearing that row's content from the grid layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "update_screen_widgets", "line_number": 79, "body": "def update_screen_widgets(self, available_screen_height):\n        max_screen_rows = available_screen_height // self.screen_row_height\n        target_screen_row_count = max(\n            min(\n                max_screen_rows,\n                self.header_row_count\n                + self.data_row_count\n                + self.footer_row_count\n                - self.first_visible_data_row_no,\n            ),\n            self.header_row_count + 1 + self.footer_row_count,\n        )\n        # target_screen_row_count = 30\n\n        # remove cells not required anymore ...\n        while self.screen_row_count > target_screen_row_count:\n            # print(\"removing\")\n            self._clear_screen_row(self.screen_row_count - 1)\n            self.screen_row_count -= 1\n\n        # ... or add cells that can be shown\n        while self.screen_row_count < target_screen_row_count:\n            # print(\"adding\")\n            for col in range(self.column_count):\n                w = self.get_data_widget(self.screen_row_count, col)\n                w.grid(\n                    row=self.screen_row_count, column=col, sticky=\"nsew\", pady=(0, 1), padx=(0, 1)\n                )\n\n            self.screen_row_count += 1\n\n        self.visible_data_row_count = (\n            self.screen_row_count - self.header_row_count - self.footer_row_count\n        )", "is_method": true, "class_name": "GridTable", "function_description": "Core method of the GridTable class that adjusts visible table rows based on available screen height, dynamically adding or removing row widgets to fit and display the appropriate portion of the grid content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "update_screen_data", "line_number": 114, "body": "def update_screen_data(self):\n        self.update_screen_widgets(self.winfo_height())\n        for screen_row_no in range(self.header_row_count, self.screen_row_count):\n            data_row_no = self.first_visible_data_row_no + screen_row_no - self.header_row_count\n            if data_row_no == self.data_row_count:\n                break\n\n            for col_no in range(self.column_count):\n                w = self.get_data_widget(screen_row_no, col_no)\n                value = self.get_data_value(data_row_no, col_no)\n                if value is None:\n                    w.configure(text=\"\")\n                else:\n                    w.configure(text=str(value))", "is_method": true, "class_name": "GridTable", "function_description": "Updates visible screen widgets in the GridTable to reflect current data values, synchronizing the display with the underlying data for all visible rows and columns. This ensures the grid view stays consistent with its data source."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "get_data_value", "line_number": 129, "body": "def get_data_value(self, row_no, col_no):\n        \"\"\"lazy dict version:\n        assert 0 <= row_no < self.data_row_count\n        if row_no in self.data_rows:\n            return self.data_rows[row_no][col_no]\n        else:\n            return \"\"\n        \"\"\"\n        return self.data_rows[row_no][col_no]", "is_method": true, "class_name": "GridTable", "function_description": "Retrieves the value at a specific row and column in the grid table, facilitating direct access to individual cell data within the table structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "get_header_value", "line_number": 139, "body": "def get_header_value(self, row_no, col_no):\n        return self.header_rows[row_no][col_no]", "is_method": true, "class_name": "GridTable", "function_description": "Retrieves the value from the table's header at the specified row and column indices. This method enables easy access to header content within a grid-structured table."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "on_configure", "line_number": 142, "body": "def on_configure(self, event):\n        # query row height\n        _, _, _, height = self.grid_bbox(row=1)\n        if height > 10 and height < 100:\n            \"self.screen_row_height = height + 2\"\n\n        # screen_available_height = self.winfo_height()\n\n        # print(\"HE\", self.winfo_height(), event.height, self.screen_row_height)\n        self.update_screen_widgets(event.height)\n\n        self.update_screen_data()", "is_method": true, "class_name": "GridTable", "function_description": "Handles widget resize events by updating the display layout and data according to the new height, ensuring the grid table adapts dynamically to configuration changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "debug", "line_number": 196, "body": "def debug(self, event=None):\n        print(\"DE\", self.vscrollbar.get())", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "Simple debugging method in ScrollableGridTable that prints the current vertical scrollbar position when triggered."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "create_infopanel", "line_number": 199, "body": "def create_infopanel(self, data_row_count):\n        self.infopanel = ttk.Frame(self)\n        self.size_label = ttk.Label(self.infopanel, text=str(data_row_count) + \" rows\")\n        self.size_label.grid(row=0, column=0, padx=5)", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "Creates an informational panel showing the number of data rows, providing a UI element that summarizes table content size within the ScrollableGridTable component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "_update_vertical_scrollbar", "line_number": 204, "body": "def _update_vertical_scrollbar(self):\n        first = self.grid_table.first_visible_data_row_no / self.grid_table.data_row_count\n        last = first + self.grid_table.visible_data_row_count / self.grid_table.data_row_count\n        # print(first, last, self.grid_table.visible_data_row_count)\n        self.vscrollbar.set(first, last)", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "Updates the vertical scrollbar to reflect the current visible portion of the grid table\u2019s data rows, ensuring accurate scroll position and size representation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "_handle_vertical_scroll", "line_number": 210, "body": "def _handle_vertical_scroll(self, *args):\n        # print(\"vscroll\", args, self.vscrollbar.get())\n        if len(args) == 3 and args[0] == \"scroll\":\n            amount = int(args[1])\n            unit = args[2]\n            if unit == \"pages\":\n                amount *= self.grid_table.visible_data_row_count\n\n            self.grid_table.set_first_visible_data_row_no(\n                self.grid_table.first_visible_data_row_no + amount\n            )\n        else:\n            assert args[0] == \"moveto\"\n            pos = max(min(float(args[1]), 1.0), 0.0)\n            top_row = math.floor(\n                (self.grid_table.data_row_count - self.grid_table.visible_data_row_count + 1) * pos\n            )\n            self.grid_table.set_first_visible_data_row_no(top_row)\n\n        self._update_vertical_scrollbar()", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "Handles vertical scrolling events to update the visible rows in a scrollable grid, ensuring the display aligns with user scroll actions. It manages both incremental scrolling and direct scrollbar position jumps."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "_on_expose", "line_number": 231, "body": "def _on_expose(self, event):\n        self.update_idletasks()\n        self._configure_interior(event)", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "Internal event handler in ScrollableGridTable that ensures the widget's layout is updated and properly configured when the component is redrawn or exposed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "_configure_interior", "line_number": 235, "body": "def _configure_interior(self, event):\n        # update the scrollbars to match the size of the inner frame\n        size = (self.interior.winfo_reqwidth(), self.canvas.winfo_height())\n        self.canvas.config(scrollregion=\"0 0 %s %s\" % size)\n        if (\n            self.interior.winfo_reqheight() != self.canvas.winfo_height()\n            and self.canvas.winfo_height() > 10\n        ):\n            # update the interior's height to fit canvas\n            self.canvas.itemconfigure(self.interior_id, height=self.canvas.winfo_height())\n\n        self._update_vertical_scrollbar()", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "Updates scrollbars and adjusts the interior frame size to ensure proper scrolling and layout within the ScrollableGridTable's canvas. This maintains synchronized scrolling behavior as the interior content or container size changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/first_run.py", "function": "on_change_language", "line_number": 55, "body": "def on_change_language(self):\n        print(self.language_variable.get())", "is_method": true, "class_name": "FirstRunWindow", "function_description": "Outputs the current value of the language setting when the language selection changes, supporting language preference tracking in the FirstRunWindow interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/first_run.py", "function": "add_combo", "line_number": 58, "body": "def add_combo(self, row, label_text, variable, values):\n        pady = 7\n        label = ttk.Label(self.main_frame, text=label_text)\n        label.grid(row=row, column=2, sticky=\"sw\", pady=(pady, 0))\n        assert isinstance(variable, tk.Variable)\n        combobox = ttk.Combobox(\n            self.main_frame,\n            exportselection=False,\n            textvariable=variable,\n            state=\"readonly\",\n            height=15,\n            width=20,\n            values=values,\n        )\n        combobox.grid(row=row, column=3, padx=(10, self.padx), sticky=\"sw\", pady=(pady, 0))", "is_method": true, "class_name": "FirstRunWindow", "function_description": "Utility method in FirstRunWindow that adds a labeled, read-only dropdown combo box to the interface, linking it to a Tkinter variable and providing selectable options for user input."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/first_run.py", "function": "center", "line_number": 74, "body": "def center(self):\n        width = max(self.winfo_reqwidth(), 640)\n        height = max(self.winfo_reqheight(), 300)\n\n        screen_width = self.winfo_screenwidth()\n        screen_height = self.winfo_screenheight()\n\n        if screen_width > screen_height * 2:\n            # probably dual monitors\n            screen_width //= 2\n\n        left = max(int(screen_width / 2 - width / 2), 0)\n        top = max(int(screen_height / 2 - height / 2), 0)\n\n        # Positions the window in the center of the page.\n        self.geometry(\"+{}+{}\".format(left, top))", "is_method": true, "class_name": "FirstRunWindow", "function_description": "Centers the FirstRunWindow on the primary screen or one monitor in a dual-monitor setup, ensuring it appears in the middle with at least a minimum size for optimal visibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/first_run.py", "function": "on_ok", "line_number": 91, "body": "def on_ok(self):\n        if self.mode_variable.get() == RPI_MODE_TEXT:\n            self.conf.set_option(\"debugger.preferred_debugger\", \"faster\")\n            self.conf.set_option(\"view.ui_theme\", \"Raspberry Pi\")\n            self.conf.set_option(\"general.ui_mode\", \"simple\")\n\n        self.conf.set_option(\n            \"general.language\", languages.get_language_code_by_name(self.language_variable.get())\n        )\n\n        self.conf.save()\n\n        self.ok = True\n        self.destroy()", "is_method": true, "class_name": "FirstRunWindow", "function_description": "Method of FirstRunWindow that saves user-selected configuration options like debugger preference, UI theme, and language, then applies and persists these settings before closing the window. It finalizes initial setup based on user choices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "extract_text_range", "line_number": 7, "body": "def extract_text_range(source, text_range):\n    if isinstance(source, bytes):\n        # TODO: may be wrong encoding\n        source = source.decode(\"utf-8\")\n\n    lines = source.splitlines(True)\n    # get relevant lines\n    lines = lines[text_range.lineno - 1 : text_range.end_lineno]\n\n    # trim last and first lines\n    lines[-1] = lines[-1][: text_range.end_col_offset]\n    lines[0] = lines[0][text_range.col_offset :]\n    return \"\".join(lines)", "is_method": false, "function_description": "Function that extracts and returns a specific substring from a multi-line text source based on given line and column start/end positions, supporting both byte and string input formats."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "find_expression", "line_number": 22, "body": "def find_expression(start_node, text_range):\n    for node in ast.walk(start_node):\n        if (\n            isinstance(node, ast.expr)\n            and node.lineno == text_range.lineno\n            and node.col_offset == text_range.col_offset\n            and node.end_lineno == text_range.end_lineno\n            and node.end_col_offset == text_range.end_col_offset\n        ):\n            return node\n\n    return None", "is_method": false, "function_description": "This function searches within an AST subtree to locate an expression node exactly matching a specific text range. It enables precise identification of code expressions based on their position in the source."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "parse_source", "line_number": 36, "body": "def parse_source(source: bytes, filename=\"<unknown>\", mode=\"exec\", fallback_to_one_char=False):\n    root = ast.parse(source, filename, mode)\n    mark_text_ranges(root, source, fallback_to_one_char)\n    return root", "is_method": false, "function_description": "Parses Python source code into an abstract syntax tree (AST) with accurate text range markings, facilitating code analysis or transformation tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "get_last_child", "line_number": 42, "body": "def get_last_child(node, skip_incorrect=True):\n    \"\"\"Returns last focusable child expression or child statement\"\"\"\n\n    def ok_node(node):\n        if node is None:\n            return None\n\n        assert isinstance(node, (ast.expr, ast.stmt))\n\n        if skip_incorrect and getattr(node, \"incorrect_range\", False):\n            return None\n\n        return node\n\n    def last_ok(nodes):\n        for i in range(len(nodes) - 1, -1, -1):\n            if ok_node(nodes[i]):\n                node = nodes[i]\n                if isinstance(node, ast.Starred):\n                    if ok_node(node.value):\n                        return node.value\n                    else:\n                        return None\n                else:\n                    return nodes[i]\n\n        return None\n\n    if isinstance(node, ast.Call):\n        # TODO: take care of Python 3.5 updates (Starred etc.)\n        if hasattr(node, \"kwargs\") and ok_node(node.kwargs):\n            return node.kwargs\n        elif hasattr(node, \"starargs\") and ok_node(node.starargs):\n            return node.starargs\n        else:\n            kw_values = list(map(lambda x: x.value, node.keywords))\n            last_ok_kw = last_ok(kw_values)\n            if last_ok_kw:\n                return last_ok_kw\n            elif last_ok(node.args):\n                return last_ok(node.args)\n            else:\n                return ok_node(node.func)\n\n    elif isinstance(node, ast.BoolOp):\n        return last_ok(node.values)\n\n    elif isinstance(node, ast.BinOp):\n        if ok_node(node.right):\n            return node.right\n        else:\n            return ok_node(node.left)\n\n    elif isinstance(node, ast.Compare):\n        return last_ok(node.comparators)\n\n    elif isinstance(node, ast.UnaryOp):\n        return ok_node(node.operand)\n\n    elif isinstance(node, (ast.Tuple, ast.List, ast.Set)):\n        return last_ok(node.elts)\n\n    elif isinstance(node, ast.Dict):\n        # TODO: actually should pairwise check last value, then last key, etc.\n        return last_ok(node.values)\n\n    elif isinstance(\n        node, (ast.Index, ast.Return, ast.Assign, ast.AugAssign, ast.Yield, ast.YieldFrom)\n    ):\n        return ok_node(node.value)\n\n    elif isinstance(node, ast.Delete):\n        return last_ok(node.targets)\n\n    elif isinstance(node, ast.Expr):\n        return ok_node(node.value)\n\n    elif isinstance(node, ast.Assert):\n        if ok_node(node.msg):\n            return node.msg\n        else:\n            return ok_node(node.test)\n\n    elif isinstance(node, ast.Slice):\n        # [:]\n        if ok_node(node.step):\n            return node.step\n        elif ok_node(node.upper):\n            return node.upper\n        else:\n            return ok_node(node.lower)\n\n    elif isinstance(node, ast.ExtSlice):\n        # [:,:]\n        for dim in reversed(node.dims):\n            result = get_last_child(dim, skip_incorrect)\n            assert result is None or isinstance(result, ast.expr)\n            if result is not None:\n                return result\n        return None\n\n    elif isinstance(node, ast.Subscript):\n        result = get_last_child(node.slice, skip_incorrect)\n        if result is not None:\n            return result\n        else:\n            return node.value\n\n    elif isinstance(node, ast.Raise):\n        if ok_node(node.cause):\n            return node.cause\n        elif ok_node(node.exc):\n            return node.exc\n\n    elif isinstance(node, (ast.For, ast.While, ast.If, ast.With)):\n        return True  # There is last child, but I don't know which it will be\n\n    # TODO: pick more cases from here:\n    \"\"\"\n    (isinstance(node, (ast.IfExp, ast.ListComp, ast.SetComp, ast.DictComp, ast.GeneratorExp))\n            # or isinstance(node, ast.FunctionDef, ast.Lambda) and len(node.args.defaults) > 0\n                and (node.dest is not None or len(node.values) > 0))\n\n            #\"TODO: Import ja ImportFrom\"\n            # TODO: what about ClassDef ???\n    \"\"\"\n\n    return None", "is_method": false, "function_description": "Function that traverses an AST node to find and return its last valid child expression or statement, useful for analyzing or manipulating the deepest focusable elements within complex Python syntax structures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "mark_text_ranges", "line_number": 172, "body": "def mark_text_ranges(node, source: Union[bytes, str], fallback_to_one_char=False):\n    \"\"\"\n    Node is an AST, source is corresponding source as string.\n    Function adds recursively attributes end_lineno and end_col_offset to each node\n    which has attributes lineno and col_offset.\n    \"\"\"\n    from asttokens.asttokens import ASTTokens\n\n    if isinstance(source, bytes):\n        source = source.decode(\"utf8\")\n\n    ASTTokens(source, tree=node)\n    for child in ast.walk(node):\n        if hasattr(child, \"last_token\"):\n            child.end_lineno, child.end_col_offset = child.last_token.end\n\n            if hasattr(child, \"lineno\"):\n                # Fixes problems with some nodes like binop\n                child.lineno, child.col_offset = child.first_token.start\n\n        # some nodes stay without end info\n        if (\n            hasattr(child, \"lineno\")\n            and (not hasattr(child, \"end_lineno\") or not hasattr(child, \"end_col_offset\"))\n            and fallback_to_one_char\n        ):\n            child.end_lineno = child.lineno\n            child.end_col_offset = child.col_offset + 2", "is_method": false, "function_description": "Utility function that annotates AST nodes with ending line and column positions based on source code, enhancing node range information for accurate source mapping or analysis in Python syntax trees."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "ok_node", "line_number": 45, "body": "def ok_node(node):\n        if node is None:\n            return None\n\n        assert isinstance(node, (ast.expr, ast.stmt))\n\n        if skip_incorrect and getattr(node, \"incorrect_range\", False):\n            return None\n\n        return node", "is_method": false, "function_description": "This function validates an AST node by checking its type and correctness, returning the node if valid or None if invalid or marked to skip. It aids in filtering nodes for safe processing in AST-related operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "last_ok", "line_number": 56, "body": "def last_ok(nodes):\n        for i in range(len(nodes) - 1, -1, -1):\n            if ok_node(nodes[i]):\n                node = nodes[i]\n                if isinstance(node, ast.Starred):\n                    if ok_node(node.value):\n                        return node.value\n                    else:\n                        return None\n                else:\n                    return nodes[i]\n\n        return None", "is_method": false, "function_description": "Returns the last node in the list that satisfies the ok_node condition, handling special cases for starred nodes by validating their inner value. Useful for selecting the most recent acceptable element from a sequence."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_current_breakpoints", "line_number": 1053, "body": "def get_current_breakpoints():\n    result = {}\n\n    for editor in get_workbench().get_editor_notebook().get_all_editors():\n        filename = editor.get_filename()\n        if filename:\n            linenos = editor.get_code_view().get_breakpoint_line_numbers()\n            if linenos:\n                result[filename] = linenos\n\n    return result", "is_method": false, "function_description": "Returns a dictionary mapping open file names to their active breakpoint line numbers in the current editor session. Useful for debugging tools to track and manage breakpoints across multiple files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_saved_current_script_filename", "line_number": 1066, "body": "def get_saved_current_script_filename(force=True):\n    editor = get_workbench().get_editor_notebook().get_current_editor()\n    if not editor:\n        return None\n\n    filename = editor.get_filename(force)\n    if not filename:\n        return None\n\n    if editor.is_modified():\n        filename = editor.save_file()\n\n    return filename", "is_method": false, "function_description": "Function that retrieves the current script's filename from the editor, optionally forcing retrieval and saving changes if the file is modified. Useful for ensuring access to the latest saved script path in editing environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "is_remote_path", "line_number": 1081, "body": "def is_remote_path(s):\n    return REMOTE_PATH_MARKER in s", "is_method": false, "function_description": "Utility function that checks if a given string represents a remote path by detecting a specific marker within it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "is_local_path", "line_number": 1085, "body": "def is_local_path(s):\n    return not is_remote_path(s)", "is_method": false, "function_description": "Utility function that determines if a given path string refers to a local (non-remote) location, supporting functions that need to differentiate between local and remote paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_target_dirname_from_editor_filename", "line_number": 1089, "body": "def get_target_dirname_from_editor_filename(s):\n    if is_local_path(s):\n        return os.path.dirname(s)\n    else:\n        return universal_dirname(extract_target_path(s))", "is_method": false, "function_description": "Utility function that derives the target directory name from an editor filename, handling both local paths and remote or abstract path formats to standardize directory retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "extract_target_path", "line_number": 1096, "body": "def extract_target_path(s):\n    assert is_remote_path(s)\n    return s[s.find(REMOTE_PATH_MARKER) + len(REMOTE_PATH_MARKER) :]", "is_method": false, "function_description": "Extracts the portion of a remote path string following a specific marker, providing a targeted subpath for further processing or access."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "make_remote_path", "line_number": 1101, "body": "def make_remote_path(target_path):\n    return get_runner().get_node_label() + REMOTE_PATH_MARKER + target_path", "is_method": false, "function_description": "Concatenates the current node's label with a remote path marker and a target path, producing a standardized remote path string. Useful for identifying or referencing resources in distributed systems across nodes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_text_widget", "line_number": 69, "body": "def get_text_widget(self):\n        return self._code_view.text", "is_method": true, "class_name": "Editor", "function_description": "Returns the text widget component from the editor's code view, providing access to the editable text area for further manipulation or interrogation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_filename", "line_number": 76, "body": "def get_filename(self, try_hard=False):\n        if self._filename is None and try_hard:\n            self.save_file()\n\n        return self._filename", "is_method": true, "class_name": "Editor", "function_description": "Method of the Editor class that returns the current filename, optionally saving the file first if no filename is set. It ensures a filename is available for further file operations or references."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_title", "line_number": 82, "body": "def get_title(self):\n        if self.get_filename() is None:\n            result = \"<untitled>\"\n        elif is_remote_path(self.get_filename()):\n            path = extract_target_path(self.get_filename())\n            name = path.split(\"/\")[-1]\n            result = \"[ \" + name + \" ]\"\n        else:\n            result = os.path.basename(self.get_filename())\n\n        if self.is_modified():\n            result += \" *\"\n\n        return result", "is_method": true, "class_name": "Editor", "function_description": "Method of the Editor class that returns the current document's title, formatting untitled, remote, and local filenames distinctly, and indicating if the document has unsaved modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "check_for_external_changes", "line_number": 97, "body": "def check_for_external_changes(self):\n        if self._asking_about_external_change:\n            # otherwise method will be re-entered when focus\n            # changes because of message box\n            return\n\n        if self._filename is None:\n            return\n\n        if is_remote_path(self._filename):\n            return\n\n        try:\n            self._asking_about_external_change = True\n\n            if self._last_known_mtime is None:\n                return\n\n            elif not os.path.exists(self._filename):\n                self.master.select(self)\n\n                if messagebox.askyesno(\n                    tr(\"File is gone\"),\n                    tr(\"Looks like '%s' was deleted or moved outside of the editor.\")\n                    % self._filename\n                    + \"\\n\\n\"\n                    + tr(\"Do you want to also close the editor?\"),\n                    master=self,\n                ):\n                    self.master.close_editor(self)\n                else:\n                    self.get_text_widget().edit_modified(True)\n                    self._last_known_mtime = None\n\n            elif os.path.getmtime(self._filename) != self._last_known_mtime:\n                self.master.select(self)\n\n                if messagebox.askyesno(\n                    tr(\"External modification\"),\n                    tr(\"Looks like '%s' was modified outside the editor.\") % self._filename\n                    + \"\\n\\n\"\n                    + tr(\n                        \"Do you want to discard current editor content and reload the file from disk?\"\n                    ),\n                    master=self,\n                ):\n                    self._load_file(self._filename, keep_undo=True)\n                else:\n                    self._last_known_mtime = os.path.getmtime(self._filename)\n        finally:\n            self._asking_about_external_change = False", "is_method": true, "class_name": "Editor", "function_description": "Checks if the editor's open file has been externally deleted or modified and prompts the user to close or reload it accordingly, ensuring the editor's content stays synchronized with the file system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_long_description", "line_number": 149, "body": "def get_long_description(self):\n\n        if self._filename is None:\n            result = \"<untitled>\"\n        else:\n            result = self._filename\n\n        try:\n            index = self._code_view.text.index(\"insert\")\n            if index and \".\" in index:\n                line, col = index.split(\".\")\n                result += \"  @  {} : {}\".format(line, int(col) + 1)\n        except Exception:\n            exception(\"Finding cursor location\")\n\n        return result", "is_method": true, "class_name": "Editor", "function_description": "Provides a descriptive string showing the editor's current file name along with the cursor's line and column position, aiding user context in text editing environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_load_file", "line_number": 166, "body": "def _load_file(self, filename, keep_undo=False):\n        try:\n            if is_remote_path(filename):\n                result = self._load_remote_file(filename)\n            else:\n                result = self._load_local_file(filename, keep_undo)\n                if not result:\n                    return False\n        except BinaryFileException:\n            messagebox.showerror(\n                \"Problem\", \"%s doesn't look like a text file\" % filename, master=self\n            )\n            return False\n        except SyntaxError as e:\n            assert \"encoding\" in str(e).lower()\n            messagebox.showerror(\n                \"Problem loading file\",\n                \"This file seems to have problems with encoding.\\n\\n\"\n                + \"Make sure it is in UTF-8 or contains proper encoding hint.\",\n                master=self,\n            )\n            return False\n\n        self.update_appearance()\n        return True", "is_method": true, "class_name": "Editor", "function_description": "Utility method in the Editor class that loads a file from local or remote sources, handling encoding and format errors gracefully while optionally preserving undo history. It enables reliable file loading with user-friendly error notifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_load_local_file", "line_number": 192, "body": "def _load_local_file(self, filename, keep_undo=False):\n        with open(filename, \"rb\") as fp:\n            source = fp.read()\n\n        # Make sure Windows filenames have proper format\n        filename = normpath_with_actual_case(filename)\n        self._filename = filename\n        self.update_file_type()\n        self._last_known_mtime = os.path.getmtime(self._filename)\n\n        get_workbench().event_generate(\"Open\", editor=self, filename=filename)\n        if not self._code_view.set_content_as_bytes(source, keep_undo):\n            return False\n        self.get_text_widget().edit_modified(False)\n        self._code_view.focus_set()\n        self.master.remember_recent_file(filename)\n        return True", "is_method": true, "class_name": "Editor", "function_description": "Core method of the Editor class that loads a local file's content into the editor, updates its state, and manages undo history. It also handles filename normalization, modification time tracking, and recent file recording."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_load_remote_file", "line_number": 210, "body": "def _load_remote_file(self, filename):\n        self._filename = filename\n        self.update_file_type()\n        self._code_view.set_content(\"\")\n        self._code_view.text.set_read_only(True)\n\n        target_filename = extract_target_path(self._filename)\n\n        self.update_title()\n        response = get_runner().send_command_and_wait(\n            InlineCommand(\n                \"read_file\", path=target_filename, description=tr(\"Loading %s\") % target_filename\n            ),\n            dialog_title=tr(\"Loading\"),\n        )\n\n        if response.get(\"error\"):\n            # TODO: make it softer\n            raise RuntimeError(response[\"error\"])\n\n        content = response[\"content_bytes\"]\n        self._code_view.text.set_read_only(False)\n        if not self._code_view.set_content_as_bytes(content):\n            return False\n        self.get_text_widget().edit_modified(False)\n        self.update_title()\n        return True", "is_method": true, "class_name": "Editor", "function_description": "Utility method of the Editor class that loads a remote file's content into the editor, sets the editor state accordingly, and handles any loading errors. It ensures the editor displays the latest file content while managing read-only states during loading."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "is_modified", "line_number": 238, "body": "def is_modified(self):\n        return bool(self._code_view.text.edit_modified())", "is_method": true, "class_name": "Editor", "function_description": "Checks whether the current text in the editor has been modified since the last save or reset. Useful for detecting unsaved changes before actions like closing or reloading."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "save_file_enabled", "line_number": 241, "body": "def save_file_enabled(self):\n        return self.is_modified() or not self.get_filename()", "is_method": true, "class_name": "Editor", "function_description": "Determines if the current file can be saved based on whether it has unsaved changes or lacks a filename. This helps control the save functionality in the editing context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "save_file", "line_number": 244, "body": "def save_file(self, ask_filename=False, save_copy=False, node=None):\n        if self._filename is not None and not ask_filename:\n            save_filename = self._filename\n            get_workbench().event_generate(\"Save\", editor=self, filename=save_filename)\n        else:\n            save_filename = self.ask_new_path(node)\n\n            if not save_filename:\n                return None\n\n            if self.notebook.get_editor(save_filename) is not None:\n                messagebox.showerror(\n                    \"File is open\",\n                    \"This file is already open in Thonny.\\n\\n\"\n                    \"If you want to save with this name,\\n\"\n                    \"close the existing editor first!\",\n                    master=get_workbench(),\n                )\n                return None\n\n            get_workbench().event_generate(\n                \"SaveAs\", editor=self, filename=save_filename, save_copy=save_copy\n            )\n\n        content_bytes = self._code_view.get_content_as_bytes()\n\n        if is_remote_path(save_filename):\n            result = self.write_remote_file(save_filename, content_bytes, save_copy)\n        else:\n            result = self.write_local_file(save_filename, content_bytes, save_copy)\n\n        if not result:\n            return None\n\n        if not save_copy:\n            self._filename = save_filename\n            self.update_file_type()\n\n        self.update_title()\n        return save_filename", "is_method": true, "class_name": "Editor", "function_description": "Saves the current editor content to a specified or user-selected file, handling both local and remote paths, with options to save as a copy or update the editor state accordingly. It prevents overwriting open files and updates the UI after saving."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "write_local_file", "line_number": 285, "body": "def write_local_file(self, save_filename, content_bytes, save_copy):\n        try:\n            f = open(save_filename, mode=\"wb\")\n            f.write(content_bytes)\n            f.flush()\n            # Force writes on disk, see https://learn.adafruit.com/adafruit-circuit-playground-express/creating-and-editing-code#1-use-an-editor-that-writes-out-the-file-completely-when-you-save-it\n            os.fsync(f)\n            f.close()\n            if not save_copy or save_filename == self._filename:\n                self._last_known_mtime = os.path.getmtime(save_filename)\n            get_workbench().event_generate(\n                \"LocalFileOperation\", path=save_filename, operation=\"save\"\n            )\n        except PermissionError:\n            messagebox.showerror(\n                \"Permission Error\", \"Looks like this file or folder is not writable.\", master=self\n            )\n            return False\n\n        if not save_copy or save_filename == self._filename:\n            self.master.remember_recent_file(save_filename)\n\n        if not save_copy or save_filename == self._filename:\n            self._code_view.text.edit_modified(False)\n\n        return True", "is_method": true, "class_name": "Editor", "function_description": "Method of the Editor class that saves byte content to a specified local file, handling file overwrites and permission errors while updating modification times and notifying the system of the save operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "update_file_type", "line_number": 312, "body": "def update_file_type(self):\n        if self._filename is None:\n            self._code_view.set_file_type(None)\n        else:\n            ext = self._filename.split(\".\")[-1].lower()\n            if ext in [\"py\", \"pyw\", \"pyi\"]:\n                file_type = \"python\"\n            else:\n                file_type = None\n\n            self._code_view.set_file_type(file_type)\n\n        self.update_appearance()", "is_method": true, "class_name": "Editor", "function_description": "Method of the Editor class that sets the code view's file type based on the current filename extension, primarily identifying Python files to enable appropriate syntax highlighting and appearance updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "write_remote_file", "line_number": 326, "body": "def write_remote_file(self, save_filename, content_bytes, save_copy):\n        if get_runner().ready_for_remote_file_operations(show_message=True):\n            target_filename = extract_target_path(save_filename)\n\n            get_runner().send_command_and_wait(\n                InlineCommand(\n                    \"write_file\",\n                    path=target_filename,\n                    content_bytes=content_bytes,\n                    editor_id=id(self),\n                    blocking=True,\n                    description=tr(\"Saving to %s\") % target_filename,\n                ),\n                dialog_title=tr(\"Saving\"),\n            )\n\n            if not save_copy:\n                self._code_view.text.edit_modified(False)\n\n            self.update_title()\n\n            # NB! edit_modified is not falsed yet!\n            get_workbench().event_generate(\n                \"RemoteFileOperation\", path=target_filename, operation=\"save\"\n            )\n            get_workbench().event_generate(\"RemoteFilesChanged\")\n            return True\n        else:\n            return False", "is_method": true, "class_name": "Editor", "function_description": "Method of the Editor class that saves file content remotely, updating the editor state and notifying the workbench of the change. It supports both saving and optionally preserving local modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "ask_new_path", "line_number": 356, "body": "def ask_new_path(self, node=None):\n        if node is None:\n            node = choose_node_for_file_operations(self.winfo_toplevel(), \"Where to save to?\")\n        if not node:\n            return None\n\n        if node == \"local\":\n            return self.ask_new_local_path()\n        else:\n            assert node == \"remote\"\n            return self.ask_new_remote_path()", "is_method": true, "class_name": "Editor", "function_description": "Utility method of the Editor class that prompts the user to select a save destination and returns a new file path accordingly, supporting both local and remote storage options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "ask_new_remote_path", "line_number": 368, "body": "def ask_new_remote_path(self):\n        target_path = ask_backend_path(self.winfo_toplevel(), \"save\")\n        if target_path:\n            return make_remote_path(target_path)\n        else:\n            return None", "is_method": true, "class_name": "Editor", "function_description": "Returns a remote-compatible save path selected by the user through a backend dialog, or None if no path is chosen. It enables specifying remote storage locations in the Editor context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "ask_new_local_path", "line_number": 375, "body": "def ask_new_local_path(self):\n        if self._filename is None:\n            initialdir = get_workbench().get_local_cwd()\n            initialfile = None\n        else:\n            initialdir = os.path.dirname(self._filename)\n            initialfile = os.path.basename(self._filename)\n\n        # http://tkinter.unpythonic.net/wiki/tkFileDialog\n        new_filename = asksaveasfilename(\n            filetypes=_dialog_filetypes,\n            defaultextension=\".py\",\n            initialdir=initialdir,\n            initialfile=initialfile,\n            parent=get_workbench(),\n        )\n\n        # Different tkinter versions may return different values\n        if new_filename in [\"\", (), None]:\n            return None\n\n        # Seems that in some Python versions defaultextension\n        # acts funny\n        if new_filename.lower().endswith(\".py.py\"):\n            new_filename = new_filename[:-3]\n\n        if running_on_windows():\n            # may have /-s instead of \\-s and wrong case\n            new_filename = os.path.join(\n                normpath_with_actual_case(os.path.dirname(new_filename)),\n                os.path.basename(new_filename),\n            )\n\n        if new_filename.endswith(\".py\"):\n            base = os.path.basename(new_filename)\n            mod_name = base[:-3].lower()\n            if running_on_windows():\n                mod_name = mod_name.lower()\n\n            if mod_name in [\n                \"math\",\n                \"turtle\",\n                \"random\",\n                \"statistics\",\n                \"pygame\",\n                \"matplotlib\",\n                \"numpy\",\n            ]:\n\n                # More proper name analysis will be performed by ProgramNamingAnalyzer\n                if not tk.messagebox.askyesno(\n                    \"Potential problem\",\n                    \"If you name your script '%s', \" % base\n                    + \"you won't be able to import the library module named '%s'\" % mod_name\n                    + \".\\n\\n\"\n                    + \"Do you still want to use this name for your script?\",\n                    master=self,\n                ):\n                    return self.ask_new_local_path()\n\n        return new_filename", "is_method": true, "class_name": "Editor", "function_description": "Prompts the user to choose or specify a new local file path for saving, with safeguards against naming conflicts with standard Python libraries. It supports initial directory suggestions and handles various platform-specific filename issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "show", "line_number": 437, "body": "def show(self):\n        self.master.select(self)", "is_method": true, "class_name": "Editor", "function_description": "Core method of the Editor class that activates or brings the editor's interface into focus within its container or window. It enables user interaction by selecting this editor instance for editing tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "update_appearance", "line_number": 440, "body": "def update_appearance(self):\n        self._code_view.set_gutter_visibility(\n            get_workbench().get_option(\"view.show_line_numbers\") or get_workbench().in_simple_mode()\n        )\n        self._code_view.set_line_length_margin(\n            get_workbench().get_option(\"view.recommended_line_length\")\n        )\n        self._code_view.text.update_tabs()\n        self._code_view.text.event_generate(\"<<UpdateAppearance>>\")", "is_method": true, "class_name": "Editor", "function_description": "Updates the code view's appearance settings such as gutter visibility, line length margin, and tab display based on current user preferences, then triggers an appearance update event. This ensures the editor reflects the latest UI configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_listen_debugger_progress", "line_number": 450, "body": "def _listen_debugger_progress(self, event):\n        # Go read-only\n        # TODO: check whether this module is active?\n        self._code_view.text.set_read_only(True)", "is_method": true, "class_name": "Editor", "function_description": "Sets the code view to read-only mode in response to debugger progress events, likely to prevent edits during debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_listen_for_toplevel_response", "line_number": 455, "body": "def _listen_for_toplevel_response(self, event: ToplevelResponse) -> None:\n        self._code_view.text.set_read_only(False)", "is_method": true, "class_name": "Editor", "function_description": "Internal method of the Editor class that handles top-level response events by making the code view editable. It supports dynamic interaction with the editor's UI state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_control_tab", "line_number": 458, "body": "def _control_tab(self, event):\n        if event.state & 1:  # shift was pressed\n            direction = -1\n        else:\n            direction = 1\n        self.master.select_next_prev_editor(direction)\n        return \"break\"", "is_method": true, "class_name": "Editor", "function_description": "Handles Control+Tab keyboard events to switch the editor view forward or backward, supporting Shift+Control+Tab for reverse navigation within multiple editor tabs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_shift_control_tab", "line_number": 466, "body": "def _shift_control_tab(self, event):\n        self.master.select_next_prev_editor(-1)\n        return \"break\"", "is_method": true, "class_name": "Editor", "function_description": "Handles the Control+Tab keyboard shortcut to switch focus to the previous editor tab. It enables quick navigation between editor tabs within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "select_range", "line_number": 470, "body": "def select_range(self, text_range):\n        self._code_view.select_range(text_range)", "is_method": true, "class_name": "Editor", "function_description": "Utility method of the Editor class that delegates selecting a specified text range within the editor view, enabling other components to highlight or focus on text segments programmatically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "select_line", "line_number": 473, "body": "def select_line(self, lineno, col_offset=None):\n        self._code_view.select_range(TextRange(lineno, 0, lineno + 1, 0))\n        self.see_line(lineno)\n\n        if col_offset is None:\n            col_offset = 0\n\n        self.get_text_widget().mark_set(\"insert\", \"%d.%d\" % (lineno, col_offset))", "is_method": true, "class_name": "Editor", "function_description": "Selects and highlights an entire line in the editor, optionally placing the cursor at a specified column offset within that line. This facilitates programmatic line navigation and cursor positioning in the text view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "see_line", "line_number": 482, "body": "def see_line(self, lineno):\n        # first see an earlier line in order to push target line downwards\n        self._code_view.text.see(\"%d.0\" % max(lineno - 4, 1))\n        self._code_view.text.see(\"%d.0\" % lineno)", "is_method": true, "class_name": "Editor", "function_description": "Makes the editor view scroll to ensure a specific line is visible, adjusting upward for context. Useful for navigating to and focusing on a particular line of code within the editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "focus_set", "line_number": 487, "body": "def focus_set(self):\n        self._code_view.focus_set()", "is_method": true, "class_name": "Editor", "function_description": "Sets the keyboard focus to the editor's code view component, enabling immediate user input. This function is useful for directing user interaction to the code editing area."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "is_focused", "line_number": 490, "body": "def is_focused(self):\n        return self.focus_displayof() == self._code_view.text", "is_method": true, "class_name": "Editor", "function_description": "Determines if the editor's code view currently has input focus, indicating user interaction readiness with the code area. This helps manage UI behavior based on focus state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_on_text_modified", "line_number": 493, "body": "def _on_text_modified(self, event):\n        self.update_title()", "is_method": true, "class_name": "Editor", "function_description": "Internal method of the Editor class that handles text modification events by updating the editor's title accordingly to reflect changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "update_title", "line_number": 496, "body": "def update_title(self):\n        try:\n            self.master.update_editor_title(self)\n        except Exception as e:\n            logger.exception(\"Could not update editor title\", exc_info=e)", "is_method": true, "class_name": "Editor", "function_description": "Updates the editor's title display through its master controller, handling exceptions to ensure stability during the update process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_on_text_change", "line_number": 502, "body": "def _on_text_change(self, event):\n        self.update_title()", "is_method": true, "class_name": "Editor", "function_description": "Private method in the Editor class that updates the document title whenever a text change event occurs, typically used to reflect editing status or unsaved changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "destroy", "line_number": 505, "body": "def destroy(self):\n        get_workbench().unbind(\"DebuggerResponse\", self._listen_debugger_progress)\n        get_workbench().unbind(\"ToplevelResponse\", self._listen_for_toplevel_response)\n        ttk.Frame.destroy(self)", "is_method": true, "class_name": "Editor", "function_description": "Method in the Editor class that cleans up event listeners and resources when an editor instance is closed or destroyed, ensuring proper unbinding from debugger and toplevel response events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_init_commands", "line_number": 549, "body": "def _init_commands(self):\n        # TODO: do these commands have to be in EditorNotebook ??\n        # Create a module level function install_editor_notebook ??\n        # Maybe add them separately, when notebook has been installed ??\n\n        get_workbench().add_command(\n            \"new_file\",\n            \"file\",\n            tr(\"New\"),\n            self._cmd_new_file,\n            caption=tr(\"New\"),\n            default_sequence=select_sequence(\"<Control-n>\", \"<Command-n>\"),\n            extra_sequences=[\"<Control-Greek_nu>\"],\n            group=10,\n            image=\"new-file\",\n            include_in_toolbar=True,\n        )\n\n        get_workbench().add_command(\n            \"open_file\",\n            \"file\",\n            tr(\"Open...\"),\n            self._cmd_open_file,\n            caption=tr(\"Load\"),\n            default_sequence=select_sequence(\"<Control-o>\", \"<Command-o>\"),\n            extra_sequences=[\"<Control-Greek_omicron>\"],\n            group=10,\n            image=\"open-file\",\n            include_in_toolbar=True,\n        )\n\n        get_workbench().add_command(\n            \"recents\", \"file\", tr(\"Recent files\"), group=10, submenu=self._recent_menu\n        )\n\n        # http://stackoverflow.com/questions/22907200/remap-default-keybinding-in-tkinter\n        get_workbench().bind_class(\"Text\", \"<Control-o>\", self._control_o)\n        get_workbench().bind_class(\"Text\", \"<Control-Greek_omicron>\", self._control_o)\n        rebind_control_a(get_workbench())\n\n        get_workbench().add_command(\n            \"close_file\",\n            \"file\",\n            tr(\"Close\"),\n            self._cmd_close_file,\n            default_sequence=select_sequence(\"<Control-w>\", \"<Command-w>\"),\n            extra_sequences=[\"<Control-Greek_finalsmallsigma>\"],\n            tester=lambda: self.get_current_editor() is not None,\n            group=10,\n        )\n\n        get_workbench().add_command(\n            \"close_files\",\n            \"file\",\n            tr(\"Close all\"),\n            self.close_tabs,\n            tester=lambda: self.get_current_editor() is not None,\n            default_sequence=select_sequence(\"<Control-W>\", \"<Command-Alt-w>\"),\n            group=10,\n        )\n\n        get_workbench().add_command(\n            \"save_file\",\n            \"file\",\n            tr(\"Save\"),\n            self._cmd_save_file,\n            caption=tr(\"Save\"),\n            default_sequence=select_sequence(\"<Control-s>\", \"<Command-s>\"),\n            extra_sequences=[\"<Control-Greek_sigma>\"],\n            tester=self._cmd_save_file_enabled,\n            group=10,\n            image=\"save-file\",\n            include_in_toolbar=True,\n        )\n\n        get_workbench().add_command(\n            \"save_all_files\",\n            \"file\",\n            tr(\"Save All files\"),\n            self._cmd_save_all_files,\n            caption=tr(\"Save All files\"),\n            default_sequence=select_sequence(\"<Control-Alt-s>\", \"<Command-Alt-s>\"),\n            tester=self._cmd_save_all_files_enabled,\n            group=10,\n        )\n\n        get_workbench().add_command(\n            \"save_file_as\",\n            \"file\",\n            tr(\"Save as...\"),\n            self._cmd_save_file_as,\n            default_sequence=select_sequence(\"<Control-Shift-S>\", \"<Command-Shift-s>\"),\n            extra_sequences=[\"<Control-Greek_SIGMA>\"],\n            tester=lambda: self.get_current_editor() is not None,\n            group=10,\n        )\n\n        get_workbench().add_command(\n            \"save_copy\",\n            \"file\",\n            tr(\"Save copy...\"),\n            self._cmd_save_copy,\n            tester=lambda: self.get_current_editor() is not None,\n            group=10,\n        )\n\n        get_workbench().add_command(\n            \"move_rename_file\",\n            \"file\",\n            tr(\"Move / rename...\"),\n            self._cmd_move_rename_file,\n            tester=self._cmd_move_rename_file_enabled,\n            group=10,\n        )\n\n        get_workbench().createcommand(\"::tk::mac::OpenDocument\", self._mac_open_document)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Initializes and registers file-related commands and keybindings in the EditorNotebook's workbench, enabling actions like new, open, save, close, and rename files with associated shortcuts and UI integration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "load_startup_files", "line_number": 666, "body": "def load_startup_files(self):\n        \"\"\"If no filename was sent from command line\n        then load previous files (if setting allows)\"\"\"\n\n        cmd_line_filenames = [\n            os.path.abspath(name) for name in sys.argv[1:] if os.path.exists(name)\n        ]\n\n        if len(cmd_line_filenames) > 0:\n            filenames = cmd_line_filenames\n        elif get_workbench().get_option(\"file.reopen_all_files\"):\n            filenames = get_workbench().get_option(\"file.open_files\")\n        elif get_workbench().get_option(\"file.current_file\"):\n            filenames = [get_workbench().get_option(\"file.current_file\")]\n        else:\n            filenames = []\n\n        if len(filenames) > 0:\n            for filename in filenames:\n                if os.path.exists(filename):\n                    self.show_file(filename)\n\n            cur_file = get_workbench().get_option(\"file.current_file\")\n            # choose correct active file\n            if len(cmd_line_filenames) > 0:\n                self.show_file(cmd_line_filenames[0])\n            elif cur_file and os.path.exists(cur_file):\n                self.show_file(cur_file)\n            else:\n                self._cmd_new_file()\n        else:\n            self._cmd_new_file()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Loads startup files based on command-line inputs or user settings, opening recent or specified files in the editor notebook to restore the previous session or start a new file if none exist."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "save_all_named_editors", "line_number": 699, "body": "def save_all_named_editors(self):\n        all_saved = True\n        for editor in self.winfo_children():\n            if editor.get_filename() and editor.is_modified():\n                success = editor.save_file()\n                all_saved = all_saved and success\n\n        return all_saved", "is_method": true, "class_name": "EditorNotebook", "function_description": "Method of the EditorNotebook class that saves all modified editors with associated filenames, returning whether all save operations succeeded. It is useful for bulk saving changes in a multi-editor environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "remember_recent_file", "line_number": 708, "body": "def remember_recent_file(self, filename):\n        recents = get_workbench().get_option(\"file.recent_files\")\n        if filename in recents:\n            recents.remove(filename)\n        recents.insert(0, filename)\n        relevant_recents = [name for name in recents if os.path.exists(name)][:15]\n        get_workbench().set_option(\"file.recent_files\", relevant_recents)\n        self._update_recent_menu()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Method of EditorNotebook that updates the list of recently accessed files by moving a given filename to the top, ensuring only existing files are kept, and maintains the recent files menu accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_update_recent_menu", "line_number": 717, "body": "def _update_recent_menu(self):\n        recents = get_workbench().get_option(\"file.recent_files\")\n        relevant_recents = [\n            path for path in recents if os.path.exists(path) and not self.file_is_opened(path)\n        ]\n        self._recent_menu.delete(0, \"end\")\n        for path in relevant_recents:\n\n            def load(path=path):\n                self.show_file(path)\n\n            self._recent_menu.insert_command(\"end\", label=path, command=load)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Updates the recent files menu by listing only existing files that are not currently open, allowing users to quickly reopen recent, relevant files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "remember_open_files", "line_number": 730, "body": "def remember_open_files(self):\n        if (\n            self.get_current_editor() is not None\n            and self.get_current_editor().get_filename() is not None\n        ):\n            current_file = self.get_current_editor().get_filename()\n        else:\n            current_file = None\n\n        get_workbench().set_option(\"file.current_file\", current_file)\n\n        open_files = [\n            editor.get_filename() for editor in self.winfo_children() if editor.get_filename()\n        ]\n        get_workbench().set_option(\"file.open_files\", open_files)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Stores the currently active file and all open files within the editor notebook to persistent settings, enabling the application to remember and restore the user's workspace state across sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_new_file", "line_number": 746, "body": "def _cmd_new_file(self):\n        new_editor = Editor(self)\n        get_workbench().event_generate(\"NewFile\", editor=new_editor)\n        self.add(new_editor, text=new_editor.get_title())\n        self.select(new_editor)\n        new_editor.focus_set()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Creates a new editor instance as a file tab, triggers a \"NewFile\" event, adds it to the notebook, selects it, and sets focus for immediate editing. This enables quick creation and editing of new files within the EditorNotebook."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_open_file", "line_number": 753, "body": "def _cmd_open_file(self):\n        node = choose_node_for_file_operations(self.winfo_toplevel(), \"Where to open from?\")\n        if not node:\n            return\n\n        if node == \"local\":\n            initialdir = get_workbench().get_local_cwd()\n            if (\n                self.get_current_editor() is not None\n                and self.get_current_editor().get_filename() is not None\n            ):\n                initialdir = os.path.dirname(self.get_current_editor().get_filename())\n            path = askopenfilename(\n                filetypes=_dialog_filetypes, initialdir=initialdir, parent=get_workbench()\n            )\n        else:\n            assert node == \"remote\"\n            target_path = ask_backend_path(self.winfo_toplevel(), \"open\")\n            if not target_path:\n                return\n\n            path = make_remote_path(target_path)\n\n        if path:\n            # self.close_single_untitled_unmodified_editor()\n            self.show_file(path, propose_dialog=False)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Handles user interaction to select and open a file either from a local directory or a remote backend, then displays it in the editor. It supports flexible file sourcing based on the user's choice."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_control_o", "line_number": 780, "body": "def _control_o(self, event):\n        # http://stackoverflow.com/questions/22907200/remap-default-keybinding-in-tkinter\n        self._cmd_open_file()\n        return \"break\"", "is_method": true, "class_name": "EditorNotebook", "function_description": "Handles the \"Control+O\" keyboard shortcut by triggering the file open command within the EditorNotebook, facilitating quick access to open files through a keybinding."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_close_files", "line_number": 785, "body": "def _close_files(self, except_index=None):\n\n        for tab_index in reversed(range(len(self.winfo_children()))):\n            if except_index is not None and tab_index == except_index:\n                continue\n            else:\n                editor = self.get_child_by_index(tab_index)\n                if self.check_allow_closing(editor):\n                    self.forget(editor)\n                    editor.destroy()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Utility method in EditorNotebook that closes all open editor tabs except a specified one, ensuring each tab can be safely closed before removal."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_close_file", "line_number": 796, "body": "def _cmd_close_file(self):\n        self.close_tab(self.index(self.select()))", "is_method": true, "class_name": "EditorNotebook", "function_description": "Private method of the EditorNotebook class that closes the currently selected file tab in the editor interface. It facilitates tab management by automating the close operation for the active document."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "close_tab", "line_number": 799, "body": "def close_tab(self, index):\n        editor = self.get_child_by_index(index)\n\n        if editor:\n            self.close_editor(editor)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Closes the editor tab at the specified index within the notebook, facilitating tab management and resource cleanup in a multi-document editing environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "close_editor", "line_number": 805, "body": "def close_editor(self, editor, force=False):\n        if not force and not self.check_allow_closing(editor):\n            return\n        self.forget(editor)\n        editor.destroy()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Method of EditorNotebook that closes a given editor instance, optionally forcing closure by bypassing checks to ensure safe editor termination and resource cleanup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_file", "line_number": 811, "body": "def _cmd_save_file(self):\n        if self.get_current_editor():\n            self.get_current_editor().save_file()\n            self.update_editor_title(self.get_current_editor())", "is_method": true, "class_name": "EditorNotebook", "function_description": "This internal method saves the current editor's file and updates the editor's title accordingly. It ensures any changes are persisted and the interface reflects the saved state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_file_enabled", "line_number": 816, "body": "def _cmd_save_file_enabled(self):\n        return self.get_current_editor() and self.get_current_editor().save_file_enabled()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Checks if the currently active editor allows saving files. This function helps determine whether the save file action should be enabled in the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_all_files", "line_number": 819, "body": "def _cmd_save_all_files(self):\n        for editor in self.get_all_editors():\n            if editor.save_file_enabled() == True:\n                editor.save_file()\n                self.update_editor_title(editor)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Hidden utility method in EditorNotebook that saves all files for editors with saving enabled and updates their titles accordingly, streamlining batch file persistence within the notebook."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_all_files_enabled", "line_number": 825, "body": "def _cmd_save_all_files_enabled(self):\n        for editor in self.get_all_editors():\n            if editor.save_file_enabled() == True:\n                return True\n        return False", "is_method": true, "class_name": "EditorNotebook", "function_description": "Checks if any open editor currently allows saving its file, indicating whether the \"save all files\" command should be enabled in the EditorNotebook context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_file_as", "line_number": 831, "body": "def _cmd_save_file_as(self, node=None):\n        if not self.get_current_editor():\n            return\n\n        self.get_current_editor().save_file(ask_filename=True, node=node)\n        self.update_editor_title(self.get_current_editor())\n        get_workbench().update_title()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Internal method of EditorNotebook that prompts saving the current editor's file under a new name and updates the editor and application titles accordingly. It facilitates \"Save As\" functionality for file management in the editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_copy", "line_number": 839, "body": "def _cmd_save_copy(self):\n        if not self.get_current_editor():\n            return\n\n        self.get_current_editor().save_file(ask_filename=True, save_copy=True)\n        self.update_editor_title(self.get_current_editor())", "is_method": true, "class_name": "EditorNotebook", "function_description": "Utility method of EditorNotebook that saves a copy of the current editor's file by prompting for a filename and updates the editor title accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_file_as_enabled", "line_number": 846, "body": "def _cmd_save_file_as_enabled(self):\n        return self.get_current_editor() is not None", "is_method": true, "class_name": "EditorNotebook", "function_description": "Utility method in EditorNotebook that indicates whether the \"Save As\" command is available, based on whether an editor is currently active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_move_rename_file", "line_number": 849, "body": "def _cmd_move_rename_file(self):\n        editor = self.get_current_editor()\n        old_filename = editor.get_filename()\n        assert old_filename is not None\n\n        if is_remote_path(old_filename):\n            node = \"remote\"\n        else:\n            node = \"local\"\n\n        self._cmd_save_file_as(node=node)\n\n        if editor.get_filename() != old_filename:\n            if is_remote_path(old_filename):\n                remote_path = extract_target_path(old_filename)\n                get_runner().send_command_and_wait(\n                    InlineCommand(\n                        \"delete\", paths=[remote_path], description=tr(\"Deleting\" + remote_path)\n                    ),\n                    dialog_title=tr(\"Deleting\"),\n                )\n                get_workbench().event_generate(\n                    \"RemoteFileOperation\", path=remote_path, operation=\"delete\"\n                )\n            else:\n                os.remove(old_filename)\n                get_workbench().event_generate(\n                    \"LocalFileOperation\", path=old_filename, operation=\"delete\"\n                )", "is_method": true, "class_name": "EditorNotebook", "function_description": "Utility method in EditorNotebook that renames or moves the current file by saving it as a new file, then deletes the original file, handling both local and remote file paths appropriately."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_move_rename_file_enabled", "line_number": 879, "body": "def _cmd_move_rename_file_enabled(self):\n        return self.get_current_editor() and self.get_current_editor().get_filename() is not None", "is_method": true, "class_name": "EditorNotebook", "function_description": "Checks if the current editor has a valid filename, indicating whether move or rename file commands are applicable. This helps enable file operations only when a file is actively open and identified."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "close_single_untitled_unmodified_editor", "line_number": 882, "body": "def close_single_untitled_unmodified_editor(self):\n        editors = self.winfo_children()\n        if len(editors) == 1 and not editors[0].is_modified() and not editors[0].get_filename():\n            self._cmd_close_file()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Method of EditorNotebook that closes the editor if only one untitled and unmodified file is open, helping to manage and clean up empty editing sessions automatically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_mac_open_document", "line_number": 887, "body": "def _mac_open_document(self, *args):\n        for arg in args:\n            if isinstance(arg, str) and os.path.exists(arg):\n                self.show_file(arg)\n        get_workbench().become_active_window()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Utility method in EditorNotebook that opens existing files on macOS by displaying each valid filepath and ensures the editor window becomes active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_current_editor", "line_number": 893, "body": "def get_current_editor(self):\n        return self.get_current_child()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Returns the currently active editor instance within the notebook, allowing other components to access or interact with the active editor's content or state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_current_editor_content", "line_number": 896, "body": "def get_current_editor_content(self):\n        editor = self.get_current_editor()\n        if editor is None:\n            return None\n        else:\n            return editor.get_code_view().get_content()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Returns the current content from the active editor within the notebook. Useful for accessing the latest code being edited for processing or display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_all_editors", "line_number": 903, "body": "def get_all_editors(self):\n        # When workspace is closing, self.winfo_children()\n        # may return an unexplainable tkinter.Frame\n        return [child for child in self.winfo_children() if isinstance(child, Editor)]", "is_method": true, "class_name": "EditorNotebook", "function_description": "Returns a list of all Editor instances contained within the notebook, facilitating access to editable documents or code sections managed by the EditorNotebook."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "select_next_prev_editor", "line_number": 908, "body": "def select_next_prev_editor(self, direction):\n        cur_index = self.index(self.select())\n        next_index = (cur_index + direction) % len(self.tabs())\n        self.select(self.get_child_by_index(next_index))", "is_method": true, "class_name": "EditorNotebook", "function_description": "Method of the EditorNotebook class that changes the current editor selection to the next or previous tab, enabling navigation through multiple open editor tabs in a cyclical manner."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "file_is_opened", "line_number": 913, "body": "def file_is_opened(self, path):\n        for editor in self.get_all_editors():\n            if editor.get_filename() and is_same_path(path, editor.get_filename()):\n                return True\n\n        return False", "is_method": true, "class_name": "EditorNotebook", "function_description": "Checks if a file at a specified path is currently opened in any editor within the notebook. This method helps avoid duplicate openings or manage file states across multiple editors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "show_file", "line_number": 920, "body": "def show_file(self, filename, text_range=None, set_focus=True, propose_dialog=True):\n        # self.close_single_untitled_unmodified_editor()\n        try:\n            editor = self.get_editor(filename, True)\n        except PermissionError:\n            logger.exception(\"Loading \" + filename)\n            msg = \"Got permission error when trying to load\\n\" + filename\n            if running_on_mac_os() and propose_dialog:\n                msg += \"\\n\\nTry opening it with File => Open.\"\n\n            messagebox.showerror(\"Permission error\", msg, master=self)\n            return None\n\n        if editor is None:\n            return\n\n        self.select(editor)\n        if set_focus:\n            editor.focus_set()\n\n        if text_range is not None:\n            editor.select_range(text_range)\n\n        return editor", "is_method": true, "class_name": "EditorNotebook", "function_description": "Service method of the EditorNotebook class that opens and displays a file in an editor, optionally setting focus and selecting a text range, while handling permission errors gracefully with user notifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "show_remote_file", "line_number": 945, "body": "def show_remote_file(self, target_filename):\n        if not get_runner().ready_for_remote_file_operations(show_message=True):\n            return None\n        else:\n            return self.show_file(make_remote_path(target_filename))", "is_method": true, "class_name": "EditorNotebook", "function_description": "This method checks remote operation readiness and displays the specified file from a remote location, enabling seamless access to remote files within the EditorNotebook environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "show_file_at_line", "line_number": 951, "body": "def show_file_at_line(self, filename, lineno, col_offset=None):\n        editor = self.show_file(filename)\n        editor.select_line(lineno, col_offset)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Utility method of EditorNotebook that opens a file and highlights a specific line and optional column, facilitating quick navigation to precise code locations within the editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "update_appearance", "line_number": 955, "body": "def update_appearance(self):\n        for editor in self.winfo_children():\n            editor.update_appearance()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Updates the visual appearance of all child editor components within the EditorNotebook, ensuring consistent and current styling across the notebook interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "update_editor_title", "line_number": 959, "body": "def update_editor_title(self, editor, title=None):\n        if title is None:\n            title = editor.get_title()\n        try:\n            self.tab(editor, text=title)\n        except TclError:\n            pass\n\n        try:\n            self.indicate_modification()\n        except Exception:\n            logging.exception(\"Could not update modification indication\")", "is_method": true, "class_name": "EditorNotebook", "function_description": "Utility method in EditorNotebook that updates the editor tab title and signals document modification, ensuring the UI reflects current document status while gracefully handling update errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "indicate_modification", "line_number": 972, "body": "def indicate_modification(self):\n        if not running_on_mac_os():\n            return\n\n        atts = self.winfo_toplevel().wm_attributes()\n        if \"-modified\" in atts:\n            i = atts.index(\"-modified\")\n            mod = atts[i : i + 2]\n            rest = atts[:i] + atts[i + 2 :]\n        else:\n            mod = ()\n            rest = atts\n\n        for editor in self.get_all_editors():\n            if editor.is_modified():\n                if mod != (\"-modified\", 1):\n                    self.winfo_toplevel().wm_attributes(*(rest + (\"-modified\", 1)))\n                break\n        else:\n            if mod == (\"-modified\", 1):\n                self.winfo_toplevel().wm_attributes(*(rest + (\"-modified\", 0)))", "is_method": true, "class_name": "EditorNotebook", "function_description": "Method of EditorNotebook that updates the window's modified state on macOS to reflect whether any contained editor has unsaved changes, helping to visually indicate document modification status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_open_file", "line_number": 994, "body": "def _open_file(self, filename):\n        editor = Editor(self)\n        if editor._load_file(filename):\n            self.add(editor, text=editor.get_title())\n            return editor\n        else:\n            editor.destroy()\n            return None", "is_method": true, "class_name": "EditorNotebook", "function_description": "Utility method in EditorNotebook that attempts to open a file in a new editor tab, adding it to the interface if successful, or cleaning up if the file fails to load."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_editor", "line_number": 1003, "body": "def get_editor(self, filename, open_when_necessary=False):\n        if not is_remote_path(filename) and os.path.isfile(filename):\n            filename = normpath_with_actual_case(os.path.abspath(filename))\n        for child in self.winfo_children():\n            child_filename = child.get_filename(False)\n            if child_filename == filename:\n                return child\n\n        if open_when_necessary:\n            return self._open_file(filename)\n        else:\n            return None", "is_method": true, "class_name": "EditorNotebook", "function_description": "Provides a way to retrieve an open editor instance by filename within the EditorNotebook, optionally opening the file if it is not already open. This supports managing and accessing multiple open files efficiently."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "check_allow_closing", "line_number": 1016, "body": "def check_allow_closing(self, editor=None):\n        if not editor:\n            modified_editors = [e for e in self.winfo_children() if e.is_modified()]\n        else:\n            if not editor.is_modified():\n                return True\n            else:\n                modified_editors = [editor]\n        if len(modified_editors) == 0:\n            return True\n\n        message = tr(\"Do you want to save files before closing?\")\n        if editor:\n            message = tr(\"Do you want to save file before closing?\")\n\n        confirm = messagebox.askyesnocancel(\n            title=tr(\"Save On Close\"), message=message, default=messagebox.YES, master=self\n        )\n\n        if confirm:\n            for editor_ in modified_editors:\n                if editor_.get_filename(True):\n                    editor_.save_file()\n                else:\n                    return False\n            return True\n\n        elif confirm is None:\n            return False\n        else:\n            return True", "is_method": true, "class_name": "EditorNotebook", "function_description": "Utility method of EditorNotebook that checks if modified editors should be saved before closing, prompting the user to confirm saving unsaved changes to prevent data loss during editor or application closure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "on_focus_window", "line_number": 1048, "body": "def on_focus_window(self, event=None):\n        for editor in self.get_all_editors():\n            editor.check_for_external_changes()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Triggers a check for external changes in all editors when the window gains focus, ensuring the displayed content stays up to date with any outside modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "ask_string", "line_number": 133, "body": "def ask_string(\n    title: str,\n    prompt: str,\n    initial_value: str = \"\",\n    options: List[str] = [],\n    entry_width: Optional[int] = None,\n    master=None,\n):\n    dlg = QueryDialog(\n        master, title, prompt, initial_value=initial_value, options=options, entry_width=entry_width\n    )\n    show_dialog(dlg, master)\n    return dlg.get_result()", "is_method": false, "function_description": "Function that displays a customizable input dialog for the user to enter or select a string value, then returns the user's input. Useful for gathering user responses through a GUI prompt with optional preset choices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "scrollbar_style", "line_number": 742, "body": "def scrollbar_style(orientation):\n    # In mac ttk.Scrollbar uses native rendering unless style attribute is set\n    # see http://wiki.tcl.tk/44444#pagetoc50f90d9a\n    # Native rendering doesn't look good in dark themes\n    if running_on_mac_os() and get_workbench().uses_dark_ui_theme():\n        return orientation + \".TScrollbar\"\n    else:\n        return None", "is_method": false, "function_description": "Determines and returns a custom scrollbar style for macOS when a dark UI theme is active, enhancing visual consistency in themed interfaces. Returns None for other platforms or themes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "sequence_to_accelerator", "line_number": 752, "body": "def sequence_to_accelerator(sequence):\n    \"\"\"Translates Tk event sequence to customary shortcut string\n    for showing in the menu\"\"\"\n\n    if not sequence:\n        return \"\"\n\n    if not sequence.startswith(\"<\"):\n        return sequence\n\n    accelerator = (\n        sequence.strip(\"<>\").replace(\"Key-\", \"\").replace(\"KeyPress-\", \"\").replace(\"Control\", \"Ctrl\")\n    )\n\n    # Tweaking individual parts\n    parts = accelerator.split(\"-\")\n    # tkinter shows shift with capital letter, but in shortcuts it's customary to include it explicitly\n    if len(parts[-1]) == 1 and parts[-1].isupper() and not \"Shift\" in parts:\n        parts.insert(-1, \"Shift\")\n\n    # even when shift is not required, it's customary to show shortcut with capital letter\n    if len(parts[-1]) == 1:\n        parts[-1] = parts[-1].upper()\n\n    accelerator = \"+\".join(parts)\n\n    # Post processing\n    accelerator = (\n        accelerator.replace(\"Minus\", \"-\")\n        .replace(\"minus\", \"-\")\n        .replace(\"Plus\", \"+\")\n        .replace(\"plus\", \"+\")\n    )\n\n    return accelerator", "is_method": false, "function_description": "Converts a Tkinter event sequence string into a user-friendly keyboard shortcut format for display in menus, standardizing modifier keys and key names for clarity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_zoomed", "line_number": 789, "body": "def get_zoomed(toplevel):\n    if \"-zoomed\" in toplevel.wm_attributes():  # Linux\n        return bool(toplevel.wm_attributes(\"-zoomed\"))\n    else:  # Win/Mac\n        return toplevel.wm_state() == \"zoomed\"", "is_method": false, "function_description": "Function that determines whether a given top-level window is currently maximized (zoomed), supporting both Linux and Windows/Mac platforms. It provides a cross-platform way to check window zoom state for GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "set_zoomed", "line_number": 796, "body": "def set_zoomed(toplevel, value):\n    if \"-zoomed\" in toplevel.wm_attributes():  # Linux\n        toplevel.wm_attributes(\"-zoomed\", str(int(value)))\n    else:  # Win/Mac\n        if value:\n            toplevel.wm_state(\"zoomed\")\n        else:\n            toplevel.wm_state(\"normal\")", "is_method": false, "function_description": "Sets the zoom (maximized) state of a window, handling platform differences between Linux, Windows, and Mac systems. Useful for controlling window appearance in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "update_entry_text", "line_number": 947, "body": "def update_entry_text(entry, text):\n    original_state = entry.cget(\"state\")\n    entry.config(state=\"normal\")\n    entry.delete(0, \"end\")\n    entry.insert(0, text)\n    entry.config(state=original_state)", "is_method": false, "function_description": "Function that updates the displayed text of a GUI entry widget while preserving its original state (enabled or disabled). Useful for safely modifying user interface input fields programmatically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_tooltip", "line_number": 1130, "body": "def create_tooltip(widget, text, **kw):\n    options = get_style_configuration(\"Tooltip\").copy()\n    options.setdefault(\"background\", \"#ffffe0\")\n    options.setdefault(\"foreground\", \"#000000\")\n    options.setdefault(\"relief\", \"solid\")\n    options.setdefault(\"borderwidth\", 1)\n    options.setdefault(\"padx\", 1)\n    options.setdefault(\"pady\", 0)\n    options.update(kw)\n\n    toolTip = ToolTip(widget, options)\n\n    def enter(event):\n        toolTip.showtip(text)\n\n    def leave(event):\n        toolTip.hidetip()\n\n    widget.bind(\"<Enter>\", enter)\n    widget.bind(\"<Leave>\", leave)", "is_method": false, "function_description": "Function that attaches a customizable tooltip displaying specified text when the user hovers over a given widget, enhancing UI interactivity by providing contextual information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_widget_offset_from_toplevel", "line_number": 1314, "body": "def get_widget_offset_from_toplevel(widget):\n    x = 0\n    y = 0\n    toplevel = widget.winfo_toplevel()\n    while widget != toplevel:\n        x += widget.winfo_x()\n        y += widget.winfo_y()\n        widget = widget.master\n    return x, y", "is_method": false, "function_description": "Calculates the (x, y) position of a widget relative to its top-level container, aiding layout management and coordinate-based widget positioning within graphical user interfaces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_string_var", "line_number": 1366, "body": "def create_string_var(value, modification_listener=None) -> EnhancedStringVar:\n    \"\"\"Creates a tk.StringVar with \"modified\" attribute\n    showing whether the variable has been modified after creation\"\"\"\n    return EnhancedStringVar(None, value, None, modification_listener)", "is_method": false, "function_description": "Utility function that creates a Tkinter StringVar instance augmented with a modification flag, tracking whether its value has been changed after creation. It supports optional callbacks to respond to such modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_int_var", "line_number": 1372, "body": "def create_int_var(value, modification_listener=None) -> EnhancedIntVar:\n    \"\"\"See create_string_var\"\"\"\n    return EnhancedIntVar(None, value, None, modification_listener)", "is_method": false, "function_description": "Utility function that creates an EnhancedIntVar object initialized with a given value and an optional modification listener to track changes, facilitating reactive integer variable management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_double_var", "line_number": 1377, "body": "def create_double_var(value, modification_listener=None) -> EnhancedDoubleVar:\n    \"\"\"See create_string_var\"\"\"\n    return EnhancedDoubleVar(None, value, None, modification_listener)", "is_method": false, "function_description": "Creates an EnhancedDoubleVar instance initialized with a given value and an optional modification listener, facilitating reactive data binding for numeric values."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_boolean_var", "line_number": 1382, "body": "def create_boolean_var(value, modification_listener=None) -> EnhancedBooleanVar:\n    \"\"\"See create_string_var\"\"\"\n    return EnhancedBooleanVar(None, value, None, modification_listener)", "is_method": false, "function_description": "Utility function that creates an EnhancedBooleanVar initialized with a specified value and optional modification listener, facilitating reactive Boolean state management in GUI or stateful applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "shift_is_pressed", "line_number": 1387, "body": "def shift_is_pressed(event_state):\n    # http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/event-handlers.html\n    # http://stackoverflow.com/q/32426250/261181\n    return event_state & 0x0001", "is_method": false, "function_description": "Utility function that checks if the Shift key was pressed during a given event, enabling conditional handling of keyboard input in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "caps_lock_is_on", "line_number": 1393, "body": "def caps_lock_is_on(event_state):\n    # http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/event-handlers.html\n    # http://stackoverflow.com/q/32426250/261181\n    return event_state & 0x0002", "is_method": false, "function_description": "Function that checks if the Caps Lock key is active based on a given keyboard event state bitmask, useful for input handling or UI feedback related to keyboard state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "control_is_pressed", "line_number": 1399, "body": "def control_is_pressed(event_state):\n    # http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/event-handlers.html\n    # http://stackoverflow.com/q/32426250/261181\n    return event_state & 0x0004", "is_method": false, "function_description": "Function that checks if the Control key was pressed during an event, enabling conditional handling of keyboard input in event-driven applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "sequence_to_event_state_and_keycode", "line_number": 1405, "body": "def sequence_to_event_state_and_keycode(sequence: str) -> Optional[Tuple[int, int]]:\n    # remember handlers for certain shortcuts which require\n    # different treatment on non-latin keyboards\n    if sequence[0] != \"<\":\n        return None\n\n    parts = sequence.strip(\"<\").strip(\">\").split(\"-\")\n    # support only latin letters for now\n    if parts[-1].lower() not in list(\"abcdefghijklmnopqrstuvwxyz\"):\n        return None\n\n    letter = parts.pop(-1)\n    if \"Key\" in parts:\n        parts.remove(\"Key\")\n    if \"key\" in parts:\n        parts.remove(\"key\")\n\n    modifiers = {part.lower() for part in parts}\n\n    if letter.isupper():\n        modifiers.add(\"shift\")\n\n    if modifiers not in [{\"control\"}, {\"control\", \"shift\"}]:\n        # don't support others for now\n        return None\n\n    event_state = 0\n    # http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/event-handlers.html\n    # https://stackoverflow.com/questions/32426250/python-documentation-and-or-lack-thereof-e-g-keyboard-event-state\n    for modifier in modifiers:\n        if modifier == \"shift\":\n            event_state |= 0x0001\n        elif modifier == \"control\":\n            event_state |= 0x0004\n        else:\n            # unsupported modifier\n            return None\n\n    # for latin letters keycode is same as its ascii code\n    return (event_state, ord(letter.upper()))", "is_method": false, "function_description": "Parses a keyboard shortcut sequence string to extract the modifier key state and ASCII keycode for supported Latin-letter shortcuts with Control and Shift modifiers. Returns event state and keycode tuple or None if the sequence is unsupported."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "select_sequence", "line_number": 1447, "body": "def select_sequence(win_version, mac_version, linux_version=None):\n    if running_on_windows():\n        return win_version\n    elif running_on_mac_os():\n        return mac_version\n    elif running_on_linux() and linux_version:\n        return linux_version\n    else:\n        return win_version", "is_method": false, "function_description": "Function that selects and returns a version of a sequence based on the operating system, allowing customizable behavior for Windows, macOS, and optionally Linux environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "try_remove_linenumbers", "line_number": 1458, "body": "def try_remove_linenumbers(text, master):\n    try:\n        if has_line_numbers(text) and messagebox.askyesno(\n            title=\"Remove linenumbers\",\n            message=\"Do you want to remove linenumbers from pasted text?\",\n            default=messagebox.YES,\n            master=master,\n        ):\n            return remove_line_numbers(text)\n        else:\n            return text\n    except Exception:\n        traceback.print_exc()\n        return text", "is_method": false, "function_description": "Function that optionally removes line numbers from text after user confirmation via a prompt, providing a way to clean pasted text while preserving original content if declined or on error."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "has_line_numbers", "line_number": 1474, "body": "def has_line_numbers(text):\n    lines = text.splitlines()\n    return len(lines) > 2 and all([len(split_after_line_number(line)) == 2 for line in lines])", "is_method": false, "function_description": "Function that checks if a multiline text appears to have line numbers by verifying each line starts with a numbered prefix before the main content. Useful for detecting numbered code or list formatting in text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "split_after_line_number", "line_number": 1479, "body": "def split_after_line_number(s):\n    parts = re.split(r\"(^\\s*\\d+\\.?)\", s)\n    if len(parts) == 1:\n        return parts\n    else:\n        assert len(parts) == 3 and parts[0] == \"\"\n        return parts[1:]", "is_method": false, "function_description": "Function that splits a string at the position immediately following the first leading line number, returning the line number and the remaining text separately for use in parsing or processing numbered lines."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "remove_line_numbers", "line_number": 1488, "body": "def remove_line_numbers(s):\n    cleaned_lines = []\n    for line in s.splitlines():\n        parts = split_after_line_number(line)\n        if len(parts) != 2:\n            return s\n        else:\n            cleaned_lines.append(parts[1])\n\n    return textwrap.dedent((\"\\n\".join(cleaned_lines)) + \"\\n\")", "is_method": false, "function_description": "Function that removes line numbers from each line in a given string, returning the cleaned text without numbering. Useful for processing code snippets or text with prefixed line numbers for easier readability or analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "center_window", "line_number": 1500, "body": "def center_window(win, master=None):\n    # for backward compat\n    return assign_geometry(win, master)", "is_method": false, "function_description": "Utility function that centers a window on its master window, maintaining backward compatibility by delegating to geometry assignment functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "assign_geometry", "line_number": 1505, "body": "def assign_geometry(win, master=None, min_left=0, min_top=0):\n    if master is None:\n        master = tk._default_root\n\n    size = get_workbench().get_option(get_size_option_name(win))\n    if size:\n        width, height = size\n        saved_size = True\n    else:\n        fallback_width = 600\n        fallback_height = 400\n        # need to wait until size is computed\n        # (unfortunately this causes dialog to jump)\n        if getattr(master, \"initializing\", False):\n            # can't get reliable positions when main window is not in mainloop yet\n            width = fallback_width\n            height = fallback_height\n        else:\n            if not running_on_linux():\n                # better to avoid in Linux because it causes ugly jump\n                win.update_idletasks()\n            # looks like it doesn't take window border into account\n            width = win.winfo_width()\n            height = win.winfo_height()\n\n            if width < 10:\n                # ie. size measurement is not correct\n                width = fallback_width\n                height = fallback_height\n\n        saved_size = False\n\n    left = master.winfo_rootx() + master.winfo_width() // 2 - width // 2\n    top = master.winfo_rooty() + master.winfo_height() // 2 - height // 2\n\n    left = max(left, min_left)\n    top = max(top, min_top)\n\n    if saved_size:\n        win.geometry(\"%dx%d+%d+%d\" % (width, height, left, top))\n    else:\n        win.geometry(\"+%d+%d\" % (left, top))", "is_method": false, "function_description": "Sets the window's size and position, centering it within a master window or screen with optional minimum coordinates. It ensures consistent geometry using saved or fallback sizes, useful for managing GUI window layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "run_with_waiting_dialog", "line_number": 1580, "body": "def run_with_waiting_dialog(master, action, args=(), description=\"Working\"):\n    # http://stackoverflow.com/a/14299004/261181\n    from multiprocessing.pool import ThreadPool\n\n    pool = ThreadPool(processes=1)\n\n    async_result = pool.apply_async(action, args)\n    dlg = WaitingDialog(master, async_result, description=description)\n    show_dialog(dlg, master)\n\n    return async_result.get()", "is_method": false, "function_description": "Utility function that runs a given action asynchronously while displaying a waiting dialog to indicate progress, blocking until the action completes and returning its result."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "ask_one_from_choices", "line_number": 1779, "body": "def ask_one_from_choices(\n    master=None,\n    title=\"Choose one\",\n    question: str = \"Choose one:\",\n    choices=[],\n    initial_choice_index=None,\n):\n    dlg = ChoiceDialog(master, title, question, choices, initial_choice_index)\n    show_dialog(dlg, master)\n    return dlg.result", "is_method": false, "function_description": "Function creates and displays a dialog prompting the user to select one option from a list, then returns the selected choice. It serves as an interactive utility for obtaining user input from predefined choices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_busy_cursor", "line_number": 1791, "body": "def get_busy_cursor():\n    if running_on_windows():\n        return \"wait\"\n    elif running_on_mac_os():\n        return \"spinning\"\n    else:\n        return \"watch\"", "is_method": false, "function_description": "Function that returns the appropriate busy cursor style string based on the operating system, facilitating consistent UI feedback during processing across platforms."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_tk_version_str", "line_number": 1800, "body": "def get_tk_version_str():\n    return tk._default_root.tk.call(\"info\", \"patchlevel\")", "is_method": false, "function_description": "Returns the version string of the Tkinter Tk library currently in use. Useful for verifying or displaying the underlying GUI toolkit version."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_tk_version_info", "line_number": 1804, "body": "def get_tk_version_info():\n    result = []\n    for part in get_tk_version_str().split(\".\"):\n        try:\n            result.append(int(part))\n        except Exception:\n            result.append(0)\n    return tuple(result)", "is_method": false, "function_description": "Returns the version information of the Tk library as a tuple of integers, enabling other functions to easily compare or check Tk version details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_style_configuration", "line_number": 1814, "body": "def get_style_configuration(style_name, default={}):\n    style = ttk.Style()\n    # NB! style.configure seems to reuse the returned dict\n    # Don't change it without copying first\n    result = style.configure(style_name)\n    if result is None:\n        return default\n    else:\n        return result", "is_method": false, "function_description": "Returns the configuration dictionary for a given style name in the ttk module, providing default values if the style is not found. Useful for retrieving GUI style settings for customization or inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "lookup_style_option", "line_number": 1825, "body": "def lookup_style_option(style_name, option_name, default=None):\n    style = ttk.Style()\n    setting = style.lookup(style_name, option_name)\n    if setting in [None, \"\"]:\n        return default\n    elif setting == \"True\":\n        return True\n    elif setting == \"False\":\n        return False\n    else:\n        return setting", "is_method": false, "function_description": "Function providing a convenient way to retrieve a named style option from a Tkinter ttk style, returning a default if the option is missing and converting boolean-like strings to actual booleans."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "open_path_in_system_file_manager", "line_number": 1842, "body": "def open_path_in_system_file_manager(path):\n    if running_on_mac_os():\n        # http://stackoverflow.com/a/3520693/261181\n        # -R doesn't allow showing hidden folders\n        subprocess.Popen([\"open\", path])\n    elif running_on_linux():\n        subprocess.Popen([\"xdg-open\", path])\n    else:\n        assert running_on_windows()\n        subprocess.Popen([\"explorer\", path])", "is_method": false, "function_description": "Function that opens a given file system path in the default file manager of the current operating system, supporting macOS, Linux, and Windows environments. It enables other functions to trigger native file browser views for user accessibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_get_dialog_provider", "line_number": 1854, "body": "def _get_dialog_provider():\n    if platform.system() != \"Linux\" or get_workbench().get_option(\"file.avoid_zenity\"):\n        return filedialog\n\n    import shutil\n\n    if shutil.which(\"zenity\"):\n        return _ZenityDialogProvider\n\n    # fallback\n    return filedialog", "is_method": false, "function_description": "Utility function that selects and returns an appropriate dialog provider based on the operating system and user settings, preferring a graphical Zenity-based provider on compatible Linux systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "asksaveasfilename", "line_number": 1867, "body": "def asksaveasfilename(**options):\n    # https://tcl.tk/man/tcl8.6/TkCmd/getSaveFile.htm\n    _check_dialog_parent(options)\n    return _get_dialog_provider().asksaveasfilename(**options)", "is_method": false, "function_description": "Function that displays a file save dialog and returns the selected filename, allowing customization through various options. It serves as a convenient interface for users to specify file paths in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askopenfilename", "line_number": 1873, "body": "def askopenfilename(**options):\n    # https://tcl.tk/man/tcl8.6/TkCmd/getOpenFile.htm\n    _check_dialog_parent(options)\n    return _get_dialog_provider().askopenfilename(**options)", "is_method": false, "function_description": "Function that opens a file dialog for the user to select a file and returns the chosen file's path, supporting customization through options. It serves as a utility for file selection in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askopenfilenames", "line_number": 1879, "body": "def askopenfilenames(**options):\n    # https://tcl.tk/man/tcl8.6/TkCmd/getOpenFile.htm\n    _check_dialog_parent(options)\n    return _get_dialog_provider().askopenfilenames(**options)", "is_method": false, "function_description": "Function acting as a wrapper to open a file selection dialog allowing multiple file selections, returning the chosen filenames. It simplifies invoking a standard GUI file picker with customizable options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askdirectory", "line_number": 1885, "body": "def askdirectory(**options):\n    # https://tcl.tk/man/tcl8.6/TkCmd/chooseDirectory.htm\n    _check_dialog_parent(options)\n    return _get_dialog_provider().askdirectory(**options)", "is_method": false, "function_description": "Function providing a directory selection dialog, allowing users to choose a filesystem directory through a graphical interface with customizable options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_check_dialog_parent", "line_number": 1891, "body": "def _check_dialog_parent(options):\n    if options.get(\"parent\") and options.get(\"master\"):\n        parent = options[\"parent\"].winfo_toplevel()\n        master = options[\"master\"].winfo_toplevel()\n        if parent is not master:\n            logger.warning(\n                \"Dialog with different parent/master toplevels:\\n%s\",\n                \"\".join(traceback.format_stack()),\n            )\n    elif options.get(\"parent\"):\n        parent = options[\"parent\"].winfo_toplevel()\n        master = options[\"parent\"].winfo_toplevel()\n    elif options.get(\"master\"):\n        parent = options[\"master\"].winfo_toplevel()\n        master = options[\"master\"].winfo_toplevel()\n    else:\n        logger.warning(\"Dialog without parent:\\n%s\", \"\".join(traceback.format_stack()))\n        parent = tk._default_root\n        master = tk._default_root\n\n    options[\"parent\"] = parent\n    options[\"master\"] = master\n\n    if running_on_mac_os():\n        # used to require master/parent (https://bugs.python.org/issue34927)\n        # but this is deprecated in Catalina (https://github.com/thonny/thonny/issues/840)\n        # TODO: Consider removing this when upgrading from Tk 8.6.8\n        del options[\"master\"]\n        del options[\"parent\"]", "is_method": false, "function_description": "Internal utility function that validates and synchronizes 'parent' and 'master' window references in dialog options, ensuring they share the same toplevel window and adjusts settings for macOS compatibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_options_to_zenity_filename", "line_number": 2004, "body": "def _options_to_zenity_filename(options):\n    if options.get(\"initialdir\"):\n        if options.get(\"initialfile\"):\n            return os.path.join(options[\"initialdir\"], options[\"initialfile\"])\n        else:\n            return options[\"initialdir\"] + os.path.sep\n\n    return None", "is_method": false, "function_description": "Converts file dialog options into a valid Zenity filename path by combining initial directory and file name when provided. Useful for configuring file selection dialogs in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "register_latin_shortcut", "line_number": 2014, "body": "def register_latin_shortcut(\n    registry, sequence: str, handler: Callable, tester: Optional[Callable]\n) -> None:\n    res = sequence_to_event_state_and_keycode(sequence)\n    if res is not None:\n        if res not in registry:\n            registry[res] = []\n        registry[res].append((handler, tester))", "is_method": false, "function_description": "Function that registers a handler and optional tester for a specific Latin input shortcut sequence within a registry, enabling customized processing of keyboard input events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "handle_mistreated_latin_shortcuts", "line_number": 2024, "body": "def handle_mistreated_latin_shortcuts(registry, event):\n    # tries to handle Ctrl+LatinLetter shortcuts\n    # given from non-Latin keyboards\n    # See: https://bitbucket.org/plas/thonny/issues/422/edit-keyboard-shortcuts-ctrl-c-ctrl-v-etc\n\n    # only consider events with Control held\n    if not event.state & 0x04:\n        return\n\n    if running_on_mac_os():\n        return\n\n    # consider only part of the state,\n    # because at least on Windows, Ctrl-shortcuts' state\n    # has something extra\n    simplified_state = 0x04\n    if shift_is_pressed(event.state):\n        simplified_state |= 0x01\n\n    # print(simplified_state, event.keycode)\n    if (simplified_state, event.keycode) in registry:\n        if event.keycode != ord(event.char) and event.keysym in (None, \"??\"):\n            # keycode and char doesn't match,\n            # this means non-latin keyboard\n            for handler, tester in registry[(simplified_state, event.keycode)]:\n                if tester is None or tester():\n                    handler()", "is_method": false, "function_description": "Function that intercepts and correctly handles Ctrl+letter keyboard shortcuts from non-Latin keyboards on non-Mac systems, ensuring appropriate shortcut execution despite keyboard layout differences."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "show_dialog", "line_number": 2053, "body": "def show_dialog(dlg, master=None, geometry=True, min_left=0, min_top=0):\n    if getattr(dlg, \"closed\", False):\n        return\n\n    if master is None:\n        master = getattr(dlg, \"parent\", None) or getattr(dlg, \"master\", None) or tk._default_root\n\n    master = master.winfo_toplevel()\n\n    get_workbench().event_generate(\"WindowFocusOut\")\n    # following order seems to give most smooth appearance\n    focused_widget = master.focus_get()\n    dlg.transient(master.winfo_toplevel())\n\n    if geometry:\n        # dlg.withdraw() # unfortunately inhibits size calculations in assign_geometry\n        if isinstance(geometry, str):\n            dlg.geometry(geometry)\n        else:\n            assign_geometry(dlg, master, min_left, min_top)\n        # dlg.wm_deiconify()\n\n    dlg.lift()\n    dlg.focus_set()\n\n    try:\n        dlg.grab_set()\n    except TclError as e:\n        print(\"Can't grab:\", e, file=sys.stderr)\n\n    master.winfo_toplevel().wait_window(dlg)\n    dlg.grab_release()\n    master.winfo_toplevel().lift()\n    master.winfo_toplevel().focus_force()\n    master.winfo_toplevel().grab_set()\n    if running_on_mac_os():\n        master.winfo_toplevel().grab_release()\n\n    if focused_widget is not None:\n        try:\n            focused_widget.focus_force()\n        except TclError:\n            pass", "is_method": false, "function_description": "Utility function that displays a dialog window as a modal transient to a master window, managing focus, geometry, and input grabbing to ensure proper user interaction flow in a GUI application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "popen_with_ui_thread_callback", "line_number": 2098, "body": "def popen_with_ui_thread_callback(*Popen_args, on_completion, poll_delay=0.1, **Popen_kwargs):\n    if \"encoding\" not in Popen_kwargs:\n        if \"env\" not in Popen_kwargs:\n            Popen_kwargs[\"env\"] = os.environ.copy()\n        Popen_kwargs[\"env\"][\"PYTHONIOENCODING\"] = \"utf-8\"\n        if sys.version_info >= (3, 6):\n            Popen_kwargs[\"encoding\"] = \"utf-8\"\n\n    proc = subprocess.Popen(*Popen_args, **Popen_kwargs)\n\n    # Need to read in thread in order to avoid blocking because\n    # of full pipe buffer (see https://bugs.python.org/issue1256)\n    out_lines = []\n    err_lines = []\n\n    def read_stream(stream, target_list):\n        while True:\n            line = stream.readline()\n            if line:\n                target_list.append(line)\n            else:\n                break\n\n    t_out = threading.Thread(target=read_stream, daemon=True, args=(proc.stdout, out_lines))\n    t_err = threading.Thread(target=read_stream, daemon=True, args=(proc.stderr, err_lines))\n    t_out.start()\n    t_err.start()\n\n    def poll():\n        if proc.poll() is not None:\n            t_out.join(3)\n            t_err.join(3)\n            on_completion(proc, out_lines, err_lines)\n            return\n\n        tk._default_root.after(int(poll_delay * 1000), poll)\n\n    poll()\n    return proc", "is_method": false, "function_description": "Function that launches a subprocess and asynchronously reads its output and error streams without blocking, invoking a callback on the UI thread when the process completes. It enables responsive GUI applications to handle subprocess execution and results seamlessly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_url_label", "line_number": 2223, "body": "def create_url_label(master, url, text=None):\n    import webbrowser\n\n    return create_action_label(master, text or url, lambda _: webbrowser.open(url))", "is_method": false, "function_description": "Creates a clickable label widget that opens a specified URL in the web browser when activated, useful for embedding hyperlinks in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_action_label", "line_number": 2229, "body": "def create_action_label(master, text, click_handler, **kw):\n    url_font = tkinter.font.nametofont(\"TkDefaultFont\").copy()\n    url_font.configure(underline=1)\n    url_label = ttk.Label(\n        master, text=text, style=\"Url.TLabel\", cursor=\"hand2\", font=url_font, **kw\n    )\n    url_label.bind(\"<Button-1>\", click_handler)\n    return url_label", "is_method": false, "function_description": "Creates a clickable label widget with underlined text that triggers a specified handler when clicked, useful for implementing interactive links or buttons in a graphical user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_size_option_name", "line_number": 2239, "body": "def get_size_option_name(window):\n    return \"layout.\" + type(window).__name__ + \"_size\"", "is_method": false, "function_description": "This function constructs and returns a string key representing the size option name for a given window object, combining its class name with a preset prefix. It standardizes size option naming for window-related configurations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_default_theme", "line_number": 2243, "body": "def get_default_theme():\n    if running_on_windows():\n        return \"Windows\"\n    elif running_on_rpi():\n        return \"Raspberry Pi\"\n    else:\n        return \"Enhanced Clam\"", "is_method": false, "function_description": "Returns the default theme name based on the detected operating environment, enabling adaptive theming for different platforms such as Windows, Raspberry Pi, or others."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_default_basic_theme", "line_number": 2252, "body": "def get_default_basic_theme():\n    if running_on_windows():\n        return \"xpnative\"\n    else:\n        return \"clam\"", "is_method": false, "function_description": "Returns the default basic theme name based on the operating system, selecting \"xpnative\" for Windows and \"clam\" for others. Useful for setting platform-appropriate UI themes in applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "ems_to_pixels", "line_number": 2262, "body": "def ems_to_pixels(x):\n    global EM_WIDTH\n    if EM_WIDTH is None:\n        EM_WIDTH = tkinter.font.nametofont(\"TkDefaultFont\").measure(\"m\")\n    return int(EM_WIDTH * x)", "is_method": false, "function_description": "Converts a measurement in 'em' units to pixels based on the default font width, enabling consistent sizing in GUI layouts using tkinter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "set_text_if_different", "line_number": 2272, "body": "def set_text_if_different(widget, text) -> bool:\n    if widget[\"text\"] != text:\n        widget[\"text\"] = text\n        return True\n    else:\n        return False", "is_method": false, "function_description": "Utility function that updates a widget's text only if it differs from the current value, preventing unnecessary changes and returning whether an update occurred."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "tr_btn", "line_number": 2280, "body": "def tr_btn(s):\n    \"\"\"Translates button caption, adds padding to make sure text fits\"\"\"\n    global _btn_padding\n    if _btn_padding is None:\n        _btn_padding = get_button_padding()\n\n    return _btn_padding + tr(s) + _btn_padding", "is_method": false, "function_description": "Utility function that translates a button caption and adds padding to ensure the text fits properly within the button layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add_messagebox_parent_checker", "line_number": 2289, "body": "def add_messagebox_parent_checker():\n    def wrap_with_parent_checker(original):\n        def wrapper(*args, **options):\n            _check_dialog_parent(options)\n            return original(*args, **options)\n\n        return wrapper\n\n    from tkinter import messagebox\n\n    for name in [\n        \"showinfo\",\n        \"showwarning\",\n        \"showerror\",\n        \"askquestion\",\n        \"askokcancel\",\n        \"askyesno\",\n        \"askyesnocancel\",\n        \"askretrycancel\",\n    ]:\n        fun = getattr(messagebox, name)\n        setattr(messagebox, name, wrap_with_parent_checker(fun))", "is_method": false, "function_description": "Adds a wrapper to tkinter messagebox functions that ensures dialog parents are checked before showing any messagebox, enhancing dialog window management and preventing orphaned dialogs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_unlock_on_focus_in", "line_number": 44, "body": "def _unlock_on_focus_in(self, event):\n        if not self.winfo_ismapped():\n            focussed_widget = self.focus_get()\n            self.deiconify()\n            if focussed_widget:\n                focussed_widget.focus_set()", "is_method": true, "class_name": "CommonDialog", "function_description": "Handles the dialog's visibility by ensuring it unlocks and becomes visible when focused, restoring focus to the previously active widget if applicable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_padding", "line_number": 51, "body": "def get_padding(self):\n        return ems_to_pixels(2)", "is_method": true, "class_name": "CommonDialog", "function_description": "Returns a fixed padding size in pixels for dialog layout, supporting consistent spacing within the CommonDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_internal_padding", "line_number": 54, "body": "def get_internal_padding(self):\n        return self.get_padding() // 4", "is_method": true, "class_name": "CommonDialog", "function_description": "Utility method in CommonDialog that calculates and returns one-fourth of the dialog's padding value, useful for internal spacing adjustments within the dialog layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_close", "line_number": 71, "body": "def on_close(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "CommonDialogEx", "function_description": "Handles the closing event of the CommonDialogEx instance by destroying the dialog, effectively closing its window and cleaning up resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_ok", "line_number": 121, "body": "def on_ok(self, event=None):\n        self.result = self.var.get()\n        self.destroy()", "is_method": true, "class_name": "QueryDialog", "function_description": "Handles confirmation action by saving the current input value and closing the dialog. Useful for finalizing user input in dialog interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_cancel", "line_number": 125, "body": "def on_cancel(self, event=None):\n        self.result = None\n        self.destroy()", "is_method": true, "class_name": "QueryDialog", "function_description": "Handles the cancellation of a query dialog by clearing the result and closing the dialog window, allowing other components to recognize the cancellation event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_result", "line_number": 129, "body": "def get_result(self) -> Optional[str]:\n        return self.result", "is_method": true, "class_name": "QueryDialog", "function_description": "Accessor method in the QueryDialog class that returns the current query result if available, supporting retrieval of dialog outcomes for further processing or display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add_cascade", "line_number": 166, "body": "def add_cascade(self, label, menu):\n        label_widget = ttk.Label(\n            self,\n            style=\"CustomMenubarLabel.TLabel\",\n            text=label,\n            padding=[6, 3, 6, 2],\n            font=\"TkDefaultFont\",\n        )\n\n        if len(self._menus) == 0:\n            padx = (6, 0)\n        else:\n            padx = 0\n\n        label_widget.grid(row=0, column=len(self._menus), padx=padx)\n\n        def enter(event):\n            label_widget.state((\"active\",))\n\n            # Don't know how to open this menu when another menu is open\n            # another tk_popup just doesn't work unless old menu is closed by click or Esc\n            # https://stackoverflow.com/questions/38081470/is-there-a-way-to-know-if-tkinter-optionmenu-dropdown-is-active\n            # unpost doesn't work in Win and Mac: https://www.tcl.tk/man/tcl8.5/TkCmd/menu.htm#M62\n            # print(\"ENTER\", menu, self._opened_menu)\n            if self._opened_menu is not None:\n                self._opened_menu.unpost()\n                click(event)\n\n        def leave(event):\n            label_widget.state((\"!active\",))\n\n        def click(event):\n            try:\n                # print(\"Before\")\n                self._opened_menu = menu\n                menu.tk_popup(\n                    label_widget.winfo_rootx(),\n                    label_widget.winfo_rooty() + label_widget.winfo_height(),\n                )\n            finally:\n                # print(\"After\")\n                self._opened_menu = None\n\n        label_widget.bind(\"<Enter>\", enter, True)\n        label_widget.bind(\"<Leave>\", leave, True)\n        label_widget.bind(\"<1>\", click, True)\n        self._menus.append(menu)", "is_method": true, "class_name": "CustomMenubar", "function_description": "Adds a new dropdown menu to the custom menubar with interactive label behavior for mouse events, enabling users to open the menu on click and handle visual states for hover effects."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "insert", "line_number": 241, "body": "def insert(self, pos, child, **kw):\n        kw.setdefault(\"minsize\", self._pane_minsize)\n\n        if pos == \"auto\":\n            # According to documentation I should use self.panes()\n            # but this doesn't return expected widgets\n            for sibling in sorted(\n                self.pane_widgets(),\n                key=lambda p: p.position_key if hasattr(p, \"position_key\") else 0,\n            ):\n                if (\n                    not hasattr(sibling, \"position_key\")\n                    or sibling.position_key == None\n                    or sibling.position_key > child.position_key\n                ):\n                    pos = sibling\n                    break\n            else:\n                pos = \"end\"\n\n        if isinstance(pos, tk.Widget):\n            kw[\"before\"] = pos\n\n        self.add(child, **kw)", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Adds a new pane widget at a specified or automatically determined position within the AutomaticPanedWindow, enforcing minimum size constraints and maintaining pane order. This method facilitates dynamic and ordered insertion of child widgets in the pane container."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add", "line_number": 266, "body": "def add(self, child, **kw):\n        kw.setdefault(\"minsize\", self._pane_minsize)\n\n        tk.PanedWindow.add(self, child, **kw)\n        self._update_visibility()\n        self._check_restore_preferred_sizes()", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Adds a new pane to the AutomaticPanedWindow, ensuring minimum size constraints and updating visibility and size preferences automatically. This enables dynamic and user-friendly management of pane elements within the window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "remove", "line_number": 273, "body": "def remove(self, child):\n        tk.PanedWindow.remove(self, child)\n        self._update_visibility()\n        self._check_restore_preferred_sizes()", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Removes a specified pane from the AutomaticPanedWindow and updates the layout visibility and preferred size settings accordingly. This supports dynamic pane management with automatic UI adjustments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "forget", "line_number": 278, "body": "def forget(self, child):\n        tk.PanedWindow.forget(self, child)\n        self._update_visibility()\n        self._check_restore_preferred_sizes()", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Method of AutomaticPanedWindow that removes a specified pane and updates the layout and size preferences accordingly to maintain consistent window behavior after pane removal."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "destroy", "line_number": 283, "body": "def destroy(self):\n        self.unbind(\"<Configure>\", self._configure_binding)\n        self.unbind(\"<<ThemeChanged>>\", self._update_appearance_binding)\n        tk.PanedWindow.destroy(self)", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Method of AutomaticPanedWindow that cleans up event bindings and then destroys the widget, ensuring proper resource release when the pane window is no longer needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "is_visible", "line_number": 288, "body": "def is_visible(self):\n        if not isinstance(self.master, AutomaticPanedWindow):\n            return self.winfo_ismapped()\n        else:\n            return self in self.master.pane_widgets()", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Determines whether the pane is currently visible within its parent AutomaticPanedWindow or, if detached, whether it is mapped in the window system. This supports visibility checks in nested or standalone pane arrangements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "pane_widgets", "line_number": 294, "body": "def pane_widgets(self):\n        result = []\n        for pane in self.panes():\n            # pane is not the widget but some kind of reference object\n            assert not isinstance(pane, tk.Widget)\n            result.append(self.nametowidget(str(pane)))\n        return result", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Returns a list of widgets contained within the panes of the AutomaticPanedWindow, converting pane references into actual widget objects for further manipulation or inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_on_window_resize", "line_number": 302, "body": "def _on_window_resize(self, event):\n        if event.width < 10 or event.height < 10:\n            return\n        window = self.winfo_toplevel()\n        window_size = (window.winfo_width(), window.winfo_height())\n        initializing = hasattr(window, \"initializing\") and window.initializing\n\n        if (\n            not initializing\n            and not self._restoring_pane_sizes\n            and (window_size != self._last_window_size or self._full_size_not_final)\n        ):\n            self._check_restore_preferred_sizes()\n            self._last_window_size = window_size", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Handles window resize events by conditionally triggering pane size restoration checks when the window size changes, supporting dynamic layout adjustments in an AutomaticPanedWindow instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_on_mouse_dragged", "line_number": 317, "body": "def _on_mouse_dragged(self, event):\n        if event.widget == self and not self._restoring_pane_sizes:\n            self._update_preferred_sizes()", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Private method in AutomaticPanedWindow that updates preferred pane sizes when the user drags the mouse, ensuring the window adapts dynamically during resizing or rearranging panes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_update_preferred_sizes", "line_number": 321, "body": "def _update_preferred_sizes(self):\n        for pane in self.pane_widgets():\n            if getattr(pane, \"preferred_size_in_pw\", None) is not None:\n                if self.cget(\"orient\") == \"horizontal\":\n                    current_size = pane.winfo_width()\n                else:\n                    current_size = pane.winfo_height()\n\n                if current_size > 20:\n                    pane.preferred_size_in_pw = current_size", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Internal method of AutomaticPanedWindow that updates each pane's preferred size based on its current width or height, supporting dynamic layout adjustments for horizontal or vertical orientations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_check_restore_preferred_sizes", "line_number": 342, "body": "def _check_restore_preferred_sizes(self):\n        window = self.winfo_toplevel()\n        if getattr(window, \"initializing\", False):\n            return\n\n        try:\n            self._restoring_pane_sizes = True\n            self._restore_preferred_sizes()\n        finally:\n            self._restoring_pane_sizes = False", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Internal method of AutomaticPanedWindow that attempts to restore pane sizes to user-preferred settings unless the window is currently initializing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_restore_preferred_sizes", "line_number": 353, "body": "def _restore_preferred_sizes(self):\n        total_preferred_size = 0\n        panes_without_preferred_size = []\n\n        panes = self.pane_widgets()\n        for pane in panes:\n            if not hasattr(pane, \"preferred_size_in_pw\"):\n                # child isn't fully constructed yet\n                return\n\n            if pane.preferred_size_in_pw is None:\n                panes_without_preferred_size.append(pane)\n                # self.paneconfig(pane, width=1000, height=1000)\n            else:\n                total_preferred_size += pane.preferred_size_in_pw\n\n                # Without updating pane width/height attribute\n                # the preferred size may lose effect when squeezing\n                # non-preferred panes too small. Also zooming/unzooming\n                # changes the supposedly fixed panes ...\n                #\n                # but\n                # paneconfig width/height effectively puts\n                # unexplainable maxsize to some panes\n                # if self.cget(\"orient\") == \"horizontal\":\n                #    self.paneconfig(pane, width=pane.preferred_size_in_pw)\n                # else:\n                #    self.paneconfig(pane, height=pane.preferred_size_in_pw)\n\n        assert len(panes_without_preferred_size) <= 1\n\n        size = self._get_size()\n        if size is None:\n            return\n\n        leftover_size = self._get_size() - total_preferred_size\n        used_size = 0\n        for i, pane in enumerate(panes[:-1]):\n            used_size += pane.preferred_size_in_pw or leftover_size\n            self._place_sash(i, used_size)\n            used_size += int(str(self.cget(\"sashwidth\")))", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Restores and adjusts pane sizes in an AutomaticPanedWindow based on each pane's preferred size to maintain a balanced layout. It ensures panes without preferred sizes share leftover space and updates sash positions accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_get_size", "line_number": 395, "body": "def _get_size(self):\n        if self.cget(\"orient\") == tk.HORIZONTAL:\n            result = self.winfo_width()\n        else:\n            result = self.winfo_height()\n\n        if result < 20:\n            # Not ready yet\n            return None\n        else:\n            return result", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Helper method in AutomaticPanedWindow that returns the current width or height based on orientation, providing the pane's size once it's properly initialized and large enough to be meaningful."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_place_sash", "line_number": 407, "body": "def _place_sash(self, i, distance):\n        if self.cget(\"orient\") == tk.HORIZONTAL:\n            self.sash_place(i, distance, 0)\n        else:\n            self.sash_place(i, 0, distance)", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Internal method of AutomaticPanedWindow that positions a sash at a specific distance along the window's orientation, supporting dynamic layout adjustments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_update_visibility", "line_number": 413, "body": "def _update_visibility(self):\n        if not isinstance(self.master, AutomaticPanedWindow):\n            return\n\n        if len(self.panes()) == 0 and self.is_visible():\n            self.master.forget(self)\n\n        if len(self.panes()) > 0 and not self.is_visible():\n            self.master.insert(\"auto\", self)", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Private method of AutomaticPanedWindow that updates its visibility within the master container based on whether it contains any panes, ensuring correct insertion or removal accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_update_appearance", "line_number": 423, "body": "def _update_appearance(self, event=None):\n        self.configure(sashwidth=lookup_style_option(\"Sash\", \"sashthickness\", ems_to_pixels(0.6)))\n        self.configure(background=lookup_style_option(\"TPanedWindow\", \"background\"))", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Updates the appearance of the AutomaticPanedWindow by configuring sash width and background based on current style settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_tab_menu", "line_number": 446, "body": "def create_tab_menu(self):\n        menu = tk.Menu(self.winfo_toplevel(), tearoff=False, **get_style_configuration(\"Menu\"))\n        menu.add_command(label=tr(\"Close\"), command=self._close_tab_from_menu)\n        menu.add_command(label=tr(\"Close others\"), command=self._close_other_tabs)\n        menu.add_command(label=tr(\"Close all\"), command=self.close_tabs)\n        return menu", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Constructs and returns a context menu for notebook tabs with options to close the current tab, all other tabs, or all tabs, facilitating tab management in the ClosableNotebook UI component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_letf_btn_press", "line_number": 453, "body": "def _letf_btn_press(self, event):\n        try:\n            elem = self.identify(event.x, event.y)\n            index = self.index(\"@%d,%d\" % (event.x, event.y))\n\n            if \"closebutton\" in elem:\n                self.state([\"pressed\"])\n                self.pressed_index = index\n        except Exception:\n            # may fail, if clicked outside of tab\n            return", "is_method": true, "class_name": "ClosableNotebook", "function_description": "This method detects if the user pressed the close button on a notebook tab and sets the state to pressed, enabling the notebook to track which tab's close action is initiated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_left_btn_release", "line_number": 465, "body": "def _left_btn_release(self, event):\n        if not self.instate([\"pressed\"]):\n            return\n\n        try:\n            elem = self.identify(event.x, event.y)\n            index = self.index(\"@%d,%d\" % (event.x, event.y))\n        except Exception:\n            # may fail, when mouse is dragged\n            return\n        else:\n            if \"closebutton\" in elem and self.pressed_index == index:\n                self.close_tab(index)\n\n            self.state([\"!pressed\"])\n        finally:\n            self.pressed_index = None", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Handles mouse left-button release events to detect and close tabs when the close button is clicked, providing tab-closing interaction within the ClosableNotebook UI component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_right_btn_press", "line_number": 483, "body": "def _right_btn_press(self, event):\n        try:\n            index = self.index(\"@%d,%d\" % (event.x, event.y))\n            self._popup_index = index\n            self.tab_menu.tk_popup(*self.winfo_toplevel().winfo_pointerxy())\n        except Exception:\n            logging.exception(\"Opening tab menu\")", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Handles right-click events on notebook tabs to identify the clicked tab and display a context menu for that tab, enabling user interactions such as tab options or management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close_tab_from_menu", "line_number": 491, "body": "def _close_tab_from_menu(self):\n        self.close_tab(self._popup_index)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Private helper method of the ClosableNotebook class that closes a tab identified by the current popup menu index. It enables programmatic tab closure based on user interface interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close_other_tabs", "line_number": 494, "body": "def _close_other_tabs(self):\n        self.close_tabs(self._popup_index)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Internal method of ClosableNotebook that closes all tabs except the one at the popup index, facilitating focused tab management within the notebook interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "close_tabs", "line_number": 497, "body": "def close_tabs(self, except_index=None):\n        for tab_index in reversed(range(len(self.winfo_children()))):\n            if except_index is not None and tab_index == except_index:\n                continue\n            else:\n                self.close_tab(tab_index)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Method of ClosableNotebook that closes all open tabs except the one at a specified index, facilitating selective tab management within the notebook interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "close_tab", "line_number": 504, "body": "def close_tab(self, index):\n        child = self.get_child_by_index(index)\n        if hasattr(child, \"close\"):\n            child.close()\n        else:\n            self.forget(index)\n            child.destroy()", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Service method of ClosableNotebook that closes a tab by either invoking its close method or removing and destroying it, enabling controlled closure of notebook tabs in a GUI environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_child_by_index", "line_number": 512, "body": "def get_child_by_index(self, index):\n        tab_id = self.tabs()[index]\n        if tab_id:\n            return self.nametowidget(tab_id)\n        else:\n            return None", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Returns the child widget at the specified index from the notebook's tabs, or None if no tab exists at that index. This method enables indexed access to the notebook's child elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_current_child", "line_number": 519, "body": "def get_current_child(self):\n        child_id = self.select()\n        if child_id:\n            return self.nametowidget(child_id)\n        else:\n            return None", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Returns the currently selected child widget within the ClosableNotebook, or None if no child is selected. This helps manage or interact with the active tab or component in the notebook interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "focus_set", "line_number": 526, "body": "def focus_set(self):\n        editor = self.get_current_child()\n        if editor:\n            editor.focus_set()\n        else:\n            super().focus_set()", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Method of ClosableNotebook that sets focus to the currently active child editor if present; otherwise, it sets focus on the notebook itself. This facilitates user interaction by directing input focus appropriately within the notebook's components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_check_update_style", "line_number": 533, "body": "def _check_update_style(self):\n        style = ttk.Style()\n        if \"closebutton\" in style.element_names():\n            # It's done already\n            return\n\n        # respect if required images have been defined already\n        if \"img_close\" not in self.image_names():\n            img_dir = os.path.join(os.path.dirname(__file__), \"res\")\n            ClosableNotebook._close_img = tk.PhotoImage(\n                \"img_tab_close\", file=os.path.join(img_dir, \"tab_close.gif\")\n            )\n            ClosableNotebook._close_active_img = tk.PhotoImage(\n                \"img_tab_close_active\", file=os.path.join(img_dir, \"tab_close_active.gif\")\n            )\n\n        style.element_create(\n            \"closebutton\",\n            \"image\",\n            \"img_tab_close\",\n            (\"active\", \"pressed\", \"!disabled\", \"img_tab_close_active\"),\n            (\"active\", \"!disabled\", \"img_tab_close_active\"),\n            border=8,\n            sticky=\"\",\n        )\n\n        style.layout(\n            \"ButtonNotebook.TNotebook.Tab\",\n            [\n                (\n                    \"Notebook.tab\",\n                    {\n                        \"sticky\": \"nswe\",\n                        \"children\": [\n                            (\n                                \"Notebook.padding\",\n                                {\n                                    \"side\": \"top\",\n                                    \"sticky\": \"nswe\",\n                                    \"children\": [\n                                        (\n                                            \"Notebook.focus\",\n                                            {\n                                                \"side\": \"top\",\n                                                \"sticky\": \"nswe\",\n                                                \"children\": [\n                                                    (\n                                                        \"Notebook.label\",\n                                                        {\"side\": \"left\", \"sticky\": \"\"},\n                                                    ),\n                                                    (\n                                                        \"Notebook.closebutton\",\n                                                        {\"side\": \"left\", \"sticky\": \"\"},\n                                                    ),\n                                                ],\n                                            },\n                                        )\n                                    ],\n                                },\n                            )\n                        ],\n                    },\n                )\n            ],\n        )", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Sets up or updates the notebook tab style to include a close button with associated images and layout, enabling tabs in the ClosableNotebook to display a functional close icon."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_check_remove_padding", "line_number": 599, "body": "def _check_remove_padding(self, kw):\n        # Windows themes produce 1-pixel padding to the bottom of the pane\n        # Don't know how to get rid of it using themes\n        if \"padding\" not in kw and ttk.Style().theme_use().lower() in (\n            \"windows\",\n            \"xpnative\",\n            \"vista\",\n        ):\n            kw[\"padding\"] = (0, 0, 0, -1)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Internal helper method of ClosableNotebook that adjusts padding parameters for UI consistency on specific Windows themes by removing unwanted bottom padding."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add", "line_number": 609, "body": "def add(self, child, **kw):\n        self._check_remove_padding(kw)\n        super().add(child, **kw)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Method of ClosableNotebook that adds a child element to the notebook, ensuring any removal padding settings are applied before insertion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "insert", "line_number": 613, "body": "def insert(self, pos, child, **kw):\n        self._check_remove_padding(kw)\n        super().insert(pos, child, **kw)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Core method of ClosableNotebook that inserts a child widget at a specified position, ensuring padding adjustments before insertion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add", "line_number": 636, "body": "def add(self, child, **kw):\n        super().add(child, **kw)\n        self._update_visibility()", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Adds a child element to the notebook and updates the notebook's visibility state accordingly. This method ensures the user interface reflects the current content structure after modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "insert", "line_number": 640, "body": "def insert(self, pos, child, **kw):\n        if pos == \"auto\":\n            for sibling in map(self.nametowidget, self.tabs()):\n                if (\n                    not hasattr(sibling, \"position_key\")\n                    or sibling.position_key == None\n                    or sibling.position_key > child.position_key\n                ):\n                    pos = sibling\n                    break\n            else:\n                pos = \"end\"\n\n        super().insert(pos, child, **kw)\n        self._update_visibility()", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Method of AutomaticNotebook that inserts a child widget at an appropriate position based on its position key, supporting automatic ordering and updating tab visibility accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "hide", "line_number": 656, "body": "def hide(self, tab_id):\n        super().hide(tab_id)\n        self._update_visibility()", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Utility method in AutomaticNotebook that hides a specific tab by its ID and updates the notebook's visibility state accordingly. It manages the display of notebook tabs dynamically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "forget", "line_number": 660, "body": "def forget(self, tab_id):\n        if tab_id in self.tabs() or tab_id in self.winfo_children():\n            super().forget(tab_id)\n        self._update_visibility()", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Removes a specified notebook tab from the display if it exists and updates the notebook's visibility accordingly, allowing dynamic management of visible tabs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "is_visible", "line_number": 665, "body": "def is_visible(self):\n        return self in self.master.pane_widgets()", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Checks if the AutomaticNotebook instance is currently visible within its parent container's pane widgets, enabling conditional actions based on its display state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_visible_child", "line_number": 668, "body": "def get_visible_child(self):\n        for child in self.winfo_children():\n            if str(child) == str(self.select()):\n                return child\n\n        return None", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Method of the AutomaticNotebook class that returns the currently selected visible child widget, or None if no child is selected. It helps identify the active tab or pane in a notebook interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_update_visibility", "line_number": 675, "body": "def _update_visibility(self):\n        if not isinstance(self.master, AutomaticPanedWindow):\n            return\n        if len(self.tabs()) == 0 and self.is_visible():\n            self.master.remove(self)\n\n        if len(self.tabs()) > 0 and not self.is_visible():\n            self.master.insert(\"auto\", self)", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Core utility method of the AutomaticNotebook class that manages the notebook's visibility by adding or removing it from its parent container based on whether it contains any tabs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_clear_tree", "line_number": 728, "body": "def _clear_tree(self):\n        for child_id in self.tree.get_children():\n            self.tree.delete(child_id)", "is_method": true, "class_name": "TreeFrame", "function_description": "Internal method of the TreeFrame class that clears all child nodes from the tree structure. It supports resetting or refreshing the tree display by removing existing entries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "clear", "line_number": 732, "body": "def clear(self):\n        self._clear_tree()", "is_method": true, "class_name": "TreeFrame", "function_description": "Clears all data and resets the internal state of the tree structure within the TreeFrame class, preparing it for fresh operations or data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "direct_insert", "line_number": 814, "body": "def direct_insert(self, index, chars, tags=None, **kw):\n        # try removing line numbers\n        # TODO: shouldn't it take place only on paste?\n        # TODO: does it occur when opening a file with line numbers in it?\n        # if self._propose_remove_line_numbers and isinstance(chars, str):\n        #    chars = try_remove_linenumbers(chars, self)\n\n        concrete_index = self.index(index)\n        line_before = self.get(concrete_index + \" linestart\", concrete_index + \" lineend\")\n        self._last_event_changed_line_count = \"\\n\" in chars\n        result = tktextext.EnhancedText.direct_insert(self, index, chars, tags=tags, **kw)\n        line_after = self.get(concrete_index + \" linestart\", concrete_index + \" lineend\")\n        trivial_for_coloring, trivial_for_parens = self._is_trivial_edit(\n            chars, line_before, line_after\n        )\n        get_workbench().event_generate(\n            \"TextInsert\",\n            index=concrete_index,\n            text=chars,\n            tags=tags,\n            text_widget=self,\n            trivial_for_coloring=trivial_for_coloring,\n            trivial_for_parens=trivial_for_parens,\n        )\n        return result", "is_method": true, "class_name": "EnhancedTextWithLogging", "function_description": "Method of EnhancedTextWithLogging that inserts text at a given index while emitting a detailed event about the insertion, supporting downstream components like syntax coloring or parenthesis matching to react appropriately to trivial or significant text changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "direct_delete", "line_number": 840, "body": "def direct_delete(self, index1, index2=None, **kw):\n        try:\n            # index1 may be eg \"sel.first\" and it doesn't make sense *after* deletion\n            concrete_index1 = self.index(index1)\n            if index2 is not None:\n                concrete_index2 = self.index(index2)\n            else:\n                concrete_index2 = None\n\n            chars = self.get(index1, index2)\n            self._last_event_changed_line_count = \"\\n\" in chars\n            line_before = self.get(\n                concrete_index1 + \" linestart\",\n                (concrete_index1 if concrete_index2 is None else concrete_index2) + \" lineend\",\n            )\n            return tktextext.EnhancedText.direct_delete(self, index1, index2=index2, **kw)\n        finally:\n            line_after = self.get(\n                concrete_index1 + \" linestart\",\n                (concrete_index1 if concrete_index2 is None else concrete_index2) + \" lineend\",\n            )\n            trivial_for_coloring, trivial_for_parens = self._is_trivial_edit(\n                chars, line_before, line_after\n            )\n            get_workbench().event_generate(\n                \"TextDelete\",\n                index1=concrete_index1,\n                index2=concrete_index2,\n                text_widget=self,\n                trivial_for_coloring=trivial_for_coloring,\n                trivial_for_parens=trivial_for_parens,\n            )", "is_method": true, "class_name": "EnhancedTextWithLogging", "function_description": "Method of EnhancedTextWithLogging that deletes text between specified indices while logging the change and generating a custom \"TextDelete\" event indicating if the edit affects text coloring or parentheses handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_is_trivial_edit", "line_number": 873, "body": "def _is_trivial_edit(self, chars, line_before, line_after):\n        # line is taken after edit for insertion and before edit for deletion\n        if not chars.strip():\n            # linebreaks, including with automatic indent\n            # check it doesn't break a triple-quote\n            trivial_for_coloring = line_before.count(\"'''\") == line_after.count(\n                \"'''\"\n            ) and line_before.count('\"\"\"') == line_after.count('\"\"\"')\n            trivial_for_parens = trivial_for_coloring\n        elif len(chars) > 1:\n            # paste, cut, load or something like this\n            trivial_for_coloring = False\n            trivial_for_parens = False\n        elif chars == \"#\":\n            trivial_for_coloring = \"''''\" not in line_before and '\"\"\"' not in line_before\n            trivial_for_parens = trivial_for_coloring and not re.search(PARENS_REGEX, line_before)\n        elif chars in \"()[]{}\":\n            trivial_for_coloring = line_before.count(\"'''\") == line_after.count(\n                \"'''\"\n            ) and line_before.count('\"\"\"') == line_after.count('\"\"\"')\n            trivial_for_parens = False\n        elif chars == \"'\":\n            trivial_for_coloring = \"'''\" not in line_before and \"'''\" not in line_after\n            trivial_for_parens = False  # can put parens into open string\n        elif chars == '\"':\n            trivial_for_coloring = '\"\"\"' not in line_before and '\"\"\"' not in line_after\n            trivial_for_parens = False  # can put parens into open string\n        elif chars == \"\\\\\":\n            # can shorten closing quote\n            trivial_for_coloring = '\"\"\"' not in line_before and '\"\"\"' not in line_after\n            trivial_for_parens = False\n        else:\n            trivial_for_coloring = line_before.count(\"'''\") == line_after.count(\n                \"'''\"\n            ) and line_before.count('\"\"\"') == line_after.count('\"\"\"')\n            trivial_for_parens = trivial_for_coloring\n\n        return trivial_for_coloring, trivial_for_parens", "is_method": true, "class_name": "EnhancedTextWithLogging", "function_description": "Determines if a text edit is trivial for syntax coloring or parenthesis matching by analyzing character changes and their effect on multiline string quotes. Useful for optimizing text editor updates by skipping insignificant edits."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "set", "line_number": 917, "body": "def set(self, first, last):\n        try:\n            ttk.Scrollbar.set(self, first, last)\n        except Exception:\n            traceback.print_exc()", "is_method": true, "class_name": "SafeScrollbar", "function_description": "Method of SafeScrollbar that safely updates scrollbar positions by delegating to the parent method while catching and logging any exceptions to prevent application crashes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "set", "line_number": 932, "body": "def set(self, first, last):\n        if float(first) <= 0.0 and float(last) >= 1.0:\n            self.grid_remove()\n        elif float(first) > 0.001 or float(last) < 0.009:\n            # with >0 and <1 it occasionally made scrollbar wobble back and forth\n            self.grid()\n        ttk.Scrollbar.set(self, first, last)", "is_method": true, "class_name": "AutoScrollbar", "function_description": "Provides a customized scrollbar behavior that hides itself when content is fully visible and shows only when scrolling is needed, preventing visual flickering during partial scrolls."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "pack", "line_number": 940, "body": "def pack(self, **kw):\n        raise tk.TclError(\"cannot use pack with this widget\")", "is_method": true, "class_name": "AutoScrollbar", "function_description": "Prevents the use of the pack geometry manager with the AutoScrollbar widget by raising an error, enforcing proper layout management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "place", "line_number": 943, "body": "def place(self, **kw):\n        raise tk.TclError(\"cannot use place with this widget\")", "is_method": true, "class_name": "AutoScrollbar", "function_description": "This method prevents the use of the 'place' geometry manager with the AutoScrollbar widget by explicitly raising an error. It enforces layout constraints to ensure proper widget behavior within the GUI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_expose", "line_number": 977, "body": "def _expose(self, event):\n        self.update_idletasks()\n        self.update_scrollbars()", "is_method": true, "class_name": "VerticallyScrollableFrame", "function_description": "Internal method of VerticallyScrollableFrame that refreshes the frame's display and updates scrollbar states in response to exposure events, ensuring correct visual representation and scroll functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_configure_interior", "line_number": 981, "body": "def _configure_interior(self, event):\n        self.update_scrollbars()", "is_method": true, "class_name": "VerticallyScrollableFrame", "function_description": "Internal method of VerticallyScrollableFrame that updates scrollbar states in response to interior widget configuration changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "update_scrollbars", "line_number": 984, "body": "def update_scrollbars(self):\n        # update the scrollbars to match the size of the inner frame\n        size = (self.canvas.winfo_width(), self.interior.winfo_reqheight())\n        self.canvas.config(scrollregion=\"0 0 %s %s\" % size)\n        if (\n            self.interior.winfo_reqwidth() != self.canvas.winfo_width()\n            and self.canvas.winfo_width() > 10\n        ):\n            # update the interior's width to fit canvas\n            # print(\"CAWI\", self.canvas.winfo_width())\n            self.canvas.itemconfigure(self.interior_id, width=self.canvas.winfo_width())", "is_method": true, "class_name": "VerticallyScrollableFrame", "function_description": "Updates scrollbar settings to synchronize the scrolling area with the inner frame's dimensions, ensuring smooth vertical scrolling and correct content display within the scrollable frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_expose", "line_number": 1027, "body": "def _expose(self, event):\n        self.update_idletasks()\n        self._configure_interior(event)", "is_method": true, "class_name": "ScrollableFrame", "function_description": "Utility method in ScrollableFrame that refreshes the widget and updates the interior layout in response to an exposure event, ensuring proper rendering and display updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_configure_interior", "line_number": 1031, "body": "def _configure_interior(self, event):\n        # update the scrollbars to match the size of the inner frame\n        size = (self.canvas.winfo_reqwidth(), self.interior.winfo_reqheight())\n        self.canvas.config(scrollregion=\"0 0 %s %s\" % size)", "is_method": true, "class_name": "ScrollableFrame", "function_description": "Private method of the ScrollableFrame class that updates the scrollable region to fit the inner content size, ensuring the scrollbars correctly reflect the current dimensions of the frame's interior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_reload_theme_options", "line_number": 1046, "body": "def _reload_theme_options(self, event=None):\n        style = ttk.Style()\n\n        states = []\n        if self[\"state\"] == \"disabled\":\n            states.append(\"disabled\")\n\n        # Following crashes when a combobox is focused\n        # if self.focus_get() == self:\n        #    states.append(\"focus\")\n        opts = {}\n        for key in [\n            \"background\",\n            \"foreground\",\n            \"highlightthickness\",\n            \"highlightcolor\",\n            \"highlightbackground\",\n        ]:\n            value = style.lookup(self.get_style_name(), key, states)\n            if value:\n                opts[key] = value\n\n        self.configure(opts)", "is_method": true, "class_name": "ThemedListbox", "function_description": "Updates the widget's appearance by reapplying current theme style options, ensuring the ThemedListbox visually reflects any theme changes or state updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_style_name", "line_number": 1070, "body": "def get_style_name(self):\n        return \"Listbox\"", "is_method": true, "class_name": "ThemedListbox", "function_description": "Returns the base style name associated with the ThemedListbox, typically used for applying consistent UI themes or styles."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "destroy", "line_number": 1073, "body": "def destroy(self):\n        self.unbind(\"<<ThemeChanged>>\", self._ui_theme_change_binding)\n        super().destroy()", "is_method": true, "class_name": "ThemedListbox", "function_description": "Method of ThemedListbox that unbinds its theme change event handler before destroying the widget, ensuring proper cleanup of theme-related bindings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "showtip", "line_number": 1088, "body": "def showtip(self, text):\n        \"Display text in tooltip window\"\n        self.text = text\n        if self.tipwindow or not self.text:\n            return\n        x, y, _, cy = self.widget.bbox(\"insert\")\n        x = x + self.widget.winfo_rootx() + 27\n        y = y + cy + self.widget.winfo_rooty() + self.widget.winfo_height() + 2\n        self.tipwindow = tw = tk.Toplevel(self.widget)\n        if running_on_mac_os():\n            try:\n                # Must be the first thing to do after creating window\n                # https://wiki.tcl-lang.org/page/MacWindowStyle\n                tw.tk.call(\n                    \"::tk::unsupported::MacWindowStyle\", \"style\", tw._w, \"help\", \"noActivates\"\n                )\n                if get_tk_version_info() >= (8, 6, 10) and running_on_mac_os():\n                    tw.wm_overrideredirect(1)\n            except tk.TclError:\n                pass\n        else:\n            tw.wm_overrideredirect(1)\n\n        tw.wm_geometry(\"+%d+%d\" % (x, y))\n\n        if running_on_mac_os():\n            # TODO: maybe it's because of Tk 8.5, not because of Mac\n            tw.wm_transient(self.widget)\n\n        label = tk.Label(tw, text=self.text, **self.options)\n        label.pack()", "is_method": true, "class_name": "ToolTip", "function_description": "Provides a tooltip display for a widget by creating and showing a small popup window with the specified text near the widget's insertion point. This method enables contextual, on-hover help or information in graphical interfaces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "hidetip", "line_number": 1121, "body": "def hidetip(self, event=None):\n        tw = self.tipwindow\n        self.tipwindow = None\n        if tw:\n            tw.destroy()", "is_method": true, "class_name": "ToolTip", "function_description": "Method of the ToolTip class that hides and removes the tooltip window from the user interface. It is typically used to dismiss tooltips when they are no longer needed or when the user moves away."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "clear", "line_number": 1200, "body": "def clear(self):\n        for tag in self._click_bindings:\n            self.text.tag_unbind(tag, \"<1>\", self._click_bindings[tag])\n            self.text.tag_remove(tag, \"1.0\", \"end\")\n\n        self.text.direct_delete(\"1.0\", \"end\")\n        self._current_chars = \"\"\n        self._click_bindings.clear()", "is_method": true, "class_name": "NoteBox", "function_description": "Clears all text content and associated click event bindings from the NoteBox, effectively resetting its state for fresh input or display. This is useful for completely wiping the NoteBox's content and interactivity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "set_content", "line_number": 1209, "body": "def set_content(self, *items):\n        self.clear()\n\n        for item in items:\n            if isinstance(item, str):\n                self.text.direct_insert(\"1.0\", item)\n                self._current_chars = item\n            else:\n                assert isinstance(item, (list, tuple))\n                chars, *props = item\n                if len(props) > 0 and callable(props[-1]):\n                    tags = tuple(props[:-1])\n                    click_handler = props[-1]\n                else:\n                    tags = tuple(props)\n                    click_handler = None\n\n                self.append_text(chars, tags, click_handler)\n\n            self.text.see(\"1.0\")", "is_method": true, "class_name": "NoteBox", "function_description": "Provides a method to replace the content of a NoteBox with given strings or formatted text items, supporting optional text styling and interactive click handlers. This facilitates dynamic and rich text updates in the NoteBox user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "append_text", "line_number": 1230, "body": "def append_text(self, chars, tags=(), click_handler=None):\n        tags = tuple(tags)\n\n        if click_handler is not None:\n            click_tag = \"click_%d\" % len(self._click_bindings)\n            tags = tags + (click_tag,)\n            binding = self.text.tag_bind(click_tag, \"<1>\", click_handler, True)\n            self._click_bindings[click_tag] = binding\n\n        self.text.direct_insert(\"end\", chars, tags)\n        self._current_chars += chars", "is_method": true, "class_name": "NoteBox", "function_description": "Adds text with optional tags and clickable behavior to the NoteBox, enabling interactive and styled text insertion within the widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "place", "line_number": 1242, "body": "def place(self, target, focus=None):\n\n        # Compute the area that will be described by this Note\n        focus_x = target.winfo_rootx()\n        focus_y = target.winfo_rooty()\n        focus_height = target.winfo_height()\n\n        if isinstance(focus, TextRange):\n            assert isinstance(target, tk.Text)\n            topleft = target.bbox(\"%d.%d\" % (focus.lineno, focus.col_offset))\n            if focus.end_col_offset == 0:\n                botright = target.bbox(\n                    \"%d.%d lineend\" % (focus.end_lineno - 1, focus.end_lineno - 1)\n                )\n            else:\n                botright = target.bbox(\"%d.%d\" % (focus.end_lineno, focus.end_col_offset))\n\n            if topleft and botright:\n                focus_x += topleft[0]\n                focus_y += topleft[1]\n                focus_height = botright[1] - topleft[1] + botright[3]\n\n        elif isinstance(focus, (list, tuple)):\n            focus_x += focus[0]\n            focus_y += focus[1]\n            focus_height = focus[3]\n\n        elif focus is None:\n            pass\n\n        else:\n            raise TypeError(\"Unsupported focus\")\n\n        # Compute dimensions of the note\n        font = self.text[\"font\"]\n        if isinstance(font, str):\n            font = tk.font.nametofont(font)\n\n        lines = self._current_chars.splitlines()\n        max_line_width = 0\n        for line in lines:\n            max_line_width = max(max_line_width, font.measure(line))\n\n        width = min(max_line_width, self._max_default_width) + self.padx * 2 + 2\n        self.wm_geometry(\"%dx%d+%d+%d\" % (width, 100, focus_x, focus_y + focus_height))\n\n        self.update_idletasks()\n        line_count = int(float(self.text.index(\"end\")))\n        line_height = font.metrics()[\"linespace\"]\n\n        self.wm_geometry(\n            \"%dx%d+%d+%d\" % (width, line_count * line_height, focus_x, focus_y + focus_height)\n        )\n\n        # TODO: detect the situation when note doesn't fit under\n        # the focus box and should be placed above\n\n        self.deiconify()", "is_method": true, "class_name": "NoteBox", "function_description": "Positions and sizes the NoteBox window relative to a target widget and optional focus area, ensuring the note appears aligned and sized appropriately for displaying its text content near the target element."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "show_note", "line_number": 1301, "body": "def show_note(self, *content_items: Union[str, List], target=None, focus=None) -> None:\n\n        self.set_content(*content_items)\n        self.place(target, focus)", "is_method": true, "class_name": "NoteBox", "function_description": "Displays specified content within the NoteBox, positioning it relative to a target and optional focus for contextual presentation. This enables dynamic visualization of notes or messages in an interactive interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close_maybe", "line_number": 1306, "body": "def _close_maybe(self, event):\n        if event.widget not in [self, self.text]:\n            self.close(event)", "is_method": true, "class_name": "NoteBox", "function_description": "Private method in NoteBox that conditionally closes the widget when an event occurs outside its main components, helping manage widget visibility based on user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "close", "line_number": 1310, "body": "def close(self, event=None):\n        self.withdraw()", "is_method": true, "class_name": "NoteBox", "function_description": "Method of the NoteBox class that hides the current window, effectively closing or minimizing the user interface without destroying it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_on_write", "line_number": 1338, "body": "def _on_write(self, *args):\n        self.modified = True\n        if self.modification_listener:\n            try:\n                self.modification_listener()\n            except Exception:\n                # Otherwise whole process will be brought down\n                # because for some reason Tk tries to call non-existing method\n                # on variable\n                get_workbench().report_exception()", "is_method": true, "class_name": "EnhancedVar", "function_description": "This method flags the EnhancedVar instance as modified and safely triggers a modification listener callback if one exists, ensuring that errors in the callback don't disrupt the overall process. It supports reactive behaviors upon variable changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_poll", "line_number": 1567, "body": "def _poll(self):\n        if self._async_result.ready():\n            self._close()\n        elif self.timeout and time.time() - self.start_time > self.timeout:\n            raise TimeoutError()\n        else:\n            self.after(500, self._poll)\n            self.desc_label[\"text\"] = self.desc_label[\"text\"] + \".\"", "is_method": true, "class_name": "WaitingDialog", "function_description": "Core utility method of the WaitingDialog class that periodically checks if an asynchronous operation has completed or timed out, updating the dialog's description and closing it when done or raising an error on timeout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close", "line_number": 1576, "body": "def _close(self):\n        self.destroy()", "is_method": true, "class_name": "WaitingDialog", "function_description": "Private method of the WaitingDialog class that closes the dialog by destroying its instance. It provides a mechanism to programmatically dismiss the waiting dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_start", "line_number": 1634, "body": "def _start(self):\n        def work():\n            self._copy_progess = 0\n\n            with open(self._source, \"rb\") as fsrc:\n                with open(self._destination, \"wb\") as fdst:\n                    while True:\n                        buf = fsrc.read(16 * 1024)\n                        if not buf:\n                            break\n\n                        fdst.write(buf)\n                        fdst.flush()\n                        if self._fsync:\n                            os.fsync(fdst)\n                        self._bytes_copied += len(buf)\n\n            self._done = True\n\n        threading.Thread(target=work, daemon=True).start()", "is_method": true, "class_name": "FileCopyDialog", "function_description": "Starts a background thread to copy a file from source to destination, tracking progress and optionally syncing to disk for data integrity during the copy operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_update_progress", "line_number": 1655, "body": "def _update_progress(self):\n        if self._done:\n            if not self._closed:\n                self._close()\n            return\n\n        self._bar.step(self._bytes_copied - self._old_bytes_copied)\n        self._old_bytes_copied = self._bytes_copied\n\n        self.after(100, self._update_progress)", "is_method": true, "class_name": "FileCopyDialog", "function_description": "Internal method of FileCopyDialog that periodically updates the progress bar reflecting bytes copied and closes the dialog when the copy operation completes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close", "line_number": 1666, "body": "def _close(self):\n        self.destroy()\n        self._closed = True", "is_method": true, "class_name": "FileCopyDialog", "function_description": "Private method in FileCopyDialog that closes the dialog window and marks it as closed for internal state tracking."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_cancel", "line_number": 1670, "body": "def _cancel(self, event=None):\n        self._cancelled = True\n        self._close()", "is_method": true, "class_name": "FileCopyDialog", "function_description": "Private method in FileCopyDialog that marks the copy operation as cancelled and closes the dialog, typically used to handle user-initiated cancellation events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_ok", "line_number": 1714, "body": "def _ok(self):\n        self.result = self.var.get()\n        if not self.result:\n            self.result = None\n\n        self.destroy()", "is_method": true, "class_name": "ChoiceDialog", "function_description": "Internal method of ChoiceDialog that captures the selected choice value, sets it as the result (or None if empty), and closes the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_cancel", "line_number": 1721, "body": "def _cancel(self):\n        self.result = None\n        self.destroy()", "is_method": true, "class_name": "ChoiceDialog", "function_description": "Utility method in ChoiceDialog that cancels the current dialog by clearing the result and closing the dialog window. It supports managing user interaction flow by handling cancellation events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_copy", "line_number": 1771, "body": "def _copy(self, event=None):\n        self.clipboard_clear()\n        self.clipboard_append(self._text.text.get(\"1.0\", \"end\"))", "is_method": true, "class_name": "LongTextDialog", "function_description": "Copies the entire text content from the dialog to the system clipboard, enabling easy text transfer or duplication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close", "line_number": 1775, "body": "def _close(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "LongTextDialog", "function_description": "Helper method in LongTextDialog that closes the dialog window, optionally triggered by an event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askopenfilename", "line_number": 1930, "body": "def askopenfilename(cls, **options):\n        args = cls._convert_common_options(\"Open file\", **options)\n        return cls._call(args)", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "Utility method in _ZenityDialogProvider that opens a file selection dialog and returns the chosen filename, supporting customizable options for dialog configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askopenfilenames", "line_number": 1935, "body": "def askopenfilenames(cls, **options):\n        args = cls._convert_common_options(\"Open files\", **options)\n        return cls._call(args + [\"--multiple\"]).split(\"|\")", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "Utility method of _ZenityDialogProvider that presents a file open dialog allowing multiple selections and returns the chosen file paths as a list. It simplifies acquiring user-selected file names with customizable dialog options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "asksaveasfilename", "line_number": 1940, "body": "def asksaveasfilename(cls, **options):\n        args = cls._convert_common_options(\"Save as\", **options)\n        args.append(\"--save\")\n        if options.get(\"confirmoverwrite\", True):\n            args.append(\"--confirm-overwrite\")\n\n        filename = cls._call(args)\n        if not filename:\n            return None\n\n        if \"defaultextension\" in options and \".\" not in os.path.basename(filename):\n            filename += options[\"defaultextension\"]\n\n        return filename", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "Provides a file save dialog that allows users to select a filename for saving, optionally confirming overwrites and appending a default extension if none is specified."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askdirectory", "line_number": 1956, "body": "def askdirectory(cls, **options):\n        args = cls._convert_common_options(\"Select directory\", **options)\n        args.append(\"--directory\")\n        return cls._call(args)", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "Utility method of _ZenityDialogProvider that opens a directory selection dialog and returns the chosen directory path, supporting customizable options for dialog behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_convert_common_options", "line_number": 1962, "body": "def _convert_common_options(cls, default_title, **options):\n        args = [\"--file-selection\", \"--title=%s\" % options.get(\"title\", default_title)]\n\n        filename = _options_to_zenity_filename(options)\n        if filename:\n            args.append(\"--filename=%s\" % filename)\n\n        parent = options.get(\"parent\", options.get(\"master\", None))\n        if parent is not None:\n            args.append(\"--modal\")\n            args.append(\"--attach=%s\" % hex(parent.winfo_id()))\n\n        for desc, pattern in options.get(\"filetypes\", ()):\n            # zenity requires star before extension\n            pattern = pattern.replace(\" .\", \" *.\")\n            if pattern.startswith(\".\"):\n                pattern = \"*\" + pattern\n\n            if pattern == \"*.*\":\n                # \".*\" was provided to make the pattern safe for Tk dialog\n                # not required with Zenity\n                pattern = \"*\"\n\n            args.append(\"--file-filter=%s | %s\" % (desc, pattern))\n\n        return args", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "Builds and returns a list of command-line arguments to configure a Zenity file selection dialog based on common options like title, filename, file filters, and parent window attachment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_call", "line_number": 1990, "body": "def _call(cls, args):\n        args = [\"zenity\", \"--name=Thonny\", \"--class=Thonny\"] + args\n        result = subprocess.run(\n            args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True\n        )\n        if result.returncode == 0:\n            return result.stdout.strip()\n        else:\n            # TODO: log problems\n            print(result.stderr, file=sys.stderr)\n            # could check stderr, but it may contain irrelevant warnings\n            return None", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "Internal utility of _ZenityDialogProvider that executes a Zenity dialog command with given arguments and returns its output or None if the command fails."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "read_stream", "line_number": 2113, "body": "def read_stream(stream, target_list):\n        while True:\n            line = stream.readline()\n            if line:\n                target_list.append(line)\n            else:\n                break", "is_method": false, "function_description": "This function reads lines from a stream and appends each line to a given list until the stream is exhausted. It provides a simple way to collect streamed data into a list for further processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_post", "line_number": 2146, "body": "def on_post(self, *args):\n        self.update_item_availability()", "is_method": true, "class_name": "MenuEx", "function_description": "Triggers an update of menu item availability, typically in response to a POST request, to ensure the menu reflects current item statuses."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "update_item_availability", "line_number": 2149, "body": "def update_item_availability(self):\n        for i in range(self.index(\"end\") + 1):\n            item_data = self.entryconfigure(i)\n            if \"label\" in item_data:\n                tester = self._testers.get(item_data[\"label\"])\n                if tester and not tester():\n                    self.entryconfigure(i, state=tk.DISABLED)\n                else:\n                    self.entryconfigure(i, state=tk.NORMAL)", "is_method": true, "class_name": "MenuEx", "function_description": "Updates the availability state of menu items based on dynamic conditions, enabling or disabling items according to associated tester functions. This helps keep menu options contextually relevant and interactive."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add", "line_number": 2159, "body": "def add(self, itemType, cnf={}, **kw):\n        cnf = cnf or kw\n        tester = cnf.get(\"tester\")\n        if \"tester\" in cnf:\n            del cnf[\"tester\"]\n\n        super().add(itemType, cnf)\n\n        itemdata = self.entryconfigure(self.index(\"end\"))\n        labeldata = itemdata.get(\"label\")\n        if labeldata:\n            self._testers[labeldata] = tester", "is_method": true, "class_name": "MenuEx", "function_description": "Adds a menu item to the MenuEx instance while associating an optional tester function with its label for later reference or validation. This extends standard menu addition by linking menu entries to custom tester callbacks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add_basic_items", "line_number": 2180, "body": "def add_basic_items(self):\n        self.add_command(label=tr(\"Cut\"), command=self.on_cut, tester=self.can_cut)\n        self.add_command(label=tr(\"Copy\"), command=self.on_copy, tester=self.can_copy)\n        self.add_command(label=tr(\"Paste\"), command=self.on_paste, tester=self.can_paste)", "is_method": true, "class_name": "TextMenu", "function_description": "Adds standard editing commands (Cut, Copy, Paste) to the menu, linking each to its respective action and availability check for text manipulation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add_extra_items", "line_number": 2185, "body": "def add_extra_items(self):\n        self.add_separator()\n        self.add_command(label=tr(\"Select All\"), command=self.on_select_all)", "is_method": true, "class_name": "TextMenu", "function_description": "Adds a separator and a \"Select All\" command to the menu, enhancing user interaction by providing quick selection capability. This supports menu customization in the TextMenu class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_cut", "line_number": 2189, "body": "def on_cut(self):\n        self.text.event_generate(\"<<Cut>>\")", "is_method": true, "class_name": "TextMenu", "function_description": "Triggers the cut action on the text component, allowing users to remove and copy the selected text to the clipboard."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_copy", "line_number": 2192, "body": "def on_copy(self):\n        self.text.event_generate(\"<<Copy>>\")", "is_method": true, "class_name": "TextMenu", "function_description": "Triggers the standard copy event on the text component, enabling external handlers to process text copying actions within the TextMenu context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_paste", "line_number": 2195, "body": "def on_paste(self):\n        self.text.event_generate(\"<<Paste>>\")", "is_method": true, "class_name": "TextMenu", "function_description": "Triggers the paste event in the TextMenu, enabling insertion of clipboard content into the associated text widget. This method facilitates handling paste actions within the menu context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_select_all", "line_number": 2198, "body": "def on_select_all(self):\n        self.text.event_generate(\"<<SelectAll>>\")", "is_method": true, "class_name": "TextMenu", "function_description": "Triggers a select-all event on the text component, enabling other functions to programmatically select all content within the TextMenu's text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "can_cut", "line_number": 2201, "body": "def can_cut(self):\n        return self.get_selected_text() and not self.selection_is_read_only()", "is_method": true, "class_name": "TextMenu", "function_description": "Determines whether the currently selected text can be cut by checking if there is a selection and it is not read-only. Useful for enabling or disabling cut operations in text editing interfaces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "can_copy", "line_number": 2204, "body": "def can_copy(self):\n        return self.get_selected_text()", "is_method": true, "class_name": "TextMenu", "function_description": "Utility method of the TextMenu class that checks if there is any selected text available to copy by returning the selected text content if present. It helps determine the copy action's availability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "can_paste", "line_number": 2207, "body": "def can_paste(self):\n        return not self.selection_is_read_only()", "is_method": true, "class_name": "TextMenu", "function_description": "Returns whether the current text selection is editable, indicating if pasting content is allowed. This method supports conditional paste operations based on selection editability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_selected_text", "line_number": 2210, "body": "def get_selected_text(self):\n        try:\n            return self.text.get(\"sel.first\", \"sel.last\")\n        except TclError:\n            return \"\"", "is_method": true, "class_name": "TextMenu", "function_description": "Core utility method of the TextMenu class that retrieves the currently selected text from a text widget, returning an empty string if no selection exists. It facilitates accessing user-highlighted content within the interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "selection_is_read_only", "line_number": 2216, "body": "def selection_is_read_only(self):\n        if hasattr(self.text, \"is_read_only\"):\n            return self.text.is_read_only()\n\n        return False", "is_method": true, "class_name": "TextMenu", "function_description": "Checks if the current text selection is read-only, indicating whether edits are allowed. Useful for enforcing editing restrictions in text-based interfaces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "wrap_with_parent_checker", "line_number": 2290, "body": "def wrap_with_parent_checker(original):\n        def wrapper(*args, **options):\n            _check_dialog_parent(options)\n            return original(*args, **options)\n\n        return wrapper", "is_method": false, "function_description": "Utility function that decorates another function to ensure a parent dialog check is performed before execution, supporting safe invocation within dialog-based workflows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "enter", "line_number": 182, "body": "def enter(event):\n            label_widget.state((\"active\",))\n\n            # Don't know how to open this menu when another menu is open\n            # another tk_popup just doesn't work unless old menu is closed by click or Esc\n            # https://stackoverflow.com/questions/38081470/is-there-a-way-to-know-if-tkinter-optionmenu-dropdown-is-active\n            # unpost doesn't work in Win and Mac: https://www.tcl.tk/man/tcl8.5/TkCmd/menu.htm#M62\n            # print(\"ENTER\", menu, self._opened_menu)\n            if self._opened_menu is not None:\n                self._opened_menu.unpost()\n                click(event)", "is_method": true, "class_name": "CustomMenubar", "function_description": "Handles mouse or keyboard enter events on the menubar, activating the associated label widget and managing the visibility of overlapping menus to ensure only one menu is displayed at a time."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "leave", "line_number": 194, "body": "def leave(event):\n            label_widget.state((\"!active\",))", "is_method": true, "class_name": "CustomMenubar", "function_description": "Clears the active state of a label widget when the mouse pointer leaves its area, typically used to update visual feedback in a custom menu bar interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "work", "line_number": 1635, "body": "def work():\n            self._copy_progess = 0\n\n            with open(self._source, \"rb\") as fsrc:\n                with open(self._destination, \"wb\") as fdst:\n                    while True:\n                        buf = fsrc.read(16 * 1024)\n                        if not buf:\n                            break\n\n                        fdst.write(buf)\n                        fdst.flush()\n                        if self._fsync:\n                            os.fsync(fdst)\n                        self._bytes_copied += len(buf)\n\n            self._done = True", "is_method": true, "class_name": "FileCopyDialog", "function_description": "Method of FileCopyDialog that performs the file copying process from source to destination, tracking progress and optionally ensuring data is physically written to disk. It facilitates file transfer with progress monitoring and data integrity options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_compute_thonny_user_dir", "line_number": 11, "body": "def _compute_thonny_user_dir():\n    if os.environ.get(\"THONNY_USER_DIR\", \"\"):\n        return os.path.expanduser(os.environ[\"THONNY_USER_DIR\"])\n    elif is_portable():\n        if platform.system() == \"Windows\":\n            root_dir = os.path.dirname(sys.executable)\n        elif platform.system() == \"Darwin\":\n            root_dir = os.path.join(\n                os.path.dirname(sys.executable), \"..\", \"..\", \"..\", \"..\", \"..\", \"..\"\n            )\n        else:\n            root_dir = os.path.join(os.path.dirname(sys.executable), \"..\")\n        return os.path.normpath(os.path.abspath(os.path.join(root_dir, \"user_data\")))\n    elif (\n        hasattr(sys, \"base_prefix\")\n        and sys.base_prefix != sys.prefix\n        or hasattr(sys, \"real_prefix\")\n        and getattr(sys, \"real_prefix\") != sys.prefix\n    ):\n        # we're in a virtualenv or venv\n        return os.path.join(sys.prefix, \".thonny\")\n    elif platform.system() == \"Windows\":\n        from thonny import misc_utils\n\n        return os.path.join(misc_utils.get_roaming_appdata_dir(), \"Thonny\")\n    elif platform.system() == \"Darwin\":\n        return os.path.expanduser(\"~/Library/Thonny\")\n    else:\n        # https://specifications.freedesktop.org/basedir-spec/latest/ar01s02.html\n        data_home = os.environ.get(\n            \"XDG_CONFIG_HOME\", os.path.expanduser(os.path.join(\"~\", \".config\"))\n        )\n        return os.path.join(data_home, \"Thonny\")", "is_method": false, "function_description": "Internal utility function that determines and returns the appropriate user directory path for storing Thonny application data, adapting to environment variables, platform, and virtual environment contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_read_configured_debug_mode", "line_number": 46, "body": "def _read_configured_debug_mode():\n    if not os.path.exists(CONFIGURATION_FILE):\n        return False\n\n    try:\n        with open(CONFIGURATION_FILE, encoding=\"utf-8\") as fp:\n            for line in fp:\n                if \"debug_mode\" in line and \"True\" in line:\n                    return True\n        return False\n    except Exception:\n        import traceback\n\n        traceback.print_exc()\n        return False", "is_method": false, "function_description": "Utility function that checks a configuration file to determine if debug mode is enabled, returning True if so and False otherwise. It supports conditional debugging based on external configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "is_portable", "line_number": 63, "body": "def is_portable():\n    # it can be explicitly declared as portable or shared ...\n    portable_marker_path = os.path.join(os.path.dirname(sys.executable), \"portable_thonny.ini\")\n    shared_marker_path = os.path.join(os.path.dirname(sys.executable), \"shared_thonny.ini\")\n\n    if os.path.exists(portable_marker_path) and not os.path.exists(shared_marker_path):\n        return True\n    elif not os.path.exists(portable_marker_path) and os.path.exists(shared_marker_path):\n        return False\n\n    # ... or it becomes implicitly portable if it's on a removable drive\n    abs_location = os.path.abspath(__file__)\n    if platform.system() == \"Windows\":\n        drive = os.path.splitdrive(abs_location)[0]\n        if drive.endswith(\":\"):\n            from ctypes import windll\n\n            return windll.kernel32.GetDriveTypeW(drive) == 2  # @UndefinedVariable\n        else:\n            return False\n    elif platform.system() == \"Darwin\":\n        # not exact heuristics\n        return abs_location.startswith(\"/Volumes/\")\n    else:\n        # not exact heuristics\n        return abs_location.startswith(\"/media/\") or abs_location.startswith(\"/mnt/\")", "is_method": false, "function_description": "Determines if the current environment is running a portable version of the application by checking explicit marker files or inferred from the installation location on removable drives. Useful for adapting behavior based on app portability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "get_version", "line_number": 91, "body": "def get_version():\n    try:\n        package_dir = os.path.dirname(sys.modules[\"thonny\"].__file__)\n        with open(os.path.join(package_dir, \"VERSION\"), encoding=\"ASCII\") as fp:\n            return fp.read().strip()\n    except Exception:\n        return \"0.0.0\"", "is_method": false, "function_description": "Function that retrieves the current version string of the software package, returning a default \"0.0.0\" if the version information is unavailable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "get_ipc_file_path", "line_number": 108, "body": "def get_ipc_file_path():\n    global _IPC_FILE\n    if _IPC_FILE:\n        return _IPC_FILE\n\n    from thonny import misc_utils\n\n    if platform.system() == \"Windows\":\n        base_dir = misc_utils.get_local_appdata_dir()\n    else:\n        base_dir = os.environ.get(\"XDG_RUNTIME_DIR\")\n        if not base_dir or not os.path.exists(base_dir):\n            base_dir = os.environ.get(\"TMPDIR\")\n\n    if not base_dir or not os.path.exists(base_dir):\n        base_dir = THONNY_USER_DIR\n\n    for name in (\"LOGNAME\", \"USER\", \"LNAME\", \"USERNAME\"):\n        if name in os.environ:\n            username = os.environ.get(name)\n            break\n    else:\n        username = os.path.basename(os.path.expanduser(\"~\"))\n\n    ipc_dir = os.path.join(base_dir, \"thonny-%s\" % username)\n    os.makedirs(ipc_dir, exist_ok=True)\n\n    if not platform.system() == \"Windows\":\n        os.chmod(ipc_dir, 0o700)\n\n    _IPC_FILE = os.path.join(ipc_dir, \"ipc.sock\")\n    return _IPC_FILE", "is_method": false, "function_description": "Function that determines and returns the file path for an inter-process communication (IPC) socket, creating necessary directories with appropriate permissions based on the operating system and user environment. It ensures a consistent, user-specific IPC location for Thonny processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_check_welcome", "line_number": 142, "body": "def _check_welcome():\n    from thonny import misc_utils\n\n    if not os.path.exists(CONFIGURATION_FILE) and not misc_utils.running_on_rpi():\n        from thonny.config import ConfigurationManager\n        from thonny.first_run import FirstRunWindow\n\n        mgr = ConfigurationManager(CONFIGURATION_FILE)\n\n        win = FirstRunWindow(mgr)\n        win.mainloop()\n        return win.ok\n    else:\n        return True", "is_method": false, "function_description": "Helper function that verifies if the welcome setup has been completed by checking configuration and system environment, and triggers an initial setup window if necessary. It ensures the application is properly initialized on first run."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "launch", "line_number": 158, "body": "def launch():\n    import runpy\n    import socket\n\n    if sys.executable.endswith(\"thonny.exe\"):\n        # otherwise some library may try to run its subprocess with thonny.exe\n        # NB! Must be pythonw.exe not python.exe, otherwise Runner thinks console\n        # is already allocated.\n        sys.executable = sys.executable[: -len(\"thonny.exe\")] + \"pythonw.exe\"\n\n    set_dpi_aware()\n\n    try:\n        runpy.run_module(\"thonny.customize\", run_name=\"__main__\")\n    except ImportError:\n        pass\n\n    prepare_thonny_user_dir()\n    _configure_frontend_logging()\n\n    if not _check_welcome():\n        return 0\n\n    if _should_delegate():\n        try:\n            _delegate_to_existing_instance(sys.argv[1:])\n            print(\"Delegated to an existing Thonny instance. Exiting now.\")\n            return 0\n        except (ConnectionRefusedError, socket.timeout):\n            pass\n\n    # Did not or could not delegate\n\n    try:\n        from thonny import workbench\n\n        bench = workbench.Workbench()\n        try:\n            bench.mainloop()\n        except SystemExit:\n            bench.destroy()\n        return 0\n\n    except SystemExit as e:\n        from tkinter import messagebox, _default_root\n\n        messagebox.showerror(\"System exit\", str(e), master=_default_root)\n        return -1\n\n    except Exception:\n        from logging import exception\n\n        exception(\"Internal launch or mainloop error\")\n        from thonny import ui_utils\n\n        dlg = ui_utils.LongTextDialog(\"Internal error\", traceback.format_exc())\n        ui_utils.show_dialog(dlg, get_workbench())\n        return -1\n    finally:\n        runner = get_runner()\n        if runner is not None:\n            runner.destroy_backend()\n\n    return 0", "is_method": false, "function_description": "Function that initializes and launches the main application environment, managing configuration, user interface setup, and delegation to existing instances for the Thonny IDE."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "prepare_thonny_user_dir", "line_number": 224, "body": "def prepare_thonny_user_dir():\n    if not os.path.exists(THONNY_USER_DIR):\n        os.makedirs(THONNY_USER_DIR, mode=0o700, exist_ok=True)\n\n        # user_dir_template is a post-installation means for providing\n        # alternative default user environment in multi-user setups\n        template_dir = os.path.join(os.path.dirname(__file__), \"user_dir_template\")\n\n        if os.path.isdir(template_dir):\n            import shutil\n\n            def copy_contents(src_dir, dest_dir):\n                # I want the copy to have current user permissions\n                for name in os.listdir(src_dir):\n                    src_item = os.path.join(src_dir, name)\n                    dest_item = os.path.join(dest_dir, name)\n                    if os.path.isdir(src_item):\n                        os.makedirs(dest_item, mode=0o700)\n                        copy_contents(src_item, dest_item)\n                    else:\n                        shutil.copyfile(src_item, dest_item)\n                        os.chmod(dest_item, 0o600)\n\n            copy_contents(template_dir, THONNY_USER_DIR)", "is_method": false, "function_description": "Creates a secure user directory for Thonny if it doesn't exist, optionally populating it with default files from a template for consistent multi-user setups."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_should_delegate", "line_number": 250, "body": "def _should_delegate():\n    if not os.path.exists(get_ipc_file_path()):\n        # no previous instance\n        return False\n\n    from thonny.config import try_load_configuration\n\n    configuration_manager = try_load_configuration(CONFIGURATION_FILE)\n    configuration_manager.set_default(\"general.single_instance\", SINGLE_INSTANCE_DEFAULT)\n    return configuration_manager.get_option(\"general.single_instance\")", "is_method": false, "function_description": "Checks whether the current process should delegate to an existing instance based on the presence of an IPC file and a configuration option controlling single-instance behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_delegate_to_existing_instance", "line_number": 262, "body": "def _delegate_to_existing_instance(args):\n    import socket\n\n    from thonny import workbench\n\n    transformed_args = []\n    for arg in args:\n        if not arg.startswith(\"-\"):\n            arg = os.path.abspath(arg)\n\n        transformed_args.append(arg)\n\n    try:\n        sock, secret = _create_client_socket()\n    except (ConnectionRefusedError, socket.timeout):\n        # Maybe the lock is abandoned\n        os.remove(get_ipc_file_path())\n        raise\n\n    data = repr((secret, transformed_args)).encode(encoding=\"utf_8\")\n\n    sock.settimeout(2.0)\n    sock.sendall(data)\n    sock.shutdown(socket.SHUT_WR)\n    response = bytes([])\n    while len(response) < len(workbench.SERVER_SUCCESS):\n        new_data = sock.recv(2)\n        if len(new_data) == 0:\n            break\n        else:\n            response += new_data\n\n    if response.decode(\"UTF-8\") != workbench.SERVER_SUCCESS:\n        raise RuntimeError(\"Unsuccessful delegation\")", "is_method": false, "function_description": "Utility function that forwards command-line arguments to an existing running instance via inter-process communication, facilitating command delegation and preventing multiple parallel instances."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_create_client_socket", "line_number": 298, "body": "def _create_client_socket():\n    import socket\n\n    timeout = 2.0\n\n    if platform.system() == \"Windows\":\n        with open(get_ipc_file_path(), \"r\") as fp:\n            port = int(fp.readline().strip())\n            secret = fp.readline().strip()\n\n        # \"localhost\" can be much slower than \"127.0.0.1\"\n        client_socket = socket.create_connection((\"127.0.0.1\", port), timeout=timeout)\n    else:\n        client_socket = socket.socket(socket.AF_UNIX)  # @UndefinedVariable\n        client_socket.settimeout(timeout)\n        client_socket.connect(get_ipc_file_path())\n        secret = \"\"\n\n    return client_socket, secret", "is_method": false, "function_description": "Function that establishes and returns a client socket connected to a local IPC endpoint, handling platform-specific connection details. It also retrieves a secret token on Windows for authentication or secure communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_configure_frontend_logging", "line_number": 319, "body": "def _configure_frontend_logging() -> None:\n    _configure_logging(\"frontend.log\")", "is_method": false, "function_description": "Configures logging specifically for frontend operations by setting up logging output to a designated frontend log file. It facilitates tracking and debugging frontend-related events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "configure_backend_logging", "line_number": 323, "body": "def configure_backend_logging() -> None:\n    _configure_logging(\"backend.log\", logging.WARNING)", "is_method": false, "function_description": "Sets up logging to record warning and higher level messages to the backend.log file, providing standardized backend logging configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_configure_logging", "line_number": 327, "body": "def _configure_logging(filename, console_level=None):\n    logFormatter = logging.Formatter(\"%(levelname)-7s %(name)s: %(message)s\")\n\n    # NB! Don't mess with the root logger, because (CPython) backend runs user code\n    thonny_root_logger = logging.getLogger(\"thonny\")\n    thonny_root_logger.setLevel(_choose_logging_level())\n    thonny_root_logger.propagate = False  # otherwise it will be also reported by IDE-s root logger\n\n    log_file = os.path.join(THONNY_USER_DIR, filename)\n    file_handler = logging.FileHandler(log_file, encoding=\"UTF-8\", mode=\"w\")\n    file_handler.setFormatter(logFormatter)\n    thonny_root_logger.addHandler(file_handler)\n\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setFormatter(logFormatter)\n    if console_level is None:\n        console_level = _choose_logging_level()\n    console_handler.setLevel(console_level)\n    thonny_root_logger.addHandler(console_handler)\n\n    thonny_root_logger.info(\"Thonny version: %s\", get_version())\n\n    import faulthandler\n\n    fault_out = open(os.path.join(THONNY_USER_DIR, \"frontend_faults.log\"), mode=\"w\")\n    faulthandler.enable(fault_out)", "is_method": false, "function_description": "Sets up logging for the Thonny environment by configuring file and console log handlers with appropriate formats and levels, also enabling fault logging to capture runtime faults for debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "set_dpi_aware", "line_number": 355, "body": "def set_dpi_aware():\n    # https://stackoverflow.com/questions/36134072/setprocessdpiaware-seems-not-to-work-under-windows-10\n    # https://bugs.python.org/issue33656\n    # https://msdn.microsoft.com/en-us/library/windows/desktop/dn280512(v=vs.85).aspx\n    # https://github.com/python/cpython/blob/master/Lib/idlelib/pyshell.py\n    if sys.platform == \"win32\":\n        try:\n            import ctypes\n\n            PROCESS_SYSTEM_DPI_AWARE = 1\n            ctypes.OleDLL(\"shcore\").SetProcessDpiAwareness(PROCESS_SYSTEM_DPI_AWARE)\n        except (ImportError, AttributeError, OSError):\n            pass", "is_method": false, "function_description": "Sets the Windows process DPI awareness to system DPI for improved display scaling on high-resolution screens, enhancing GUI clarity in Windows applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "get_workbench", "line_number": 381, "body": "def get_workbench() -> \"Workbench\":\n    return cast(\"Workbench\", _workbench)", "is_method": false, "function_description": "Returns the current global Workbench instance for use in managing or interacting with the workbench environment throughout the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "set_logging_level", "line_number": 388, "body": "def set_logging_level(level=None):\n    if level is None:\n        level = _choose_logging_level()\n\n    logging.getLogger(\"thonny\").setLevel(level)", "is_method": false, "function_description": "Sets the logging verbosity level for the \"thonny\" logger, optionally determining the level automatically if not specified. This function enables control over logging output detail in the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_choose_logging_level", "line_number": 395, "body": "def _choose_logging_level():\n    if in_debug_mode():\n        return logging.DEBUG\n    else:\n        return logging.INFO", "is_method": false, "function_description": "Determines the appropriate logging level based on the application's debug status, enabling dynamic control of log verbosity for development or production environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "in_debug_mode", "line_number": 402, "body": "def in_debug_mode() -> bool:\n    # Value may be something other than string when it is set in Python code\n    return (\n        os.environ.get(\"THONNY_DEBUG\", False)\n        in [\n            \"1\",\n            1,\n            \"True\",\n            True,\n            \"true\",\n        ]\n        or _CONFIGURED_DEBUG\n    )", "is_method": false, "function_description": "Utility function that checks if the application is currently running in debug mode by examining specific environment variables and internal debug configurations. This enables conditional debugging behaviors in other parts of the program."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "get_runner", "line_number": 417, "body": "def get_runner() -> \"Runner\":\n    return cast(\"Runner\", _runner)", "is_method": false, "function_description": "Returns the current Runner instance, providing access to its functionality for coordinating execution or tasks within the system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "get_shell", "line_number": 421, "body": "def get_shell() -> \"ShellView\":\n    return cast(\"ShellView\", get_workbench().get_view(\"ShellView\"))", "is_method": false, "function_description": "Utility function that retrieves the current ShellView instance from the workbench, enabling other components to interact with the shell interface easily."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "copy_contents", "line_number": 235, "body": "def copy_contents(src_dir, dest_dir):\n                # I want the copy to have current user permissions\n                for name in os.listdir(src_dir):\n                    src_item = os.path.join(src_dir, name)\n                    dest_item = os.path.join(dest_dir, name)\n                    if os.path.isdir(src_item):\n                        os.makedirs(dest_item, mode=0o700)\n                        copy_contents(src_item, dest_item)\n                    else:\n                        shutil.copyfile(src_item, dest_item)\n                        os.chmod(dest_item, 0o600)", "is_method": false, "function_description": "Copies all files and directories from a source to a destination, setting permissions to restrict access to the current user. Useful for securely duplicating directory contents with controlled access rights."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "delete_dir_try_hard", "line_number": 18, "body": "def delete_dir_try_hard(path: str, hardness: int = 5) -> None:\n    # Deleting the folder on Windows is not so easy task\n    # http://bugs.python.org/issue15496\n    import shutil\n\n    for i in range(hardness):\n        if os.path.exists(path):\n            time.sleep(i * 0.5)\n            shutil.rmtree(path, True)\n        else:\n            break\n\n    if os.path.exists(path):\n        # try once more but now without ignoring errors\n        shutil.rmtree(path, False)", "is_method": false, "function_description": "Function that attempts to reliably delete a directory by repeatedly trying with increasing delays, ensuring removal even under difficult conditions like Windows file-locking issues. It provides a robust deletion capability useful for cleanup tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "running_on_windows", "line_number": 35, "body": "def running_on_windows() -> bool:\n    return platform.system() == \"Windows\"", "is_method": false, "function_description": "Utility function that determines if the current operating system is Windows, enabling platform-specific behavior or conditional execution in other functions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "running_on_mac_os", "line_number": 39, "body": "def running_on_mac_os() -> bool:\n    return platform.system() == \"Darwin\"", "is_method": false, "function_description": "Utility function that determines if the current operating system is macOS, enabling conditional behavior or platform-specific handling in cross-platform applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "running_on_linux", "line_number": 43, "body": "def running_on_linux() -> bool:\n    return platform.system() == \"Linux\"", "is_method": false, "function_description": "Utility function that detects if the current operating system is Linux, enabling OS-specific behavior in other functions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "running_on_rpi", "line_number": 47, "body": "def running_on_rpi() -> bool:\n    return running_on_linux() and (\n        platform.uname().machine.lower().startswith(\"arm\")\n        or os.environ.get(\"DESKTOP_SESSION\") == \"LXDE-pi\"\n    )", "is_method": false, "function_description": "This function determines if the current environment is a Raspberry Pi by checking for a Linux OS and ARM architecture or a specific desktop session. It helps other functions adapt behavior based on running on Raspberry Pi hardware."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "list_volumes", "line_number": 54, "body": "def list_volumes(skip_letters=set()) -> Sequence[str]:\n    \"Adapted from https://github.com/ntoll/uflash/blob/master/uflash.py\"\n    if sys.platform == \"win32\":\n        import ctypes\n\n        #\n        # In certain circumstances, volumes are allocated to USB\n        # storage devices which cause a Windows popup to raise if their\n        # volume contains no media. Wrapping the check in SetErrorMode\n        # with SEM_FAILCRITICALERRORS (1) prevents this popup.\n        #\n        old_mode = ctypes.windll.kernel32.SetErrorMode(1)  # @UndefinedVariable\n        try:\n            volumes = []\n            for disk in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                if disk in skip_letters:\n                    continue\n                path = \"{}:\\\\\".format(disk)\n                if os.path.exists(path):\n                    volumes.append(path)\n\n            return volumes\n        finally:\n            ctypes.windll.kernel32.SetErrorMode(old_mode)  # @UndefinedVariable\n    else:\n        # 'posix' means we're on Linux or OSX (Mac).\n        # Call the unix \"mount\" command to list the mounted volumes.\n        mount_output = subprocess.check_output(\"mount\").splitlines()\n        return [x.split()[2].decode(\"utf-8\") for x in mount_output]", "is_method": false, "function_description": "Function that lists available mounted storage volumes on the system, optionally skipping specified drive letters on Windows. It supports cross-platform volume discovery for tasks involving drive access or monitoring."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_win_volume_name", "line_number": 85, "body": "def get_win_volume_name(path: str) -> str:\n    \"\"\"\n    Each disk or external device connected to windows has an attribute\n    called \"volume name\". This function returns the volume name for\n    the given disk/device.\n    Code from http://stackoverflow.com/a/12056414\n    \"\"\"\n    if sys.platform == \"win32\":\n        import ctypes\n\n        vol_name_buf = ctypes.create_unicode_buffer(1024)\n        ctypes.windll.kernel32.GetVolumeInformationW(  # @UndefinedVariable\n            ctypes.c_wchar_p(path),\n            vol_name_buf,\n            ctypes.sizeof(vol_name_buf),\n            None,\n            None,\n            None,\n            None,\n            0,\n        )\n        assert isinstance(vol_name_buf.value, str)\n        return vol_name_buf.value\n    else:\n        raise RuntimeError(\"Only meant for Windows\")", "is_method": false, "function_description": "Function that returns the volume label of a specified disk or device on Windows systems, aiding identification of storage devices by their user-friendly names."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "find_volumes_by_name", "line_number": 112, "body": "def find_volumes_by_name(volume_name: str, skip_letters={\"A\"}) -> Sequence[str]:\n    volumes = list_volumes(skip_letters=skip_letters)\n    if os.name == \"nt\":\n        return [\n            volume\n            for volume in volumes\n            if get_win_volume_name(volume).upper() == volume_name.upper()\n        ]\n    else:\n        return [volume for volume in volumes if volume.endswith(volume_name)]", "is_method": false, "function_description": "Function that returns a list of system volumes matching a given name, with optional filtering of volumes by skipped initial letters. It supports both Windows and non-Windows environments for volume name matching."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "find_volume_by_name", "line_number": 124, "body": "def find_volume_by_name(\n    volume_name: str,\n    not_found_msg: Optional[str] = None,\n    found_several_msg: Optional[str] = None,\n    parent=None,\n) -> Optional[str]:\n    from thonny.languages import tr\n\n    # Can't translate in the header as _ may not be available at import time\n    if not_found_msg is None:\n        not_found_msg = tr(\"Could not find disk '%s'. Do you want to locate it yourself?\")\n\n    if found_several_msg is None:\n        found_several_msg = tr(\"Found several '%s' disks. Do you want to choose one yourself?\")\n\n    volumes = find_volumes_by_name(volume_name)\n    if len(volumes) == 1:\n        return volumes[0]\n    else:\n        if len(volumes) == 0:\n            msg = not_found_msg % volume_name\n        else:\n            msg = found_several_msg % volume_name\n\n        import tkinter as tk\n        from tkinter.messagebox import askyesno\n\n        from thonny.ui_utils import askdirectory\n\n        if askyesno(tr(\"Can't find suitable disk\"), msg, master=parent):\n            path = askdirectory(parent=parent)\n            if path:\n                return path\n\n    return None", "is_method": false, "function_description": "Function that locates a disk volume by name, returning its path if uniquely found. If none or multiple matches exist, it prompts the user to manually locate or choose the correct volume interactively."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "shorten_repr", "line_number": 161, "body": "def shorten_repr(original_repr: str, max_len: int = 1000) -> str:\n    if len(original_repr) > max_len:\n        return original_repr[: max_len - 1] + \"\u2026\"\n    else:\n        return original_repr", "is_method": false, "function_description": "Function that truncates a string representation to a specified maximum length, appending an ellipsis if the original exceeds that limit. Useful for concise display of lengthy text or object representations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "_win_get_used_memory", "line_number": 168, "body": "def _win_get_used_memory():\n    # http://code.activestate.com/recipes/578513-get-memory-usage-of-windows-processes-using-getpro/\n    import ctypes\n    from ctypes import wintypes\n\n    GetCurrentProcess = ctypes.windll.kernel32.GetCurrentProcess\n    GetCurrentProcess.argtypes = []\n    GetCurrentProcess.restype = wintypes.HANDLE\n\n    SIZE_T = ctypes.c_size_t\n\n    class PROCESS_MEMORY_COUNTERS_EX(ctypes.Structure):\n        _fields_ = [\n            (\"cb\", wintypes.DWORD),\n            (\"PageFaultCount\", wintypes.DWORD),\n            (\"PeakWorkingSetSize\", SIZE_T),\n            (\"WorkingSetSize\", SIZE_T),\n            (\"QuotaPeakPagedPoolUsage\", SIZE_T),\n            (\"QuotaPagedPoolUsage\", SIZE_T),\n            (\"QuotaPeakNonPagedPoolUsage\", SIZE_T),\n            (\"QuotaNonPagedPoolUsage\", SIZE_T),\n            (\"PagefileUsage\", SIZE_T),\n            (\"PeakPagefileUsage\", SIZE_T),\n            (\"PrivateUsage\", SIZE_T),\n        ]\n\n    GetProcessMemoryInfo = ctypes.windll.psapi.GetProcessMemoryInfo\n    GetProcessMemoryInfo.argtypes = [\n        wintypes.HANDLE,\n        ctypes.POINTER(PROCESS_MEMORY_COUNTERS_EX),\n        wintypes.DWORD,\n    ]\n    GetProcessMemoryInfo.restype = wintypes.BOOL\n\n    def get_current_process():\n        \"\"\"Return handle to current process.\"\"\"\n        return GetCurrentProcess()\n\n    def get_memory_info(process=None):\n        \"\"\"Return Win32 process memory counters structure as a dict.\"\"\"\n        if process is None:\n            process = get_current_process()\n        counters = PROCESS_MEMORY_COUNTERS_EX()\n        ret = GetProcessMemoryInfo(process, ctypes.byref(counters), ctypes.sizeof(counters))\n        if not ret:\n            raise ctypes.WinError()\n        info = dict((name, getattr(counters, name)) for name, _ in counters._fields_)\n        return info\n\n    return get_memory_info()[\"PrivateUsage\"]", "is_method": false, "function_description": "Utility function that returns the amount of private memory currently used by the running Windows process, useful for monitoring and managing process memory consumption."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "construct_cmd_line", "line_number": 225, "body": "def construct_cmd_line(parts, safe_tokens=[]) -> str:\n    def quote(s):\n        if s in safe_tokens:\n            return s\n        else:\n            return shlex.quote(s)\n\n    return \" \".join(map(quote, parts))", "is_method": false, "function_description": "Utility function that safely constructs a shell command line string from components, selectively quoting tokens to prevent shell injection vulnerabilities while allowing specified safe tokens unquoted."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "user_friendly_python_command_line", "line_number": 235, "body": "def user_friendly_python_command_line(cmd):\n    if \"-m\" in cmd:\n        cmd = cmd[cmd.index(\"-m\") + 1 :]\n\n    lines = [\"\"]\n    for item in cmd:\n        if lines[-1] and len(lines[-1] + \" \" + item) > 60:\n            lines.append(\"\")\n        lines[-1] = (lines[-1] + \" \" + item).strip()\n\n    return \"\\n\".join(lines)\n\n    return subprocess.list2cmdline(cmd)", "is_method": false, "function_description": "Converts a list of Python command-line arguments into a neatly formatted, user-friendly multiline string for improved readability, splitting lines at around 60 characters."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "parse_cmd_line", "line_number": 250, "body": "def parse_cmd_line(s):\n    return shlex.split(s, posix=True)", "is_method": false, "function_description": "Parses a command line string into a list of arguments, handling quotes and escape characters according to POSIX shell syntax. Useful for processing and tokenizing command input in shell-like applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "levenshtein_distance", "line_number": 254, "body": "def levenshtein_distance(s1, s2):\n    # https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#Python\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)  # pylint: disable=arguments-out-of-order\n\n    # len(s1) >= len(s2)\n    if len(s2) == 0:\n        return len(s1)\n\n    previous_row = range(len(s2) + 1)\n    for i, c1 in enumerate(s1):\n        current_row = [i + 1]\n        for j, c2 in enumerate(s2):\n            insertions = (\n                previous_row[j + 1] + 1\n            )  # j+1 instead of j since previous_row and current_row are one character longer\n            deletions = current_row[j] + 1  # than s2\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n\n    return previous_row[-1]", "is_method": false, "function_description": "Function that calculates the minimum number of single-character edits required to change one string into another, useful for measuring string similarity or spelling correction tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "levenshtein_damerau_distance", "line_number": 278, "body": "def levenshtein_damerau_distance(s1, s2, maxDistance):\n    # https://gist.github.com/giststhebearbear/4145811\n    #  get smallest string so our rows are minimized\n    s1, s2 = (s1, s2) if len(s1) <= len(s2) else (s2, s1)\n    #  set lengths\n    l1, l2 = len(s1), len(s2)\n\n    #  We are simulatng an NM matrix where n is the longer string\n    #  and m is the shorter string. By doing this we can minimize\n    #  memory usage to O(M).\n    #  Since we are simulating the matrix we only maintain two rows\n    #  at a time the current row and the previous rows.\n    #  A move from the current cell looking at the cell before it indicates\n    #  consideration of an insert operation.\n    #  A move from the current cell looking at the cell above it indicates\n    #  consideration of a deletion\n    #  Both operations are cost 1\n    #  A move from the current cell to the cell up and to the left indicates\n    #  an edit operation of 0 cost for a matching character and a 1 cost for\n    #  a non matching characters\n    #  no row has been previously computed yet, set empty row\n    #  Since this is also a Damerou-Levenshtein calculation transposition\n    #  costs will be taken into account. These look back 2 characters to\n    #  determine optimal cost based on a possible transposition\n    #  example: aei -> aie with levensthein has a cost of 2\n    #  match a, change e->i change i->e => aie\n    #  Damarau-Levenshtein has a cost of 1\n    #  match a, transpose ei to ie => aie\n    transpositionRow = []\n    prevRow = []\n\n    #  build first leven matrix row\n    #  The first row represents transformation from an empty string\n    #  to the shorter string making it static [0-n]\n    #  since this row is static we can set it as\n    #  curRow and start computation at the second row or index 1\n    curRow = list(range(0, l1 + 1))\n\n    # use second length to loop through all the rows being built\n    # we start at row one\n    for rowNum in range(1, l2 + 1):\n        #  set transposition, previous, and current\n        #  because the rowNum always increments by one\n        #  we can use rowNum to set the value representing\n        #  the first column which is indicitive of transforming TO\n        #  the empty string from our longer string\n        #  transposition row maintains an extra row so that it is possible\n        #  for us to apply Damarou's formula\n        transpositionRow, prevRow, curRow = prevRow, curRow, [rowNum] + [0] * l1\n\n        #  consider if we have passed the max distance if all paths through\n        #  the transposition row are larger than the max we can stop calculating\n        #  distance and return the last element in that row and return the max\n        if transpositionRow:\n            if not any(cellValue < maxDistance for cellValue in transpositionRow):\n                return maxDistance\n\n        for colNum in range(1, l1 + 1):\n            insertionCost = curRow[colNum - 1] + 1\n            deletionCost = prevRow[colNum] + 1\n            changeCost = prevRow[colNum - 1] + (0 if s1[colNum - 1] == s2[rowNum - 1] else 1)\n            #  set the cell value - min distance to reach this\n            #  position\n            curRow[colNum] = min(insertionCost, deletionCost, changeCost)\n\n            #  test for a possible transposition optimization\n            #  check to see if we have at least 2 characters\n            if 1 < rowNum <= colNum:\n                #  test for possible transposition\n                if s1[colNum - 1] == s2[colNum - 2] and s2[colNum - 1] == s1[colNum - 2]:\n                    curRow[colNum] = min(curRow[colNum], transpositionRow[colNum - 2] + 1)\n\n    #  the last cell of the matrix is ALWAYS the shortest distance between the two strings\n    return curRow[-1]", "is_method": false, "function_description": "Function that computes the Damerau-Levenshtein distance between two strings with an upper bound cutoff, measuring the minimum edits including transpositions to transform one string into the other. It enables efficient approximate string matching with early termination for large distances."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_file_creation_date", "line_number": 354, "body": "def get_file_creation_date(path_to_file):\n    \"\"\"\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn't possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    \"\"\"\n    if platform.system() == \"Windows\":\n        return os.path.getctime(path_to_file)\n    else:\n        stat = os.stat(path_to_file)\n        try:\n            return stat.st_birthtime\n        except AttributeError:\n            # We're probably on Linux. No easy way to get creation dates here,\n            # so we'll settle for when its content was last modified.\n            return stat.st_mtime", "is_method": false, "function_description": "Function that retrieves a file's creation date on supported platforms, or falls back to the file's last modification date when creation time is unavailable. Useful for tracking or sorting files by their origination time."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "start_time", "line_number": 375, "body": "def start_time(text=\"\"):\n    global _timer_time\n    print(\"RESET\", text)\n    _timer_time = time.time()", "is_method": false, "function_description": "Function that resets a global timer and logs a reset message with an optional text label for tracking elapsed time in processes or operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "lap_time", "line_number": 381, "body": "def lap_time(text=\"\"):\n    global _timer_time\n    new_time = time.time()\n    print(\"LAP\", text, round(new_time - _timer_time, 4))\n    _timer_time = time.time()", "is_method": false, "function_description": "Utility function that prints the elapsed time since the last lap or start, optionally tagging the output with a custom text label to help measure performance intervals."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "copy_to_clipboard", "line_number": 402, "body": "def copy_to_clipboard(data):\n    if running_on_windows():\n        _copy_to_windows_clipboard(data)\n    elif running_on_mac_os():\n        command = [\"pbcopy\"]\n    else:\n        command = [\"xsel\", \"-b\", \"-i\"]\n\n    env = dict(os.environ).copy()\n    encoding = \"utf-8\"\n    env[\"PYTHONIOENCODING\"] = encoding\n\n    if sys.version_info >= (3, 6):\n        extra = {\"encoding\": encoding}\n    else:\n        extra = {}\n\n    proc = subprocess.Popen(\n        command,\n        stdin=subprocess.PIPE,\n        shell=False,\n        env=env,\n        universal_newlines=True,\n        close_fds=True,\n        **extra\n    )\n    proc.communicate(input=data, timeout=0.1)", "is_method": false, "function_description": "Provides a cross-platform utility to copy given text data to the system clipboard, supporting Windows, macOS, and Linux environments. This enables other functions to programmatically place text onto the clipboard for user convenience or inter-process communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "_copy_to_windows_clipboard", "line_number": 431, "body": "def _copy_to_windows_clipboard(data):\n    # https://bugs.python.org/file37366/test_clipboard_win.py\n    import ctypes\n\n    wcscpy = ctypes.cdll.msvcrt.wcscpy\n    OpenClipboard = ctypes.windll.user32.OpenClipboard\n    EmptyClipboard = ctypes.windll.user32.EmptyClipboard\n    SetClipboardData = ctypes.windll.user32.SetClipboardData\n    CloseClipboard = ctypes.windll.user32.CloseClipboard\n    CF_UNICODETEXT = 13\n    GlobalAlloc = ctypes.windll.kernel32.GlobalAlloc\n    GlobalLock = ctypes.windll.kernel32.GlobalLock\n    GlobalUnlock = ctypes.windll.kernel32.GlobalUnlock\n    GMEM_DDESHARE = 0x2000\n\n    OpenClipboard(None)\n    EmptyClipboard()\n    hCd = GlobalAlloc(GMEM_DDESHARE, 2 * (len(data) + 1))\n    pchData = GlobalLock(hCd)\n    wcscpy(ctypes.c_wchar_p(pchData), data)\n    GlobalUnlock(hCd)\n    SetClipboardData(CF_UNICODETEXT, hCd)\n    # ctypes.windll.user32.SetClipboardText(CF_UNICODETEXT, hCd)\n    CloseClipboard()", "is_method": false, "function_description": "Copies a Unicode string to the Windows clipboard, enabling other applications to access the copied text. It provides a low-level method for setting clipboard content on Windows systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "sizeof_fmt", "line_number": 457, "body": "def sizeof_fmt(num, suffix=\"B\"):\n    \"\"\"Readable file size\n    :param num: Bytes value\n    :type num: int\n    :param suffix: Unit suffix (optionnal) default = B\n    :type suffix: str\n    :rtype: str\n    \"\"\"\n    # https://gist.github.com/cbwar/d2dfbc19b140bd599daccbe0fe925597\n    for unit in [\"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\"]:\n        if abs(num) < 1024.0:\n            if unit == \"\":\n                return \"%d %s%s\" % (num, unit, suffix)\n            return \"%.1f %s%s\" % (num, unit, suffix)\n        num /= 1024.0\n    return \"%.1f%s%s\" % (num, \"Yi\", suffix)", "is_method": false, "function_description": "Utility function that converts a byte count into a human-readable file size string with appropriate unit prefixes for easier interpretation of data sizes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "_get_known_folder", "line_number": 475, "body": "def _get_known_folder(ID):\n    # http://stackoverflow.com/a/3859336/261181\n    # http://www.installmate.com/support/im9/using/symbols/functions/csidls.htm\n    import ctypes.wintypes\n\n    SHGFP_TYPE_CURRENT = 0\n    buf = ctypes.create_unicode_buffer(ctypes.wintypes.MAX_PATH)\n    ctypes.windll.shell32.SHGetFolderPathW(0, ID, 0, SHGFP_TYPE_CURRENT, buf)\n    assert buf.value\n    return buf.value", "is_method": false, "function_description": "Utility function that retrieves the full path of a known Windows system folder identified by a given CSIDL ID. It provides access to standard directories like Desktop or Documents for use in file management tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_roaming_appdata_dir", "line_number": 487, "body": "def get_roaming_appdata_dir():\n    return _get_known_folder(26)", "is_method": false, "function_description": "Returns the path to the user's roaming application data directory, enabling applications to access or store user-specific settings and files in a standardized location."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_local_appdata_dir", "line_number": 491, "body": "def get_local_appdata_dir():\n    return _get_known_folder(28)", "is_method": false, "function_description": "Returns the path to the local application data directory specific to the current user. Useful for storing user-specific app data on the local machine."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_current_process", "line_number": 202, "body": "def get_current_process():\n        \"\"\"Return handle to current process.\"\"\"\n        return GetCurrentProcess()", "is_method": false, "function_description": "Returns a handle to the currently executing process, enabling functions to query or manipulate the process at the system level."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_memory_info", "line_number": 206, "body": "def get_memory_info(process=None):\n        \"\"\"Return Win32 process memory counters structure as a dict.\"\"\"\n        if process is None:\n            process = get_current_process()\n        counters = PROCESS_MEMORY_COUNTERS_EX()\n        ret = GetProcessMemoryInfo(process, ctypes.byref(counters), ctypes.sizeof(counters))\n        if not ret:\n            raise ctypes.WinError()\n        info = dict((name, getattr(counters, name)) for name, _ in counters._fields_)\n        return info", "is_method": false, "function_description": "Function retrieves detailed memory usage statistics of a Windows process, returning them as a dictionary. It can report on the current or a specified process's memory consumption, aiding system monitoring or resource management tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "quote", "line_number": 226, "body": "def quote(s):\n        if s in safe_tokens:\n            return s\n        else:\n            return shlex.quote(s)", "is_method": false, "function_description": "Function that conditionally quotes a string based on its presence in a safe tokens set, ensuring secure shell command construction by quoting only when necessary."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "time_spent", "line_number": 394, "body": "def time_spent(self):\n        return time.time() - self.start_time", "is_method": true, "class_name": "TimeHelper", "function_description": "Returns the elapsed time since the object's start time, providing a simple way to measure duration intervals. Useful for tracking execution time or monitoring elapsed periods within processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "time_left", "line_number": 398, "body": "def time_left(self):\n        return max(self.time_allowed - self.time_spent, 0)", "is_method": true, "class_name": "TimeHelper", "function_description": "Returns the remaining allowable time by subtracting time spent from the total allowed, ensuring it never goes below zero. Useful for tracking time limits in timed tasks or processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "_listen_thread", "line_number": 509, "body": "def _listen_thread(self, stream, target_queue: queue.Queue):\n        while True:\n            data = stream.readline()\n            if data == \"\":\n                break\n            target_queue.put(data)", "is_method": true, "class_name": "PopenWithOutputQueues", "function_description": "Private method of PopenWithOutputQueues that continuously reads lines from a given stream and enqueues them into a specified queue until the stream ends. It supports asynchronous collection of subprocess output in real-time."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_syntax_options", "line_number": 367, "body": "def set_syntax_options(syntax_options):\n    global _syntax_options\n    _syntax_options = syntax_options\n    get_workbench().event_generate(\"SyntaxThemeChanged\")", "is_method": false, "function_description": "Function that updates global syntax highlighting options and triggers a system event to notify changes, facilitating dynamic updates to syntax themes across the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_syntax_options_for_tag", "line_number": 373, "body": "def get_syntax_options_for_tag(tag, **base_options):\n    global _syntax_options\n    if tag in _syntax_options:\n        base_options.update(_syntax_options[tag])\n    return base_options", "is_method": false, "function_description": "Function that merges predefined syntax options associated with a given tag into provided base options, facilitating consistent configuration retrieval for tagged elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "tweak_newlines", "line_number": 380, "body": "def tweak_newlines(content):\n    cr_count = len(OLD_MAC_LINEBREAK.findall(content))\n    lf_count = len(UNIX_LINEBREAK.findall(content))\n    crlf_count = len(WINDOWS_LINEBREAK.findall(content))\n\n    if cr_count > 0 and lf_count == 0 and crlf_count == 0:\n        original_newlines = \"\\r\"\n    elif crlf_count > 0 and lf_count == 0 and cr_count == 0:\n        original_newlines = \"\\r\\n\"\n    elif lf_count > 0 and crlf_count == 0 and cr_count == 0:\n        original_newlines = \"\\n\"\n    else:\n        original_newlines = os.linesep\n\n    content = OLD_MAC_LINEBREAK.sub(\"\\n\", content)\n    content = WINDOWS_LINEBREAK.sub(\"\\n\", content)\n\n    return content, original_newlines", "is_method": false, "function_description": "Function that normalizes various newline formats in text to Unix-style newlines while detecting and returning the original newline convention used. Useful for consistent text processing across different operating systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "perform_python_return", "line_number": 400, "body": "def perform_python_return(text: EnhancedText, event):\n    # copied from idlelib.EditorWindow (Python 3.4.2)\n    # slightly modified\n    # pylint: disable=lost-exception\n\n    assert text is event.widget\n    assert isinstance(text, EnhancedText)\n\n    try:\n        # delete selection\n        first, last = text.get_selection_indices()\n        if first and last:\n            text.delete(first, last)\n            text.mark_set(\"insert\", first)\n\n        # Strip whitespace after insert point\n        # (ie. don't carry whitespace from the right of the cursor over to the new line)\n        while text.get(\"insert\") in [\" \", \"\\t\"]:\n            text.delete(\"insert\")\n\n        left_part = text.get(\"insert linestart\", \"insert\")\n        # locate first non-white character\n        i = 0\n        n = len(left_part)\n        while i < n and left_part[i] in \" \\t\":\n            i = i + 1\n\n        # is it only whitespace?\n        if i == n:\n            # start the new line with the same whitespace\n            text.insert(\"insert\", \"\\n\" + left_part)\n            return \"break\"\n\n        # Turned out the left part contains visible chars\n        # Remember the indent\n        indent = left_part[:i]\n\n        # Strip whitespace before insert point\n        # (ie. after inserting the linebreak this line doesn't have trailing whitespace)\n        while text.get(\"insert-1c\", \"insert\") in [\" \", \"\\t\"]:\n            text.delete(\"insert-1c\", \"insert\")\n\n        # start new line\n        text.insert(\"insert\", \"\\n\")\n\n        # adjust indentation for continuations and block\n        # open/close first need to find the last stmt\n        lno = tktextext.index2line(text.index(\"insert\"))\n        y = roughparse.RoughParser(text.indent_width, text.tabwidth)\n\n        for context in roughparse.NUM_CONTEXT_LINES:\n            startat = max(lno - context, 1)\n            startatindex = repr(startat) + \".0\"\n            rawtext = text.get(startatindex, \"insert\")\n            y.set_str(rawtext)\n            bod = y.find_good_parse_start(\n                False, roughparse._build_char_in_string_func(startatindex)\n            )\n            if bod is not None or startat == 1:\n                break\n        y.set_lo(bod or 0)\n\n        c = y.get_continuation_type()\n        if c != roughparse.C_NONE:\n            # The current stmt hasn't ended yet.\n            if c == roughparse.C_STRING_FIRST_LINE:\n                # after the first line of a string; do not indent at all\n                pass\n            elif c == roughparse.C_STRING_NEXT_LINES:\n                # inside a string which started before this line;\n                # just mimic the current indent\n                text.insert(\"insert\", indent)\n            elif c == roughparse.C_BRACKET:\n                # line up with the first (if any) element of the\n                # last open bracket structure; else indent one\n                # level beyond the indent of the line with the\n                # last open bracket\n                text._reindent_to(y.compute_bracket_indent())\n            elif c == roughparse.C_BACKSLASH:\n                # if more than one line in this stmt already, just\n                # mimic the current indent; else if initial line\n                # has a start on an assignment stmt, indent to\n                # beyond leftmost =; else to beyond first chunk of\n                # non-whitespace on initial line\n                if y.get_num_lines_in_stmt() > 1:\n                    text.insert(\"insert\", indent)\n                else:\n                    text._reindent_to(y.compute_backslash_indent())\n            else:\n                assert 0, \"bogus continuation type %r\" % (c,)\n            return \"break\"\n\n        # This line starts a brand new stmt; indent relative to\n        # indentation of initial line of closest preceding\n        # interesting stmt.\n        indent = y.get_base_indent_string()\n        text.insert(\"insert\", indent)\n        if y.is_block_opener():\n            text.perform_smart_tab(event)\n        elif indent and y.is_block_closer():\n            text.perform_smart_backspace(event)\n        return \"break\"\n    finally:\n        text.see(\"insert\")\n        text.event_generate(\"<<NewLine>>\")\n        return \"break\"", "is_method": false, "function_description": "Core utility of the EnhancedText editor that handles inserting a new line with appropriate indentation based on Python syntax, facilitating intelligent code formatting during user input."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "perform_simple_return", "line_number": 508, "body": "def perform_simple_return(text: EnhancedText, event):\n    assert text is event.widget\n    assert isinstance(text, EnhancedText)\n\n    text._log_keypress_for_undo(event)\n\n    try:\n        # delete selection\n        first, last = text.get_selection_indices()\n        if first and last:\n            text.delete(first, last)\n            text.mark_set(\"insert\", first)\n\n        # Strip whitespace after insert point\n        # (ie. don't carry whitespace from the right of the cursor over to the new line)\n        while text.get(\"insert\") in [\" \", \"\\t\"]:\n            text.delete(\"insert\")\n\n        left_part = text.get(\"insert linestart\", \"insert\")\n        # locate first non-white character\n        i = 0\n        n = len(left_part)\n        while i < n and left_part[i] in \" \\t\":\n            i = i + 1\n\n        # start the new line with the same whitespace\n        text.insert(\"insert\", \"\\n\" + left_part[:i])\n        return \"break\"\n\n    finally:\n        text.see(\"insert\")\n        text.event_generate(\"<<NewLine>>\")\n        return \"break\"", "is_method": false, "function_description": "This function handles inserting a new line in an EnhancedText widget, preserving the leading whitespace of the current line and managing text selection and cursor position. It supports text editing features like undo logging and whitespace consistency during newline insertion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_proposed_encodings", "line_number": 547, "body": "def get_proposed_encodings():\n    # https://w3techs.com/technologies/overview/character_encoding\n    result = [\n        \"UTF-8\",\n        \"ISO-8859-1\",\n        \"Windows-1251\",\n        \"Windows-1252\",\n        \"GB2312\",\n        \"Shift JIS\",\n        \"GBK\",\n        \"EUC-KR\",\n        \"ISO-8859-9\",\n        \"Windows-1254\",\n        \"EUC-JP\",\n        \"Big5\",\n        \"ISO-8859-2  \",\n        \"Windows-1250\",\n        \"Windows-874\",\n        \"Windows-1256\",\n        \"ISO-8859-15\",\n        \"US-ASCII\",\n        \"Windows-1255\",\n        \"TIS-620\",\n        \"ISO-8859-7\",\n        \"Windows-1253\",\n        \"UTF-16\",\n        \"KOI8-R\",\n        \"GB18030\",\n        \"Windows-1257\",\n        \"KS C 5601\",\n        \"UTF-7\",\n        \"ISO-8859-8\",\n        \"Windows-31J\",\n        \"ISO-8859-5\",\n        \"ISO-8859-6\",\n        \"ISO-8859-4\",\n        \"ANSI_X3.110-1983\",\n        \"ISO-8859-3\",\n        \"KOI8-U\",\n        \"Big5 HKSCS\",\n        \"ISO-2022-JP\",\n        \"Windows-1258\",\n        \"ISO-8859-13\",\n        \"ISO-8859-14\",\n        \"Windows-949\",\n        \"ISO-8859-10\",\n        \"ISO-8859-11\",\n        \"ISO-8859-16\",\n    ]\n\n    sys_enc = sys.getdefaultencoding()\n    for item in result[:]:\n        if item.lower() == sys_enc.lower():\n            result.remove(item)\n            sys_enc = item\n\n    result.insert(0, sys_enc)\n    return result", "is_method": false, "function_description": "Function that returns a prioritized list of common character encodings, placing the system's default encoding first to support flexible text processing and encoding selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_syntax_options", "line_number": 40, "body": "def set_syntax_options(self, syntax_options):\n        # clear old options\n        for tag_name in self._syntax_options:\n            self.tag_reset(tag_name)\n\n        background = syntax_options.get(\"TEXT\", {}).get(\"background\")\n\n        # apply new options\n        for tag_name in syntax_options:\n            opts = syntax_options[tag_name]\n\n            if tag_name == \"string3\":\n                # Needs explicit background to override uniline tags\n                opts[\"background\"] = background\n\n            if tag_name == \"TEXT\":\n                self.configure(**opts)\n            else:\n                self.tag_configure(tag_name, **opts)\n\n        self._syntax_options = syntax_options\n\n        if \"current_line\" in syntax_options:\n            self.tag_lower(\"current_line\")\n\n        self.tag_raise(\"sel\")\n        self.tag_lower(\"stdout\")", "is_method": true, "class_name": "SyntaxText", "function_description": "Configures and applies syntax highlighting options for text elements, managing visual styles like backgrounds and layering of tags. Enables dynamic updating of syntax appearance in the SyntaxText component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_reload_theme_options", "line_number": 68, "body": "def _reload_theme_options(self, event=None):\n        super()._reload_theme_options(event)\n        self._reload_syntax_options(event)", "is_method": true, "class_name": "SyntaxText", "function_description": "Internal method of SyntaxText that reloads theme and syntax options, typically triggered by an event to update visual or stylistic settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_reload_syntax_options", "line_number": 72, "body": "def _reload_syntax_options(self, event=None):\n        global _syntax_options\n        self.set_syntax_options(_syntax_options)", "is_method": true, "class_name": "SyntaxText", "function_description": "Reloads and applies the global syntax options to the current SyntaxText instance, ensuring its syntax settings are updated. This supports dynamic configuration changes in syntax highlighting behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "destroy", "line_number": 76, "body": "def destroy(self):\n        super().destroy()\n        get_workbench().unbind(\"SyntaxThemeChanged\", self._reload_syntax_options)", "is_method": true, "class_name": "SyntaxText", "function_description": "Method of the SyntaxText class that cleans up resources by calling the parent destroy routine and unregistering its syntax theme change event handler from the workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "perform_return", "line_number": 80, "body": "def perform_return(self, event):\n        if self.file_type == \"python\":\n            return perform_python_return(self, event)\n        else:\n            return perform_simple_return(self, event)", "is_method": true, "class_name": "SyntaxText", "function_description": "Service method of SyntaxText that handles return events by delegating to language-specific return handlers based on the file type, enabling proper return processing for Python and other file types."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "perform_smart_backspace", "line_number": 86, "body": "def perform_smart_backspace(self, event):\n        if self.file_type == \"python\":\n            return EnhancedText.perform_smart_backspace(self, event)\n        else:\n            self._log_keypress_for_undo(event)\n            # let the default action work\n            return", "is_method": true, "class_name": "SyntaxText", "function_description": "Utility method in SyntaxText that handles backspace behavior intelligently for Python files, delegating specialized processing, while falling back to default behavior for other file types with undo logging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "should_indent_with_tabs", "line_number": 94, "body": "def should_indent_with_tabs(self):\n        return get_workbench().get_option(\"edit.indent_with_tabs\")", "is_method": true, "class_name": "SyntaxText", "function_description": "Method of SyntaxText that determines whether code indentation should use tabs based on the current workbench settings. It provides configuration access to guide formatting behavior in editors or IDEs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_file_type", "line_number": 97, "body": "def set_file_type(self, file_type):\n        self.file_type = file_type", "is_method": true, "class_name": "SyntaxText", "function_description": "Sets the file type attribute of a SyntaxText instance. This method allows specifying or updating the file format associated with the text content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "is_python_text", "line_number": 100, "body": "def is_python_text(self):\n        return self.file_type == \"python\"", "is_method": true, "class_name": "SyntaxText", "function_description": "Checks if the current SyntaxText instance represents Python source code by verifying its file type. Useful for conditionally handling or processing Python-specific text content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "update_tabs", "line_number": 103, "body": "def update_tabs(self):\n        tab_chars = 4\n        tab_pixels = tk.font.nametofont(self[\"font\"]).measure(\"n\" * tab_chars)\n        tabs = [tab_pixels]\n        self.configure(tabs=tabs, tabstyle=\"wordprocessor\")", "is_method": true, "class_name": "SyntaxText", "function_description": "Method of SyntaxText that updates tab stop widths based on the current font metrics, ensuring consistent tab spacing in the displayed text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "on_secondary_click", "line_number": 125, "body": "def on_secondary_click(self, event=None):\n        super().on_secondary_click(event)\n        self.mark_set(\"insert\", \"@%d,%d\" % (event.x, event.y))\n\n        menu = get_workbench().get_menu(\"edit\")\n        try:\n            from thonny.plugins.debugger import get_current_debugger\n\n            debugger = get_current_debugger()\n            if debugger is not None:\n                menu = debugger.get_editor_context_menu()\n        except ImportError:\n            pass\n\n        menu.tk_popup(event.x_root, event.y_root)", "is_method": true, "class_name": "CodeViewText", "function_description": "Handles right-click events by setting the text cursor position and displaying the appropriate context menu, adapting to debugger-specific menus when available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_content", "line_number": 173, "body": "def get_content(self):\n        return self.text.get(\"1.0\", \"end-1c\")", "is_method": true, "class_name": "CodeView", "function_description": "Core method of the CodeView class that returns the entire textual content managed by the instance, enabling retrieval of the current code or text for display, processing, or storage."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "detect_encoding", "line_number": 176, "body": "def detect_encoding(self, data):\n        enc = self.detect_encoding_without_check(data)\n        try:\n            codecs.lookup(enc)\n            return enc\n        except LookupError:\n            messagebox.showerror(\n                \"Error\", \"Unknown encoding '%s'. Using utf-8 instead\" % enc, master=self\n            )\n            return \"utf-8\"", "is_method": true, "class_name": "CodeView", "function_description": "Utility method of CodeView that detects the encoding of given data, ensuring it is valid and defaults to \"utf-8\" with error notification if the detected encoding is unknown."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "detect_encoding_without_check", "line_number": 187, "body": "def detect_encoding_without_check(self, data):\n        if self.text.is_python_text():\n            import tokenize\n\n            encoding, _ = tokenize.detect_encoding(io.BytesIO(data).readline)\n            return encoding\n        else:\n            ENCODING_MARKER = re.compile(\n                br\"(charset|coding)[\\t ]*[=: ][\\t ]*[\\\"\\']?([a-z][0-9a-z-_ ]*[0-9a-z])[\\\"\\'\\n\\r\\t ]?\",\n                re.IGNORECASE,\n            )\n\n            for line in data[:1024].splitlines():\n                match = ENCODING_MARKER.search(line)\n                if match and len(match.group(2)) > 2:\n                    return match.group(2).decode(\"ascii\", errors=\"replace\")\n\n            return \"UTF-8\"", "is_method": true, "class_name": "CodeView", "function_description": "Detects the text encoding of given data by using Python-specific tokenization or by searching encoding markers in the data's initial lines, helping to correctly interpret text content without external checks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_file_type", "line_number": 206, "body": "def set_file_type(self, file_type):\n        self.text.set_file_type(file_type)", "is_method": true, "class_name": "CodeView", "function_description": "Sets the syntax highlighting or parsing mode based on the given file type, enabling appropriate code display or analysis within the CodeView."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_content_as_bytes", "line_number": 209, "body": "def get_content_as_bytes(self):\n        content = self.get_content()\n\n        # convert all linebreaks to original format\n        content = OLD_MAC_LINEBREAK.sub(self._original_newlines, content)\n        content = WINDOWS_LINEBREAK.sub(self._original_newlines, content)\n        content = UNIX_LINEBREAK.sub(self._original_newlines, content)\n\n        return content.encode(self.detect_encoding(content.encode(\"ascii\", errors=\"replace\")))", "is_method": true, "class_name": "CodeView", "function_description": "Utility method in CodeView that retrieves the content normalized to original linebreaks and returns it encoded as bytes, preserving the detected character encoding for accurate content representation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_content_as_bytes", "line_number": 219, "body": "def set_content_as_bytes(self, data, keep_undo=False):\n\n        encoding = self.detect_encoding(data)\n        while True:\n            try:\n                chars = data.decode(encoding)\n                if self.looks_like_text(chars):\n                    self.set_content(chars, keep_undo)\n                    return True\n            except UnicodeDecodeError:\n                pass\n\n            encoding = ask_string(\n                \"Bad encoding\",\n                \"Could not read as %s text.\\nYou could try another encoding\" % encoding,\n                initial_value=encoding,\n                options=get_proposed_encodings(),\n                master=self.winfo_toplevel(),\n            )\n            if not encoding:\n                return False", "is_method": true, "class_name": "CodeView", "function_description": "Sets the content from byte data by detecting and validating its text encoding, allowing users to retry with different encodings if decoding fails. It enables reliable conversion of raw bytes into text within the CodeView context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "looks_like_text", "line_number": 241, "body": "def looks_like_text(self, chars):\n        if not chars:\n            return True\n\n        non_text_char_count = 0\n        for ch in chars:\n            if ch in NON_TEXT_CHARS:\n                non_text_char_count += 1\n\n        return non_text_char_count / len(chars) < 0.01", "is_method": true, "class_name": "CodeView", "function_description": "Method of the CodeView class that determines if a given sequence of characters resembles readable text by checking the proportion of non-text characters, useful for distinguishing text from binary or corrupted data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_content", "line_number": 252, "body": "def set_content(self, content, keep_undo=False):\n        content, self._original_newlines = tweak_newlines(content)\n\n        self.text.direct_delete(\"1.0\", tk.END)\n        self.text.direct_insert(\"1.0\", content)\n\n        if not keep_undo:\n            self.text.edit_reset()", "is_method": true, "class_name": "CodeView", "function_description": "Sets the displayed content of the CodeView, normalizing newlines and optionally preserving the undo history. This enables updating the text view with consistent formatting while controlling undo state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_toggle_breakpoint", "line_number": 261, "body": "def _toggle_breakpoint(self, event):\n        index = \"@%d,%d\" % (event.x, event.y)\n        start_index = index + \" linestart\"\n        end_index = index + \" lineend\"\n\n        if self.text.tag_nextrange(\"breakpoint_line\", start_index, end_index):\n            self.text.tag_remove(\"breakpoint_line\", start_index, end_index)\n        else:\n            line_content = self.text.get(start_index, end_index).strip()\n            if line_content and line_content[0] != \"#\":\n                self.text.tag_add(\"breakpoint_line\", start_index, end_index)\n\n        self.update_gutter(clean=True)", "is_method": true, "class_name": "CodeView", "function_description": "Utility method of the CodeView class that toggles breakpoints on code lines when triggered by an event, enabling or disabling breakpoint markers for non-comment lines in the editor's gutter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_clean_selection", "line_number": 275, "body": "def _clean_selection(self):\n        self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n        self._gutter.tag_remove(\"sel\", \"1.0\", \"end\")", "is_method": true, "class_name": "CodeView", "function_description": "Private method of the CodeView class that clears any active text selection and its visual highlight within the text area and associated gutter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_text_changed", "line_number": 279, "body": "def _text_changed(self, event):\n        self.update_gutter(\n            clean=self.text._last_event_changed_line_count\n            and self.text.tag_ranges(\"breakpoint_line\")\n        )", "is_method": true, "class_name": "CodeView", "function_description": "Internal handler in CodeView that updates the gutter display based on text changes, reflecting breakpoint states after user edits."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "compute_gutter_line", "line_number": 285, "body": "def compute_gutter_line(self, lineno, plain=False):\n        if plain:\n            yield str(lineno) + \" \", ()\n        else:\n            visual_line_number = self._first_line_number + lineno - 1\n            linestart = str(visual_line_number) + \".0\"\n\n            yield str(lineno), ()\n\n            if self.text.tag_nextrange(\"breakpoint_line\", linestart, linestart + \" lineend\"):\n                yield BREAKPOINT_SYMBOL, (\"breakpoint\",)\n            else:\n                yield \" \", ()", "is_method": true, "class_name": "CodeView", "function_description": "Generates elements for a code editor's gutter line, including line numbers and breakpoint indicators, to visually represent debugging markers alongside code lines."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "select_range", "line_number": 299, "body": "def select_range(self, text_range):\n        self.text.tag_remove(\"sel\", \"1.0\", tk.END)\n\n        if text_range:\n            if isinstance(text_range, int):\n                # it's line number\n                start = str(text_range - self._first_line_number + 1) + \".0\"\n                end = str(text_range - self._first_line_number + 1) + \".end\"\n            elif isinstance(text_range, TextRange):\n                start = \"%s.%s\" % (\n                    text_range.lineno - self._first_line_number + 1,\n                    text_range.col_offset,\n                )\n                end = \"%s.%s\" % (\n                    text_range.end_lineno - self._first_line_number + 1,\n                    text_range.end_col_offset,\n                )\n            else:\n                assert isinstance(text_range, tuple)\n                start, end = text_range\n\n            self.text.tag_add(\"sel\", start, end)\n            if isinstance(text_range, int):\n                self.text.mark_set(\"insert\", end)\n            self.text.see(\"%s -1 lines\" % start)", "is_method": true, "class_name": "CodeView", "function_description": "Selects and highlights a specified range of text within the CodeView, supporting line numbers, text range objects, or explicit coordinates to focus and scroll to that segment in the displayed code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_breakpoint_line_numbers", "line_number": 325, "body": "def get_breakpoint_line_numbers(self):\n        result = set()\n        for num_line in self._gutter.get(\"1.0\", \"end\").splitlines():\n            if BREAKPOINT_SYMBOL in num_line:\n                result.add(int(num_line.replace(BREAKPOINT_SYMBOL, \"\")))\n        return result", "is_method": true, "class_name": "CodeView", "function_description": "Core utility of CodeView that identifies all line numbers marked with breakpoints in the gutter, facilitating debugging features by tracking where execution should pause."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_selected_range", "line_number": 332, "body": "def get_selected_range(self):\n        if self.text.has_selection():\n            lineno, col_offset = map(int, self.text.index(tk.SEL_FIRST).split(\".\"))\n            end_lineno, end_col_offset = map(int, self.text.index(tk.SEL_LAST).split(\".\"))\n        else:\n            lineno, col_offset = map(int, self.text.index(tk.INSERT).split(\".\"))\n            end_lineno, end_col_offset = lineno, col_offset\n\n        return TextRange(lineno, col_offset, end_lineno, end_col_offset)", "is_method": true, "class_name": "CodeView", "function_description": "Returns the start and end positions of the current text selection or the cursor location if no selection exists, providing a range for further text manipulation or analysis within the CodeView editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "destroy", "line_number": 342, "body": "def destroy(self):\n        super().destroy()\n        get_workbench().unbind(\"SyntaxThemeChanged\", self._reload_theme_options)", "is_method": true, "class_name": "CodeView", "function_description": "Clean-up method of the CodeView class that removes the instance and unregisters its syntax theme change handler from the workbench event system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_reload_gutter_theme_options", "line_number": 346, "body": "def _reload_gutter_theme_options(self, event=None):\n        # super()._reload_gutter_theme_options(event)\n        if \"GUTTER\" in _syntax_options:\n            opts = _syntax_options[\"GUTTER\"].copy()\n            if \"background\" in opts and \"selectbackground\" not in opts:\n                opts[\"selectbackground\"] = opts[\"background\"]\n                opts[\"inactiveselectbackground\"] = opts[\"background\"]\n            if \"foreground\" in opts and \"selectforeground\" not in opts:\n                opts[\"selectforeground\"] = opts[\"foreground\"]\n\n            self._gutter.configure(opts)\n\n            if \"background\" in opts:\n                background = opts[\"background\"]\n                self._margin_line.configure(background=background)\n                self._gutter.tag_configure(\"sel\", background=background)\n\n        if \"breakpoint\" in _syntax_options:\n            self._gutter.tag_configure(\"breakpoint\", _syntax_options[\"breakpoint\"])", "is_method": true, "class_name": "CodeView", "function_description": "Updates the visual theme settings for the gutter area in the code view, including selection and breakpoint highlights, ensuring consistent and customizable syntax highlighting appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "ask_backend_path", "line_number": 1301, "body": "def ask_backend_path(master, dialog_kind):\n    proxy = get_runner().get_backend_proxy()\n    if not proxy:\n        return None\n\n    assert proxy.supports_remote_files()\n\n    dlg = BackendFileDialog(master, dialog_kind, proxy.get_cwd())\n    show_dialog(dlg, master)\n    return dlg.result", "is_method": false, "function_description": "Function that opens a backend file dialog for selecting or managing remote files, returning the user's choice. It relies on a backend proxy to ensure remote file support and current working directory context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "choose_node_for_file_operations", "line_number": 1313, "body": "def choose_node_for_file_operations(master, prompt):\n    if get_runner().supports_remote_files():\n        dlg = NodeChoiceDialog(master, prompt)\n        show_dialog(dlg, master)\n        if dlg.result == \"remote\" and not get_runner().ready_for_remote_file_operations(\n            show_message=True\n        ):\n            return None\n        return dlg.result\n    else:\n        return \"local\"", "is_method": false, "function_description": "Function that determines the appropriate node (\"local\" or \"remote\") for file operations based on runner capabilities and user selection, ensuring readiness for remote file handling when applicable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_local_files_root_text", "line_number": 1326, "body": "def get_local_files_root_text():\n    global _LOCAL_FILES_ROOT_TEXT\n\n    if not _LOCAL_FILES_ROOT_TEXT:\n        # translation can't be done in module load time\n        _LOCAL_FILES_ROOT_TEXT = tr(\"This computer\")\n\n    return _LOCAL_FILES_ROOT_TEXT", "is_method": false, "function_description": "Returns a localized display string representing the root of local files, caching it to avoid repeated translation calls. This supports consistent UI labeling for local file access points."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_with_default_app", "line_number": 1336, "body": "def open_with_default_app(path):\n    if running_on_windows():\n        os.startfile(path)\n    elif running_on_mac_os():\n        subprocess.run([\"open\", path])\n    else:\n        subprocess.run([\"xdg-open\", path])", "is_method": false, "function_description": "Function that opens a file or URL using the system's default application across different operating systems, providing a simple interface for launching external resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_file_handler_conf_key", "line_number": 1345, "body": "def get_file_handler_conf_key(extension):\n    return \"file_default_handlers.%s\" % extension", "is_method": false, "function_description": "Utility function that generates a configuration key string for default file handlers based on a given file extension, facilitating handler lookup or storage by extension."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "show_hidden_files", "line_number": 1349, "body": "def show_hidden_files():\n    return get_workbench().get_option(HIDDEN_FILES_OPTION)", "is_method": false, "function_description": "This function retrieves the current setting for displaying hidden files from the workbench configuration, allowing programs to check if hidden files should be shown."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "init_header", "line_number": 101, "body": "def init_header(self, row, column):\n        header_frame = ttk.Frame(self, style=\"ViewToolbar.TFrame\")\n        header_frame.grid(row=row, column=column, sticky=\"nsew\")\n        header_frame.columnconfigure(0, weight=1)\n\n        self.path_bar = tktextext.TweakableText(\n            header_frame,\n            borderwidth=0,\n            relief=\"flat\",\n            height=1,\n            font=\"TkDefaultFont\",\n            wrap=\"word\",\n            padx=6,\n            pady=5,\n            insertwidth=0,\n            highlightthickness=0,\n            background=lookup_style_option(\"ViewToolbar.TFrame\", \"background\"),\n        )\n\n        self.path_bar.grid(row=0, column=0, sticky=\"nsew\")\n        self.path_bar.set_read_only(True)\n        self.path_bar.bind(\"<Configure>\", self.resize_path_bar, True)\n        self.path_bar.tag_configure(\n            \"dir\", foreground=lookup_style_option(\"Url.TLabel\", \"foreground\")\n        )\n        self.path_bar.tag_configure(\"underline\", underline=True)\n\n        def get_dir_range(event):\n            mouse_index = self.path_bar.index(\"@%d,%d\" % (event.x, event.y))\n            return self.path_bar.tag_prevrange(\"dir\", mouse_index + \"+1c\")\n\n        def dir_tag_motion(event):\n            self.path_bar.tag_remove(\"underline\", \"1.0\", \"end\")\n            dir_range = get_dir_range(event)\n            if dir_range:\n                range_start, range_end = dir_range\n                self.path_bar.tag_add(\"underline\", range_start, range_end)\n\n        def dir_tag_enter(event):\n            self.path_bar.config(cursor=\"hand2\")\n\n        def dir_tag_leave(event):\n            self.path_bar.config(cursor=\"\")\n            self.path_bar.tag_remove(\"underline\", \"1.0\", \"end\")\n\n        def dir_tag_click(event):\n            mouse_index = self.path_bar.index(\"@%d,%d\" % (event.x, event.y))\n            lineno = int(float(mouse_index))\n            if lineno == 1:\n                self.request_focus_into(\"\")\n            else:\n                assert lineno == 2\n                dir_range = get_dir_range(event)\n                if dir_range:\n                    _, end_index = dir_range\n                    path = self.path_bar.get(\"2.0\", end_index)\n                    if path.endswith(\":\"):\n                        path += \"\\\\\"\n                    self.request_focus_into(path)\n\n        self.path_bar.tag_bind(\"dir\", \"<1>\", dir_tag_click)\n        self.path_bar.tag_bind(\"dir\", \"<Enter>\", dir_tag_enter)\n        self.path_bar.tag_bind(\"dir\", \"<Leave>\", dir_tag_leave)\n        self.path_bar.tag_bind(\"dir\", \"<Motion>\", dir_tag_motion)\n\n        # self.menu_button = ttk.Button(header_frame, text=\"\u2261 \", style=\"ViewToolbar.Toolbutton\")\n        self.menu_button = ttk.Button(\n            header_frame, text=\" \u2261 \", style=\"ViewToolbar.Toolbutton\", command=self.post_button_menu\n        )\n        # self.menu_button.grid(row=0, column=1, sticky=\"ne\")\n        self.menu_button.place(anchor=\"ne\", rely=0, relx=1)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Initializes a header section with a read-only, interactive path bar displaying directory paths and a menu button in the BaseFileBrowser GUI. It enables user navigation by handling mouse interactions with directory elements in the path display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "clear", "line_number": 173, "body": "def clear(self):\n        self.clear_error()\n        self.invalidate_cache()\n        self.path_bar.direct_delete(\"1.0\", \"end\")\n        self.tree.set_children(\"\")\n        self.current_focus = None", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Method of the BaseFileBrowser class that resets the browser state by clearing errors, invalidating cached data, emptying the path input, clearing directory listings, and removing focus. It prepares the interface for a fresh browsing session."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_focus_into", "line_number": 180, "body": "def request_focus_into(self, path):\n        return self.focus_into(path)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method in BaseFileBrowser that directs focus to a specified path, facilitating navigation or interaction with that location within the file browser interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "focus_into", "line_number": 183, "body": "def focus_into(self, path):\n        self.clear_error()\n        self.invalidate_cache()\n\n        # clear\n        self.tree.set_children(ROOT_NODE_ID)\n\n        self.tree.set(ROOT_NODE_ID, \"path\", path)\n\n        self.building_breadcrumbs = True\n        self.path_bar.direct_delete(\"1.0\", \"end\")\n\n        self.path_bar.direct_insert(\"1.0\", self.get_root_text(), (\"dir\",))\n\n        if path and path != \"/\":\n            self.path_bar.direct_insert(\"end\", \"\\n\")\n\n            def create_spacer():\n                return ttk.Frame(self.path_bar, height=1, width=4, style=\"ViewToolbar.TFrame\")\n\n            parts = self.split_path(path)\n            for i, part in enumerate(parts):\n                if i > 0:\n                    if parts[i - 1] != \"\":\n                        self.path_bar.window_create(\"end\", window=create_spacer())\n                    self.path_bar.direct_insert(\"end\", self.get_dir_separator())\n                    self.path_bar.window_create(\"end\", window=create_spacer())\n\n                self.path_bar.direct_insert(\"end\", part, tags=(\"dir\",))\n\n        self.building_breadcrumbs = False\n        self.resize_path_bar()\n        self.render_children_from_cache()\n        self.scroll_to_top()\n        self.current_focus = path", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Method of BaseFileBrowser that sets the current directory focus to the given path, updating the UI breadcrumbs and file tree to reflect this location for user navigation within the file system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "scroll_to_top", "line_number": 219, "body": "def scroll_to_top(self):\n        children = self.tree.get_children()\n        if children:\n            self.tree.see(children[0])", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method in BaseFileBrowser that scrolls the file tree view to the top, ensuring the first item is visible for quick navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "split_path", "line_number": 224, "body": "def split_path(self, path):\n        return path.split(self.get_dir_separator())", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method in BaseFileBrowser that splits a file path into components based on the directory separator, facilitating path manipulation and navigation tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_root_text", "line_number": 227, "body": "def get_root_text(self):\n        return get_local_files_root_text()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Returns the root directory path or label used by the file browser for local files, serving as the base reference point for file navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_open_node", "line_number": 230, "body": "def on_open_node(self, event):\n        node_id = self.get_selected_node()\n        path = self.tree.set(node_id, \"path\")\n        if path:  # and path not in self._cached_child_data:\n            self.render_children_from_cache(node_id)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Method in BaseFileBrowser that handles the event of opening a tree node by retrieving its path and rendering its cached child nodes if available. It supports efficient navigation by loading previously cached directory contents."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "resize_path_bar", "line_number": 238, "body": "def resize_path_bar(self, event=None):\n        if self.building_breadcrumbs:\n            return\n        height = self.tk.call((self.path_bar, \"count\", \"-update\", \"-displaylines\", \"1.0\", \"end\"))\n        self.path_bar.configure(height=height)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Adjusts the visual height of the path bar in the file browser to fit its content dynamically. This ensures the file path display is properly sized for readability and user interface consistency."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "_cleaned_selection", "line_number": 244, "body": "def _cleaned_selection(self):\n        # In some cases (eg. Python 3.6.9 and Tk 8.6.8 in Ubuntu when selecting a range with shift),\n        # nodes may contain collapsed children.\n        # In most cases this does no harm, because the command would apply to children as well,\n        # but dummy dir marker nodes may cause confusion\n        nodes = self.tree.selection()\n        return [node for node in nodes if self.tree.item(node, \"text\") != _dummy_node_text]", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method of BaseFileBrowser that returns the currently selected tree nodes, excluding placeholder or dummy directory markers to ensure accurate processing of user selections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_node", "line_number": 252, "body": "def get_selected_node(self):\n        \"\"\"Returns single node (or nothing)\"\"\"\n        nodes = self._cleaned_selection()\n        if len(nodes) == 1:\n            return nodes[0]\n        elif len(nodes) > 1:\n            return self.tree.focus() or None\n        else:\n            return None", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Returns the currently selected node in the file browser, prioritizing a single selection or the focused node if multiple are selected. It helps identify user selection within a tree structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_nodes", "line_number": 262, "body": "def get_selected_nodes(self, notify_if_empty=False):\n        \"\"\"Can return several nodes\"\"\"\n        result = self._cleaned_selection()\n        if not result and notify_if_empty:\n            self.notify_missing_selection()\n        return result", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides a list of currently selected nodes and optionally notifies if no selection exists. This method supports components needing awareness of user selections within a file browsing context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selection_info", "line_number": 269, "body": "def get_selection_info(self, notify_if_empty=False):\n        nodes = self.get_selected_nodes(notify_if_empty)\n        if not nodes:\n            return None\n        elif len(nodes) == 1:\n            description = \"'\" + self.tree.set(nodes[0], \"name\") + \"'\"\n        else:\n            description = tr(\"%d items\") % len(nodes)\n\n        paths = [self.tree.set(node, \"path\") for node in nodes]\n        kinds = [self.tree.set(node, \"kind\") for node in nodes]\n\n        return {\"description\": description, \"nodes\": nodes, \"paths\": paths, \"kinds\": kinds}", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides a summary of the currently selected file nodes, including a descriptive label, their paths, and types, facilitating operations based on user selections within a file browsing interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_path", "line_number": 283, "body": "def get_selected_path(self):\n        return self.get_selected_value(\"path\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method of BaseFileBrowser that returns the currently selected filesystem path, facilitating access to user-selected file or directory locations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_kind", "line_number": 286, "body": "def get_selected_kind(self):\n        return self.get_selected_value(\"kind\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method in BaseFileBrowser that returns the currently selected file kind or type, abstracting selection retrieval by leveraging a generic value-fetching mechanism."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_name", "line_number": 289, "body": "def get_selected_name(self):\n        return self.get_selected_value(\"name\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method of the BaseFileBrowser class that retrieves the name of the currently selected file or item, facilitating identification or further processing based on selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_extension_from_name", "line_number": 292, "body": "def get_extension_from_name(self, name):\n        if name is None:\n            return None\n        if \".\" in name:\n            return \".\" + name.split(\".\")[-1].lower()\n        else:\n            return name.lower()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Returns the file extension from a given name, standardizing it to lowercase and including the dot. Useful for identifying file types within file browsing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_value", "line_number": 300, "body": "def get_selected_value(self, key):\n        node_id = self.get_selected_node()\n\n        if node_id:\n            return self.tree.set(node_id, key)\n        else:\n            return None", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Retrieves the value associated with a specified key from the currently selected item in the file browser's tree structure, returning None if no item is selected."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_active_directory", "line_number": 308, "body": "def get_active_directory(self):\n        path = self.tree.set(ROOT_NODE_ID, \"path\")\n        return path", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Returns the current active directory path selected in the file browser. This allows other functions to know which directory is being accessed or manipulated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "show_fs_info", "line_number": 315, "body": "def show_fs_info(self):\n        path = self.get_selected_path()\n        if path is None:\n            path = self.current_focus\n        self.request_fs_info(path)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Service method of BaseFileBrowser that triggers retrieval of file system information for the currently selected or focused path, facilitating UI updates or further file operations based on that data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "present_fs_info", "line_number": 324, "body": "def present_fs_info(self, info):\n        total_str = \"?\" if info[\"total\"] is None else sizeof_fmt(info[\"total\"])\n        used_str = \"?\" if info[\"used\"] is None else sizeof_fmt(info[\"used\"])\n        free_str = \"?\" if info[\"free\"] is None else sizeof_fmt(info[\"free\"])\n        text = tr(\"Storage space on this drive or filesystem\") + \":\\n\\n\" \"    %s: %s\\n\" % (\n            tr(\"total space\"),\n            total_str,\n        ) + \"    %s: %s\\n\" % (tr(\"used space\"), used_str) + \"    %s: %s\\n\" % (\n            tr(\"free space\"),\n            free_str,\n        )\n\n        if info.get(\"comment\"):\n            text += \"\\n\" + info[\"comment\"]\n\n        messagebox.showinfo(tr(\"Storage info\"), text, master=self)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Displays a user-friendly message box showing total, used, and free storage space details for a filesystem, including any additional comments. This function provides a convenient way to present storage information to users through a graphical interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "cache_dirs_child_data", "line_number": 341, "body": "def cache_dirs_child_data(self, data):\n        from copy import deepcopy\n\n        data = deepcopy(data)\n\n        for parent_path in data:\n            children_data = data[parent_path]\n            if isinstance(children_data, dict):\n                for child_name in children_data:\n                    child_data = children_data[child_name]\n                    assert isinstance(child_data, dict)\n                    if \"label\" not in child_data:\n                        child_data[\"label\"] = child_name\n\n                    if \"isdir\" not in child_data:\n                        child_data[\"isdir\"] = child_data.get(\"size\", 0) is None\n            else:\n                assert children_data is None\n\n        self._cached_child_data.update(data)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Service method in BaseFileBrowser that processes and caches directory children metadata, ensuring each child has 'label' and 'isdir' attributes for consistent representation in directory structures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "file_exists_in_cache", "line_number": 362, "body": "def file_exists_in_cache(self, path):\n        for parent_path in self._cached_child_data:\n            # hard to split because it may not be in this system format\n            name = path[len(parent_path) :]\n            if name[0:1] in [\"/\", \"\\\\\"]:\n                name = name[1:]\n\n            if name in self._cached_child_data[parent_path]:\n                return True\n\n        return False", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method in BaseFileBrowser that checks if a given file path exists within the cached directory data, enabling quick verification of file presence without accessing the underlying file system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "select_path_if_visible", "line_number": 374, "body": "def select_path_if_visible(self, path, node_id=\"\"):\n        for child_id in self.tree.get_children(node_id):\n            if self.tree.set(child_id, \"path\") == path:\n                self.tree.selection_set(child_id)\n                return\n\n            if self.tree.item(child_id, \"open\"):\n                self.select_path_if_visible(path, child_id)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method of BaseFileBrowser that selects a file or folder in the tree view if its path is currently visible, helping synchronize UI selection based on filesystem paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_open_paths", "line_number": 383, "body": "def get_open_paths(self, node_id=ROOT_NODE_ID):\n        if self.tree.set(node_id, \"kind\") == \"file\":\n            return set()\n\n        elif node_id == ROOT_NODE_ID or self.tree.item(node_id, \"open\"):\n            result = {self.tree.set(node_id, \"path\")}\n            for child_id in self.tree.get_children(node_id):\n                result.update(self.get_open_paths(child_id))\n            return result\n\n        else:\n            return set()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Core method of BaseFileBrowser that returns the set of file system paths currently expanded or \"open\" under a given directory node, facilitating navigation state tracking in a hierarchical file tree."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "invalidate_cache", "line_number": 396, "body": "def invalidate_cache(self, paths=None):\n        if paths is None:\n            self._cached_child_data.clear()\n        else:\n            for path in paths:\n                if path in self._cached_child_data:\n                    del self._cached_child_data[path]", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Method of BaseFileBrowser that clears the cached child data, either entirely or selectively for specified paths, ensuring the file browser reflects updated directory contents."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "render_children_from_cache", "line_number": 404, "body": "def render_children_from_cache(self, node_id=\"\"):\n        \"\"\"This node is supposed to be a directory and\n        its contents needs to be shown and/or refreshed\"\"\"\n        path = self.tree.set(node_id, \"path\")\n\n        if path not in self._cached_child_data:\n            self.request_dirs_child_data(node_id, self.get_open_paths() | {path})\n            # leave it as is for now, it will be updated later\n            return\n\n        children_data = self._cached_child_data[path]\n\n        if children_data in [\"file\", \"missing\"]:\n            # path used to be a dir but is now a file or does not exist\n\n            # if browser is focused into this path\n            if node_id == \"\":\n                self.show_error(\"Directory \" + path + \" does not exist anymore\", node_id)\n            elif children_data == \"missing\":\n                self.tree.delete(node_id)\n            else:\n                assert children_data == \"file\"\n                self.tree.set_children(node_id)  # clear the list of children\n                self.tree.item(node_id, open=False)\n\n        elif children_data is None:\n            raise RuntimeError(\"None data for %s\" % path)\n        else:\n            fs_children_names = children_data.keys()\n            tree_children_ids = self.tree.get_children(node_id)\n\n            # recollect children\n            children = {}\n\n            # first the ones, which are present already in tree\n            for child_id in tree_children_ids:\n                name = self.tree.set(child_id, \"name\")\n                if name in fs_children_names:\n                    children[name] = child_id\n                    self.update_node_data(child_id, name, children_data[name])\n\n            # add missing children\n            for name in fs_children_names:\n                if name not in children:\n                    child_id = self.tree.insert(node_id, \"end\")\n                    children[name] = child_id\n                    self.tree.set(children[name], \"path\", self.join(path, name))\n                    self.update_node_data(child_id, name, children_data[name])\n\n            def file_order(name):\n                # items in a folder should be ordered so that\n                # folders come first and names are ordered case insensitively\n                return (\n                    not children_data[name][\"isdir\"],  # prefer directories\n                    not \":\" in name,  # prefer drives\n                    name.upper(),\n                    name,\n                )\n\n            # update tree\n            ids_sorted_by_name = list(\n                map(lambda key: children[key], sorted(children.keys(), key=file_order))\n            )\n            self.tree.set_children(node_id, *ids_sorted_by_name)\n\n            # recursively update open children\n            for child_id in ids_sorted_by_name:\n                if self.tree.item(child_id, \"open\"):\n                    self.render_children_from_cache(child_id)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method of BaseFileBrowser that refreshes or displays directory contents from cached data, updating the file tree structure and handling changes such as missing or converted files to ensure the file browser view stays current."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "show_error", "line_number": 474, "body": "def show_error(self, msg, node_id=\"\"):\n        if not node_id:\n            # clear tree\n            self.tree.set_children(\"\")\n\n        err_id = self.tree.insert(node_id, \"end\")\n        self.tree.item(err_id, text=msg)\n        self.tree.set_children(node_id, err_id)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method of BaseFileBrowser that displays an error message within a tree structure, optionally clearing existing nodes and associating the message with a specified node."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "update_node_data", "line_number": 486, "body": "def update_node_data(self, node_id, name, data):\n        assert node_id != \"\"\n\n        path = self.tree.set(node_id, \"path\")\n\n        if data.get(\"modified\"):\n            try:\n                # modification time is Unix epoch\n                time_str = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(int(data[\"modified\"])))\n            except Exception:\n                time_str = \"\"\n        else:\n            time_str = \"\"\n\n        self.tree.set(node_id, \"modified\", time_str)\n\n        if data[\"isdir\"]:\n            self.tree.set(node_id, \"kind\", \"dir\")\n            self.tree.set(node_id, \"size\", \"\")\n\n            # Ensure that expand button is visible\n            # unless we know it doesn't have children\n            children_ids = self.tree.get_children(node_id)\n            if (\n                self.show_expand_buttons\n                and len(children_ids) == 0\n                and (path not in self._cached_child_data or self._cached_child_data[path])\n            ):\n                self.tree.insert(node_id, \"end\", text=_dummy_node_text)\n\n            if path.endswith(\":\") or path.endswith(\":\\\\\"):\n                img = self.hard_drive_icon\n            else:\n                img = self.folder_icon\n        else:\n            self.tree.set(node_id, \"kind\", \"file\")\n            self.tree.set(node_id, \"size\", data[\"size\"])\n\n            # Make sure it doesn't have children\n            self.tree.set_children(node_id)\n\n            if (\n                path.lower().endswith(\".py\")\n                or path.lower().endswith(\".pyw\")\n                or path.lower().endswith(\".pyi\")\n            ):\n                img = self.python_file_icon\n            elif self.should_open_name_in_thonny(name):\n                img = self.text_file_icon\n            else:\n                img = self.generic_file_icon\n\n        self.tree.set(node_id, \"name\", name)\n        self.tree.item(node_id, text=\" \" + data[\"label\"], image=img)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Updates the visual and metadata attributes of a node representing a file or directory in the file browser tree, including icons, modification time, size, and child indicators to reflect its current state and type."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "join", "line_number": 541, "body": "def join(self, parent, child):\n        if parent == \"\":\n            if self.get_dir_separator() == \"/\":\n                return \"/\" + child\n            else:\n                return child\n\n        if parent.endswith(self.get_dir_separator()):\n            return parent + child\n        else:\n            return parent + self.get_dir_separator() + child", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method in BaseFileBrowser that constructs a file path by joining a parent directory and a child filename, handling directory separators appropriately for different operating systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_dir_separator", "line_number": 553, "body": "def get_dir_separator(self):\n        return os.path.sep", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Returns the directory path separator specific to the operating system, providing a consistent way to handle file paths across platforms."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_double_click", "line_number": 556, "body": "def on_double_click(self, event):\n        # TODO: don't act when the click happens below last item\n        path = self.get_selected_path()\n        kind = self.get_selected_kind()\n        name = self.get_selected_name()\n        if kind == \"file\":\n            if self.should_open_name_in_thonny(name):\n                self.open_file(path)\n            else:\n                self.open_path_with_system_app(path)\n        elif kind == \"dir\":\n            self.request_focus_into(path)\n\n        return \"break\"", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Handles double-click events in a file browser to either open files with an editor or system app, or to navigate into directories. It enables intuitive user interaction with files and folders via double-click actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_secondary_click", "line_number": 577, "body": "def on_secondary_click(self, event):\n        node_id = self.tree.identify_row(event.y)\n\n        if node_id:\n            if node_id not in self.tree.selection():\n                # replace current selection\n                self.tree.selection_set(node_id)\n            self.tree.focus(node_id)\n        else:\n            self.tree.selection_set()\n            self.path_bar.focus_set()\n\n        self.tree.update()\n\n        self.refresh_menu(context=\"item\")\n        self.menu.tk_popup(event.x_root, event.y_root)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Handles right-click events on the file browser tree, updating selection and focus, then displays a context menu for the clicked item or path bar area. Enables contextual user interactions based on current selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "post_button_menu", "line_number": 594, "body": "def post_button_menu(self):\n        self.refresh_menu(context=\"button\")\n        self.menu.tk_popup(\n            self.menu_button.winfo_rootx(),\n            self.menu_button.winfo_rooty() + self.menu_button.winfo_height(),\n        )", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Method of BaseFileBrowser that displays a context menu positioned below a button, refreshing its contents before showing it to the user. It enables interactive menu options linked to the button context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "refresh_menu", "line_number": 601, "body": "def refresh_menu(self, context):\n        self.menu.delete(0, \"end\")\n        self.add_first_menu_items(context)\n        self.menu.add_separator()\n        self.add_middle_menu_items(context)\n        self.menu.add_separator()\n        self.add_last_menu_items(context)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides a structured way to update and rebuild the file browser's menu by refreshing its content in three distinct sections based on the given context. This supports dynamic menu management in the BaseFileBrowser interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "is_active_browser", "line_number": 609, "body": "def is_active_browser(self):\n        return False", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Returns False to indicate this browser is not currently active; serves as a default or placeholder status checker in the BaseFileBrowser class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "add_first_menu_items", "line_number": 612, "body": "def add_first_menu_items(self, context):\n        if context == \"item\":\n            selected_path = self.get_selected_path()\n            selected_kind = self.get_selected_kind()\n        else:\n            selected_path = self.get_active_directory()\n            selected_kind = \"dir\"\n\n        if context == \"button\":\n            self.menu.add_command(label=tr(\"Refresh\"), command=self.cmd_refresh_tree)\n            self.menu.add_command(\n                label=tr(\"Open in system file manager\"),\n                command=lambda: self.open_path_with_system_app(selected_path),\n            )\n\n            hidden_files_label = (\n                tr(\"Hide hidden files\") if show_hidden_files() else tr(\"Show hidden files\")\n            )\n            self.menu.add_command(label=hidden_files_label, command=self.toggle_hidden_files)\n        else:\n            if selected_kind == \"dir\":\n                self.menu.add_command(\n                    label=tr(\"Focus into\"), command=lambda: self.request_focus_into(selected_path)\n                )\n            else:\n                self.menu.add_command(\n                    label=tr(\"Open in Thonny\"), command=lambda: self.open_file(selected_path)\n                )\n\n            if self.is_active_browser():\n                self.menu.add_command(\n                    label=tr(\"Open in system default app\"),\n                    command=lambda: self.open_path_with_system_app(selected_path),\n                )\n\n                if selected_kind == \"file\":\n                    ext = self.get_extension_from_name(self.get_selected_name())\n                    self.menu.add_command(\n                        label=tr(\"Configure %s files\") % ext + \"...\",\n                        command=lambda: self.open_extension_dialog(ext),\n                    )", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Constructs and adds context-specific menu items to the file browser's menu, enabling actions like refreshing, opening files or directories, toggling hidden files, and configuring file types based on the current selection or UI context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "toggle_hidden_files", "line_number": 654, "body": "def toggle_hidden_files(self):\n        get_workbench().set_option(\n            HIDDEN_FILES_OPTION, not get_workbench().get_option(HIDDEN_FILES_OPTION)\n        )\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Toggles the visibility of hidden files in the file browser and refreshes the display accordingly. This method allows users to switch between showing and hiding hidden files within the interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "cmd_refresh_tree", "line_number": 660, "body": "def cmd_refresh_tree(self):\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Triggers a refresh of the file browser's directory tree to update the displayed file structure. This ensures the view reflects the current state of the filesystem."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_extension_dialog", "line_number": 663, "body": "def open_extension_dialog(self, extension: str) -> None:\n        system_choice = tr(\"Open in system default app\")\n        thonny_choice = tr(\"Open in Thonny's text editor\")\n\n        current_index = (\n            1 if get_workbench().get_option(get_file_handler_conf_key(extension)) == \"thonny\" else 0\n        )\n\n        choice = ask_one_from_choices(\n            title=tr(\"Configure %s files\") % extension,\n            question=tr(\n                \"What to do with a %s file when you double-click it in Thonny's file browser?\"\n            )\n            % extension,\n            choices=[system_choice, thonny_choice],\n            initial_choice_index=current_index,\n            master=self.winfo_toplevel(),\n        )\n\n        if not choice:\n            return\n\n        get_workbench().set_option(\n            get_file_handler_conf_key(extension),\n            \"system\" if choice == system_choice else \"thonny\",\n        )\n        # update icons\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Method of BaseFileBrowser that prompts the user to choose how to open files of a specific extension, configuring whether double-click opens them with the system default app or the editor, then updates the choice persistently."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "add_middle_menu_items", "line_number": 692, "body": "def add_middle_menu_items(self, context):\n        if self.supports_trash():\n            if running_on_windows():\n                trash_label = tr(\"Move to Recycle Bin\")\n            else:\n                trash_label = tr(\"Move to Trash\")\n            self.menu.add_command(label=trash_label, command=self.move_to_trash)\n        else:\n            self.menu.add_command(label=tr(\"Delete\"), command=self.delete)\n\n        if self.supports_directories():\n            self.menu.add_command(label=tr(\"New directory\") + \"...\", command=self.mkdir)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Adds context-specific commands like trash, delete, or new directory options to a menu based on system support, enhancing file management interactions in the BaseFileBrowser interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "add_last_menu_items", "line_number": 705, "body": "def add_last_menu_items(self, context):\n        self.menu.add_command(label=tr(\"Properties\"), command=self.show_properties)\n        if context == \"button\":\n            self.menu.add_command(label=tr(\"Storage space\"), command=self.show_fs_info)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Adds \"Properties\" and conditionally \"Storage space\" options to the file browser menu based on the given context, enhancing user interaction with file properties and storage information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "show_properties", "line_number": 710, "body": "def show_properties(self):\n        node_id = self.get_selected_node()\n        if node_id is None:\n            self.notify_missing_selection()\n            return\n\n        values = self.tree.set(node_id)\n\n        text = tr(\"Path\") + \":\\n    \" + values[\"path\"] + \"\\n\\n\"\n        if values[\"kind\"] == \"dir\":\n            title = tr(\"Directory properties\")\n        else:\n            title = tr(\"File properties\")\n            size_fmt_str = sizeof_fmt(int(values[\"size\"]))\n            bytes_str = str(values[\"size\"]) + \" \" + tr(\"bytes\")\n\n            text += (\n                tr(\"Size\")\n                + \":\\n    \"\n                + (\n                    bytes_str\n                    if size_fmt_str.endswith(\" B\")\n                    else size_fmt_str + \"  (\" + bytes_str + \")\"\n                )\n                + \"\\n\\n\"\n            )\n\n        if values[\"modified\"].strip():\n            text += tr(\"Modified\") + \":\\n    \" + values[\"modified\"] + \"\\n\\n\"\n\n        messagebox.showinfo(title, text.strip(), master=self)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Displays a dialog with detailed properties (path, size, modification date) of the currently selected file or directory in the file browser, notifying the user if no selection is made."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "refresh_tree", "line_number": 742, "body": "def refresh_tree(self, paths_to_invalidate=None):\n        self.invalidate_cache(paths_to_invalidate)\n        if self.winfo_ismapped():\n            self.render_children_from_cache(\"\")\n\n        if self.path_to_highlight:\n            self.select_path_if_visible(self.path_to_highlight)\n            self.path_to_highlight = None", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Method in BaseFileBrowser that refreshes the displayed file tree by invalidating cache and re-rendering visible items; it also highlights a specified path if set, ensuring the file view is up to date and focused."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "create_new_file", "line_number": 751, "body": "def create_new_file(self):\n        selected_node_id = self.get_selected_node()\n\n        if selected_node_id:\n            selected_path = self.tree.set(selected_node_id, \"path\")\n            selected_kind = self.tree.set(selected_node_id, \"kind\")\n\n            if selected_kind == \"dir\":\n                parent_path = selected_path\n            else:\n                parent_id = self.tree.parent(selected_node_id)\n                parent_path = self.tree.set(parent_id, \"path\")\n        else:\n            parent_path = self.current_focus\n\n        name = ask_string(\n            \"File name\", \"Provide filename\", initial_value=\"\", master=self.winfo_toplevel()\n        )\n\n        if not name:\n            return None\n\n        path = self.join(parent_path, name)\n\n        if name in self._cached_child_data[parent_path]:\n            # TODO: ignore case in windows\n            messagebox.showerror(\"Error\", \"The file '\" + path + \"' already exists\", master=self)\n            return self.create_new_file()\n        else:\n            self.open_file(path)\n\n        return path", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Creates a new file in the currently selected directory or focused path, prompting the user for a filename and handling duplicate name conflicts. It enables easy file creation within the file browser interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "delete", "line_number": 784, "body": "def delete(self):\n        selection = self.get_selection_info(True)\n        if not selection:\n            return\n\n        confirmation = \"Are you sure want to delete %s?\" % selection[\"description\"]\n        confirmation += \"\\n\\nNB! Recycle bin won't be used (no way to undelete)!\"\n        if \"dir\" in selection[\"kinds\"]:\n            confirmation += \"\\n\" + \"Directories will be deleted with content.\"\n\n        if not messagebox.askyesno(\"Are you sure?\", confirmation, master=self):\n            return\n\n        self.perform_delete(selection[\"paths\"], tr(\"Deleting %s\") % selection[\"description\"])\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides a user-confirmed deletion service for selected files or directories without using a recycle bin, ensuring immediate removal and updating the file browser view accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "move_to_trash", "line_number": 800, "body": "def move_to_trash(self):\n        assert self.supports_trash()\n\n        selection = self.get_selection_info(True)\n        if not selection:\n            return\n\n        trash = \"Recycle Bin\" if running_on_windows() else \"Trash\"\n        if not messagebox.askokcancel(\n            \"Moving to %s\" % trash,\n            \"I'll try to move %s to %s,\\n\" % (selection[\"description\"], trash)\n            + \"but my method is not always reliable \u2014\\n\"\n            + \"in some cases the files will be deleted\\n\"\n            + \"without the possibility to restore.\",\n            icon=\"info\",\n            master=self,\n        ):\n            return\n\n        self.perform_move_to_trash(\n            selection[\"paths\"], tr(\"Moving %s to %s\") % (selection[\"description\"], trash)\n        )\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides functionality to move selected files or items to the system's trash/recycle bin with user confirmation, while warning about potential limitations in recoverability. It supports file management actions within the BaseFileBrowser context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "supports_trash", "line_number": 824, "body": "def supports_trash(self):\n        return False", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Indicates whether the file browser supports a trash or recycle bin feature. Returns False by default, signaling no trash capability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "mkdir", "line_number": 827, "body": "def mkdir(self):\n        parent = self.get_selected_path()\n        if parent is None:\n            parent = self.current_focus\n        else:\n            if self.get_selected_kind() == \"file\":\n                # dirname does the right thing even if parent is Linux path and running on Windows\n                parent = os.path.dirname(parent)\n\n        name = ask_string(\n            tr(\"New directory\"),\n            tr(\"Enter name for new directory under\\n%s\") % parent,\n            master=self.winfo_toplevel(),\n        )\n        if not name or not name.strip():\n            return\n\n        self.perform_mkdir(parent, name.strip())\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Creates a new directory at a user-specified location within the file browser, prompting for the directory name and updating the view to reflect changes. It simplifies directory management in the file browsing interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "supports_directories", "line_number": 853, "body": "def supports_directories(self):\n        return True", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Indicates whether the file browser supports directory navigation, enabling functions that rely on browsing folder structures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "notify_missing_selection", "line_number": 859, "body": "def notify_missing_selection(self):\n        messagebox.showerror(\n            tr(\"Nothing selected\"), tr(\"Select an item and try again!\"), master=self\n        )", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Displays an error message alerting the user that no item was selected, prompting them to make a selection before proceeding."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "should_open_name_in_thonny", "line_number": 864, "body": "def should_open_name_in_thonny(self, name):\n        ext = self.get_extension_from_name(name)\n        return get_workbench().get_option(get_file_handler_conf_key(ext), \"system\") == \"thonny\"", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Determines if a file with the given name should be opened in the Thonny IDE based on its extension and user configuration settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "destroy", "line_number": 875, "body": "def destroy(self):\n        super().destroy()\n        get_workbench().unbind(\"WindowFocusIn\", self.on_window_focus_in)\n        get_workbench().unbind(\"LocalFileOperation\", self.on_local_file_operation)", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Cleans up resources and event bindings related to the file browser instance when it is destroyed, ensuring proper detachment from application-wide event handlers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_dirs_child_data", "line_number": 880, "body": "def request_dirs_child_data(self, node_id, paths):\n        self.cache_dirs_child_data(get_dirs_children_info(paths, show_hidden_files()))\n        self.render_children_from_cache(node_id)", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Method of BaseLocalFileBrowser that updates the cached directory children data for given paths and triggers rendering of those child elements under a specified node in the file browser interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "split_path", "line_number": 884, "body": "def split_path(self, path):\n        parts = super().split_path(path)\n        if running_on_windows() and path.startswith(\"\\\\\\\\\"):\n            # Don't split a network name!\n            sep = self.get_dir_separator()\n            for i in reversed(range(len(parts))):\n                prefix = sep.join(parts[: i + 1])\n                if os.path.ismount(prefix):\n                    return [prefix] + parts[i + 1 :]\n\n            # Could not find the prefix corresponding to mount\n            return [path]\n        else:\n            return parts", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Method of BaseLocalFileBrowser that splits a filesystem path into components, correctly handling Windows network paths to avoid splitting the network share name. It ensures accurate path parsing across different operating systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_file", "line_number": 899, "body": "def open_file(self, path):\n        get_workbench().get_editor_notebook().show_file(path)", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Utility method in BaseLocalFileBrowser that opens a specified file in the editor notebook interface, facilitating file viewing or editing within the application workspace."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_path_with_system_app", "line_number": 902, "body": "def open_path_with_system_app(self, path):\n        try:\n            open_with_default_app(path)\n        except Exception as e:\n            logger.error(\"Could not open %r in system app\", path, exc_info=e)\n            messagebox.showerror(\n                \"Error\",\n                \"Could not open '%s' in system app\\nError: %s\" % (path, e),\n                parent=self.winfo_toplevel(),\n            )", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Utility method of BaseLocalFileBrowser that attempts to open a given file path using the system's default application, handling errors by logging and displaying an error message dialog to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_window_focus_in", "line_number": 913, "body": "def on_window_focus_in(self, event=None):\n        self.refresh_tree()", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Triggers a refresh of the file browser's tree view when the window gains focus, ensuring displayed file information stays up to date."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_local_file_operation", "line_number": 916, "body": "def on_local_file_operation(self, event):\n        if event[\"operation\"] in [\"save\", \"delete\"]:\n            self.refresh_tree()\n            self.select_path_if_visible(event[\"path\"])", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Handles local file save or delete events by refreshing the file tree view and selecting the affected path if it is visible, keeping the file browser interface updated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_fs_info", "line_number": 921, "body": "def request_fs_info(self, path):\n        if path == \"\":\n            self.notify_missing_selection()\n        else:\n            if not os.path.isdir(path):\n                path = os.path.dirname(path)\n\n            import shutil\n\n            self.present_fs_info(shutil.disk_usage(path)._asdict())", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Provides disk usage information for a given path, adjusting the input to a directory if needed, and notifies if no path is selected. It supports file system monitoring and storage capacity checks in the BaseLocalFileBrowser context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "perform_move_to_trash", "line_number": 936, "body": "def perform_move_to_trash(self, paths, description):\n        # TODO: do it with subprocess dialog\n        import send2trash\n\n        for path in paths:\n            send2trash.send2trash(path)", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Utility method in BaseLocalFileBrowser that moves specified files or directories to the system's trash/recycle bin, enabling safe file deletion with potential for user confirmation integration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "perform_mkdir", "line_number": 943, "body": "def perform_mkdir(self, parent_dir, name):\n        os.mkdir(os.path.join(parent_dir, name), mode=0o700)", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Creates a new directory with restricted permissions inside the specified parent directory. This method facilitates controlled folder creation within the local file browser context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "supports_trash", "line_number": 946, "body": "def supports_trash(self):\n        try:\n            import send2trash  # @UnusedImport\n\n            return True\n        except ImportError:\n            return False", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Utility method of BaseLocalFileBrowser that checks if the environment supports safely moving files to the trash using the send2trash module. It helps determine if trash functionality is available for file deletion operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "destroy", "line_number": 964, "body": "def destroy(self):\n        super().destroy()\n        get_workbench().unbind(\"get_dirs_children_info_response\", self.update_dir_data)\n        get_workbench().unbind(\"get_fs_info_response\", self.present_fs_info)\n        get_workbench().unbind(\"RemoteFileOperation\", self.on_remote_file_operation)", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Releases resources and unregisters event listeners related to remote file browsing to properly clean up the BaseRemoteFileBrowser instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_root_text", "line_number": 970, "body": "def get_root_text(self):\n        runner = get_runner()\n        if runner:\n            return runner.get_node_label()\n\n        return \"Back-end\"", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Returns the label of the root node from the current execution context or a default \"Back-end\" string if unavailable, facilitating identification of the root element in remote file browsing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_dirs_child_data", "line_number": 977, "body": "def request_dirs_child_data(self, node_id, paths):\n        if get_runner():\n            get_runner().send_command(\n                InlineCommand(\n                    \"get_dirs_children_info\",\n                    node_id=node_id,\n                    paths=paths,\n                    include_hidden=show_hidden_files(),\n                )\n            )", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Utility method of BaseRemoteFileBrowser that requests directory children information for given nodes and paths, facilitating remote file browsing with optional inclusion of hidden files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_fs_info", "line_number": 988, "body": "def request_fs_info(self, path):\n        if get_runner():\n            get_runner().send_command(InlineCommand(\"get_fs_info\", path=path))", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Method in BaseRemoteFileBrowser that sends a command to retrieve filesystem information for a specified path from a remote runner environment. It enables querying remote directory or file metadata for integration or display purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_dir_separator", "line_number": 992, "body": "def get_dir_separator(self):\n        return self.dir_separator", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Returns the directory path separator used by the remote file browser, facilitating consistent handling of file paths across different remote systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "update_dir_data", "line_number": 995, "body": "def update_dir_data(self, msg):\n        if msg.get(\"error\"):\n            self.show_error(msg[\"error\"])\n        else:\n            self.dir_separator = msg[\"dir_separator\"]\n            self.cache_dirs_child_data(msg[\"data\"])\n            self.render_children_from_cache(msg[\"node_id\"])\n\n        if self.path_to_highlight:\n            self.select_path_if_visible(self.path_to_highlight)\n            self.path_to_highlight = None", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Updates the directory data by handling error messages or refreshing directory contents, then highlights a specific path if specified. It supports dynamic remote file browsing with error handling and UI updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_file", "line_number": 1007, "body": "def open_file(self, path):\n        get_workbench().get_editor_notebook().show_remote_file(path)", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Opens and displays a remote file in the user's editor notebook interface. This provides seamless access to remote file contents within the application\u2019s workspace."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_path_with_system_app", "line_number": 1010, "body": "def open_path_with_system_app(self, path):\n        messagebox.showinfo(\n            \"Not supported\",\n            \"Opening remote files in system app is not supported.\\n\\n\"\n            + \"Please download the file to a local directory and open it from there!\",\n            master=self,\n        )", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "This method informs users that opening remote files directly in a system application is unsupported and advises downloading files locally before opening them. It provides user guidance within a remote file browsing context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "supports_directories", "line_number": 1018, "body": "def supports_directories(self):\n        runner = get_runner()\n        if not runner:\n            return False\n        proxy = runner.get_backend_proxy()\n        if not proxy:\n            return False\n        return proxy.supports_remote_directories()", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Checks if the remote file browser supports navigating directories by querying the underlying backend proxy. Useful for determining directory-related capabilities before performing file operations remotely."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_remote_file_operation", "line_number": 1027, "body": "def on_remote_file_operation(self, event):\n        path = event[\"path\"]\n        exists_in_cache = self.file_exists_in_cache(path)\n        if (\n            event[\"operation\"] == \"save\"\n            and exists_in_cache\n            or event[\"operation\"] == \"delete\"\n            and not exists_in_cache\n        ):\n            # No need to refresh\n            return\n\n        if \"/\" in path:\n            parent = path[: path.rfind(\"/\")]\n            if not parent:\n                parent = \"/\"\n        else:\n            parent = \"\"\n\n        self.refresh_tree([parent])\n        self.path_to_highlight = path", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Monitors remote file changes to conditionally refresh the directory view and highlight affected files, ensuring the file browser's display remains accurate and up to date."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "perform_delete", "line_number": 1049, "body": "def perform_delete(self, paths, description):\n        get_runner().send_command_and_wait(\n            InlineCommand(\"delete\", paths=paths, description=description),\n            dialog_title=tr(\"Deleting\"),\n        )", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Performs deletion of specified files or directories remotely, providing a description for the operation. Useful for automated or remote file management tasks within a remote file browsing context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "perform_mkdir", "line_number": 1055, "body": "def perform_mkdir(self, parent_dir, name):\n        path = (parent_dir + self.get_dir_separator() + name).replace(\"//\", \"/\")\n        get_runner().send_command_and_wait(\n            InlineCommand(\"mkdir\", path=path),\n            dialog_title=tr(\"Creating directory\"),\n        )", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Creates a new directory with a specified name inside a given parent directory on a remote file system, facilitating remote directory management within BaseRemoteFileBrowser."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "supports_trash", "line_number": 1062, "body": "def supports_trash(self):\n        return get_runner().get_backend_proxy().supports_trash()", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Indicates whether the remote file browser backend supports trash (recycle bin) functionality, enabling conditional handling of file deletion and recovery features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_focus_into", "line_number": 1065, "body": "def request_focus_into(self, path):\n        if not get_runner().ready_for_remote_file_operations(show_message=True):\n            return False\n\n        # super().request_focus_into(path)\n\n        if not get_runner().supports_remote_directories():\n            assert path == \"\"\n            self.focus_into(path)\n        elif self.current_focus == path:\n            # refreshes\n            self.focus_into(path)\n        else:\n            self.request_new_focus(path)\n\n        return True", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Method in BaseRemoteFileBrowser that manages focus navigation to a specified remote directory path, handling refreshes and capability checks to facilitate remote file browsing interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_new_focus", "line_number": 1082, "body": "def request_new_focus(self, path):\n        # Overridden in active browser\n        self.focus_into(path)", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Core function of BaseRemoteFileBrowser intended to update the current focus to a specified path, serving as a placeholder for subclasses that implement active browsing behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "cmd_refresh_tree", "line_number": 1086, "body": "def cmd_refresh_tree(self):\n        if not get_runner().ready_for_remote_file_operations(show_message=True):\n            return\n\n        super().cmd_refresh_tree()", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Utility method in BaseRemoteFileBrowser that refreshes the file tree view if the system is ready for remote file operations, ensuring up-to-date remote file listings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_file", "line_number": 1102, "body": "def open_file(self, path):\n        self.dialog.double_click_file(path)", "is_method": true, "class_name": "DialogRemoteFileBrowser", "function_description": "Method of DialogRemoteFileBrowser that opens a file at the specified path by simulating a double-click action within the remote file browser dialog. It enables programmatic file access in the browsing interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "should_open_name_in_thonny", "line_number": 1105, "body": "def should_open_name_in_thonny(self, name):\n        # In dialog, all file types are to be opened in Thonny\n        return True", "is_method": true, "class_name": "DialogRemoteFileBrowser", "function_description": "Always indicates that any given file name should be opened in the Thonny editor, supporting consistent file handling in the DialogRemoteFileBrowser context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_ok", "line_number": 1165, "body": "def on_ok(self, event=None):\n        tree = self.browser.tree\n        name = self.name_var.get()\n\n        if not name:\n            messagebox.showerror(tr(\"Error\"), tr(\"You need to select a file!\"), master=self)\n            return\n\n        for node_id in tree.get_children(\"\"):\n            if name and name == tree.set(node_id, \"name\"):\n                break\n        else:\n            node_id = None\n\n        if node_id is not None:\n            node_kind = tree.set(node_id, \"kind\")\n            if node_kind != \"file\":\n                messagebox.showerror(tr(\"Error\"), tr(\"You need to select a file!\"), master=self)\n                return\n            elif self.kind == \"save\":\n                if not messagebox.askyesno(\n                    tr(\"Overwrite?\"), tr(\"Do you want to overwrite '%s' ?\") % name, master=self\n                ):\n                    return\n\n        parent_path = tree.set(\"\", \"path\")\n        if parent_path == \"\" or parent_path.endswith(\"/\"):\n            self.result = parent_path + name\n        else:\n            self.result = parent_path + \"/\" + name\n\n        self.destroy()", "is_method": true, "class_name": "BackendFileDialog", "function_description": "Handles user confirmation in a file dialog by validating the selected file name, checking file existence and type, prompting overwrite confirmation if saving, and then setting the full file path as the result before closing the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_cancel", "line_number": 1198, "body": "def on_cancel(self, event=None):\n        self.result = None\n        self.destroy()", "is_method": true, "class_name": "BackendFileDialog", "function_description": "Handles the cancellation of the file dialog by clearing the result and closing the dialog window, enabling graceful termination of user file selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_tree_select", "line_number": 1202, "body": "def on_tree_select(self, event=None):\n        if self.updating_selection:\n            return\n\n        if self.browser.get_selected_kind() == \"file\":\n            name = self.browser.get_selected_name()\n            if name:\n                self.name_var.set(name)", "is_method": true, "class_name": "BackendFileDialog", "function_description": "Handles tree selection events in BackendFileDialog by updating the selected file name when a file is chosen, ensuring the UI reflects the current file selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_name_edit", "line_number": 1211, "body": "def on_name_edit(self, event=None):\n        self.updating_selection = True\n        tree = self.browser.tree\n        if self.tree_select_handler_id:\n            tree.unbind(\"<<TreeviewSelect>>\", self.tree_select_handler_id)\n            self.tree_select_handler_id = None\n\n        name = self.name_var.get()\n        for node_id in tree.get_children(\"\"):\n            if name == tree.set(node_id, \"name\"):\n                tree.selection_add(node_id)\n            else:\n                tree.selection_remove(node_id)\n\n        self.updating_selection = False\n        self.tree_select_handler_id = tree.bind(\"<<TreeviewSelect>>\", self.on_tree_select, True)", "is_method": true, "class_name": "BackendFileDialog", "function_description": "Handles editing the filename in the backend file dialog by synchronizing the tree view selection with the current name input, ensuring consistent UI state during user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "double_click_file", "line_number": 1228, "body": "def double_click_file(self, path):\n        assert path.endswith(self.name_var.get())\n        self.on_ok()", "is_method": true, "class_name": "BackendFileDialog", "function_description": "Handles a double-click event on a file, asserting the clicked file matches the expected name and then triggers the confirmation action. It enables confirming file selection via double-click in a file dialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_local", "line_number": 1274, "body": "def on_local(self, event=None):\n        self.result = \"local\"\n        self.destroy()", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "Handles the selection of the \"local\" option, setting the result accordingly and closing the dialog. Useful for capturing user choice in a node selection interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_remote", "line_number": 1278, "body": "def on_remote(self, event=None):\n        self.result = \"remote\"\n        self.destroy()", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "Handles the selection of the \"remote\" option in a dialog, setting the result accordingly and closing the dialog window. It enables user choice processing within the NodeChoiceDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_return", "line_number": 1282, "body": "def on_return(self, event=None):\n        if self.focus_get() == self.local_button:\n            self.on_local(event)\n        elif self.focus_get() == self.remote_button:\n            self.on_remote(event)", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "Handles the return key event by triggering corresponding actions based on which button (local or remote) currently has focus. This enables intuitive keyboard navigation within the NodeChoiceDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_down", "line_number": 1288, "body": "def on_down(self, event=None):\n        if self.focus_get() == self.local_button:\n            self.remote_button.focus_set()", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "Handles focus transition from the local button to the remote button when triggered, supporting keyboard navigation within the NodeChoiceDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_up", "line_number": 1292, "body": "def on_up(self, event=None):\n        if self.focus_get() == self.remote_button:\n            self.local_button.focus_set()", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "Handles the \"up\" key event by shifting focus from the remote button to the local button in the NodeChoiceDialog interface, enabling keyboard navigation between options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_cancel", "line_number": 1296, "body": "def on_cancel(self, event=None):\n        self.result = None\n        self.destroy()", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "Method of NodeChoiceDialog that handles cancellation by clearing the result and closing the dialog, allowing calling code to detect user cancellation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_dir_range", "line_number": 128, "body": "def get_dir_range(event):\n            mouse_index = self.path_bar.index(\"@%d,%d\" % (event.x, event.y))\n            return self.path_bar.tag_prevrange(\"dir\", mouse_index + \"+1c\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Utility method of BaseFileBrowser that identifies the range of a directory path label based on mouse event coordinates, supporting user interaction with directory paths in the file browser interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "dir_tag_motion", "line_number": 132, "body": "def dir_tag_motion(event):\n            self.path_bar.tag_remove(\"underline\", \"1.0\", \"end\")\n            dir_range = get_dir_range(event)\n            if dir_range:\n                range_start, range_end = dir_range\n                self.path_bar.tag_add(\"underline\", range_start, range_end)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Handles a user event to update underline styling on a path bar, visually indicating the directory segment based on the event context in the file browser interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "dir_tag_enter", "line_number": 139, "body": "def dir_tag_enter(event):\n            self.path_bar.config(cursor=\"hand2\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Sets the mouse cursor to a hand icon when the pointer enters the directory tag area, indicating interactivity in the file browser interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "dir_tag_leave", "line_number": 142, "body": "def dir_tag_leave(event):\n            self.path_bar.config(cursor=\"\")\n            self.path_bar.tag_remove(\"underline\", \"1.0\", \"end\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Removes underlining and resets the cursor style on the path bar, typically used to clear visual highlight effects after a directory tag interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "dir_tag_click", "line_number": 146, "body": "def dir_tag_click(event):\n            mouse_index = self.path_bar.index(\"@%d,%d\" % (event.x, event.y))\n            lineno = int(float(mouse_index))\n            if lineno == 1:\n                self.request_focus_into(\"\")\n            else:\n                assert lineno == 2\n                dir_range = get_dir_range(event)\n                if dir_range:\n                    _, end_index = dir_range\n                    path = self.path_bar.get(\"2.0\", end_index)\n                    if path.endswith(\":\"):\n                        path += \"\\\\\"\n                    self.request_focus_into(path)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Handles clicks on directory tags in the UI's path bar, changing focus to the clicked directory path for navigation within the BaseFileBrowser interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "create_spacer", "line_number": 200, "body": "def create_spacer():\n                return ttk.Frame(self.path_bar, height=1, width=4, style=\"ViewToolbar.TFrame\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Creates a styled spacer frame used in the path bar interface to visually separate elements within the BaseFileBrowser UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "file_order", "line_number": 453, "body": "def file_order(name):\n                # items in a folder should be ordered so that\n                # folders come first and names are ordered case insensitively\n                return (\n                    not children_data[name][\"isdir\"],  # prefer directories\n                    not \":\" in name,  # prefer drives\n                    name.upper(),\n                    name,\n                )", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides a sorting key to order folder contents by prioritizing directories and drives, then sorting names case-insensitively. Enables consistent and user-friendly file listing in file browsing contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "_build_char_in_string_func", "line_number": 954, "body": "def _build_char_in_string_func(startindex):\n    # copied from idlelib.EditorWindow (Python 3.4.2)\n\n    # Our editwin provides a _is_char_in_string function that works\n    # with a Tk text index, but PyParse only knows about offsets into\n    # a string. This builds a function for PyParse that accepts an\n    # offset.\n\n    def inner(offset, _startindex=startindex, _icis=_is_char_in_string):\n        return _icis(_startindex + \"+%dc\" % offset)\n\n    return inner", "is_method": false, "function_description": "Creates a function that checks if a character at a given string offset is within a string literal, bridging index formats between text widget and string offsets for parsing purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "__getitem__", "line_number": 149, "body": "def __getitem__(self, item):\n        return self._get(item)", "is_method": true, "class_name": "StringTranslatePseudoMapping", "function_description": "Implements item access by delegating retrieval to an internal method, enabling dictionary-like behavior for the StringTranslatePseudoMapping class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "__len__", "line_number": 152, "body": "def __len__(self):\n        return len(self._non_defaults)", "is_method": true, "class_name": "StringTranslatePseudoMapping", "function_description": "Returns the count of non-default entries in the StringTranslatePseudoMapping, providing the number of explicitly mapped elements excluding defaults."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "__iter__", "line_number": 155, "body": "def __iter__(self):\n        return iter(self._non_defaults)", "is_method": true, "class_name": "StringTranslatePseudoMapping", "function_description": "Returns an iterator over the non-default translation mappings in the StringTranslatePseudoMapping instance, enabling iteration through customized translation entries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get", "line_number": 158, "body": "def get(self, key, default=None):\n        return self._get(key)", "is_method": true, "class_name": "StringTranslatePseudoMapping", "function_description": "Returns the translation mapping value for a given key, providing a default if the key is not found. This method simplifies retrieving mapped string translations within the StringTranslatePseudoMapping class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "set_str", "line_number": 167, "body": "def set_str(self, s):\n        assert len(s) == 0 or s[-1] == \"\\n\"\n        self.str = s\n        self.study_level = 0", "is_method": true, "class_name": "RoughParser", "function_description": "Sets the input string to be parsed, ensuring it ends with a newline, and resets the parser\u2019s study level. This prepares the RoughParser for a new parsing operation on the provided text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "find_good_parse_start", "line_number": 183, "body": "def find_good_parse_start(self, is_char_in_string=None, _synchre=_synchre):\n        # pylint: disable=redefined-builtin\n\n        str, pos = self.str, None  # @ReservedAssignment\n\n        if not is_char_in_string:\n            # no clue -- make the caller pass everything\n            return None\n\n        # Peek back from the end for a good place to start,\n        # but don't try too often; pos will be left None, or\n        # bumped to a legitimate synch point.\n        limit = len(str)\n        for _ in range(5):\n            i = str.rfind(\":\\n\", 0, limit)\n            if i < 0:\n                break\n            i = str.rfind(\"\\n\", 0, i) + 1  # start of colon line\n            m = _synchre(str, i, limit)\n            if m and not is_char_in_string(m.start()):\n                pos = m.start()\n                break\n            limit = i\n        if pos is None:\n            # Nothing looks like a block-opener, or stuff does\n            # but is_char_in_string keeps returning true; most likely\n            # we're in or near a giant string, the colorizer hasn't\n            # caught up enough to be helpful, or there simply *aren't*\n            # any interesting stmts.  In any of these cases we're\n            # going to have to parse the whole thing to be sure, so\n            # give it one last try from the start, but stop wasting\n            # time here regardless of the outcome.\n            m = _synchre(str)\n            if m and not is_char_in_string(m.start()):\n                pos = m.start()\n            return pos\n\n        # Peeking back worked; look forward until _synchre no longer\n        # matches.\n        i = pos + 1\n        while 1:\n            m = _synchre(str, i)\n            if m:\n                s, i = m.span()\n                if not is_char_in_string(s):\n                    pos = s\n            else:\n                break\n        return pos", "is_method": true, "class_name": "RoughParser", "function_description": "Method of the RoughParser class that identifies an optimal position in the source string to begin parsing, improving parsing efficiency by skipping over string literals and irrelevant code regions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "set_lo", "line_number": 236, "body": "def set_lo(self, lo):\n        assert lo == 0 or self.str[lo - 1] == \"\\n\"\n        if lo > 0:\n            self.str = self.str[lo:]", "is_method": true, "class_name": "RoughParser", "function_description": "Method of RoughParser that sets the starting index for parsing, ensuring it begins at a line start by trimming the input string from that position. It enables controlled parsing from specific line boundaries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "_study1", "line_number": 255, "body": "def _study1(self):\n        # pylint: disable=redefined-builtin\n\n        if self.study_level >= 1:\n            return\n        self.study_level = 1\n\n        # Map all uninteresting characters to \"x\", all open brackets\n        # to \"(\", all close brackets to \")\", then collapse runs of\n        # uninteresting characters.  This can cut the number of chars\n        # by a factor of 10-40, and so greatly speed the following loop.\n        str = (\n            self.str.translate(self._tran)  # @ReservedAssignment\n            .replace(\"xxxxxxxx\", \"x\")\n            .replace(\"xxxx\", \"x\")\n            .replace(\"xx\", \"x\")\n            .replace(\"xx\", \"x\")\n            .replace(\"\\nx\", \"\\n\")\n        )\n        # note that replacing x\\n with \\n would be incorrect, because\n        # x may be preceded by a backslash\n\n        # March over the squashed version of the program, accumulating\n        # the line numbers of non-continued stmts, and determining\n        # whether & why the last stmt is a continuation.\n        continuation = C_NONE\n        level = lno = 0  # level is nesting level; lno is line number\n        self.goodlines = goodlines = [0]\n        push_good = goodlines.append\n        i, n = 0, len(str)\n        while i < n:\n            ch = str[i]\n            i = i + 1\n\n            # cases are checked in decreasing order of frequency\n            if ch == \"x\":\n                continue\n\n            if ch == \"\\n\":\n                lno = lno + 1\n                if level == 0:\n                    push_good(lno)\n                    # else we're in an unclosed bracket structure\n                continue\n\n            if ch == \"(\":\n                level = level + 1\n                continue\n\n            if ch == \")\":\n                if level:\n                    level = level - 1\n                    # else the program is invalid, but we can't complain\n                continue\n\n            if ch == '\"' or ch == \"'\":\n                # consume the string\n                quote = ch\n                if str[i - 1 : i + 2] == quote * 3:\n                    quote = quote * 3\n                firstlno = lno\n                w = len(quote) - 1\n                i = i + w\n                while i < n:\n                    ch = str[i]\n                    i = i + 1\n\n                    if ch == \"x\":\n                        continue\n\n                    if str[i - 1 : i + w] == quote:\n                        i = i + w\n                        break\n\n                    if ch == \"\\n\":\n                        lno = lno + 1\n                        if w == 0:\n                            # unterminated single-quoted string\n                            # It doesn't matter if we're in brackets,\n                            # this should lead to\n                            # SyntaxError: EOL while scanning string literal\n                            level = 0\n                            push_good(lno)\n                            break\n                        continue\n\n                    if ch == \"\\\\\":\n                        assert i < n\n                        if str[i] == \"\\n\":\n                            lno = lno + 1\n                        i = i + 1\n                        continue\n\n                    # else comment char or paren inside string\n\n                else:\n                    # didn't break out of the loop, so we're still\n                    # inside a string\n                    if (lno - 1) == firstlno:\n                        # before the previous \\n in str, we were in the first\n                        # line of the string\n                        continuation = C_STRING_FIRST_LINE\n                    else:\n                        continuation = C_STRING_NEXT_LINES\n                continue  # with outer loop\n\n            if ch == \"#\":\n                # consume the comment\n                i = str.find(\"\\n\", i)\n                assert i >= 0\n                continue\n\n            assert ch == \"\\\\\"\n            assert i < n\n            if str[i] == \"\\n\":\n                lno = lno + 1\n                if i + 1 == n:\n                    continuation = C_BACKSLASH\n            i = i + 1\n\n        # The last stmt may be continued for all 3 reasons.\n        # String continuation takes precedence over bracket\n        # continuation, which beats backslash continuation.\n        if (\n            continuation != C_STRING_FIRST_LINE\n            and continuation != C_STRING_NEXT_LINES\n            and level > 0\n        ):\n            continuation = C_BRACKET\n        self.continuation = continuation\n\n        # Push the final line number as a sentinel value, regardless of\n        # whether it's continued.\n        assert (continuation == C_NONE) == (goodlines[-1] == lno)\n        if goodlines[-1] != lno:\n            push_good(lno)", "is_method": true, "class_name": "RoughParser", "function_description": "Core method of RoughParser that analyzes a simplified representation of source code to identify \"good\" line breaks and detect if the last statement is logically continued over multiple lines. Useful for parsing and understanding Python code structure at line-level granularity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_continuation_type", "line_number": 392, "body": "def get_continuation_type(self):\n        self._study1()\n        return self.continuation", "is_method": true, "class_name": "RoughParser", "function_description": "Returns the current continuation type after performing an internal study operation. This method provides access to the continuation state within the RoughParser class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "_study2", "line_number": 413, "body": "def _study2(self):\n        # pylint: disable=redefined-builtin\n\n        if self.study_level >= 2:\n            return\n        self._study1()\n        self.study_level = 2\n\n        # Set p and q to slice indices of last interesting stmt.\n        str, goodlines = self.str, self.goodlines  # @ReservedAssignment\n        i = len(goodlines) - 1\n        p = len(str)  # index of newest line\n        while i:\n            assert p\n            # p is the index of the stmt at line number goodlines[i].\n            # Move p back to the stmt at line number goodlines[i-1].\n            q = p\n            for _ in range(goodlines[i - 1], goodlines[i]):  # @UnusedVariable\n                # tricky: sets p to 0 if no preceding newline\n                p = str.rfind(\"\\n\", 0, p - 1) + 1\n            # The stmt str[p:q] isn't a continuation, but may be blank\n            # or a non-indenting comment line.\n            if _junkre(str, p):\n                i = i - 1\n            else:\n                break\n        if i == 0:\n            # nothing but junk!\n            assert p == 0\n            q = p\n        self.stmt_start, self.stmt_end = p, q\n\n        # Analyze this stmt, to find the last open bracket (if any)\n        # and last interesting character (if any).\n        lastch = \"\"\n        stack = []  # stack of open bracket indices\n        push_stack = stack.append\n        bracketing = [(p, 0)]\n        while p < q:\n            # suck up all except ()[]{}'\"#\\\\\n            m = _chew_ordinaryre(str, p, q)\n            if m:\n                # we skipped at least one boring char\n                newp = m.end()\n                # back up over totally boring whitespace\n                i = newp - 1  # index of last boring char\n                while i >= p and str[i] in \" \\t\\n\":\n                    i = i - 1\n                if i >= p:\n                    lastch = str[i]\n                p = newp\n                if p >= q:\n                    break\n\n            ch = str[p]\n\n            if ch in \"([{\":\n                push_stack(p)\n                bracketing.append((p, len(stack)))\n                lastch = ch\n                p = p + 1\n                continue\n\n            if ch in \")]}\":\n                if stack:\n                    del stack[-1]\n                lastch = ch\n                p = p + 1\n                bracketing.append((p, len(stack)))\n                continue\n\n            if ch == '\"' or ch == \"'\":\n                # consume string\n                # Note that study1 did this with a Python loop, but\n                # we use a regexp here; the reason is speed in both\n                # cases; the string may be huge, but study1 pre-squashed\n                # strings to a couple of characters per line.  study1\n                # also needed to keep track of newlines, and we don't\n                # have to.\n                bracketing.append((p, len(stack) + 1))\n                lastch = ch\n                p = _match_stringre(str, p, q).end()\n                bracketing.append((p, len(stack)))\n                continue\n\n            if ch == \"#\":\n                # consume comment and trailing newline\n                bracketing.append((p, len(stack) + 1))\n                p = str.find(\"\\n\", p, q) + 1\n                assert p > 0\n                bracketing.append((p, len(stack)))\n                continue\n\n            assert ch == \"\\\\\"\n            p = p + 1  # beyond backslash\n            assert p < q\n            if str[p] != \"\\n\":\n                # the program is invalid, but can't complain\n                lastch = ch + str[p]\n            p = p + 1  # beyond escaped char\n\n        # end while p < q:\n\n        self.lastch = lastch\n        if stack:\n            self.lastopenbracketpos = stack[-1]\n        self.stmt_bracketing = tuple(bracketing)", "is_method": true, "class_name": "RoughParser", "function_description": "Internal method of RoughParser that analyzes the latest relevant statement in the source code, identifying statement boundaries, bracket nesting, and significant trailing characters for detailed syntactic parsing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "compute_bracket_indent", "line_number": 524, "body": "def compute_bracket_indent(self):\n        # pylint: disable=redefined-builtin\n        self._study2()\n        assert self.continuation == C_BRACKET\n        j = self.lastopenbracketpos\n        str = self.str  # @ReservedAssignment\n        n = len(str)\n        origi = i = str.rfind(\"\\n\", 0, j) + 1\n        j = j + 1  # one beyond open bracket\n        # find first list item; set i to start of its line\n        while j < n:\n            m = _itemre(str, j)\n            if m:\n                j = m.end() - 1  # index of first interesting char\n                extra = 0\n                break\n            else:\n                # this line is junk; advance to next line\n                i = j = str.find(\"\\n\", j) + 1\n        else:\n            # nothing interesting follows the bracket;\n            # reproduce the bracket line's indentation + a level\n            j = i = origi\n            while str[j] in \" \\t\":\n                j = j + 1\n            extra = self.indent_width\n        return len(str[i:j].expandtabs(self.tabwidth)) + extra", "is_method": true, "class_name": "RoughParser", "function_description": "Calculates the indentation level following an open bracket in the parsed text, aiding consistent formatting by determining how much additional indent should be applied after bracketed structures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_num_lines_in_stmt", "line_number": 556, "body": "def get_num_lines_in_stmt(self):\n        self._study1()\n        goodlines = self.goodlines\n        return goodlines[-1] - goodlines[-2]", "is_method": true, "class_name": "RoughParser", "function_description": "Returns the number of lines spanned by the current statement based on tracked good lines, supporting line-based analysis or parsing within the RoughParser context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "compute_backslash_indent", "line_number": 565, "body": "def compute_backslash_indent(self):\n        # pylint: disable=redefined-builtin\n        self._study2()\n        assert self.continuation == C_BACKSLASH\n        str = self.str  # @ReservedAssignment\n        i = self.stmt_start\n        while str[i] in \" \\t\":\n            i = i + 1\n        startpos = i\n\n        # See whether the initial line starts an assignment stmt; i.e.,\n        # look for an = operator\n        endpos = str.find(\"\\n\", startpos) + 1\n        found = level = 0\n        while i < endpos:\n            ch = str[i]\n            if ch in \"([{\":\n                level = level + 1\n                i = i + 1\n            elif ch in \")]}\":\n                if level:\n                    level = level - 1\n                i = i + 1\n            elif ch == '\"' or ch == \"'\":\n                i = _match_stringre(str, i, endpos).end()\n            elif ch == \"#\":\n                break\n            elif (\n                level == 0\n                and ch == \"=\"\n                and (i == 0 or str[i - 1] not in \"=<>!\")\n                and str[i + 1] != \"=\"\n            ):\n                found = 1\n                break\n            else:\n                i = i + 1\n\n        if found:\n            # found a legit =, but it may be the last interesting\n            # thing on the line\n            i = i + 1  # move beyond the =\n            found = re.match(r\"\\s*\\\\\", str[i:endpos]) is None\n\n        if not found:\n            # oh well ... settle for moving beyond the first chunk\n            # of non-whitespace chars\n            i = startpos\n            while str[i] not in \" \\t\\n\":\n                i = i + 1\n\n        return len(str[self.stmt_start : i].expandtabs(self.tabwidth)) + 1", "is_method": true, "class_name": "RoughParser", "function_description": "Calculates the indentation level following a backslash continuation in code, determining where a logical line of code effectively continues. Useful for parsing and interpreting multi-line Python statements in the RoughParser class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_base_indent_string", "line_number": 621, "body": "def get_base_indent_string(self):\n        self._study2()\n        i, n = self.stmt_start, self.stmt_end\n        j = i\n        str_ = self.str\n        while j < n and str_[j] in \" \\t\":\n            j = j + 1\n        return str_[i:j]", "is_method": true, "class_name": "RoughParser", "function_description": "Returns the leading whitespace characters from the start of the current statement, providing the base indentation string useful for parsing and maintaining code indentation structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "is_block_opener", "line_number": 632, "body": "def is_block_opener(self):\n        self._study2()\n        return self.lastch == \":\"", "is_method": true, "class_name": "RoughParser", "function_description": "Checks if the current position in parsing marks the start of a new block by verifying if the last examined character is a colon. This aids in identifying block openings during syntax analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "is_block_closer", "line_number": 638, "body": "def is_block_closer(self):\n        self._study2()\n        return _closere(self.str, self.stmt_start) is not None", "is_method": true, "class_name": "RoughParser", "function_description": "Checks if a specific block structure is closer in the parsed string, indicating the proximity of a code block boundary during parsing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_last_open_bracket_pos", "line_number": 645, "body": "def get_last_open_bracket_pos(self):\n        self._study2()\n        return self.lastopenbracketpos", "is_method": true, "class_name": "RoughParser", "function_description": "Returns the position of the most recent unmatched opening bracket in the parsed content, supporting syntax analysis or error detection in RoughParser."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_last_stmt_bracketing", "line_number": 654, "body": "def get_last_stmt_bracketing(self):\n        self._study2()\n        return self.stmt_bracketing", "is_method": true, "class_name": "RoughParser", "function_description": "This method performs an internal parsing step and returns the current statement bracketing structure. It provides access to the latest parsed statement boundaries within the RoughParser."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "set_index", "line_number": 721, "body": "def set_index(self, index):\n        \"\"\"Set the index to which the functions relate.\n\n        The index must be in the same statement.\n        \"\"\"\n        indexinrawtext = len(self.rawtext) - len(self.text.get(index, self.stopatindex))\n        if indexinrawtext < 0:\n            raise ValueError(\"Index %s precedes the analyzed statement\" % index)\n        self.indexinrawtext = indexinrawtext\n        # find the rightmost bracket to which index belongs\n        self.indexbracket = 0\n        while (\n            self.indexbracket < len(self.bracketing) - 1\n            and self.bracketing[self.indexbracket + 1][0] < self.indexinrawtext\n        ):\n            self.indexbracket += 1\n        if (\n            self.indexbracket < len(self.bracketing) - 1\n            and self.bracketing[self.indexbracket + 1][0] == self.indexinrawtext\n            and not self.isopener[self.indexbracket + 1]\n        ):\n            self.indexbracket += 1", "is_method": true, "class_name": "HyperParser", "function_description": "Sets the internal position index within the parsed statement, aligning it with the relevant bracket context to ensure the index corresponds to a valid location inside the same statement. This supports accurate parsing and analysis relative to statement structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "is_in_string", "line_number": 744, "body": "def is_in_string(self):\n        \"\"\"Is the index given to the HyperParser in a string?\"\"\"\n        # The bracket to which we belong should be an opener.\n        # If it's an opener, it has to have a character.\n        return self.isopener[self.indexbracket] and self.rawtext[\n            self.bracketing[self.indexbracket][0]\n        ] in ('\"', \"'\")", "is_method": true, "class_name": "HyperParser", "function_description": "Method of HyperParser that checks whether the current bracket index corresponds to a quotation mark in the original text, indicating if the parser's position is inside a string."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "is_in_code", "line_number": 752, "body": "def is_in_code(self):\n        \"\"\"Is the index given to the HyperParser in normal code?\"\"\"\n        return not self.isopener[self.indexbracket] or self.rawtext[\n            self.bracketing[self.indexbracket][0]\n        ] not in (\"#\", '\"', \"'\")", "is_method": true, "class_name": "HyperParser", "function_description": "Determines if the current parsing position in HyperParser is within normal code rather than inside special characters or comments. This helps distinguish code segments from strings or comments during parsing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_surrounding_brackets", "line_number": 758, "body": "def get_surrounding_brackets(self, openers=\"([{\", mustclose=False):\n        \"\"\"Return bracket indexes or None.\n\n        If the index given to the HyperParser is surrounded by a\n        bracket defined in openers (or at least has one before it),\n        return the indices of the opening bracket and the closing\n        bracket (or the end of line, whichever comes first).\n\n        If it is not surrounded by brackets, or the end of line comes\n        before the closing bracket and mustclose is True, returns None.\n        \"\"\"\n\n        bracketinglevel = self.bracketing[self.indexbracket][1]\n        before = self.indexbracket\n        while (\n            not self.isopener[before]\n            or self.rawtext[self.bracketing[before][0]] not in openers\n            or self.bracketing[before][1] > bracketinglevel\n        ):\n            before -= 1\n            if before < 0:\n                return None\n            bracketinglevel = min(bracketinglevel, self.bracketing[before][1])\n        after = self.indexbracket + 1\n        while after < len(self.bracketing) and self.bracketing[after][1] >= bracketinglevel:\n            after += 1\n\n        beforeindex = self.text.index(\n            \"%s-%dc\" % (self.stopatindex, len(self.rawtext) - self.bracketing[before][0])\n        )\n        if after >= len(self.bracketing) or self.bracketing[after][0] > len(self.rawtext):\n            if mustclose:\n                return None\n            afterindex = self.stopatindex\n        else:\n            # We are after a real char, so it is a ')' and we give the\n            # index before it.\n            afterindex = self.text.index(\n                \"%s-%dc\" % (self.stopatindex, len(self.rawtext) - (self.bracketing[after][0] - 1))\n            )\n\n        return beforeindex, afterindex", "is_method": true, "class_name": "HyperParser", "function_description": "Method of HyperParser that identifies the indices of the opening and closing brackets surrounding a given position, aiding bracket-aware parsing tasks. It supports customizable bracket sets and optional strict closure enforcement."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "_eat_identifier", "line_number": 806, "body": "def _eat_identifier(cls, s, limit, pos):\n        \"\"\"Given a string and pos, return the number of chars in the\n        identifier which ends at pos, or 0 if there is no such one.\n\n        This ignores non-identifier eywords are not identifiers.\n        \"\"\"\n        is_ascii_id_char = _IS_ASCII_ID_CHAR\n\n        # Start at the end (pos) and work backwards.\n        i = pos\n\n        # Go backwards as long as the characters are valid ASCII\n        # identifier characters. This is an optimization, since it\n        # is faster in the common case where most of the characters\n        # are ASCII.\n        while i > limit and (ord(s[i - 1]) < 128 and is_ascii_id_char[ord(s[i - 1])]):\n            i -= 1\n\n        # If the above loop ended due to reaching a non-ASCII\n        # character, continue going backwards using the most generic\n        # test for whether a string contains only valid identifier\n        # characters.\n        if i > limit and ord(s[i - 1]) >= 128:\n            while i - 4 >= limit and (\"a\" + s[i - 4 : pos]).isidentifier():\n                i -= 4\n            if i - 2 >= limit and (\"a\" + s[i - 2 : pos]).isidentifier():\n                i -= 2\n            if i - 1 >= limit and (\"a\" + s[i - 1 : pos]).isidentifier():\n                i -= 1\n\n            # The identifier candidate starts here. If it isn't a valid\n            # identifier, don't eat anything. At this point that is only\n            # possible if the first character isn't a valid first\n            # character for an identifier.\n            if not s[i:pos].isidentifier():\n                return 0\n        elif i < pos:\n            # All characters in str[i:pos] are valid ASCII identifier\n            # characters, so it is enough to check that the first is\n            # valid as the first character of an identifier.\n            if not _IS_ASCII_ID_FIRST_CHAR[ord(s[i])]:\n                return 0\n\n        # All keywords are valid identifiers, but should not be\n        # considered identifiers here, except for True, False and None.\n        if i < pos and (iskeyword(s[i:pos]) and s[i:pos] not in cls._ID_KEYWORDS):\n            return 0\n\n        return pos - i", "is_method": true, "class_name": "HyperParser", "function_description": "Private class method of HyperParser that determines the length of a valid identifier ending at a given position in a string, excluding most keywords. It aids parsing by identifying valid variable or function names within source code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_expression", "line_number": 859, "body": "def get_expression(self):\n        \"\"\"Return a string with the Python expression which ends at the\n        given index, which is empty if there is no real one.\n        \"\"\"\n        if not self.is_in_code():\n            raise ValueError(\"get_expression should only be called\" \"if index is inside a code.\")\n\n        rawtext = self.rawtext\n        bracketing = self.bracketing\n\n        brck_index = self.indexbracket\n        brck_limit = bracketing[brck_index][0]\n        pos = self.indexinrawtext\n\n        last_identifier_pos = pos\n        postdot_phase = True\n\n        while 1:\n            # Eat whitespaces, comments, and if postdot_phase is False - a dot\n            while 1:\n                if pos > brck_limit and rawtext[pos - 1] in self._whitespace_chars:\n                    # Eat a whitespace\n                    pos -= 1\n                elif not postdot_phase and pos > brck_limit and rawtext[pos - 1] == \".\":\n                    # Eat a dot\n                    pos -= 1\n                    postdot_phase = True\n                # The next line will fail if we are *inside* a comment,\n                # but we shouldn't be.\n                elif (\n                    pos == brck_limit\n                    and brck_index > 0\n                    and rawtext[bracketing[brck_index - 1][0]] == \"#\"\n                ):\n                    # Eat a comment\n                    brck_index -= 2\n                    brck_limit = bracketing[brck_index][0]\n                    pos = bracketing[brck_index + 1][0]\n                else:\n                    # If we didn't eat anything, quit.\n                    break\n\n            if not postdot_phase:\n                # We didn't find a dot, so the expression end at the\n                # last identifier pos.\n                break\n\n            ret = self._eat_identifier(rawtext, brck_limit, pos)\n            if ret:\n                # There is an identifier to eat\n                pos = pos - ret\n                last_identifier_pos = pos\n                # Now, to continue the search, we must find a dot.\n                postdot_phase = False\n                # (the loop continues now)\n\n            elif pos == brck_limit:\n                # We are at a bracketing limit. If it is a closing\n                # bracket, eat the bracket, otherwise, stop the search.\n                level = bracketing[brck_index][1]\n                while brck_index > 0 and bracketing[brck_index - 1][1] > level:\n                    brck_index -= 1\n                if bracketing[brck_index][0] == brck_limit:\n                    # We were not at the end of a closing bracket\n                    break\n                pos = bracketing[brck_index][0]\n                brck_index -= 1\n                brck_limit = bracketing[brck_index][0]\n                last_identifier_pos = pos\n                if rawtext[pos] in \"([\":\n                    # [] and () may be used after an identifier, so we\n                    # continue. postdot_phase is True, so we don't allow a dot.\n                    pass\n                else:\n                    # We can't continue after other types of brackets\n                    if rawtext[pos] in \"'\\\"\":\n                        # Scan a string prefix\n                        while pos > 0 and rawtext[pos - 1] in \"rRbBuU\":\n                            pos -= 1\n                        last_identifier_pos = pos\n                    break\n\n            else:\n                # We've found an operator or something.\n                break\n\n        return rawtext[last_identifier_pos : self.indexinrawtext]", "is_method": true, "class_name": "HyperParser", "function_description": "Provides the Python expression substring ending at the current parsing index within code, enabling extraction of syntactically valid expressions for tasks like code analysis or completion in the HyperParser class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "_get", "line_number": 144, "body": "def _get(key, _get=non_defaults.get, _default=default_value):\n            return _get(key, _default)", "is_method": true, "class_name": "StringTranslatePseudoMapping", "function_description": "Provides a lookup service that retrieves the value for a given key from a primary source, returning a default if the key is not found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "index2line", "line_number": 686, "body": "def index2line(index):\n            return int(float(index))", "is_method": true, "class_name": "HyperParser", "function_description": "Converts a given index value, possibly a string or float, to an integer line number. This utility ensures consistent line indexing within the HyperParser class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "is_ready_for_work", "line_number": 51, "body": "def is_ready_for_work(self):\n        return True", "is_method": true, "class_name": "WorkDialog", "function_description": "Simple readiness check method that always indicates the WorkDialog instance is ready for work-related operations or processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "init_instructions_frame", "line_number": 54, "body": "def init_instructions_frame(self):\n        instructions = self.get_instructions()\n        self.instructions_frame = ttk.Frame(self, style=\"Tip.TFrame\")\n        self.instructions_frame.grid(row=0, column=0, sticky=\"nsew\")\n        self.instructions_frame.rowconfigure(0, weight=1)\n        self.instructions_frame.columnconfigure(0, weight=1)\n\n        pad = self.get_padding()\n        self.instructions_label = ttk.Label(self, style=\"Tip.TLabel\", text=instructions)\n        self.instructions_label.grid(row=0, column=0, sticky=\"w\", padx=pad, pady=pad)", "is_method": true, "class_name": "WorkDialog", "function_description": "Sets up and displays a styled instructions frame with corresponding text in the WorkDialog interface, organizing layout and padding for user guidance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_instructions", "line_number": 65, "body": "def get_instructions(self) -> Optional[str]:\n        return None", "is_method": true, "class_name": "WorkDialog", "function_description": "Returns None, indicating no specific instructions are provided by this method."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "init_main_frame", "line_number": 68, "body": "def init_main_frame(self):\n        self.main_frame = ttk.Frame(self)\n        self.main_frame.grid(row=1, column=0, sticky=\"nsew\")", "is_method": true, "class_name": "WorkDialog", "function_description": "Initializes the main_frame attribute as a ttk.Frame widget and places it in the grid layout of the WorkDialog, setting up the primary container for the dialog's UI components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "init_action_frame", "line_number": 72, "body": "def init_action_frame(self):\n        padding = self.get_padding()\n        intpad = self.get_internal_padding()\n\n        self.action_frame = ttk.Frame(self)\n        self.action_frame.grid(row=2, column=0, sticky=\"nsew\")\n\n        self._progress_bar = ttk.Progressbar(\n            self.action_frame, length=ems_to_pixels(4), mode=\"indeterminate\"\n        )\n\n        self._current_action_label = create_action_label(\n            self.action_frame,\n            text=\"\",\n            width=round(self.get_action_text_max_length() * 1.1),\n            click_handler=self.toggle_log_frame,\n        )\n        self._current_action_label.grid(\n            row=1, column=2, sticky=\"we\", pady=padding, padx=(0, intpad)\n        )\n\n        self._ok_button = ttk.Button(\n            self.action_frame,\n            text=self.get_ok_text(),\n            command=self.on_ok,\n            state=\"disabled\",\n            default=\"active\",\n        )\n        if not self._autostart:\n            self._ok_button.grid(column=4, row=1, pady=padding, padx=(0, intpad))\n\n        self._cancel_button = ttk.Button(\n            self.action_frame,\n            text=self.get_cancel_text(),\n            command=self.on_cancel,\n        )\n        self._cancel_button.grid(column=5, row=1, padx=(0, padding), pady=padding)\n\n        self.action_frame.columnconfigure(2, weight=1)", "is_method": true, "class_name": "WorkDialog", "function_description": "Initializes and configures the user interface components of the WorkDialog's action frame, including progress bar, action label, and control buttons, setting up layout and interaction for dialog actions and status display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_action_text_max_length", "line_number": 112, "body": "def get_action_text_max_length(self):\n        return 35", "is_method": true, "class_name": "WorkDialog", "function_description": "Provides the maximum allowed length (35 characters) for action text within the WorkDialog class, standardizing text constraints for consistent user interface or processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "init_log_frame", "line_number": 115, "body": "def init_log_frame(self):\n        self.log_frame = ttk.Frame(self)\n        self.log_frame.columnconfigure(1, weight=1)\n        self.log_frame.rowconfigure(1, weight=1)\n        fixed_font = tk.font.nametofont(\"TkFixedFont\")\n        font = fixed_font.copy()\n        font.configure(size=round(fixed_font.cget(\"size\") * 0.8))\n        self.log_text = tktextext.TextFrame(\n            self.log_frame,\n            horizontal_scrollbar=False,\n            wrap=\"word\",\n            borderwidth=1,\n            height=5,\n            width=20,\n            font=font,\n            read_only=True,\n        )\n\n        padding = self.get_padding()\n        self.log_text.grid(row=1, column=1, sticky=\"nsew\", padx=padding, pady=(0, padding))", "is_method": true, "class_name": "WorkDialog", "function_description": "Initializes a read-only text frame within the dialog for displaying log messages with customized font and layout, supporting clear and organized presentation of log output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "update_ui", "line_number": 136, "body": "def update_ui(self):\n        if self._state == \"closed\":\n            return\n\n        while not self._work_events_queue.empty():\n            self.handle_work_event(*self._work_events_queue.get())\n            if self._state == \"closed\":\n                return\n\n        if self._state == \"idle\":\n            if self.is_ready_for_work():\n                self._ok_button.configure(state=\"normal\")\n            else:\n                self._ok_button.configure(state=\"disabled\")\n        else:\n            self._ok_button.configure(state=\"disabled\")\n\n        if self._state == \"done\":\n            set_text_if_different(self._cancel_button, tr(\"Close\"))\n        else:\n            set_text_if_different(self._cancel_button, tr(\"Cancel\"))", "is_method": true, "class_name": "WorkDialog", "function_description": "Manages the user interface state of WorkDialog by processing queued work events and updating button states and labels based on the dialog's current status and readiness for work."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_title", "line_number": 161, "body": "def get_title(self):\n        return \"Work dialog\"", "is_method": true, "class_name": "WorkDialog", "function_description": "Returns a fixed title string identifying the dialog as \"Work dialog,\" useful for UI display or dialog management within the WorkDialog class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "_keep_updating_ui", "line_number": 164, "body": "def _keep_updating_ui(self):\n        if self._state != \"closed\":\n            self.update_ui()\n            self._update_scheduler = self.after(200, self._keep_updating_ui)\n        else:\n            self._update_scheduler = None", "is_method": true, "class_name": "WorkDialog", "function_description": "Internal method of WorkDialog that continuously refreshes the user interface every 200 milliseconds until the dialog is closed, ensuring the UI stays updated in real time."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "close", "line_number": 171, "body": "def close(self):\n        self._state = \"closed\"\n        if self._update_scheduler is not None:\n            try:\n                self.after_cancel(self._update_scheduler)\n            except tk.TclError:\n                pass\n\n        self.destroy()", "is_method": true, "class_name": "WorkDialog", "function_description": "Core method of the WorkDialog class that terminates the dialog session by updating its state, canceling scheduled updates, and closing the interface. It ensures clean dialog shutdown and resource release."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "cancel_work", "line_number": 181, "body": "def cancel_work(self):\n        # worker should periodically check this value\n        self._state = \"cancelling\"\n        self.set_action_text(tr(\"Cancelling\"))", "is_method": true, "class_name": "WorkDialog", "function_description": "Sets the WorkDialog's state to indicate cancellation is in progress and updates its action text to notify users that the operation is being cancelled. This allows coordinated interruption handling in ongoing work processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "toggle_log_frame", "line_number": 186, "body": "def toggle_log_frame(self, event=None):\n        if self.log_frame.winfo_ismapped():\n            self.log_frame.grid_forget()\n            self.rowconfigure(2, weight=1)\n            self.rowconfigure(4, weight=0)\n        else:\n            self.log_frame.grid(row=4, column=0, sticky=\"nsew\")\n            self.rowconfigure(2, weight=0)\n            self.rowconfigure(4, weight=1)", "is_method": true, "class_name": "WorkDialog", "function_description": "Toggles the visibility of the log frame within the WorkDialog interface, adjusting layout weights to dynamically show or hide logging information as needed for better user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_ok_text", "line_number": 196, "body": "def get_ok_text(self):\n        return tr(\"OK\")", "is_method": true, "class_name": "WorkDialog", "function_description": "Returns the localized string for \"OK\", enabling consistent UI text display across different languages in the WorkDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_cancel_text", "line_number": 199, "body": "def get_cancel_text(self):\n        return tr(\"Cancel\")", "is_method": true, "class_name": "WorkDialog", "function_description": "Returns the localized text string for \"Cancel.\" This method provides a standardized way to retrieve the cancel button label in the WorkDialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "on_ok", "line_number": 202, "body": "def on_ok(self, event=None):\n        assert self._state == \"idle\"\n        if self.start_work() is not False:\n            self._state = \"working\"\n            self.success = False\n            self.grid_progress_widgets()\n            self._progress_bar[\"mode\"] = \"indeterminate\"\n            self._progress_bar.start()\n            if not self._current_action_label[\"text\"]:\n                self._current_action_label[\"text\"] = tr(\"Starting\") + \"...\"", "is_method": true, "class_name": "WorkDialog", "function_description": "Handles the confirmation action to initiate a work process, updating the dialog state, starting progress indicators, and signaling the start of the current task within the WorkDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "grid_progress_widgets", "line_number": 213, "body": "def grid_progress_widgets(self):\n        padding = self.get_padding()\n        intpad = self.get_internal_padding()\n        self._progress_bar.grid(row=1, column=1, sticky=\"w\", padx=(padding, intpad), pady=padding)", "is_method": true, "class_name": "WorkDialog", "function_description": "Utility method of the WorkDialog class that arranges the progress bar widget within a grid layout using calculated padding values for consistent spacing in the dialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "on_cancel", "line_number": 218, "body": "def on_cancel(self, event=None):\n        if self._state in (\"idle\", \"done\"):\n            self.close()\n        elif self._state == \"cancelling\" and self.confirm_leaving_while_cancelling():\n            self.close()\n        elif self.confirm_cancel():\n            self.cancel_work()", "is_method": true, "class_name": "WorkDialog", "function_description": "Handles cancellation events by confirming and managing work cancellation or dialog closure based on the current state, ensuring a controlled exit from ongoing tasks within the WorkDialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "confirm_leaving_while_cancelling", "line_number": 226, "body": "def confirm_leaving_while_cancelling(self):\n        return messagebox.askyesno(\n            \"Close dialog?\",\n            \"Cancelling is in progress.\\nDo you still want to close the dialog?\",\n            parent=self,\n        )", "is_method": true, "class_name": "WorkDialog", "function_description": "Utility method in WorkDialog that prompts the user to confirm closing the dialog during a cancellation process, ensuring accidental closure is avoided."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "confirm_cancel", "line_number": 233, "body": "def confirm_cancel(self):\n        return messagebox.askyesno(\n            \"Cancel work?\",\n            \"Are you sure you want to cancel?\",\n            parent=self,\n        )", "is_method": true, "class_name": "WorkDialog", "function_description": "Method of WorkDialog that prompts the user for confirmation before canceling an ongoing work session, returning a boolean based on the user's response. It enables safe user cancellation with verification."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "append_text", "line_number": 240, "body": "def append_text(self, text: str, stream_name=\"stdout\") -> None:\n        \"\"\"Appends text to the details box. May be called from another thread.\"\"\"\n        self._work_events_queue.put((\"append\", (text, stream_name)))\n        setattr(self, stream_name, getattr(self, stream_name) + text)", "is_method": true, "class_name": "WorkDialog", "function_description": "Method of WorkDialog that appends text to a designated stream and queues this update for thread-safe UI detail box display. It supports concurrent text additions from multiple threads, enhancing real-time interface updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "replace_last_line", "line_number": 245, "body": "def replace_last_line(self, text: str, stream_name=\"stdout\") -> None:\n        \"\"\"Replaces last line in the details box. May be called from another thread.\"\"\"\n        self._work_events_queue.put((\"replace\", (text, stream_name)))\n        setattr(self, stream_name, getattr(self, stream_name) + text)", "is_method": true, "class_name": "WorkDialog", "function_description": "Method of WorkDialog that updates the last line of a specified output stream and queues this change for display, supporting real-time text replacement possibly from other threads."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "report_progress", "line_number": 250, "body": "def report_progress(self, value: float, maximum: float) -> None:\n        \"\"\"Updates progress bar. May be called from another thread.\"\"\"\n        self._work_events_queue.put((\"progress\", (value, maximum)))", "is_method": true, "class_name": "WorkDialog", "function_description": "Updates the progress indicator by reporting the current value against a maximum, supporting thread-safe progress tracking in WorkDialog operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "set_action_text", "line_number": 254, "body": "def set_action_text(self, text: str) -> None:\n        \"\"\"Updates text above the progress bar. May be called from another thread.\"\"\"\n        self._work_events_queue.put((\"action\", (text,)))", "is_method": true, "class_name": "WorkDialog", "function_description": "Updates the display text above the progress bar to inform users about the current action, supporting thread-safe updates in concurrent environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "set_action_text_smart", "line_number": 258, "body": "def set_action_text_smart(self, text: str) -> None:\n        \"\"\"Updates text above the progress bar. May be called from another thread.\"\"\"\n        text = text.strip()\n        if not text:\n            return\n        if len(text) > self.get_action_text_max_length():\n            text = text[: self.get_action_text_max_length() - 3] + \"...\"\n        self.set_action_text(text)", "is_method": true, "class_name": "WorkDialog", "function_description": "Updates the action text displayed above the progress bar, ensuring it fits within a maximum length and can be safely called from any thread. This helps provide concise, real-time status updates in concurrent environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "report_done", "line_number": 267, "body": "def report_done(self, success):\n        \"\"\"May be called from another thread.\"\"\"\n        self._work_events_queue.put((\"done\", (success,)))", "is_method": true, "class_name": "WorkDialog", "function_description": "Utility method of the WorkDialog class that signals completion status by queuing a \"done\" event with a success flag, supporting thread-safe communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "handle_work_event", "line_number": 271, "body": "def handle_work_event(self, type, args):\n        if type in (\"append\", \"replace\"):\n            text, stream_name = args\n            if type == \"replace\":\n                self.log_text.text.direct_delete(\"end-1c linestart\", \"end-1c\")\n            self.log_text.text.direct_insert(\"end\", text, (stream_name,))\n            self.log_text.text.see(\"end\")\n        elif type == \"action\":\n            set_text_if_different(self._current_action_label, args[0])\n        elif type == \"progress\":\n            value, maximum = args\n            if value is None or maximum is None:\n                if self._progress_bar[\"mode\"] != \"indeterminate\":\n                    self._progress_bar[\"mode\"] = \"indeterminate\"\n                    self._progress_bar.start()\n            else:\n                if self._progress_bar[\"mode\"] != \"determinate\":\n                    self._progress_bar[\"mode\"] = \"determinate\"\n                    self._progress_bar.stop()\n                self._progress_bar.configure(value=value, maximum=maximum)\n        elif type == \"done\":\n            self.on_done(args[0])", "is_method": true, "class_name": "WorkDialog", "function_description": "Handles different types of work-related events to update UI elements such as text logs, action labels, progress bars, or to trigger completion callbacks. It centralizes event-driven updates within the WorkDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "on_done", "line_number": 294, "body": "def on_done(self, success):\n        \"\"\"NB! Don't call from non-ui thread!\"\"\"\n        self.success = success\n        if self.success:\n            self._state = \"done\"\n            self._cancel_button.focus_set()\n            self._cancel_button[\"default\"] = \"active\"\n            self._ok_button[\"default\"] = \"normal\"\n        elif self._autostart:\n            # Can't try again if failed with autostart\n            self._state = \"done\"\n            self._cancel_button.focus_set()\n            self._cancel_button[\"default\"] = \"active\"\n            self._ok_button[\"default\"] = \"normal\"\n        else:\n            # allows trying again when failed\n            self._state = \"idle\"\n            self._ok_button.focus_set()\n            self._ok_button[\"default\"] = \"active\"\n            self._cancel_button[\"default\"] = \"normal\"\n\n        self._progress_bar.stop()\n        # need to put to determinate mode, otherwise it looks half done\n        self._progress_bar[\"mode\"] = \"determinate\"\n        if self.success and self._autostart and not self.log_frame.winfo_ismapped():\n            self.close()\n\n        if not self.success and not self.log_frame.winfo_ismapped():\n            self.toggle_log_frame()", "is_method": true, "class_name": "WorkDialog", "function_description": "Handles the completion state of a work dialog, updating UI elements and progress status based on success or failure. It manages retry logic, button focus, and visibility of the log frame accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "is_ready_for_work", "line_number": 341, "body": "def is_ready_for_work(self):\n        return True", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Trivial readiness check method in SubprocessDialog that always indicates the subprocess is ready to perform work."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_title", "line_number": 344, "body": "def get_title(self):\n        return self._title", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Returns the current title of the SubprocessDialog instance. This provides access to the dialog's title information for display or reference purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_instructions", "line_number": 347, "body": "def get_instructions(self) -> Optional[str]:\n        return self._long_description", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Returns the detailed instruction text associated with the subprocess, providing contextual guidance or information for users or other components interacting with the subprocess dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "start_work", "line_number": 350, "body": "def start_work(self):\n        if hasattr(self._proc, \"cmd\"):\n            try:\n                self.append_text(subprocess.list2cmdline(self._proc.cmd) + \"\\n\")\n            except:\n                logger.warning(\"Could not extract cmd (%s)\", self._proc.cmd)\n        self._start_listening_current_proc()", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Starts the subprocess dialog by displaying the command line used and initiating listening for the subprocess output, enabling real-time interaction or monitoring of the process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "_start_listening_current_proc", "line_number": 358, "body": "def _start_listening_current_proc(self):\n        def listen_stream(stream_name):\n            stream = getattr(self._proc, stream_name)\n            while True:\n                data = stream.readline()\n                self.append_text(data, stream_name)\n                self._check_set_action_text_from_output_line(data)\n                setattr(self, stream_name, getattr(self, stream_name) + data)\n                if data == \"\":\n                    logger.debug(\"Finished reading %s\", stream_name)\n                    break\n\n            if stream_name == \"stdout\":\n                self._finish_process()\n\n            logger.debug(\"Returning from reading %s\", stream_name)\n\n        self._stdout_thread = threading.Thread(target=listen_stream, args=[\"stdout\"], daemon=True)\n        self._stdout_thread.start()\n        if self._proc.stderr is not None:\n            self._stderr_thread = threading.Thread(\n                target=listen_stream, args=[\"stderr\"], daemon=True\n            )\n            self._stderr_thread.start()", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Starts background threads to continuously read a subprocess\u2019s stdout and stderr streams, capturing and processing their output in real time until the subprocess ends. This enables asynchronous monitoring and handling of subprocess outputs within the SubprocessDialog class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "_finish_process", "line_number": 383, "body": "def _finish_process(self):\n        self.returncode = self._proc.wait()\n        logger.debug(\"Process ended with returncode %s\", self.returncode)\n        if self.returncode:\n            self.set_action_text(\"Error\")\n            self.append_text(\"Error: process returned with code %s\\n\" % self.returncode)\n        else:\n            self.set_action_text(\"Done!\")\n            self.append_text(\"Done!\")\n\n        self.report_done(self.returncode == 0)", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Helper method inside SubprocessDialog that finalizes a subprocess by capturing its exit code, updating the UI with success or error status, and signaling completion to other components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_action_text_max_length", "line_number": 395, "body": "def get_action_text_max_length(self):\n        return 35", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Returns the maximum allowed length for action text in the SubprocessDialog, enforcing a consistent limit for user inputs or display elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "_check_set_action_text_from_output_line", "line_number": 398, "body": "def _check_set_action_text_from_output_line(self, line):\n        if len(line) > self.get_action_text_max_length():\n            line = line[: self.get_action_text_max_length() - 3].strip() + \"...\"\n        if line:\n            self.set_action_text(line.strip())", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Internal helper method of SubprocessDialog that sets action text based on a given output line, truncating it if it exceeds a specified maximum length to ensure concise action descriptions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "cancel_work", "line_number": 404, "body": "def cancel_work(self):\n        super().cancel_work()\n        # try gently first\n        try:\n            try:\n                if running_on_windows():\n                    os.kill(self._proc.pid, signal.CTRL_BREAK_EVENT)  # pylint: disable=no-member\n                else:\n                    os.kill(self._proc.pid, signal.SIGINT)\n\n                self._proc.wait(2)\n            except subprocess.TimeoutExpired:\n                if self._proc.poll() is None:\n                    # now let's be more concrete\n                    self._proc.kill()\n        except OSError as e:\n            messagebox.showerror(\"Error\", \"Could not kill subprocess: \" + str(e), master=self)\n            logger.error(\"Could not kill subprocess\", exc_info=e)", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Method of SubprocessDialog that attempts to gracefully terminate a running subprocess, escalating to forceful termination if needed, and handles termination errors by notifying the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "listen_stream", "line_number": 359, "body": "def listen_stream(stream_name):\n            stream = getattr(self._proc, stream_name)\n            while True:\n                data = stream.readline()\n                self.append_text(data, stream_name)\n                self._check_set_action_text_from_output_line(data)\n                setattr(self, stream_name, getattr(self, stream_name) + data)\n                if data == \"\":\n                    logger.debug(\"Finished reading %s\", stream_name)\n                    break\n\n            if stream_name == \"stdout\":\n                self._finish_process()\n\n            logger.debug(\"Returning from reading %s\", stream_name)", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Captures and processes output lines from a subprocess stream in real-time, appending text and triggering related actions until the stream ends. It finalizes the process upon completing stdout reading."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "range_contains_smaller", "line_number": 122, "body": "def range_contains_smaller(one: TextRange, other: TextRange) -> bool:\n    this_start = (one.lineno, one.col_offset)\n    this_end = (one.end_lineno, one.end_col_offset)\n    other_start = (other.lineno, other.col_offset)\n    other_end = (other.end_lineno, other.end_col_offset)\n\n    return (\n        this_start < other_start\n        and this_end > other_end\n        or this_start == other_start\n        and this_end > other_end\n        or this_start < other_start\n        and this_end == other_end\n    )", "is_method": false, "function_description": "Determines whether one text range fully contains another by comparing their start and end positions. Useful for checking hierarchical or nested spans in source code or text analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "range_contains_smaller_or_equal", "line_number": 138, "body": "def range_contains_smaller_or_equal(one: TextRange, other: TextRange) -> bool:\n    return range_contains_smaller(one, other) or one == other", "is_method": false, "function_description": "Utility function that checks if one text range is either contained within or equal to another, supporting precise range comparisons in text processing tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "serialize_message", "line_number": 217, "body": "def serialize_message(msg: Record) -> str:\n    # I want to transfer only ASCII chars because encodings are not reliable\n    # (eg. can't find a way to specify PYTHONIOENCODING for cx_freeze'd program)\n    return MESSAGE_MARKER + ascii(msg)", "is_method": false, "function_description": "Function that converts a message record into a safely transferable ASCII string with a marker prefix, ensuring reliable encoding for environments with limited encoding support."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "parse_message", "line_number": 223, "body": "def parse_message(msg_string: str) -> Record:\n    # DataFrames may have nan\n    # pylint: disable=unused-variable\n    nan = float(\"nan\")  # @UnusedVariable\n    assert msg_string[0] == MESSAGE_MARKER\n    return eval(msg_string[1:])", "is_method": false, "function_description": "Utility function that parses a specially formatted message string into a Record object by evaluating the string content after a specific marker. It enables conversion of text messages into structured data records."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "normpath_with_actual_case", "line_number": 231, "body": "def normpath_with_actual_case(name: str) -> str:\n    \"\"\"In Windows return the path with the case it is stored in the filesystem\"\"\"\n    if not os.path.exists(name):\n        return os.path.normpath(name)\n\n    assert os.path.isabs(name) or os.path.ismount(name), \"Not abs nor mount: \" + name\n    assert os.path.exists(name), \"Not exists: \" + name\n\n    if os.name == \"nt\":\n        # https://stackoverflow.com/questions/2113822/python-getting-filename-case-as-stored-in-windows/2114975\n        name = os.path.normpath(name)\n\n        from ctypes import create_unicode_buffer, windll\n\n        buf = create_unicode_buffer(512)\n        # GetLongPathNameW alone doesn't fix filename part\n        windll.kernel32.GetShortPathNameW(name, buf, 512)  # @UndefinedVariable\n        windll.kernel32.GetLongPathNameW(buf.value, buf, 512)  # @UndefinedVariable\n        result = buf.value\n\n        if result.casefold() != name.casefold():\n            # Sometimes GetShortPathNameW + GetLongPathNameW doesn't work\n            # see eg. https://github.com/thonny/thonny/issues/925\n            windll.kernel32.GetLongPathNameW(name, buf, 512)  # @UndefinedVariable\n            result = buf.value\n\n            if result.casefold() != name.casefold():\n                result = name\n\n        if result[1] == \":\":\n            # ensure drive letter is capital\n            return result[0].upper() + result[1:]\n        else:\n            return result\n    else:\n        # easy on Linux\n        # too difficult on mac\n        # https://stackoverflow.com/questions/14515073/in-python-on-osx-with-hfs-how-can-i-get-the-correct-case-of-an-existing-filenam\n        # Hopefully only correct case comes into Thonny (eg. via open dialog)\n        return os.path.normpath(name)", "is_method": false, "function_description": "Function that returns a normalized filesystem path reflecting the actual letter casing on Windows, preserving the case as stored on disk; on other systems, it returns a standard normalized path. Useful for case-sensitive path comparisons or display on Windows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "is_same_path", "line_number": 273, "body": "def is_same_path(name1: str, name2: str) -> bool:\n    return os.path.normpath(os.path.normcase(name1)) == os.path.normpath(os.path.normcase(name2))", "is_method": false, "function_description": "Function that compares two file path strings for equivalence by normalizing case and path format, ensuring consistent path comparison across different operating systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "path_startswith", "line_number": 277, "body": "def path_startswith(child_name: str, dir_name: str) -> bool:\n    normchild = os.path.normpath(os.path.normcase(child_name))\n    normdir = os.path.normpath(os.path.normcase(dir_name))\n    return normdir == normchild or normchild.startswith(normdir.rstrip(os.path.sep) + os.path.sep)", "is_method": false, "function_description": "Function that determines if one path is the same as or is nested within another directory path, enabling verification of hierarchical file system relationships in a normalized and case-insensitive manner."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "read_source", "line_number": 283, "body": "def read_source(filename):\n    import tokenize\n\n    with tokenize.open(filename) as fp:\n        return fp.read()", "is_method": false, "function_description": "Function that reads and returns the complete source code from a specified file using Python's tokenize module for proper encoding detection. It enables safe reading of source files regardless of their encoding."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_exe_dirs", "line_number": 290, "body": "def get_exe_dirs():\n    result = []\n    if site.ENABLE_USER_SITE:\n        if platform.system() == \"Windows\":\n            if site.getusersitepackages():\n                result.append(site.getusersitepackages().replace(\"site-packages\", \"Scripts\"))\n        else:\n            if site.getuserbase():\n                result.append(site.getuserbase() + \"/bin\")\n\n    main_scripts = os.path.join(sys.prefix, \"Scripts\")\n    if os.path.isdir(main_scripts) and main_scripts not in result:\n        result.append(main_scripts)\n\n    if os.path.dirname(sys.executable) not in result:\n        result.append(os.path.dirname(sys.executable))\n\n    # These entries are used by Anaconda\n    for part in [\n        \"Library/mingw-w64/bin\",\n        \"Library/usr/bin\",\n        \"Library/bin\",\n        \"Scripts\",\n        \"bin\",\n        \"condabin\",\n    ]:\n        dirpath = os.path.join(sys.prefix, part.replace(\"/\", os.sep))\n        if os.path.isdir(dirpath) and dirpath not in result:\n            result.append(dirpath)\n\n    if platform.system() != \"Windows\" and \"/usr/local/bin\" not in result:\n        # May be missing on macOS, when started as bundle\n        # (yes, more may be missing, but this one is most useful)\n        result.append(\"/usr/local/bin\")\n\n    return result", "is_method": false, "function_description": "Returns a list of executable directories relevant to the current Python environment, including user-specific, system, and Anaconda-related paths. This helps locate script and binary folders for environment management or subprocess execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_site_dir", "line_number": 328, "body": "def get_site_dir(symbolic_name, executable=None):\n    if not executable or executable == sys.executable:\n        result = getattr(site, symbolic_name, \"\")\n    else:\n        result = (\n            subprocess.check_output(\n                [executable, \"-m\", \"site\", \"--\" + symbolic_name.lower().replace(\"_\", \"-\")],\n                universal_newlines=True,\n            )\n            .decode()\n            .strip()\n        )\n\n    return result if result else None", "is_method": false, "function_description": "Function that retrieves the path of specific site-related directories for a given Python executable, supporting queries for standard or custom Python environments. Useful for environment inspection and configuration tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_base_executable", "line_number": 344, "body": "def get_base_executable():\n    if sys.exec_prefix == sys.base_exec_prefix:\n        return sys.executable\n\n    if platform.system() == \"Windows\":\n        result = sys.base_exec_prefix + \"\\\\\" + os.path.basename(sys.executable)\n        result = normpath_with_actual_case(result)\n    else:\n        result = sys.executable.replace(sys.exec_prefix, sys.base_exec_prefix)\n\n    if not os.path.isfile(result):\n        raise RuntimeError(\"Can't locate base executable\")\n\n    return result", "is_method": false, "function_description": "Function that returns the path to the Python base executable, ensuring the path points to the original interpreter rather than a virtual environment. This is useful for locating the base Python binary in diverse runtime contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_augmented_system_path", "line_number": 360, "body": "def get_augmented_system_path(extra_dirs):\n    path_items = os.environ.get(\"PATH\", \"\").split(os.pathsep)\n\n    for d in reversed(extra_dirs):\n        if d not in path_items:\n            path_items.insert(0, d)\n\n    return os.pathsep.join(path_items)", "is_method": false, "function_description": "Function that returns the system PATH environment variable augmented by prepending specified directories, ensuring they appear before existing entries. Useful for temporarily extending executable search paths without modifying the actual environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "update_system_path", "line_number": 370, "body": "def update_system_path(env, value):\n    # in Windows, env keys are not case sensitive\n    # this is important if env is a dict (not os.environ)\n    if platform.system() == \"Windows\":\n        found = False\n        for key in env:\n            if key.upper() == \"PATH\":\n                found = True\n                env[key] = value\n\n        if not found:\n            env[\"PATH\"] = value\n    else:\n        env[\"PATH\"] = value", "is_method": false, "function_description": "Function that updates the PATH environment variable in a given environment dictionary, handling case insensitivity on Windows to ensure the path is correctly set or added."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "is_hidden_or_system_file", "line_number": 392, "body": "def is_hidden_or_system_file(path: str) -> bool:\n    if os.path.basename(path).startswith(\".\"):\n        return True\n    elif platform.system() == \"Windows\":\n        from ctypes import windll\n\n        FILE_ATTRIBUTE_HIDDEN = 0x2\n        FILE_ATTRIBUTE_SYSTEM = 0x4\n        return bool(\n            windll.kernel32.GetFileAttributesW(path)  # @UndefinedVariable\n            & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)\n        )\n    else:\n        return False", "is_method": false, "function_description": "Function that determines if a given file path points to a hidden or system file, supporting both Unix-like and Windows systems. Useful for filtering or managing files based on their visibility or system status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_dirs_children_info", "line_number": 408, "body": "def get_dirs_children_info(\n    paths: List[str], include_hidden: bool = False\n) -> Dict[str, Optional[Dict[str, Dict]]]:\n    return {path: get_single_dir_child_data(path, include_hidden) for path in paths}", "is_method": false, "function_description": "Returns a mapping of directory paths to their respective children information, optionally including hidden files. Useful for batch retrieval of directory contents in file system operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_single_dir_child_data", "line_number": 414, "body": "def get_single_dir_child_data(path: str, include_hidden: bool = False) -> Optional[Dict[str, Dict]]:\n    if path == \"\":\n        if platform.system() == \"Windows\":\n            return {**get_windows_volumes_info(), **get_windows_network_locations()}\n        else:\n            return get_single_dir_child_data(\"/\", include_hidden)\n\n    elif os.path.isdir(path) or os.path.ismount(path):\n        result = {}\n\n        try:\n            for child in os.listdir(path):\n                full_child_path = os.path.join(path, child)\n                if not os.path.exists(full_child_path):\n                    # must be broken link\n                    continue\n                full_child_path = normpath_with_actual_case(full_child_path)\n                hidden = is_hidden_or_system_file(full_child_path)\n                if not hidden or include_hidden:\n                    name = os.path.basename(full_child_path)\n                    st = os.stat(full_child_path, dir_fd=None, follow_symlinks=True)\n                    result[name] = {\n                        \"size\": None if os.path.isdir(full_child_path) else st.st_size,\n                        \"modified\": st.st_mtime,\n                        \"hidden\": hidden,\n                    }\n        except PermissionError:\n            result[\"<not accessible>\"] = {\n                \"kind\": \"error\",\n                \"size\": -1,\n                \"modified\": None,\n                \"hidden\": None,\n            }\n\n        return result\n    else:\n        return None", "is_method": false, "function_description": "Function that lists immediate child files and directories of a given path, returning metadata like size, modification time, and hidden status, with special handling for root paths and Windows volumes. Useful for directory browsing with optional inclusion of hidden items."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_windows_volumes_info", "line_number": 453, "body": "def get_windows_volumes_info():\n    # http://stackoverflow.com/a/2288225/261181\n    # http://msdn.microsoft.com/en-us/library/windows/desktop/aa364939%28v=vs.85%29.aspx\n    import string\n    from ctypes import windll\n\n    all_drive_types = [\n        \"DRIVE_UNKNOWN\",\n        \"DRIVE_NO_ROOT_DIR\",\n        \"DRIVE_REMOVABLE\",\n        \"DRIVE_FIXED\",\n        \"DRIVE_REMOTE\",\n        \"DRIVE_CDROM\",\n        \"DRIVE_RAMDISK\",\n    ]\n\n    required_drive_types = [\"DRIVE_REMOVABLE\", \"DRIVE_FIXED\", \"DRIVE_REMOTE\", \"DRIVE_RAMDISK\"]\n\n    result = {}\n\n    bitmask = windll.kernel32.GetLogicalDrives()  # @UndefinedVariable\n    for letter in string.ascii_uppercase:\n        if not bitmask & 1:\n            pass\n        else:\n            drive_type = all_drive_types[\n                windll.kernel32.GetDriveTypeW(\"%s:\\\\\" % letter)\n            ]  # @UndefinedVariable\n\n            # NB! Drive A can be present in bitmask but actually missing.\n            # In this case querying information about it would freeze the UI\n            # for several seconds.\n            # One solution is to uninstall the device in device manager,\n            # but OS may restore the drive later.\n            # Therefore it is safest to skip A drive (user can access it via Open dialog)\n\n            if drive_type in required_drive_types and (\n                letter != \"A\" or drive_type != \"DRIVE_REMOVABLE\"\n            ):\n                drive = letter + \":\"\n                path = drive + \"\\\\\"\n\n                try:\n                    st = os.stat(path)\n                    volume_name = get_windows_volume_name(path)\n                    if not volume_name:\n                        volume_name = \"Disk\"\n\n                    label = volume_name + \" (\" + drive + \")\"\n                    result[path] = {\n                        \"label\": label,\n                        \"size\": None,\n                        \"modified\": max(st.st_mtime, st.st_ctime),\n                    }\n                except OSError as e:\n                    logger.warning(\"Could not get information for %s\", path, exc_info=e)\n\n        bitmask >>= 1\n\n    return result", "is_method": false, "function_description": "Function that scans all available Windows drives of specific types and returns their paths with basic metadata, providing labeled volume info suitable for disk management or display purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_windows_volume_name", "line_number": 515, "body": "def get_windows_volume_name(path):\n    # https://stackoverflow.com/a/12056414/261181\n    import ctypes\n\n    kernel32 = ctypes.windll.kernel32\n    volume_name_buffer = ctypes.create_unicode_buffer(1024)\n    file_system_name_buffer = ctypes.create_unicode_buffer(1024)\n    serial_number = None\n    max_component_length = None\n    file_system_flags = None\n\n    result = kernel32.GetVolumeInformationW(\n        ctypes.c_wchar_p(path),\n        volume_name_buffer,\n        ctypes.sizeof(volume_name_buffer),\n        serial_number,\n        max_component_length,\n        file_system_flags,\n        file_system_name_buffer,\n        ctypes.sizeof(file_system_name_buffer),\n    )\n\n    if result:\n        return volume_name_buffer.value\n    else:\n        return None", "is_method": false, "function_description": "Function that retrieves the volume (drive) name of a given Windows filesystem path, useful for identifying or displaying the label of a disk or partition."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_windows_network_locations", "line_number": 543, "body": "def get_windows_network_locations():\n    import ctypes.wintypes\n\n    CSIDL_NETHOOD = 0x13\n    SHGFP_TYPE_CURRENT = 0\n    buf = ctypes.create_unicode_buffer(ctypes.wintypes.MAX_PATH)\n    ctypes.windll.shell32.SHGetFolderPathW(0, CSIDL_NETHOOD, 0, SHGFP_TYPE_CURRENT, buf)\n    shortcuts_dir = buf.value\n\n    result = {}\n    for entry in os.scandir(shortcuts_dir):\n        # full_path = normpath_with_actual_case(entry.path)\n        lnk_path = os.path.join(entry.path, \"target.lnk\")\n        if os.path.exists(lnk_path):\n            try:\n                target = get_windows_lnk_target(lnk_path)\n                result[target] = {\n                    \"label\": entry.name + \" (\" + target + \")\",\n                    \"size\": None,\n                    \"modified\": None,\n                }\n            except Exception:\n                logger.error(\"Can't get target from %s\", lnk_path, exc_info=True)\n\n    return result", "is_method": false, "function_description": "Function that discovers and returns Windows network shortcut targets along with labels, enabling programs to access and reference network location links stored in the user's network shortcuts folder."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_windows_lnk_target", "line_number": 570, "body": "def get_windows_lnk_target(lnk_file_path):\n    import thonny\n\n    script_path = os.path.join(os.path.dirname(thonny.__file__), \"res\", \"PrintLnkTarget.vbs\")\n    cmd = [\"cscript\", \"/NoLogo\", script_path, lnk_file_path]\n    result = subprocess.check_output(cmd, universal_newlines=True, timeout=3)\n\n    return result.strip()", "is_method": false, "function_description": "Function that extracts and returns the target path from a Windows shortcut (.lnk) file by running a VBScript via the system command line. Useful for resolving actual file locations from shortcut files in automation or file management tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "execute_system_command", "line_number": 580, "body": "def execute_system_command(cmd, cwd=None, disconnect_stdin=False):\n    logger.debug(\"execute_system_command, cmd=%r, cwd=%s\", cmd, cwd)\n    env = dict(os.environ).copy()\n    encoding = \"utf-8\"\n    env[\"PYTHONIOENCODING\"] = encoding\n    # Make sure this python interpreter and its scripts are available\n    # in PATH\n    update_system_path(env, get_augmented_system_path(get_exe_dirs()))\n    popen_kw = dict(\n        env=env,\n        universal_newlines=True,\n        bufsize=0,\n    )\n\n    if cwd and os.path.isdir(cwd):\n        popen_kw[\"cwd\"] = cwd\n\n    if disconnect_stdin:\n        popen_kw[\"stdin\"] = subprocess.DEVNULL\n\n    if sys.version_info >= (3, 6):\n        popen_kw[\"errors\"] = \"replace\"\n        popen_kw[\"encoding\"] = encoding\n\n    if isinstance(cmd.cmd_line, str) and cmd.cmd_line.startswith(\"!\"):\n        cmd_line = cmd.cmd_line[1:]\n        popen_kw[\"shell\"] = True\n    else:\n        assert isinstance(cmd.cmd_line, list)\n        cmd_line = cmd.cmd_line\n    logger.debug(\"Popen(%r, ...)\", cmd_line)\n    proc = subprocess.Popen(cmd_line, **popen_kw)\n    proc.communicate()\n    return proc.wait()", "is_method": false, "function_description": "Function that executes a system command optionally within a specified directory, managing environment variables and input disconnection, and returns the command's exit status. It supports both shell commands and argument lists for flexible command execution scenarios."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "universal_dirname", "line_number": 616, "body": "def universal_dirname(path: str) -> str:\n    if \"/\" in path:\n        sep = \"/\"\n    elif \"\\\\\" in path:\n        sep = \"\\\\\"\n    else:\n        # micro:bit\n        return \"\"\n\n    path = path.rstrip(sep)\n    result = path[: path.rindex(sep)]\n    if not result:\n        return sep\n    else:\n        return result", "is_method": false, "function_description": "Function that returns the parent directory path from a given file path string, handling both Unix and Windows path separators. Useful for cross-platform directory navigation or path manipulation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "universal_relpath", "line_number": 633, "body": "def universal_relpath(path: str, context: str) -> str:\n    \"\"\"Tries to give relative path\"\"\"\n    if \"/\" in path:\n        import pathlib\n\n        p = pathlib.PurePosixPath(path)\n        try:\n            return str(p.relative_to(context))\n        except ValueError:\n            return path\n    else:\n        return os.path.relpath(path, context)", "is_method": false, "function_description": "Function that returns a relative path of a given path with respect to a context, handling both POSIX-style and other paths for flexible path resolution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_python_version_string", "line_number": 647, "body": "def get_python_version_string(version_info: Optional[Tuple] = None, maxsize=None):\n    result = \".\".join(map(str, sys.version_info[:3]))\n    if sys.version_info[3] != \"final\":\n        result += \"-\" + sys.version_info[3]\n\n    if maxsize is not None:\n        result += \" (\" + (\"64\" if sys.maxsize > 2 ** 32 else \"32\") + \" bit)\"\n\n    return result", "is_method": false, "function_description": "Returns a formatted string representing the current Python version and optionally indicates the system's architecture as 32- or 64-bit. This helps identify the Python environment for compatibility or debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "try_load_modules_with_frontend_sys_path", "line_number": 658, "body": "def try_load_modules_with_frontend_sys_path(module_names):\n    try:\n        frontend_sys_path = ast.literal_eval(os.environ[\"THONNY_FRONTEND_SYS_PATH\"])\n        assert isinstance(frontend_sys_path, list)\n    except Exception as e:\n        logger.warning(\"Could not get THONNY_FRONTEND_SYS_PATH\", exc_info=e)\n        return\n\n    from importlib import import_module\n\n    old_sys_path = sys.path.copy()\n    sys.path = sys.path + frontend_sys_path\n    try:\n        for name in module_names:\n            try:\n                import_module(name)\n            except ImportError:\n                pass\n    finally:\n        sys.path = old_sys_path", "is_method": false, "function_description": "Function that attempts to import specified modules by temporarily extending the system path with a frontend-specific environment path, enabling dynamic module loading in customized execution contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "update", "line_number": 61, "body": "def update(self, e, **kw):\n        self.__dict__.update(e, **kw)", "is_method": true, "class_name": "Record", "function_description": "Core utility of the Record class that updates the instance's attributes with values from a given dictionary and additional keyword arguments. It simplifies modifying multiple attributes in one call."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "setdefault", "line_number": 64, "body": "def setdefault(self, **kw):\n        \"updates those fields that are not yet present (similar to dict.setdefault)\"\n        for key in kw:\n            if not hasattr(self, key):\n                setattr(self, key, kw[key])", "is_method": true, "class_name": "Record", "function_description": "This method sets attributes on the Record instance only if they don't already exist, allowing default values to be assigned without overwriting existing ones. It facilitates safe initialization of object fields with default data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get", "line_number": 70, "body": "def get(self, key, default=None):\n        return self.__dict__.get(key, default)", "is_method": true, "class_name": "Record", "function_description": "Utility method of the Record class that retrieves the value for a given attribute key, returning a default if the key is not found. It simplifies safe access to instance attributes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__getitem__", "line_number": 73, "body": "def __getitem__(self, key):\n        return self.__dict__[key]", "is_method": true, "class_name": "Record", "function_description": "Provides dictionary-style access to the Record object's attributes by returning the value associated with the given key. Enables intuitive retrieval of attribute values using bracket notation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__delitem__", "line_number": 76, "body": "def __delitem__(self, key):\n        self.__dict__.__delitem__(key)", "is_method": true, "class_name": "Record", "function_description": "Overrides item deletion to remove an attribute from the Record instance by key. It enables dictionary-like deletion of stored record fields within the class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__setitem__", "line_number": 79, "body": "def __setitem__(self, key, value):\n        self.__dict__[key] = value", "is_method": true, "class_name": "Record", "function_description": "Special method of the Record class that assigns a value to a given key, allowing dictionary-style item assignment directly to the object's attributes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__contains__", "line_number": 82, "body": "def __contains__(self, key):\n        return key in self.__dict__", "is_method": true, "class_name": "Record", "function_description": "Method enabling `in` keyword support to check if a given key exists within the Record instance's attributes. This facilitates intuitive and Pythonic membership testing for Record objects."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__repr__", "line_number": 85, "body": "def __repr__(self):\n        keys = self.__dict__.keys()\n        items = (\"{}={}\".format(k, repr(self.__dict__[k])) for k in keys)\n        return \"{}({})\".format(self.__class__.__name__, \", \".join(items))", "is_method": true, "class_name": "Record", "function_description": "Provides a readable string representation of a Record instance, showing its class name and all attribute names with their corresponding values. Useful for debugging and logging object state clearly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__str__", "line_number": 90, "body": "def __str__(self):\n        keys = sorted(self.__dict__.keys())\n        items = (\"{}={}\".format(k, repr(self.__dict__[k])) for k in keys)\n        return \"{}({})\".format(self.__class__.__name__, \", \".join(items))", "is_method": true, "class_name": "Record", "function_description": "Provides a readable string representation of a Record instance by listing its attributes and their values, aiding in debugging and logging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__eq__", "line_number": 95, "body": "def __eq__(self, other):\n        # pylint: disable=unidiomatic-typecheck\n\n        if type(self) != type(other):\n            return False\n\n        if len(self.__dict__) != len(other.__dict__):\n            return False\n\n        for key in self.__dict__:\n            if not hasattr(other, key):\n                return False\n            self_value = getattr(self, key)\n            other_value = getattr(other, key)\n\n            if type(self_value) != type(other_value) or self_value != other_value:\n                return False\n\n        return True", "is_method": true, "class_name": "Record", "function_description": "Provides an equality comparison for Record instances by checking type, attribute count, and matching attribute values, ensuring two records are identical in structure and content. This supports accurate object comparison in data processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__ne__", "line_number": 115, "body": "def __ne__(self, other):\n        return not self.__eq__(other)", "is_method": true, "class_name": "Record", "function_description": "Overrides inequality comparison to return True when two Record instances are not equal, complementing the equality check method. This enables proper use of the != operator for Record objects."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__hash__", "line_number": 118, "body": "def __hash__(self):\n        return hash(repr(self))", "is_method": true, "class_name": "Record", "function_description": "Provides a hash value for the Record instance based on its string representation, enabling its use in hashed collections like sets and dictionaries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_longest_common_path_prefix", "line_number": 628, "body": "def _longest_common_path_prefix(str_paths, path_class):\n    assert str_paths\n\n    if len(str_paths) == 1:\n        return str_paths[0]\n\n    list_of_parts = []\n    for str_path in str_paths:\n        list_of_parts.append(path_class(str_path).parts)\n\n    first = list_of_parts[0]\n    rest = list_of_parts[1:]\n\n    i = 0\n    while i < len(first):\n        item_i = first[i]\n        if not all([len(x) > i and x[i] == item_i for x in rest]):\n            break\n        else:\n            i += 1\n\n    if i == 0:\n        return \"\"\n\n    result = path_class(first[0])\n    for j in range(1, i):\n        result = result.joinpath(first[j])\n\n    return str(result)", "is_method": false, "function_description": "Function that finds the longest common path prefix among a list of filesystem paths, returning it as a string for use in path-related operations or comparisons."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "ensure_posix_directory", "line_number": 659, "body": "def ensure_posix_directory(\n    path: str, stat_mode_fun: Callable[[str], Optional[int]], mkdir_fun: Callable[[str], None]\n) -> None:\n    assert path.startswith(\"/\")\n    if path == \"/\":\n        return\n\n    for step in list(reversed(list(map(str, pathlib.PurePosixPath(path).parents)))) + [path]:\n\n        if step != \"/\":\n            mode = stat_mode_fun(step)\n            if mode is None:\n                mkdir_fun(step)\n            elif not stat.S_ISDIR(mode):\n                raise AssertionError(\"'%s' is file, not a directory\" % step)", "is_method": false, "function_description": "Utility function that ensures all directories in a given POSIX path exist by creating any missing ones and verifying existing elements are directories, preventing conflicts with files along the path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "interrupt_local_process", "line_number": 676, "body": "def interrupt_local_process() -> None:\n    \"\"\"Meant to be executed from a background thread\"\"\"\n    import signal\n\n    if hasattr(signal, \"raise_signal\"):\n        # Python 3.8 and later\n        signal.raise_signal(signal.SIGINT)\n    elif sys.platform == \"win32\":\n        # https://stackoverflow.com/a/51122690/261181\n        import ctypes\n\n        ucrtbase = ctypes.CDLL(\"ucrtbase\")\n        c_raise = ucrtbase[\"raise\"]\n        c_raise(signal.SIGINT)\n    else:\n        # Does not give KeyboardInterrupt in Windows\n        os.kill(os.getpid(), signal.SIGINT)", "is_method": false, "function_description": "Function that programmatically sends an interrupt signal (SIGINT) to the local process, enabling background threads to trigger KeyboardInterrupt exceptions for graceful interruption handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "get_ssh_password_file_path", "line_number": 695, "body": "def get_ssh_password_file_path():\n    from thonny import THONNY_USER_DIR\n\n    return os.path.join(THONNY_USER_DIR, \"ssh_password\")", "is_method": false, "function_description": "Utility function that returns the file path for storing SSH passwords within the Thonny user directory, facilitating secure and consistent access to SSH credential storage."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "delete_stored_ssh_password", "line_number": 701, "body": "def delete_stored_ssh_password():\n    if os.path.exists(get_ssh_password_file_path()):\n        # invalidate stored password\n        os.remove(get_ssh_password_file_path())", "is_method": false, "function_description": "Utility function that removes a stored SSH password file, effectively invalidating any saved SSH credentials for security or cleanup purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_init_command_reader", "line_number": 52, "body": "def _init_command_reader(self):\n        # Don't use threading for creating a management thread, because I don't want them\n        # to be affected by threading.settrace\n        _thread.start_new_thread(self._read_incoming_messages, ())", "is_method": true, "class_name": "BaseBackend", "function_description": "Internal method of BaseBackend that starts a new thread to continuously read incoming messages without using Python's threading module."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "mainloop", "line_number": 57, "body": "def mainloop(self):\n        try:\n            while self._should_keep_going():\n                try:\n                    try:\n                        msg = self._fetch_next_incoming_message(timeout=0.01)\n                    except queue.Empty:\n                        self._perform_idle_tasks()\n                    else:\n                        if isinstance(msg, InputSubmission):\n                            self._handle_user_input(msg)\n                        elif isinstance(msg, EOFCommand):\n                            self._handle_eof_command(msg)\n                        else:\n                            self._current_command = msg\n                            self._handle_normal_command(msg)\n                except KeyboardInterrupt:\n                    self._send_output(\"KeyboardInterrupt\", \"stderr\")  # CPython idle REPL does this\n                    self.send_message(ToplevelResponse())\n        except ConnectionClosedException:\n            sys.exit(0)", "is_method": true, "class_name": "BaseBackend", "function_description": "Core loop method of the BaseBackend class that continuously processes incoming messages, handling user inputs, commands, and idle states until termination or connection closure. It centralizes message-driven backend operation and graceful interruption handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_current_command_is_interrupted", "line_number": 79, "body": "def _current_command_is_interrupted(self):\n        return getattr(self._current_command, \"interrupted\", False)", "is_method": true, "class_name": "BaseBackend", "function_description": "Utility method in BaseBackend that checks whether the currently executing command has been marked as interrupted, allowing for responsive control flow in command processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_fetch_next_incoming_message", "line_number": 82, "body": "def _fetch_next_incoming_message(self, timeout=None):\n        return self._incoming_message_queue.get(timeout=timeout)", "is_method": true, "class_name": "BaseBackend", "function_description": "Internal method of the BaseBackend class that retrieves the next incoming message from a queue, optionally waiting up to a specified timeout. It enables asynchronous message consumption for backend processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_report_progress", "line_number": 85, "body": "def _report_progress(\n        self, cmd, description: Optional[str], value: float, maximum: float\n    ) -> None:\n        # Don't notify too often (unless it's the final notification)\n        if value != maximum and time.time() - self._last_progress_reporting_time < 0.2:\n            return\n\n        self.send_message(\n            BackendEvent(\n                event_type=\"InlineProgress\",\n                command_id=cmd[\"id\"],\n                value=value,\n                maximum=maximum,\n                description=description,\n            )\n        )\n        self._last_progress_reporting_time = time.time()", "is_method": true, "class_name": "BaseBackend", "function_description": "Private method of BaseBackend that sends periodic progress updates for a command, ensuring notifications are not sent too frequently except for the final completion event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_report_current_action", "line_number": 103, "body": "def _report_current_action(self, cmd, description: str) -> None:\n        self.send_message(\n            BackendEvent(\n                event_type=\"InlineProgress\",\n                command_id=cmd[\"id\"],\n                description=description,\n            )\n        )", "is_method": true, "class_name": "BaseBackend", "function_description": "Internal method of BaseBackend that sends a progress update message reflecting the current action described by a command and its description. It supports communicating inline progress during backend operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_read_incoming_messages", "line_number": 112, "body": "def _read_incoming_messages(self):\n        # works in a separate thread\n        while self._should_keep_going():\n            if not self._read_one_incoming_message():\n                break", "is_method": true, "class_name": "BaseBackend", "function_description": "Internal method of BaseBackend that continuously reads incoming messages in a loop until stopped or reading fails, supporting asynchronous message processing in a separate thread."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_read_one_incoming_message", "line_number": 118, "body": "def _read_one_incoming_message(self):\n        line = self._read_incoming_msg_line()\n        if line == \"\":\n            return False\n        msg = parse_message(line)\n        if isinstance(msg, ImmediateCommand):\n            # This will be handled right away\n            self._handle_immediate_command(msg)\n        else:\n            self._incoming_message_queue.put(msg)\n        return True", "is_method": true, "class_name": "BaseBackend", "function_description": "Core utility method of BaseBackend that reads and processes one incoming message, handling immediate commands instantly or queuing others for later use in message-driven communication systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_prepare_command_response", "line_number": 130, "body": "def _prepare_command_response(\n        self, response: Union[MessageFromBackend, Dict, None], command: CommandToBackend\n    ) -> MessageFromBackend:\n        if response is None:\n            response = {}\n\n        if \"id\" in command and \"command_id\" not in response:\n            response[\"command_id\"] = command[\"id\"]\n\n        if isinstance(response, MessageFromBackend):\n            if \"command_name\" not in response:\n                response[\"command_name\"] = command[\"name\"]\n            return response\n        else:\n            if isinstance(response, dict):\n                args = response\n            else:\n                args = {}\n\n            if isinstance(command, ToplevelCommand):\n                return ToplevelResponse(command_name=command.name, **args)\n            else:\n                assert isinstance(command, InlineCommand)\n                return InlineResponse(command_name=command.name, **args)", "is_method": true, "class_name": "BaseBackend", "function_description": "Core method of BaseBackend that standardizes and enriches backend responses with command metadata, enabling consistent communication formats for different command types (toplevel or inline) in command-response workflows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "send_message", "line_number": 155, "body": "def send_message(self, msg: MessageFromBackend) -> None:\n        sys.stdout.write(serialize_message(msg) + \"\\n\")\n        sys.stdout.flush()", "is_method": true, "class_name": "BaseBackend", "function_description": "Utility method of the BaseBackend class that sends serialized messages to the standard output stream, enabling communication or logging through message dispatching."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_send_output", "line_number": 159, "body": "def _send_output(self, data, stream_name):\n        if not data:\n            return\n\n        data = self._transform_output(data, stream_name)\n        msg = BackendEvent(event_type=\"ProgramOutput\", stream_name=stream_name, data=data)\n        self.send_message(msg)", "is_method": true, "class_name": "BaseBackend", "function_description": "Internal method of the BaseBackend class that processes and sends transformed output data to a specified stream, facilitating communication of program output events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_transform_output", "line_number": 167, "body": "def _transform_output(self, data, stream_name):\n        return data", "is_method": true, "class_name": "BaseBackend", "function_description": "This internal method of BaseBackend returns the given data unmodified, serving as a default or placeholder for output transformation that subclasses can override."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_read_incoming_msg_line", "line_number": 170, "body": "def _read_incoming_msg_line(self) -> str:\n        return sys.stdin.readline()", "is_method": true, "class_name": "BaseBackend", "function_description": "Private method of the BaseBackend class that reads a single line of input from the standard input stream. It serves as a basic utility for receiving incoming messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_report_internal_exception", "line_number": 177, "body": "def _report_internal_exception(self, exception=None):\n        logger.exception(\"PROBLEM WITH THONNY'S BACK-END\", exc_info=exception)", "is_method": true, "class_name": "BaseBackend", "function_description": "Internal method in BaseBackend that logs backend exceptions with detailed traceback for debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_report_internal_error", "line_number": 180, "body": "def _report_internal_error(self, message):\n        print(\"PROBLEM WITH THONNY'S BACK-END:\\n\" + message + \"\\n\", file=sys.stderr)", "is_method": true, "class_name": "BaseBackend", "function_description": "Internal utility of BaseBackend that reports backend errors by printing a standardized error message to the standard error output for diagnostic purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_should_keep_going", "line_number": 184, "body": "def _should_keep_going(self) -> bool:\n        \"\"\"Returns False when there is no point in processing more commands\n        (eg. connection to the target process is lost or target process has exited)\"\"\"", "is_method": true, "class_name": "BaseBackend", "function_description": "Utility method in BaseBackend that determines whether to continue processing commands, by checking if the target process is still connected and running."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_handle_immediate_command", "line_number": 201, "body": "def _handle_immediate_command(self, cmd: ImmediateCommand) -> None:\n        \"\"\"Command handler will be executed in command reading thread, right after receiving the command\"\"\"", "is_method": true, "class_name": "BaseBackend", "function_description": "Internal method of the BaseBackend class that processes immediate commands as soon as they are received, ensuring prompt handling within the command reading thread."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_get_dirs_children_info", "line_number": 211, "body": "def _cmd_get_dirs_children_info(self, cmd):\n        \"\"\"Provides information about immediate children of paths opened in a file browser\"\"\"\n        data = {\n            path: self._get_filtered_dir_children_info(path, cmd[\"include_hidden\"])\n            for path in cmd[\"paths\"]\n        }\n        return {\"node_id\": cmd[\"node_id\"], \"dir_separator\": self._get_sep(), \"data\": data}", "is_method": true, "class_name": "MainBackend", "function_description": "This function returns detailed information about the immediate child entries of specified directory paths, optionally including hidden files. It supports file browser interfaces by providing structured directory content data with metadata like path separators."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_prepare_upload", "line_number": 219, "body": "def _cmd_prepare_upload(self, cmd):\n        \"\"\"Returns info about items to be overwritten or merged by cmd.paths\"\"\"\n        return {\"existing_items\": self._get_paths_info(cmd.target_paths, recurse=False)}", "is_method": true, "class_name": "MainBackend", "function_description": "Internal utility of MainBackend that identifies existing items at specified paths to inform potential overwrites or merges before performing an upload operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_prepare_download", "line_number": 223, "body": "def _cmd_prepare_download(self, cmd):\n        assert \"id\" in cmd\n        \"\"\"Returns info about all items under and including cmd.paths\"\"\"\n        return {\"all_items\": self._get_paths_info(cmd.source_paths, recurse=True)}", "is_method": true, "class_name": "MainBackend", "function_description": "Internal method of MainBackend that returns detailed information about all items under specified source paths, including subdirectories, facilitating recursive retrieval of file or directory metadata."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_paths_info", "line_number": 228, "body": "def _get_paths_info(self, paths: List[str], recurse: bool) -> Dict[str, Dict]:\n        result = {}\n\n        for path in paths:\n            info = self._get_path_info(path)\n            if info is not None:\n                info[\"anchor\"] = path\n                result[path] = info\n\n            if recurse and info is not None and info[\"kind\"] == \"dir\":\n                desc_infos = self._get_dir_descendants_info(path)\n                for key in desc_infos:\n                    desc_infos[key][\"anchor\"] = path\n                result.update(desc_infos)\n\n        return result", "is_method": true, "class_name": "MainBackend", "function_description": "Core method of MainBackend that gathers information about given file system paths, optionally including all descendants if recursion is enabled, supporting detailed directory and file metadata retrieval for other components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_dir_descendants_info", "line_number": 245, "body": "def _get_dir_descendants_info(self, path: str, include_hidden: bool = False) -> Dict[str, Dict]:\n        \"\"\"Assumes path is dir. Dict is keyed by full path\"\"\"\n        result = {}\n        children_info = self._get_filtered_dir_children_info(path, include_hidden)\n        for child_name, child_info in children_info.items():\n            full_child_path = path + self._get_sep() + child_name\n            result[full_child_path] = child_info\n            if child_info[\"kind\"] == \"dir\":\n                result.update(self._get_dir_descendants_info(full_child_path))\n\n        return result", "is_method": true, "class_name": "MainBackend", "function_description": "Method of MainBackend that recursively collects and returns information about all descendant files and directories under a specified directory, optionally including hidden items. It provides a comprehensive directory tree metadata mapping keyed by full paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_filtered_dir_children_info", "line_number": 257, "body": "def _get_filtered_dir_children_info(\n        self, path: str, include_hidden: bool = False\n    ) -> Optional[Dict[str, Dict]]:\n        children = self._get_dir_children_info(path, include_hidden)\n        if children is None:\n            return None\n\n        return {name: children[name] for name in children if name not in IGNORED_FILES_AND_DIRS}", "is_method": true, "class_name": "MainBackend", "function_description": "Private method in MainBackend that retrieves directory contents filtered to exclude ignored files and directories, optionally including hidden items. It provides a cleaned view of directory children metadata for internal use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_path_info", "line_number": 267, "body": "def _get_path_info(self, path: str) -> Optional[Dict]:\n        \"\"\"Returns information about this path or None if it doesn't exist\"\"\"", "is_method": true, "class_name": "MainBackend", "function_description": "Private helper method in MainBackend that retrieves metadata about a specified path, returning None if the path does not exist."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_dir_children_info", "line_number": 271, "body": "def _get_dir_children_info(self, path: str) -> Optional[Dict[str, Dict]]:\n        \"\"\"For existing dirs returns Dict[child_short_name, Dict of its information].\n        Returns None if path doesn't exist or is not a dir.\n        \"\"\"", "is_method": true, "class_name": "MainBackend", "function_description": "Private method of MainBackend that returns detailed information about children entries in a directory path, or None if the path is invalid or not a directory. Useful for exploring directory contents and metadata."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_sep", "line_number": 277, "body": "def _get_sep(self) -> str:\n        \"\"\"Returns symbol for combining parent directory path and child name\"\"\"", "is_method": true, "class_name": "MainBackend", "function_description": "Private method of MainBackend that returns the separator symbol used to join parent directory paths with child names, supporting consistent path construction across the system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_download", "line_number": 285, "body": "def _cmd_download(self, cmd):\n        errors = self._transfer_files_and_dirs(\n            cmd.items, self._ensure_local_directory, self._download_file, cmd, pathlib.Path\n        )\n        return {\"errors\": errors}", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Utility method in UploadDownloadMixin that processes download commands by transferring specified files and directories to a local directory, returning any errors encountered during the operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_upload", "line_number": 291, "body": "def _cmd_upload(self, cmd):\n        errors = self._transfer_files_and_dirs(\n            cmd.items,\n            self._ensure_remote_directory,\n            self._upload_file,\n            cmd,\n            pathlib.PurePosixPath,\n        )\n        return {\"errors\": errors}", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Utility method in UploadDownloadMixin that uploads multiple files or directories to a remote location, ensuring necessary directories exist and reporting any transfer errors encountered."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_read_file", "line_number": 301, "body": "def _cmd_read_file(self, cmd):\n        def callback(completed, total):\n            self._report_progress(cmd, cmd[\"path\"], completed, total)\n\n        try:\n            with io.BytesIO() as fp:\n                self._read_file(cmd[\"path\"], fp, callback)\n                fp.seek(0)\n                content_bytes = fp.read()\n\n            error = None\n        except Exception as e:\n            self._report_internal_exception()\n            error = str(e)\n            content_bytes = None\n\n        return {\"content_bytes\": content_bytes, \"path\": cmd[\"path\"], \"error\": error}", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Provides a utility to read a file's content into memory while reporting progress and handling errors, returning the file data along with any encountered error information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_write_file", "line_number": 319, "body": "def _cmd_write_file(self, cmd):\n        def callback(completed, total):\n            self._report_progress(cmd, cmd[\"path\"], completed, total)\n\n        try:\n            with io.BytesIO() as fp:\n                fp.write(cmd[\"content_bytes\"])\n                fp.seek(0)\n                self._write_file(fp, cmd[\"path\"], len(cmd[\"content_bytes\"]), callback)\n\n            error = None\n        except Exception as e:\n            self._report_internal_exception()\n            error = str(e)\n\n        return InlineResponse(\n            command_name=\"write_file\", path=cmd[\"path\"], editor_id=cmd.get(\"editor_id\"), error=error\n        )", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Provides a utility to write byte content to a specified file path while reporting progress and handling errors. This internal method supports file upload operations with detailed completion feedback."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_supports_directories", "line_number": 338, "body": "def _supports_directories(self) -> bool:\n        return True", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Indicates whether the upload/download functionality supports directory operations, enabling methods to handle directories in addition to individual files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_transfer_files_and_dirs", "line_number": 341, "body": "def _transfer_files_and_dirs(\n        self,\n        items: Iterable[Dict],\n        ensure_dir_fun: Callable[[str], None],\n        transfer_file_fun: Callable,\n        cmd,\n        target_path_class,\n    ) -> List[str]:\n\n        total_cost = 0\n        for item in items:\n            if item[\"kind\"] == \"file\":\n                total_cost += item[\"size\"] + self._get_file_fixed_cost()\n            else:\n                total_cost += self._get_dir_transfer_cost()\n\n        completed_cost = 0\n        errors = []\n\n        ensured_dirs = set()\n\n        def ensure_dir(path):\n            if path in ensured_dirs:\n                return\n            ensure_dir_fun(path)\n            ensured_dirs.add(path)\n\n        for item in sorted(items, key=lambda x: x[\"source_path\"]):\n            self._report_progress(cmd, \"Starting\", completed_cost, total_cost)\n\n            def copy_bytes_notifier(completed_bytes, total_bytes):\n                completed = completed_cost + completed_bytes\n                desc = str(round(completed / total_cost * 100)) + \"%\"\n\n                self._report_progress(cmd, desc, completed, total_cost)\n\n            try:\n                if item[\"kind\"] == \"dir\":\n                    ensure_dir(item[\"target_path\"])\n                    completed_cost += self._get_dir_transfer_cost()\n                else:\n                    if self._supports_directories():\n                        ensure_dir(self._get_parent_directory(item[\"target_path\"]))\n                    print(\"%s (%d bytes)\" % (item[\"source_path\"], item[\"size\"]))\n                    transfer_file_fun(item[\"source_path\"], item[\"target_path\"], copy_bytes_notifier)\n                    completed_cost += self._get_file_fixed_cost() + item[\"size\"]\n            except OSError as e:\n                errors.append(\n                    \"Could not copy %s to %s: %s\"\n                    % (item[\"source_path\"], item[\"target_path\"], str(e))\n                )\n\n        return errors", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Core method of UploadDownloadMixin that transfers multiple files and directories, ensuring target directories exist and reporting progress. It handles errors and returns a list of transfer failures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_download_file", "line_number": 395, "body": "def _download_file(self, source_path, target_path, callback):\n        with open(target_path, \"bw\") as target_fp:\n            self._read_file(source_path, target_fp, callback)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Core method in UploadDownloadMixin that downloads a file from a source path, saving it to a target location while optionally reporting progress via a callback."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_upload_file", "line_number": 399, "body": "def _upload_file(self, source_path, target_path, callback):\n        with open(source_path, \"br\") as source_fp:\n            self._write_file(\n                source_fp,\n                target_path,\n                os.path.getsize(source_path),\n                callback,\n            )", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Internal utility method of UploadDownloadMixin that uploads a file from a local source path to a target destination, supporting progress tracking via a callback function."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_dir_transfer_cost", "line_number": 408, "body": "def _get_dir_transfer_cost(self):\n        # Validating and maybe creating a directory is taken to be equal to copying this number of bytes\n        return 1000", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Returns a fixed cost estimate for directory transfer operations, used to model or calculate data transfer expenses in upload or download processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_file_fixed_cost", "line_number": 412, "body": "def _get_file_fixed_cost(self):\n        # Creating or overwriting a file is taken to be equal to copying this number of bytes\n        return 100", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Private helper method in UploadDownloadMixin that defines a fixed byte cost used as a baseline for create or overwrite file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_parent_directory", "line_number": 416, "body": "def _get_parent_directory(self, path: str):\n        return universal_dirname(path)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Internal helper method that returns the parent directory of a given file path, supporting file path manipulations within the UploadDownloadMixin class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_ensure_local_directory", "line_number": 419, "body": "def _ensure_local_directory(self, path: str) -> None:\n        os.makedirs(path, NEW_DIR_MODE, exist_ok=True)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Utility method in UploadDownloadMixin that ensures a specified local directory exists by creating it if necessary, facilitating safe file upload or download operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_ensure_remote_directory", "line_number": 422, "body": "def _ensure_remote_directory(self, path: str) -> None:\n        # assuming remote system is Posix\n        ensure_posix_directory(path, self._get_stat_mode_for_upload, self._mkdir_for_upload)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Utility method in UploadDownloadMixin that ensures a remote POSIX directory exists at the specified path before uploading files. It supports reliable remote file management by creating directories as needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_stat_mode_for_upload", "line_number": 427, "body": "def _get_stat_mode_for_upload(self, path: str) -> Optional[int]:\n        \"returns None if path doesn't exist\"", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Returns the file mode bits if the given path exists; otherwise, returns None. This helps determine the file's status before upload operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "poll", "line_number": 472, "body": "def poll(self):\n        if self._channel.exit_status_ready():\n            self.returncode = self._channel.recv_exit_status()\n            return self.returncode\n        else:\n            return None", "is_method": true, "class_name": "RemoteProcess", "function_description": "Polls the remote process to check if it has finished execution, returning its exit code if complete or None if still running. This method helps monitor remote command completion status asynchronously."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "wait", "line_number": 479, "body": "def wait(self):\n        self.returncode = self._channel.recv_exit_status()\n        return self.returncode", "is_method": true, "class_name": "RemoteProcess", "function_description": "Wait method of the RemoteProcess class that blocks until the remote process finishes and returns its exit status code. It enables synchronous monitoring of remote process completion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "kill", "line_number": 483, "body": "def kill(self):\n        _, stdout, _ = self._client.exec_command(\"kill -9 %s\" % self.pid)\n        # wait until completion\n        stdout.channel.recv_exit_status()", "is_method": true, "class_name": "RemoteProcess", "function_description": "Terminates the remote process identified by its PID by forcefully killing it and waits until the termination completes. This method is used to ensure remote process cleanup or interruption."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_connect", "line_number": 516, "body": "def _connect(self):\n        from paramiko.ssh_exception import AuthenticationException\n        import socket\n\n        from paramiko import SSHException\n\n        try:\n            self._client.connect(\n                hostname=self._host,\n                username=self._user,\n                password=self._password,\n                passphrase=self._password,\n            )\n        except (SSHException, OSError) as e:\n            print(\n                \"\\nCan't connect to '%s' with user '%s': %s\" % (self._host, self._user, str(e)),\n                file=sys.stderr,\n            )\n            print(\"Re-check your host, authentication method, password or keys.\", file=sys.stderr)\n            delete_stored_ssh_password()\n\n            sys.exit(1)", "is_method": true, "class_name": "SshMixin", "function_description": "Core method of the SshMixin class that establishes an SSH connection using stored credentials, handling connection errors and terminating the program if authentication or connection fails."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_create_remote_process", "line_number": 539, "body": "def _create_remote_process(self, cmd_items: List[str], cwd: str, env: Dict) -> RemoteProcess:\n        # Before running the main thing:\n        # * print process id (so that we can kill it later)\n        #   http://redes-privadas-virtuales.blogspot.com/2013/03/getting-hold-of-remote-pid-through.html\n        # * change to desired directory\n        #\n        # About -onlcr: https://stackoverflow.com/q/35887380/261181\n        cmd_line_str = (\n            \"echo $$ ; stty -echo ; stty -onlcr ; \"\n            + (\" cd %s  2> /dev/null ;\" % shlex.quote(cwd) if cwd else \"\")\n            + (\" exec \" + \" \".join(map(shlex.quote, cmd_items)))\n        )\n        stdin, stdout, _ = self._client.exec_command(\n            cmd_line_str, bufsize=0, get_pty=True, environment=env\n        )\n\n        # stderr gets directed to stdout because of pty\n        pid = stdout.readline().strip()\n        channel = stdout.channel\n\n        return RemoteProcess(self._client, channel, stdin, stdout, pid)", "is_method": true, "class_name": "SshMixin", "function_description": "Creates and initiates a remote process over SSH with specified command, working directory, and environment, returning a handle to manage the process remotely including its PID. Useful for executing and controlling remote commands within SSH sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_handle_immediate_command", "line_number": 561, "body": "def _handle_immediate_command(self, cmd: ImmediateCommand) -> None:\n        if cmd.name == \"kill\":\n            self._kill()\n        elif cmd.name == \"interrupt\":\n            self._interrupt()\n        else:\n            raise RuntimeError(\"Unknown immediateCommand %s\" % cmd.name)", "is_method": true, "class_name": "SshMixin", "function_description": "Handles immediate SSH commands by executing corresponding actions like kill or interrupt, raising an error for unknown commands. It provides a direct interface to control SSH session states through predefined immediate commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_kill", "line_number": 569, "body": "def _kill(self):\n        if self._proc is None or self._proc.poll() is not None:\n            return\n\n        self._proc.kill()", "is_method": true, "class_name": "SshMixin", "function_description": "Private method of the SshMixin class that terminates an active SSH process if it is currently running. It ensures safe process termination by checking the process status before killing it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_sftp", "line_number": 578, "body": "def _get_sftp(self, fresh: bool):\n\n        if fresh and self._sftp is not None:\n            self._sftp.close()\n            self._sftp = None\n\n        if self._sftp is None:\n            import paramiko\n\n            # TODO: does it get closed properly after process gets killed?\n            self._sftp = paramiko.SFTPClient.from_transport(self._client.get_transport())\n\n        return self._sftp", "is_method": true, "class_name": "SshMixin", "function_description": "Provides access to an SFTP client instance, optionally creating a new connection or reusing an existing one, enabling file transfers over SSH within the SshMixin context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_read_file", "line_number": 592, "body": "def _read_file(\n        self, source_path: str, target_fp: BinaryIO, callback: Callable[[int, int], None]\n    ) -> None:\n        self._perform_sftp_operation_with_retry(\n            lambda sftp: sftp.getfo(source_path, target_fp, callback)\n        )", "is_method": true, "class_name": "SshMixin", "function_description": "Utility method in SshMixin that reads a remote file via SFTP into a binary stream, providing progress updates through a callback during the transfer. It ensures reliable file retrieval with automatic retries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_write_file", "line_number": 599, "body": "def _write_file(\n        self,\n        source_fp: BinaryIO,\n        target_path: str,\n        file_size: int,\n        callback: Callable[[int, int], None],\n    ) -> None:\n        self._perform_sftp_operation_with_retry(\n            lambda sftp: sftp.putfo(source_fp, target_path, callback)\n        )", "is_method": true, "class_name": "SshMixin", "function_description": "Internal helper method of SshMixin that writes binary data from a source stream to a remote file path over SFTP, supporting progress tracking and automatic retry on failure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_perform_sftp_operation_with_retry", "line_number": 610, "body": "def _perform_sftp_operation_with_retry(self, operation) -> Any:\n        try:\n            return operation(self._get_sftp(fresh=False))\n        except OSError:\n            # It looks like SFTPClient gets stale after a while.\n            # Try again with fresh SFTPClient\n            return operation(self._get_sftp(fresh=True))", "is_method": true, "class_name": "SshMixin", "function_description": "Utility method in SshMixin that executes an SFTP operation, retrying once with a fresh SFTP client if an OSError occurs, ensuring reliable SFTP interactions in unstable connections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_stat_mode_for_upload", "line_number": 618, "body": "def _get_stat_mode_for_upload(self, path: str) -> Optional[int]:\n        try:\n            return self._perform_sftp_operation_with_retry(lambda sftp: sftp.stat(path).st_mode)\n        except OSError as e:\n            return None", "is_method": true, "class_name": "SshMixin", "function_description": "Utility method in SshMixin that retrieves the file mode (permissions) of a given path via SFTP with retry logic, enabling callers to determine file status before upload operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_mkdir_for_upload", "line_number": 624, "body": "def _mkdir_for_upload(self, path: str) -> None:\n        self._perform_sftp_operation_with_retry(lambda sftp: sftp.mkdir(path, NEW_DIR_MODE))", "is_method": true, "class_name": "SshMixin", "function_description": "Utility method in SshMixin that creates a directory at the specified path via SFTP, ensuring reliable upload setups with automatic retry logic."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "callback", "line_number": 302, "body": "def callback(completed, total):\n            self._report_progress(cmd, cmd[\"path\"], completed, total)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Callback method that reports progress of an upload or download operation by updating completion status relative to total data size. It supports tracking and displaying transfer progress in the UploadDownloadMixin context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "callback", "line_number": 320, "body": "def callback(completed, total):\n            self._report_progress(cmd, cmd[\"path\"], completed, total)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Reports progress updates during an upload or download operation by invoking a progress reporting method with the current completion status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "ensure_dir", "line_number": 362, "body": "def ensure_dir(path):\n            if path in ensured_dirs:\n                return\n            ensure_dir_fun(path)\n            ensured_dirs.add(path)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Utility method in UploadDownloadMixin that ensures a directory exists at the given path, avoiding redundant operations by tracking previously ensured directories."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "select_page", "line_number": 64, "body": "def select_page(self, key):\n        for i, tab in enumerate(self._notebook.tabs()):\n            if self._page_records[i][0] == key:\n                self._notebook.select(tab)", "is_method": true, "class_name": "ConfigurationDialog", "function_description": "Selects and displays the configuration page matching the given key within a tabbed dialog interface, facilitating navigation between different settings or options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "_ok", "line_number": 69, "body": "def _ok(self, event=None):\n        for _, title, page in self._page_records:\n            try:\n                if page.apply() is False:\n                    return\n            except Exception:\n                get_workbench().report_exception(\"Error when applying options in \" + title)\n\n        self.destroy()", "is_method": true, "class_name": "ConfigurationDialog", "function_description": "Private method of ConfigurationDialog that attempts to apply settings from all pages and closes the dialog if successful, reporting errors encountered during the application process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "_cancel", "line_number": 79, "body": "def _cancel(self, event=None):\n        for _, title, page in self._page_records:\n            try:\n                page.cancel()\n            except Exception:\n                get_workbench().report_exception(\"Error when cancelling options in \" + title)\n\n        self.destroy()", "is_method": true, "class_name": "ConfigurationDialog", "function_description": "Handles cancellation of all options pages within the dialog, ensuring each page's cancel action is executed and then closes the ConfigurationDialog. It manages cleanup and error reporting during dialog cancellation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "destroy", "line_number": 88, "body": "def destroy(self):\n        ConfigurationDialog.last_shown_tab_index = self._notebook.index(self._notebook.select())\n        super().destroy()", "is_method": true, "class_name": "ConfigurationDialog", "function_description": "Method of ConfigurationDialog that saves the currently selected tab index before closing the dialog, preserving user interface state for future openings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "add_checkbox", "line_number": 104, "body": "def add_checkbox(\n        self, flag_name, description, row=None, column=0, padx=0, pady=0, columnspan=1, tooltip=None\n    ):\n        variable = get_workbench().get_variable(flag_name)\n        checkbox = ttk.Checkbutton(self, text=description, variable=variable)\n        checkbox.grid(\n            row=row, column=column, sticky=tk.W, padx=padx, pady=pady, columnspan=columnspan\n        )\n\n        if tooltip is not None:\n            ui_utils.create_tooltip(checkbox, tooltip)", "is_method": true, "class_name": "ConfigurationPage", "function_description": "Adds a configurable checkbox to the interface with an optional tooltip, enabling users to toggle a flag variable within a configuration page layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "add_combobox", "line_number": 116, "body": "def add_combobox(\n        self, variable, values, row=None, column=0, padx=0, pady=0, columnspan=1, width=None\n    ):\n        if isinstance(variable, str):\n            variable = get_workbench().get_variable(variable)\n        combobox = ttk.Combobox(\n            self,\n            exportselection=False,\n            textvariable=variable,\n            state=\"readonly\",\n            height=15,\n            width=width,\n            values=values,\n        )\n        combobox.grid(\n            row=row, column=column, sticky=tk.W, pady=pady, padx=padx, columnspan=columnspan\n        )\n        return variable", "is_method": true, "class_name": "ConfigurationPage", "function_description": "Adds a read-only combobox widget to the configuration page, linking it to a variable and customizing its layout and options. This facilitates user selection from predefined values within the UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "add_entry", "line_number": 135, "body": "def add_entry(self, option_name, row=None, column=0, pady=0, padx=0, columnspan=1, **kw):\n        variable = get_workbench().get_variable(option_name)\n        entry = ttk.Entry(self, textvariable=variable, **kw)\n        entry.grid(row=row, column=column, sticky=tk.W, pady=pady, columnspan=columnspan, padx=padx)", "is_method": true, "class_name": "ConfigurationPage", "function_description": "Adds a text entry widget linked to a configuration variable on the page, allowing user input to modify settings with customizable grid placement and layout options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/token_utils.py", "function": "matches_any", "line_number": 5, "body": "def matches_any(name, alternates):\n    \"Return a named group pattern matching list of alternates.\"\n    return \"(?P<%s>\" % name + \"|\".join(alternates) + \")\"", "is_method": false, "function_description": "Utility function that constructs a named regex group matching any string from a list of alternates, facilitating pattern matching with readable group names in regular expressions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "name_similarity", "line_number": 874, "body": "def name_similarity(a, b):\n    # TODO: tweak the result values\n    a = a.replace(\"_\", \"\")\n    b = b.replace(\"_\", \"\")\n\n    minlen = min(len(a), len(b))\n\n    if a.replace(\"0\", \"O\").replace(\"1\", \"l\") == b.replace(\"0\", \"O\").replace(\"1\", \"l\"):\n        if minlen >= 4:\n            return 7\n        else:\n            return 6\n\n    a = a.lower()\n    b = b.lower()\n\n    if a == b:\n        if minlen >= 4:\n            return 7\n        else:\n            return 6\n\n    if minlen <= 2:\n        return 0\n\n    # if names differ at final isolated digits,\n    # then they are probably different vars, even if their\n    # distance is small (eg. location_1 and location_2)\n    if a[-1].isdigit() and not a[-2].isdigit() and b[-1].isdigit() and not b[-2].isdigit():\n        return 0\n\n    # same thing with _ + single char suffixes\n    # (eg. location_a and location_b)\n    if a[-2] == \"_\" and b[-2] == \"_\":\n        return 0\n\n    distance = levenshtein_damerau_distance(a, b, 5)\n\n    if minlen <= 5:\n        return max(8 - distance * 2, 0)\n    elif minlen <= 10:\n        return max(9 - distance * 2, 0)\n    else:\n        return max(10 - distance * 2, 0)", "is_method": false, "function_description": "Function that computes a similarity score between two names by normalizing characters and applying heuristic rules combined with an edit distance measure to assess how closely the names match. Useful for comparing variable or identifier names in code analysis or refactoring tools."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_get_imported_user_files", "line_number": 920, "body": "def _get_imported_user_files(main_file, source=None):\n    assert os.path.isabs(main_file)\n\n    if source is None:\n        source = read_source(main_file)\n\n    try:\n        root = ast.parse(source, main_file)\n    except SyntaxError:\n        return set()\n\n    main_dir = os.path.dirname(main_file)\n    module_names = set()\n    # TODO: at the moment only considers non-package modules\n    for node in ast.walk(root):\n        if isinstance(node, ast.Import):\n            for item in node.names:\n                module_names.add(item.name)\n        elif isinstance(node, ast.ImportFrom):\n            module_names.add(node.module)\n\n    imported_files = set()\n\n    for file in {name + ext for ext in [\".py\", \".pyw\"] for name in module_names}:\n        possible_path = os.path.join(main_dir, file)\n        if os.path.exists(possible_path):\n            imported_files.add(possible_path)\n\n    return imported_files", "is_method": false, "function_description": "Function that identifies and returns the set of Python source files imported by a given main Python file, based on static analysis of its import statements. Useful for tracing direct module dependencies within the same directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "add_program_analyzer", "line_number": 952, "body": "def add_program_analyzer(cls):\n    _program_analyzer_classes.append(cls)", "is_method": false, "function_description": "Registers a program analyzer class by adding it to a global list, enabling the system to keep track of available analyzer types for later use or instantiation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "add_error_helper", "line_number": 956, "body": "def add_error_helper(error_type_name, helper_class):\n    _error_helper_classes.setdefault(error_type_name, [])\n    _error_helper_classes[error_type_name].append(helper_class)", "is_method": false, "function_description": "Utility function that registers a helper class associated with a specific error type, enabling organized management or handling of error-specific helper behaviors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "format_file_url", "line_number": 961, "body": "def format_file_url(filename, lineno, col_offset):\n    s = \"thonny-editor://\" + rst_utils.escape(filename).replace(\" \", \"%20\")\n    if lineno is not None:\n        s += \"#\" + str(lineno)\n        if col_offset is not None:\n            s += \":\" + str(col_offset)\n\n    return s", "is_method": false, "function_description": "Constructs a custom URL string referencing a specific location (line and column) within a file, useful for linking to particular positions in code editors or tools that recognize the \"thonny-editor\" URL scheme."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "init", "line_number": 975, "body": "def init():\n    get_workbench().set_default(\"assistance.open_assistant_on_errors\", True)\n    get_workbench().set_default(\"assistance.open_assistant_on_warnings\", False)\n    get_workbench().set_default(\"assistance.disabled_checks\", [])\n    get_workbench().add_view(AssistantView, tr(\"Assistant\"), \"se\", visible_by_default=False)", "is_method": false, "function_description": "Initializes the workbench by setting default assistant-related configurations and adding the assistant view, preparing the interface for user assistance features and error handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "handle_toplevel_response", "line_number": 96, "body": "def handle_toplevel_response(self, msg: ToplevelResponse) -> None:\n        # Can be called by event system or by Workbench\n        # (if Assistant wasn't created yet but an error came)\n        if not msg.get(\"user_exception\") and msg.get(\"command_name\") in [\n            \"execute_system_command\",\n            \"execute_source\",\n        ]:\n            # Shell commands may be used to investigate the problem, don't clear assistance\n            return\n\n        self._clear()\n\n        from thonny.plugins.cpython import CPythonProxy\n\n        if not isinstance(get_runner().get_backend_proxy(), CPythonProxy):\n            # TODO: add some support for MicroPython as well\n            return\n\n        # prepare for snapshot\n        key = msg.get(\"filename\", \"<pyshell>\")\n        self._current_snapshot = {\n            \"timestamp\": datetime.datetime.now().isoformat()[:19],\n            \"main_file_path\": key,\n        }\n        self._snapshots_per_main_file.setdefault(key, [])\n        self._snapshots_per_main_file[key].append(self._current_snapshot)\n\n        if msg.get(\"user_exception\"):\n            if not msg[\"user_exception\"].get(\"message\", None):\n                msg[\"user_exception\"][\"message\"] = \"<no message>\"\n\n            self._exception_info = msg[\"user_exception\"]\n            self._explain_exception(msg[\"user_exception\"])\n            if get_workbench().get_option(\"assistance.open_assistant_on_errors\"):\n                get_workbench().show_view(\"AssistantView\", set_focus=False)\n        else:\n            self._exception_info = None\n\n        if msg.get(\"filename\") and os.path.exists(msg[\"filename\"]):\n            self.main_file_path = msg[\"filename\"]\n            source = read_source(msg[\"filename\"])\n            self._start_program_analyses(\n                msg[\"filename\"], source, _get_imported_user_files(msg[\"filename\"], source)\n            )\n        else:\n            self.main_file_path = None\n            self._present_conclusion()", "is_method": true, "class_name": "AssistantView", "function_description": "Handles top-level responses by managing error states, preparing code execution snapshots, and triggering program analysis or assistance display based on the response content and runtime environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_explain_exception", "line_number": 144, "body": "def _explain_exception(self, error_info):\n        rst = (\n            self._get_rst_prelude()\n            + rst_utils.create_title(\n                error_info[\"type_name\"] + \": \" + rst_utils.escape(error_info[\"message\"])\n            )\n            + \"\\n\"\n        )\n\n        if (\n            error_info.get(\"lineno\") is not None\n            and error_info.get(\"filename\")\n            and os.path.exists(error_info[\"filename\"])\n        ):\n            rst += \"`%s, line %d <%s>`__\\n\\n\" % (\n                os.path.basename(error_info[\"filename\"]),\n                error_info[\"lineno\"],\n                self._format_file_url(error_info),\n            )\n\n        helpers = []\n\n        for helper_class in (\n            _error_helper_classes.get(error_info[\"type_name\"], []) + _error_helper_classes[\"*\"]\n        ):\n            try:\n                helpers.append(helper_class(error_info))\n            except HelperNotSupportedError:\n                pass\n            except Exception as e:\n                logger.exception(\"Could not create helper %s\", helper_class, exc_info=e)\n\n        best_intro = helpers[0]\n        for helper in helpers:\n            if helper.intro_confidence > best_intro.intro_confidence:\n                best_intro = helper\n\n        # intro\n        if best_intro.intro_text:\n            rst += (\n                \".. note::\\n\"\n                + \"    \"\n                + best_intro.intro_text.strip().replace(\"\\n\", \"\\n\\n    \")\n                + \"\\n\\n\"\n            )\n\n        suggestions = [\n            suggestion\n            for helper in helpers\n            for suggestion in helper.suggestions\n            if suggestion is not None\n        ]\n        suggestions = sorted(suggestions, key=lambda s: s.relevance, reverse=True)\n\n        if suggestions[0].relevance > 1 or best_intro.intro_confidence > 1:\n            relevance_threshold = 2\n        else:\n            # use relevance 1 only when there is nothing better\n            relevance_threshold = 1\n\n        suggestions = [s for s in suggestions if s.relevance >= relevance_threshold]\n\n        for i, suggestion in enumerate(suggestions):\n            rst += self._format_suggestion(\n                suggestion,\n                i == len(suggestions) - 1,\n                # TODO: is it good if first is preopened?\n                # It looks cleaner if it is not.\n                False,  # i==0\n            )\n\n        self._current_snapshot[\"exception_suggestions\"] = [\n            dict(sug._asdict()) for sug in suggestions\n        ]\n\n        self.text.append_rst(rst)\n        self._append_text(\"\\n\")\n\n        self._current_snapshot[\"exception_type_name\"] = error_info[\"type_name\"]\n        self._current_snapshot[\"exception_message\"] = error_info[\"message\"]\n        self._current_snapshot[\"exception_file_path\"] = error_info[\"filename\"]\n        self._current_snapshot[\"exception_lineno\"] = error_info[\"lineno\"]\n        self._current_snapshot[\"exception_rst\"] = rst", "is_method": true, "class_name": "AssistantView", "function_description": "Generates a detailed, formatted explanation for an exception, including context, relevant suggestions, and helpful notes, to assist in understanding and resolving errors within the AssistantView interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_format_suggestion", "line_number": 228, "body": "def _format_suggestion(self, suggestion, last, initially_open):\n        return (\n            # assuming that title is already in rst format\n            \".. topic:: \"\n            + suggestion.title\n            + \"\\n\"\n            + \"    :class: toggle%s%s\\n\"\n            % (\", open\" if initially_open else \"\", \", tight\" if not last else \"\")\n            + \"    \\n\"\n            + textwrap.indent(suggestion.body, \"    \")\n            + \"\\n\\n\"\n        )", "is_method": true, "class_name": "AssistantView", "function_description": "Private method in AssistantView that formats a suggestion into a reStructuredText toggle topic with customizable open state and spacing, supporting dynamic display of suggestion content in documentation or UI views."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_append_text", "line_number": 241, "body": "def _append_text(self, chars, tags=()):\n        self.text.direct_insert(\"end\", chars, tags=tags)", "is_method": true, "class_name": "AssistantView", "function_description": "Private method of AssistantView that appends given text with optional formatting tags to the end of the view\u2019s text content. It supports adding styled text dynamically to the display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_clear", "line_number": 244, "body": "def _clear(self):\n        self._accepted_warning_sets.clear()\n        for wp in self._analyzer_instances:\n            wp.cancel_analysis()\n        self._analyzer_instances = []\n        self.text.clear()", "is_method": true, "class_name": "AssistantView", "function_description": "Clears internal state by resetting accepted warnings, canceling ongoing analyses, and emptying text and analyzer instances. This method provides a cleanup utility for resetting the AssistantView's working state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_start_program_analyses", "line_number": 251, "body": "def _start_program_analyses(self, main_file_path, main_file_source, imported_file_paths):\n\n        for cls in _program_analyzer_classes:\n            analyzer = cls(self._accept_warnings)\n            if analyzer.is_enabled():\n                self._analyzer_instances.append(analyzer)\n\n        if not self._analyzer_instances:\n            return\n\n        self._append_text(\"\\nAnalyzing your code ...\", (\"em\",))\n\n        # save snapshot of current source\n        self._current_snapshot[\"main_file_path\"] = main_file_path\n        self._current_snapshot[\"main_file_source\"] = main_file_source\n        self._current_snapshot[\"imported_files\"] = {\n            name: read_source(name) for name in imported_file_paths\n        }\n\n        # start the analysis\n        for analyzer in self._analyzer_instances:\n            analyzer.start_analysis(main_file_path, imported_file_paths)", "is_method": true, "class_name": "AssistantView", "function_description": "Initializes and starts multiple program analyzers for a given main source file and its dependencies, preparing the environment by capturing snapshots of source code to enable comprehensive code analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_accept_warnings", "line_number": 274, "body": "def _accept_warnings(self, analyzer, warnings):\n        if analyzer.cancelled:\n            return\n\n        self._accepted_warning_sets.append(warnings)\n        if len(self._accepted_warning_sets) == len(self._analyzer_instances):\n            self._present_warnings()\n            self._present_conclusion()", "is_method": true, "class_name": "AssistantView", "function_description": "Internal method of AssistantView that records accepted warnings from analyzers and triggers the presentation of all warnings and the final conclusion once all analyzer instances have responded."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_present_conclusion", "line_number": 283, "body": "def _present_conclusion(self):\n\n        if not self.text.get(\"1.0\", \"end\").strip():\n            if self.main_file_path is not None and os.path.exists(self.main_file_path):\n                self._append_text(\"\\n\")\n                self.text.append_rst(\n                    \"The code in `%s <%s>`__ looks good.\\n\\n\"\n                    % (\n                        os.path.basename(self.main_file_path),\n                        self._format_file_url({\"filename\": self.main_file_path}),\n                    )\n                )\n                self.text.append_rst(\n                    \"If it is not working as it should, \"\n                    + \"then consider using some general \"\n                    + \"`debugging techniques <debugging.rst>`__.\\n\\n\",\n                    (\"em\",),\n                )\n\n        if self.text.get(\"1.0\", \"end\").strip():\n            self._append_feedback_link()\n\n        if self._exception_info:\n            self._append_text(\n                \"General advice on dealing with errors.\\n\", (\"a\", \"python_errors_link\")\n            )", "is_method": true, "class_name": "AssistantView", "function_description": "Utility method of AssistantView that generates and displays a conclusion message about the main code file status, appends debugging advice if needed, and provides feedback or error guidance to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_present_warnings", "line_number": 310, "body": "def _present_warnings(self):\n        warnings = [w for ws in self._accepted_warning_sets for w in ws]\n        self.text.direct_delete(\"end-2l linestart\", \"end-1c lineend\")\n\n        if not warnings:\n            return\n\n        if self._exception_info is None:\n            intro = \"May be ignored if you are happy with your program.\"\n        else:\n            intro = \"May help you find the cause of the error.\"\n\n        rst = (\n            self._get_rst_prelude()\n            + rst_utils.create_title(\"Warnings\")\n            + \":remark:`%s`\\n\\n\" % intro\n        )\n\n        by_file = {}\n        for warning in warnings:\n            if warning[\"filename\"] not in by_file:\n                by_file[warning[\"filename\"]] = []\n            if warning not in by_file[warning[\"filename\"]]:\n                # Pylint may give double warnings (eg. when module imports itself)\n                by_file[warning[\"filename\"]].append(warning)\n\n        for filename in by_file:\n            rst += \"`%s <%s>`__\\n\\n\" % (\n                os.path.basename(filename),\n                self._format_file_url(dict(filename=filename)),\n            )\n            file_warnings = sorted(\n                by_file[filename], key=lambda x: (x.get(\"lineno\", 0), -x.get(\"relevance\", 1))\n            )\n\n            for i, warning in enumerate(file_warnings):\n                rst += self._format_warning(warning, i == len(file_warnings) - 1) + \"\\n\"\n\n            rst += \"\\n\"\n\n        self.text.append_rst(rst)\n\n        # save snapshot\n        self._current_snapshot[\"warnings_rst\"] = rst\n        self._current_snapshot[\"warnings\"] = warnings\n\n        if get_workbench().get_option(\"assistance.open_assistant_on_warnings\"):\n            get_workbench().show_view(\"AssistantView\")", "is_method": true, "class_name": "AssistantView", "function_description": "Generates and displays a formatted RST report of collected warnings, grouping them by file and providing context-sensitive intros to help users understand or ignore potential issues in their code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_format_warning", "line_number": 359, "body": "def _format_warning(self, warning, last):\n        title = rst_utils.escape(warning[\"msg\"].splitlines()[0])\n        if warning.get(\"lineno\") is not None:\n            url = self._format_file_url(warning)\n            if warning.get(\"lineno\"):\n                title = \"`Line %d <%s>`__ : %s\" % (warning[\"lineno\"], url, title)\n\n        if warning.get(\"explanation_rst\"):\n            explanation_rst = warning[\"explanation_rst\"]\n        elif warning.get(\"explanation\"):\n            explanation_rst = rst_utils.escape(warning[\"explanation\"])\n        else:\n            explanation_rst = \"\"\n\n        if warning.get(\"more_info_url\"):\n            explanation_rst += \"\\n\\n`More info online <%s>`__\" % warning[\"more_info_url\"]\n\n        explanation_rst = explanation_rst.strip()\n        topic_class = \"toggle\" if explanation_rst else \"empty\"\n        if not explanation_rst:\n            explanation_rst = \"n/a\"\n\n        return (\n            \".. topic:: %s\\n\" % title\n            + \"    :class: \"\n            + topic_class\n            + (\"\" if last else \", tight\")\n            + \"\\n\"\n            + \"    \\n\"\n            + textwrap.indent(explanation_rst, \"    \")\n            + \"\\n\\n\"\n        )", "is_method": true, "class_name": "AssistantView", "function_description": "Utility method in AssistantView that formats and constructs a reStructuredText warning message, including optional line numbers, explanations, and links, for displaying detailed warning information in a structured view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_append_feedback_link", "line_number": 392, "body": "def _append_feedback_link(self):\n        self._append_text(\"Was it helpful or confusing?\\n\", (\"a\", \"feedback_link\"))", "is_method": true, "class_name": "AssistantView", "function_description": "Adds a feedback prompt with a styled link asking users if the content was helpful or confusing, supporting user interaction and feedback collection within AssistantView."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_format_file_url", "line_number": 395, "body": "def _format_file_url(self, atts):\n        return format_file_url(atts[\"filename\"], atts.get(\"lineno\"), atts.get(\"col_offset\"))", "is_method": true, "class_name": "AssistantView", "function_description": "Utility method in AssistantView that formats a file URL using filename and optional line and column numbers extracted from attributes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_ask_feedback", "line_number": 398, "body": "def _ask_feedback(self, event=None):\n\n        all_snapshots = self._snapshots_per_main_file[self._current_snapshot[\"main_file_path\"]]\n\n        # TODO: select only snapshots which are not sent yet\n        snapshots = all_snapshots\n\n        ui_utils.show_dialog(FeedbackDialog(get_workbench(), self.main_file_path, snapshots))", "is_method": true, "class_name": "AssistantView", "function_description": "Private method of AssistantView that prompts the user for feedback by displaying a dialog containing relevant snapshots of the current main file."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_get_rst_prelude", "line_number": 407, "body": "def _get_rst_prelude(self):\n        return \".. default-role:: code\\n\\n\" + \".. role:: light\\n\\n\" + \".. role:: remark\\n\\n\"", "is_method": true, "class_name": "AssistantView", "function_description": "Returns a predefined reStructuredText prelude string setting default and custom roles for code, light, and remark formatting. Useful for preparing consistent documentation styling in text outputs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "configure_tags", "line_number": 412, "body": "def configure_tags(self):\n        super().configure_tags()\n\n        main_font = tk.font.nametofont(\"TkDefaultFont\")\n\n        italic_font = main_font.copy()\n        italic_font.configure(slant=\"italic\", size=main_font.cget(\"size\"))\n\n        h1_font = main_font.copy()\n        h1_font.configure(weight=\"bold\", size=main_font.cget(\"size\"))\n\n        self.tag_configure(\"h1\", font=h1_font, spacing3=0, spacing1=10)\n        self.tag_configure(\"topic_title\", font=\"TkDefaultFont\")\n\n        self.tag_configure(\"topic_body\", font=italic_font, spacing1=10, lmargin1=25, lmargin2=25)\n\n        self.tag_raise(\"sel\")", "is_method": true, "class_name": "AssistantRstText", "function_description": "Sets up and customizes text styling tags like headers and italics for the AssistantRstText widget to control text appearance and formatting within the interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "is_enabled", "line_number": 507, "body": "def is_enabled(self):\n        return True", "is_method": true, "class_name": "ProgramAnalyzer", "function_description": "Simple status check method indicating whether the ProgramAnalyzer is enabled. It consistently returns True, signaling the analyzer is always active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "cancel_analysis", "line_number": 522, "body": "def cancel_analysis(self):\n        self.cancelled = True\n        if self._proc is not None:\n            self._proc.kill()", "is_method": true, "class_name": "SubprocessProgramAnalyzer", "function_description": "Method of SubprocessProgramAnalyzer that cancels the ongoing analysis by marking it as cancelled and terminating the associated subprocess if it is running."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "get_intro", "line_number": 531, "body": "def get_intro(self):\n        return \"This error happened in library code. This may mean a bug in \"", "is_method": true, "class_name": "LibraryErrorHelper", "function_description": "Provides a standard introductory message indicating an error originated within library code, suggesting the issue might be a library bug. It serves as a reusable error context initializer for consistent error reporting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "get_suggestions", "line_number": 534, "body": "def get_suggestions(self):\n        return []", "is_method": true, "class_name": "LibraryErrorHelper", "function_description": "Returns an empty list of suggestions related to library errors. This placeholder method can be extended to provide helpful error resolution suggestions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_happened_in_shell", "line_number": 671, "body": "def _happened_in_shell(self):\n        return self.main_file_path is None or self.main_file_path.lower() == \"<pyshell>\"", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Private method in FeedbackDialog that determines if the current context is an interactive Python shell session rather than a script execution. It helps tailor feedback behavior based on the execution environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_populate_tree", "line_number": 674, "body": "def _populate_tree(self):\n        groups = {}\n\n        for snap in self.snapshots:\n            if snap.get(\"exception_message\") and snap.get(\"exception_suggestions\"):\n                group = snap[\"exception_type_name\"]\n                groups.setdefault(group, set())\n                for sug in snap[\"exception_suggestions\"]:\n                    groups[group].add((sug[\"symbol\"], sug[\"title\"]))\n\n            # warnings group\n            if snap.get(\"warnings\"):\n                group = \"Warnings\"\n                groups.setdefault(group, set())\n                for w in snap[\"warnings\"]:\n                    groups[group].add((w[\"symbol\"], w[\"msg\"]))\n\n        for group in sorted(groups.keys(), key=lambda x: x.replace(\"Warnings\", \"z\")):\n            group_id = self.tree.insert(\"\", \"end\", open=True, tags=(\"group\",))\n            self.tree.set(group_id, \"title\", group)\n\n            for symbol, title in sorted(groups[group], key=lambda m: m[1]):\n                item_id = self.tree.insert(\"\", \"end\")\n                self.tree.set(item_id, \"helpful\", self._empty_box)\n                self.tree.set(item_id, \"confusing\", self._empty_box)\n                self.tree.set(item_id, \"title\", title)\n                self.tree.set(item_id, \"symbol\", symbol)\n                self.tree.set(item_id, \"group\", group)\n\n        self.tree.see(\"\")", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Constructs and organizes a tree view grouping exceptions and warnings from snapshots by their types and suggestions, preparing the UI structure for displaying categorized feedback items within the FeedbackDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_on_tree_click", "line_number": 705, "body": "def _on_tree_click(self, event):\n        item_id = self.tree.identify(\"item\", event.x, event.y)\n        column = self.tree.identify_column(event.x)\n\n        if not item_id or not column:\n            return\n\n        value_index = int(column[1:]) - 1\n        values = list(self.tree.item(item_id, \"values\"))\n\n        if values[value_index] == self._empty_box:\n            values[value_index] = self._checked_box\n        elif values[value_index] == self._checked_box:\n            values[value_index] = self._empty_box\n        else:\n            return\n\n        # update values\n        self.tree.item(item_id, values=tuple(values))", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Toggles the check state of a clicked checkbox cell within a tree view in the FeedbackDialog UI, enabling interactive selection or deselection of items in the tree widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_preview_submission_data", "line_number": 725, "body": "def _preview_submission_data(self, event=None):\n        import tempfile\n\n        temp_path = os.path.join(\n            tempfile.mkdtemp(dir=get_workbench().get_temp_dir()),\n            \"ThonnyAssistantFeedback_\"\n            + datetime.datetime.now().isoformat().replace(\":\", \".\")[:19]\n            + \".txt\",\n        )\n        data = self._collect_submission_data()\n        with open(temp_path, \"w\", encoding=\"ascii\") as fp:\n            fp.write(data)\n\n        if running_on_mac_os():\n            subprocess.Popen([\"open\", \"-e\", temp_path])\n        else:\n            import webbrowser\n\n            webbrowser.open(temp_path)", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Prepares and opens a temporary text file showing collected feedback submission data for user preview, adapting the file-opening method based on the operating system. Useful for reviewing feedback before final submission."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_collect_submission_data", "line_number": 745, "body": "def _collect_submission_data(self):\n        import json\n\n        tree_data = []\n\n        for iid in self.tree.get_children():\n            values = self.tree.item(iid, \"values\")\n            tree_data.append(\n                {\n                    \"helpful\": values[0] == self._checked_box,\n                    \"confusing\": values[1] == self._checked_box,\n                    \"message\": values[2],\n                    \"group\": values[3],\n                    \"symbol\": values[4],\n                }\n            )\n\n        submission = {\n            \"feedback_format_version\": 1,\n            \"thonny_version\": thonny.get_version(),\n            \"python_version\": \".\".join(map(str, sys.version_info[:3])),\n            \"message_feedback\": tree_data,\n            \"comments\": self.comments_text_frame.text.get(\"1.0\", \"end\"),\n        }\n\n        try:\n            import mypy.version\n\n            submission[\"mypy_version\"] = str(mypy.version.__version__)\n        except ImportError:\n            logging.exception(\"Could not get MyPy version\")\n\n        try:\n            import pylint\n\n            submission[\"pylint_version\"] = str(pylint.__version__)\n        except ImportError:\n            logging.exception(\"Could not get Pylint version\")\n\n        if self.include_snapshots_var.get():\n            submission[\"snapshots\"] = self.snapshots\n\n        if self.include_thonny_id_var.get():\n            submission[\"thonny_timestamp\"] = get_workbench().get_option(\n                \"general.configuration_creation_timestamp\"\n            )\n\n        return json.dumps(submission, indent=2)", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Collects and compiles detailed user feedback and environment data into a structured JSON string, including feedback items, comments, software versions, and optional snapshots or timestamps, to facilitate comprehensive submission processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_submit_data", "line_number": 794, "body": "def _submit_data(self):\n        import gzip\n        import urllib.request\n\n        json_data = self._collect_submission_data()\n        compressed_data = gzip.compress(json_data.encode(\"ascii\"))\n\n        def do_work():\n            try:\n                handle = urllib.request.urlopen(\n                    \"https://thonny.org/store_assistant_feedback.php\",\n                    data=compressed_data,\n                    timeout=10,\n                )\n                return handle.read()\n            except Exception as e:\n                return str(e)\n\n        result = ui_utils.run_with_waiting_dialog(self, do_work, description=\"Uploading\")\n        if result == b\"OK\":\n            if self.snapshots:\n                last_timestamp = self.snapshots[-1][\"timestamp\"]\n                _last_feedback_timestamps[self.main_file_path] = last_timestamp\n            messagebox.showinfo(\n                \"Done!\",\n                \"Thank you for the feedback!\\n\\nLet us know again when Assistant\\nhelps or confuses you!\",\n                master=self.master,\n            )\n            self._close()\n        else:\n            messagebox.showerror(\n                \"Problem\",\n                \"Something went wrong:\\n%s\\n\\nIf you don't mind, then try again later!\"\n                % result[:1000],\n                master=self,\n            )", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Handles submission of user feedback by collecting, compressing, and uploading data, then informs the user of success or failure. It supports tracking feedback timestamps for further use within the FeedbackDialog class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_select_unsent_snapshots", "line_number": 831, "body": "def _select_unsent_snapshots(self, all_snapshots):\n        if self.main_file_path not in _last_feedback_timestamps:\n            return all_snapshots\n        else:\n            return [\n                s\n                for s in all_snapshots\n                if s[\"timestamp\"] > _last_feedback_timestamps[self.main_file_path]\n            ]", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Selects and returns snapshots that have not yet been sent based on timestamps, enabling incremental feedback processing tied to a specific main file path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_close", "line_number": 841, "body": "def _close(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Private method of FeedbackDialog that closes the dialog window, optionally triggered by an event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_get_since_str", "line_number": 844, "body": "def _get_since_str(self):\n        if not self.snapshots:\n            assert self.main_file_path in _last_feedback_timestamps\n            since = datetime.datetime.strptime(\n                _last_feedback_timestamps[self.main_file_path], \"%Y-%m-%dT%H:%M:%S\"\n            )\n        else:\n            since = datetime.datetime.strptime(self.snapshots[0][\"timestamp\"], \"%Y-%m-%dT%H:%M:%S\")\n\n        if since.date() == datetime.date.today() or (\n            datetime.datetime.now() - since\n        ) <= datetime.timedelta(hours=5):\n            since_str = since.strftime(\"%X\")\n        else:\n            # date and time without yer\n            since_str = since.strftime(\"%c\").replace(str(datetime.date.today().year), \"\")\n\n        # remove seconds\n        if since_str.count(\":\") == 2:\n            i = since_str.rfind(\":\")\n            if (\n                i > 0\n                and len(since_str[i + 1 : i + 3]) == 2\n                and since_str[i + 1 : i + 3].isnumeric()\n            ):\n                since_str = since_str[:i] + since_str[i + 3 :]\n\n        return since_str.strip()", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Returns a formatted string representing the most recent relevant timestamp from feedback snapshots or stored records, adjusting the display based on how recent the timestamp is. This helps present concise, human-readable feedback timing information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "do_work", "line_number": 801, "body": "def do_work():\n            try:\n                handle = urllib.request.urlopen(\n                    \"https://thonny.org/store_assistant_feedback.php\",\n                    data=compressed_data,\n                    timeout=10,\n                )\n                return handle.read()\n            except Exception as e:\n                return str(e)", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Performs an HTTP POST request to submit feedback data to a remote server, returning the server's response or an error message. It enables sending user feedback for processing or storage."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "try_load_configuration", "line_number": 21, "body": "def try_load_configuration(filename):\n    if filename in _manager_cache:\n        return _manager_cache[filename]\n\n    try:\n        # use cache so Workbench doesn't create duplicate manager\n        # when FirstRunWindow already created one\n        mgr = ConfigurationManager(filename)\n        _manager_cache[filename] = mgr\n        return mgr\n    except configparser.Error:\n        from tkinter import messagebox\n\n        if os.path.exists(filename) and messagebox.askyesno(\n            \"Problem\",\n            \"Thonny's configuration file can't be read. It may be corrupt.\\n\\n\"\n            + \"Do you want to discard the file and open Thonny with default settings?\",\n            master=tk._default_root,\n        ):\n            os.replace(filename, filename + \"_corrupt\")\n            # For some reasons Thonny styles are not loaded properly once messagebox has been shown before main window (At least Windows Py 3.5)\n            raise SystemExit(\"Configuration file has been discarded. Please restart Thonny!\")\n        else:\n            raise", "is_method": false, "function_description": "Function that attempts to load a configuration manager from a file, using caching to avoid duplication, and handles corrupt configuration files by prompting the user to discard them or raise an error."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "_init_default_overrides", "line_number": 94, "body": "def _init_default_overrides(self):\n        overrides_path = os.path.join(os.path.dirname(__file__), \"defaults.ini\")\n        if not os.path.isfile(overrides_path):\n            return\n\n        defparser = configparser.ConfigParser()\n        defparser.read(overrides_path, \"utf-8\")\n        for section in defparser.sections():\n            for key in defparser[section]:\n                # leave parsing until base default value is known\n                self._defaults_overrides_str[section + \".\" + key] = defparser[section][key]", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Initializes default configuration overrides by reading key-value pairs from a \"defaults.ini\" file, storing them for later use in the ConfigurationManager."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "get_option", "line_number": 106, "body": "def get_option(self, name, secondary_default=None):\n        section, option = self._parse_name(name)\n        name = section + \".\" + option\n\n        # variable may have more recent value\n        if name in self._variables:\n            return self._variables[name].get()\n\n        try:\n            val = self._ini.get(section, option)\n\n            # if option's data type is str (inferred from the default value)\n            # then don't try to parse anything (unless it's None)\n            if val == \"None\":\n                return None\n            elif isinstance(self._defaults.get(name), str):\n                return val\n            else:\n                return self._parse_value(val)\n        except Exception:\n            if name in self._defaults:\n                return self._defaults[name]\n            else:\n                return secondary_default", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Provides a unified interface to retrieve configuration options with support for recent overrides, default fallbacks, and type parsing. This method is useful for safely accessing configuration values in various formats within an application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "has_option", "line_number": 131, "body": "def has_option(self, name):\n        return name in self._defaults", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Checks if a given configuration option name exists within the default settings, enabling verification of option availability in the ConfigurationManager."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "set_option", "line_number": 134, "body": "def set_option(self, name, value):\n        section, option = self._parse_name(name)\n        name = section + \".\" + option\n        if not self._ini.has_section(section):\n            self._ini.add_section(section)\n\n        if isinstance(value, str):\n            self._ini.set(section, option, value)\n        else:\n            self._ini.set(section, option, repr(value))\n\n        # update variable\n        if name in self._variables:\n            self._variables[name].set(value)", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Sets or updates a configuration option by parsing its name into section and option, storing the value in the configuration and updating any associated variable. This method enables dynamic management of configuration settings within ConfigurationManager."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "set_default", "line_number": 149, "body": "def set_default(self, name, primary_default_value):\n        # normalize name\n        section, option = self._parse_name(name)\n        name = section + \".\" + option\n        self._defaults[name] = primary_default_value\n\n        if name in self._defaults_overrides_str:\n            if isinstance(primary_default_value, str):\n                value = self._defaults_overrides_str[name]\n            else:\n                value = self._parse_value(self._defaults_overrides_str[name])\n        else:\n            value = primary_default_value\n\n        self._defaults[name] = value", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Sets or updates a default configuration value, applying overrides if present, ensuring consistent default settings across the ConfigurationManager. This supports flexible management of configuration defaults with type-aware override handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "get_variable", "line_number": 165, "body": "def get_variable(self, name: str) -> tk.Variable:\n        section, option = self._parse_name(name)\n        name = section + \".\" + option\n\n        if name in self._variables:\n            return self._variables[name]\n        else:\n            value = self.get_option(name)\n            if isinstance(value, bool):\n                var = tk.BooleanVar(value=value)  # type: tk.Variable\n            elif isinstance(value, int):\n                var = tk.IntVar(value=value)\n            elif isinstance(value, str):\n                var = tk.StringVar(value=value)\n            elif isinstance(value, float):\n                var = tk.StringVar(value=value)\n            else:\n                raise KeyError(\n                    \"Can't create Tk Variable for \" + name + \". Type is \" + str(type(value))\n                )\n            self._variables[name] = var\n            return var", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Provides a Tkinter variable linked to a configuration option, creating and caching it to reflect the option\u2019s current value and type. This facilitates GUI components' dynamic access and updates to configuration settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "save", "line_number": 188, "body": "def save(self):\n        # save all tk variables\n        for name in self._variables:\n            self.set_option(name, self._variables[name].get())\n\n        # store\n        if not os.path.exists(self._filename):\n            os.makedirs(os.path.dirname(self._filename), mode=0o700, exist_ok=True)\n\n        # Normal saving occasionally creates corrupted file:\n        # https://bitbucket.org/plas/thonny/issues/167/configuration-file-occasionally-gets\n        # Now I'm saving the configuration to a temp file\n        # and if the save is successful, I replace configuration file with it\n        temp_filename = self._filename + \".temp\"\n        with open(temp_filename, \"w\", encoding=\"UTF-8\") as fp:\n            self._ini.write(fp)\n\n        try:\n            ConfigurationManager(temp_filename)\n            # temp file was created successfully\n            os.chmod(temp_filename, 0o600)\n            os.replace(temp_filename, self._filename)\n            os.chmod(self._filename, 0o600)\n        except Exception:\n            exception(\"Could not save configuration file. Reverting to previous file.\")", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Core method of ConfigurationManager that securely saves configuration options to a file by first writing to a temporary file and then replacing the original, ensuring file integrity and proper permissions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "_parse_name", "line_number": 214, "body": "def _parse_name(self, name):\n        if \".\" in name:\n            return name.split(\".\", 1)\n        else:\n            return \"general\", name", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Private helper method in ConfigurationManager that splits a dot-separated name into category and key parts, defaulting to a general category if no dot is present. It supports organized access to configuration entries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "_parse_value", "line_number": 220, "body": "def _parse_value(self, value):\n        try:\n            return ast.literal_eval(value)\n        except Exception:\n            return value", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Helper method of ConfigurationManager that attempts to safely parse a string value into a Python literal; returns the original value if parsing fails, supporting flexible configuration value handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "init_plotter", "line_number": 136, "body": "def init_plotter(self):\n        self.plotter = None\n        get_workbench().set_default(\"view.show_plotter\", False)\n        get_workbench().set_default(\"view.shell_sash_position\", 400)\n\n        self.plotter_visibility_var = get_workbench().get_variable(\"view.show_plotter\")\n\n        def can_toggle():\n            return self.winfo_ismapped()\n\n        get_workbench().add_command(\n            \"toggle_plotter\",\n            \"view\",\n            tr(\"Plotter\"),\n            self.toggle_plotter,\n            can_toggle,\n            flag_name=\"view.show_plotter\",\n            group=11,\n        )\n\n        self.update_plotter_visibility(True)", "is_method": true, "class_name": "ShellView", "function_description": "Initializes plotting components and integrates plotter visibility toggling into the user interface, managing default settings and commands within the ShellView context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "set_ignore_program_output", "line_number": 158, "body": "def set_ignore_program_output(self, value):\n        self.text._ignore_program_output = value", "is_method": true, "class_name": "ShellView", "function_description": "Sets whether the ShellView should ignore output from executed programs, controlling if such output is displayed or processed further. This enables toggling program output visibility within the shell interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "toggle_plotter", "line_number": 161, "body": "def toggle_plotter(self):\n        self.plotter_visibility_var.set(not self.plotter_visibility_var.get())\n        self.update_plotter_visibility()", "is_method": true, "class_name": "ShellView", "function_description": "Toggles the visibility state of the plotter component within the ShellView and applies the change immediately, enabling dynamic display control of the plotter interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_plotter_visibility", "line_number": 165, "body": "def update_plotter_visibility(self, initializing_shell_view=False):\n        if self.plotter_visibility_var.get():\n            self.show_plotter(initializing_shell_view)\n        else:\n            self.hide_plotter()", "is_method": true, "class_name": "ShellView", "function_description": "Core method of ShellView that toggles the visibility of a plotter widget based on the current visibility state, supporting optional initialization behavior for display control."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "show_plotter", "line_number": 171, "body": "def show_plotter(self, initializing_shell_view=False):\n        if not initializing_shell_view:\n            get_workbench().show_view(\"ShellView\", True)\n\n        if self.plotter is None:\n            self.plotter = PlotterCanvas(self, self.text)\n\n        if not self.plotter.winfo_ismapped():\n            self.add(self.plotter, minsize=100)\n\n        self.sash_place(0, get_workbench().get_option(\"view.shell_sash_position\"), 0)\n\n        running.io_animation_required = True\n        self.update_plotter()", "is_method": true, "class_name": "ShellView", "function_description": "Service method in ShellView that initializes and displays the plotting interface, ensuring the plotter canvas is set up, visible, and updated for interactive visualization within the shell environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "hide_plotter", "line_number": 186, "body": "def hide_plotter(self):\n        if self.plotter is None or not self.plotter.winfo_ismapped():\n            return\n        else:\n            self.remove(self.plotter)\n            running.io_animation_required = False", "is_method": true, "class_name": "ShellView", "function_description": "Utility method of the ShellView class that hides the currently displayed plotter widget and disables the related animation flag if the plotter is visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "set_notice", "line_number": 193, "body": "def set_notice(self, text):\n        if text is None:\n            self.notice.grid_forget()\n        else:\n            self.notice[\"text\"] = text\n            if not self.notice.winfo_ismapped():\n                self.notice.grid(row=0, column=1, columnspan=2, sticky=\"nsew\", pady=(0, 1))\n                # height of the text was reduced so adjust the scrolling\n                # self.update()\n                self.text.see(\"end\")", "is_method": true, "class_name": "ShellView", "function_description": "Updates or clears a notification message in the ShellView interface, managing its display visibility and ensuring related content scrolls appropriately when shown."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "print_error", "line_number": 204, "body": "def print_error(self, txt):\n        self.text._insert_text_directly(txt, (\"io\", \"stderr\"))\n        self.text.see(\"end\")", "is_method": true, "class_name": "ShellView", "function_description": "Utility method in ShellView that displays error messages in the shell's standard error output area and ensures the view scrolls to show the latest error text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "insert_command_link", "line_number": 208, "body": "def insert_command_link(self, txt, handler):\n        self.text._insert_command_link(txt, handler)", "is_method": true, "class_name": "ShellView", "function_description": "Method of ShellView that inserts interactive command links with associated handlers into the text display, enabling clickable commands within the shell interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "focus_set", "line_number": 211, "body": "def focus_set(self):\n        self.text.focus_set()", "is_method": true, "class_name": "ShellView", "function_description": "Sets keyboard focus to the ShellView's text input area, enabling immediate user interaction. This function is useful for directing input focus within the interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "submit_python_code", "line_number": 214, "body": "def submit_python_code(self, cmd_line):\n        self.text.submit_command(cmd_line, ())", "is_method": true, "class_name": "ShellView", "function_description": "Submits a line of Python code for execution through the ShellView's input interface, facilitating the running of commands within its environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "submit_magic_command", "line_number": 217, "body": "def submit_magic_command(self, cmd_line):\n        if isinstance(cmd_line, list):\n            cmd_line = construct_cmd_line(cmd_line)\n\n        if not cmd_line.endswith(\"\\n\"):\n            cmd_line += \"\\n\"\n\n        self.text.submit_command(cmd_line, (\"magic\",))", "is_method": true, "class_name": "ShellView", "function_description": "Service method of ShellView that submits a magic command line to the shell, ensuring proper formatting and handling both string and list inputs for flexible command execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "restart", "line_number": 226, "body": "def restart(self):\n        self.text.restart()", "is_method": true, "class_name": "ShellView", "function_description": "Service method of the ShellView class that restarts the associated text component, enabling a fresh state or reinitialization of the shell view's content or interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "clear_shell", "line_number": 229, "body": "def clear_shell(self):\n        self.text._clear_shell()", "is_method": true, "class_name": "ShellView", "function_description": "Clears the content of the shell interface, providing a fresh state for displaying new output or commands. This method supports shell view management by resetting its displayed text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "has_pending_input", "line_number": 232, "body": "def has_pending_input(self):\n        return self.text.has_pending_input()", "is_method": true, "class_name": "ShellView", "function_description": "Utility method in ShellView that checks if there is any pending input in the associated text component, enabling calling code to determine if user input is awaiting processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "report_exception", "line_number": 235, "body": "def report_exception(self, prelude=None, conclusion=None):\n        if prelude is not None:\n            self.text.direct_insert(\"end\", prelude + \"\\n\", (\"stderr\",))\n\n        self.text.direct_insert(\"end\", traceback.format_exc() + \"\\n\", (\"stderr\",))\n\n        if conclusion is not None:\n            self.text.direct_insert(\"end\", conclusion + \"\\n\", (\"stderr\",))", "is_method": true, "class_name": "ShellView", "function_description": "Handles and displays the current exception traceback in the ShellView's text area, optionally adding custom messages before and after the error output for clearer error reporting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "set_scrollbar", "line_number": 244, "body": "def set_scrollbar(self, *args):\n        self.vert_scrollbar.set(*args)\n        self.update_plotter()", "is_method": true, "class_name": "ShellView", "function_description": "Utility method of the ShellView class that updates the vertical scrollbar settings and refreshes the associated plot display accordingly. It enables synchronized scrollbar control with plot visualization updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "text_deleted", "line_number": 248, "body": "def text_deleted(self, event):\n        if event.text_widget == self.text:\n            self.update_plotter()", "is_method": true, "class_name": "ShellView", "function_description": "Method in ShellView that updates the plotter whenever text is deleted from the associated text widget, ensuring the displayed plot reflects the current text content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "text_inserted", "line_number": 252, "body": "def text_inserted(self, event):\n        if (\n            event.text_widget == self.text\n            and \"\\n\" in event.text\n            # only when scrollbar doesn't move, because otherwise\n            # the update gets triggered by scrollbar anyway\n            and self.vert_scrollbar.get() == (0.0, 1.0)\n        ):\n            self.update_plotter()", "is_method": true, "class_name": "ShellView", "function_description": "Monitors text insertions in the ShellView's text widget and triggers a plot update only when newlines are inserted without scrollbar movement. This ensures responsive visual updates tied to user text input events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_plotter", "line_number": 262, "body": "def update_plotter(self):\n        if self.plotter is not None and self.plotter.winfo_ismapped():\n            self.plotter.update_plot()", "is_method": true, "class_name": "ShellView", "function_description": "Core method of the ShellView class that updates the plot display by refreshing it only if the plotter widget is currently visible, ensuring efficient graphical updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_tabs", "line_number": 266, "body": "def update_tabs(self):\n        self.text.update_tabs()", "is_method": true, "class_name": "ShellView", "function_description": "Service method of the ShellView class that triggers an update of tab settings or formatting in its text component, facilitating consistent tab behavior within the shell interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "resize_plotter", "line_number": 269, "body": "def resize_plotter(self):\n        if len(self.panes()) > 1 and self.text.winfo_width() > 5:\n            get_workbench().set_option(\"view.shell_sash_position\", self.sash_coord(0)[0])", "is_method": true, "class_name": "ShellView", "function_description": "Adjusts the sash position option when multiple panes are present and the text widget has a valid width, facilitating dynamic layout resizing in the ShellView interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "add_extra_items", "line_number": 279, "body": "def add_extra_items(self):\n        self.add_separator()\n        self.add_command(label=tr(\"Clear\"), command=self.text._clear_shell)\n\n        def toggle_from_menu():\n            # I don't like that Tk menu toggles checbutton variable\n            # automatically before calling the handler.\n            # So I revert the toggle before calling the actual handler.\n            # This way the handler doesn't have to worry whether it\n            # needs to toggle the variable or not, and it can choose to\n            # decline the toggle.\n            self.view.plotter_visibility_var.set(not self.view.plotter_visibility_var.get())\n            self.view.toggle_plotter()\n\n        self.add_checkbutton(\n            label=tr(\"Show Plotter\"),\n            command=toggle_from_menu,\n            variable=self.view.plotter_visibility_var,\n        )", "is_method": true, "class_name": "ShellMenu", "function_description": "Adds extra interactive items to the shell menu, including a clear command and a togglable option to show or hide the plotter, enhancing user control over the shell interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "selection_is_read_only", "line_number": 299, "body": "def selection_is_read_only(self):\n        return not self.text.selection_is_writable()", "is_method": true, "class_name": "ShellMenu", "function_description": "Determines if the current text selection is read-only by checking if it is not writable. This helps in controlling editing capabilities within the ShellMenu context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "is_python_text", "line_number": 399, "body": "def is_python_text(self):\n        return True", "is_method": true, "class_name": "BaseShellText", "function_description": "Indicates that the text handled by this BaseShellText instance is Python code. This method provides a simple flag for identifying the text language type."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "submit_command", "line_number": 402, "body": "def submit_command(self, cmd_line, tags):\n        # assert get_runner().is_waiting_toplevel_command()\n        self.delete(\"input_start\", \"end\")\n        self.insert(\"input_start\", cmd_line, tags)\n        self.see(\"end\")\n        self.mark_set(\"insert\", \"end\")\n        self._try_submit_input()", "is_method": true, "class_name": "BaseShellText", "function_description": "Method of BaseShellText that inserts a command line with tags into the input area and attempts to submit it for execution, facilitating automated command input and processing in the shell interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_handle_input_request", "line_number": 410, "body": "def _handle_input_request(self, msg):\n        self._ensure_visible()\n        self.focus_set()\n        self.mark_set(\"insert\", \"end\")\n        self.tag_remove(\"sel\", \"1.0\", tk.END)\n        self._try_submit_input()  # try to use leftovers from previous request\n        self.see(\"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Internal method of BaseShellText that prepares the widget for new input by focusing, clearing selections, and attempting to process any pending input, ensuring the interface is ready for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_handle_program_output", "line_number": 418, "body": "def _handle_program_output(self, msg):\n        if self._ignore_program_output:\n            # This output will be handled elsewhere\n            return\n        # Discard but not too often, as toplevel response will discard anyway\n        if int(float(self.index(\"end\"))) > get_workbench().get_option(\"shell.max_lines\") + 100:\n            self._discard_old_content()\n\n        self._ensure_visible()\n        self._append_to_io_queue(msg.data, msg.stream_name)\n\n        if not self._applied_io_events:\n            # this is first line of io, add padding below command line\n            self.tag_add(\"before_io\", \"output_insert -1 line linestart\")\n\n        self._update_visible_io(None)", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles and processes output messages from executed shell commands, managing visibility, content length, and proper insertion of output into the interface's I/O queue for consistent user display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_handle_toplevel_response", "line_number": 435, "body": "def _handle_toplevel_response(self, msg: ToplevelResponse) -> None:\n        if msg.get(\"error\"):\n            self._insert_text_directly(msg[\"error\"] + \"\\n\", (\"toplevel\", \"stderr\"))\n            self._ensure_visible()\n\n        if \"user_exception\" in msg:\n            self._show_user_exception(msg[\"user_exception\"])\n            self._ensure_visible()\n\n        welcome_text = msg.get(\"welcome_text\")\n        if welcome_text and welcome_text:\n            preceding = self.get(\"output_insert -1 c\", \"output_insert\")\n            if preceding.strip() and not preceding.endswith(\"\\n\"):\n                self._insert_text_directly(\"\\n\")\n            self._insert_text_directly(welcome_text, (\"welcome\",))\n            self.see(\"end\")\n\n        self.mark_set(\"output_end\", self.index(\"end-1c\"))\n        self._discard_old_content()\n        self._update_visible_io(None)\n        self._reset_ansi_attributes()\n        self._io_cursor_offset = 0\n        self._insert_prompt()\n        self._try_submit_input()  # Trying to submit leftover code (eg. second magic command)\n        self.see(\"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles top-level response messages by displaying errors, user exceptions, and welcome text in the shell, then updates the shell state and prompt accordingly. This supports interactive shell output management in BaseShellText."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_handle_fancy_debugger_progress", "line_number": 466, "body": "def _handle_fancy_debugger_progress(self, msg):\n        if msg.in_present or msg.io_symbol_count is None:\n            self._update_visible_io(None)\n        else:\n            self._update_visible_io(msg.io_symbol_count)", "is_method": true, "class_name": "BaseShellText", "function_description": "Internal method of BaseShellText that updates visible input/output indicators based on debugger progress messages, managing display states during debugging sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_get_squeeze_threshold", "line_number": 472, "body": "def _get_squeeze_threshold(self):\n        return get_workbench().get_option(\"shell.squeeze_threshold\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Utility method of BaseShellText that retrieves the current squeeze threshold setting from the workbench configuration for shell text processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_append_to_io_queue", "line_number": 475, "body": "def _append_to_io_queue(self, data, stream_name):\n        # Make sure ANSI CSI codes and object links are stored as separate events\n        # TODO: try to complete previously submitted incomplete code\n        parts = re.split(OUTPUT_SPLIT_REGEX, data)\n        for part in parts:\n            if part:  # split may produce empty string in the beginning or start\n                # split the data so that very long lines separated\n                for block in re.split(\"(.{%d,})\" % (self._get_squeeze_threshold() + 1), part):\n                    if block:\n                        self._queued_io_events.append((block, stream_name))", "is_method": true, "class_name": "BaseShellText", "function_description": "Internal method of BaseShellText that breaks input data into manageable segments and queues them with their stream identifiers, facilitating controlled processing of shell output events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_update_visible_io", "line_number": 486, "body": "def _update_visible_io(self, target_num_visible_chars):\n        current_num_visible_chars = sum(map(lambda x: len(x[0]), self._applied_io_events))\n\n        if (\n            target_num_visible_chars is not None\n            and target_num_visible_chars < current_num_visible_chars\n        ):\n            # hard to undo complex renderings (squeezed texts and ANSI codes)\n            # easier to clean everything and start again\n            self._queued_io_events = self._applied_io_events + self._queued_io_events\n            self._applied_io_events = []\n            self.direct_delete(\"command_io_start\", \"output_end\")\n            current_num_visible_chars = 0\n            self._reset_ansi_attributes()\n\n        while self._queued_io_events and current_num_visible_chars != target_num_visible_chars:\n            data, stream_name = self._queued_io_events.pop(0)\n\n            if target_num_visible_chars is not None:\n                leftover_count = current_num_visible_chars + len(data) - target_num_visible_chars\n\n                if leftover_count > 0:\n                    # add suffix to the queue\n                    self._queued_io_events.insert(0, (data[-leftover_count:], stream_name))\n                    data = data[:-leftover_count]\n\n            self._apply_io_event(data, stream_name)\n            current_num_visible_chars += len(data)\n\n        self.mark_set(\"output_end\", self.index(\"end-1c\"))\n        self.see(\"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Updates the visible text output to match a target character count by managing and applying queued input/output events, ensuring correct rendering and handling of complex output states like ANSI codes. This supports controlled, incremental display updates in a shell-like text environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_apply_io_event", "line_number": 518, "body": "def _apply_io_event(self, data, stream_name):\n        if not data:\n            return\n\n        original_data = data\n\n        if self.tty_mode and re.match(TERMINAL_CONTROL_REGEX, data):\n            if data == \"\\a\":\n                get_workbench().bell()\n            elif data == \"\\b\":\n                self._change_io_cursor_offset(-1)\n            elif data == \"\\r\":\n                self._change_io_cursor_offset(\"line\")\n            elif data.endswith(\"D\") or data.endswith(\"C\"):\n                self._change_io_cursor_offset_csi(data)\n            elif stream_name == \"stdout\":\n                # According to https://github.com/tartley/colorama/blob/master/demos/demo04.py\n                # codes sent to stderr shouldn't affect later output in stdout\n                # It makes sense, but Ubuntu terminal does not confirm it.\n                # For now I'm just trimming stderr color codes\n                self._update_ansi_attributes(data)\n            else:\n                logger.warning(\"Don't know what to do with %r\" % data)\n\n        elif re.match(OBJECT_INFO_START_REGEX, data):\n            id_str = data[data.index(\"=\") + 1 : data.index(\"]\")]\n            self.active_extra_tags.append(\"value\")\n            self.active_extra_tags.append(id_str)\n            if get_workbench().get_option(\"shell.auto_inspect_values\"):\n                get_workbench().event_generate(\"ObjectSelect\", object_id=int(id_str))\n\n            if get_workbench().in_heap_mode():\n                self._insert_text_directly(\n                    memory.format_object_id(int(id_str)), tuple(self.active_extra_tags)\n                )\n\n        elif re.match(OBJECT_INFO_END_REGEX, data):\n            self.active_extra_tags.pop()\n            self.active_extra_tags.pop()\n\n        elif \"value\" in self.active_extra_tags and get_workbench().in_heap_mode():\n            # id was already printed and value should be suppressed\n            pass\n        else:\n            if \"value\" in self.active_extra_tags:\n                tags = set(self.active_extra_tags)\n            else:\n                tags = set(self.active_extra_tags) | {\"io\", stream_name}\n\n            if stream_name == \"stdout\" and self.tty_mode:\n                tags |= self._get_ansi_tags()\n\n            non_url_length = len(data)\n            for url_match in SIMPLE_URL_SPLIT_REGEX.finditer(data):\n                non_url_length -= url_match.end() - url_match.start()\n\n            if (\n                non_url_length > self._get_squeeze_threshold()\n                and \"\\n\" not in data\n                and not (data.startswith(OBJECT_LINK_START))\n            ):\n                self._io_cursor_offset = 0  # ignore the effect of preceding \\r and \\b\n                actual_text = data\n                button_text = actual_text[:70] + \" \u2026\"\n                btn = tk.Label(\n                    self,\n                    text=button_text,\n                    # width=len(button_text),\n                    cursor=\"arrow\",\n                    borderwidth=2,\n                    relief=\"raised\",\n                    font=\"IOFont\",\n                )\n                btn.bind(\"<1>\", lambda e: self._show_squeezed_text(btn), True)\n                btn.contained_text = actual_text\n                btn.tags = tags\n                self._squeeze_buttons.add(btn)\n                create_tooltip(btn, \"%d characters squeezed. \" % len(data) + \"Click for details.\")\n\n                # TODO: refactor\n                # (currently copied from insert_text_directly)\n                self.mark_gravity(\"input_start\", tk.RIGHT)\n                self.mark_gravity(\"output_insert\", tk.RIGHT)\n\n                self.window_create(\"output_insert\", window=btn)\n                for tag_name in tags:\n                    self.tag_add(tag_name, \"output_insert -1 chars\")\n                data = \"\"\n\n            elif self._io_cursor_offset < 0:\n                overwrite_len = min(len(data), -self._io_cursor_offset)\n\n                if 0 <= data.find(\"\\n\") < overwrite_len:\n                    overwrite_len = data.find(\"\\n\")\n\n                overwrite_data = data[:overwrite_len]\n                self.direct_insert(\n                    \"output_insert -%d chars\" % -self._io_cursor_offset, overwrite_data, tuple(tags)\n                )\n                del_start = self.index(\"output_insert -%d chars\" % -self._io_cursor_offset)\n                del_end = self.index(\n                    \"output_insert -%d chars\" % (-self._io_cursor_offset - overwrite_len)\n                )\n                self.direct_delete(del_start, del_end)\n\n                # compute leftover data to be printed normally\n                data = data[overwrite_len:]\n\n                if \"\\n\" in data:\n                    # cursor offset doesn't apply on new line\n                    self._io_cursor_offset = 0\n                else:\n                    # offset becomes closer to 0\n                    self._io_cursor_offset += overwrite_len\n\n            elif self._io_cursor_offset > 0:\n                # insert spaces before actual data\n                # NB! Print without formatting tags\n                self._insert_text_directly(\" \" * self._io_cursor_offset, (\"io\", stream_name))\n                self._io_cursor_offset = 0\n\n            if data:\n                # if any data is still left, then this should be output normally\n                self._insert_text_directly(data, tuple(tags))\n\n        self._applied_io_events.append((original_data, stream_name))", "is_method": true, "class_name": "BaseShellText", "function_description": "Core method of BaseShellText that processes and formats shell I/O data based on tty mode and content type, handling control characters, object info tags, and long output squeezing for interactive display. It enables responsive, context-aware output rendering in a shell interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_show_squeezed_text", "line_number": 645, "body": "def _show_squeezed_text(self, button):\n        dlg = SqueezedTextDialog(self, button)\n        show_dialog(dlg)", "is_method": true, "class_name": "BaseShellText", "function_description": "Internal helper method of BaseShellText that displays a dialog showing condensed text when triggered by a button."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_change_io_cursor_offset_csi", "line_number": 649, "body": "def _change_io_cursor_offset_csi(self, marker):\n        ints = re.findall(INT_REGEX, marker)\n        if len(ints) != 1:\n            logging.warning(\"bad CSI cursor positioning: %s\", marker)\n            # do nothing\n            return\n\n        try:\n            delta = int(ints[0])\n        except ValueError:\n            logging.warning(\"bad CSI cursor positioning: %s\", marker)\n            return\n\n        if marker.endswith(\"D\"):\n            delta = -delta\n\n        self._change_io_cursor_offset(delta)", "is_method": true, "class_name": "BaseShellText", "function_description": "Internal helper method of BaseShellText that adjusts the input/output cursor position based on a control sequence marker, supporting relative left or right cursor movements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_change_io_cursor_offset", "line_number": 667, "body": "def _change_io_cursor_offset(self, delta):\n        line = self.get(\"output_insert linestart\", \"output_insert\")\n        if delta == \"line\":\n            self._io_cursor_offset = -len(line)\n        else:\n            self._io_cursor_offset += delta\n            if self._io_cursor_offset < -len(line):\n                # cap\n                self._io_cursor_offset = -len(line)", "is_method": true, "class_name": "BaseShellText", "function_description": "Adjusts the internal cursor offset within the shell's output line for input/output management, ensuring the offset stays within the line's boundaries. This supports precise cursor control during shell text interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_reset_ansi_attributes", "line_number": 677, "body": "def _reset_ansi_attributes(self):\n        self._ansi_foreground = None\n        self._ansi_background = None\n        self._ansi_inverse = False\n        self._ansi_intensity = None\n        self._ansi_italic = False\n        self._ansi_underline = False\n        self._ansi_conceal = False\n        self._ansi_strikethrough = False", "is_method": true, "class_name": "BaseShellText", "function_description": "Resets all ANSI styling attributes of the BaseShellText instance to their default states, effectively clearing any applied text formatting such as colors, intensity, or decorations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_update_ansi_attributes", "line_number": 687, "body": "def _update_ansi_attributes(self, marker):\n        if not marker.endswith(\"m\"):\n            # ignore\n            return\n\n        codes = re.findall(INT_REGEX, marker)\n        if not codes:\n            self._reset_ansi_attributes()\n\n        while codes:\n            code = codes.pop(0)\n\n            if code == \"0\":\n                self._reset_ansi_attributes()\n            elif code in [\"1\", \"2\"]:\n                self._ansi_intensity = code\n            elif code == \"3\":\n                self._ansi_italic = True\n            elif code == \"4\":\n                self._ansi_underline = True\n            elif code == \"7\":\n                self._ansi_inverse = True\n            elif code == \"8\":\n                self._ansi_conceal = True\n            elif code == \"9\":\n                self._ansi_strikethrough = True\n            elif code == \"22\":\n                self._ansi_intensity = None\n            elif code == \"23\":\n                self._ansi_italic = False\n            elif code == \"24\":\n                self._ansi_underline = False\n            elif code == \"27\":\n                self._ansi_inverse = False\n            elif code == \"28\":\n                self._ansi_conceal = False\n            elif code == \"29\":\n                self._ansi_strikethrough = False\n            if code in [\n                \"30\",\n                \"31\",\n                \"32\",\n                \"33\",\n                \"34\",\n                \"35\",\n                \"36\",\n                \"37\",\n                \"90\",\n                \"91\",\n                \"92\",\n                \"93\",\n                \"94\",\n                \"95\",\n                \"96\",\n                \"97\",\n            ]:\n                self._ansi_foreground = code\n            elif code == \"39\":\n                self._ansi_foreground = None\n            elif code in [\n                \"40\",\n                \"41\",\n                \"42\",\n                \"43\",\n                \"44\",\n                \"45\",\n                \"46\",\n                \"47\",\n                \"100\",\n                \"101\",\n                \"102\",\n                \"103\",\n                \"104\",\n                \"105\",\n                \"106\",\n                \"107\",\n            ]:\n                self._ansi_background = code\n            elif code == \"49\":\n                self._ansi_background = None\n            elif code in [\"38\", \"48\"]:\n                # multipart code, ignore for now,\n                # but make sure all arguments are ignored\n                if not codes:\n                    # nothing follows, ie. invalid code\n                    break\n                mode = codes.pop(0)\n                if mode == \"5\":\n                    # 256-color code, just ignore for now\n                    if not codes:\n                        break\n                    codes = codes[1:]\n                elif mode == \"2\":\n                    # 24-bit code, ignore\n                    if len(codes) < 3:\n                        # invalid code\n                        break\n                    codes = codes[3:]\n            else:\n                # ignore other codes\n                pass", "is_method": true, "class_name": "BaseShellText", "function_description": "Core method of BaseShellText that parses ANSI escape codes to update text styling attributes like intensity, italic, underline, color, and concealment, enabling correct representation of formatted terminal output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_get_ansi_tags", "line_number": 789, "body": "def _get_ansi_tags(self):\n        result = set()\n\n        if self._ansi_foreground:\n            fg = ANSI_COLOR_NAMES[self._ansi_foreground[-1]]\n            if self._ansi_intensity == \"1\" or self._ansi_foreground[0] == \"9\":\n                fg = \"bright_\" + fg\n            elif self._ansi_intensity == \"2\":\n                fg = \"dim_\" + fg\n        else:\n            fg = \"fore\"\n            if self._ansi_intensity == \"1\":\n                fg = \"bright_\" + fg\n            elif self._ansi_intensity == \"2\":\n                fg = \"dim_\" + fg\n\n        if self._ansi_background:\n            bg = ANSI_COLOR_NAMES[self._ansi_background[-1]]\n            if self._ansi_background.startswith(\"10\"):\n                bg = \"bright_\" + bg\n        else:\n            bg = \"back\"\n\n        if self._ansi_inverse:\n            result.add(fg + \"_bg\")\n            result.add(bg + \"_fg\")\n        else:\n            if fg != \"fore\":\n                result.add(fg + \"_fg\")\n            if bg != \"back\":\n                result.add(bg + \"_bg\")\n\n        if self._ansi_intensity == \"1\" and self._ansi_italic:\n            result.add(\"intense_italic_io\")\n        elif self._ansi_intensity == \"1\":\n            result.add(\"intense_io\")\n        elif self._ansi_italic:\n            result.add(\"italic_io\")\n\n        if self._ansi_underline:\n            result.add(\"underline\")\n\n        if self._ansi_strikethrough:\n            result.add(\"strikethrough\")\n\n        return result", "is_method": true, "class_name": "BaseShellText", "function_description": "Utility method of the BaseShellText class that derives a set of ANSI style tags representing the current text formatting state, facilitating text styling based on foreground, background, intensity, and other ANSI attributes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_insert_prompt", "line_number": 836, "body": "def _insert_prompt(self):\n        # if previous output didn't put a newline, then do it now\n        if not self.index(\"output_insert\").endswith(\".0\"):\n            self._insert_text_directly(\"\\n\", (\"io\",))\n\n        prompt_tags = (\"toplevel\", \"prompt\")\n\n        # if previous line has value or io then add little space\n        prev_line = self.index(\"output_insert - 1 lines\")\n        prev_line_tags = self.tag_names(prev_line)\n        if \"io\" in prev_line_tags or \"value\" in prev_line_tags:\n            prompt_tags += (\"after_io_or_value\",)\n\n        self._insert_text_directly(\">>> \", prompt_tags)\n        self.edit_reset()", "is_method": true, "class_name": "BaseShellText", "function_description": "In the BaseShellText class, this method inserts a formatted prompt marker (\">>> \") at the current insertion point, ensuring proper spacing and line breaks for interactive shell-like text input interfaces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_ensure_visible", "line_number": 852, "body": "def _ensure_visible(self):\n        if self.winfo_ismapped():\n            return\n\n        focused_view = get_workbench().focus_get()\n        get_workbench().show_view(\"ShellView\")\n        if focused_view is not None:\n            focused_view.focus()", "is_method": true, "class_name": "BaseShellText", "function_description": "Ensures the ShellView is displayed in the interface if not already visible, while preserving the user's current focus to maintain workflow continuity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_tabs", "line_number": 861, "body": "def update_tabs(self):\n        tab_chars = 8\n        tab_pixels = tk.font.nametofont(\"IOFont\").measure(\"n\" * tab_chars)\n\n        offset = self.io_indent\n        tabs = [offset]\n        for _ in range(20):\n            offset += tab_pixels\n            tabs.append(offset)\n\n        self.tag_configure(\"io\", tabs=tabs, tabstyle=\"wordprocessor\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Sets and updates tab stop positions in the BaseShellText widget to align text consistently, supporting proper indentation and formatting for interactive input/output display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "restart", "line_number": 873, "body": "def restart(self):\n        self._insert_text_directly(\n            # \"\\n============================== RESTART ==============================\\n\",\n            \"\\n\" + \"\u2500\" * 200 + \"\\n\",\n            # \"\\n\" + \"\u2550\"*200 + \"\\n\",\n            (\"magic\", \"restart_line\"),\n        )\n        self.see(\"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Service method of BaseShellText that visually marks a restart point in the shell's text output and moves the cursor to the end, aiding in clear session restarts or resets within a text interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "intercept_insert", "line_number": 882, "body": "def intercept_insert(self, index, txt, tags=()):\n        # pylint: disable=arguments-differ\n        if self._editing_allowed() and self._in_current_input_range(index):\n            # self._print_marks(\"before insert\")\n            # I want all marks to stay in place\n            self.mark_gravity(\"input_start\", tk.LEFT)\n            self.mark_gravity(\"output_insert\", tk.LEFT)\n\n            if get_runner().is_waiting_toplevel_command():\n                tags = tags + (\"toplevel\", \"command\")\n            else:\n                tags = tags + (\"io\", \"stdin\")\n\n            EnhancedTextWithLogging.intercept_insert(self, index, txt, tags)\n\n            if not get_runner().is_waiting_toplevel_command():\n                if not self._applied_io_events:\n                    # tag preceding command line differently\n                    self.tag_add(\"before_io\", \"input_start -1 lines linestart\")\n\n                self._try_submit_input()\n\n            self.see(\"insert\")\n        else:\n            get_workbench().bell()", "is_method": true, "class_name": "BaseShellText", "function_description": "Method of BaseShellText that manages controlled text insertions within the current input area, tagging input appropriately and triggering input submission while maintaining text mark positions and providing user feedback on invalid edits."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "intercept_delete", "line_number": 908, "body": "def intercept_delete(self, index1, index2=None, **kw):\n        if index1 == \"sel.first\" and index2 == \"sel.last\" and not self.has_selection():\n            return\n\n        if (\n            self._editing_allowed()\n            and self._in_current_input_range(index1)\n            and (index2 is None or self._in_current_input_range(index2))\n        ):\n            self.direct_delete(index1, index2, **kw)\n        else:\n            get_workbench().bell()", "is_method": true, "class_name": "BaseShellText", "function_description": "Method of BaseShellText that conditionally intercepts and performs deletion commands within allowed input ranges, preventing unauthorized edits and signaling with a bell when deletion is disallowed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "selection_is_writable", "line_number": 921, "body": "def selection_is_writable(self):\n        try:\n            if not self.has_selection():\n                return self._in_current_input_range(self.index(\"insert\"))\n            else:\n                return self._in_current_input_range(\n                    self.index(\"sel.first\")\n                ) and self._in_current_input_range(self.index(\"sel.last\"))\n        except TclError:\n            return True", "is_method": true, "class_name": "BaseShellText", "function_description": "Checks if the current text selection or cursor position is within an editable input range, indicating whether the user can modify the selected text or insertion point."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "perform_return", "line_number": 932, "body": "def perform_return(self, event):\n        if get_runner().is_running():\n            # if we are fixing the middle of the input string and pressing ENTER\n            # then we expect the whole line to be submitted not linebreak to be inserted\n            # (at least that's how IDLE works)\n            self.mark_set(\"insert\", \"end\")  # move cursor to the end\n\n            # Do the return without auto indent\n            EnhancedTextWithLogging.perform_return(self, event)\n\n            self._try_submit_input()\n\n        elif get_runner().is_waiting_toplevel_command():\n            # Same with editin middle of command, but only if it's a single line command\n            whole_input = self.get(\"input_start\", \"end-1c\")  # asking the whole input\n            if \"\\n\" not in whole_input and self._code_is_ready_for_submission(whole_input):\n                self.mark_set(\"insert\", \"end\")  # move cursor to the end\n                # Do the return without auto indent\n                EnhancedTextWithLogging.perform_return(self, event)\n            else:\n                # Don't want auto indent when code is ready for submission\n                source = self.get(\"input_start\", \"insert\")\n                tail = self.get(\"insert\", \"end\")\n\n                if self._code_is_ready_for_submission(source + \"\\n\", tail):\n                    # No auto-indent\n                    EnhancedTextWithLogging.perform_return(self, event)\n                else:\n                    # Allow auto-indent\n                    perform_python_return(self, event)\n\n            self._try_submit_input()\n\n        return \"break\"", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles the Return key behavior in an interactive shell text widget, ensuring proper submission or newline insertion based on the current input state and execution context. It manages cursor positioning and indentation to facilitate seamless code entry and submission."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "on_secondary_click", "line_number": 967, "body": "def on_secondary_click(self, event=None):\n        super().on_secondary_click(event)\n        if self.view:\n            self.view.menu.tk_popup(event.x_root, event.y_root)", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles right-click events by displaying a context menu at the click position, enabling interactive user interface actions within the BaseShellText view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_in_current_input_range", "line_number": 972, "body": "def _in_current_input_range(self, index):\n        try:\n            return self.compare(index, \">=\", \"input_start\")\n        except Exception:\n            return False", "is_method": true, "class_name": "BaseShellText", "function_description": "Checks if a given index falls within the current input range by comparing it to the input start marker; returns False if the comparison cannot be performed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_insert_command_link", "line_number": 978, "body": "def _insert_command_link(self, txt, handler):\n        self._link_handler_count += 1\n        command_tag = \"link_handler_%s\" % self._link_handler_count\n\n        self.direct_insert(\"output_insert\", txt, (\"io_hyperlink\", command_tag))\n        self.tag_bind(command_tag, \"<1>\", handler)", "is_method": true, "class_name": "BaseShellText", "function_description": "Utility method in BaseShellText that inserts clickable text linked to a handler function, enabling interactive command execution within the shell interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_insert_text_directly", "line_number": 985, "body": "def _insert_text_directly(self, txt, tags=()):\n        def _insert(txt, tags):\n            if txt != \"\":\n                self.direct_insert(\"output_insert\", txt, tags)\n\n        def _insert_and_highlight_urls(txt, tags):\n            parts = SIMPLE_URL_SPLIT_REGEX.split(txt)\n            for i, part in enumerate(parts):\n                if i % 2 == 0:\n                    _insert(part, tags)\n                else:\n                    if part.startswith(\"data:image/\"):\n                        token = \";base64,\"\n                        data = part[part.index(token) + len(token) :]\n                        try:\n                            img = tk.PhotoImage(data=data)\n                            self._images.add(img)  # to avoit it being gc-d\"\"\"\n                            self.image_create(\"output_insert\", image=img)\n                            for tag in tags:\n                                self.tag_add(tag, \"output_insert -1 chars\")\n                        except TclError:\n                            _insert(part, tags + (\"io_hyperlink\",))\n                    else:\n                        _insert(part, tags + (\"io_hyperlink\",))\n\n        # I want the insertion to go before marks\n        # self._print_marks(\"before output\")\n        self.mark_gravity(\"input_start\", tk.RIGHT)\n        self.mark_gravity(\"output_insert\", tk.RIGHT)\n        tags = tuple(tags)\n\n        # Make stacktrace clickable\n        if \"stderr\" in tags or \"error\" in tags or (\"File\" in txt and \"line\" in txt):\n            # show lines pointing to source lines as hyperlinks\n            for line in txt.splitlines(True):\n                parts = re.split(r\"(File .* line \\d+.*)$\", line, maxsplit=1)\n                if len(parts) == 3 and \"<pyshell\" not in line:\n                    _insert(parts[0], tags)\n                    _insert(parts[1], tags + (\"io_hyperlink\",))\n                    _insert(parts[2], tags)\n                else:\n                    parts = re.split(r\"(\\'[^\\']+\\.pyw?\\')\", line, flags=re.IGNORECASE)\n                    if len(parts) == 3 and os.path.exists(os.path.expanduser(parts[1][1:-1])):\n                        match = re.search(r\"\\S\", line)\n                        _insert(line[: match.start()], tags)\n                        _insert(line[match.start() :], tags + (\"io_hyperlink\",))\n                    else:\n                        _insert_and_highlight_urls(line, tags)\n        else:\n            _insert_and_highlight_urls(txt, tags)", "is_method": true, "class_name": "BaseShellText", "function_description": "Utility method of the BaseShellText class that inserts text with support for clickable hyperlinks and embedded images, enhancing output display by highlighting URLs and making error tracebacks interactive."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "has_pending_input", "line_number": 1039, "body": "def has_pending_input(self):\n        pending = self.get(\"input_start\", \"end-1c\")\n        return bool(pending)", "is_method": true, "class_name": "BaseShellText", "function_description": "Checks whether there is any pending user input in the shell text buffer, indicating if input processing is incomplete or waiting. This helps manage input readiness in interactive shell environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_try_submit_input", "line_number": 1043, "body": "def _try_submit_input(self):\n        # see if there is already enough inputted text to submit\n        input_text = self.get(\"input_start\", \"insert\")\n        tail = self.get(\"insert\", \"end\")\n\n        # user may have pasted more text than necessary for this request\n        submittable_text = self._extract_submittable_input(input_text, tail)\n\n        if submittable_text is not None:\n            if get_runner().is_waiting_toplevel_command():\n                # clean up the tail\n                if len(tail) > 0:\n                    assert tail.strip() == \"\"\n                    self.delete(\"insert\", \"end-1c\")\n\n            # leftover text will be kept in widget, waiting for next request.\n            start_index = self.index(\"input_start\")\n            end_index = self.index(\"input_start+{0}c\".format(len(submittable_text)))\n\n            # apply correct tags (if it's leftover then it doesn't have them yet)\n            if get_runner().is_running():\n                self.tag_add(\"io\", start_index, end_index)\n                self.tag_add(\"stdin\", start_index, end_index)\n            else:\n                self.tag_add(\"toplevel\", start_index, end_index)\n                self.tag_add(\"command\", start_index, end_index)\n\n            # update start mark for next input range\n            self.mark_set(\"input_start\", end_index)\n\n            # Move output_insert mark after the requested_text\n            # Leftover input, if any, will stay after output_insert,\n            # so that any output that will come in before\n            # next input request will go before leftover text\n            self.mark_set(\"output_insert\", end_index)\n\n            # remove tags from leftover text\n            for tag in (\"io\", \"stdin\", \"toplevel\", \"command\"):\n                # don't remove magic, because otherwise I can't know it's auto\n                self.tag_remove(tag, end_index, \"end\")\n\n            self._submit_input(submittable_text)", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles partial user input in an interactive shell by submitting all text that forms a complete command while preserving any leftover input for subsequent processing. It manages text tags and markers to coordinate input submission and output placement seamlessly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_editing_allowed", "line_number": 1086, "body": "def _editing_allowed(self):\n        return get_runner() is not None", "is_method": true, "class_name": "BaseShellText", "function_description": "This method checks if an editing operation is permissible by verifying the availability of a runner component. It provides a simple permission check used internally within the BaseShellText class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_extract_submittable_input", "line_number": 1089, "body": "def _extract_submittable_input(self, input_text, tail):\n\n        if get_runner().is_waiting_toplevel_command():\n            if input_text.endswith(\"\\n\"):\n                if input_text.strip().startswith(\"%\") or input_text.strip().startswith(\"!\"):\n                    # if several magic command are submitted, then take only first\n                    return input_text[: input_text.index(\"\\n\") + 1]\n                elif self._code_is_ready_for_submission(input_text, tail):\n                    return input_text\n                else:\n                    return None\n            else:\n                return None\n\n        elif get_runner().is_running():\n            i = 0\n            while True:\n                if i >= len(input_text):\n                    return None\n                elif input_text[i] == \"\\n\":\n                    return input_text[: i + 1]\n                else:\n                    i += 1\n\n        return None", "is_method": true, "class_name": "BaseShellText", "function_description": "Utility method in BaseShellText that determines and extracts the portion of input text ready for submission based on the shell's current execution state, supporting command splitting and magic command handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_code_is_ready_for_submission", "line_number": 1115, "body": "def _code_is_ready_for_submission(self, source, tail=\"\"):\n        # Ready to submit if ends with empty line\n        # or is complete single-line code\n\n        if tail.strip() != \"\":\n            return False\n\n        # First check if it has unclosed parens, unclosed string or ending with : or \\\n        parser = roughparse.RoughParser(self.indent_width, self.tabwidth)\n        parser.set_str(source.rstrip() + \"\\n\")\n        if parser.get_continuation_type() != roughparse.C_NONE or parser.is_block_opener():\n            return False\n\n        # Multiline compound statements need to end with empty line to be considered\n        # complete.\n        lines = source.splitlines()\n        # strip starting empty and comment lines\n        while len(lines) > 0 and (lines[0].strip().startswith(\"#\") or lines[0].strip() == \"\"):\n            lines.pop(0)\n\n        compound_keywords = [\"if\", \"while\", \"for\", \"with\", \"try\", \"def\", \"class\", \"async\", \"await\"]\n        if len(lines) > 0:\n            first_word = lines[0].strip().split()[0]\n            if first_word in compound_keywords and not source.replace(\" \", \"\").replace(\n                \"\\t\", \"\"\n            ).endswith(\"\\n\\n\"):\n                # last line is not empty\n                return False\n\n        return True", "is_method": true, "class_name": "BaseShellText", "function_description": "Determines if a given Python source code snippet is syntactically complete and ready for execution or submission, considering multi-line constructs and required line endings. Useful for interactive shells or code editors to detect code block completion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_submit_input", "line_number": 1146, "body": "def _submit_input(self, text_to_be_submitted):\n        logging.debug(\n            \"SHELL: submitting %r in state %s\", text_to_be_submitted, get_runner().get_state()\n        )\n        if get_runner().is_waiting_toplevel_command():\n            # register in history and count\n            if text_to_be_submitted in self._command_history:\n                self._command_history.remove(text_to_be_submitted)\n            self._command_history.append(text_to_be_submitted)\n\n            # meaning command selection is not in process\n            self._command_history_current_index = None\n\n            self.update_tty_mode()\n\n            cmd_line = text_to_be_submitted.strip()\n            try:\n                if cmd_line.startswith(\"%\"):\n                    parts = cmd_line.split(\" \", maxsplit=1)\n                    if len(parts) == 2:\n                        args_str = parts[1].strip()\n                    else:\n                        args_str = \"\"\n                    argv = parse_cmd_line(cmd_line[1:])\n                    command_name = argv[0]\n                    cmd_args = argv[1:]\n\n                    if len(cmd_args) >= 2 and cmd_args[0] == \"-c\":\n                        # move source argument to source attribute\n                        source = cmd_args[1]\n                        cmd_args = [cmd_args[0]] + cmd_args[2:]\n                        if source == EDITOR_CONTENT_TOKEN:\n                            source = (\n                                get_workbench().get_editor_notebook().get_current_editor_content()\n                            )\n                    else:\n                        source = None\n\n                    get_workbench().event_generate(\"MagicCommand\", cmd_line=text_to_be_submitted)\n                    get_runner().send_command(\n                        ToplevelCommand(\n                            command_name,\n                            args=cmd_args,\n                            args_str=args_str,\n                            cmd_line=cmd_line,\n                            tty_mode=self.tty_mode,\n                            source=source,\n                        )\n                    )\n                elif cmd_line.startswith(\"!\"):\n                    argv = parse_cmd_line(cmd_line[1:])\n                    get_workbench().event_generate(\"SystemCommand\", cmd_line=text_to_be_submitted)\n                    get_runner().send_command(\n                        ToplevelCommand(\n                            \"execute_system_command\",\n                            argv=argv,\n                            cmd_line=cmd_line,\n                            tty_mode=self.tty_mode,\n                        )\n                    )\n                else:\n                    get_runner().send_command(\n                        ToplevelCommand(\n                            \"execute_source\", source=text_to_be_submitted, tty_mode=self.tty_mode\n                        )\n                    )\n\n                # remember the place where the output of this command started\n                self.mark_set(\"command_io_start\", \"output_insert\")\n                self.mark_gravity(\"command_io_start\", \"left\")\n                # discard old io events\n                self._applied_io_events = []\n                self._queued_io_events = []\n            except Exception:\n                get_workbench().report_exception()\n                self._insert_prompt()\n\n            get_workbench().event_generate(\"ShellCommand\", command_text=text_to_be_submitted)\n        else:\n            assert get_runner().is_running()\n            get_runner().send_program_input(text_to_be_submitted)\n            get_workbench().event_generate(\"ShellInput\", input_text=text_to_be_submitted)\n            self._applied_io_events.append((text_to_be_submitted, \"stdin\"))", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles input submission in a shell interface by processing and dispatching commands or program input based on shell state, managing command history, and generating related events for the broader workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_arrow_up", "line_number": 1230, "body": "def _arrow_up(self, event):\n        if not get_runner().is_waiting_toplevel_command():\n            return None\n\n        if not self._in_current_input_range(\"insert\"):\n            return None\n\n        insert_line = index2line(self.index(\"insert\"))\n        input_start_line = index2line(self.index(\"input_start\"))\n        if insert_line != input_start_line:\n            # we're in the middle of a multiline command\n            return None\n\n        if len(self._command_history) == 0 or self._command_history_current_index == 0:\n            # can't take previous command\n            return \"break\"\n\n        if self._command_history_current_index is None:\n            self._command_history_current_index = len(self._command_history) - 1\n        else:\n            self._command_history_current_index -= 1\n\n        cmd = self._command_history[self._command_history_current_index]\n        if cmd[-1] == \"\\n\":\n            cmd = cmd[:-1]  # remove the submission linebreak\n        self._propose_command(cmd)\n        return \"break\"", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles the up-arrow key event to navigate backward through command history when inputting a top-level shell command, proposing previous commands for user editing or re-execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_arrow_down", "line_number": 1258, "body": "def _arrow_down(self, event):\n        if not get_runner().is_waiting_toplevel_command():\n            return None\n\n        if not self._in_current_input_range(\"insert\"):\n            return None\n\n        insert_line = index2line(self.index(\"insert\"))\n        last_line = index2line(self.index(\"end-1c\"))\n        if insert_line != last_line:\n            # we're in the middle of a multiline command\n            return None\n\n        if (\n            len(self._command_history) == 0\n            or self._command_history_current_index is None\n            or self._command_history_current_index >= len(self._command_history) - 1\n        ):\n            # can't take next command\n            self._command_history_current_index = len(self._command_history)\n            self._propose_command(\"\")\n            return \"break\"\n\n        if self._command_history_current_index is None:\n            self._command_history_current_index = len(self._command_history) - 1\n        else:\n            self._command_history_current_index += 1\n\n        self._propose_command(\n            self._command_history[self._command_history_current_index].strip(\"\\n\")\n        )\n        return \"break\"", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles the Down Arrow key event in a shell-like text interface, navigating forward through the command history and updating the input accordingly when at the current input line."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_propose_command", "line_number": 1291, "body": "def _propose_command(self, cmd_line):\n        self.delete(\"input_start\", \"end\")\n        self.intercept_insert(\"input_start\", cmd_line)\n        self.see(\"insert\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Utility method in BaseShellText that replaces the current input area with a proposed command line and scrolls the view to the cursor position."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_clear_shell", "line_number": 1315, "body": "def _clear_shell(self):\n        end_index = self.index(\"output_end\")\n        self._clear_content(end_index)", "is_method": true, "class_name": "BaseShellText", "function_description": "Private method in BaseShellText that clears the shell's content up to the output end marker, supporting shell interface management by removing previous output data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_backend_restart", "line_number": 1319, "body": "def _on_backend_restart(self, event=None):\n        # make sure dead values are not clickable anymore\n        self.tag_remove(\"value\", \"0.1\", \"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Private method of BaseShellText that disables interaction with outdated or invalid content after a backend restart, ensuring the user interface reflects the current backend state consistently."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "compute_smart_home_destination_index", "line_number": 1323, "body": "def compute_smart_home_destination_index(self):\n        \"\"\"Is used by EnhancedText\"\"\"\n\n        if self._in_current_input_range(\"insert\"):\n            # on input line, go to just after prompt\n            return \"input_start\"\n        else:\n            return super().compute_smart_home_destination_index()", "is_method": true, "class_name": "BaseShellText", "function_description": "Overrides behavior to determine the cursor position when the Home key is pressed, customizing the destination for text input lines and falling back to the default otherwise. Useful for enhanced text input navigation within the BaseShellText context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_value_click", "line_number": 1332, "body": "def _value_click(self, event):\n        pos = \"@%d,%d\" % (event.x, event.y)\n        tags = self.tag_names(pos)\n        for tag in tags:\n            if tag.isnumeric() or tag[0] == \"-\" and tag[1:].isnumeric():\n                get_workbench().show_view(\"ObjectInspector\", set_focus=False)\n                get_workbench().update_idletasks()\n                get_workbench().event_generate(\"ObjectSelect\", object_id=int(tag))", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles a click event on numeric tags within the text, triggering the ObjectInspector view to display details for the corresponding object ID without shifting user focus."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_handle_hyperlink", "line_number": 1352, "body": "def _handle_hyperlink(self, event):\n        import webbrowser\n\n        try:\n            line = self.get(\"insert linestart\", \"insert lineend\")\n            # Python stacktrace\n            matches = list(re.finditer(r'File \"(?P<file>[^\"]+)\", line (?P<line>\\d+)', line))\n            if not matches:\n                # Friendly traceback\n                matches = list(\n                    re.finditer(\n                        r\"\\b(?P<line>\\d+)\\b.+'(?P<file>[^\\']+\\.pyw?)'\", line, flags=re.IGNORECASE\n                    )\n                )\n\n            if len(matches) == 1:\n                filename = os.path.expanduser(matches[0].group(\"file\"))\n                lineno = int(matches[0].group(\"line\"))\n                if os.path.exists(filename) and os.path.isfile(filename):\n                    # TODO: better use events instead direct referencing\n                    get_workbench().get_editor_notebook().show_file(\n                        filename, lineno, set_focus=False\n                    )\n            else:\n                r = self.tag_prevrange(\"io_hyperlink\", \"@%d,%d\" % (event.x, event.y))\n                if r and len(r) == 2:\n                    url = self.get(r[0], r[1])\n                    if SIMPLE_URL_SPLIT_REGEX.match(url):\n                        webbrowser.open(url)\n\n        except Exception as e:\n            logger.exception(\"Could not handle hyperlink click\", exc_info=e)", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles clicks on hyperlinks or file references in shell text, opening files at specific lines in the editor or launching URLs in a web browser for enhanced interactive error tracebacks and user convenience."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_show_user_exception", "line_number": 1385, "body": "def _show_user_exception(self, user_exception):\n        for line, frame_id, *_ in user_exception[\"items\"]:\n\n            tags = (\"io\", \"stderr\")\n            if frame_id is not None:\n                frame_tag = \"frame_%d\" % frame_id\n\n                def handle_frame_click(event, frame_id=frame_id):\n                    get_runner().send_command(InlineCommand(\"get_frame_info\", frame_id=frame_id))\n                    return \"break\"\n\n                # TODO: put first line with frame tag and rest without\n                tags += (frame_tag,)\n                self.tag_bind(frame_tag, \"<ButtonRelease-1>\", handle_frame_click, True)\n\n            self._insert_text_directly(line, tags)", "is_method": true, "class_name": "BaseShellText", "function_description": "Utility method in BaseShellText that displays user exceptions with interactive frame tags, enabling users to click frames to trigger commands for retrieving frame-specific information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_discard_old_content", "line_number": 1402, "body": "def _discard_old_content(self):\n        max_lines = max(get_workbench().get_option(\"shell.max_lines\"), 0)\n        proposed_cut = self.index(\"end -%d lines linestart\" % max_lines)\n        if proposed_cut == \"1.0\":\n            return\n\n        # would this keep current block intact?\n        next_prompt = self.tag_nextrange(\"prompt\", proposed_cut, \"end\")\n        if not next_prompt:\n            pass  # TODO: disable stepping back\n\n        self._clear_content(proposed_cut)", "is_method": true, "class_name": "BaseShellText", "function_description": "Private method of BaseShellText that removes old lines from the shell output exceeding a configured maximum, maintaining prompt blocks intact to manage shell content length efficiently."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_clear_content", "line_number": 1415, "body": "def _clear_content(self, cut_idx):\n        proposed_cut_float = float(cut_idx)\n        for btn in list(self._squeeze_buttons):\n            try:\n                idx = self.index(btn)\n                if idx is None or idx == \"\" or float(idx) < proposed_cut_float:\n                    self._squeeze_buttons.remove(btn)\n                    # looks like the widgets are not fully GC-d.\n                    # At least avoid leaking big chunks of texts\n                    btn.contained_text = None\n                    btn.destroy()\n            except Exception as e:\n                logger.warning(\"Problem with a squeeze button, removing it\", exc_info=e)\n                if btn in self._squeeze_buttons:\n                    self._squeeze_buttons.remove(btn)\n\n        self.direct_delete(\"0.1\", cut_idx)", "is_method": true, "class_name": "BaseShellText", "function_description": "Clears content and removes certain interface buttons before a specified cut-off index, helping manage and clean up text and associated widgets within the BaseShellText component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_mouse_move", "line_number": 1433, "body": "def _on_mouse_move(self, event=None):\n        tags = self.tag_names(\"@%d,%d\" % (event.x, event.y))\n        if \"value\" in tags or \"io_hyperlink\" in tags:\n            if self.cget(\"cursor\") != \"hand2\":\n                self.config(cursor=\"hand2\")\n        else:\n            if self.cget(\"cursor\"):\n                self.config(cursor=\"\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Core utility method of BaseShellText that dynamically changes the mouse cursor style to a pointer when hovering over specific text tags, enhancing user interaction feedback within the text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_invalidate_current_data", "line_number": 1442, "body": "def _invalidate_current_data(self):\n        \"\"\"\n        Grayes out input & output displayed so far\n        \"\"\"\n        end_index = self.index(\"output_end\")\n\n        self.tag_add(\"inactive\", \"1.0\", end_index)\n        self.tag_remove(\"value\", \"1.0\", end_index)\n\n        while len(self.active_extra_tags) > 0:\n            self.tag_remove(self.active_extra_tags.pop(), \"1.0\", \"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Utility method in BaseShellText that visually disables (grays out) all current input and output text, removing active styling tags to indicate the content is inactive or finalized."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "get_lines_above_viewport_bottom", "line_number": 1454, "body": "def get_lines_above_viewport_bottom(self, tag_name, n):\n        end_index = self.index(\"@%d,%d lineend\" % (self.winfo_height(), self.winfo_height()))\n        start_index = self.index(end_index + \" -50 lines\")\n\n        result = \"\"\n        while True:\n            r = self.tag_nextrange(tag_name, start_index, end_index)\n            if not r:\n                break\n            result += self.get(r[0], r[1])\n            start_index = r[1]\n\n        return result", "is_method": true, "class_name": "BaseShellText", "function_description": "Returns concatenated text segments tagged with a specific name located within the last 50 lines above the visible bottom area of the widget, facilitating retrieval of recent tagged content near the viewport end."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_tty_mode", "line_number": 1468, "body": "def update_tty_mode(self):\n        self.tty_mode = get_workbench().get_option(\"shell.tty_mode\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Updates the object's tty_mode attribute based on the current shell tty_mode configuration from the workbench settings. Useful for syncing the shell text behavior with the environment's terminal mode."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "set_syntax_options", "line_number": 1471, "body": "def set_syntax_options(self, syntax_options):\n        super().set_syntax_options(syntax_options)\n        self.update_margin_color()", "is_method": true, "class_name": "BaseShellText", "function_description": "Overrides syntax options while updating margin color to maintain consistent text rendering settings in the BaseShellText interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_margin_color", "line_number": 1475, "body": "def update_margin_color(self):\n        if ui_utils.get_tk_version_info() >= (8, 6, 6):\n            self.tag_configure(\"io\", lmargincolor=get_syntax_options_for_tag(\"TEXT\")[\"background\"])", "is_method": true, "class_name": "BaseShellText", "function_description": "Method of BaseShellText that updates the left margin color of the shell text based on the UI toolkit version and syntax highlighting settings. It ensures consistent margin appearance when supported by the underlying UI framework."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_hide_trailing_output", "line_number": 1479, "body": "def _hide_trailing_output(self, msg):\n        pos = self.search(msg.text, index=\"end\", backwards=True)\n        if pos:\n            end_pos = self.index(\"%s + %d chars\" % (pos, len(msg.text)))\n            if end_pos == self.index(\"output_end\"):\n                self.direct_delete(pos, end_pos)", "is_method": true, "class_name": "BaseShellText", "function_description": "Internal method of BaseShellText that removes specific trailing output matching a given message, helping manage or clean displayed shell text dynamically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_wrap_changed", "line_number": 1579, "body": "def _on_wrap_changed(self):\n        if self._wrap_var.get():\n            self.text_frame.text.configure(wrap=\"word\")\n        else:\n            self.text_frame.text.configure(wrap=\"none\")", "is_method": true, "class_name": "SqueezedTextDialog", "function_description": "Toggles the word-wrapping behavior of a text widget based on the current setting, allowing dynamic adjustment of how text lines are displayed within the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_expand", "line_number": 1585, "body": "def _on_expand(self):\n        index = self.shell_text.index(self.button)\n        self.shell_text.direct_delete(index, index + \" +1 chars\")\n        self.shell_text.direct_insert(index, self.content, tuple(self.button.tags))\n        self.destroy()\n\n        # looks like the widgets are not fully GC-d.\n        # At least avoid leaking big chunks of texts\n        self.button.contained_text = None\n        self.button.destroy()", "is_method": true, "class_name": "SqueezedTextDialog", "function_description": "Private method in SqueezedTextDialog that replaces a button with its full text content in the UI and cleans up related resources to prevent memory leaks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_copy", "line_number": 1596, "body": "def _on_copy(self):\n        self.clipboard_clear()\n        self.clipboard_append(self.content)", "is_method": true, "class_name": "SqueezedTextDialog", "function_description": "Private method in SqueezedTextDialog that clears the clipboard and copies the current content to it, enabling efficient text copying functionality within the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_close", "line_number": 1600, "body": "def _on_close(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "SqueezedTextDialog", "function_description": "Private method in SqueezedTextDialog that closes and destroys the dialog window, typically called in response to a close event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "create_close_button", "line_number": 1669, "body": "def create_close_button(self):\n        self.close_img = get_workbench().get_image(\"tab-close\")\n        self.close_active_img = get_workbench().get_image(\"tab-close-active\")\n\n        self.close_rect = self.create_rectangle(\n            self.winfo_width() - self.close_img.width() - self.linespace,\n            self.linespace / 2,\n            self.winfo_width(),\n            self.linespace / 2 + self.close_img.height(),\n            fill=self.background,\n            width=0,\n            tags=(\"close\",),\n        )\n\n        self.close_button = self.create_image(\n            self.winfo_width() - self.linespace / 2,\n            self.linespace / 2,\n            anchor=\"ne\",\n            image=self.close_img,\n            activeimage=self.close_active_img,\n            tags=(\"close\",),\n        )\n\n        self.tag_bind(\"close\", \"<1>\", self.on_close)", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Creates an interactive close button on the PlotterCanvas, displaying images for normal and active states and binding click events to trigger the close action. This enables users to visually close or dismiss the canvas element."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_close_button", "line_number": 1694, "body": "def update_close_button(self):\n        self.coords(\n            self.close_rect,\n            self.winfo_width() - self.close_img.width() - self.linespace / 1.5,\n            self.linespace / 2,\n            self.winfo_width() - self.linespace / 2,\n            self.linespace / 2 + self.close_img.height(),\n        )\n        self.coords(self.close_button, self.winfo_width() - self.linespace / 2, self.linespace / 2)", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Updates the position of the close button and its clickable area based on the current canvas size, ensuring it remains correctly aligned and accessible within the PlotterCanvas interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "on_close", "line_number": 1704, "body": "def on_close(self, event):\n        self.master.toggle_plotter()", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Handles the close event by toggling the plotter's visibility or state in the master interface, enabling coordinated UI behavior upon closing the canvas."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "reset_range", "line_number": 1707, "body": "def reset_range(self, event=None):\n        self.fresh_range = True", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Resets the plotting range state to indicate that the range should be refreshed. This allows other functions to recognize when to update or recalculate plot boundaries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "get_num_steps", "line_number": 1710, "body": "def get_num_steps(self):\n        return 30", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Constant-return method in PlotterCanvas that provides the fixed number of steps used for plotting or animation sequences."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_plot", "line_number": 1713, "body": "def update_plot(self, force_clean=False):\n        data_lines = []\n        bottom_index = self.text.index(\n            \"@%d,%d\" % (self.text.winfo_width(), self.text.winfo_height())\n        )\n        bottom_lineno = int(float(bottom_index))\n\n        for i in range(bottom_lineno - self.get_num_steps(), bottom_lineno + 1):\n            line_start_index = \"%d.0\" % i\n            if i < 1 or \"stdout\" not in self.text.tag_names(line_start_index):\n                data_lines.append(([], []))\n            else:\n                content = self.text.get(line_start_index, line_start_index + \" lineend\")\n                data_lines.append(self.extract_pattern_and_numbers(content))\n\n        # data_lines need to be transposed\n        segments_by_color = []\n        for i in range(100):\n            segments = list(self.extract_series_segments(data_lines, i))\n            if segments:\n                segments_by_color.append(segments)\n            else:\n                break\n\n        self.delete(\"segment\")\n\n        self.update_range(segments_by_color, force_clean)\n        segment_count = self.draw_segments(segments_by_color)\n        self.update_legend(data_lines, force_clean)\n\n        self.delete(\"info\")\n        if segment_count == 0:\n            info_text = (\n                tr(\"Plotter visualizes series of\\n\" + \"numbers printed to the Shell.\")\n                + \"\\n\\n\"\n                + tr(\"See Help for details.\")\n            )\n\n            self.create_text_with_background(\n                self.winfo_width() / 2,\n                self.winfo_height() / 2,\n                text=info_text,\n                anchor=\"center\",\n                justify=\"center\",\n                tags=(\"info\",),\n            )\n            # self.delete(\"guide\", \"tick\", \"legend\")\n            # self.range_start = 0\n            # self.range_end = 0\n            self.tag_raise(\"info\")\n\n        self.fresh_range = False", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Updates the plot by extracting, processing, and visualizing numeric data lines from the associated text widget, refreshing the display and legend to reflect current data or showing guidance when no data is present."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_legend", "line_number": 1766, "body": "def update_legend(self, data_lines, force_clean=False):\n        legend = None\n        i = len(data_lines) - 2  # one before last\n        while i >= 0:\n            legend = data_lines[i][0]\n            if legend and legend == data_lines[i + 1][0]:\n                # found last legend, which covers at least 2 consecutive points\n                break\n            i -= 1\n\n        if self.last_legend == legend and not force_clean:\n            # just make sure it remains topmost\n            self.tag_raise(\"legend\")\n            return\n\n        self.delete(\"legend\")\n\n        if legend is None:\n            return\n\n        # add horizontal padding\n        # legend[0] = \" \" + legend[0]\n        # legend[-1] = legend[-1] + \" \"\n\n        marker = \"\u25cf\"  # \"\u25cf\" \"\u2022\"\n        marker_width = self.font.measure(marker)\n        full_text_width = self.font.measure(marker.join(legend))\n\n        y = self.winfo_height() - self.linespace // 2\n        x = self.winfo_width() - full_text_width - self.linespace\n\n        self.create_rectangle(\n            x - self.linespace // 4,\n            y - self.linespace,\n            x + full_text_width + self.linespace // 4,\n            y,\n            fill=self.background,\n            width=0,\n            tags=(\"legend\",),\n        )\n\n        for i, part in enumerate(legend):\n            if i > 0:\n                self.create_text(\n                    x,\n                    y,\n                    text=marker,\n                    anchor=\"sw\",\n                    fill=self.colors[(i - 1) % len(self.colors)],\n                    tags=(\"legend\",),\n                )\n                x += marker_width\n\n            self.create_text(x, y, text=part, anchor=\"sw\", tags=(\"legend\",), fill=self.foreground)\n            x += self.font.measure(part)\n\n        self.last_legend = legend", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Updates or redraws the plot legend based on the most recent consecutive data line labels, managing visibility and styling to reflect current plot data. It ensures the legend remains accurate and visually accessible during dynamic plot updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "draw_segments", "line_number": 1824, "body": "def draw_segments(self, segments_by_color):\n        count = 0\n        for color, segments in enumerate(segments_by_color):\n            for pos, nums in segments:\n                self.draw_segment(color, pos, nums)\n                count += 1\n\n        # raise certain elements above segments\n        self.tag_raise(\"tick\")\n        self.tag_raise(\"close\")\n        return count", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Draws multiple colored line segments on the canvas and raises specified elements above these segments. Returns the total number of segments drawn, facilitating layered graphical rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "draw_segment", "line_number": 1836, "body": "def draw_segment(self, color, pos, nums):\n\n        x = self.x_padding_left + pos * self.x_scale\n\n        args = []\n        for num in nums:\n            y = self.y_padding + (self.range_end - num) * self.y_scale\n            args.extend([x, y])\n            x += self.x_scale\n\n        self.create_line(\n            *args,\n            width=2,\n            fill=self.colors[color % len(self.colors)],\n            tags=(\"segment\",),\n            # arrow may be confusing\n            # and doesn't play nice with distinguising between\n            # scrollback view and fresh_range view\n            # arrow=\"last\",\n            # arrowshape=(3,5,3)\n        )", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Draws a colored polyline segment on the canvas based on given numeric values and position, scaling coordinates to fit the plotting area. Useful for visualizing sequences or trends within a graphical plot."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_range", "line_number": 1859, "body": "def update_range(self, segments_by_color, clean):\n        if not segments_by_color:\n            return\n\n        range_start = 2 ** 15\n        range_end = -(2 ** 15)\n\n        # if new block is using 3/4 of the width,\n        # then don't consider old block's values anymore\n        interest_position = 0\n        for start_pos, nums in reversed(segments_by_color[0]):\n            if start_pos < self.get_num_steps() / 10:\n                interest_position = start_pos\n                break\n\n        assert isinstance(interest_position, int)\n        for segments in segments_by_color:\n            for start_pos, nums in segments:\n                if start_pos >= interest_position:\n                    range_start = min(range_start, *nums)\n                    range_end = max(range_end, *nums)\n\n        if interest_position == 0 and not self.fresh_range:\n            # meaning we still care about old line's values\n            range_start = min(range_start, self.range_start)\n            range_end = max(range_end, self.range_end)\n\n        if range_end == range_start:\n            range_end += 1\n\n        if (\n            not clean\n            and not self.fresh_range\n            and self.x_scale is not None\n            and range_end == self.range_end\n            and range_start == self.range_start\n        ):\n            # don't recompute as nothing was changed\n            return\n\n        value_range = range_end - range_start\n        range_block_size = value_range // 4\n        # prefer round blocks\n        for size in self.range_block_sizes:\n            if size * 4 >= value_range:\n                range_block_size = size\n                break\n\n        # extend to range block boundary\n        if range_end % range_block_size != 0:\n            range_end -= range_end % -range_block_size\n\n        if range_start % range_block_size != 0:\n            range_start -= range_start % range_block_size\n\n        # not sure about these assertions when using floats\n        # assert range_start % range_block_size == 0\n        # assert range_end % range_block_size == 0, \"range_end: %s, bs: %s\" % (range_end, range_block_size)\n\n        # remember\n        self.range_start = range_start\n        self.range_end = range_end\n        self.value_range = range_end - range_start\n        self.range_block_size = range_block_size\n\n        available_height = self.winfo_height() - 2 * self.y_padding\n        available_width = self.winfo_width() - self.x_padding_left - self.x_padding_right\n        num_steps = self.get_num_steps()\n\n        self.x_scale = available_width / (num_steps - 1)\n        self.y_scale = available_height / self.value_range\n\n        self.update_guides_and_ticks()", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Core method of PlotterCanvas that recalculates and updates the vertical value range and scaling factors based on recent data segments to ensure accurate plotting bounds and axis guides for graph rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_guides_and_ticks", "line_number": 1933, "body": "def update_guides_and_ticks(self):\n        self.delete(\"guide\", \"tick\")\n        value = self.range_start\n        while value <= self.range_end:\n            y = self.y_padding + (self.range_end - value) * self.y_scale\n\n            # guide\n            self.create_line(\n                0, y, self.winfo_width(), y, tags=(\"guide\",), dash=(2, 2), fill=\"#aaaaaa\"\n            )\n\n            # tick\n            if value == int(value):\n                value = int(value)\n\n            caption = \" \" + str(value) + \" \"\n            self.create_text_with_background(\n                self.linespace // 2, y, caption, anchor=\"w\", tags=(\"tick\",)\n            )\n            value += self.range_block_size", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Updates and redraws horizontal guide lines and corresponding tick labels on the canvas based on the current value range, providing visual reference markers for plotted data in PlotterCanvas."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "extract_pattern_and_numbers", "line_number": 1954, "body": "def extract_pattern_and_numbers(self, line):\n        parts = NUMBER_SPLIT_REGEX.split(line)\n        if len(parts) < 2:\n            return ([], [])\n\n        assert len(parts) % 2 == 1\n\n        pattern = []\n        numbers = []\n        for i in range(0, len(parts), 2):\n            pattern.append(parts[i])\n\n        for i in range(1, len(parts), 2):\n            numbers.append(float(parts[i]))\n\n        return (pattern, numbers)", "is_method": true, "class_name": "PlotterCanvas", "function_description": "This method extracts alternating text patterns and numeric values from a given string line, returning them separately as lists. It supports parsing mixed-format lines where numbers and text segments interleave."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "extract_series_segments", "line_number": 1971, "body": "def extract_series_segments(self, data_lines, series_nr):\n        \"\"\"Yields numbers which form connected multilines on graph\n        Each segment is pair of starting position and numbers\"\"\"\n        segment = (0, [])\n        prev_pattern = None\n        for i, (pattern, nums) in enumerate(data_lines):\n            if len(nums) <= series_nr or pattern != prev_pattern:\n                # break the segment\n                if len(segment[1]) > 1:\n                    yield segment\n                segment = (i, [])\n\n            if len(nums) > series_nr:\n                segment[1].append(nums[series_nr])\n\n            prev_pattern = pattern\n\n        if len(segment[1]) > 1:\n            yield segment", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Core method of PlotterCanvas that identifies and yields continuous segments of data points from a specified series across multiple patterned lines, enabling analysis or rendering of connected multiline graph components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "create_text_with_background", "line_number": 1991, "body": "def create_text_with_background(\n        self, x, y, text, anchor=\"w\", justify=\"left\", background=None, tags=()\n    ):\n        if background is None:\n            background = self.background\n\n        width = 0\n        lines = text.splitlines()\n        for line in lines:\n            width = max(width, self.font.measure(line))\n\n        height = len(lines) * self.linespace\n\n        rect_x = x\n        rect_y = y\n        if anchor == \"center\":\n            rect_x = x - width / 2\n            rect_y = y - height / 2\n        elif anchor == \"w\":\n            rect_y = y - height / 2\n        else:\n            \"TODO:\"\n\n        self.create_rectangle(\n            rect_x, rect_y, rect_x + width, rect_y + height, fill=background, width=0, tags=tags\n        )\n        self.create_text(\n            x, y, anchor=anchor, text=text, tags=tags, fill=self.foreground, justify=justify\n        )", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Creates a text label on the canvas with a customizable background rectangle for improved readability and visual distinction. It supports positioning and text alignment to enhance display flexibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "reload_theme_options", "line_number": 2021, "body": "def reload_theme_options(self, event):\n        self.background = get_syntax_options_for_tag(\"TEXT\")[\"background\"]\n        self.foreground = get_syntax_options_for_tag(\"TEXT\")[\"foreground\"]\n        self.configure(background=self.background)\n        self.itemconfig(self.close_rect, fill=self.background)\n        self.update_plot(True)", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Updates the canvas's color scheme based on current syntax theme settings and refreshes the plot display accordingly. This enables dynamic adaptation of the canvas appearance to theme changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "on_resize", "line_number": 2028, "body": "def on_resize(self, event):\n        if self.winfo_width() > 10:\n            get_workbench().set_option(\"view.plotter_width\", self.winfo_width())\n        self.update_plot(True)\n        self.update_close_button()\n        self.master.resize_plotter()", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Handles the canvas resizing event by updating stored width settings, refreshing the plot display, adjusting the close button, and notifying the container to resize accordingly. It ensures the plotting interface adapts dynamically to size changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "can_toggle", "line_number": 143, "body": "def can_toggle():\n            return self.winfo_ismapped()", "is_method": true, "class_name": "ShellView", "function_description": "Returns whether the ShellView component is currently displayed, indicating if it can be toggled visible or hidden."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "toggle_from_menu", "line_number": 283, "body": "def toggle_from_menu():\n            # I don't like that Tk menu toggles checbutton variable\n            # automatically before calling the handler.\n            # So I revert the toggle before calling the actual handler.\n            # This way the handler doesn't have to worry whether it\n            # needs to toggle the variable or not, and it can choose to\n            # decline the toggle.\n            self.view.plotter_visibility_var.set(not self.view.plotter_visibility_var.get())\n            self.view.toggle_plotter()", "is_method": true, "class_name": "ShellMenu", "function_description": "Core method of the ShellMenu class that manages the toggling behavior of a menu checkbutton and triggers visibility changes for a plotter view, ensuring consistent control over UI state updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_insert", "line_number": 986, "body": "def _insert(txt, tags):\n            if txt != \"\":\n                self.direct_insert(\"output_insert\", txt, tags)", "is_method": true, "class_name": "BaseShellText", "function_description": "Private helper method in BaseShellText that inserts non-empty text with given tags into the output stream."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "handle_frame_click", "line_number": 1392, "body": "def handle_frame_click(event, frame_id=frame_id):\n                    get_runner().send_command(InlineCommand(\"get_frame_info\", frame_id=frame_id))\n                    return \"break\"", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles a click event on a UI frame by sending a command to retrieve information about the specified frame, preventing further event propagation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "escape", "line_number": 476, "body": "def escape(s):\n    return (\n        s.replace(\"\\\\\", \"\\\\\\\\\")\n        .replace(\"*\", \"\\\\*\")\n        .replace(\"`\", \"\\\\`\")\n        .replace(\"_\", \"\\\\_\")\n        .replace(\"..\", \"\\\\..\")\n    )", "is_method": false, "function_description": "Function that escapes special characters in a string to prevent interpretation as markdown or control symbols, useful for safely displaying text with markdown syntax."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "create_title", "line_number": 486, "body": "def create_title(text, line_symbol=\"=\"):\n    text = text.replace(\"\\r\\n\", \"\\n\").replace(\"\\n\", \" \").strip()\n    return text + \"\\n\" + line_symbol * len(text) + \"\\n\"", "is_method": false, "function_description": "Returns a formatted title string by underlining the given text with a repeated line symbol, useful for creating visually distinct headings in console or text outputs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "configure_tags", "line_number": 28, "body": "def configure_tags(self):\n        main_font = tk.font.nametofont(\"TkDefaultFont\")\n\n        bold_font = main_font.copy()\n        bold_font.configure(weight=\"bold\", size=main_font.cget(\"size\"))\n\n        italic_font = main_font.copy()\n        italic_font.configure(slant=\"italic\", size=main_font.cget(\"size\"))\n\n        h1_font = main_font.copy()\n        h1_font.configure(size=main_font.cget(\"size\") * 2, weight=\"bold\")\n\n        h2_font = main_font.copy()\n        h2_font.configure(size=round(main_font.cget(\"size\") * 1.5), weight=\"bold\")\n\n        h3_font = main_font.copy()\n        h3_font.configure(size=main_font.cget(\"size\"), weight=\"bold\")\n\n        small_font = main_font.copy()\n        small_font.configure(size=round(main_font.cget(\"size\") * 0.8))\n        small_italic_font = italic_font.copy()\n        small_italic_font.configure(size=round(main_font.cget(\"size\") * 0.8))\n\n        # Underline on font looks better than underline on tag\n        underline_font = main_font.copy()\n        underline_font.configure(underline=True)\n\n        self.tag_configure(\"h1\", font=h1_font, spacing3=5)\n        self.tag_configure(\"h2\", font=h2_font, spacing3=5)\n        self.tag_configure(\"h3\", font=h3_font, spacing3=5)\n        self.tag_configure(\"p\", spacing1=0, spacing3=10, spacing2=0)\n        self.tag_configure(\"line_block\", spacing1=0, spacing3=10, spacing2=0)\n        self.tag_configure(\"em\", font=italic_font)\n        self.tag_configure(\"strong\", font=bold_font)\n\n        # TODO: hyperlink syntax options may require different background as well\n        hyperlink_opts = get_syntax_options_for_tag(\"hyperlink\")\n        hyperlink_opts[\"underline\"] = False\n        hyperlink_opts[\"font\"] = underline_font\n        self.tag_configure(\"a\", **hyperlink_opts)\n\n        self.tag_configure(\"small\", font=small_font)\n        self.tag_configure(\"light\", foreground=\"gray\")\n        self.tag_configure(\"remark\", font=small_italic_font)\n        self.tag_bind(\"a\", \"<Enter>\", self._hyperlink_enter)\n        self.tag_bind(\"a\", \"<Leave>\", self._hyperlink_leave)\n\n        self.tag_configure(\"topic_title\", lmargin2=16, font=bold_font)\n        self.tag_configure(\"topic_body\", lmargin1=16, lmargin2=16)\n        self.tag_configure(\n            \"code\",\n            font=\"TkFixedFont\",\n            # wrap=\"none\", # TODO: needs automatic hor-scrollbar and better padding mgmt\n            # background=\"#eeeeee\"\n        )\n        # if ui_utils.get_tk_version_info() >= (8,6,6):\n        #    self.tag_configure(\"code\", lmargincolor=self[\"background\"])\n\n        for i in range(1, 6):\n            self.tag_configure(\"list%d\" % i, lmargin1=i * 10, lmargin2=i * 10 + 10)\n\n        toti_code_font = bold_font.copy()\n        toti_code_font.configure(\n            family=tk.font.nametofont(\"TkFixedFont\").cget(\"family\"), size=bold_font.cget(\"size\")\n        )\n        self.tag_configure(\"topic_title_code\", font=toti_code_font)\n        self.tag_raise(\"topic_title_code\", \"code\")\n        self.tag_raise(\"topic_title_code\", \"topic_title\")\n        self.tag_raise(\"a\", \"topic_title\")\n\n        # TODO: topic_title + em\n        self.tag_raise(\"em\", \"topic_title\")\n        self.tag_raise(\"a\", \"em\")\n        self.tag_raise(\"a\", \"topic_body\")\n        self.tag_raise(\"a\", \"topic_title\")\n\n        if ui_utils.get_tk_version_info() >= (8, 6, 6):\n            self.tag_configure(\"sel\", lmargincolor=self[\"background\"])\n        self.tag_raise(\"sel\")", "is_method": true, "class_name": "RstText", "function_description": "Sets up text formatting and style tags for a rich-text widget, defining fonts, colors, and spacing for headings, emphasis, links, lists, and code blocks to enable styled text rendering and interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "clear", "line_number": 108, "body": "def clear(self):\n        self.direct_delete(\"1.0\", \"end\")", "is_method": true, "class_name": "RstText", "function_description": "Clears all the text content within the RstText object, effectively resetting it to an empty state. This method is useful for clearing the editor or text area completely."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "load_rst", "line_number": 111, "body": "def load_rst(self, rst_source, global_tags=()):\n        self.clear()\n        self.append_rst(rst_source, global_tags)", "is_method": true, "class_name": "RstText", "function_description": "Utility method of the RstText class that loads reStructuredText content from a source, clears existing content, and appends the new text with optional global tags for processing or rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "append_rst", "line_number": 115, "body": "def append_rst(self, rst_source, global_tags=()):\n        try:\n            import docutils.core\n\n            doc = docutils.core.publish_doctree(rst_source)\n            doc.walkabout(self.create_visitor(doc, global_tags))\n        except Exception:\n            self.direct_insert(\"end\", \"RST SOURCE:\\n\" + rst_source + \"\\n\\n\")\n            self.direct_insert(\"end\", traceback.format_exc())", "is_method": true, "class_name": "RstText", "function_description": "Appends reStructuredText content by parsing and processing it with custom visitors, falling back to inserting raw source and error info if parsing fails; useful for integrating and displaying RST data robustly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "create_visitor", "line_number": 129, "body": "def create_visitor(self, doc, global_tags=()):\n        # Pass unique tag count from previous visitor\n        # to keep uniqueness\n\n        if self._visitor is None:\n            unique_tag_count = 0\n        else:\n            unique_tag_count = self._visitor.unique_tag_count\n\n        import docutils.nodes\n\n        class TkTextRenderingVisitor(docutils.nodes.GenericNodeVisitor):\n            def __init__(self, document, text, global_tags=(), unique_tag_count=0):\n                super().__init__(document)\n\n                self._context_tags = list(global_tags)\n                self.text = text\n                self.section_level = 0\n                self.in_topic = False\n                self.in_paragraph = False\n                self.in_title = False\n\n                self.active_lists = []\n\n                self.unique_tag_count = unique_tag_count\n\n            def visit_document(self, node):\n                pass\n\n            def visit_Text(self, node):\n                self._append_text(self._node_to_text(node))\n\n            def visit_section(self, node):\n                self.section_level += 1\n\n            def depart_section(self, node):\n                self.section_level -= 1\n\n            def _get_title_tag(self):\n                if self.in_topic:\n                    return \"topic_title\"\n                else:\n                    return \"h%d\" % (self.section_level + 1)\n\n            def visit_title(self, node):\n                self.in_title = True\n                self._add_tag(self._get_title_tag())\n\n            def depart_title(self, node):\n                self.in_title = False\n                self._append_text(\"\\n\")\n                self._pop_tag(self._get_title_tag())\n\n            def visit_paragraph(self, node):\n                self.in_paragraph = True\n                if not self.active_lists:\n                    self._add_tag(\"p\")\n\n            def depart_paragraph(self, node):\n                self.in_paragraph = False\n                self._append_text(\"\\n\")\n                if not self.active_lists:\n                    self._pop_tag(\"p\")\n\n            def visit_line_block(self, node):\n                self._add_tag(\"line_block\")\n\n            def depart_line_block(self, node):\n                self._pop_tag(\"line_block\")\n\n            def visit_line(self, node):\n                pass\n\n            def depart_line(self, node):\n                self._append_text(\"\\n\")\n\n            def visit_topic(self, node):\n                self.in_topic = True\n\n                if \"toggle\" in node.attributes[\"classes\"]:\n                    return self._visit_toggle_topic(node)\n                elif \"empty\" in node.attributes[\"classes\"]:\n                    return self._visit_empty_topic(node)\n                else:\n                    return self.default_visit(node)\n\n            def _visit_toggle_topic(self, node):\n                tag = self._create_unique_tag()\n                title_id_tag = tag + \"_title\"\n                body_id_tag = tag + \"_body\"\n\n                def get_toggler_image_name(kind):\n                    if get_workbench().uses_dark_ui_theme():\n                        return kind + \"_light\"\n                    else:\n                        return kind\n\n                if \"open\" in node.attributes[\"classes\"]:\n                    initial_image = get_toggler_image_name(\"boxminus\")\n                    initial_elide = False\n                else:\n                    initial_image = get_toggler_image_name(\"boxplus\")\n                    initial_elide = True\n\n                label = tk.Label(\n                    self.text,\n                    image=get_workbench().get_image(initial_image),\n                    borderwidth=0,\n                    background=self.text[\"background\"],\n                    cursor=\"arrow\",\n                )\n\n                def toggle_body(event=None):\n                    elide = self.text.tag_cget(body_id_tag, \"elide\")\n                    if elide == \"1\":\n                        elide = True\n                    elif elide == \"0\":\n                        elide = False\n                    else:\n                        elide = bool(elide)\n\n                    elide = not elide\n\n                    self.text.tag_configure(body_id_tag, elide=elide)\n                    if self.text.has_selection():\n                        self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n\n                    if elide:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxplus\"))\n                        )\n                    else:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxminus\"))\n                        )\n\n                assert isinstance(node.children[0], docutils.nodes.title)\n\n                # self.text.tag_bind(title_id_tag, \"<1>\", toggle_body, True)\n                self._add_tag(title_id_tag)\n                self._append_window(label)\n                label.bind(\"<1>\", toggle_body, True)\n                node.children[0].walkabout(self)\n                self._pop_tag(title_id_tag)\n\n                self.text.tag_configure(body_id_tag, elide=initial_elide)\n                self._add_tag(body_id_tag)\n                self._add_tag(\"topic_body\")\n                for child in list(node.children)[1:]:\n                    child.walkabout(self)\n                self._pop_tag(\"topic_body\")\n                self._pop_tag(body_id_tag)\n\n                if \"tight\" not in node.attributes[\"classes\"]:\n                    self._append_text(\"\\n\")\n\n                raise docutils.nodes.SkipNode()\n\n            def _visit_empty_topic(self, node):\n                img = get_workbench().get_image(\n                    \"boxdot_light\" if get_workbench().uses_dark_ui_theme() else \"boxdot\"\n                )\n                label = tk.Label(\n                    self.text,\n                    image=img,\n                    borderwidth=0,\n                    background=self.text[\"background\"],\n                    cursor=\"arrow\",\n                )\n                self._append_window(label)\n                assert isinstance(node.children[0], docutils.nodes.title)\n                node.children[0].walkabout(self)\n\n                if \"tight\" not in node.attributes[\"classes\"]:\n                    self._append_text(\"\\n\")\n\n                raise docutils.nodes.SkipNode()\n\n            def depart_topic(self, node):\n                # only for non-toggle topics\n                self.in_topic = False\n                self._append_text(\"\\n\")\n\n            def visit_image(self, node):\n                self._append_image(node.attributes[\"uri\"])\n                if not self.in_paragraph and not self.in_title:\n                    self._append_text(\"\\n\")\n\n            def visit_reference(self, node):\n                tag = self._create_unique_tag()\n                node.unique_tag = tag\n                self._add_tag(\"a\")\n                self._add_tag(tag)\n\n                def handle_click(event):\n                    get_workbench().open_url(node.attributes[\"refuri\"])\n\n                self.text.tag_bind(tag, \"<ButtonRelease-1>\", handle_click)\n\n            def depart_reference(self, node):\n                self._pop_tag(\"a\")\n                self._pop_tag(node.unique_tag)\n\n            def visit_literal(self, node):\n                self._add_tag(\"code\")\n\n            def depart_literal(self, node):\n                self._pop_tag(\"code\")\n\n            def visit_inline(self, node):\n                for cls in node.attributes[\"classes\"]:\n                    self._add_tag(cls)\n\n            def depart_inline(self, node):\n                for cls in node.attributes[\"classes\"]:\n                    self._pop_tag(cls)\n\n            def visit_literal_block(self, node):\n                self._add_tag(\"code\")\n\n            def depart_literal_block(self, node):\n                self._pop_tag(\"code\")\n                self._append_text(\"\\n\\n\")\n\n            def visit_bullet_list(self, node):\n                self.active_lists.append(node.attributes[\"bullet\"])\n\n            def depart_bullet_list(self, node):\n                self._append_text(\"\\n\")\n                self.active_lists.pop()\n\n            def visit_enumerated_list(self, node):\n                self.active_lists.append(node.attributes[\"enumtype\"])\n\n            def depart_enumerated_list(self, node):\n                self._append_text(\"\\n\")\n                self.active_lists.pop()\n\n            def visit_list_item(self, node):\n                if self.active_lists[-1] == \"*\":\n                    self._append_text(\"\u2022 \")\n                elif self.active_lists[-1] == \"arabic\":\n                    for i, sib in enumerate(node.parent.children):\n                        if sib is node:\n                            self._append_text(\"%d. \" % (i + 1))\n                            break\n\n            def visit_note(self, node):\n                self._add_tag(\"em\")\n\n            def depart_note(self, node):\n                self._pop_tag(\"em\")\n\n            def visit_target(self, node):\n                pass\n\n            def visit_substitution_definition(self, node):\n                raise docutils.nodes.SkipNode()\n\n            def visit_system_message(self, node):\n                logger.warning(\"docutils message: '%s'. Context: %s\" % (node.astext(), node.parent))\n                raise docutils.nodes.SkipNode\n\n            def visit_emphasis(self, node):\n                self._add_tag(\"em\")\n\n            def depart_emphasis(self, node):\n                self._pop_tag(\"em\")\n\n            def visit_strong(self, node):\n                self._add_tag(\"strong\")\n\n            def depart_strong(self, node):\n                self._pop_tag(\"strong\")\n\n            def visit_block_quote(self, node):\n                self._add_tag(\"code\")\n\n            def depart_block_quote(self, node):\n                self._pop_tag(\"code\")\n\n            def default_visit(self, node):\n                self._append_text(self._node_to_text(node))\n                print(\"skipping children\", type(node), node)\n                raise docutils.nodes.SkipChildren()\n\n            def default_departure(self, node):\n                # Pass all other nodes through.\n                pass\n\n            def _create_unique_tag(self):\n                self.unique_tag_count += 1\n                return \"_UT_%s\" % self.unique_tag_count\n\n            def _node_to_text(self, node):\n                if node.parent.attributes.get(\"xml:space\") == \"preserve\":\n                    return node.astext()\n                else:\n                    return node.astext().replace(\"\\r\", \"\").replace(\"\\n\", \" \")\n\n            def _add_tag(self, tag):\n                self._context_tags.append(tag)\n\n            def _pop_tag(self, tag):\n                self._context_tags.remove(tag)\n\n            def _append_text(self, chars, extra_tags=()):\n                # print(\"APPP\", chars, tags)\n                self.text.direct_insert(\"end\", chars, self._get_effective_tags(extra_tags))\n\n            def _append_image(self, name, extra_tags=()):\n                index = self.text.index(\"end-1c\")\n                self.text.image_create(index, image=get_workbench().get_image(name))\n                for tag in self._get_effective_tags(extra_tags):\n                    self.text.tag_add(tag, index)\n\n            def _append_window(self, window, extra_tags=()):\n                index = self.text.index(\"end-1c\")\n                self.text.window_create(index, window=window)\n                for tag in self._get_effective_tags(extra_tags):\n                    self.text.tag_add(tag, index)\n\n            def _get_effective_tags(self, extra_tags):\n                tags = set(extra_tags) | set(self._context_tags)\n\n                if self.active_lists:\n                    tags.add(\"list%d\" % min(len(self.active_lists), 5))\n\n                # combine tags\n                if \"code\" in tags and \"topic_title\" in tags:\n                    tags.remove(\"code\")\n                    tags.remove(\"topic_title\")\n                    tags.add(\"topic_title_code\")\n\n                return tuple(sorted(tags))\n\n        self._visitor = TkTextRenderingVisitor(doc, self, global_tags, unique_tag_count)\n\n        return self._visitor", "is_method": true, "class_name": "RstText", "function_description": "Creates and returns a specialized visitor object that traverses and converts a document tree into a formatted Tkinter text widget representation, supporting tags, images, and interactive elements for rich text display within the RstText context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_hyperlink_enter", "line_number": 469, "body": "def _hyperlink_enter(self, event):\n        self.config(cursor=\"hand2\")", "is_method": true, "class_name": "RstText", "function_description": "Changes the cursor to a hand icon when hovering over a hyperlink, indicating it is clickable. This method enhances user interaction within the RstText interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_hyperlink_leave", "line_number": 472, "body": "def _hyperlink_leave(self, event):\n        self.config(cursor=\"\")", "is_method": true, "class_name": "RstText", "function_description": "Utility method in RstText class that resets the mouse cursor to default when the pointer leaves a hyperlink area, improving user interface behavior in text widgets."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_Text", "line_number": 158, "body": "def visit_Text(self, node):\n                self._append_text(self._node_to_text(node))", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Core method of TkTextRenderingVisitor that processes a text node by converting it to text and appending it for rendering or further handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_section", "line_number": 161, "body": "def visit_section(self, node):\n                self.section_level += 1", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Increments the current section level during traversal to track nesting depth in text rendering. This supports structured processing of text sections within the TkTextRenderingVisitor context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_section", "line_number": 164, "body": "def depart_section(self, node):\n                self.section_level -= 1", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Method of TkTextRenderingVisitor that decreases the current section nesting level, managing hierarchical structure during text rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_get_title_tag", "line_number": 167, "body": "def _get_title_tag(self):\n                if self.in_topic:\n                    return \"topic_title\"\n                else:\n                    return \"h%d\" % (self.section_level + 1)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Returns the appropriate title tag based on the current context, distinguishing between topic titles and section headers. Useful for rendering text with correct hierarchical formatting in TkTextRenderingVisitor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_title", "line_number": 173, "body": "def visit_title(self, node):\n                self.in_title = True\n                self._add_tag(self._get_title_tag())", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Marks the start of processing a title node and applies the appropriate title tag for text rendering purposes within TkTextRenderingVisitor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_title", "line_number": 177, "body": "def depart_title(self, node):\n                self.in_title = False\n                self._append_text(\"\\n\")\n                self._pop_tag(self._get_title_tag())", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles the closing process of a title element during text rendering, marking title end and updating formatting state accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_paragraph", "line_number": 182, "body": "def visit_paragraph(self, node):\n                self.in_paragraph = True\n                if not self.active_lists:\n                    self._add_tag(\"p\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles the start of a paragraph node by marking paragraph context and adding a paragraph tag when not inside a list, supporting structured text rendering in the TkTextRenderingVisitor class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_paragraph", "line_number": 187, "body": "def depart_paragraph(self, node):\n                self.in_paragraph = False\n                self._append_text(\"\\n\")\n                if not self.active_lists:\n                    self._pop_tag(\"p\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Method in TkTextRenderingVisitor that finalizes paragraph processing by marking its end and managing associated text formatting and tag closure, ensuring proper rendering structure in the text output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_line_block", "line_number": 193, "body": "def visit_line_block(self, node):\n                self._add_tag(\"line_block\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Adds a \"line_block\" tag when visiting a line block node during text rendering. It supports tagging elements for further processing or styling in the TkTextRenderingVisitor context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_line_block", "line_number": 196, "body": "def depart_line_block(self, node):\n                self._pop_tag(\"line_block\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Method in TkTextRenderingVisitor that handles the closing actions when finishing processing a block of lines during text rendering. It primarily manages internal tag state related to line blocks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_line", "line_number": 202, "body": "def depart_line(self, node):\n                self._append_text(\"\\n\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "In the context of TkTextRenderingVisitor, this method adds a newline character to the text output, marking the end of a line during text rendering. It supports formatting by managing line breaks within the rendered text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_topic", "line_number": 205, "body": "def visit_topic(self, node):\n                self.in_topic = True\n\n                if \"toggle\" in node.attributes[\"classes\"]:\n                    return self._visit_toggle_topic(node)\n                elif \"empty\" in node.attributes[\"classes\"]:\n                    return self._visit_empty_topic(node)\n                else:\n                    return self.default_visit(node)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles a topic node during traversal by selecting an appropriate rendering method based on its class attributes, supporting toggleable, empty, or default topic types for Tkinter text rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_visit_toggle_topic", "line_number": 215, "body": "def _visit_toggle_topic(self, node):\n                tag = self._create_unique_tag()\n                title_id_tag = tag + \"_title\"\n                body_id_tag = tag + \"_body\"\n\n                def get_toggler_image_name(kind):\n                    if get_workbench().uses_dark_ui_theme():\n                        return kind + \"_light\"\n                    else:\n                        return kind\n\n                if \"open\" in node.attributes[\"classes\"]:\n                    initial_image = get_toggler_image_name(\"boxminus\")\n                    initial_elide = False\n                else:\n                    initial_image = get_toggler_image_name(\"boxplus\")\n                    initial_elide = True\n\n                label = tk.Label(\n                    self.text,\n                    image=get_workbench().get_image(initial_image),\n                    borderwidth=0,\n                    background=self.text[\"background\"],\n                    cursor=\"arrow\",\n                )\n\n                def toggle_body(event=None):\n                    elide = self.text.tag_cget(body_id_tag, \"elide\")\n                    if elide == \"1\":\n                        elide = True\n                    elif elide == \"0\":\n                        elide = False\n                    else:\n                        elide = bool(elide)\n\n                    elide = not elide\n\n                    self.text.tag_configure(body_id_tag, elide=elide)\n                    if self.text.has_selection():\n                        self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n\n                    if elide:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxplus\"))\n                        )\n                    else:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxminus\"))\n                        )\n\n                assert isinstance(node.children[0], docutils.nodes.title)\n\n                # self.text.tag_bind(title_id_tag, \"<1>\", toggle_body, True)\n                self._add_tag(title_id_tag)\n                self._append_window(label)\n                label.bind(\"<1>\", toggle_body, True)\n                node.children[0].walkabout(self)\n                self._pop_tag(title_id_tag)\n\n                self.text.tag_configure(body_id_tag, elide=initial_elide)\n                self._add_tag(body_id_tag)\n                self._add_tag(\"topic_body\")\n                for child in list(node.children)[1:]:\n                    child.walkabout(self)\n                self._pop_tag(\"topic_body\")\n                self._pop_tag(body_id_tag)\n\n                if \"tight\" not in node.attributes[\"classes\"]:\n                    self._append_text(\"\\n\")\n\n                raise docutils.nodes.SkipNode()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Provides interactive toggle controls for collapsible topics in a Tkinter text widget, enabling expanding or collapsing of content sections with dynamic icons reflecting their state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_visit_empty_topic", "line_number": 287, "body": "def _visit_empty_topic(self, node):\n                img = get_workbench().get_image(\n                    \"boxdot_light\" if get_workbench().uses_dark_ui_theme() else \"boxdot\"\n                )\n                label = tk.Label(\n                    self.text,\n                    image=img,\n                    borderwidth=0,\n                    background=self.text[\"background\"],\n                    cursor=\"arrow\",\n                )\n                self._append_window(label)\n                assert isinstance(node.children[0], docutils.nodes.title)\n                node.children[0].walkabout(self)\n\n                if \"tight\" not in node.attributes[\"classes\"]:\n                    self._append_text(\"\\n\")\n\n                raise docutils.nodes.SkipNode()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Concise utility method that renders an empty topic in a Tkinter text widget by inserting a themed icon and processing its title, supporting document display with UI theme awareness."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_topic", "line_number": 307, "body": "def depart_topic(self, node):\n                # only for non-toggle topics\n                self.in_topic = False\n                self._append_text(\"\\n\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Method in TkTextRenderingVisitor that marks exiting a non-toggle topic node and appends a newline to the rendered text output. It manages text flow when processing topic elements in document rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_image", "line_number": 312, "body": "def visit_image(self, node):\n                self._append_image(node.attributes[\"uri\"])\n                if not self.in_paragraph and not self.in_title:\n                    self._append_text(\"\\n\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Method of TkTextRenderingVisitor that processes image nodes by appending image references to the output and conditionally adds a newline outside paragraphs or titles for proper formatting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_reference", "line_number": 317, "body": "def visit_reference(self, node):\n                tag = self._create_unique_tag()\n                node.unique_tag = tag\n                self._add_tag(\"a\")\n                self._add_tag(tag)\n\n                def handle_click(event):\n                    get_workbench().open_url(node.attributes[\"refuri\"])\n\n                self.text.tag_bind(tag, \"<ButtonRelease-1>\", handle_click)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Method of TkTextRenderingVisitor that assigns a unique clickable tag to a reference node, enabling it to open the linked URL when clicked within a Tkinter text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_reference", "line_number": 328, "body": "def depart_reference(self, node):\n                self._pop_tag(\"a\")\n                self._pop_tag(node.unique_tag)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles the closing of reference elements during text rendering by removing associated tags from the rendering stack. This supports proper management of hyperlink or reference structures in rendered text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_literal", "line_number": 332, "body": "def visit_literal(self, node):\n                self._add_tag(\"code\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Adds a \"code\" tag when visiting a literal node to apply specific text rendering styles. This supports syntax highlighting or formatting in the TkTextRenderingVisitor class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_literal", "line_number": 335, "body": "def depart_literal(self, node):\n                self._pop_tag(\"code\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Ends processing of a literal (code) node by removing its associated formatting tag during text rendering. It supports correctly closing code segments in rich text outputs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_inline", "line_number": 338, "body": "def visit_inline(self, node):\n                for cls in node.attributes[\"classes\"]:\n                    self._add_tag(cls)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles inline nodes by applying all class-based tags to the text content, supporting styled text rendering in a Tkinter text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_inline", "line_number": 342, "body": "def depart_inline(self, node):\n                for cls in node.attributes[\"classes\"]:\n                    self._pop_tag(cls)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Terminates inline nodes by removing their corresponding formatting tags, supporting the text rendering process in TkTextRenderingVisitor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_literal_block", "line_number": 346, "body": "def visit_literal_block(self, node):\n                self._add_tag(\"code\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Marks a literal code block node with a \"code\" tag during text rendering, facilitating proper formatting and styling of code sections in the TkTextRenderingVisitor context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_literal_block", "line_number": 349, "body": "def depart_literal_block(self, node):\n                self._pop_tag(\"code\")\n                self._append_text(\"\\n\\n\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Method in TkTextRenderingVisitor that finalizes processing of a literal block by closing the code tag and adding spacing for formatting in rendered text output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_bullet_list", "line_number": 353, "body": "def visit_bullet_list(self, node):\n                self.active_lists.append(node.attributes[\"bullet\"])", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Adds a bullet style from the current bullet list node to the active list stack, supporting hierarchical bullet list rendering in the TkTextRenderingVisitor class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_bullet_list", "line_number": 356, "body": "def depart_bullet_list(self, node):\n                self._append_text(\"\\n\")\n                self.active_lists.pop()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles the completion of a bullet list in text rendering by appending a newline and updating the active lists stack. This supports proper formatting and tracking of nested bullet lists during rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_enumerated_list", "line_number": 360, "body": "def visit_enumerated_list(self, node):\n                self.active_lists.append(node.attributes[\"enumtype\"])", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Adds the enumeration type of a list node to the current active lists, supporting structured text rendering with enumeration tracking."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_enumerated_list", "line_number": 363, "body": "def depart_enumerated_list(self, node):\n                self._append_text(\"\\n\")\n                self.active_lists.pop()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Terminates an enumerated list in the text rendering process by appending a newline and updating the internal list tracking state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_list_item", "line_number": 367, "body": "def visit_list_item(self, node):\n                if self.active_lists[-1] == \"*\":\n                    self._append_text(\"\u2022 \")\n                elif self.active_lists[-1] == \"arabic\":\n                    for i, sib in enumerate(node.parent.children):\n                        if sib is node:\n                            self._append_text(\"%d. \" % (i + 1))\n                            break", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Method of TkTextRenderingVisitor that formats list items by inserting appropriate bullet points for unordered lists or numeric prefixes for ordered (Arabic) lists during text rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_note", "line_number": 376, "body": "def visit_note(self, node):\n                self._add_tag(\"em\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Core utility method of the TkTextRenderingVisitor class that processes a \"note\" node by applying emphasis styling, enabling formatted text rendering within a Tkinter text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_note", "line_number": 379, "body": "def depart_note(self, node):\n                self._pop_tag(\"em\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Ends the emphasis formatting for a note element during text rendering by removing the corresponding tag from the processing stack."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_substitution_definition", "line_number": 385, "body": "def visit_substitution_definition(self, node):\n                raise docutils.nodes.SkipNode()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Raises an exception to skip processing of substitution definition nodes during text rendering, effectively ignoring these nodes in the rendering workflow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_system_message", "line_number": 388, "body": "def visit_system_message(self, node):\n                logger.warning(\"docutils message: '%s'. Context: %s\" % (node.astext(), node.parent))\n                raise docutils.nodes.SkipNode", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles system messages during rendering by logging a warning and skipping the current node, ensuring such messages don't disrupt the rendering flow in TkTextRenderingVisitor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_emphasis", "line_number": 392, "body": "def visit_emphasis(self, node):\n                self._add_tag(\"em\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Adds an emphasis tag to the current text segment during rendering. It supports marking text for emphasis within the TkTextRenderingVisitor's processing flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_emphasis", "line_number": 395, "body": "def depart_emphasis(self, node):\n                self._pop_tag(\"em\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Ends the emphasis text formatting by removing the emphasis tag during text rendering in the TkTextRenderingVisitor class. It helps manage text styling transitions in rendered documents."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_strong", "line_number": 398, "body": "def visit_strong(self, node):\n                self._add_tag(\"strong\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Adds a formatting tag to represent strong emphasis in text rendering. This method supports rich text processing by marking segments that should be displayed with strong (bold) styling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_strong", "line_number": 401, "body": "def depart_strong(self, node):\n                self._pop_tag(\"strong\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Utility method in TkTextRenderingVisitor that finalizes processing of a strong (bold) text node by closing its formatting tag during text rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_block_quote", "line_number": 404, "body": "def visit_block_quote(self, node):\n                self._add_tag(\"code\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Adds a \"code\" tag when visiting a block quote node during text rendering. This method customizes block quote formatting in the TkTextRenderingVisitor class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_block_quote", "line_number": 407, "body": "def depart_block_quote(self, node):\n                self._pop_tag(\"code\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles the closing process of a block quote element during text rendering by removing the associated 'code' tag from the tag stack. It supports proper tag management in the rendering workflow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "default_visit", "line_number": 410, "body": "def default_visit(self, node):\n                self._append_text(self._node_to_text(node))\n                print(\"skipping children\", type(node), node)\n                raise docutils.nodes.SkipChildren()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles a node by converting it to text and appending it, then skips processing its children. Provides a default visit behavior for unhandled node types during text rendering in document processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_create_unique_tag", "line_number": 419, "body": "def _create_unique_tag(self):\n                self.unique_tag_count += 1\n                return \"_UT_%s\" % self.unique_tag_count", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Generates a unique tag string by incrementing an internal counter, providing distinct identifiers for text rendering elements within the TkTextRenderingVisitor class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_node_to_text", "line_number": 423, "body": "def _node_to_text(self, node):\n                if node.parent.attributes.get(\"xml:space\") == \"preserve\":\n                    return node.astext()\n                else:\n                    return node.astext().replace(\"\\r\", \"\").replace(\"\\n\", \" \")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Private helper method in TkTextRenderingVisitor that converts a node to plain text, preserving whitespace if specified, otherwise normalizing line breaks. It supports consistent text extraction respecting XML spacing rules."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_add_tag", "line_number": 429, "body": "def _add_tag(self, tag):\n                self._context_tags.append(tag)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Adds a formatting tag to the current rendering context, enabling management of text styles during rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_pop_tag", "line_number": 432, "body": "def _pop_tag(self, tag):\n                self._context_tags.remove(tag)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Removes a specified tag from the current context tag stack, managing the active text formatting or rendering state during processing in the TkTextRenderingVisitor class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_append_text", "line_number": 435, "body": "def _append_text(self, chars, extra_tags=()):\n                # print(\"APPP\", chars, tags)\n                self.text.direct_insert(\"end\", chars, self._get_effective_tags(extra_tags))", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Internal method of TkTextRenderingVisitor that inserts text with specified formatting tags into a text widget, supporting customized text rendering within the widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_append_image", "line_number": 439, "body": "def _append_image(self, name, extra_tags=()):\n                index = self.text.index(\"end-1c\")\n                self.text.image_create(index, image=get_workbench().get_image(name))\n                for tag in self._get_effective_tags(extra_tags):\n                    self.text.tag_add(tag, index)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Internal helper of TkTextRenderingVisitor that inserts an image at the end of the text widget and applies specified formatting tags to it. It supports enhancing text content with embedded images and styling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_append_window", "line_number": 445, "body": "def _append_window(self, window, extra_tags=()):\n                index = self.text.index(\"end-1c\")\n                self.text.window_create(index, window=window)\n                for tag in self._get_effective_tags(extra_tags):\n                    self.text.tag_add(tag, index)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Private method of TkTextRenderingVisitor that inserts a window widget at the end of a Tkinter Text widget and applies relevant styling tags, supporting enhanced text rendering with embedded GUI elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_get_effective_tags", "line_number": 451, "body": "def _get_effective_tags(self, extra_tags):\n                tags = set(extra_tags) | set(self._context_tags)\n\n                if self.active_lists:\n                    tags.add(\"list%d\" % min(len(self.active_lists), 5))\n\n                # combine tags\n                if \"code\" in tags and \"topic_title\" in tags:\n                    tags.remove(\"code\")\n                    tags.remove(\"topic_title\")\n                    tags.add(\"topic_title_code\")\n\n                return tuple(sorted(tags))", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Determines the combined set of active text tags by merging context and extra tags, adjusting for list nesting and special tag combinations. It provides effective tagging information for text rendering in TkTextRenderingVisitor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "get_toggler_image_name", "line_number": 220, "body": "def get_toggler_image_name(kind):\n                    if get_workbench().uses_dark_ui_theme():\n                        return kind + \"_light\"\n                    else:\n                        return kind", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Utility method of the TkTextRenderingVisitor class that returns the appropriate toggler image name based on the current UI theme, supporting theme-consistent interface rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "toggle_body", "line_number": 241, "body": "def toggle_body(event=None):\n                    elide = self.text.tag_cget(body_id_tag, \"elide\")\n                    if elide == \"1\":\n                        elide = True\n                    elif elide == \"0\":\n                        elide = False\n                    else:\n                        elide = bool(elide)\n\n                    elide = not elide\n\n                    self.text.tag_configure(body_id_tag, elide=elide)\n                    if self.text.has_selection():\n                        self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n\n                    if elide:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxplus\"))\n                        )\n                    else:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxminus\"))\n                        )", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Method of TkTextRenderingVisitor that toggles the visibility of a specific text section, updating its concealment state and associated UI indicator accordingly. Useful for expanding or collapsing text content interactively."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "handle_click", "line_number": 323, "body": "def handle_click(event):\n                    get_workbench().open_url(node.attributes[\"refuri\"])", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles click events by opening a URL specified in the node's attributes using the workbench interface. This enables interactive navigation from rendered text elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/export.py", "function": "add_export_page", "line_number": 51, "body": "def add_export_page(title, page_class):\n    page_specs.append((title, page_class))", "is_method": false, "function_description": "Adds a new page entry by storing its title and class in a collection for later use. This function supports dynamic registration of page components in an application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/export.py", "function": "on_ok", "line_number": 38, "body": "def on_ok(self):\n        print(\"OK\")", "is_method": true, "class_name": "ExportDialog", "function_description": "Simple event handler in ExportDialog that responds to an OK action by printing \"OK\"; likely a placeholder or basic confirmation step for dialog interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/export.py", "function": "on_cancel", "line_number": 41, "body": "def on_cancel(self):\n        print(\"Cancel\")\n        self.destroy()", "is_method": true, "class_name": "ExportDialog", "function_description": "Handles the cancellation action in ExportDialog by logging the event and closing the dialog, allowing users to exit the export process gracefully."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_update_highlighting", "line_number": 179, "body": "def _update_highlighting(event, text_changed, need_update, delay=None):\n    text = event.widget\n    if not hasattr(text, \"paren_matcher\"):\n        if isinstance(text, CodeViewText):\n            text.paren_matcher = ParenMatcher(text)\n        elif isinstance(text, ShellText):\n            text.paren_matcher = ShellParenMatcher(text)\n        else:\n            return\n\n    if text_changed:\n        text.paren_matcher.invalidate_token_cache()\n\n    if need_update:\n        text.paren_matcher.schedule_update(delay)", "is_method": false, "function_description": "Internal helper function that manages and schedules updates for syntax highlighting, specifically parenthesis matching, based on text changes and update requirements in text-editing widgets."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "update_highlighting_full", "line_number": 196, "body": "def update_highlighting_full(event):\n    _update_highlighting(event, True, True)", "is_method": false, "function_description": "Calls an internal update function to fully refresh highlighting based on an event. Provides a simple interface to trigger complete highlight updates in response to user actions or state changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "clear_highlighting", "line_number": 200, "body": "def clear_highlighting(text):\n    text.tag_remove(\"surrounding_parens\", \"0.1\", \"end\")\n    text.tag_remove(\"unclosed_expression\", \"0.1\", \"end\")", "is_method": false, "function_description": "Utility function that removes specific highlight tags from a text widget, clearing visual markers related to parentheses and unclosed expressions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "update_highlighting_move", "line_number": 208, "body": "def update_highlighting_move(event):\n    global _last_move_time\n    # needs delay because selecting with mouse causes many events\n    # and I don't know how to distinguish selection from other moves\n    t = time.time()\n    if t - _last_move_time > 0.1:\n        delay = None\n    else:\n        delay = 300\n    _last_move_time = t\n    _update_highlighting(event, False, True, delay=delay)", "is_method": false, "function_description": "This function manages delayed updating of highlighting in response to user move events, preventing redundant or excessive updates during rapid interactions like mouse selections. It optimizes UI responsiveness by controlling when the highlight refresh occurs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "update_highlighting_edit_cw", "line_number": 221, "body": "def update_highlighting_edit_cw(event):\n    if isinstance(event.text_widget, CodeViewText):\n        event.widget = event.text_widget\n        trivial = event.get(\"trivial_for_parens\", False)\n        _update_highlighting(event, True, not trivial)\n        if trivial:\n            event.text_widget.tag_remove(\"surrounding_parens\", \"0.1\", \"end\")", "is_method": false, "function_description": "Utility function that updates syntax highlighting in a CodeViewText widget during editing, optionally handling trivial changes to parentheses highlighting for improved code readability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "load_plugin", "line_number": 230, "body": "def load_plugin() -> None:\n    wb = get_workbench()\n\n    wb.set_default(\"view.paren_highlighting\", True)\n    wb.bind(\"TextInsert\", update_highlighting_edit_cw, True)\n    wb.bind(\"TextDelete\", update_highlighting_edit_cw, True)\n    wb.bind_class(\"CodeViewText\", \"<<VerticalScroll>>\", update_highlighting_move, True)\n    wb.bind_class(\"CodeViewText\", \"<<CursorMove>>\", update_highlighting_move, True)\n    wb.bind_class(\"ShellText\", \"<<TextChange>>\", update_highlighting_full, True)\n    wb.bind_class(\"ShellText\", \"<<CursorMove>>\", update_highlighting_full, True)\n    wb.bind(\"<<UpdateAppearance>>\", update_highlighting_full, True)", "is_method": false, "function_description": "Enables and configures parenthesis highlighting in the workbench by setting default preferences and binding relevant text and cursor events to update highlighting dynamically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "schedule_update", "line_number": 33, "body": "def schedule_update(self, delay=None):\n        if self._update_scheduling_id is not None:\n            self.text.after_cancel(self._update_scheduling_id)\n\n        if delay is not None:\n            self._update_scheduling_id = self.text.after(delay, self.perform_update)\n        else:\n            self._update_scheduling_id = self.text.after_idle(self.perform_update)", "is_method": true, "class_name": "ParenMatcher", "function_description": "Schedules or reschedules a future update action in the ParenMatcher, optionally after a specified delay, ensuring only one pending update is queued at a time. This supports efficient asynchronous processing within a text widget context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "perform_update", "line_number": 42, "body": "def perform_update(self):\n        try:\n            self.update_highlighting()\n        finally:\n            self._update_scheduled = False", "is_method": true, "class_name": "ParenMatcher", "function_description": "Service method of ParenMatcher that ensures syntax highlighting is updated and resets the update scheduling flag. It supports reliable visual feedback during code editing by managing highlight refresh cycles."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "invalidate_token_cache", "line_number": 48, "body": "def invalidate_token_cache(self):\n        self._tokens_cache = {}", "is_method": true, "class_name": "ParenMatcher", "function_description": "Clears the cached tokens stored within the ParenMatcher instance, ensuring fresh tokenization on subsequent operations. This is useful for resetting internal state after changes to the input or parsing context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "update_highlighting", "line_number": 51, "body": "def update_highlighting(self):\n        clear_highlighting(self.text)\n\n        if get_workbench().get_option(\"view.paren_highlighting\") and self.text.is_python_text():\n            self._update_highlighting_for_active_range()", "is_method": true, "class_name": "ParenMatcher", "function_description": "Updates the parenthesis highlighting in the text editor if the feature is enabled and the text is Python code, ensuring visual cues reflect the current code context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_update_highlighting_for_active_range", "line_number": 57, "body": "def _update_highlighting_for_active_range(self):\n        start_index = \"1.0\"\n        end_index = self.text.index(\"end\")\n\n        # Try to reduce search range for better performance.\n        index = self._find_block_start(\"@0,0 linestart\", True)\n        if index:\n            start_index = index\n\n        lower_right = \"@%d,%d\" % (self.text.winfo_width(), self.text.winfo_height())\n        index = self._find_block_start(lower_right + \" lineend\", False)\n        if index:\n            end_index = index\n\n        self._highlight(start_index, end_index)", "is_method": true, "class_name": "ParenMatcher", "function_description": "Updates the text highlighting in the currently visible text range to reflect active parentheses matching, optimizing the search range for efficient rendering within the ParenMatcher context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_find_block_start", "line_number": 73, "body": "def _find_block_start(self, start_position, backwards):\n        while True:\n            index = self.text.search(\n                BLOCK_START_REGEX_STR,\n                start_position,\n                regexp=True,\n                backwards=backwards,\n                stopindex=\"1.0\" if backwards else \"end\",\n            )\n            if not index:\n                break\n\n            tags = self.text.tag_names(index)\n            if \"string3\" in tags or \"open_string3\" in tags:\n                # not a block start\n                if backwards:\n                    start_position = index\n                else:\n                    start_position = index + \" +1c\"\n            else:\n                break\n\n        return index", "is_method": true, "class_name": "ParenMatcher", "function_description": "Utility method in ParenMatcher that locates the starting position of a code block in text, skipping positions inside string literals, supporting both forward and backward search directions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_highlight", "line_number": 97, "body": "def _highlight(self, start_index, end_index):\n        stack = []\n\n        cursor_row, cursor_col = map(int, self.text.index(\"insert\").split(\".\"))\n\n        for t in self._get_paren_tokens(start_index, end_index):\n            if t.string in \"([{\":\n                stack.append(t)\n            elif not stack:\n                # stack is empty, ie. found a closer without opener\n                close_index = \"%d.%d\" % (t.start[0], t.end[1])\n                self.text.tag_add(\"unclosed_expression\", start_index, close_index)\n                break\n            elif stack[-1].string != _OPENERS[t.string]:\n                # incorrect closure\n                opener = stack[-1]\n                open_index = \"%d.%d\" % opener.start\n                self.text.tag_add(\"unclosed_expression\", open_index, end_index)\n                break\n            else:\n                # found a pair\n                opener = stack[-1]\n                closer = t\n\n                # if cursor is right after opener or closer then highlight both\n                if (\n                    cursor_row == opener.start[0]\n                    and cursor_col == opener.end[1]\n                    or cursor_row == closer.start[0]\n                    and cursor_col == closer.end[1]\n                ):\n                    self.text.tag_add(\"surrounding_parens\", \"%d.%d\" % closer.start)\n                    self.text.tag_add(\"surrounding_parens\", \"%d.%d\" % opener.start)\n\n                stack.pop()\n\n        if stack:\n            # something was left without closure\n            opener = stack[-1]\n            open_index = \"%d.%d\" % opener.start\n            self.text.tag_add(\"unclosed_expression\", open_index, end_index)", "is_method": true, "class_name": "ParenMatcher", "function_description": "Highlights matching or unmatched parentheses within a specified text range, marking pairs around the cursor and flagging any unclosed expressions for user awareness in a text editing context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_get_paren_tokens", "line_number": 139, "body": "def _get_paren_tokens(self, start_index, end_index):\n        import tokenize\n\n        if (start_index, end_index) in self._tokens_cache:\n            return self._tokens_cache[(start_index, end_index)]\n\n        start_row, start_col = map(int, start_index.split(\".\"))\n        source = self.text.get(start_index, end_index)\n        # prepend source with empty lines and spaces to make\n        # token rows and columns match with widget indices\n        source = (\"\\n\" * (start_row - 1)) + (\" \" * start_col) + source\n\n        result = []\n        try:\n            tokens = tokenize.tokenize(io.BytesIO(source.encode(\"utf-8\")).readline)\n            for token in tokens:\n                # if token.string != \"\" and token.string in \"()[]{}\":\n                if token.exact_type in TOKTYPES:\n                    result.append(token)\n        except Exception:\n            # happens eg when parens are unbalanced or there is indentation error or ...\n            pass\n\n        if start_index == \"1.0\" and end_index == \"end\":\n            self._tokens_cache[(start_index, end_index)] = result\n\n        return result", "is_method": true, "class_name": "ParenMatcher", "function_description": "Extracts and caches all parentheses-related tokens from a specified text range, enabling efficient identification of matching parentheses within that segment for use in syntax or structural analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_update_highlighting_for_active_range", "line_number": 169, "body": "def _update_highlighting_for_active_range(self):\n\n        # TODO: check that cursor is in this range\n        index_parts = self.text.tag_prevrange(\"command\", \"end\")\n\n        if index_parts:\n            start_index, end_index = index_parts\n            self._highlight(start_index, end_index)", "is_method": true, "class_name": "ShellParenMatcher", "function_description": "Updates the syntax highlighting by applying it to the most recent command range in the text, ensuring the active shell command is visually distinguished."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_get_phrase_for_object", "line_number": 680, "body": "def _get_phrase_for_object(type_name, with_article=True):\n    friendly_names = {\n        \"str\": \"a string\",\n        \"int\": \"an integer\",\n        \"float\": \"a float\",\n        \"list\": \"a list\",\n        \"tuple\": \"a tuple\",\n        \"dict\": \"a dictionary\",\n        \"set\": \"a set\",\n        \"bool\": \"a boolean\",\n    }\n    result = friendly_names.get(type_name, \"an object of type '%s'\" % type_name)\n\n    if with_article:\n        return result\n    else:\n        _, rest = result.split(\" \", maxsplit=1)\n        return rest", "is_method": false, "function_description": "Utility function that returns a human-readable phrase describing a Python data type, optionally including an article. It aids in generating clear type-related messages or documentation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_get_sample_for_type", "line_number": 700, "body": "def _get_sample_for_type(type_name):\n    if type_name == \"int\":\n        return \"42\"\n    elif type_name == \"float\":\n        return \"3.14\"\n    elif type_name == \"str\":\n        return \"'abc'\"\n    elif type_name == \"bytes\":\n        return \"b'abc'\"\n    elif type_name == \"list\":\n        return \"[1, 2, 3]\"\n    elif type_name == \"tuple\":\n        return \"(1, 2, 3)\"\n    elif type_name == \"set\":\n        return \"{1, 2, 3}\"\n    elif type_name == \"dict\":\n        return \"{1 : 'one', 2 : 'two'}\"\n    else:\n        return \"...\"", "is_method": false, "function_description": "Provides example literal representations for common Python data types, useful for generating sample values in documentation or test scenarios."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "load_plugin", "line_number": 721, "body": "def load_plugin():\n    for name in globals():\n        if name.endswith(\"ErrorHelper\") and not name.startswith(\"_\"):\n            type_name = name[: -len(\"Helper\")]\n            add_error_helper(type_name, globals()[name])", "is_method": false, "function_description": "Scans global names for error helper classes and registers them by type, enabling dynamic integration of error handling helpers into the system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_missing_or_misplaced_colon", "line_number": 74, "body": "def _sug_missing_or_misplaced_colon(self):\n        import tokenize\n\n        i = 0\n        title = \"Did you forget the colon?\"\n        relevance = 0\n        body = \"\"\n        while i < len(self.tokens) and self.tokens[i].type != token.ENDMARKER:\n            t = self.tokens[i]\n            if t.string in [\n                \"if\",\n                \"elif\",\n                \"else\",\n                \"while\",\n                \"for\",\n                \"with\",\n                \"try\",\n                \"except\",\n                \"finally\",\n                \"class\",\n                \"def\",\n            ]:\n                keyword_pos = i\n                while (\n                    self.tokens[i].type\n                    not in [\n                        token.NEWLINE,\n                        token.ENDMARKER,\n                        token.COLON,  # colon may be OP\n                        token.RBRACE,\n                    ]\n                    and self.tokens[i].string != \":\"\n                ):\n\n                    old_i = i\n                    if self.tokens[i].string in \"([{\":\n                        i = self._skip_braced_part(i)\n                        assert i > old_i\n                        if i == len(self.tokens):\n                            return None\n                    else:\n                        i += 1\n\n                if self.tokens[i].string != \":\":\n                    relevance = 9\n                    body = \"`%s` header must end with a colon.\" % t.string\n                    break\n\n                # Colon was present, but maybe it should have been right\n                # after the keyword.\n                if (\n                    t.string in [\"else\", \"try\", \"finally\"]\n                    and self.tokens[keyword_pos + 1].string != \":\"\n                ):\n                    title = \"Incorrect use of `%s`\" % t.string\n                    body = \"Nothing is allowed between `%s` and colon.\" % t.string\n                    relevance = 9\n                    if (\n                        self.tokens[keyword_pos + 1].type not in (token.NEWLINE, tokenize.COMMENT)\n                        and t.string == \"else\"\n                    ):\n                        body = \"If you want to specify a condition, then use `elif` or nested `if`.\"\n                    break\n\n            i += 1\n\n        return Suggestion(\"missing-or-misplaced-colon\", title, body, relevance)", "is_method": true, "class_name": "SyntaxErrorHelper", "function_description": "Method of SyntaxErrorHelper that analyzes code tokens to detect missing or incorrectly placed colons in control or definition statements, providing specific suggestions to help fix common syntax errors related to colons."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_unbalanced_parens", "line_number": 142, "body": "def _sug_unbalanced_parens(self):\n        problem = self._find_first_braces_problem()\n        if not problem:\n            return None\n\n        return Suggestion(\"missing-or-misplaced-colon\", \"Unbalanced brackets\", problem[1], 8)", "is_method": true, "class_name": "SyntaxErrorHelper", "function_description": "Private helper method in SyntaxErrorHelper that identifies unbalanced brackets and returns a suggestion to fix missing or misplaced colons related to that issue."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_skip_braced_part", "line_number": 161, "body": "def _skip_braced_part(self, token_index):\n        assert self.tokens[token_index].string in [\"(\", \"[\", \"{\"]\n        level = 1\n        token_index += 1\n        while token_index < len(self.tokens):\n\n            if self.tokens[token_index].string in [\"(\", \"[\", \"{\"]:\n                level += 1\n            elif self.tokens[token_index].string in [\")\", \"]\", \"}\"]:\n                level -= 1\n\n            token_index += 1\n\n            if level <= 0:\n                return token_index\n\n        assert token_index == len(self.tokens)\n        return token_index", "is_method": true, "class_name": "SyntaxErrorHelper", "function_description": "Private helper method that advances the token index past a balanced braced expression, useful for parsing or analyzing nested structures in code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_find_first_braces_problem", "line_number": 180, "body": "def _find_first_braces_problem(self):\n        # closers = {'(':')', '{':'}', '[':']'}\n        openers = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        brace_stack = []\n        for t in self.tokens:\n            if t.string in [\"(\", \"[\", \"{\"]:\n                brace_stack.append(t)\n            elif t.string in [\")\", \"]\", \"}\"]:\n                if not brace_stack:\n                    return (\n                        t,\n                        \"Found '`%s`' at `line %d <%s>`_ without preceding matching '`%s`'\"\n                        % (\n                            t.string,\n                            t.start[0],\n                            assistance.format_file_url(\n                                self.error_info[\"filename\"], t.start[0], t.start[1]\n                            ),\n                            openers[t.string],\n                        ),\n                    )\n                elif brace_stack[-1].string != openers[t.string]:\n                    return (\n                        t,\n                        \"Found '`%s`' at `line %d <%s>`__ when last unmatched opener was '`%s`' at `line %d <%s>`__\"\n                        % (\n                            t.string,\n                            t.start[0],\n                            assistance.format_file_url(\n                                self.error_info[\"filename\"], t.start[0], t.start[1]\n                            ),\n                            brace_stack[-1].string,\n                            brace_stack[-1].start[0],\n                            assistance.format_file_url(\n                                self.error_info[\"filename\"],\n                                brace_stack[-1].start[0],\n                                brace_stack[-1].start[1],\n                            ),\n                        ),\n                    )\n                else:\n                    brace_stack.pop()\n\n        if brace_stack:\n            return (\n                brace_stack[-1],\n                \"'`%s`' at `line %d <%s>`_ is not closed by the end of the program\"\n                % (\n                    brace_stack[-1].string,\n                    brace_stack[-1].start[0],\n                    assistance.format_file_url(\n                        self.error_info[\"filename\"],\n                        brace_stack[-1].start[0],\n                        brace_stack[-1].start[1],\n                    ),\n                ),\n            )\n\n        return None", "is_method": true, "class_name": "SyntaxErrorHelper", "function_description": "Identifies the first unmatched or incorrectly paired brace in a tokenized Python source, providing detailed error location and context to aid in syntax error diagnosis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_missing_quotes", "line_number": 259, "body": "def _sug_missing_quotes(self):\n        if self._is_attribute_value() or self._is_call_function() or self._is_subscript_value():\n            relevance = 0\n        else:\n            relevance = 5\n\n        return Suggestion(\n            \"missing-quotes\",\n            \"Did you actually mean string (text)?\",\n            'If you didn\\'t mean a variable but literal text \"%s\", then surround it with quotes.'\n            % self.name,\n            relevance,\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Helper method in NameErrorHelper that generates a suggestion indicating a missing string literal, advising to surround text with quotes when a variable was likely intended as a string."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_bad_spelling", "line_number": 273, "body": "def _sug_bad_spelling(self):\n\n        # Yes, it would be more proper to consult builtins from the backend,\n        # but it's easier this way...\n        all_names = {name for name in dir(builtins) if not name.startswith(\"_\")}\n        all_names |= {\"pass\", \"break\", \"continue\", \"return\", \"yield\"}\n\n        if self.last_frame.globals is not None:\n            all_names |= set(self.last_frame.globals.keys())\n        if self.last_frame.locals is not None:\n            all_names |= set(self.last_frame.locals.keys())\n\n        similar_names = {self.name}\n        if all_names:\n            relevance = 0\n            for name in all_names:\n                sim = name_similarity(name, self.name)\n                if sim > 4:\n                    similar_names.add(name)\n                relevance = max(sim, relevance)\n        else:\n            relevance = 3\n\n        if len(similar_names) > 1:\n            body = \"I found similar names. Are all of them spelled correctly?\\n\\n\"\n            for name in sorted(similar_names, key=lambda x: x.lower()):\n                # TODO: add location info\n                body += \"* `%s`\\n\\n\" % name\n        else:\n            body = (\n                \"Compare the name with corresponding definition / assignment / documentation.\"\n                + \" Don't forget that case of the letters matters!\"\n            )\n\n        return Suggestion(\"bad-spelling-name\", \"Did you misspell it (somewhere)?\", body, relevance)", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Generates suggestions for potential misspellings by comparing a given name to built-in names and visible variables in the current scope, helping identify similar names that might be intended."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_missing_import", "line_number": 309, "body": "def _sug_missing_import(self):\n        likely_importable_functions = {\n            \"math\": {\"ceil\", \"floor\", \"sqrt\", \"sin\", \"cos\", \"degrees\"},\n            \"random\": {\"randint\"},\n            \"turtle\": {\n                \"left\",\n                \"right\",\n                \"forward\",\n                \"fd\",\n                \"goto\",\n                \"setpos\",\n                \"Turtle\",\n                \"penup\",\n                \"up\",\n                \"pendown\",\n                \"down\",\n                \"color\",\n                \"pencolor\",\n                \"fillcolor\",\n                \"begin_fill\",\n                \"end_fill\",\n                \"pensize\",\n                \"width\",\n            },\n            \"re\": {\"search\", \"match\", \"findall\"},\n            \"datetime\": {\"date\", \"time\", \"datetime\", \"today\"},\n            \"statistics\": {\n                \"mean\",\n                \"median\",\n                \"median_low\",\n                \"median_high\",\n                \"mode\",\n                \"pstdev\",\n                \"pvariance\",\n                \"stdev\",\n                \"variance\",\n            },\n            \"os\": {\"listdir\"},\n            \"time\": {\"time\", \"sleep\"},\n        }\n\n        body = None\n\n        if self._is_call_function():\n            relevance = 5\n            for mod in likely_importable_functions:\n                if self.name in likely_importable_functions[mod]:\n                    relevance += 3\n                    body = (\n                        \"If you meant `%s` from module `%s`, then add\\n\\n`from %s import %s`\\n\\nto the beginning of your script.\"\n                        % (self.name, mod, mod, self.name)\n                    )\n                    break\n\n        elif self._is_attribute_value():\n            relevance = 5\n            body = (\n                \"If you meant module `%s`, then add `import %s` to the beginning of your script\"\n                % (self.name, self.name)\n            )\n\n            if self.name in likely_importable_functions:\n                relevance += 3\n\n        elif self._is_subscript_value() and self.name != \"argv\":\n            relevance = 0\n        elif self.name == \"pi\":\n            body = \"If you meant the constant \u03c0, then add `from math import pi` to the beginning of your script.\"\n            relevance = 8\n        elif self.name == \"argv\":\n            body = \"If you meant the list with program arguments, then add `from sys import argv` to the beginning of your script.\"\n            relevance = 8\n        else:\n            relevance = 3\n\n        if body is None:\n            body = \"Some functions/variables need to be imported before they can be used.\"\n\n        return Suggestion(\"missing-import\", \"Did you forget to import it?\", body, relevance)", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Helper method in NameErrorHelper that suggests appropriate import statements for missing functions or modules based on common Python libraries, aiding users in resolving undefined name errors due to missing imports."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_local_from_global", "line_number": 389, "body": "def _sug_local_from_global(self):\n        import ast\n\n        relevance = 0\n        body = None\n\n        if self.last_frame.code_name == \"<module>\" and self.last_frame_module_ast is not None:\n            function_names = set()\n            for node in ast.walk(self.last_frame_module_ast):\n                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                    if self.name in map(lambda x: x.arg, node.args.args):\n                        function_names.add(node.name)\n                    # TODO: varargs, kw, ...\n                    declared_global = False\n                    for localnode in ast.walk(node):\n                        # print(node.name, localnode)\n                        if (\n                            isinstance(localnode, ast.Name)\n                            and localnode.id == self.name\n                            and isinstance(localnode.ctx, ast.Store)\n                        ):\n                            function_names.add(node.name)\n                        elif isinstance(localnode, ast.Global) and self.name in localnode.names:\n                            declared_global = True\n\n                    if node.name in function_names and declared_global:\n                        function_names.remove(node.name)\n\n            if function_names:\n                relevance = 9\n                body = (\n                    (\n                        \"Name `%s` defined in `%s` is not accessible in the global/module level.\"\n                        % (self.name, \" and \".join(function_names))\n                    )\n                    + \"\\n\\nIf you need that data at the global level, then consider changing the function so that it `return`-s the value.\"\n                )\n\n        return Suggestion(\n            \"local-from-global\",\n            \"Are you trying to access a local variable outside of the function?\",\n            body,\n            relevance,\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Method of NameErrorHelper that analyzes if a variable name is defined locally inside a function but mistakenly accessed at the global/module level, providing a relevant suggestion to correct scope misuse in code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_not_defined_yet", "line_number": 434, "body": "def _sug_not_defined_yet(self):\n        return Suggestion(\n            \"not-defined-yet\",\n            \"Has Python executed the definition?\",\n            (\n                \"Don't forget that name becomes defined when corresponding definition ('=', 'def' or 'import') gets executed.\"\n                + \" If the definition comes later in code or is inside an if-statement, Python may not have executed it (yet).\"\n                + \"\\n\\n\"\n                + \"Make sure Python arrives to the definition before it arrives to this line. When in doubt, \"\n                + \"`use the debugger <debuggers.rst>`_.\"\n            ),\n            2,\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Service method in NameErrorHelper that generates a suggestion explaining that a Python name error may occur because the name's definition has not been executed yet, aiding debugging of undefined names."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_is_call_function", "line_number": 454, "body": "def _is_call_function(self):\n        return self.name + \"(\" in (\n            self.error_info[\"line\"].replace(\" \", \"\").replace(\"\\n\", \"\").replace(\"\\r\", \"\")\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Helper method in NameErrorHelper that detects if the undefined name is being called like a function in the error line, useful for tailoring error messages or debugging assistance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_is_subscript_value", "line_number": 459, "body": "def _is_subscript_value(self):\n        return self.name + \"[\" in (\n            self.error_info[\"line\"].replace(\" \", \"\").replace(\"\\n\", \"\").replace(\"\\r\", \"\")\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Determines if the NameError is related to a subscripted variable by checking if the name appears as a subscript in the error line. This helps diagnose complex NameErrors involving indexing or key access."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_is_attribute_value", "line_number": 464, "body": "def _is_attribute_value(self):\n        return self.name + \".\" in (\n            self.error_info[\"line\"].replace(\" \", \"\").replace(\"\\n\", \"\").replace(\"\\r\", \"\")\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Helper method in NameErrorHelper that checks if the error involves accessing an attribute of the given name within the error line context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_wrong_attribute_instead_of_len", "line_number": 498, "body": "def _sug_wrong_attribute_instead_of_len(self):\n\n        if self.type_name == \"str\":\n            goal = \"length\"\n        elif self.type_name == \"bytes\":\n            goal = \"number of bytes\"\n        elif self.type_name == \"list\":\n            goal = \"number of elements\"\n        elif self.type_name == \"tuple\":\n            goal = \"number of elements\"\n        elif self.type_name == \"set\":\n            goal = \"number of elements\"\n        elif self.type_name == \"dict\":\n            goal = \"number of entries\"\n        else:\n            return None\n\n        return Suggestion(\n            \"wrong-attribute-instead-of-len\",\n            \"Did you mean to ask the %s?\" % goal,\n            \"This can be done with function `len`, eg:\\n\\n`len(%s)`\"\n            % _get_sample_for_type(self.type_name),\n            (9 if self.att_name.lower() in (\"len\", \"length\", \"size\") else 0),\n        )", "is_method": true, "class_name": "AttributeErrorHelper", "function_description": "Provides a context-aware suggestion for mistaken attribute access when the intended goal was to get the length or size of a common container type, guiding users to use the `len()` function instead."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_bad_spelling", "line_number": 523, "body": "def _sug_bad_spelling(self):\n        # TODO: compare with attributes of known types\n        return Suggestion(\n            \"bad-spelling-attribute\",\n            \"Did you misspell the name?\",\n            \"Don't forget that case of the letters matters too!\",\n            3,\n        )", "is_method": true, "class_name": "AttributeErrorHelper", "function_description": "Private helper method in AttributeErrorHelper that provides a suggestion for attribute name misspellings, prompting users to check spelling and case sensitivity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_bad_type", "line_number": 532, "body": "def _sug_bad_type(self):\n        if self._is_call_function():\n            action = \"call this function on\"\n        else:\n            action = \"ask this attribute from\"\n\n        return Suggestion(\n            \"wrong-type-attribute\",\n            \"Did you expect another type?\",\n            \"If you didn't mean %s %s, \" % (action, _get_phrase_for_object(self.type_name))\n            + \"then step through your program to see \"\n            + \"why this type appears here.\",\n            3,\n        )", "is_method": true, "class_name": "AttributeErrorHelper", "function_description": "Generates a customized suggestion message when an attribute error occurs due to wrong object type, helping debug type-related issues by indicating whether a function call or attribute access was attempted."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_is_call_function", "line_number": 547, "body": "def _is_call_function(self):\n        return \".\" + self.att_name + \"(\" in (\n            self.error_info[\"line\"].replace(\" \", \"\").replace(\"\\n\", \"\").replace(\"\\r\", \"\")\n        )", "is_method": true, "class_name": "AttributeErrorHelper", "function_description": "Private helper method in AttributeErrorHelper that checks if the attribute error is caused by an attempted function call on the attribute, based on analyzing the error line's code snippet."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "get_kill_process_instructions", "line_number": 578, "body": "def get_kill_process_instructions(self):\n        s = (\n            \"Let's say you need port 5000. If you don't know which process is using it,\"\n            + \" then enter following system command into Thonny's Shell:\\n\\n\"\n        )\n\n        if running_on_windows():\n            s += (\n                \"``!netstat -ano | findstr :5000``\\n\\n\"\n                + \"You should see the process ID in the last column.\\n\\n\"\n            )\n        else:\n            s += (\n                \"``!lsof -i:5000``\\n\\n\" + \"You should see the process ID under the heading PID.\\n\\n\"\n            )\n\n        s += (\n            \"Let's pretend the ID is 12345.\"\n            \" You can try hard-killing the process with following command:\\n\\n\"\n        )\n\n        if running_on_windows():\n            s += \"``!tskill 12345``\\n\"\n        else:\n            s += (\n                \"``!kill -9 12345``\\n\\n\"\n                + \"Both steps can be combined into single command:\\n\\n\"\n                + \"``!kill -9 $(lsof -t -i:5000)``\\n\\n\"\n            )\n\n        return s", "is_method": true, "class_name": "OSErrorHelper", "function_description": "Generates platform-specific instructions for identifying and forcibly terminating processes occupying port 5000, guiding users to free network resources on Windows or Unix-like systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_bad_string_concatenation", "line_number": 649, "body": "def _bad_string_concatenation(self, other_type_name, string_first):\n        self.intro_text = \"Your program is trying to put together \" + (\n            \"a string and %s.\" if string_first else \"%s and a string.\"\n        ) % _get_phrase_for_object(other_type_name)\n\n        self.suggestions.append(\n            Suggestion(\n                \"convert-other-operand-to-string\",\n                \"Did you mean to treat both sides as text and produce a string?\",\n                \"In this case you should apply function `str` to the %s \"\n                % _get_phrase_for_object(other_type_name, False)\n                + \"in order to convert it to string first, eg:\\n\\n\"\n                + (\"`'abc' + str(%s)`\" if string_first else \"`str(%s) + 'abc'`\")\n                % _get_sample_for_type(other_type_name),\n                8,\n            )\n        )\n\n        if other_type_name in (\"float\", \"int\"):\n            self.suggestions.append(\n                Suggestion(\n                    \"convert-other-operand-to-number\",\n                    \"Did you mean to treat both sides as numbers and produce a sum?\",\n                    \"In this case you should first convert the string to a number \"\n                    + \"using either function `float` or `int`, eg:\\n\\n\"\n                    + (\"`float('3.14') + 22`\" if string_first else \"`22 + float('3.14')`\"),\n                    7,\n                )\n            )", "is_method": true, "class_name": "TypeErrorHelper", "function_description": "Generates explanatory messages and tailored suggestions to help users resolve errors caused by attempting to concatenate strings with non-string types in Python."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "default_light", "line_number": 5, "body": "def default_light() -> SyntaxThemeSettings:\n    default_fg = \"black\"\n    default_bg = \"#fdfdfd\"\n    light_fg = \"DarkGray\"\n    string_fg = \"DarkGreen\"\n    open_string_bg = \"#c3f9d3\"\n    gutter_foreground = \"#999999\"\n    gutter_background = \"#e0e0e0\"\n\n    return {\n        \"TEXT\": {\n            \"foreground\": default_fg,\n            \"insertbackground\": default_fg,\n            \"background\": default_bg,\n        },\n        \"GUTTER\": {\"foreground\": gutter_foreground, \"background\": gutter_background},\n        \"breakpoint\": {\"foreground\": \"crimson\"},\n        \"current_line\": {\"background\": \"#f5f5f5\"},\n        \"definition\": {\"foreground\": \"DarkBlue\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg, \"background\": None, \"font\": \"EditorFont\"},\n        \"open_string\": {\"foreground\": string_fg, \"background\": open_string_bg},\n        \"open_string3\": {\n            \"foreground\": string_fg,\n            \"background\": open_string_bg,\n            \"font\": \"EditorFont\",\n        },\n        \"tab\": {\"background\": \"#f5ecd7\"},\n        \"keyword\": {\"foreground\": \"#7f0055\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#7f0055\"},\n        \"number\": {\"foreground\": \"#B04600\"},\n        \"comment\": {\"foreground\": light_fg},\n        \"welcome\": {\"foreground\": light_fg},\n        \"magic\": {\"foreground\": light_fg},\n        \"prompt\": {\"foreground\": \"purple\", \"font\": \"BoldEditorFont\"},\n        \"stdin\": {\"foreground\": \"Blue\"},\n        \"stdout\": {\"foreground\": \"Black\"},\n        \"stderr\": {\"foreground\": \"#CC0000\"},  # same as ANSI red\n        \"value\": {\"foreground\": \"DarkBlue\"},\n        \"hyperlink\": {\"foreground\": \"#3A66DD\", \"underline\": True},\n        # paren matcher\n        \"surrounding_parens\": {\"foreground\": \"Blue\", \"font\": \"BoldEditorFont\"},\n        \"unclosed_expression\": {\"background\": \"LightGray\"},\n        # find/replace\n        \"found\": {\"foreground\": \"blue\", \"underline\": True},\n        \"current_found\": {\"foreground\": \"white\", \"background\": \"red\"},\n        \"matched_name\": {\"background\": \"#e6ecfe\"},\n        \"local_name\": {\"font\": \"ItalicEditorFont\"},\n        # debugger\n        \"active_focus\": {\"background\": \"#F8FC9A\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"suspended_focus\": {\"background\": \"\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"completed_focus\": {\"background\": \"#BBEDB2\", \"borderwidth\": 1, \"relief\": \"flat\"},\n        \"exception_focus\": {\"background\": \"#FFBFD6\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"expression_box\": {\"background\": \"#DCEDF2\", \"foreground\": default_fg},\n        \"black_fg\": {\"foreground\": \"#2E3436\"},\n        \"black_bg\": {\"background\": \"#2E3436\"},\n        \"bright_black_fg\": {\"foreground\": \"#555753\"},\n        \"bright_black_bg\": {\"background\": \"#555753\"},\n        \"dim_black_fg\": {\"foreground\": \"#1E2224\"},\n        \"dim_black_bg\": {\"background\": \"#1E2224\"},\n        \"red_fg\": {\"foreground\": \"#CC0000\"},\n        \"red_bg\": {\"background\": \"#CC0000\"},\n        \"bright_red_fg\": {\"foreground\": \"#EF2929\"},\n        \"bright_red_bg\": {\"background\": \"#EF2929\"},\n        \"dim_red_fg\": {\"foreground\": \"#880000\"},\n        \"dim_red_bg\": {\"background\": \"#880000\"},\n        \"green_fg\": {\"foreground\": \"#4E9A06\"},\n        \"green_bg\": {\"background\": \"#4E9A06\"},\n        \"bright_green_fg\": {\"foreground\": \"#8AE234\"},\n        \"bright_green_bg\": {\"background\": \"#8AE234\"},\n        \"dim_green_fg\": {\"foreground\": \"#346704\"},\n        \"dim_green_bg\": {\"background\": \"#346704\"},\n        \"yellow_fg\": {\"foreground\": \"#C4A000\"},\n        \"yellow_bg\": {\"background\": \"#C4A000\"},\n        \"bright_yellow_fg\": {\"foreground\": \"#FCE94F\"},\n        \"bright_yellow_bg\": {\"background\": \"#FCE94F\"},\n        \"dim_yellow_fg\": {\"foreground\": \"#836B00\"},\n        \"dim_yellow_bg\": {\"background\": \"#836B00\"},\n        \"blue_fg\": {\"foreground\": \"#3465A4\"},\n        \"blue_bg\": {\"background\": \"#3465A4\"},\n        \"bright_blue_fg\": {\"foreground\": \"#729FCF\"},\n        \"bright_blue_bg\": {\"background\": \"#729FCF\"},\n        \"dim_blue_fg\": {\"foreground\": \"#22436D\"},\n        \"dim_blue_bg\": {\"background\": \"#22436D\"},\n        \"magenta_fg\": {\"foreground\": \"#75507B\"},\n        \"magenta_bg\": {\"background\": \"#75507B\"},\n        \"bright_magenta_fg\": {\"foreground\": \"#AD7FA8\"},\n        \"bright_magenta_bg\": {\"background\": \"#AD7FA8\"},\n        \"dim_magenta_fg\": {\"foreground\": \"#4E3552\"},\n        \"dim_magenta_bg\": {\"background\": \"#4E3552\"},\n        \"cyan_fg\": {\"foreground\": \"#06989A\"},\n        \"cyan_bg\": {\"background\": \"#06989A\"},\n        \"bright_cyan_fg\": {\"foreground\": \"#34E2E2\"},\n        \"bright_cyan_bg\": {\"background\": \"#34E2E2\"},\n        \"dim_cyan_fg\": {\"foreground\": \"#046567\"},\n        \"dim_cyan_bg\": {\"background\": \"#046567\"},\n        \"white_fg\": {\"foreground\": \"#D3D7CF\"},\n        \"white_bg\": {\"background\": \"#D3D7CF\"},\n        \"bright_white_fg\": {\"foreground\": \"#EEEEEC\"},\n        \"bright_white_bg\": {\"background\": \"#EEEEEC\"},\n        \"dim_white_fg\": {\"foreground\": \"#8D8F8A\"},\n        \"dim_white_bg\": {\"background\": \"#8D8F8A\"},\n        \"fore_fg\": {\"foreground\": default_fg},\n        \"fore_bg\": {\"background\": default_fg},\n        \"bright_fore_fg\": {\"foreground\": \"#000000\"},\n        \"bright_fore_bg\": {\"background\": \"#000000\"},\n        \"dim_fore_fg\": {\"foreground\": \"#222222\"},\n        \"dim_fore_bg\": {\"background\": \"#222222\"},\n        \"back_fg\": {\"foreground\": default_bg},\n        \"back_bg\": {\"background\": default_bg},\n        \"bright_back_fg\": {\"foreground\": \"#ffffff\"},\n        \"bright_back_bg\": {\"background\": \"#ffffff\"},\n        \"dim_back_fg\": {\"foreground\": \"#e0e0e0\"},\n        \"dim_back_bg\": {\"background\": \"#e0e0e0\"},\n        \"intense_io\": {\"font\": \"BoldIOFont\"},\n        \"italic_io\": {\"font\": \"ItalicIOFont\"},\n        \"intense_italic_io\": {\"font\": \"BoldItalicIOFont\"},\n        \"underline\": {\"underline\": True},\n        \"strikethrough\": {\"overstrike\": True},\n    }", "is_method": false, "function_description": "Provides a predefined light-themed syntax highlighting configuration dictionary specifying colors, fonts, and styles for various text editor elements and code tokens. Useful for applying consistent light theme visual styling in code editors or IDEs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "default_dark", "line_number": 127, "body": "def default_dark() -> SyntaxThemeSettings:\n    default_fg = \"#B3B3B3\"\n    default_bg = \"#2d2d2d\"\n    string_fg = \"#8DC76F\"\n    open_string_bg = \"#224533\"\n    gutter_foreground = \"#606060\"\n    gutter_background = \"#323232\"\n\n    # s.configure(\"Local.Code\", foreground=\"#BCCAE8\")\n    # s.configure(\"MatchedName.Code\", background=\"#193022\")\n\n    return {\n        \"TEXT\": {\n            \"foreground\": default_fg,\n            \"insertbackground\": default_fg,\n            \"background\": default_bg,\n        },\n        \"GUTTER\": {\"foreground\": gutter_foreground, \"background\": gutter_background},\n        \"breakpoint\": {\"foreground\": \"pink\"},\n        \"current_line\": {\"background\": \"#363636\"},\n        \"sel\": {\"foreground\": \"#eeeeee\", \"background\": \"#6E6E6E\"},\n        \"definition\": {\"foreground\": default_fg},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg, \"background\": None, \"font\": \"EditorFont\"},\n        \"open_string\": {\"foreground\": string_fg, \"background\": open_string_bg},\n        \"open_string3\": {\n            \"foreground\": string_fg,\n            \"background\": open_string_bg,\n            \"font\": \"EditorFont\",\n        },\n        \"tab\": {\"background\": \"#424034\"},\n        \"builtin\": {\"foreground\": \"#A9B1C9\"},\n        \"keyword\": {\"foreground\": \"#A9B1C9\", \"font\": \"BoldEditorFont\"},\n        \"number\": {\"foreground\": \"#FFCABF\"},\n        \"comment\": {\"foreground\": \"#D4D44E\"},\n        \"welcome\": {\"foreground\": \"pink\"},\n        \"magic\": {\"foreground\": \"pink\"},\n        # shell\n        \"prompt\": {\"foreground\": \"#5BEBBB\", \"font\": \"BoldEditorFont\"},\n        \"stdin\": {\"foreground\": \"LightBlue\"},\n        \"stdout\": {\"foreground\": \"LightGray\"},\n        \"stderr\": {\"foreground\": \"#EB5B83\"},\n        \"value\": {\"foreground\": \"#EBEB5B\"},\n        \"hyperlink\": {\"foreground\": \"#619DC7\", \"underline\": True},\n        # paren matcher\n        \"surrounding_parens\": {\"foreground\": \"#F0995B\", \"font\": \"BoldEditorFont\"},\n        \"unclosed_expression\": {\"background\": \"#000000\"},\n        # find/replace\n        \"found\": {\"underline\": True},\n        \"current_found\": {\"foreground\": \"white\", \"background\": \"red\"},\n        \"matched_name\": {\"background\": \"#474747\"},\n        \"local_name\": {\"font\": \"ItalicEditorFont\"},\n        # debugger\n        \"active_focus\": {\"background\": \"#807238\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"suspended_focus\": {\"background\": \"\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"completed_focus\": {\"background\": \"#807238\", \"borderwidth\": 1, \"relief\": \"flat\"},\n        \"exception_focus\": {\"background\": \"#FFBFD6\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"expression_box\": {\"background\": \"#506E67\", \"foreground\": default_fg},\n        \"black_fg\": {\"foreground\": \"#2E3436\"},\n        \"black_bg\": {\"background\": \"#2E3436\"},\n        \"bright_black_fg\": {\"foreground\": \"#555753\"},\n        \"bright_black_bg\": {\"background\": \"#555753\"},\n        \"dim_black_fg\": {\"foreground\": \"#1E2224\"},\n        \"dim_black_bg\": {\"background\": \"#1E2224\"},\n        \"red_fg\": {\"foreground\": \"#CC0000\"},\n        \"red_bg\": {\"background\": \"#CC0000\"},\n        \"bright_red_fg\": {\"foreground\": \"#EF2929\"},\n        \"bright_red_bg\": {\"background\": \"#EF2929\"},\n        \"dim_red_fg\": {\"foreground\": \"#880000\"},\n        \"dim_red_bg\": {\"background\": \"#880000\"},\n        \"green_fg\": {\"foreground\": \"#4E9A06\"},\n        \"green_bg\": {\"background\": \"#4E9A06\"},\n        \"bright_green_fg\": {\"foreground\": \"#8AE234\"},\n        \"bright_green_bg\": {\"background\": \"#8AE234\"},\n        \"dim_green_fg\": {\"foreground\": \"#346704\"},\n        \"dim_green_bg\": {\"background\": \"#346704\"},\n        \"yellow_fg\": {\"foreground\": \"#C4A000\"},\n        \"yellow_bg\": {\"background\": \"#C4A000\"},\n        \"bright_yellow_fg\": {\"foreground\": \"#FCE94F\"},\n        \"bright_yellow_bg\": {\"background\": \"#FCE94F\"},\n        \"dim_yellow_fg\": {\"foreground\": \"#836B00\"},\n        \"dim_yellow_bg\": {\"background\": \"#836B00\"},\n        \"blue_fg\": {\"foreground\": \"#3465A4\"},\n        \"blue_bg\": {\"background\": \"#3465A4\"},\n        \"bright_blue_fg\": {\"foreground\": \"#729FCF\"},\n        \"bright_blue_bg\": {\"background\": \"#729FCF\"},\n        \"dim_blue_fg\": {\"foreground\": \"#22436D\"},\n        \"dim_blue_bg\": {\"background\": \"#22436D\"},\n        \"magenta_fg\": {\"foreground\": \"#75507B\"},\n        \"magenta_bg\": {\"background\": \"#75507B\"},\n        \"bright_magenta_fg\": {\"foreground\": \"#AD7FA8\"},\n        \"bright_magenta_bg\": {\"background\": \"#AD7FA8\"},\n        \"dim_magenta_fg\": {\"foreground\": \"#4E3552\"},\n        \"dim_magenta_bg\": {\"background\": \"#4E3552\"},\n        \"cyan_fg\": {\"foreground\": \"#06989A\"},\n        \"cyan_bg\": {\"background\": \"#06989A\"},\n        \"bright_cyan_fg\": {\"foreground\": \"#34E2E2\"},\n        \"bright_cyan_bg\": {\"background\": \"#34E2E2\"},\n        \"dim_cyan_fg\": {\"foreground\": \"#046567\"},\n        \"dim_cyan_bg\": {\"background\": \"#046567\"},\n        \"white_fg\": {\"foreground\": \"#D3D7CF\"},\n        \"white_bg\": {\"background\": \"#D3D7CF\"},\n        \"bright_white_fg\": {\"foreground\": \"#EEEEEC\"},\n        \"bright_white_bg\": {\"background\": \"#EEEEEC\"},\n        \"dim_white_fg\": {\"foreground\": \"#8D8F8A\"},\n        \"dim_white_bg\": {\"background\": \"#8D8F8A\"},\n        \"fore_fg\": {\"foreground\": default_fg},\n        \"fore_bg\": {\"background\": default_fg},\n        \"bright_fore_fg\": {\"foreground\": \"#ffffff\"},\n        \"bright_fore_bg\": {\"background\": \"#ffffff\"},\n        \"dim_fore_fg\": {\"foreground\": \"#e0e0e0\"},\n        \"dim_fore_bg\": {\"background\": \"#e0e0e0\"},\n        \"back_fg\": {\"foreground\": default_bg},\n        \"back_bg\": {\"background\": default_bg},\n        \"bright_back_fg\": {\"foreground\": \"#000000\"},\n        \"bright_back_bg\": {\"background\": \"#000000\"},\n        \"dim_back_fg\": {\"foreground\": \"#222222\"},\n        \"dim_back_bg\": {\"background\": \"#222222\"},\n        \"intense_io\": {\"font\": \"BoldIOFont\"},\n        \"italic_io\": {\"font\": \"ItalicIOFont\"},\n        \"intense_italic_io\": {\"font\": \"BoldItalicIOFont\"},\n        \"underline\": {\"underline\": True},\n        \"strikethrough\": {\"overstrike\": True},\n    }", "is_method": false, "function_description": "Returns a predefined dictionary of color and style settings for a dark-themed syntax highlighting scheme, providing a consistent and customizable appearance for text editors or code displays."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "default_dark_green", "line_number": 253, "body": "def default_dark_green() -> SyntaxThemeSettings:\n    open_string_bg = \"#453B22\"\n    gutter_background = \"#33402F\"\n\n    return {\n        \"TEXT\": {\"background\": \"#273627\"},\n        \"GUTTER\": {\"background\": gutter_background},\n        \"current_line\": {\"background\": \"#2E402E\"},\n        \"sel\": {\"background\": \"#6E6E6E\"},\n        \"unclosed_expression\": {\"background\": \"#0F1F15\"},\n        \"open_string\": {\"background\": open_string_bg},\n        \"open_string3\": {\"background\": open_string_bg},\n        \"keyword\": {\"foreground\": \"#88CFB6\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#88CFB6\"},\n        # debugger\n        \"active_focus\": {\"background\": \"#807238\"},\n        \"completed_focus\": {\"background\": \"#807238\"},\n        \"exception_focus\": {\"background\": \"#FFBFD6\"},\n        \"expression_box\": {\"background\": \"#506E67\"},\n    }", "is_method": false, "function_description": "Returns a preset dark green color scheme configuration for syntax highlighting, providing consistent background and foreground styles for text editors or code displays."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "default_dark_blue", "line_number": 275, "body": "def default_dark_blue() -> SyntaxThemeSettings:\n    open_string_bg = \"#224533\"\n    gutter_background = \"#2F3640\"\n    return {\n        \"TEXT\": {\"background\": \"#272936\"},\n        \"GUTTER\": {\"background\": gutter_background},\n        \"current_line\": {\"background\": \"#2D3040\"},\n        \"sel\": {\"background\": \"#6E6E6E\"},\n        \"unclosed_expression\": {\"background\": \"#100B21\"},\n        \"open_string\": {\"background\": open_string_bg},\n        \"open_string3\": {\"background\": open_string_bg},\n        \"keyword\": {\"foreground\": \"#8899CF\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#8899CF\"},\n        # debugger\n        \"active_focus\": {\"background\": \"#807238\"},\n        \"completed_focus\": {\"background\": \"#807238\"},\n        \"exception_focus\": {\"background\": \"#FFBFD6\"},\n        \"expression_box\": {\"background\": \"#506E67\"},\n    }", "is_method": false, "function_description": "Provides a predefined color and style theme with dark blue tones for syntax highlighting, useful for consistent editor or debugger UI appearance settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "idle_classic", "line_number": 296, "body": "def idle_classic() -> SyntaxThemeSettings:\n    string_fg = \"#00aa00\"\n    return {\n        \"TEXT\": {\"foreground\": \"black\", \"insertbackground\": \"black\", \"background\": \"white\"},\n        \"GUTTER\": {\"foreground\": \"gray\", \"background\": \"#efefef\"},\n        \"sel\": {\"foreground\": \"black\", \"background\": \"gray\"},\n        \"number\": {\"foreground\": \"black\"},\n        \"definition\": {\"foreground\": \"#0000ff\", \"font\": \"EditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string_fg},\n        \"open_string3\": {\"foreground\": string_fg},\n        \"keyword\": {\"foreground\": \"#ff7700\", \"font\": \"EditorFont\"},\n        \"builtin\": {\"foreground\": \"#900090\"},\n        \"comment\": {\"foreground\": \"#dd0000\"},\n        \"prompt\": {\"foreground\": \"#770000\"},\n        \"stdin\": {\"foreground\": \"black\"},\n        \"stdout\": {\"foreground\": \"Blue\"},\n        \"value\": {\"foreground\": \"Blue\"},\n        \"stderr\": {\"foreground\": \"Red\"},\n        \"found\": {\"foreground\": \"\", \"underline\": True},\n        \"current_found\": {\"foreground\": \"white\", \"background\": \"black\"},\n    }", "is_method": false, "function_description": "Provides predefined syntax highlighting color and style settings for a classic idle theme, enabling consistent and visually distinct code elements in a text editor or IDE."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "idle_dark", "line_number": 321, "body": "def idle_dark() -> SyntaxThemeSettings:\n    normal_fg = \"white\"\n    string_fg = \"#02ff02\"\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#002240\"},\n        \"sel\": {\"foreground\": \"#FFFFFF\", \"background\": \"#7e7e7e\"},\n        \"number\": {\"foreground\": normal_fg},\n        \"definition\": {\"foreground\": \"#5e5eff\", \"font\": \"EditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string_fg},\n        \"open_string3\": {\"foreground\": string_fg},\n        \"keyword\": {\"foreground\": \"#ff8000\", \"font\": \"EditorFont\"},\n        \"builtin\": {\"foreground\": \"#ff00ff\"},\n        \"comment\": {\"foreground\": \"#dd0000\"},\n        \"welcome\": {\"foreground\": \"#dd0000\"},\n        \"prompt\": {\"foreground\": \"#ff4d4d\"},\n        \"stdin\": {\"foreground\": normal_fg},\n        \"stdout\": {\"foreground\": \"#c2d1fa\"},\n        \"value\": {\"foreground\": \"#c2d1fa\"},\n        \"stderr\": {\"foreground\": \"#ffb3b3\"},\n        \"found\": {\"foreground\": \"\", \"underline\": True},\n        \"current_found\": {\"foreground\": \"#002240\", \"background\": \"#fbfbfb\"},\n    }", "is_method": false, "function_description": "Returns a predefined color and font style configuration for syntax highlighting in the IDLE editor's dark theme, enabling consistent visual formatting of Python code elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "desert_sunset", "line_number": 348, "body": "def desert_sunset() -> SyntaxThemeSettings:\n    normal_fg = \"#f0e68c\"\n    string_fg = \"#ffa0a0\"\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#333333\"},\n        \"GUTTER\": {\"foreground\": \"gray\", \"background\": \"#404040\"},\n        \"sel\": {\"foreground\": \"#000000\", \"background\": \"gray\"},\n        \"number\": {\"foreground\": normal_fg},\n        \"definition\": {\"foreground\": \"#98fb98\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string_fg},\n        \"open_string3\": {\"foreground\": string_fg},\n        \"keyword\": {\"foreground\": \"#cc6600\"},\n        \"builtin\": {\"foreground\": \"#519e51\"},\n        \"comment\": {\"foreground\": \"#87ceeb\"},\n        \"welcome\": {\"foreground\": \"#87ceeb\"},\n        \"prompt\": {\"foreground\": \"#87ceeb\"},\n        \"stdin\": {\"foreground\": normal_fg},\n        \"stdout\": {\"foreground\": \"#eeeeee\"},\n        \"value\": {\"foreground\": \"#eeeeee\"},\n        \"stderr\": {\"foreground\": \"#ff595b\"},\n        \"found\": {\"foreground\": \"\", \"underline\": True},\n        \"current_found\": {\"foreground\": \"#ffffff\", \"background\": \"#333333\"},\n    }", "is_method": false, "function_description": "Function that provides a predefined color scheme named \"desert_sunset\" for syntax highlighting settings, defining colors for text elements and interface components in a consistent theme."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "zenburn", "line_number": 376, "body": "def zenburn() -> SyntaxThemeSettings:\n    # https://github.com/mig/gedit-themes/blob/master/zenburn.xml\n    # https://github.com/trusktr/gedit-color-schemes/blob/master/gtksourceview-3.0/styles/zenburn.xml\n    normal_fg = \"#dcdccc\"\n    string_fg = \"#cc9393\"\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#3f3f3f\"},\n        \"GUTTER\": {\"foreground\": \"#7f8f8f\", \"background\": \"#464646\"},\n        \"current_line\": {\"background\": \"#4A4A4A\"},\n        \"sel\": {\"foreground\": \"white\", \"background\": \"#506070\"},\n        \"number\": {\"foreground\": \"#8cd0d3\"},\n        \"definition\": {\"foreground\": \"#f4a020\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string_fg},\n        \"open_string3\": {\"foreground\": string_fg},\n        \"keyword\": {\"foreground\": \"#f0dfaf\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#efef8f\"},\n        \"comment\": {\"foreground\": \"#7f9f7f\"},\n        \"welcome\": {\"foreground\": \"#7f9f7f\"},\n        \"prompt\": {\"foreground\": \"#87ceeb\"},\n        \"stdin\": {\"foreground\": normal_fg},\n        \"stdout\": {\"foreground\": \"#eeeeee\"},\n        \"value\": {\"foreground\": \"#eeeeee\"},\n        \"stderr\": {\"foreground\": \"#ff3e40\"},\n        # paren matcher\n        \"surrounding_parens\": {\"foreground\": \"white\", \"font\": \"BoldEditorFont\"},\n    }", "is_method": false, "function_description": "Provides a predefined Zenburn color theme configuration for syntax highlighting, defining foreground, background, and font styles used in a code editor or similar interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "load_plugin", "line_number": 407, "body": "def load_plugin() -> None:\n    get_workbench().add_syntax_theme(\"Default Light\", None, default_light)\n    get_workbench().add_syntax_theme(\"Default Dark\", None, default_dark)\n    get_workbench().add_syntax_theme(\"Default Dark Green\", \"Default Dark\", default_dark_green)\n    get_workbench().add_syntax_theme(\"Default Dark Blue\", \"Default Dark\", default_dark_blue)\n    get_workbench().add_syntax_theme(\"Desert Sunset\", \"Default Dark\", desert_sunset)\n    get_workbench().add_syntax_theme(\"Zenburn\", \"Default Dark\", zenburn)\n    get_workbench().add_syntax_theme(\"IDLE Classic\", \"Default Light\", idle_classic)\n\n    # Comments in IDLE Dark really hurt the eyes\n    # get_workbench().add_syntax_theme(\"IDLE Dark\", \"Default Dark\", idle_dark)\n\n    get_workbench().set_default(\"view.syntax_theme\", \"Default Light\")", "is_method": false, "function_description": "Registers multiple syntax highlighting themes in the workbench and sets the default theme to \"Default Light\" for the user interface. This enables customizable code appearance within the environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/goto_definition.py", "function": "goto_definition", "line_number": 11, "body": "def goto_definition(event):\n    if not control_is_pressed(event.state):\n        return\n\n    assert isinstance(event.widget, tk.Text)\n    text = event.widget\n\n    source = text.get(\"1.0\", \"end\")\n    index = text.index(\"insert\")\n    index_parts = index.split(\".\")\n    line, column = int(index_parts[0]), int(index_parts[1])\n    try:\n        editor = text.master.home_widget\n        path = editor.get_filename()\n    except Exception as e:\n        logger.warning(\"Could not get path\", exc_info=e)\n        path = None\n\n    defs = jedi_utils.get_definitions(source, line, column, path)\n    if len(defs) > 0:\n        # TODO: handle multiple results like PyCharm\n        module_path = str(defs[0].module_path)\n        if not os.path.isfile(module_path):\n            logger.warning(\"%s is not a file\", module_path)\n            return\n\n        module_name = defs[0].module_name\n        line = defs[0].line\n        if module_path and line is not None:\n            get_workbench().get_editor_notebook().show_file(module_path, line)\n        elif module_name == \"\" and line is not None:  # current editor\n            get_workbench().get_editor_notebook().get_current_editor().select_range(line)", "is_method": false, "function_description": "This function enables navigating to the source definition of a symbol in a text editor when the control key is pressed, supporting quick code exploration by opening the relevant file and line in the editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "update_editor_cells", "line_number": 11, "body": "def update_editor_cells(event):\n    text = event.widget\n\n    if not getattr(text, \"cell_tags_configured\", False):\n        text.tag_configure(\"CURRENT_CELL\", borderwidth=1, relief=\"groove\", background=\"LightYellow\")\n        text.tag_configure(\"CELL_HEADER\", font=\"BoldEditorFont\", foreground=\"#665843\")\n\n        text.tag_lower(\"CELL_HEADER\")\n        text.tag_lower(\"CURRENT_CELL\")\n        text.cell_tags_configured = True\n\n    text.tag_remove(\"CURRENT_CELL\", \"0.1\", \"end\")\n    text.tag_remove(\"CELL_HEADER\", \"0.1\", \"end\")\n    source = text.get(\"1.0\", \"end\")\n    cells = []\n    prev_marker = 0\n    for match in cell_regex.finditer(source):\n        if match.start() == 0:\n            this_marker = match.start()\n        else:\n            this_marker = match.start() + 1\n\n        cell_start_index = text.index(\"1.0+%dc\" % prev_marker)\n        header_end_index = text.index(\"1.0+%dc\" % match.end())\n        cell_end_index = text.index(\"1.0+%dc\" % this_marker)\n        text.tag_add(\"CELL_HEADER\", cell_end_index, header_end_index)\n        cells.append((cell_start_index, cell_end_index))\n\n        prev_marker = this_marker\n\n    if prev_marker != 0:\n        cells.append((text.index(\"1.0+%dc\" % prev_marker), \"end\"))\n\n    # if get_workbench().focus_get() == text:\n    # It's nice to have cell highlighted even when focus\n    # is elsewhere ? This would act as kind of bookmark.\n\n    for start_index, end_index in cells:\n        if text.compare(start_index, \"<=\", \"insert\") and text.compare(end_index, \">\", \"insert\"):\n            text.tag_add(\"CURRENT_CELL\", start_index, end_index)\n            break", "is_method": false, "function_description": "Utility function that highlights and visually distinguishes editor cells and their headers within a text widget, updating cell boundaries and current cell focus based on cursor position."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "_submit_code", "line_number": 54, "body": "def _submit_code(code):\n    lines = code.splitlines()\n\n    # remove starting comments\n    while len(lines) > 0 and lines[0].strip().startswith(\"#\"):\n        lines = lines[1:]\n\n    # remove starting empty lines\n    while len(lines) > 0 and lines[0].strip() == \"\":\n        lines = lines[1:]\n\n    # remove trailing empty lines\n    while len(lines) > 0 and lines[-1].strip() == \"\":\n        lines = lines[:-1]\n\n    if len(lines) > 0:\n        code = \"\\n\".join(lines) + \"\\n\"\n        # if code is function definition/last line start with whitespace\n        # end function definition with a second endline\n        if re.match(r\"^[ \\t].*\", lines[-1]) is not None:\n            code += \"\\n\"\n        shell = get_workbench().show_view(\"ShellView\", False)\n        shell.submit_python_code(code)", "is_method": false, "function_description": "Utility function that cleans leading comments and empty lines from Python code before submitting it to an interactive shell for execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "_patch_perform_return", "line_number": 79, "body": "def _patch_perform_return():\n    original_perform_return = CodeViewText.perform_return\n\n    def _patched_perform_return(self, event):\n        text = event.widget\n        ranges = text.tag_ranges(\"CURRENT_CELL\")\n\n        if len(ranges) == 2 and (\n            ui_utils.shift_is_pressed(event.state) or ui_utils.control_is_pressed(event.state)\n        ):\n\n            if run_enabled():\n                code = text.get(ranges[0], ranges[1]).strip()\n                _submit_code(code)\n\n                if ui_utils.shift_is_pressed(event.state):\n                    # advance to next cell\n                    text.mark_set(\"insert\", ranges[1])\n\n            return \"break\"\n        else:\n            return original_perform_return(self, event)\n\n    CodeViewText.perform_return = _patched_perform_return", "is_method": false, "function_description": "This function monkey-patches CodeViewText.perform_return to enable running highlighted code cells with Shift or Control keys pressed, supporting inline code execution and optional cell advancement in a code editor interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "_patch_intercept_mark", "line_number": 105, "body": "def _patch_intercept_mark():\n    \"\"\"Need to make cursor wider when in first column. Otherwise\n    the border of the cell box makes it hard to notice the cursor.\n\n    NB! Need to be careful with setting text[\"insertwidth\"]!\n    My first straightforward solution caused unexplainable\n    infinite loop of insertions and deletions in the text\n    (insert a line and a word, select that word and then do Ctrl-Z).\n\n    Looks like this solution is safe, but I don't dare to include\n    it in the main code.\n\n    UPDATE: not safe. Select and delete a block of lines. Write a new\n    line and do Ctrl-Z\"\"\"\n\n    original_intercept_mark = CodeViewText.intercept_mark\n\n    def _patched_intercept_mark(self, *args):\n        if args[:2] == (\"set\", \"insert\") and args[2].endswith(\".0\"):\n            self.set_insertwidth(3)\n        else:\n            self.set_insertwidth(2)\n\n        original_intercept_mark(self, *args)\n\n    CodeViewText.intercept_mark = _patched_intercept_mark", "is_method": false, "function_description": "This function modifies cursor behavior to widen it when positioned in the first column for better visibility, by patching a text widget's internal mark interception method. It enhances cursor UI but is marked unstable and not intended for main code use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "run_selection", "line_number": 137, "body": "def run_selection(event=None):\n    widget = get_workbench().focus_get()\n    if isinstance(widget, CodeViewText):\n        text = widget\n\n        if text.has_selection():\n            code = text.get(\"sel.first\", \"sel.last\")\n        else:\n            code = text.get(\"insert linestart\", \"insert lineend\")\n\n        # move cursor to next row\n        row, col = map(int, text.index(\"insert\").split(\".\"))\n        text.mark_set(\"insert\", \"{}.{}\".format(row + 1, col))\n\n        _submit_code(code)", "is_method": false, "function_description": "Function that executes the currently selected code or the current line in a CodeViewText widget and advances the cursor to the next line, supporting interactive code execution workflows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "run_enabled", "line_number": 154, "body": "def run_enabled():\n    widget = get_workbench().focus_get()\n    return isinstance(widget, CodeViewText) and get_runner().is_waiting_toplevel_command()", "is_method": false, "function_description": "Checks if the currently focused widget is a code editor and if the system is ready to execute a top-level command. Useful for determining when code input can be actively run."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "_load_plugin", "line_number": 159, "body": "def _load_plugin():\n    wb = get_workbench()\n    wb.bind_class(\"CodeViewText\", \"<<CursorMove>>\", update_editor_cells, True)\n    wb.bind_class(\"CodeViewText\", \"<<TextChange>>\", update_editor_cells, True)\n    wb.bind_class(\"CodeViewText\", \"<FocusIn>\", update_editor_cells, True)\n    wb.bind_class(\"CodeViewText\", \"<FocusOut>\", update_editor_cells, True)\n\n    _patch_perform_return()\n    # TODO: try changing insertwidth in keyup/mouseup events\n    # _patch_intercept_mark() # Still causes freezes\n\n    wb.add_command(\n        \"run_cell\",\n        \"run\",\n        (\"Run cell\"),\n        handler=dummy,  # actual handler is in the patch\n        default_sequence=\"<Control-Return>\",\n        tester=run_enabled,\n        group=11,\n    )\n\n    wb.add_command(\n        \"run_cell_and_advance\",\n        \"run\",\n        (\"Run cell and advance\"),\n        handler=dummy,  # actual handler is in the patch\n        default_sequence=\"<Shift-Return>\",\n        tester=run_enabled,\n        group=11,\n    )\n\n    wb.add_command(\n        \"run_selection\",\n        \"run\",\n        (\"Run selection or current line\"),\n        handler=run_selection,\n        default_sequence=\"<F9>\",\n        tester=run_enabled,\n        group=11,\n    )", "is_method": false, "function_description": "Sets up event bindings and command registrations in a workbench for code cells, enabling execution actions and cell updates via keyboard shortcuts and editor events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "_patched_perform_return", "line_number": 82, "body": "def _patched_perform_return(self, event):\n        text = event.widget\n        ranges = text.tag_ranges(\"CURRENT_CELL\")\n\n        if len(ranges) == 2 and (\n            ui_utils.shift_is_pressed(event.state) or ui_utils.control_is_pressed(event.state)\n        ):\n\n            if run_enabled():\n                code = text.get(ranges[0], ranges[1]).strip()\n                _submit_code(code)\n\n                if ui_utils.shift_is_pressed(event.state):\n                    # advance to next cell\n                    text.mark_set(\"insert\", ranges[1])\n\n            return \"break\"\n        else:\n            return original_perform_return(self, event)", "is_method": false, "function_description": "This method conditionally intercepts return key events in a text widget to execute selected code cells, supporting modifier keys for enhanced control and navigation during code execution in an interactive environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/terminal_config_page.py", "function": "load_plugin", "line_number": 39, "body": "def load_plugin():\n    get_workbench().add_configuration_page(\n        \"terminal\", tr(\"Terminal\"), TerminalConfigurationPage, 60\n    )", "is_method": false, "function_description": "Adds a terminal configuration page to the workbench interface, enabling users to customize terminal settings within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "load_plugin", "line_number": 714, "body": "def load_plugin() -> None:\n    get_workbench().add_view(ObjectInspector, tr(\"Object inspector\"), \"se\")", "is_method": false, "function_description": "Adds an Object Inspector view to the workbench interface, enhancing the environment with object inspection capabilities. It serves as a setup utility within the application\u2019s UI framework."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_create_toolbar", "line_number": 43, "body": "def _create_toolbar(self):\n        toolbar = ttk.Frame(self, style=\"ViewToolbar.TFrame\")\n\n        self.title_label = ttk.Label(\n            toolbar,\n            style=\"ViewToolbar.TLabel\",\n            text=\"\"\n            # borderwidth=1,\n            # background=ui_utils.get_main_background()\n        )\n        self.title_label.grid(row=0, column=3, sticky=\"nsew\", pady=5, padx=5)\n        toolbar.columnconfigure(3, weight=1)\n\n        self.tabs = []\n\n        def create_tab(col, caption, page):\n            if page == self.active_page:\n                style = \"Active.ViewTab.TLabel\"\n            else:\n                style = \"Inactive.ViewTab.TLabel\"\n            tab = ttk.Label(toolbar, text=caption, style=style)\n            tab.grid(row=0, column=col, pady=5, padx=5, sticky=\"nsew\")\n            self.tabs.append(tab)\n            page.tab = tab\n\n            def on_click(event):\n                if self.active_page == page:\n                    return\n                else:\n                    if self.active_page is not None:\n                        self.active_page.grid_forget()\n                        self.active_page.tab.configure(style=\"Inactive.ViewTab.TLabel\")\n\n                    self.active_page = page\n                    page.grid(row=1, column=0, sticky=\"nsew\", padx=0)\n                    tab.configure(style=\"Active.ViewTab.TLabel\")\n                    if (\n                        self.active_page == self.attributes_page\n                        and (self.object_info is None or not self.object_info.get(\"attributes\"))\n                        and self.object_id is not None\n                    ):\n                        self.request_object_info()\n\n            tab.bind(\"<1>\", on_click)\n\n        # create_tab(1, \"Overview\", self.general_page)\n        create_tab(5, tr(\"Data\"), self.content_page)\n        create_tab(6, tr(\"Attributes\"), self.attributes_page)\n\n        def create_navigation_link(col, image_filename, action, tooltip, padx=0):\n            button = ttk.Button(\n                toolbar,\n                # command=handler,\n                image=get_workbench().get_image(image_filename),\n                style=\"ViewToolbar.Toolbutton\",  # TODO: does this cause problems in some Macs?\n                state=tk.NORMAL,\n            )\n            ui_utils.create_tooltip(button, tooltip)\n\n            button.grid(row=0, column=col, sticky=tk.NE, padx=padx, pady=4)\n            button.bind(\"<Button-1>\", action)\n            return button\n\n        def configure(event):\n            if event.width > 20:\n                self.title_label.configure(wraplength=event.width - 10)\n\n        self.title_label.bind(\"<Configure>\", configure, True)\n\n        self.back_button = create_navigation_link(\n            1, \"nav-backward\", self.navigate_back, tr(\"Previous object\"), (5, 0)\n        )\n        self.forward_button = create_navigation_link(\n            2, \"nav-forward\", self.navigate_forward, tr(\"Next object\")\n        )\n        self.back_links = []\n        self.forward_links = []\n\n        return toolbar", "is_method": true, "class_name": "ObjectInspector", "function_description": "Constructs and configures the ObjectInspector's toolbar with navigation buttons, page tabs, and a dynamic title label to facilitate object viewing, tab switching, and navigation within the interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_create_content_page", "line_number": 123, "body": "def _create_content_page(self):\n        self.content_page = ttk.Frame(self, style=\"ViewBody.TFrame\")\n        # type-specific inspectors\n        self.current_content_inspector = None\n        self.content_inspectors = []\n        # load custom inspectors\n        for insp_class in get_workbench().content_inspector_classes:\n            self.content_inspectors.append(insp_class(self.content_page))\n\n        # read standard inspectors\n        self.content_inspectors.extend(\n            [\n                FileHandleInspector(self.content_page),\n                FunctionInspector(self.content_page),\n                StringInspector(self.content_page),\n                ElementsInspector(self.content_page),\n                DictInspector(self.content_page),\n                ImageInspector(self.content_page),\n                IntInspector(self.content_page),\n                FloatInspector(self.content_page),\n                ReprInspector(self.content_page),  # fallback content inspector\n            ]\n        )\n\n        self.content_page.columnconfigure(0, weight=1)\n        self.content_page.rowconfigure(0, weight=1)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Sets up the content display page and initializes various type-specific inspector components for dynamically inspecting different object types within the ObjectInspector interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_create_attributes_page", "line_number": 150, "body": "def _create_attributes_page(self):\n        self.attributes_page = AttributesFrame(self)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Private method in ObjectInspector that initializes the attributes_page with a new AttributesFrame instance, setting up the attribute display component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "navigate_back", "line_number": 153, "body": "def navigate_back(self, event):\n        if len(self.back_links) == 0:\n            return\n\n        self.forward_links.append(self.object_id)\n        self._show_object_by_id(self.back_links.pop(), True)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Method of ObjectInspector that navigates back to the previous inspected object, updating navigation history to allow forward navigation. It enables traversal through the object's inspection history in a user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "navigate_forward", "line_number": 160, "body": "def navigate_forward(self, event):\n        if len(self.forward_links) == 0:\n            return\n\n        self.back_links.append(self.object_id)\n        self._show_object_by_id(self.forward_links.pop(), True)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Provides forward navigation through previously viewed objects, updating navigation history to enable moving ahead after backtracking within the ObjectInspector context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "show_object", "line_number": 167, "body": "def show_object(self, event):\n        self._show_object_by_id(event.object_id)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Simple wrapper method in ObjectInspector that triggers displaying an object based on its ID from an event, facilitating object lookup and visualization within event-driven contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_show_object_by_id", "line_number": 170, "body": "def _show_object_by_id(self, object_id, via_navigation=False):\n        assert object_id is not None\n\n        if self.winfo_ismapped() and self.object_id != object_id:\n            if not via_navigation and self.object_id is not None:\n                if self.object_id in self.back_links:\n                    self.back_links.remove(self.object_id)\n                self.back_links.append(self.object_id)\n                del self.forward_links[:]\n\n            context_id = self.object_id\n            self.object_id = object_id\n            self.set_object_info(None)\n            self._set_title(\"object @ \" + thonny.memory.format_object_id(object_id))\n            self.request_object_info(context_id=context_id)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Updates the displayed object in the inspector view by its ID, managing navigation history to support back and forward traversal of inspected objects. It helps maintain context while switching views in an object inspection UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_on_backend_restart", "line_number": 186, "body": "def _on_backend_restart(self, event=None):\n        self.set_object_info(None)\n        self.object_id = None", "is_method": true, "class_name": "ObjectInspector", "function_description": "Resets the inspected object information and identifier when the backend system restarts, ensuring the ObjectInspector reflects the current backend state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_set_title", "line_number": 190, "body": "def _set_title(self, text):\n        self.title_label.configure(text=text)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Private method of ObjectInspector that sets the display text of the title label, updating the UI component to reflect the given text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_handle_object_info_event", "line_number": 193, "body": "def _handle_object_info_event(self, msg):\n        if self.winfo_ismapped():\n            if msg.get(\"error\") and not msg.get(\"info\"):\n                self.set_object_info({\"error\": msg[\"error\"]})\n                return\n\n            if msg.info[\"id\"] == self.object_id:\n                if hasattr(msg, \"not_found\") and msg.not_found:\n                    self.object_id = None\n                    self.set_object_info(None)\n                else:\n                    self.set_object_info(msg.info)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Internal method of ObjectInspector that processes incoming object info events to update or clear the displayed object information based on event content and object identity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_handle_progress_event", "line_number": 206, "body": "def _handle_progress_event(self, event):\n        if self.object_id is not None:\n            # refresh\n            self.request_object_info()", "is_method": true, "class_name": "ObjectInspector", "function_description": "Private method of the ObjectInspector class that triggers a refresh of object information upon receiving a progress event, ensuring the object data remains up-to-date during processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "request_object_info", "line_number": 211, "body": "def request_object_info(self, context_id=None):\n        # current width and height of the frame are required for\n        # some content providers\n        if self.active_page is not None:\n            frame_width = self.active_page.winfo_width()\n            frame_height = self.active_page.winfo_height()\n\n            # in some cases measures are inaccurate\n            if frame_width < 5 or frame_height < 5:\n                frame_width = None\n                frame_height = None\n        else:\n            frame_width = None\n            frame_height = None\n\n        get_runner().send_command(\n            InlineCommand(\n                \"get_object_info\",\n                object_id=self.object_id,\n                context_id=context_id,\n                back_links=self.back_links,\n                forward_links=self.forward_links,\n                include_attributes=self.active_page == self.attributes_page,\n                all_attributes=False,\n                frame_width=frame_width,\n                frame_height=frame_height,\n            )\n        )", "is_method": true, "class_name": "ObjectInspector", "function_description": "Utility method of ObjectInspector that requests detailed information about an object, optionally considering UI frame dimensions and navigation links, to support context-aware inspection or attribute retrieval in the active interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 240, "body": "def set_object_info(self, object_info):\n        self.object_info = object_info\n        if object_info is None or \"error\" in object_info:\n            if object_info is None:\n                self._set_title(\"\")\n            else:\n                self._set_title(object_info[\"error\"])\n            if self.current_content_inspector is not None:\n                self.current_content_inspector.grid_remove()\n                self.current_content_inspector = None\n            self.attributes_page.clear()\n        else:\n            self._set_title(\n                object_info[\"full_type_name\"]\n                + \" @ \"\n                + thonny.memory.format_object_id(object_info[\"id\"])\n            )\n            self.attributes_page.update_variables(object_info[\"attributes\"])\n            self.attributes_page.context_id = object_info[\"id\"]\n            self.update_type_specific_info(object_info)\n\n            # update layout\n            # self._expose(None)\n            # if not self.grid_frame.winfo_ismapped():\n            #    self.grid_frame.grid()\n\n        \"\"\"\n        if self.back_links == []:\n            self.back_label.config(foreground=\"lightgray\", cursor=\"arrow\")\n        else:\n            self.back_label.config(foreground=\"blue\", cursor=\"hand2\")\n\n        if self.forward_links == []:\n            self.forward_label.config(foreground=\"lightgray\", cursor=\"arrow\")\n        else:\n            self.forward_label.config(foreground=\"blue\", cursor=\"hand2\")\n        \"\"\"", "is_method": true, "class_name": "ObjectInspector", "function_description": "Updates the inspector's display and internal state based on provided object information, handling errors and showing type-specific details and attributes for the inspected object. It supports dynamic UI updates reflecting the current object's metadata and attributes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "update_type_specific_info", "line_number": 278, "body": "def update_type_specific_info(self, object_info):\n        content_inspector = None\n        for insp in self.content_inspectors:\n            if insp.applies_to(object_info):\n                content_inspector = insp\n                break\n\n        if content_inspector != self.current_content_inspector:\n            if self.current_content_inspector is not None:\n                self.current_content_inspector.grid_remove()  # TODO: or forget?\n                self.current_content_inspector = None\n\n            if content_inspector is not None:\n                content_inspector.grid(row=0, column=0, sticky=tk.NSEW, padx=(0, 0))\n\n            self.current_content_inspector = content_inspector\n\n        if self.current_content_inspector is not None:\n            self.current_content_inspector.set_object_info(object_info)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Updates the ObjectInspector's display by selecting and showing the appropriate content inspector for the given object information, ensuring the interface reflects the object's specific type details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "get_tab_text", "line_number": 306, "body": "def get_tab_text(self):\n        return \"Data\"", "is_method": true, "class_name": "ContentInspector", "function_description": "Returns a fixed string label \"Data\" typically used for tab identification or display within the ContentInspector context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 309, "body": "def applies_to(self, object_info):\n        return False", "is_method": true, "class_name": "ContentInspector", "function_description": "Returns False unconditionally, indicating this function currently applies to no objects; serves as a placeholder or default method to be overridden."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 322, "body": "def applies_to(self, object_info):\n        return \"file_content\" in object_info or \"file_error\" in object_info", "is_method": true, "class_name": "FileHandleInspector", "function_description": "Checks if the given object information relates to file content or file errors, indicating applicability to file handling scenarios."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 325, "body": "def set_object_info(self, object_info):\n\n        if \"file_content\" not in object_info:\n            logging.exception(\"File error: \" + object_info[\"file_error\"])\n            return\n\n        assert \"file_content\" in object_info\n        content = object_info[\"file_content\"]\n        line_count_sep = len(content.split(\"\\n\"))\n        # line_count_term = len(content.splitlines())\n        # char_count = len(content)\n        self.text.configure(height=min(line_count_sep, 10))\n        self.text.set_content(content)\n\n        assert \"file_tell\" in object_info\n        # f.tell() gives num of bytes read (minus some magic with linebreaks)\n\n        file_bytes = content.encode(encoding=object_info[\"file_encoding\"])\n        bytes_read = file_bytes[0 : object_info[\"file_tell\"]]\n        read_content = bytes_read.decode(encoding=object_info[\"file_encoding\"])\n        read_char_count = len(read_content)\n        # read_line_count_term = (len(content.splitlines())\n        #                        - len(content[read_char_count:].splitlines()))\n\n        pos_index = \"1.0+\" + str(read_char_count) + \"c\"\n        self.text.tag_add(\"read\", \"1.0\", pos_index)\n        self.text.see(pos_index)\n\n        # TODO: show this info somewhere\n        \"\"\"\n        label.configure(text=\"Read %d/%d %s, %d/%d %s\"\n                        % (read_char_count,\n                           char_count,\n                           \"symbol\" if char_count == 1 else \"symbols\",\n                           read_line_count_term,\n                           line_count_term,\n                           \"line\" if line_count_term == 1 else \"lines\"))\n        \"\"\"", "is_method": true, "class_name": "FileHandleInspector", "function_description": "Sets and displays file content in a text widget, highlighting the portion of the file that has been read based on byte position and encoding information. It helps visualize file reading progress within a user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 371, "body": "def applies_to(self, object_info):\n        return \"source\" in object_info", "is_method": true, "class_name": "FunctionInspector", "function_description": "Checks if the given object information contains source code details, indicating applicability to source-based objects."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "get_tab_text", "line_number": 374, "body": "def get_tab_text(self):\n        return \"Code\"", "is_method": true, "class_name": "FunctionInspector", "function_description": "Returns the label \"Code\" to represent the content or category associated with the FunctionInspector instance, likely used for UI tab identification or display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 377, "body": "def set_object_info(self, object_info):\n        line_count = len(object_info[\"source\"].split(\"\\n\"))\n        self.text.configure(height=min(line_count, 15))\n        self.text.set_content(object_info[\"source\"])", "is_method": true, "class_name": "FunctionInspector", "function_description": "Sets and displays source code of an object within a text widget, adjusting the display height based on the source's line count for optimal viewing. This supports inspection and visualization of code snippets."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 390, "body": "def applies_to(self, object_info):\n        return object_info[\"type\"] == repr(str)", "is_method": true, "class_name": "StringInspector", "function_description": "Determines if the given object information corresponds to a string type. This method helps identify or filter string objects based on their type representation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 393, "body": "def set_object_info(self, object_info):\n        # TODO: don't show too big string\n        try:\n            content = ast.literal_eval(object_info[\"repr\"])\n        except SyntaxError:\n            try:\n                # can be shortened\n                content = ast.literal_eval(object_info[\"repr\"] + object_info[\"repr\"][0:1])\n            except SyntaxError:\n                content = \"<can't show string content>\"\n\n        line_count_sep = len(content.split(\"\\n\"))\n        # line_count_term = len(content.splitlines())\n        self.text.configure(height=min(line_count_sep, 10))\n        self.text.set_content(content)\n        \"\"\" TODO:\n        label.configure(text=\"%d %s, %d %s\"\n                        % (len(content),\n                           \"symbol\" if len(content) == 1 else \"symbols\",\n                           line_count_term,\n                           \"line\" if line_count_term == 1 else \"lines\"))\n        \"\"\"", "is_method": true, "class_name": "StringInspector", "function_description": "Sets and formats a string representation of an object for display, adjusting the display height based on content length while handling cases where the string content may be too large or improperly formatted."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 424, "body": "def applies_to(self, object_info):\n        return object_info[\"type\"] == repr(int)", "is_method": true, "class_name": "IntInspector", "function_description": "Method of IntInspector that determines whether a given object's type corresponds to an integer, enabling type-specific processing or inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 427, "body": "def set_object_info(self, object_info):\n        content = ast.literal_eval(object_info[\"repr\"])\n        self.text.set_content(\n            object_info[\"repr\"]\n            + \"\\n\\n\"\n            + \"bin: \"\n            + bin(content)\n            + \"\\n\"\n            + \"oct: \"\n            + oct(content)\n            + \"\\n\"\n            + \"hex: \"\n            + hex(content)\n            + \"\\n\"\n        )", "is_method": true, "class_name": "IntInspector", "function_description": "Service method of IntInspector that updates display content to show an object's integer representation alongside its binary, octal, and hexadecimal forms for inspection or debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 456, "body": "def applies_to(self, object_info):\n        return object_info[\"type\"] == repr(float)", "is_method": true, "class_name": "FloatInspector", "function_description": "Determines if the given object information corresponds to a float type, enabling type-specific inspection within the FloatInspector class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 459, "body": "def set_object_info(self, object_info):\n        content = object_info[\"repr\"] + \"\\n\\n\\n\"\n\n        if \"as_integer_ratio\" in object_info:\n            ratio = object_info[\"as_integer_ratio\"]\n            from decimal import Decimal\n\n            ratio_dec_str = str(Decimal(ratio[0]) / Decimal(ratio[1]))\n\n            if ratio_dec_str != object_info[\"repr\"]:\n                explanation = tr(\n                    \"The representation above is an approximate value of this float. \"\n                    \"The exact stored value is %s which is about %s\"\n                )\n\n                content += explanation % (\n                    \"\\n\\n  %d / %d\\n\\n\" % ratio,\n                    \"\\n\\n  %s\\n\\n\" % ratio_dec_str,\n                )\n\n        self.text.set_content(content)", "is_method": true, "class_name": "FloatInspector", "function_description": "Sets detailed textual information about a float object, including its string representation and an explanation of its exact stored value if it differs from the approximate representation. This supports clear inspection of float precision and value details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 489, "body": "def applies_to(self, object_info):\n        return True", "is_method": true, "class_name": "ReprInspector", "function_description": "Always returns True, indicating this inspector is applicable to any given object information without restriction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 492, "body": "def set_object_info(self, object_info):\n        # TODO: don't show too big string\n        content = object_info[\"repr\"]\n        self.text.set_content(content)\n        \"\"\"\n        line_count_sep = len(content.split(\"\\n\"))\n        line_count_term = len(content.splitlines())\n        self.text.configure(height=min(line_count_sep, 10))\n        label.configure(text=\"%d %s, %d %s\"\n                        % (len(content),\n                           \"symbol\" if len(content) == 1 else \"symbols\",\n                           line_count_term,\n                           \"line\" if line_count_term == 1 else \"lines\"))\n        \"\"\"", "is_method": true, "class_name": "ReprInspector", "function_description": "Sets and displays a textual representation of an object within the ReprInspector interface, updating the display content based on provided object information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "update_memory_model", "line_number": 534, "body": "def update_memory_model(self, event=None):\n        self._update_columns()", "is_method": true, "class_name": "ElementsInspector", "function_description": "Updates the internal data model by refreshing its column definitions, ensuring the ElementsInspector's state stays current with underlying data changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_update_columns", "line_number": 537, "body": "def _update_columns(self):\n        if get_workbench().in_heap_mode():\n            if self.elements_have_indices:\n                self.tree.configure(displaycolumns=(\"index\", \"id\"))\n            else:\n                self.tree.configure(displaycolumns=(\"id\",))\n        else:\n            if self.elements_have_indices:\n                self.tree.configure(displaycolumns=(\"index\", \"value\"))\n            else:\n                self.tree.configure(displaycolumns=(\"value\"))", "is_method": true, "class_name": "ElementsInspector", "function_description": "Internal method of ElementsInspector that updates the displayed columns of a tree view based on the current mode and whether elements have indices, ensuring the UI reflects the relevant element attributes appropriately."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 549, "body": "def applies_to(self, object_info):\n        return \"elements\" in object_info", "is_method": true, "class_name": "ElementsInspector", "function_description": "Determines if the provided object information pertains to or includes an \"elements\" attribute. This method helps identify applicable objects for further processing within ElementsInspector."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "on_double_click", "line_number": 555, "body": "def on_double_click(self, event):\n        self.show_selected_object_info()", "is_method": true, "class_name": "ElementsInspector", "function_description": "Handles double-click events by displaying information about the currently selected object, facilitating user interaction and inspection within the ElementsInspector interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 558, "body": "def set_object_info(self, object_info):\n        assert \"elements\" in object_info\n\n        self.elements_have_indices = object_info[\"type\"] in (repr(tuple), repr(list))\n        self._update_columns()\n        self.context_id = object_info[\"id\"]\n\n        self._clear_tree()\n        index = 0\n        # TODO: don't show too big number of elements\n        for element in object_info[\"elements\"]:\n            node_id = self.tree.insert(\"\", \"end\")\n            if self.elements_have_indices:\n                self.tree.set(node_id, \"index\", index)\n            else:\n                self.tree.set(node_id, \"index\", \"\")\n\n            self.tree.set(node_id, \"id\", thonny.memory.format_object_id(element.id))\n            self.tree.set(\n                node_id, \"value\", shorten_repr(element.repr, thonny.memory.MAX_REPR_LENGTH_IN_GRID)\n            )\n            index += 1\n\n        count = len(object_info[\"elements\"])\n        self.len_label.configure(text=\" len: %d\" % count)", "is_method": true, "class_name": "ElementsInspector", "function_description": "Method of ElementsInspector that initializes and displays information about elements from a given object, updating a tree view and label to reflect element indices, IDs, and shortened representations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "update_memory_model", "line_number": 609, "body": "def update_memory_model(self, event=None):\n        if get_workbench().in_heap_mode():\n            self.tree.configure(displaycolumns=(\"key_id\", \"id\"))\n        else:\n            self.tree.configure(displaycolumns=(\"key\", \"value\"))", "is_method": true, "class_name": "DictInspector", "function_description": "This method updates the display configuration of a UI tree component based on the current memory mode, toggling which columns are shown. It enables dynamic adjustment of the view to reflect different data representations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 615, "body": "def applies_to(self, object_info):\n        return \"entries\" in object_info", "is_method": true, "class_name": "DictInspector", "function_description": "Checks if the given object information contains an \"entries\" key, indicating applicability. Useful for determining if an object conforms to a dictionary-like structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "on_double_click", "line_number": 621, "body": "def on_double_click(self, event):\n        # NB! this selects value\n        self.show_selected_object_info()", "is_method": true, "class_name": "DictInspector", "function_description": "Handles double-click events by triggering display of information about the currently selected dictionary object, facilitating interactive inspection of dictionary contents."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 625, "body": "def set_object_info(self, object_info):\n        assert \"entries\" in object_info\n        self.context_id = object_info[\"id\"]\n\n        self._clear_tree()\n        # TODO: don't show too big number of elements\n        for key, value in object_info[\"entries\"]:\n            node_id = self.tree.insert(\"\", \"end\")\n            self.tree.set(node_id, \"key_id\", thonny.memory.format_object_id(key.id))\n            self.tree.set(\n                node_id, \"key\", shorten_repr(key.repr, thonny.memory.MAX_REPR_LENGTH_IN_GRID)\n            )\n            self.tree.set(node_id, \"id\", thonny.memory.format_object_id(value.id))\n            self.tree.set(\n                node_id, \"value\", shorten_repr(value.repr, thonny.memory.MAX_REPR_LENGTH_IN_GRID)\n            )\n\n        count = len(object_info[\"entries\"])\n        self.len_label.configure(text=\" len: %d\" % count)\n        self.update_memory_model()", "is_method": true, "class_name": "DictInspector", "function_description": "Sets and displays detailed information about dictionary-like objects in the DictInspector, including keys and values, updating the visual representation and related metadata accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 656, "body": "def set_object_info(self, object_info):\n        if isinstance(object_info[\"image_data\"], bytes):\n            import base64\n\n            data = base64.b64encode(object_info[\"image_data\"])\n        elif isinstance(object_info[\"image_data\"], str):\n            data = object_info[\"image_data\"]\n        else:\n            self.label.configure(\n                image=None, text=\"Unsupported image data (%s)\" % type(object_info[\"image_data\"])\n            )\n            return\n\n        try:\n            self.image = tk.PhotoImage(data=data)\n            self.label.configure(image=self.image)\n        except Exception as e:\n            self.label.configure(image=None, text=\"Unsupported image data (%s)\" % e)", "is_method": true, "class_name": "ImageInspector", "function_description": "Sets and displays an image in the ImageInspector from raw bytes or a base64 string, updating the UI label accordingly while handling unsupported data types or errors gracefully."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 675, "body": "def applies_to(self, object_info):\n        return \"image_data\" in object_info", "is_method": true, "class_name": "ImageInspector", "function_description": "Checks if the given object contains image data by verifying the presence of the \"image_data\" key. This function helps determine if the ImageInspector class should process the object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "on_double_click", "line_number": 687, "body": "def on_double_click(self, event):\n        self.show_selected_object_info()", "is_method": true, "class_name": "AttributesFrame", "function_description": "Handles a double-click event by displaying detailed information about the currently selected object, facilitating interactive inspection within the AttributesFrame context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "show_selected_object_info", "line_number": 690, "body": "def show_selected_object_info(self):\n        object_id = self.get_object_id()\n        if object_id is None:\n            return\n\n        iid = self.tree.focus()\n        if not iid:\n            return\n        repr_str = self.tree.item(iid)[\"values\"][2]\n\n        if repr_str == \"<bound_method>\":\n            from thonny.plugins.micropython import MicroPythonProxy\n\n            if isinstance(get_runner().get_backend_proxy(), MicroPythonProxy):\n                messagebox.showinfo(\n                    \"Not supported\",\n                    \"Inspecting bound methods is not supported with MicroPython\",\n                    master=self,\n                )\n                return\n\n        get_workbench().event_generate(\"ObjectSelect\", object_id=object_id)", "is_method": true, "class_name": "AttributesFrame", "function_description": "Provides detailed information about the currently selected object in the AttributesFrame, handling special cases and triggering an event to notify other components of the selection change."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "create_tab", "line_number": 58, "body": "def create_tab(col, caption, page):\n            if page == self.active_page:\n                style = \"Active.ViewTab.TLabel\"\n            else:\n                style = \"Inactive.ViewTab.TLabel\"\n            tab = ttk.Label(toolbar, text=caption, style=style)\n            tab.grid(row=0, column=col, pady=5, padx=5, sticky=\"nsew\")\n            self.tabs.append(tab)\n            page.tab = tab\n\n            def on_click(event):\n                if self.active_page == page:\n                    return\n                else:\n                    if self.active_page is not None:\n                        self.active_page.grid_forget()\n                        self.active_page.tab.configure(style=\"Inactive.ViewTab.TLabel\")\n\n                    self.active_page = page\n                    page.grid(row=1, column=0, sticky=\"nsew\", padx=0)\n                    tab.configure(style=\"Active.ViewTab.TLabel\")\n                    if (\n                        self.active_page == self.attributes_page\n                        and (self.object_info is None or not self.object_info.get(\"attributes\"))\n                        and self.object_id is not None\n                    ):\n                        self.request_object_info()\n\n            tab.bind(\"<1>\", on_click)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Creates and manages a clickable tab in the ObjectInspector's toolbar that switches the visible page and updates tab styles accordingly. It facilitates user navigation between different views while optionally triggering object info retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "create_navigation_link", "line_number": 92, "body": "def create_navigation_link(col, image_filename, action, tooltip, padx=0):\n            button = ttk.Button(\n                toolbar,\n                # command=handler,\n                image=get_workbench().get_image(image_filename),\n                style=\"ViewToolbar.Toolbutton\",  # TODO: does this cause problems in some Macs?\n                state=tk.NORMAL,\n            )\n            ui_utils.create_tooltip(button, tooltip)\n\n            button.grid(row=0, column=col, sticky=tk.NE, padx=padx, pady=4)\n            button.bind(\"<Button-1>\", action)\n            return button", "is_method": true, "class_name": "ObjectInspector", "function_description": "Creates and returns a styled toolbar button with an image, tooltip, and click action, facilitating user navigation within the ObjectInspector interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "configure", "line_number": 106, "body": "def configure(event):\n            if event.width > 20:\n                self.title_label.configure(wraplength=event.width - 10)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Updates the title label's wrap length based on the event's width to ensure proper text wrapping in the ObjectInspector UI component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "on_click", "line_number": 68, "body": "def on_click(event):\n                if self.active_page == page:\n                    return\n                else:\n                    if self.active_page is not None:\n                        self.active_page.grid_forget()\n                        self.active_page.tab.configure(style=\"Inactive.ViewTab.TLabel\")\n\n                    self.active_page = page\n                    page.grid(row=1, column=0, sticky=\"nsew\", padx=0)\n                    tab.configure(style=\"Active.ViewTab.TLabel\")\n                    if (\n                        self.active_page == self.attributes_page\n                        and (self.object_info is None or not self.object_info.get(\"attributes\"))\n                        and self.object_id is not None\n                    ):\n                        self.request_object_info()", "is_method": true, "class_name": "ObjectInspector", "function_description": "Handles tab click events in ObjectInspector, switching the active page and updating UI styles. It triggers fetching object info when the attributes page is activated but lacks current attribute data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/general_config_page.py", "function": "load_plugin", "line_number": 128, "body": "def load_plugin() -> None:\n    get_workbench().add_configuration_page(\"general\", tr(\"General\"), GeneralConfigurationPage, 10)", "is_method": false, "function_description": "Adds a general configuration page to the workbench interface, enabling users to access and modify general settings within the plugin environment. It integrates UI components into the application framework."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/general_config_page.py", "function": "apply", "line_number": 116, "body": "def apply(self):\n        get_workbench().set_option(\n            \"general.language\", languages.get_language_code_by_name(self._language_name_var.get())\n        )\n        get_workbench().update_debug_mode()\n\n        env = []\n        for entry in self.env_box.text.get(\"1.0\", \"end\").strip(\"\\r\\n\").splitlines():\n            env.append(entry.strip(\"\\r\\n\"))\n        get_workbench().set_option(\"general.environment\", env)", "is_method": true, "class_name": "GeneralConfigurationPage", "function_description": "Method of GeneralConfigurationPage that applies user-selected language and environment settings to the application, updating relevant options and debug mode accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "load_plugin", "line_number": 145, "body": "def load_plugin() -> None:\n    get_workbench().add_view(OutlineView, tr(\"Outline\"), \"ne\")", "is_method": false, "function_description": "Adds an OutlineView panel to the application's workbench interface, enabling users to view the structure or summary of content within the environment. It enhances the user interface by integrating this focused view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "destroy", "line_number": 26, "body": "def destroy(self):\n        try:\n            # Not sure if editor notebook is still living\n            get_workbench().get_editor_notebook().unbind(\n                \"<<NotebookTabChanged>>\", self._tab_changed_binding\n            )\n        except Exception:\n            pass\n        self.vert_scrollbar[\"command\"] = None\n        ttk.Frame.destroy(self)", "is_method": true, "class_name": "OutlineView", "function_description": "Method in OutlineView that cleans up event bindings and resources when the view is closed or destroyed. It ensures proper unbinding and widget teardown to prevent side effects or memory leaks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_init_widgets", "line_number": 37, "body": "def _init_widgets(self):\n        # init and place scrollbar\n        self.vert_scrollbar = SafeScrollbar(self, orient=tk.VERTICAL)\n        self.vert_scrollbar.grid(row=0, column=1, sticky=tk.NSEW)\n\n        # init and place tree\n        self.tree = ttk.Treeview(self, yscrollcommand=self.vert_scrollbar.set)\n        self.tree.grid(row=0, column=0, sticky=tk.NSEW)\n        self.vert_scrollbar[\"command\"] = self.tree.yview\n\n        # set single-cell frame\n        self.columnconfigure(0, weight=1)\n        self.rowconfigure(0, weight=1)\n\n        # init tree events\n        self.tree.bind(\"<<TreeviewSelect>>\", self._on_select, True)\n        self.tree.bind(\"<Map>\", self._update_frame_contents, True)\n\n        # configure the only tree column\n        self.tree.column(\"#0\", anchor=tk.W, stretch=True)\n        # self.tree.heading('#0', text='Item (type @ line)', anchor=tk.W)\n        self.tree[\"show\"] = (\"tree\",)\n\n        self._class_img = get_workbench().get_image(\"outline-class\")\n        self._method_img = get_workbench().get_image(\"outline-method\")", "is_method": true, "class_name": "OutlineView", "function_description": "Initializes and configures the OutlineView's GUI components, including a scrollbar and a tree view widget, setting up layout, event bindings, and icons for displaying an outline structure visually."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_update_frame_contents", "line_number": 63, "body": "def _update_frame_contents(self, event=None):\n        if not self.winfo_ismapped():\n            return\n\n        self._clear_tree()\n\n        editor = get_workbench().get_editor_notebook().get_current_editor()\n        if editor is None:\n            return\n\n        root = self._parse_source(editor.get_code_view().get_content())\n        for child in root[2]:\n            self._add_item_to_tree(\"\", child)", "is_method": true, "class_name": "OutlineView", "function_description": "Updates the outline view to reflect the current editor's source code structure by clearing the existing content and populating it with parsed elements from the active code. Useful for synchronizing the UI with code changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_parse_source", "line_number": 77, "body": "def _parse_source(self, source):\n        # all nodes in format (parent, node_indent, node_children, name, type, linenumber)\n        root_node = (None, 0, [], None, None, None)  # name, type and linenumber not needed for root\n        active_node = root_node\n\n        lineno = 0\n        for line in source.split(\"\\n\"):\n            lineno += 1\n            m = re.match(r\"[ ]*[\\w]{1}\", line)\n            if m:\n                indent = len(m.group(0))\n                while indent <= active_node[1]:\n                    active_node = active_node[0]\n\n                t = re.match(r\"[ ]*(?P<type>(def|class){1})[ ]+(?P<name>[\\w]+)\", line)\n                if t:\n                    current = (active_node, indent, [], t.group(\"name\"), t.group(\"type\"), lineno)\n                    active_node[2].append(current)\n                    active_node = current\n\n        return root_node", "is_method": true, "class_name": "OutlineView", "function_description": "Core method of OutlineView that parses source code into a hierarchical tree of classes and functions based on indentation, capturing their names, types, and line numbers for structured code outline generation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_add_item_to_tree", "line_number": 100, "body": "def _add_item_to_tree(self, parent, item):\n        # create the text to be played for this item\n        item_type = item[4]\n        item_text = \" \" + item[3]\n\n        if item_type == \"class\":\n            image = self._class_img\n        elif item_type == \"def\":\n            image = self._method_img\n        else:\n            image = None\n\n        # insert the item, set lineno as a 'hidden' value\n        current = self.tree.insert(parent, \"end\", text=item_text, values=item[5], image=image)\n\n        for child in item[2]:\n            self._add_item_to_tree(current, child)", "is_method": true, "class_name": "OutlineView", "function_description": "Private helper method used within OutlineView to recursively add hierarchical items representing code elements (classes, methods) into a tree structure, supporting visual organization of code outlines with appropriate icons."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_clear_tree", "line_number": 119, "body": "def _clear_tree(self):\n        for child_id in self.tree.get_children():\n            self.tree.delete(child_id)", "is_method": true, "class_name": "OutlineView", "function_description": "Clears all items from the OutlineView's tree structure, effectively resetting the displayed outline content. This is useful for refreshing or initializing the view before loading new data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_on_select", "line_number": 123, "body": "def _on_select(self, event):\n        editor = get_workbench().get_editor_notebook().get_current_editor()\n        if editor:\n            code_view = editor.get_code_view()\n            focus = self.tree.focus()\n            if not focus:\n                return\n\n            values = self.tree.item(focus)[\"values\"]\n            if not values:\n                return\n\n            lineno = values[0]\n            index = code_view.text.index(str(lineno) + \".0\")\n            code_view.text.see(index)  # make sure that the double-clicked item is visible\n            code_view.text.select_lines(lineno, lineno)\n\n            get_workbench().event_generate(\n                \"OutlineDoubleClick\", item_text=self.tree.item(self.tree.focus(), option=\"text\")\n            )", "is_method": true, "class_name": "OutlineView", "function_description": "Handles selection events in OutlineView by syncing the editor's code view to the selected outline item and triggering a related event for UI interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "transpose_path", "line_number": 418, "body": "def transpose_path(\n    source_path: str,\n    source_dir: str,\n    target_dir: str,\n    source_path_class: Type[PurePath],\n    target_path_class: Type[PurePath],\n) -> str:\n    assert not source_dir.endswith(\":\")\n    source_path_parts = source_path_class(source_path).parts\n    source_dir_parts = source_path_class(source_dir).parts\n    assert source_path_parts[: len(source_dir_parts)] == source_dir_parts\n    source_suffix_parts = source_path_parts[len(source_dir_parts) :]\n\n    target = target_path_class(target_dir).joinpath(*source_suffix_parts)\n    return str(target)", "is_method": false, "function_description": "Function that converts a file path from one directory and path style to another, preserving the relative subpath. It enables seamless path translation between different path representations or root directories."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "pick_transfer_items", "line_number": 435, "body": "def pick_transfer_items(\n    prepared_items: List[Dict], existing_target_items: Dict[str, Dict], master\n) -> List[Dict]:\n    if not existing_target_items:\n        return prepared_items\n\n    errors = []\n    overwrites = []\n\n    for item in prepared_items:\n        if item[\"target_path\"] in existing_target_items:\n            target_info = existing_target_items[item[\"target_path\"]]\n            if item[\"kind\"] != target_info[\"kind\"]:\n                errors.append(\n                    \"Can't overwrite '%s' with '%s', because former is a %s but latter is a %s\"\n                    % (item[\"target_path\"], item[\"source_path\"], target_info[\"kind\"], item[\"kind\"])\n                )\n            elif item[\"kind\"] == \"file\":\n                size_diff = item[\"size\"] - target_info[\"size\"]\n                if size_diff > 0:\n                    replacement = \"a larger file (%s + %s)\" % (\n                        sizeof_fmt(target_info[\"size\"]),\n                        sizeof_fmt(size_diff),\n                    )\n                elif size_diff < 0:\n                    replacement = \"a smaller file (%s - %s)\" % (\n                        sizeof_fmt(target_info[\"size\"]),\n                        sizeof_fmt(-size_diff),\n                    )\n                else:\n                    replacement = \"a file of same size (%s)\" % sizeof_fmt(target_info[\"size\"])\n\n                overwrites.append(\"'%s' with %s\" % (item[\"target_path\"], replacement))\n\n    if errors:\n        showerror(\"Error\", format_items(errors), master=master)\n        return []\n    elif overwrites:\n        if askokcancel(\n            \"Overwrite?\",\n            \"This operation will overwrite\\n\\n\" + format_items(overwrites),\n            master=master,\n        ):\n            return prepared_items\n        else:\n            return []\n    else:\n        return prepared_items", "is_method": false, "function_description": "Selects which items to transfer by checking for conflicts or overwrites with existing target items, prompting the user to confirm replacements or cancel the operation if errors occur. It ensures safe and user-approved file or item transfers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "format_items", "line_number": 485, "body": "def format_items(items):\n    max_count = 10\n    if len(items) == 1:\n        return items[0]\n    msg = \"\u2022 \" + \"\\n\u2022 \".join(items[:max_count])\n    if len(items) > max_count:\n        msg += \"\\n ... %d more ...\"\n\n    return msg", "is_method": false, "function_description": "Function that formats a list of items into a bulleted string, showing up to 10 items and indicating if more items exist. Useful for concise display of lists in textual user interfaces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "upload", "line_number": 496, "body": "def upload(paths, target_dir, master) -> bool:\n    dlg = UploadDialog(master, paths, target_dir)\n    ui_utils.show_dialog(dlg)\n    return dlg.response is not None", "is_method": false, "function_description": "This function opens a user interface dialog to upload files from given paths to a target directory and returns whether the upload was confirmed. It facilitates interactive file upload operations within a GUI environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "prepare_upload_items", "line_number": 502, "body": "def prepare_upload_items(\n    source_path: str, source_context_dir: str, target_dir: str\n) -> Iterable[Dict]:\n    # assuming target system has Posix paths\n    if os.path.isdir(source_path):\n        kind = \"dir\"\n        size = None\n    else:\n        kind = \"file\"\n        size = os.path.getsize(source_path)\n\n    result = [\n        {\n            \"kind\": kind,\n            \"size\": size,\n            \"source_path\": source_path,\n            \"target_path\": transpose_path(\n                source_path, source_context_dir, target_dir, pathlib.Path, PurePosixPath\n            ),\n        }\n    ]\n\n    if os.path.isdir(source_path):\n        for child in os.listdir(source_path):\n            if child not in IGNORED_FILES_AND_DIRS:\n                result.extend(\n                    prepare_upload_items(\n                        os.path.join(source_path, child), source_context_dir, target_dir\n                    )\n                )\n    return result", "is_method": false, "function_description": "Function that recursively prepares a list of dictionaries describing files and directories for upload, including their source and target paths and sizes, facilitating consistent transfer to a POSIX-based target system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "get_transfer_description", "line_number": 535, "body": "def get_transfer_description(verb, paths, target_dir):\n    if len(paths) == 1:\n        subject = \"'%s'\" % paths[0]\n    else:\n        subject = \"%d items\" % len(paths)\n\n    return \"%s %s to %s\" % (verb, subject, target_dir)", "is_method": false, "function_description": "Constructs a concise textual description of a file transfer action, summarizing what is moved, the action performed, and the destination directory. Useful for logging or user interface feedback during file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "load_plugin", "line_number": 544, "body": "def load_plugin() -> None:\n    get_workbench().set_default(\n        \"file.last_browser_folder\", normpath_with_actual_case(os.path.expanduser(\"~\"))\n    )\n\n    get_workbench().set_default(HIDDEN_FILES_OPTION, False)\n\n    get_workbench().add_view(FilesView, tr(\"Files\"), \"nw\")\n\n    for ext in [\".py\", \".pyw\", \".pyi\", \".txt\", \".log\", \".json\", \".yml\", \".yaml\", \".md\", \".rst\"]:\n        get_workbench().set_default(get_file_handler_conf_key(ext), \"thonny\")", "is_method": false, "function_description": "Initialize and configure the plugin by setting default file browser paths, visibility options, registering the file view, and associating specific file extensions with the Thonny editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_show", "line_number": 52, "body": "def on_show(self):\n        self.reset_remote()\n        self.local_files.refresh_tree()", "is_method": true, "class_name": "FilesView", "function_description": "Resets remote data and refreshes the local files display when the view is shown, ensuring the file list is up-to-date in the FilesView interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "reset_remote", "line_number": 56, "body": "def reset_remote(self, msg=None):\n        runner = get_runner()\n        if not runner:\n            return\n\n        proxy = runner.get_backend_proxy()\n        if not proxy:\n            self.hide_remote()\n            return\n\n        if proxy.supports_remote_files():\n            # remote pane is needed\n            if not self.remote_added:\n                self.add(self.remote_files, minsize=minsize)\n                self.remote_added = True\n                self.restore_split()\n            self.remote_files.clear()\n            self.remote_files.check_update_focus()\n        else:\n            # remote pane not needed\n            self.hide_remote()", "is_method": true, "class_name": "FilesView", "function_description": "Manages the visibility and state of the remote files pane based on backend support, ensuring the interface dynamically adapts to whether remote files are accessible or not."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "hide_remote", "line_number": 78, "body": "def hide_remote(self):\n        if self.remote_added:\n            self.save_split()\n            self.remove(self.remote_files)\n            self.remote_added = False", "is_method": true, "class_name": "FilesView", "function_description": "Method of FilesView that hides remote files by removing them from the current view and updating internal state to reflect their removal."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "save_split", "line_number": 84, "body": "def save_split(self):\n        _, y = self.sash_coord(0)\n        get_workbench().set_option(\"view.files_split\", y)", "is_method": true, "class_name": "FilesView", "function_description": "Method of FilesView that saves the current vertical split position of the files view to user settings for consistent layout across sessions. It enables persistent customization of the files panel size within the workspace."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "restore_split", "line_number": 88, "body": "def restore_split(self):\n        split = get_workbench().get_option(\"view.files_split\", None)\n        if split is None:\n            if self.winfo_height() > 5:\n                split = int(self.winfo_height() * 0.66)\n            else:\n                split = 600\n\n        self.sash_place(0, 0, split)", "is_method": true, "class_name": "FilesView", "function_description": "Restores the vertical split position of a file view by retrieving a saved setting or applying a default based on the view's height, ensuring consistent layout appearance across sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_backend_restart", "line_number": 98, "body": "def on_backend_restart(self, event):\n        if event.get(\"full\"):\n            self.reset_remote(event)", "is_method": true, "class_name": "FilesView", "function_description": "Handles backend restart events by triggering a remote reset when a full restart occurs, ensuring the FilesView stays synchronized with backend state changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_backend_terminate", "line_number": 102, "body": "def on_backend_terminate(self, event):\n        self.reset_remote(event)", "is_method": true, "class_name": "FilesView", "function_description": "Handles backend termination events by triggering a remote reset, ensuring proper cleanup or state reset within the FilesView context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_workbench_close", "line_number": 105, "body": "def on_workbench_close(self, event=None):\n        if self.remote_added:\n            self.save_split()", "is_method": true, "class_name": "FilesView", "function_description": "Handles cleanup when the workbench closes by saving the split layout if a remote file was added, ensuring the current workspace state is preserved."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "get_active_local_dir", "line_number": 109, "body": "def get_active_local_dir(self):\n        return self.local_files.get_active_directory()", "is_method": true, "class_name": "FilesView", "function_description": "Returns the currently active local directory managed within the FilesView instance, enabling other components to access or manipulate files in this directory context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "get_active_remote_dir", "line_number": 112, "body": "def get_active_remote_dir(self):\n        if self.remote_added:\n            return self.remote_files.get_active_directory()\n        else:\n            return None", "is_method": true, "class_name": "FilesView", "function_description": "Returns the currently active directory from remote files if a remote source is added; otherwise, returns None. This supports file navigation by providing access to the active remote directory within the FilesView context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "destroy", "line_number": 118, "body": "def destroy(self):\n        get_workbench().unbind(\"BackendTerminated\", self.on_backend_terminate)\n        get_workbench().unbind(\"BackendRestart\", self.on_backend_restart)\n        get_workbench().unbind(\"WorkbenchClose\", self.on_workbench_close)\n        super().destroy()", "is_method": true, "class_name": "FilesView", "function_description": "Service method of the FilesView class that unregisters event handlers related to backend and workbench lifecycle before performing cleanup during object destruction. It ensures proper resource release when the view is closed or terminated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "is_active_browser", "line_number": 130, "body": "def is_active_browser(self):\n        return True", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Returns True to indicate that the ActiveLocalFileBrowser instance is currently active or in use. This method can help other components verify the browser's active status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "create_new_file", "line_number": 133, "body": "def create_new_file(self):\n        path = super().create_new_file()\n        if path and path.endswith(\".py\"):\n            get_workbench().get_editor_notebook().show_file(path)", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Utility method of ActiveLocalFileBrowser that creates a new file and opens it in the editor notebook if it is a Python source file (.py)."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "get_proposed_new_file_name", "line_number": 138, "body": "def get_proposed_new_file_name(self, folder, extension):\n        base = \"new_file\"\n\n        if os.path.exists(os.path.join(folder, base + extension)):\n            i = 2\n\n            while True:\n                name = base + \"_\" + str(i) + extension\n                path = os.path.join(folder, name)\n                if os.path.exists(path):\n                    i += 1\n                else:\n                    return name\n        else:\n            return base + extension", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Provides a unique new file name in a given folder by appending an incrementing number if a default name already exists, preventing filename conflicts when creating new files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "request_focus_into", "line_number": 154, "body": "def request_focus_into(self, path):\n        if path == \"\":\n            if running_on_windows():\n                # list of drives, can't cd\n                self.focus_into(path)\n                return\n            else:\n                path = \"/\"\n\n        if not os.path.isdir(path):\n            return\n\n        proxy = get_runner().get_backend_proxy()\n        if (\n            proxy\n            and proxy.uses_local_filesystem()\n            and proxy.get_cwd() != path\n            and get_runner().is_waiting_toplevel_command()\n        ):\n            get_shell().submit_magic_command(construct_cd_command(normpath_with_actual_case(path)))\n        else:\n            # it's OK, if it's already focused into this directory\n            # focus again to refresh\n            self.focus_into(path)\n            get_workbench().set_local_cwd(path)", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Method of ActiveLocalFileBrowser that sets focus to a specified directory path, handling platform-specific cases and updating the local working directory context accordingly. It ensures the file browser and environment reflect the requested directory focus for user navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_toplevel_response", "line_number": 180, "body": "def on_toplevel_response(self, event):\n        self.check_update_focus()", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Triggers a focus update check in response to a top-level event, helping the ActiveLocalFileBrowser maintain correct UI focus state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "check_update_focus", "line_number": 183, "body": "def check_update_focus(self):\n        cwd = get_workbench().get_local_cwd()\n        if cwd != self.current_focus and os.path.isdir(cwd):\n            self.focus_into(cwd)", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "This method updates the browser's current focus to the workbench's local directory if it has changed and is a valid directory, ensuring the local file view stays in sync with the active workspace."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "check_add_upload_command", "line_number": 188, "body": "def check_add_upload_command(self):\n        target_dir = self.master.get_active_remote_dir()\n        if target_dir is None:\n            return\n\n        proxy = get_runner().get_backend_proxy()\n\n        if not proxy.supports_remote_directories():\n            target_dir_desc = proxy.get_node_label()\n        else:\n            target_dir_desc = target_dir\n\n        def _upload():\n            selection = self.get_selection_info(True)\n            if not selection:\n                return\n\n            if \"dir\" in selection[\"kinds\"] and not proxy.supports_remote_directories():\n                messagebox.showerror(\n                    \"Can't upload directory\",\n                    \"%s does not support directories.\\n\" % proxy.get_node_label()\n                    + \"You can only upload files.\",\n                    master=self,\n                )\n            else:\n                if upload(selection[\"paths\"], target_dir, master=self):\n                    self.master.remote_files.refresh_tree()\n\n        self.menu.add_command(label=tr(\"Upload to %s\") % target_dir_desc, command=_upload)", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Adds an \"Upload\" option to the menu that allows users to upload selected files or directories to the active remote directory, with validation based on backend support for remote directories."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "add_middle_menu_items", "line_number": 218, "body": "def add_middle_menu_items(self, context):\n        self.check_add_upload_command()\n        super().add_middle_menu_items(context)", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Adds additional menu items, including upload-related commands, to the browser's middle-click context menu, enhancing user interaction options within the ActiveLocalFileBrowser interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "is_active_browser", "line_number": 229, "body": "def is_active_browser(self):\n        return True", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Simple method indicating that this browser instance is active, providing a quick status check for components interacting with multiple browser types."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_toplevel_response", "line_number": 232, "body": "def on_toplevel_response(self, msg):\n        if not self.winfo_ismapped():\n            return\n        if get_runner().get_backend_proxy().supports_remote_files():\n            # pass cwd, as proxy may not yet know it\n            self.check_update_focus(msg.get(\"cwd\"))", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Method in ActiveRemoteFileBrowser that responds to top-level messages by updating focus if the remote backend supports file operations and the browser is currently visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_remote_files_changed", "line_number": 239, "body": "def on_remote_files_changed(self, event=None):\n        if not self.winfo_ismapped():\n            return\n\n        if get_runner().get_backend_proxy().supports_remote_files():\n            self.refresh_tree()", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Monitors remote file changes and refreshes the file browser view if visible and remote file support is available, ensuring the displayed file tree stays up to date."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "check_update_focus", "line_number": 246, "body": "def check_update_focus(self, new_cwd=None):\n        if new_cwd is None:\n            proxy = get_runner().get_backend_proxy()\n            new_cwd = proxy.get_cwd()\n\n        if self.current_focus != new_cwd:\n            self.focus_into(new_cwd)", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Utility method of ActiveRemoteFileBrowser that updates the current directory focus if it differs from the provided or backend's current working directory, ensuring the browser view stays synchronized."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "request_new_focus", "line_number": 254, "body": "def request_new_focus(self, path):\n        get_shell().submit_magic_command([\"%cd\", path if path != \"\" else \"/\"])", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Shifts the current working directory to the specified path in the remote file browser, enabling navigation within the remote filesystem environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "add_download_command", "line_number": 257, "body": "def add_download_command(self):\n        target_dir = self.master.get_active_local_dir()\n\n        def download():\n            selection = self.get_selection_info(True)\n            if not selection:\n                return\n\n            dlg = DownloadDialog(\n                self,\n                selection[\"paths\"],\n                selection[\"description\"],\n                target_dir,\n            )\n            ui_utils.show_dialog(dlg)\n            if dlg.response is not None:\n                self.master.local_files.refresh_tree()\n\n        self.menu.add_command(label=tr(\"Download to %s\") % target_dir, command=download)", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Adds a \"Download\" command to the menu that lets users download selected remote files to the current local directory and refreshes the local file view upon completion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "add_middle_menu_items", "line_number": 277, "body": "def add_middle_menu_items(self, context):\n        self.add_download_command()\n        super().add_middle_menu_items(context)", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Adds download command and other standard middle menu items to the context menu in the ActiveRemoteFileBrowser interface, enhancing user interaction options for remote file management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_on_response", "line_number": 283, "body": "def _on_response(self, response):\n        if response.get(\"command_id\") != self._cmd[\"id\"]:\n            return\n\n        if self._stage == \"preparation\":\n            if self._confirm_and_start_main_work(response):\n                self._stage = \"main_work\"\n            else:\n                self.response = None\n                self.report_done(True)\n\n        elif self._stage == \"main_work\":\n            self.response = response\n            self.report_done(self._check_success(response))\n\n        self.update_ui()", "is_method": true, "class_name": "TransferDialog", "function_description": "Internal handler within TransferDialog that processes responses to coordinate dialog stages, manage progress based on commands, and update the UI accordingly during a transfer operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_check_success", "line_number": 303, "body": "def _check_success(self, response):\n        if response.get(\"error\"):\n            self.set_action_text(\"Error\")\n            self.append_text(\"\\nError: %s\\n\" % response[\"error\"])\n            return False\n        elif response[\"errors\"]:\n            self.set_action_text(\"Error\")\n            self.append_text(\"\\nError: %s\\n\" % format_items(response[\"errors\"]))\n            return False\n        else:\n            self.set_action_text(\"Done!\")\n            return True", "is_method": true, "class_name": "TransferDialog", "function_description": "Helper method in TransferDialog that evaluates a response for errors, updates status text accordingly, and indicates whether the response is successful or contains errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_confirm_and_start_main_work", "line_number": 339, "body": "def _confirm_and_start_main_work(self, preparation_response):\n        picked_items = list(\n            sorted(\n                pick_transfer_items(self.items, preparation_response[\"existing_items\"], self),\n                key=lambda x: x[\"target_path\"],\n            )\n        )\n        if picked_items:\n            self._cmd = InlineCommand(\"upload\", items=picked_items)\n            get_runner().send_command(self._cmd)\n            return True\n        else:\n            return False", "is_method": true, "class_name": "UploadDialog", "function_description": "Method of UploadDialog that confirms, organizes, and initiates the upload process for selected items based on preparation results, triggering the upload command if items are available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_prepare_download_items", "line_number": 367, "body": "def _prepare_download_items(\n        self, all_source_items: Dict[str, Dict], target_dir: str\n    ) -> List[Dict]:\n        result = []\n        for source_path, source_item in all_source_items.items():\n            source_context_dir = universal_dirname(source_item[\"anchor\"])\n            result.append(\n                {\n                    \"kind\": source_item[\"kind\"],\n                    \"size\": source_item[\"size\"],\n                    \"source_path\": source_path,\n                    \"target_path\": transpose_path(\n                        source_path, source_context_dir, target_dir, PurePosixPath, pathlib.Path\n                    ),\n                }\n            )\n        return result", "is_method": true, "class_name": "DownloadDialog", "function_description": "Prepares a list of download items by transforming source item paths into target paths and collecting relevant metadata, facilitating organized file downloads to a specified directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_get_existing_target_items", "line_number": 385, "body": "def _get_existing_target_items(self, prepared_items: List[Dict]) -> Dict[str, Dict]:\n        result = {}\n\n        for item in prepared_items:\n            target_path = item[\"target_path\"]\n            if os.path.exists(target_path):\n                if os.path.isdir(target_path):\n                    kind = \"dir\"\n                    size = None\n                else:\n                    kind = \"file\"\n                    size = os.path.getsize(target_path)\n\n                result[target_path] = {\n                    \"kind\": kind,\n                    \"size\": size,\n                }\n        return result", "is_method": true, "class_name": "DownloadDialog", "function_description": "Utility method of DownloadDialog that identifies existing files or directories from given items, returning their types and sizes to support efficient download management or conflict resolution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_confirm_and_start_main_work", "line_number": 404, "body": "def _confirm_and_start_main_work(self, preparation_response):\n        prepared_items = self._prepare_download_items(\n            preparation_response[\"all_items\"], self._target_dir\n        )\n        existing_target_items = self._get_existing_target_items(prepared_items)\n        picked_items = pick_transfer_items(prepared_items, existing_target_items, self)\n        if picked_items:\n            self._cmd = InlineCommand(\"download\", items=picked_items)\n            get_runner().send_command(self._cmd)\n            return True\n        else:\n            return False", "is_method": true, "class_name": "DownloadDialog", "function_description": "Utility method in DownloadDialog that prepares and selects items for download, then initiates the download command if any items are chosen, enabling controlled start of the main download process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_upload", "line_number": 200, "body": "def _upload():\n            selection = self.get_selection_info(True)\n            if not selection:\n                return\n\n            if \"dir\" in selection[\"kinds\"] and not proxy.supports_remote_directories():\n                messagebox.showerror(\n                    \"Can't upload directory\",\n                    \"%s does not support directories.\\n\" % proxy.get_node_label()\n                    + \"You can only upload files.\",\n                    master=self,\n                )\n            else:\n                if upload(selection[\"paths\"], target_dir, master=self):\n                    self.master.remote_files.refresh_tree()", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Internal method in ActiveLocalFileBrowser that handles uploading selected files or directories, validating remote support, and refreshing the remote file view upon successful upload."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "download", "line_number": 260, "body": "def download():\n            selection = self.get_selection_info(True)\n            if not selection:\n                return\n\n            dlg = DownloadDialog(\n                self,\n                selection[\"paths\"],\n                selection[\"description\"],\n                target_dir,\n            )\n            ui_utils.show_dialog(dlg)\n            if dlg.response is not None:\n                self.master.local_files.refresh_tree()", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Provides a user-initiated download process for selected remote files, displaying a dialog and refreshing the local file view upon completion. It enables easy transfer of remote content to a local directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pgzero_frontend.py", "function": "toggle_variable", "line_number": 9, "body": "def toggle_variable():\n    var = get_workbench().get_variable(_OPTION_NAME)\n    var.set(not var.get())\n    update_environment()", "is_method": false, "function_description": "Toggle the boolean value of a specific workbench variable and update the environment accordingly. This function enables switching a configuration option on or off within the current workbench context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pgzero_frontend.py", "function": "update_environment", "line_number": 15, "body": "def update_environment():\n    if get_workbench().in_simple_mode():\n        os.environ[\"PGZERO_MODE\"] = \"auto\"\n    else:\n        os.environ[\"PGZERO_MODE\"] = str(get_workbench().get_option(_OPTION_NAME))", "is_method": false, "function_description": "Sets the PGZERO_MODE environment variable based on the current workbench mode to configure the application's runtime behavior accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pgzero_frontend.py", "function": "load_plugin", "line_number": 22, "body": "def load_plugin():\n    get_workbench().set_default(_OPTION_NAME, False)\n    get_workbench().add_command(\n        \"toggle_pgzero_mode\",\n        \"run\",\n        tr(\"Pygame Zero mode\"),\n        toggle_variable,\n        flag_name=_OPTION_NAME,\n        group=40,\n    )\n    update_environment()", "is_method": false, "function_description": "Sets up and configures the plugin by initializing default options, registering the Pygame Zero mode toggle command, and refreshing the environment accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_get_focused_writable_text", "line_number": 11, "body": "def _get_focused_writable_text():\n    widget = get_workbench().focus_get()\n    # In Ubuntu when moving from one menu to another, this may give None when text is actually focused\n    if isinstance(widget, tk.Text) and (\n        not hasattr(widget, \"is_read_only\") or not widget.is_read_only()\n    ):\n        return widget\n    else:\n        return None", "is_method": false, "function_description": "Utility function that returns the currently focused writable text widget, enabling targeted text manipulation only if the widget is editable and focused. Useful for GUI text input handling in applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_selection_is_line_commented", "line_number": 26, "body": "def _selection_is_line_commented(text):\n    sel_range = _get_focused_code_range(text)\n\n    for lineno in range(sel_range.lineno, sel_range.end_lineno + 1):\n        line = text.get(str(lineno) + \".0\", str(lineno) + \".end\")\n        if not line.startswith(BLOCK_COMMENT_PREFIX):\n            return False\n\n    return True", "is_method": false, "function_description": "Determines if all lines in the currently focused code selection are commented out using a specific line comment prefix. Useful for toggling or validating code comment states within an editor or IDE environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_select_lines", "line_number": 37, "body": "def _select_lines(text, first_line, last_line):\n    text.tag_remove(\"sel\", \"1.0\", tk.END)\n    text.tag_add(\"sel\", str(first_line) + \".0\", str(last_line) + \".end\")", "is_method": false, "function_description": "Selects and highlights a range of lines in a tkinter text widget from the first to the last line specified. This aids in programmatically managing text selection within the widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_toggle_selection_comment", "line_number": 42, "body": "def _toggle_selection_comment(text):\n    if _selection_is_line_commented(text):\n        _uncomment_selection(text)\n    else:\n        _comment_selection(text)", "is_method": false, "function_description": "Toggles commenting on a given text by commenting it if uncommented, or uncommenting if already commented, facilitating quick code or text block modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_comment_selection", "line_number": 49, "body": "def _comment_selection(text):\n    \"\"\"Adds ## in front of all selected lines if any lines are selected,\n    or just the current line otherwise\"\"\"\n\n    sel_range = _get_focused_code_range(text)\n\n    for lineno in range(sel_range.lineno, sel_range.end_lineno + 1):\n        text.insert(str(lineno) + \".0\", BLOCK_COMMENT_PREFIX)\n\n    if sel_range.end_lineno > sel_range.lineno:\n        _select_lines(text, sel_range.lineno, sel_range.end_lineno)\n\n    text.edit_separator()", "is_method": false, "function_description": "This function provides a way to comment out lines in a text editor by inserting a comment prefix on selected lines or the current line if no selection exists. It supports batch commenting with visual selection update and undo grouping."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_uncomment_selection", "line_number": 64, "body": "def _uncomment_selection(text):\n    sel_range = _get_focused_code_range(text)\n\n    for lineno in range(sel_range.lineno, sel_range.end_lineno + 1):\n        line = text.get(str(lineno) + \".0\", str(lineno) + \".end\")\n        if line.startswith(BLOCK_COMMENT_PREFIX):\n            text.delete(str(lineno) + \".0\", str(lineno) + \".\" + str(len(BLOCK_COMMENT_PREFIX)))", "is_method": false, "function_description": "This function removes block comment prefixes from a specific selected range of lines in a text component, enabling users to uncomment code sections within that selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_get_focused_code_range", "line_number": 73, "body": "def _get_focused_code_range(text):\n    if len(text.tag_ranges(\"sel\")) > 0:\n        lineno, col_offset = map(int, text.index(tk.SEL_FIRST).split(\".\"))\n        end_lineno, end_col_offset = map(int, text.index(tk.SEL_LAST).split(\".\"))\n\n        if end_lineno > lineno and end_col_offset == 0:\n            # SelectAll includes nonexisting extra line\n            end_lineno -= 1\n            end_col_offset = int(text.index(str(end_lineno) + \".end\").split(\".\")[1])\n    else:\n        lineno, col_offset = map(int, text.index(tk.INSERT).split(\".\"))\n        end_lineno, end_col_offset = lineno, col_offset\n\n    return TextRange(lineno, col_offset, end_lineno, end_col_offset)", "is_method": false, "function_description": "Returns the start and end positions of the current text selection or cursor within a text widget, providing a precise range for focused text operations. Useful for editors needing to identify and manipulate selected code segments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_cmd_uncomment_selection", "line_number": 101, "body": "def _cmd_uncomment_selection():\n    text = _get_focused_writable_text()\n    if text is not None:\n        _uncomment_selection(text)", "is_method": false, "function_description": "This function uncomments the currently selected text in the active writable text area. It enables undoing commented code or text blocks within an editor environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_cmd_indent_selection", "line_number": 107, "body": "def _cmd_indent_selection():\n    text = _get_focused_writable_text()\n    if text is not None and hasattr(text, \"indent_region\"):\n        text.indent_region()", "is_method": false, "function_description": "Utility function that indents the currently selected region in a focused, writable text component if available, facilitating code or text formatting in an editor environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_cmd_replace_tabs", "line_number": 119, "body": "def _cmd_replace_tabs():\n    text = _get_focused_writable_text()\n    if text is not None:\n        orig_lines = text.get(\"1.0\", \"end\").splitlines(keepends=True)\n        new_lines = []\n        for line in orig_lines:\n            leading_tab_count = 0\n            for char in line:\n                if char == \"\\t\":\n                    leading_tab_count += 1\n                else:\n                    break\n            new_lines.append(leading_tab_count * \"    \" + line[leading_tab_count:])\n\n        text.delete(\"1.0\", \"end\")\n\n        text.insert(\"1.0\", \"\".join(new_lines))", "is_method": false, "function_description": "Utility function that replaces leading tab characters with four spaces in the currently focused writable text area, standardizing indentation for consistent text formatting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "load_plugin", "line_number": 138, "body": "def load_plugin() -> None:\n\n    get_workbench().add_command(\n        \"indent\",\n        \"edit\",\n        tr(\"Indent selected lines\"),\n        _cmd_indent_selection,\n        tester=_writable_text_is_focused,\n        accelerator=\"Tab\",\n        group=49,\n    )\n\n    get_workbench().add_command(\n        \"dedent\",\n        \"edit\",\n        tr(\"Dedent selected lines\"),\n        _cmd_dedent_selection,\n        tester=_writable_text_is_focused,\n        accelerator=\"Shift+Tab\",\n        group=49,\n    )\n\n    get_workbench().add_command(\n        \"replace_tabs\",\n        \"edit\",\n        tr(\"Replace tabs with spaces\"),\n        _cmd_replace_tabs,\n        tester=_writable_text_is_focused,\n        group=49,\n    )\n\n    get_workbench().add_command(\n        \"toggle_comment\",\n        \"edit\",\n        tr(\"Toggle comment\"),\n        _cmd_toggle_selection_comment,\n        default_sequence=select_sequence(\"<Control-Key-3>\", \"<Command-Key-3>\"),\n        tester=_writable_text_is_focused,\n        group=50,\n    )\n\n    get_workbench().add_command(\n        \"comment_selection\",\n        \"edit\",\n        tr(\"Comment out\"),\n        _cmd_comment_selection,\n        default_sequence=\"<Alt-Key-3>\",\n        tester=_writable_text_is_focused,\n        group=50,\n    )\n\n    get_workbench().add_command(\n        \"uncomment_selection\",\n        \"edit\",\n        tr(\"Uncomment\"),\n        _cmd_uncomment_selection,\n        default_sequence=\"<Alt-Key-4>\",\n        tester=_writable_text_is_focused,\n        group=50,\n    )", "is_method": false, "function_description": "Function that registers a set of text editing commands (indent, dedent, toggle comments, replace tabs) with a workbench, enabling keyboard shortcuts and context-sensitive activation in a text editor environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/notes.py", "function": "load_plugin", "line_number": 62, "body": "def load_plugin():\n    get_workbench().add_view(NotesView, tr(\"Notes\"), \"ne\", default_position_key=\"zz\")", "is_method": false, "function_description": "Adds a Notes view to the workbench interface, integrating note-taking functionality into the application UI at a specified position."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/notes.py", "function": "on_secondary_click", "line_number": 14, "body": "def on_secondary_click(self, event=None):\n        super().on_secondary_click(event=event)\n        self.context_menu.tk_popup(event.x_root, event.y_root)", "is_method": true, "class_name": "NotesText", "function_description": "Handles right-click events by triggering the parent behavior and displaying a context menu at the cursor's screen position. This supports user interactions requiring secondary click options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/notes.py", "function": "load_content", "line_number": 31, "body": "def load_content(self):\n        if not os.path.isfile(self.filename):\n            self.text.insert(\n                \"1.0\",\n                tr(\n                    \"This box is meant for your working notes -- assignment instructions, \"\n                    + \"code snippets, whatever.\\n\\n\"\n                    + \"Everything will be saved automatically \"\n                    + \"and loaded when you open Thonny next time.\\n\\n\"\n                    + \"Feel free to delete this text to make room for your own notes.\"\n                ),\n            )\n            return\n\n        with open(self.filename, encoding=\"utf-8\") as fp:\n            content = fp.read()\n\n        self.text.delete(\"1.0\", \"end\")\n        self.text.insert(\"1.0\", content)\n        self.text.mark_set(\"insert\", \"1.0\")\n        self.text.see(\"1.0\")", "is_method": true, "class_name": "NotesView", "function_description": "Loads and displays saved notes content from a file into the NotesView text area, or shows an introductory message if no saved file exists, facilitating persistent and user-friendly note-taking."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/notes.py", "function": "save_content", "line_number": 53, "body": "def save_content(self, event=None):\n        with open(self.filename, \"w\", encoding=\"utf-8\") as fp:\n            fp.write(self.text.get(\"1.0\", \"end-1c\"))", "is_method": true, "class_name": "NotesView", "function_description": "Method of NotesView that saves the current text content to a specified file, ensuring persistent storage of user-entered notes or data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/notes.py", "function": "destroy", "line_number": 57, "body": "def destroy(self):\n        self.save_content()\n        super().destroy()", "is_method": true, "class_name": "NotesView", "function_description": "Method in NotesView that ensures the current content is saved before the view is destroyed, preserving data integrity during cleanup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_debugger_command_enabled", "line_number": 1166, "body": "def _debugger_command_enabled(command):\n    if _current_debugger is None:\n        return False\n    else:\n        return _current_debugger.command_enabled(command)", "is_method": false, "function_description": "Internal utility function that checks if a specific debugger command is currently enabled, facilitating conditional debugging behavior based on the debugger state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_issue_debugger_command", "line_number": 1173, "body": "def _issue_debugger_command(command):\n    if _current_debugger is None:\n        raise AssertionError(\"Trying to send debugger command without debugger\")\n    else:\n        return _current_debugger.check_issue_command(command)", "is_method": false, "function_description": "Internal helper function that sends a command to the current debugger instance, raising an error if no debugger is attached."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_start_debug_enabled", "line_number": 1180, "body": "def _start_debug_enabled():\n    return (\n        _current_debugger is None\n        and get_workbench().get_editor_notebook().get_current_editor() is not None\n        and \"debug\" in get_runner().get_supported_features()\n    )", "is_method": false, "function_description": "Checks if debugging can be started by verifying no active debugger exists, an editor is open, and the runner supports debugging features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_request_debug", "line_number": 1188, "body": "def _request_debug(command_name):\n    # Don't assume Debug command gets issued after this\n    # This may just call the %cd command\n    # or the user may deny saving current editor\n    if get_workbench().in_simple_mode():\n        get_workbench().show_view(\"VariablesView\")\n\n    get_runner().execute_current(command_name)", "is_method": false, "function_description": "Private helper function that executes a given command and conditionally displays the Variables view in simple mode, facilitating debugging or command execution within the workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_debug_accepted", "line_number": 1198, "body": "def _debug_accepted(event):\n    # Called when proxy accepted the debug command\n    global _current_debugger\n    cmd = event.command\n    if cmd.get(\"name\") in [\"Debug\", \"FastDebug\"]:\n        assert _current_debugger is None\n        if get_workbench().get_option(\"debugger.frames_in_separate_windows\"):\n            _current_debugger = StackedWindowsDebugger()\n        else:\n            _current_debugger = SingleWindowDebugger()", "is_method": false, "function_description": "Internal function that initializes the debugger interface when a debug command is accepted, selecting the debugger type based on user interface settings for frame display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_handle_debugger_progress", "line_number": 1210, "body": "def _handle_debugger_progress(msg):\n    global _current_debugger\n    assert _current_debugger is not None\n    _current_debugger.handle_debugger_progress(msg)\n    _update_run_or_resume_button()", "is_method": false, "function_description": "Internal function that forwards debugger progress messages to the current debugger instance and updates the UI control accordingly. It supports debugging workflows by reflecting real-time progress changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_handle_toplevel_response", "line_number": 1217, "body": "def _handle_toplevel_response(msg):\n    global _current_debugger\n    if _current_debugger is not None:\n        _current_debugger.close()\n        _current_debugger = None\n\n    _update_run_or_resume_button()", "is_method": false, "function_description": "Handles the top-level response by closing any active debugger and updating the run or resume button state. It manages debugger lifecycle and UI state in response processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_handle_debugger_return", "line_number": 1226, "body": "def _handle_debugger_return(msg):\n    global _current_debugger\n    assert _current_debugger is not None\n    _current_debugger.handle_debugger_return(msg)", "is_method": false, "function_description": "Internal function that forwards a debugger return message to the active debugger instance for handling. It supports communication within debugging workflows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_run_or_resume", "line_number": 1232, "body": "def _run_or_resume():\n    state = get_runner().get_state()\n    if state == \"waiting_debugger_command\":\n        _issue_debugger_command(\"resume\")\n    elif state == \"waiting_toplevel_command\":\n        get_runner().cmd_run_current_script()", "is_method": false, "function_description": "Private utility function that resumes execution by issuing the appropriate command based on the current runner state, supporting debugging and script running workflows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_run_or_resume_enabled", "line_number": 1240, "body": "def _run_or_resume_enabled():\n    return get_runner().cmd_run_current_script_enabled() or _debugger_command_enabled(\"resume\")", "is_method": false, "function_description": "Checks if running the current script or resuming from a debugger command is enabled, indicating whether execution control operations are active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_run_or_resume_button", "line_number": 1244, "body": "def _update_run_or_resume_button():\n    if not get_workbench().in_simple_mode():\n        return\n\n    state = get_runner().get_state()\n    if state == \"waiting_debugger_command\":\n        caption = RESUME_COMMAND_CAPTION\n        image = get_workbench().get_image(\"resume\")\n    elif state == \"waiting_toplevel_command\":\n        caption = running.RUN_COMMAND_CAPTION\n        image = get_workbench().get_image(\"run-current-script\")\n    else:\n        return\n\n    button = get_workbench().get_toolbar_button(\"runresume\")\n    button.configure(text=caption, image=image)", "is_method": false, "function_description": "Updates the run or resume toolbar button to reflect the current debugger or script execution state, ensuring the UI accurately represents whether to resume debugging or run the script in simple mode."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_current_debugger", "line_number": 1262, "body": "def get_current_debugger():\n    return _current_debugger", "is_method": false, "function_description": "Returns the current active debugger instance if any is set, enabling access to debugging controls or state within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "run_preferred_debug_command", "line_number": 1266, "body": "def run_preferred_debug_command():\n    preferred_debugger = get_workbench().get_option(\"debugger.preferred_debugger\").lower()\n    if preferred_debugger == \"faster\":\n        return _request_debug(\"FastDebug\")\n    elif preferred_debugger == \"birdseye\":\n        from thonny.plugins.birdseye_frontend import debug_with_birdseye\n\n        return debug_with_birdseye()\n    else:\n        return _request_debug(\"Debug\")", "is_method": false, "function_description": "Function that executes a debugging command based on the user\u2019s preferred debugger setting, supporting multiple debugging tools for flexible debugging workflows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "load_plugin", "line_number": 1278, "body": "def load_plugin() -> None:\n\n    global RESUME_COMMAND_CAPTION\n    RESUME_COMMAND_CAPTION = tr(\"Resume\")\n\n    if get_workbench().in_simple_mode():\n        get_workbench().set_default(\"debugger.frames_in_separate_windows\", False)\n    else:\n        get_workbench().set_default(\"debugger.frames_in_separate_windows\", True)\n\n    get_workbench().set_default(\"debugger.automatic_stack_view\", True)\n    get_workbench().set_default(\n        \"debugger.preferred_debugger\", \"faster\" if running_on_rpi() else \"nicer\"\n    )\n    get_workbench().set_default(\"debugger.allow_stepping_into_libraries\", False)\n\n    get_workbench().add_command(\n        \"runresume\",\n        \"run\",\n        tr(\"Run / resume\"),\n        _run_or_resume,\n        caption=running.RUN_COMMAND_CAPTION,\n        tester=_run_or_resume_enabled,\n        default_sequence=None,\n        group=10,\n        image=\"run-current-script\",\n        include_in_menu=False,\n        include_in_toolbar=get_workbench().in_simple_mode(),\n        alternative_caption=RESUME_COMMAND_CAPTION,\n    )\n\n    get_workbench().add_command(\n        \"debug_preferred\",\n        \"run\",\n        tr(\"Debug current script\"),\n        run_preferred_debug_command,\n        caption=tr(\"Debug\"),\n        tester=_start_debug_enabled,\n        group=10,\n        image=\"debug-current-script\",\n        include_in_menu=False,\n        include_in_toolbar=True,\n    )\n\n    get_workbench().add_command(\n        \"debug_nicer\",\n        \"run\",\n        tr(\"Debug current script (nicer)\"),\n        lambda: _request_debug(\"Debug\"),\n        caption=\"Debug (nicer)\",\n        tester=_start_debug_enabled,\n        default_sequence=\"<Control-F5>\",\n        group=10,\n        # image=\"debug-current-script\",\n    )\n\n    get_workbench().add_command(\n        \"debug_faster\",\n        \"run\",\n        tr(\"Debug current script (faster)\"),\n        lambda: _request_debug(\"FastDebug\"),\n        caption=\"Debug (faster)\",\n        tester=_start_debug_enabled,\n        default_sequence=\"<Shift-F5>\",\n        group=10,\n    )\n\n    get_workbench().add_command(\n        \"step_over\",\n        \"run\",\n        tr(\"Step over\"),\n        lambda: _issue_debugger_command(\"step_over\"),\n        caption=tr(\"Over\"),\n        tester=lambda: _debugger_command_enabled(\"step_over\"),\n        default_sequence=\"<F6>\",\n        group=30,\n        image=\"step-over\",\n        include_in_toolbar=True,\n    )\n\n    get_workbench().add_command(\n        \"step_into\",\n        \"run\",\n        tr(\"Step into\"),\n        lambda: _issue_debugger_command(\"step_into\"),\n        caption=tr(\"Into\"),\n        tester=lambda: _debugger_command_enabled(\"step_into\"),\n        default_sequence=\"<F7>\",\n        group=30,\n        image=\"step-into\",\n        include_in_toolbar=True,\n    )\n\n    get_workbench().add_command(\n        \"step_out\",\n        \"run\",\n        tr(\"Step out\"),\n        lambda: _issue_debugger_command(\"step_out\"),\n        caption=tr(\"Out\"),\n        tester=lambda: _debugger_command_enabled(\"step_out\"),\n        group=30,\n        image=\"step-out\",\n        include_in_toolbar=True,\n    )\n\n    get_workbench().add_command(\n        \"resume\",\n        \"run\",\n        RESUME_COMMAND_CAPTION,\n        lambda: _issue_debugger_command(\"resume\"),\n        caption=RESUME_COMMAND_CAPTION,\n        tester=lambda: _debugger_command_enabled(\"resume\"),\n        default_sequence=\"<F8>\",\n        group=30,\n        image=\"resume\",\n        include_in_toolbar=not get_workbench().in_simple_mode(),\n    )\n\n    get_workbench().add_command(\n        \"run_to_cursor\",\n        \"run\",\n        tr(\"Run to cursor\"),\n        lambda: _issue_debugger_command(\"run_to_cursor\"),\n        tester=lambda: _debugger_command_enabled(\"run_to_cursor\"),\n        default_sequence=select_sequence(\"<Control-F8>\", \"<Control-F8>\"),\n        group=30,\n        image=\"run-to-cursor\",\n        include_in_toolbar=False,\n    )\n\n    get_workbench().add_command(\n        \"step_back\",\n        \"run\",\n        tr(\"Step back\"),\n        lambda: _issue_debugger_command(\"step_back\"),\n        caption=tr(\"Back\"),\n        tester=lambda: _debugger_command_enabled(\"step_back\"),\n        default_sequence=select_sequence(\"<Control-b>\", \"<Command-b>\"),\n        group=30,\n    )\n\n    get_workbench().add_view(StackView, tr(\"Stack\"), \"se\")\n    get_workbench().add_view(ExceptionView, tr(\"Exception\"), \"s\")\n    get_workbench().bind(\"DebuggerResponse\", _handle_debugger_progress, True)\n    get_workbench().bind(\"ToplevelResponse\", _handle_toplevel_response, True)\n    get_workbench().bind(\"debugger_return_response\", _handle_debugger_return, True)\n    get_workbench().bind(\"CommandAccepted\", _debug_accepted, True)", "is_method": false, "function_description": "Function that initializes and configures debugger-related commands, views, and event bindings within the workbench, adapting settings based on the interface mode and environment. It enables debugging controls and UI integration for script execution and inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "check_issue_command", "line_number": 48, "body": "def check_issue_command(self, command, **kwargs):\n        cmd = DebuggerCommand(command, **kwargs)\n        self._last_debugger_command = cmd\n\n        if get_runner().is_waiting_debugger_command():\n            logging.debug(\"_check_issue_debugger_command: %s\", cmd)\n\n            # tell MainCPythonBackend the state we are seeing\n            cmd.setdefault(\n                frame_id=self._last_progress_message.stack[-1].id,\n                breakpoints=self.get_effective_breakpoints(command),\n                state=self._last_progress_message.stack[-1].event,\n                focus=self._last_progress_message.stack[-1].focus,\n                allow_stepping_into_libraries=get_workbench().get_option(\n                    \"debugger.allow_stepping_into_libraries\"\n                ),\n            )\n            if command == \"run_to_cursor\":\n                # cursor position was added as another breakpoint\n                cmd.name = \"resume\"\n\n            get_runner().send_command(cmd)\n            if command == \"resume\":\n                self.clear_last_frame()\n        else:\n            logging.debug(\"Bad state for sending debugger command \" + str(command))", "is_method": true, "class_name": "Debugger", "function_description": "Utility method of the Debugger class that processes and sends debugging commands to the runtime, managing command state, breakpoints, and execution flow based on the current debugging context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_effective_breakpoints", "line_number": 78, "body": "def get_effective_breakpoints(self, command):\n        result = editors.get_current_breakpoints()\n\n        if command == \"run_to_cursor\":\n            bp = self.get_run_to_cursor_breakpoint()\n            if bp is not None:\n                filename, lineno = bp\n                result.setdefault(filename, set())\n                result[filename].add(lineno)\n\n        return result", "is_method": true, "class_name": "Debugger", "function_description": "Core method of the Debugger class that returns the current set of active breakpoints, including an additional breakpoint for a \"run to cursor\" command if specified. It consolidates breakpoints for use in debugging control flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "command_enabled", "line_number": 90, "body": "def command_enabled(self, command):\n        if not get_runner().is_waiting_debugger_command():\n            return False\n\n        if command == \"run_to_cursor\":\n            return self.get_run_to_cursor_breakpoint() is not None\n        elif command == \"step_back\":\n            return (\n                self._last_progress_message\n                and self._last_progress_message[\"tracer_class\"] == \"NiceTracer\"\n            )\n        else:\n            return True", "is_method": true, "class_name": "Debugger", "function_description": "Determines whether a given debugger command is currently available based on the debugger state and specific conditions, enabling UI or logic to selectively activate debug commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handle_debugger_progress", "line_number": 104, "body": "def handle_debugger_progress(self, msg):\n        self._last_brought_out_frame_id = None", "is_method": true, "class_name": "Debugger", "function_description": "Core utility method of the Debugger class that resets the identifier of the last highlighted frame during debugging progress updates. It helps manage debugging state transitions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close", "line_number": 110, "body": "def close(self) -> None:\n        self._last_brought_out_frame_id = None\n\n        if get_workbench().get_option(\"debugger.automatic_stack_view\"):\n            get_workbench().hide_view(\"StackView\")", "is_method": true, "class_name": "Debugger", "function_description": "Method in Debugger that resets the last active frame and conditionally hides the stack view based on user settings when closing a debugging session."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_frame_by_id", "line_number": 119, "body": "def get_frame_by_id(self, frame_id):\n        for frame_info in self._last_progress_message.stack:\n            if frame_info.id == frame_id:\n                return frame_info\n\n        raise ValueError(\"Could not find frame %d\" % frame_id)", "is_method": true, "class_name": "Debugger", "function_description": "Method in Debugger that retrieves a specific stack frame by its identifier from the last recorded execution state, facilitating targeted inspection or analysis of program state during debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_editor_context_menu", "line_number": 130, "body": "def get_editor_context_menu(self):\n        def create_edit_command_handler(virtual_event_sequence):\n            def handler(event=None):\n                widget = get_workbench().focus_get()\n                if widget:\n                    return widget.event_generate(virtual_event_sequence)\n\n                return None\n\n            return handler\n\n        if self._editor_context_menu is None:\n            menu = tk.Menu(get_workbench())\n            menu.add(\n                \"command\",\n                label=tr(\"Run to cursor\"),\n                command=lambda: self.check_issue_command(\"run_to_cursor\"),\n            )\n            menu.add(\"separator\")\n            menu.add(\"command\", label=\"Copy\", command=create_edit_command_handler(\"<<Copy>>\"))\n            menu.add(\n                \"command\",\n                label=tr(\"Select all\"),\n                command=create_edit_command_handler(\"<<SelectAll>>\"),\n            )\n            self._editor_context_menu = menu\n\n        return self._editor_context_menu", "is_method": true, "class_name": "Debugger", "function_description": "Provides a context menu for the editor with common actions like \"Run to cursor,\" \"Copy,\" and \"Select all,\" facilitating quick access to these commands within the Debugger interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_run_to_cursor_breakpoint", "line_number": 167, "body": "def get_run_to_cursor_breakpoint(self):\n        editor = get_workbench().get_editor_notebook().get_current_editor()\n        if editor:\n            filename = editor.get_filename()\n            selection = editor.get_code_view().get_selected_range()\n            lineno = selection.lineno\n            if filename and lineno:\n                return filename, lineno\n\n        return None", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "Returns the filename and line number of the current cursor position in the active editor, facilitating the setting of a run-to-cursor breakpoint during debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handle_debugger_progress", "line_number": 178, "body": "def handle_debugger_progress(self, msg):\n        super().handle_debugger_progress(msg)\n        self._last_progress_message = msg\n        self.bring_out_frame(self._last_progress_message.stack[-1].id, force=True)\n\n        if get_workbench().get_option(\"debugger.automatic_stack_view\"):\n            if len(msg.stack) > 1:\n                get_workbench().show_view(\"StackView\")\n\n        get_workbench().get_view(\"ExceptionView\").set_exception(\n            msg[\"exception_info\"][\"lines_with_frame_info\"]\n        )", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "Handles debugger progress updates by tracking the latest message, updating the stack and exception views, and optionally displaying the stack view for deeper debugging insights within the SingleWindowDebugger context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close", "line_number": 191, "body": "def close(self):\n        super().close()\n        if self._last_frame_visualizer is not None:\n            self._last_frame_visualizer.close()\n            self._last_frame_visualizer = None", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "Closes the SingleWindowDebugger instance along with its associated last frame visualizer, ensuring proper cleanup of visualization resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear_last_frame", "line_number": 197, "body": "def clear_last_frame(self):\n        if self._last_frame_visualizer is not None:\n            self._last_frame_visualizer.clear()", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "Clears the visual display of the last debugged frame if it exists. This helps reset or remove the previous frame's visualization during debugging sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "bring_out_frame", "line_number": 201, "body": "def bring_out_frame(self, frame_id, force=False):\n        if not force and frame_id == self._last_brought_out_frame_id:\n            return\n\n        self._last_brought_out_frame_id = frame_id\n\n        frame_info = self.get_frame_by_id(frame_id)\n\n        if (\n            self._last_frame_visualizer is not None\n            and self._last_frame_visualizer._frame_id != frame_info.id\n        ):\n            self._last_frame_visualizer.close()\n            self._last_frame_visualizer = None\n\n        if self._last_frame_visualizer is None:\n            self._last_frame_visualizer = EditorVisualizer(frame_info)\n\n        self._last_frame_visualizer._update_this_frame(self._last_progress_message, frame_info)\n\n        # show variables\n        var_view = get_workbench().get_view(\"VariablesView\")\n        if frame_info.code_name == \"<module>\":\n            var_view.show_globals(frame_info.globals, frame_info.module_name)\n        else:\n            var_view.show_frame_variables(\n                frame_info.locals,\n                frame_info.globals,\n                frame_info.freevars,\n                frame_info.module_name\n                if frame_info.code_name == \"<module>\"\n                else frame_info.code_name,\n            )", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "Provides functionality to display and update a debugger frame's detailed view, including variables and code context, ensuring efficient switching and visualization within a single-window debugging environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handle_debugger_return", "line_number": 235, "body": "def handle_debugger_return(self, msg):\n        if (\n            self._last_frame_visualizer is not None\n            and self._last_frame_visualizer.get_frame_id() == msg.get(\"frame_id\")\n        ):\n            self._last_frame_visualizer.close()", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "Utility method in SingleWindowDebugger that closes the last visualized frame if the returned debugger message corresponds to that frame, supporting synchronized debugger UI updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_run_to_cursor_breakpoint", "line_number": 248, "body": "def get_run_to_cursor_breakpoint(self):\n        visualizer = self._get_topmost_selected_visualizer()\n        if visualizer:\n            assert isinstance(visualizer._text_frame, CodeView)\n            code_view = visualizer._text_frame\n            selection = code_view.get_selected_range()\n\n            target_lineno = visualizer._firstlineno - 1 + selection.lineno\n            return visualizer._filename, target_lineno\n        else:\n            return None", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Retrieves the filename and line number of the current cursor position as a breakpoint within the topmost selected visualizer, aiding precise debugging workflows by mapping UI selection to code locations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handle_debugger_progress", "line_number": 260, "body": "def handle_debugger_progress(self, msg):\n        super().handle_debugger_progress(msg)\n\n        self._last_progress_message = msg\n\n        main_frame_id = msg.stack[0].id\n\n        # clear obsolete main frame visualizer\n        if (\n            self._main_frame_visualizer\n            and self._main_frame_visualizer.get_frame_id() != main_frame_id\n        ):\n            self._main_frame_visualizer.close()\n            self._main_frame_visualizer = None\n\n        if not self._main_frame_visualizer:\n            self._main_frame_visualizer = EditorVisualizer(msg.stack[0])\n\n        self._main_frame_visualizer.update_this_and_next_frames(msg)\n\n        self.bring_out_frame(msg.stack[-1].id, force=True)\n\n        get_workbench().get_view(\"ExceptionView\").set_exception(\n            msg[\"exception_info\"][\"lines_with_frame_info\"]\n        )", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Handles debugger progress updates by managing and refreshing the main frame visualizer and updating the exception view with current debugging information, ensuring the debugging UI reflects the latest program state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close", "line_number": 286, "body": "def close(self):\n        super().close()\n        if self._main_frame_visualizer is not None:\n            self._main_frame_visualizer.close()\n            self._main_frame_visualizer = None", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Provides a cleanup method that closes resources held by the debugger and its main frame visualizer, ensuring proper release of associated visualization components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear_last_frame", "line_number": 292, "body": "def clear_last_frame(self):\n        visualizer = self._get_topmost_visualizer()\n        if visualizer is not None:\n            visualizer.clear()", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Utility method of StackedWindowsDebugger that clears the visual content of the most recently added visualizer frame, aiding in resetting or updating the display during debugging sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_get_topmost_visualizer", "line_number": 297, "body": "def _get_topmost_visualizer(self):\n        visualizer = self._main_frame_visualizer\n        if visualizer is None:\n            return None\n\n        while visualizer._next_frame_visualizer is not None:\n            visualizer = visualizer._next_frame_visualizer\n\n        return visualizer", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Returns the last visualizer in a linked sequence of frame visualizers, enabling access to the topmost visual representation in a stacked window hierarchy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_get_topmost_selected_visualizer", "line_number": 307, "body": "def _get_topmost_selected_visualizer(self):\n        visualizer = self._get_topmost_visualizer()\n        if visualizer is None:\n            return None\n\n        topmost_text_widget = visualizer._text\n        focused_widget = get_workbench().focus_get()\n\n        if focused_widget is None:\n            return None\n        elif focused_widget == topmost_text_widget:\n            return visualizer\n        else:\n            return None", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Internal method of StackedWindowsDebugger that identifies whether the currently focused widget is the topmost visualizer's text widget, returning that visualizer if so, or None otherwise. It helps determine user interaction focus within stacked visual elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "bring_out_frame", "line_number": 322, "body": "def bring_out_frame(self, frame_id, force=False):\n        if not force and frame_id == self._last_brought_out_frame_id:\n            return\n\n        self._last_brought_out_frame_id = frame_id\n\n        self._main_frame_visualizer.bring_out_frame(frame_id)\n\n        # show variables\n        var_view = get_workbench().get_view(\"VariablesView\")\n        frame_info = self.get_frame_by_id(frame_id)\n        var_view.show_globals(frame_info.globals, frame_info.module_name)", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Utility method of StackedWindowsDebugger that highlights a specified frame visually and displays its global variables, optionally forcing a refresh even if the frame is already highlighted."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handle_debugger_return", "line_number": 335, "body": "def handle_debugger_return(self, msg):\n        if self._main_frame_visualizer is None:\n            return\n\n        self._main_frame_visualizer.close(msg[\"frame_id\"])\n        if msg[\"frame_id\"] == self._main_frame_visualizer.get_frame_id():\n            self._main_frame_visualizer = None", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Handles debugger return messages by closing the visualizer frame identified in the message and resets the main visualizer if that frame was active. It manages debugger frame lifecycle within StackedWindowsDebugger."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_translate_lineno", "line_number": 370, "body": "def _translate_lineno(self, lineno):\n        return lineno - self._firstlineno + 1", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Private helper method in FrameVisualizer that converts an absolute line number to a relative line number within a frame, facilitating easier mapping of lines during visualization or debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_reconfigure_tags", "line_number": 373, "body": "def _reconfigure_tags(self):\n        for tag in [\"active_focus\", \"exception_focus\"]:\n            conf = get_syntax_options_for_tag(tag).copy()\n            if self._line_debug:\n                # meaning data comes from line-debug\n                conf[\"borderwidth\"] = 0\n\n            self._text.tag_configure(tag, **conf)", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Private method of the FrameVisualizer class that updates the configuration of specific text tags, adjusting their visual styles based on debugging settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close", "line_number": 382, "body": "def close(self, frame_id=None):\n        if self._next_frame_visualizer:\n            self._next_frame_visualizer.close(frame_id)\n            if frame_id is None or self._next_frame_visualizer.get_frame_id() == frame_id:\n                self._next_frame_visualizer = None\n\n        if frame_id is None or frame_id == self._frame_id:\n            self._text.set_read_only(False)\n            self.clear()", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Method of FrameVisualizer that closes the specified frame (or all if none specified), clears its content, and manages the linked sequence of frame visualizers by closing and unlinking the matching subsequent frames."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear", "line_number": 393, "body": "def clear(self):\n        self.remove_focus_tags()\n        self.hide_expression_box()\n        self.close_note()", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Utility method in FrameVisualizer that resets the visualization state by removing focus indicators, hiding expression inputs, and closing any active notes for a clean interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_frame_id", "line_number": 398, "body": "def get_frame_id(self):\n        return self._frame_id", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Returns the unique identifier of the current frame, allowing other functions to reference or track this specific frame within the FrameVisualizer context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "update_this_and_next_frames", "line_number": 401, "body": "def update_this_and_next_frames(self, msg):\n        \"\"\"Must not be used on obsolete frame\"\"\"\n\n        # debug(\"State: %s, focus: %s\", msg.state, msg.focus)\n\n        frame_info, next_frame_info = self._find_this_and_next_frame(msg.stack)\n        self._update_this_frame(msg, frame_info)\n\n        # clear obsolete next frame visualizer\n        if self._next_frame_visualizer and (\n            not next_frame_info or self._next_frame_visualizer.get_frame_id() != next_frame_info.id\n        ):\n            self._next_frame_visualizer.close()\n            self._next_frame_visualizer = None\n\n        if next_frame_info and not self._next_frame_visualizer:\n            self._next_frame_visualizer = self._create_next_frame_visualizer(next_frame_info)\n            self._next_frame_visualizer._prev_frame_visualizer = self\n\n        if self._next_frame_visualizer:\n            self._next_frame_visualizer.update_this_and_next_frames(msg)", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Updates the current and upcoming frame visualizations based on a message, managing lifecycle and recursion to ensure the display reflects the latest frame states within a sequence."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "remove_focus_tags", "line_number": 423, "body": "def remove_focus_tags(self):\n        for name in [\n            \"exception_focus\",\n            \"active_focus\",\n            \"completed_focus\",\n            \"suspended_focus\",\n            \"sel\",\n        ]:\n            self._text.tag_remove(name, \"0.0\", \"end\")", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Clears specific focus-related text tags from the entire content within the FrameVisualizer's text display, effectively removing visual highlights or selections. This facilitates resetting or updating the visual focus state in the interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "hide_expression_box", "line_number": 433, "body": "def hide_expression_box(self):\n        if self._expression_box is not None:\n            self._expression_box.clear_debug_view()", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Method of FrameVisualizer that clears the debug view of the expression box if it exists, effectively hiding or resetting its displayed content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_this_frame", "line_number": 437, "body": "def _update_this_frame(self, msg, frame_info):\n        self._frame_info = frame_info\n        self.remove_focus_tags()\n\n        if frame_info.event == \"line\":\n            if (\n                frame_info.id in msg[\"exception_info\"][\"affected_frame_ids\"]\n                and msg[\"exception_info\"][\"is_fresh\"]\n            ):\n                self._tag_range(frame_info.focus, \"exception_focus\")\n            else:\n                self._tag_range(frame_info.focus, \"active_focus\")\n        else:\n            if \"statement\" in frame_info.event:\n                if msg[\"exception_info\"][\"msg\"] is not None and msg[\"exception_info\"][\"is_fresh\"]:\n                    stmt_tag = \"exception_focus\"\n                elif frame_info.event.startswith(\"before\"):\n                    stmt_tag = \"active_focus\"\n                else:\n                    stmt_tag = \"completed_focus\"\n            else:\n                assert \"expression\" in frame_info.event\n                stmt_tag = \"suspended_focus\"\n\n            if frame_info.current_statement is not None:\n                self._tag_range(frame_info.current_statement, stmt_tag)\n            else:\n                logging.warning(\"Missing current_statement: %s\", frame_info)\n\n        self._expression_box.update_expression(msg, frame_info)\n\n        if (\n            frame_info.id in msg[\"exception_info\"][\"affected_frame_ids\"]\n            and msg[\"exception_info\"][\"is_fresh\"]\n        ):\n            self._show_exception(msg[\"exception_info\"][\"lines_with_frame_info\"], frame_info)\n        else:\n            self.close_note()", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Internal method of FrameVisualizer that updates visual highlights and exception indicators based on the current frame's execution state, supporting detailed debugging and code step visualization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_show_exception", "line_number": 476, "body": "def _show_exception(self, lines, frame_info):\n        last_line_text = lines[-1][0]\n        self.show_note(\n            last_line_text.strip() + \" \",\n            (\"...\", lambda _: get_workbench().show_view(\"ExceptionView\")),\n            focus=frame_info.focus,\n        )", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Private method of FrameVisualizer that displays the last line of an exception with a clickable note to open the detailed ExceptionView, aiding in quick debugging and error inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_find_this_and_next_frame", "line_number": 484, "body": "def _find_this_and_next_frame(self, stack):\n        for i in range(len(stack)):\n            if stack[i].id == self._frame_id:\n                if i == len(stack) - 1:  # last frame\n                    return stack[i], None\n                else:\n                    return stack[i], stack[i + 1]\n\n        raise AssertionError(\"Frame doesn't exist anymore\")", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Core helper method of the FrameVisualizer class that locates the current frame and its immediate successor within a stack. It facilitates frame-by-frame navigation or comparison in visualization contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_tag_range", "line_number": 494, "body": "def _tag_range(self, text_range, tag):\n        # For most statements I want to highlight block of whole lines\n        # but for pseudo-statements (like header in for-loop) I want to highlight only the indicated range\n\n        self._text.tag_raise(tag)\n\n        line_prefix = self._text.get(\n            \"%d.0\" % self._translate_lineno(text_range.lineno),\n            \"%d.%d\" % (self._translate_lineno(text_range.lineno), text_range.col_offset),\n        )\n        if line_prefix.strip():\n            # pseudo-statement\n            first_line = self._translate_lineno(text_range.lineno)\n            last_line = self._translate_lineno(text_range.end_lineno)\n            self._text.tag_add(\n                tag,\n                \"%d.%d\" % (first_line, text_range.col_offset),\n                \"%d.%d\" % (last_line, text_range.end_col_offset),\n            )\n        else:\n            # normal statement\n            first_line, first_col, last_line = self._get_text_range_block(text_range)\n\n            for lineno in range(first_line, last_line + 1):\n                self._text.tag_add(tag, \"%d.%d\" % (lineno, first_col), \"%d.0\" % (lineno + 1))\n\n        self._text.update_idletasks()\n        self._text.see(\"%d.0\" % (last_line))\n        self._text.see(\"%d.0\" % (first_line))\n\n        if last_line - first_line < 3:\n            # if it's safe to assume that whole code fits into screen\n            # then scroll it down a bit so that expression view doesn't hide behind\n            # lower edge of the editor\n            self._text.update_idletasks()\n            self._text.see(\"%d.0\" % (first_line + 3))", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Marks and highlights a specified text range within a code frame, adjusting the highlight behavior for full-line or partial-line (pseudo-statement) selections to improve code visualization and navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_get_text_range_block", "line_number": 531, "body": "def _get_text_range_block(self, text_range):\n        first_line = text_range.lineno - self._firstlineno + 1\n        last_line = (\n            text_range.end_lineno - self._firstlineno + (1 if text_range.end_col_offset > 0 else 0)\n        )\n        first_line_content = self._text.get(\"%d.0\" % first_line, \"%d.end\" % first_line)\n        if first_line_content.strip().startswith(\"elif \"):\n            first_col = first_line_content.find(\"elif \")\n        else:\n            first_col = text_range.col_offset\n\n        return (first_line, first_col, last_line)", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Private method of FrameVisualizer that determines the line and column boundaries of a given text range within a frame, supporting precise text block location for visualization or analysis purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_create_next_frame_visualizer", "line_number": 544, "body": "def _create_next_frame_visualizer(self, next_frame_info):\n        if next_frame_info.code_name == \"<module>\":\n            return ModuleLoadDialog(self._text, next_frame_info)\n        else:\n            dialog = FunctionCallDialog(self._text.master, next_frame_info)\n\n            if self._expression_box.winfo_ismapped():\n                dialog.title(self._expression_box.get_focused_text())\n            else:\n                dialog.title(tr(\"Function call at %s\") % hex(self._frame_id))\n\n            return dialog", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Creates and returns a visual dialog representing the next frame in execution, differentiating between module loading and function calls, with context-aware titling based on the current UI state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "bring_out_frame", "line_number": 557, "body": "def bring_out_frame(self, frame_id):\n        if self._frame_id == frame_id:\n            self.bring_out_this_frame()\n        elif self._next_frame_visualizer is not None:\n            self._next_frame_visualizer.bring_out_frame(frame_id)", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Method in FrameVisualizer that activates the specified frame by ID, delegating the request to the next visualizer if the frame is not the current one. It allows hierarchical frame management and activation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "show_note", "line_number": 566, "body": "def show_note(self, *content_items: Union[str, List], target=None, focus=None) -> None:\n        if target is None:\n            target = self._text\n\n        self._note_box.show_note(*content_items, target=target, focus=focus)", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Method of FrameVisualizer that displays notes composed of text or lists, targeting a specified area and optionally highlighting focused content. It facilitates flexible presentation of annotations or messages within the visualization frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close_note", "line_number": 572, "body": "def close_note(self):\n        self._note_box.close()", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Closes the active note box in the FrameVisualizer, providing a simple way to dismiss or hide the current note display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_this_frame", "line_number": 589, "body": "def _update_this_frame(self, msg, frame_info):\n        FrameVisualizer._update_this_frame(self, msg, frame_info)\n        if msg.in_present:\n            self._decorate_editor_title(\"\")\n        else:\n            self._decorate_editor_title(\"   <<< REPLAYING >>> \")", "is_method": true, "class_name": "EditorVisualizer", "function_description": "Internal method of EditorVisualizer that updates the current frame visualization and modifies the editor title to indicate whether the frame is live or replaying."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_decorate_editor_title", "line_number": 596, "body": "def _decorate_editor_title(self, suffix):\n        self.editor.master.update_editor_title(self.editor, self.editor.get_title() + suffix)", "is_method": true, "class_name": "EditorVisualizer", "function_description": "Helper method in EditorVisualizer to append a suffix to the editor's current title, updating the display accordingly. It supports dynamic title modifications in the editor interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "bring_out_this_frame", "line_number": 599, "body": "def bring_out_this_frame(self):\n        get_workbench().focus_set()", "is_method": true, "class_name": "EditorVisualizer", "function_description": "Brings the application\u2019s main workbench frame into focus, ensuring user input is directed there. Useful for managing window focus in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear", "line_number": 602, "body": "def clear(self):\n        super().clear()\n        self._decorate_editor_title(\"\")", "is_method": true, "class_name": "EditorVisualizer", "function_description": "Clears the editor's content and removes any title decoration, effectively resetting the editor's display state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_text_options", "line_number": 623, "body": "def get_text_options(self):\n        opts = dict(\n            height=1,\n            width=1,\n            relief=tk.RAISED,\n            background=\"#DCEDF2\",\n            borderwidth=1,\n            highlightthickness=0,\n            padx=7,\n            pady=7,\n            wrap=tk.NONE,\n            font=\"EditorFont\",\n        )\n        opts.update(get_syntax_options_for_tag(\"expression_box\"))\n        return opts", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Provides a set of default and customized text display options for an expression box, including layout, appearance, and syntax highlighting settings used in the UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "update_expression", "line_number": 639, "body": "def update_expression(self, msg, frame_info):\n        focus = frame_info.focus\n        event = frame_info.event\n\n        if frame_info.current_root_expression is not None:\n\n            if self._last_root_expression != frame_info.current_root_expression:\n                # can happen, eg. when focus jumps from the last expr in while body\n                # to while test expression\n                self.clear_debug_view()\n\n            with open(frame_info.filename, \"rb\") as fp:\n                whole_source = fp.read()\n\n            lines = whole_source.splitlines()\n            if len(lines) < frame_info.current_root_expression.end_lineno:\n                # it must be on a synthetical line which is not actually present in the editor\n                self.clear_debug_view()\n                return\n\n            self._load_expression(\n                whole_source, frame_info.filename, frame_info.current_root_expression\n            )\n            for subrange, value in frame_info.current_evaluations:\n                self._replace(subrange, value)\n            if \"expression\" in event:\n                # Event may be also after_statement_again\n                self._highlight_range(\n                    focus,\n                    event,\n                    (\n                        frame_info.id in msg[\"exception_info\"][\"affected_frame_ids\"]\n                        and msg[\"exception_info\"][\"is_fresh\"]\n                    ),\n                )\n                self._last_focus = focus\n\n            self._update_position(frame_info.current_root_expression)\n            self._update_size()\n\n        else:\n            # hide and clear on non-expression events\n            self.clear_debug_view()\n\n        self._last_root_expression = frame_info.current_root_expression", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Updates the displayed expression based on the current debugging frame, reflecting evaluation results, managing highlights, and clearing the view when no valid expression is present. This supports dynamic visualization of code expressions during debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_focused_text", "line_number": 685, "body": "def get_focused_text(self):\n        if self._last_focus:\n            start_mark = self._get_mark_name(self._last_focus.lineno, self._last_focus.col_offset)\n            end_mark = self._get_mark_name(\n                self._last_focus.end_lineno, self._last_focus.end_col_offset\n            )\n            return self.text.get(start_mark, end_mark)\n        else:\n            return \"\"", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Returns the substring of text currently focused by the last selection or cursor position within the BaseExpressionBox. Useful for extracting and working with the precise portion of text under user focus or editing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear_debug_view", "line_number": 695, "body": "def clear_debug_view(self):\n        self._main_range = None\n        self._last_focus = None\n        self._clear_expression()", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Clears the debug state within the BaseExpressionBox by resetting key tracking attributes and removing the current expression. This function supports maintaining a clean debugging environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_clear_expression", "line_number": 700, "body": "def _clear_expression(self):\n        for tag in self.text.tag_names():\n            self.text.tag_remove(tag, \"1.0\", \"end\")\n\n        self.text.mark_unset(*self.text.mark_names())\n        self.text.delete(\"1.0\", \"end\")", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Clears all text content, tags, and marks from the widget's text area. This function resets the text box to an empty state for fresh input or display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_replace", "line_number": 707, "body": "def _replace(self, focus, value):\n        start_mark = self._get_mark_name(focus.lineno, focus.col_offset)\n        end_mark = self._get_mark_name(focus.end_lineno, focus.end_col_offset)\n\n        self.text.delete(start_mark, end_mark)\n\n        id_str = memory.format_object_id(value.id)\n        if get_workbench().in_heap_mode():\n            value_str = id_str\n        else:\n            value_str = shorten_repr(value.repr, 100)\n\n        object_tag = \"object_\" + str(value.id)\n        self.text.insert(start_mark, value_str, (\"value\", object_tag))\n        if misc_utils.running_on_mac_os():\n            sequence = \"<Command-Button-1>\"\n        else:\n            sequence = \"<Control-Button-1>\"\n        self.text.tag_bind(\n            object_tag,\n            sequence,\n            lambda _: get_workbench().event_generate(\"ObjectSelect\", object_id=value.id),\n        )", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Utility method in BaseExpressionBox that replaces a specified text segment with a formatted representation of a given object, adding interactive tagging linked to the object's identity for user selection events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_load_expression", "line_number": 731, "body": "def _load_expression(self, whole_source, filename, text_range):\n\n        root = ast_utils.parse_source(whole_source, filename)\n        main_node = ast_utils.find_expression(root, text_range)\n\n        source = ast_utils.extract_text_range(whole_source, text_range)\n        logging.debug(\"EV.load_exp: %s\", (text_range, main_node, source))\n\n        self._clear_expression()\n\n        self.text.insert(\"1.0\", source)\n\n        # create node marks\n        def _create_index(lineno, col_offset):\n            local_lineno = lineno - main_node.lineno + 1\n            if lineno == main_node.lineno:\n                local_col_offset = col_offset - main_node.col_offset\n            else:\n                local_col_offset = col_offset\n\n            return str(local_lineno) + \".\" + str(local_col_offset)\n\n        for node in ast.walk(main_node):\n            if \"lineno\" in node._attributes and hasattr(node, \"end_lineno\"):\n                index1 = _create_index(node.lineno, node.col_offset)\n                index2 = _create_index(node.end_lineno, node.end_col_offset)\n\n                start_mark = self._get_mark_name(node.lineno, node.col_offset)\n                if not start_mark in self.text.mark_names():\n                    self.text.mark_set(start_mark, index1)\n                    # print(\"Creating mark\", start_mark, index1)\n                    self.text.mark_gravity(start_mark, tk.LEFT)\n\n                end_mark = self._get_mark_name(node.end_lineno, node.end_col_offset)\n                if not end_mark in self.text.mark_names():\n                    self.text.mark_set(end_mark, index2)\n                    # print(\"Creating mark\", end_mark, index2)\n                    self.text.mark_gravity(end_mark, tk.RIGHT)", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "This method processes and displays a specific code expression extracted from source text, marking its AST node positions for later reference or editing within a text widget. It enables precise interaction with parsed code fragments in the context of the BaseExpressionBox UI component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_get_mark_name", "line_number": 770, "body": "def _get_mark_name(self, lineno, col_offset):\n        return str(lineno) + \"_\" + str(col_offset)", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Private utility method of BaseExpressionBox that generates a unique string identifier by combining a line number and column offset, useful for marking positions within source code or expressions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_get_tag_name", "line_number": 773, "body": "def _get_tag_name(self, node_or_text_range):\n        return (\n            str(node_or_text_range.lineno)\n            + \"_\"\n            + str(node_or_text_range.col_offset)\n            + \"_\"\n            + str(node_or_text_range.end_lineno)\n            + \"_\"\n            + str(node_or_text_range.end_col_offset)\n        )", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Generates a unique string tag based on the positional attributes of a code node or text range, facilitating identification or referencing within the BaseExpressionBox context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_highlight_range", "line_number": 784, "body": "def _highlight_range(self, text_range, state, has_exception):\n        logging.debug(\"EV._highlight_range: %s\", text_range)\n        self.text.tag_remove(\"after\", \"1.0\", \"end\")\n        self.text.tag_remove(\"before\", \"1.0\", \"end\")\n        self.text.tag_remove(\"exception\", \"1.0\", \"end\")\n\n        if state.startswith(\"after\"):\n            tag = \"after\"\n        elif state.startswith(\"before\"):\n            tag = \"before\"\n        else:\n            return\n\n        start_index = self._get_mark_name(text_range.lineno, text_range.col_offset)\n        end_index = self._get_mark_name(text_range.end_lineno, text_range.end_col_offset)\n        self.text.tag_add(tag, start_index, end_index)\n\n        if has_exception:\n            self.text.tag_add(\"exception\", start_index, end_index)", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Highlights a specified text range in the BaseExpressionBox widget by applying visual tags based on state and exception presence, aiding in contextual text display and error indication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_position", "line_number": 804, "body": "def _update_position(self, text_range):\n        self._codeview.update_idletasks()\n        text_line_number = text_range.lineno - self._codeview._first_line_number + 1\n        bbox = self._codeview.text.bbox(str(text_line_number) + \".\" + str(text_range.col_offset))\n\n        if isinstance(bbox, tuple):\n            x = bbox[0] - self._codeview.text.cget(\"padx\") + 6\n            y = bbox[1] - self._codeview.text.cget(\"pady\") - 6\n        else:\n            x = 30\n            y = 30\n\n        self._set_position_make_visible(x, y)", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Updates the position of the expression box in the UI based on a specified text range, ensuring it is visible and aligned with the corresponding text in the code view. It supports synchronizing UI elements with text cursor location for better user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_size", "line_number": 818, "body": "def _update_size(self):\n        content = self.text.get(\"1.0\", tk.END)\n        lines = content.splitlines()\n        self.text[\"height\"] = len(lines)\n        self.text[\"width\"] = max(map(len, lines))", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Utility method of BaseExpressionBox that adjusts the text box dimensions to fit its current content by updating its height and width based on the number and length of text lines."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear_debug_view", "line_number": 833, "body": "def clear_debug_view(self):\n        if self.winfo_ismapped():\n            self.place_forget()\n\n        super().clear_debug_view()", "is_method": true, "class_name": "PlacedExpressionBox", "function_description": "Clears the debug view of a PlacedExpressionBox by hiding it if currently displayed, then performs any additional cleanup defined in the superclass. This supports managing the visibility of debug information in the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_set_position_make_visible", "line_number": 839, "body": "def _set_position_make_visible(self, rel_x, rel_y):\n        x = rel_x\n        y = rel_y\n\n        widget = self._codeview.text\n        while widget != self.master:\n            x += widget.winfo_x()\n            y += widget.winfo_y()\n            widget = widget.master\n\n        if not self.winfo_ismapped():\n            self.place(x=x, y=y, anchor=tk.NW)\n            self.update()", "is_method": true, "class_name": "PlacedExpressionBox", "function_description": "Sets the widget\u2019s position relative to its container and makes it visible by placing it at the calculated absolute coordinates within the GUI hierarchy. Useful for dynamically positioning interface elements within nested widget structures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear_debug_view", "line_number": 880, "body": "def clear_debug_view(self):\n        if self.winfo_ismapped():\n            self.withdraw()\n\n        super().clear_debug_view()", "is_method": true, "class_name": "ToplevelExpressionBox", "function_description": "Method of ToplevelExpressionBox that hides the debug view if it's currently visible and then performs standard debug view clearing operations. It ensures the debug interface is properly reset and hidden when requested."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_set_position_make_visible", "line_number": 886, "body": "def _set_position_make_visible(self, rel_x, rel_y):\n        \"\"\"\n        widget = self._codeview.text\n        while widget is not None:\n            x += widget.winfo_x()\n            y += widget.winfo_y()\n            widget = widget.master\n        \"\"\"\n        x = rel_x + self._codeview.text.winfo_rootx()\n        y = rel_y + self._codeview.text.winfo_rooty()\n\n        if not self.winfo_ismapped():\n            self.update()\n            self.deiconify()\n        self.geometry(\"+%d+%d\" % (x, y))", "is_method": true, "class_name": "ToplevelExpressionBox", "function_description": "Sets the widget's screen position relative to a code view and ensures it is visible by mapping and updating its geometry. This method helps display the expression box at a specific location within the UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_text_options", "line_number": 902, "body": "def get_text_options(self):\n        opts = super().get_text_options()\n        opts[\"relief\"] = \"flat\"\n        opts[\"borderwidth\"] = 0\n        return opts", "is_method": true, "class_name": "ToplevelExpressionBox", "function_description": "Method of ToplevelExpressionBox that customizes and returns text display options by modifying the base options to have a flat relief and no border, likely for refined UI appearance in expression boxes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_init_layout_widgets", "line_number": 944, "body": "def _init_layout_widgets(self, master, frame_info):\n        self.main_frame = ttk.Frame(\n            self\n        )  # just a background behind padding of main_pw, without this OS X leaves white border\n        self.main_frame.grid(sticky=tk.NSEW)\n        self.rowconfigure(0, weight=1)\n        self.columnconfigure(0, weight=1)\n        self.main_pw = ui_utils.AutomaticPanedWindow(self.main_frame, orient=tk.VERTICAL)\n        self.main_pw.grid(sticky=tk.NSEW, padx=10, pady=10)\n        self.main_frame.rowconfigure(0, weight=1)\n        self.main_frame.columnconfigure(0, weight=1)\n\n        self._code_book = ttk.Notebook(self.main_pw)\n        self._text_frame = CodeView(\n            self._code_book, first_line_number=frame_info.firstlineno, font=\"EditorFont\"\n        )\n        self._code_book.add(self._text_frame, text=tr(\"Source code\"))\n        self.main_pw.add(self._code_book, minsize=200)\n        self._code_book.preferred_size_in_pw = 400", "is_method": true, "class_name": "DialogVisualizer", "function_description": "Initializes and arranges the main layout widgets within the DialogVisualizer, setting up frames, panes, and a notebook for displaying source code with proper sizing and padding."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_load_code", "line_number": 964, "body": "def _load_code(self, frame_info):\n        self._text_frame.set_content(frame_info.source)", "is_method": true, "class_name": "DialogVisualizer", "function_description": "Private method of DialogVisualizer that sets the text frame content to the source code from the provided frame information, supporting visualization of code within dialog contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_this_frame", "line_number": 967, "body": "def _update_this_frame(self, msg, frame_info):\n        FrameVisualizer._update_this_frame(self, msg, frame_info)", "is_method": true, "class_name": "DialogVisualizer", "function_description": "This private method in DialogVisualizer overrides or extends frame update behavior by delegating to the FrameVisualizer's update method, enabling customized frame processing within dialog visualization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "bring_out_this_frame", "line_number": 970, "body": "def bring_out_this_frame(self):\n        self.focus_set()  # no effect when clicking on stack view\n        var_view = get_workbench().get_view(\"VariablesView\")\n        var_view.show_globals(self._frame_info.globals, self._frame_info.module_name)", "is_method": true, "class_name": "DialogVisualizer", "function_description": "Method of the DialogVisualizer class that focuses the dialog and displays the global variables of the current frame in the VariablesView, facilitating inspection of the program state during debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_on_close", "line_number": 979, "body": "def _on_close(self):\n        showinfo(\n            tr(\"Can't close yet\"),\n            tr('Use \"Stop\" command if you want to cancel debugging'),\n            master=self,\n        )", "is_method": true, "class_name": "DialogVisualizer", "function_description": "Private method in DialogVisualizer that prevents closing the window prematurely by informing users to use the \"Stop\" command to cancel debugging instead."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close", "line_number": 986, "body": "def close(self, frame_id=None):\n        super().close()\n\n        if frame_id is None or frame_id == self._frame_id:\n            self.destroy()", "is_method": true, "class_name": "DialogVisualizer", "function_description": "Utility method of DialogVisualizer that closes the current dialog or a specified frame, ensuring proper cleanup and destruction when the targeted frame matches or is unspecified."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_init_layout_widgets", "line_number": 997, "body": "def _init_layout_widgets(self, master, frame_info):\n        DialogVisualizer._init_layout_widgets(self, master, frame_info)\n        self._locals_book = ttk.Notebook(self.main_pw)\n        self._locals_frame = VariablesFrame(self._locals_book)\n        self._locals_book.preferred_size_in_pw = 200\n        self._locals_book.add(self._locals_frame, text=tr(\"Local variables\"))\n        self.main_pw.add(self._locals_book, minsize=100)", "is_method": true, "class_name": "FunctionCallDialog", "function_description": "Sets up the graphical layout for the dialog, adding a tabbed section to display local variables within the main panel. This prepares the interface for variable inspection during function call dialogs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_load_code", "line_number": 1005, "body": "def _load_code(self, frame_info):\n        DialogVisualizer._load_code(self, frame_info)\n\n        function_label = frame_info.code_name\n\n        # change tab label\n        self._code_book.tab(self._text_frame, text=function_label)", "is_method": true, "class_name": "FunctionCallDialog", "function_description": "Private method in FunctionCallDialog that updates the dialog's code display by loading new code context and setting the tab label to the current function's name."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_this_frame", "line_number": 1013, "body": "def _update_this_frame(self, msg, frame_info):\n        DialogVisualizer._update_this_frame(self, msg, frame_info)\n        self._locals_frame.update_variables(frame_info.locals)", "is_method": true, "class_name": "FunctionCallDialog", "function_description": "Core internal method of FunctionCallDialog that updates the current frame's state by refreshing visualization and local variables, supporting accurate and synchronized dialog representation during function call tracing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_stack", "line_number": 1041, "body": "def _update_stack(self, msg):\n        self._clear_tree()\n\n        node_id = None\n        for frame in msg.stack:\n            lineno = frame.focus.lineno\n\n            node_id = self.tree.insert(\"\", \"end\")\n            self.tree.set(node_id, \"function\", frame.code_name)\n            self.tree.set(\n                node_id, \"location\", \"%s, line %s\" % (os.path.basename(frame.filename), lineno)\n            )\n            self.tree.set(node_id, \"id\", frame.id)\n\n        # select last frame\n        if node_id is not None:\n            self.tree.see(node_id)\n            self.tree.selection_add(node_id)\n            self.tree.focus(node_id)", "is_method": true, "class_name": "StackView", "function_description": "Updates the StackView's tree display to reflect the current stack frames from a message, showing function names, file locations, and selecting the most recent frame for user focus."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_handle_debugger_return", "line_number": 1061, "body": "def _handle_debugger_return(self, msg):\n        delete = False\n        for iid in self.tree.get_children():\n            if self.tree.set(iid, \"id\") == msg[\"frame_id\"]:\n                # start deleting from this frame\n                delete = True\n\n            if delete:\n                self.tree.delete(iid)", "is_method": true, "class_name": "StackView", "function_description": "Internal method of StackView that removes debugger stack frames from a specified frame ID onward, effectively updating the stack view by deleting relevant frames."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "on_select", "line_number": 1071, "body": "def on_select(self, event):\n        iid = self.tree.focus()\n        if iid != \"\":\n            # assuming id is in the last column\n            frame_id = self.tree.item(iid)[\"values\"][-1]\n            if _current_debugger is not None:\n                _current_debugger.bring_out_frame(frame_id)", "is_method": true, "class_name": "StackView", "function_description": "Handles selection events in the StackView by identifying the selected frame and instructing the debugger to display its details. This enables interactive navigation through stack frames during debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_show_description", "line_number": 1107, "body": "def _show_description(self):\n        self.text.configure(foreground=get_syntax_options_for_tag(\"TEXT\")[\"foreground\"])\n        self.text.direct_insert(\n            \"end\",\n            tr(\"If last command raised an exception then this view will show the stacktrace.\"),\n        )", "is_method": true, "class_name": "ExceptionView", "function_description": "Provides a descriptive message in the ExceptionView indicating that it displays the stack trace when the last command raised an exception. This helps users understand the purpose of the view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "set_exception", "line_number": 1114, "body": "def set_exception(self, exception_lines_with_frame_info):\n        if exception_lines_with_frame_info == self._prev_exception:\n            return\n\n        self.text.direct_delete(\"1.0\", \"end\")\n\n        if exception_lines_with_frame_info is None:\n            self._show_description()\n            return\n\n        self.text.configure(foreground=get_syntax_options_for_tag(\"stderr\")[\"foreground\"])\n        for line, frame_id, filename, lineno in exception_lines_with_frame_info:\n\n            if frame_id is not None:\n                frame_tag = \"frame_%d\" % frame_id\n\n                def handle_frame_click(event, frame_id=frame_id, filename=filename, lineno=lineno):\n                    get_runner().send_command(InlineCommand(\"get_frame_info\", frame_id=frame_id))\n                    if os.path.exists(filename):\n                        get_workbench().get_editor_notebook().show_file(\n                            filename, lineno, set_focus=False\n                        )\n\n                self.text.tag_bind(frame_tag, \"<1>\", handle_frame_click, True)\n\n                start = max(line.find(\"File\"), 0)\n                end = line.replace(\"\\r\", \"\").find(\"\\n\")\n                if end < 10:\n                    end = len(line)\n\n                self.text.direct_insert(\"end\", line[:start])\n                self.text.direct_insert(\"end\", line[start:end], (\"hyperlink\", frame_tag))\n                self.text.direct_insert(\"end\", line[end:])\n\n            else:\n                self.text.direct_insert(\"end\", line)\n\n        self._prev_exception = exception_lines_with_frame_info", "is_method": true, "class_name": "ExceptionView", "function_description": "Updates the exception display with detailed traceback lines, embedding clickable links to source code frames for quick navigation and context within the ExceptionView interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_on_toplevel_response", "line_number": 1153, "body": "def _on_toplevel_response(self, msg):\n        if \"user_exception\" in msg:\n            self.set_exception(msg[\"user_exception\"][\"items\"])\n        else:\n            self.set_exception(None)", "is_method": true, "class_name": "ExceptionView", "function_description": "Handles top-level response messages by detecting and setting user exceptions for further processing or clearing exceptions if none are present."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_hyperlink_enter", "line_number": 1159, "body": "def _hyperlink_enter(self, event):\n        self.text.config(cursor=\"hand2\")", "is_method": true, "class_name": "ExceptionView", "function_description": "Sets the cursor to a hand icon when hovering over a hyperlink, indicating interactivity within the ExceptionView text display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_hyperlink_leave", "line_number": 1162, "body": "def _hyperlink_leave(self, event):\n        self.text.config(cursor=\"\")", "is_method": true, "class_name": "ExceptionView", "function_description": "Utility method in ExceptionView that resets the cursor to default when the mouse pointer leaves a hyperlink area, enhancing user interface interaction responsiveness."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "create_edit_command_handler", "line_number": 131, "body": "def create_edit_command_handler(virtual_event_sequence):\n            def handler(event=None):\n                widget = get_workbench().focus_get()\n                if widget:\n                    return widget.event_generate(virtual_event_sequence)\n\n                return None\n\n            return handler", "is_method": true, "class_name": "Debugger", "function_description": "Creates and returns an event handler that triggers a specified virtual event on the currently focused widget, facilitating custom event-driven behavior within the debugging environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_create_index", "line_number": 744, "body": "def _create_index(lineno, col_offset):\n            local_lineno = lineno - main_node.lineno + 1\n            if lineno == main_node.lineno:\n                local_col_offset = col_offset - main_node.col_offset\n            else:\n                local_col_offset = col_offset\n\n            return str(local_lineno) + \".\" + str(local_col_offset)", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Private helper method that computes a local index string combining line and column offsets relative to a main node, typically used for precise position tracking within a text or code block."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handler", "line_number": 132, "body": "def handler(event=None):\n                widget = get_workbench().focus_get()\n                if widget:\n                    return widget.event_generate(virtual_event_sequence)\n\n                return None", "is_method": true, "class_name": "Debugger", "function_description": "This function generates a specific virtual event on the currently focused widget in the workbench, facilitating event-driven interactions within the debugger interface. It enables triggering custom behavior tied to user interface focus."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handle_frame_click", "line_number": 1130, "body": "def handle_frame_click(event, frame_id=frame_id, filename=filename, lineno=lineno):\n                    get_runner().send_command(InlineCommand(\"get_frame_info\", frame_id=frame_id))\n                    if os.path.exists(filename):\n                        get_workbench().get_editor_notebook().show_file(\n                            filename, lineno, set_focus=False\n                        )", "is_method": true, "class_name": "ExceptionView", "function_description": "Handles a click event on a stack frame by requesting frame information and, if available, opening the corresponding file at the specified line in the editor without changing focus."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "get_ssh_password", "line_number": 293, "body": "def get_ssh_password(conf_group):\n    host = get_workbench().get_option(conf_group + \".host\")\n    user = get_workbench().get_option(conf_group + \".user\")\n    method = get_workbench().get_option(conf_group + \".auth_method\")\n    if method == PUBLIC_KEY_NO_PASS_METHOD:\n        return None\n    elif os.path.exists(get_ssh_password_file_path()):\n        with open(get_ssh_password_file_path()) as fp:\n            return fp.read().strip()\n    else:\n        dlg = PasswordDialog(get_workbench(), host, user, method)\n        ui_utils.show_dialog(dlg)\n        if dlg.password and dlg.save_password:\n            with open(get_ssh_password_file_path(), \"w\") as fp:\n                fp.write(dlg.password)\n\n        if not dlg.save_password or not dlg.password:\n            delete_stored_ssh_password()\n\n        return dlg.password", "is_method": false, "function_description": "Function that obtains the SSH password for a given configuration group by checking authentication method, reading saved passwords, or prompting the user with an option to save it for future use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "load_plugin", "line_number": 315, "body": "def load_plugin() -> None:\n    def select_device():\n        get_workbench().show_options(\"interpreter\")\n\n    get_workbench().add_configuration_page(\n        \"interpreter\", tr(\"Interpreter\"), BackendConfigurationPage, 20\n    )\n    get_workbench().add_command(\n        \"select_interpreter\", \"run\", tr(\"Select interpreter\") + \"...\", select_device, group=1\n    )", "is_method": false, "function_description": "Registers an interpreter selection interface and related commands in the workbench, enabling users to configure and choose the Python interpreter within the application environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "_add_text_field", "line_number": 25, "body": "def _add_text_field(\n        self, label_text, variable_name, row, show=None, pady: Union[int, tuple] = 0, width=None\n    ):\n\n        if isinstance(pady, int):\n            pady = (pady, pady)\n\n        entry_label = ttk.Label(self, text=label_text)\n        entry_label.grid(row=row, column=0, sticky=\"w\", pady=pady)\n\n        variable = create_string_var(get_workbench().get_option(variable_name), self._on_change)\n        entry = ttk.Entry(self, textvariable=variable, show=show, width=width)\n        entry.grid(row=row, column=1, sticky=\"we\", pady=pady, padx=ems_to_pixels(1))\n        return variable", "is_method": true, "class_name": "BackendDetailsConfigPage", "function_description": "Adds a labeled text entry field to the interface, linking it to a variable with change monitoring. This method supports customized display options and layout positioning within the BackendDetailsConfigPage UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "_add_combobox_field", "line_number": 40, "body": "def _add_combobox_field(\n        self, label_text, variable_name, row, options, pady: Union[int, tuple] = 0, width=None\n    ):\n        if isinstance(pady, int):\n            pady = (pady, pady)\n\n        label = ttk.Label(self, text=label_text)\n        label.grid(row=row, column=0, sticky=\"w\", pady=pady)\n\n        variable = create_string_var(get_workbench().get_option(variable_name), self._on_change)\n        return self.add_combobox(\n            variable, options, row=row, column=1, pady=pady, padx=ems_to_pixels(1), width=width\n        )", "is_method": true, "class_name": "BackendDetailsConfigPage", "function_description": "Utility method in BackendDetailsConfigPage that adds a labeled combobox widget to the interface, linking it to a variable and handling its layout and change events. It simplifies creating configurable dropdown fields in the UI form."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "should_restart", "line_number": 61, "body": "def should_restart(self):\n        return False", "is_method": true, "class_name": "OnlyTextConfigurationPage", "function_description": "This method indicates whether a restart is required for the OnlyTextConfigurationPage. It consistently signals that no restart is needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "_backend_changed", "line_number": 114, "body": "def _backend_changed(self, *args):\n        backend_desc = self._combo_variable.get()\n\n        if backend_desc == \"\":\n            if self._current_page is not None:\n                self._current_page.grid_forget()\n            return\n\n        page = self._get_conf_page(backend_desc)\n\n        if page != self._current_page:\n\n            if self._current_page is not None:\n                self._current_page.grid_forget()\n\n            page.grid(sticky=\"nsew\", padx=10, pady=5)\n            self._current_page = page", "is_method": true, "class_name": "BackendConfigurationPage", "function_description": "Updates the displayed configuration page based on the selected backend, ensuring only the relevant settings page is visible to the user in the BackendConfigurationPage interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "_get_conf_page", "line_number": 132, "body": "def _get_conf_page(self, backend_desc):\n        if backend_desc not in self._conf_pages:\n            cp_constructor = self._backend_specs_by_desc[backend_desc].config_page_constructor\n            if isinstance(cp_constructor, str):\n                self._conf_pages[backend_desc] = OnlyTextConfigurationPage(\n                    self.labelframe, cp_constructor\n                )\n            else:\n                assert issubclass(cp_constructor, ConfigurationPage)\n                self._conf_pages[backend_desc] = cp_constructor(self.labelframe)\n\n        return self._conf_pages[backend_desc]", "is_method": true, "class_name": "BackendConfigurationPage", "function_description": "Internal method of BackendConfigurationPage that retrieves or creates a configuration page instance for a given backend description, caching it to avoid redundant construction and support backend-specific configuration management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "apply", "line_number": 145, "body": "def apply(self):\n        if self._current_page is None:\n            return None\n\n        result = self._current_page.apply()\n\n        if result is False:\n            return False\n\n        backend_desc = self._combo_variable.get()\n        backend_name = self._backend_specs_by_desc[backend_desc].name\n        get_workbench().set_option(\"run.backend_name\", backend_name)\n\n        if getattr(self._combo_variable, \"modified\") or self._current_page.should_restart():\n            self.dialog.backend_restart_required = True\n\n        return None", "is_method": true, "class_name": "BackendConfigurationPage", "function_description": "Method of BackendConfigurationPage that applies the current backend configuration, updates the selected backend name, and signals if a backend restart is required based on changes or restart conditions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "_on_change", "line_number": 203, "body": "def _on_change(self):\n        self._changed = True", "is_method": true, "class_name": "BaseSshProxyConfigPage", "function_description": "Marks the configuration page as changed to indicate unsaved modifications, supporting change tracking within the BaseSshProxyConfigPage class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "apply", "line_number": 206, "body": "def apply(self):\n        if self._changed:\n            get_workbench().set_option(self._conf_group + \".host\", self._host_var.get())\n            get_workbench().set_option(self._conf_group + \".user\", self._user_var.get())\n            get_workbench().set_option(self._conf_group + \".auth_method\", self._method_var.get())\n            get_workbench().set_option(\n                self._conf_group + \".executable\", self._interpreter_var.get()\n            )\n\n            delete_stored_ssh_password()\n\n            # reset cwd setting to default\n            get_workbench().set_option(self._conf_group + \".cwd\", \"\")", "is_method": true, "class_name": "BaseSshProxyConfigPage", "function_description": "Method of BaseSshProxyConfigPage that saves modified SSH configuration settings to the workbench and resets sensitive data and working directory to defaults upon changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "should_restart", "line_number": 220, "body": "def should_restart(self):\n        return self._changed", "is_method": true, "class_name": "BaseSshProxyConfigPage", "function_description": "Indicates whether the SSH proxy configuration page has been modified and requires a restart to apply changes. This helps other components decide if a restart action is necessary."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "on_ok", "line_number": 282, "body": "def on_ok(self, event=None):\n        self.password = self.entry_widget.get()\n        self.save_password = self.save_variable.get()\n        self.destroy()", "is_method": true, "class_name": "PasswordDialog", "function_description": "Handles user confirmation by capturing the entered password and save preference, then closes the password dialog. It facilitates secure password input and optional saving in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "on_cancel", "line_number": 287, "body": "def on_cancel(self, event=None):\n        self.password = None\n        self.save_variable = False\n        self.destroy()", "is_method": true, "class_name": "PasswordDialog", "function_description": "Handles the cancellation of the password dialog by clearing stored password data and closing the dialog, preventing any password from being saved or processed further."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "select_device", "line_number": 316, "body": "def select_device():\n        get_workbench().show_options(\"interpreter\")", "is_method": false, "function_description": "Displays the available interpreter options in the workbench interface for the user to select a device or environment to run code on."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_view.py", "function": "load_plugin", "line_number": 37, "body": "def load_plugin() -> None:\n    if get_workbench().get_option(\"general.debug_mode\"):\n        get_workbench().add_view(EventsView, tr(\"Events\"), \"se\")", "is_method": false, "function_description": "Enables debug mode features by adding an event view in the workbench interface if debug mode is active; facilitates monitoring events during development or troubleshooting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_view.py", "function": "_log_event", "line_number": 21, "body": "def _log_event(self, event):\n        self.text.insert(\"end\", event.sequence + \"\\n\")\n        for name in dir(event):\n            if name not in [\"sequence\", \"setdefault\", \"update\"] and not name.startswith(\"_\"):\n                self.text.insert(\n                    \"end\", \"    \" + name + \": \" + repr(getattr(event, name))[:100] + \"\\n\"\n                )\n\n        if isinstance(event, DebuggerResponse):\n            frame = event.stack[-1]\n            self.text.insert(\"end\", \"    \" + \"event\" + \": \" + frame.event + \"\\n\")\n            self.text.insert(\"end\", \"    \" + \"focus\" + \": \" + str(frame.focus) + \"\\n\")\n\n        self.text.see(\"end\")", "is_method": true, "class_name": "EventsView", "function_description": "Logs detailed attributes of an event to a textual interface, displaying key properties and specific debugger response details for monitoring and debugging event sequences within the EventsView UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/remove_old_data_dir.py", "function": "load_plugin", "line_number": 7, "body": "def load_plugin():\n    old_data_dir = os.path.join(os.path.expanduser(\"~\"), \".thonny\")\n    if os.path.exists(old_data_dir):\n\n        def doit():\n            import shutil\n\n            if not os.path.exists(old_data_dir):\n                showinfo(\n                    \"Already deleted\", \"Looks like it's already deleted\", master=get_workbench()\n                )\n                return\n\n            answer = askyesno(\n                \"Delete old data directory?\",\n                \"Thonny versions before 3.0 (and first 3.0 betas) used to keep \"\n                + \"configuration, logs and such in '%s'\" % old_data_dir\n                + \". \"\n                + \"Since 3.0 this data is kept in a new location: '%s'.\\n\\n\" % THONNY_USER_DIR\n                + \"If you don't intend to use older Thonny versions anymore, \"\n                + \"you probably want to delete the old directory and reclaim disk space.\\n\\n\"\n                + \"Do you want me to delete this directory now?\",\n                master=get_workbench(),\n            )\n            if answer:\n                shutil.rmtree(old_data_dir, True)\n                shutil.rmtree(old_data_dir, True)  # first one may keep empty directory\n                showinfo(\"Done!\", \"Done!\", master=get_workbench())\n\n        get_workbench().add_command(\n            \"delolddatadir\", \"tools\", \"Clean up Thonny 2.1 data folder ...\", doit, group=110\n        )", "is_method": false, "function_description": "Function that checks for an old configuration directory from previous Thonny versions and adds a user-invoked command to optionally delete it, helping users reclaim disk space from outdated data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/remove_old_data_dir.py", "function": "doit", "line_number": 11, "body": "def doit():\n            import shutil\n\n            if not os.path.exists(old_data_dir):\n                showinfo(\n                    \"Already deleted\", \"Looks like it's already deleted\", master=get_workbench()\n                )\n                return\n\n            answer = askyesno(\n                \"Delete old data directory?\",\n                \"Thonny versions before 3.0 (and first 3.0 betas) used to keep \"\n                + \"configuration, logs and such in '%s'\" % old_data_dir\n                + \". \"\n                + \"Since 3.0 this data is kept in a new location: '%s'.\\n\\n\" % THONNY_USER_DIR\n                + \"If you don't intend to use older Thonny versions anymore, \"\n                + \"you probably want to delete the old directory and reclaim disk space.\\n\\n\"\n                + \"Do you want me to delete this directory now?\",\n                master=get_workbench(),\n            )\n            if answer:\n                shutil.rmtree(old_data_dir, True)\n                shutil.rmtree(old_data_dir, True)  # first one may keep empty directory\n                showinfo(\"Done!\", \"Done!\", master=get_workbench())", "is_method": false, "function_description": "Function that prompts the user to confirm and delete an old data directory from earlier Thonny versions to free up disk space. It provides an interactive cleanup utility for migrating user data to a new location."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/misc_analyzers.py", "function": "load_plugin", "line_number": 297, "body": "def load_plugin():\n    add_program_analyzer(ProgramNamingAnalyzer)", "is_method": false, "function_description": "Registers the ProgramNamingAnalyzer plugin by adding it to the program analyzer system. This function enables the integration of naming analysis capabilities into the broader analysis framework."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/misc_analyzers.py", "function": "start_analysis", "line_number": 224, "body": "def start_analysis(self, main_file_path, imported_file_paths):\n        self.completion_handler(self, list(self._get_warnings(main_file_path)))", "is_method": true, "class_name": "ProgramNamingAnalyzer", "function_description": "Initializing the analysis process by generating warnings for a given main file and invoking a completion handler with these results. This function triggers the core analysis workflow in the ProgramNamingAnalyzer class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/misc_analyzers.py", "function": "_get_warnings", "line_number": 227, "body": "def _get_warnings(self, main_file_path):\n        from thonny import rst_utils\n\n        # TODO: current dir may be different\n        main_file_dir = os.path.dirname(main_file_path)\n        if not os.path.isdir(main_file_dir):\n            return\n\n        library_modules = known_stdlib_modules | self._get_3rd_party_modules()\n\n        for item in os.listdir(main_file_dir):\n            full_path = os.path.join(main_file_dir, item)\n            if item.endswith(\".py\") and item[:-3] in library_modules:\n\n                if is_same_path(full_path, main_file_path):\n                    prelude = \"Your program file is named '%s'.\" % item\n                    rename_hint = \" (*File \u2192 Rename\u2026* )\"\n                else:\n                    prelude = (\n                        \"Your working directory `%s <%s>`__ contains a file named '%s'.\\n\\n\"\n                        % (rst_utils.escape(main_file_dir), rst_utils.escape(main_file_dir), item)\n                    )\n                    rename_hint = \"\"\n\n                yield {\n                    \"filename\": full_path,\n                    \"lineno\": 0,\n                    \"symbol\": \"file-shadows-library-module\",\n                    \"msg\": \"Possibly bad file name\",\n                    \"explanation_rst\": prelude\n                    + \"\\n\\n\"\n                    + \"When you try to import library module ``%s``, your file will be imported instead.\\n\\n\"\n                    % item[:-3]\n                    + \"Rename your '%s'%s to make the library module visible again.\"\n                    % (item, rename_hint),\n                    \"group\": \"warnings\",\n                    \"relevance\": 5,\n                }", "is_method": true, "class_name": "ProgramNamingAnalyzer", "function_description": "Identifies potential naming conflicts where program files shadow standard or third-party library modules, generating warnings to help avoid import errors caused by such naming collisions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/misc_analyzers.py", "function": "_get_3rd_party_modules", "line_number": 266, "body": "def _get_3rd_party_modules(self):\n        proxy = get_runner().get_backend_proxy()\n        from thonny.plugins.cpython import CPythonProxy\n\n        if not isinstance(proxy, CPythonProxy):\n            return []\n\n        try:\n            sys_path = proxy.get_sys_path()\n        except Exception:\n            logging.exception(\"Can't get sys path from proxy\")\n            return []\n\n        module_names = set()\n        for item in sys_path:\n            if os.path.isdir(item) and (\"site-packages\" in item or \"dist-packages\" in item):\n                module_names.update(self._get_module_names(item))\n                for name in os.listdir(item):\n                    if \"-\" not in name:\n                        module_names.add(name.replace(\".py\", \"\"))\n\n        return module_names", "is_method": true, "class_name": "ProgramNamingAnalyzer", "function_description": "Private method of ProgramNamingAnalyzer that identifies and returns third-party Python module names installed in the environment by inspecting standard package directories from the Python backend proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/misc_analyzers.py", "function": "_get_module_names", "line_number": 289, "body": "def _get_module_names(self, dir_path):\n        result = set()\n        for name in os.listdir(dir_path):\n            if \"-\" not in name:\n                result.add(name.replace(\".py\", \"\"))\n        return result", "is_method": true, "class_name": "ProgramNamingAnalyzer", "function_description": "Utility method of ProgramNamingAnalyzer that collects Python module names from a directory, excluding files with dashes, to support analysis or processing of module naming conventions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/about.py", "function": "load_plugin", "line_number": 139, "body": "def load_plugin() -> None:\n    def open_about(*args):\n        ui_utils.show_dialog(AboutDialog(get_workbench()))\n\n    def open_url(url):\n        import webbrowser\n\n        # webbrowser.open returns bool, but add_command expects None\n        webbrowser.open(url)\n\n    get_workbench().add_command(\n        \"changelog\",\n        \"help\",\n        tr(\"Version history\"),\n        lambda: open_url(\"https://github.com/thonny/thonny/blob/master/CHANGELOG.rst\"),\n        group=60,\n    )\n    get_workbench().add_command(\n        \"issues\",\n        \"help\",\n        tr(\"Report problems\"),\n        lambda: open_url(\"https://github.com/thonny/thonny/issues/new\"),\n        group=60,\n    )\n    get_workbench().add_command(\"about\", \"help\", tr(\"About Thonny\"), open_about, group=61)\n\n    # For Mac\n    get_workbench().createcommand(\"tkAboutDialog\", open_about)", "is_method": false, "function_description": "Initializes and registers help-related commands and dialogs in the application's user interface, enabling users to access the about dialog, view changelogs, and report issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/about.py", "function": "_ok", "line_number": 127, "body": "def _ok(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "AboutDialog", "function_description": "Closes the AboutDialog window, typically in response to user confirmation or dismissal actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/about.py", "function": "get_os_word_size_guess", "line_number": 130, "body": "def get_os_word_size_guess(self):\n        if \"32\" in platform.machine() and \"64\" not in platform.machine():\n            return \"(32-bit)\"\n        elif \"64\" in platform.machine() and \"32\" not in platform.machine():\n            return \"(64-bit)\"\n        else:\n            return \"\"", "is_method": true, "class_name": "AboutDialog", "function_description": "Method of the AboutDialog class that guesses and returns the operating system's word size as a string label, aiding in display or diagnostic contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/about.py", "function": "open_about", "line_number": 140, "body": "def open_about(*args):\n        ui_utils.show_dialog(AboutDialog(get_workbench()))", "is_method": false, "function_description": "Displays an informational dialog about the application or system, typically accessed via an \"About\" menu option to provide users with version or author details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/about.py", "function": "open_url", "line_number": 143, "body": "def open_url(url):\n        import webbrowser\n\n        # webbrowser.open returns bool, but add_command expects None\n        webbrowser.open(url)", "is_method": false, "function_description": "Function that opens a given URL in the system's default web browser, providing a simple interface for launching web pages or resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "show_dialog", "line_number": 80, "body": "def show_dialog():\n    dlg = ShellMacroDialog(get_workbench())\n    ui_utils.show_dialog(dlg)", "is_method": false, "function_description": "Displays a dialog window within the application\u2019s user interface, facilitating user interaction through a predefined shell macro dialog component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "execute_macro", "line_number": 85, "body": "def execute_macro():\n    if get_runner().is_waiting_toplevel_command():\n        source = get_workbench().get_option(\"run.shell_macro_main\")\n        if source is not None:\n            shell = get_workbench().show_view(\"ShellView\")\n            shell.submit_python_code(source.strip() + \"\\n\")", "is_method": false, "function_description": "This function executes a predefined shell macro command within a workbench environment when the system is ready to accept top-level commands, facilitating automated shell interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_load_plugin", "line_number": 93, "body": "def _load_plugin():\n    get_workbench().set_default(\"run.shell_macro_main\", None)\n    get_workbench().add_command(\n        \"configure_shell_macro\", \"run\", \"Configure shell macro...\", show_dialog\n    )\n    get_workbench().add_command(\n        \"execute_shell_macro\", \"run\", \"Execute shell macro\", execute_macro, default_sequence=\"<F9>\"\n    )", "is_method": false, "function_description": "Internal setup function that registers shell macro configuration and execution commands within the workbench environment, enabling users to configure and run shell macros interactively."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_create_widgets", "line_number": 26, "body": "def _create_widgets(self):\n\n        bg = \"#ffff99\"\n        banner_frame = tk.Frame(self, background=bg)\n        banner_frame.grid(row=0, column=0, sticky=\"nsew\")\n        banner_frame.rowconfigure(0, weight=1)\n        banner_frame.columnconfigure(0, weight=1)\n        banner_text = tk.Label(\n            banner_frame,\n            text=\"These\\nare\\ninstructions asdfa afs fa sfasdf\",\n            background=bg,\n            justify=\"left\",\n        )\n        banner_text.grid(column=0, row=0, pady=10, padx=10, sticky=\"nsew\")\n\n        main_frame = ttk.Frame(self)\n        main_frame.grid(row=1, column=0, sticky=tk.NSEW, padx=15, pady=15)\n        self.rowconfigure(0, weight=1)\n        self.columnconfigure(0, weight=1)\n\n        self.main_command_text = CodeView(main_frame, height=5)\n        self.main_command_text.grid(column=0, row=1, sticky=\"nsew\")\n        # main_command_text[\"relief\"] = \"groove\"\n\n        main_frame.rowconfigure(1, weight=1)\n        main_frame.columnconfigure(0, weight=1)\n\n        button_frame = ttk.Frame(main_frame)\n        button_frame.grid(row=2, column=0, sticky=\"nsew\")\n\n        run_button = ttk.Button(button_frame, text=\"Save and execute\", command=self._save_exec)\n        run_button.grid(row=0, column=1, sticky=\"nsew\")\n        ok_button = ttk.Button(button_frame, text=\"Save\", command=self._save)\n        ok_button.grid(row=0, column=2, sticky=\"nsew\")\n        cancel_button = ttk.Button(button_frame, text=\"Cancel\", command=self._cancel)\n        cancel_button.grid(row=0, column=3, sticky=\"nsew\")\n        button_frame.columnconfigure(0, weight=1)", "is_method": true, "class_name": "ShellMacroDialog", "function_description": "Initial analysis shows this method builds and lays out the graphical user interface elements of the ShellMacroDialog window. It creates frames, labels, a code view widget, and command buttons with their bindings. Its role is to initialize the dialog\u2019s interactive components, facilitating user input and command control.\n\nThis method serves as a GUI setup utility for the ShellMacroDialog class, arranging instruction text, an editable code area, and control buttons for saving, executing, or canceling actions within the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_on_close", "line_number": 64, "body": "def _on_close(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "ShellMacroDialog", "function_description": "Private method in the ShellMacroDialog class that handles the dialog's close event by destroying the dialog window. It ensures proper cleanup when the dialog is closed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_save_exec", "line_number": 67, "body": "def _save_exec(self, event=None):\n        self._save(event)\n        execute_macro()", "is_method": true, "class_name": "ShellMacroDialog", "function_description": "Private method of ShellMacroDialog that saves the current state and then executes a macro, facilitating combined save-and-run macro operations within the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_save", "line_number": 71, "body": "def _save(self, event=None):\n        source = self.main_command_text.text.get(\"1.0\", \"end\")\n        get_workbench().set_option(\"run.shell_macro_main\", repr(source))\n        self.destroy()", "is_method": true, "class_name": "ShellMacroDialog", "function_description": "Handles saving the current shell macro text to a global configuration and closes the dialog, enabling persistence of user-defined shell macros within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_cancel", "line_number": 76, "body": "def _cancel(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "ShellMacroDialog", "function_description": "Private method of ShellMacroDialog that closes the dialog, typically used to cancel the current operation or dismiss the interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "load_plugin", "line_number": 357, "body": "def load_plugin() -> None:\n    def open_replayer():\n        win = ReplayWindow(get_workbench())\n        ui_utils.show_dialog(win)\n\n    get_workbench().set_default(\"tools.replayer_last_browser_folder\", None)\n    if get_workbench().get_ui_mode() == \"expert\":\n        get_workbench().add_command(\n            \"open_replayer\", \"tools\", tr(\"Open replayer...\"), open_replayer, group=110\n        )", "is_method": false, "function_description": "This function configures and integrates a replay tool command into the workbench UI when in expert mode, enabling users to launch the replay interface conveniently from the tools menu."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "on_double_click", "line_number": 63, "body": "def on_double_click(self, event):\n        # self.save_current_folder()\n        path = self.get_selected_path()\n        if path:\n            kind = self.get_selected_kind()\n            if kind == \"dir\":\n                self.focus_into(path)\n            else:\n                self.log_frame.load_log(path)\n\n        return \"break\"", "is_method": true, "class_name": "ReplayerFileBrowser", "function_description": "Handles double-click actions in a file browser, navigating into directories or loading log files based on the selected item. It enables intuitive user interaction for browsing and opening files in the ReplayerFileBrowser."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "load_log", "line_number": 105, "body": "def load_log(self, filename):\n        self._clear_tree()\n        self.details_frame._clear_tree()\n        self.all_events = []\n        self.last_event_index = -1\n        self.loading = True\n        self.editor_notebook.reset()\n        self.shell.reset()\n\n        import json\n\n        with open(filename, encoding=\"UTF-8\") as f:\n            events = json.load(f)\n            last_event_time = None\n            for event in events:\n                node_id = self.tree.insert(\"\", \"end\")\n                self.tree.set(node_id, \"desc\", event[\"sequence\"])\n                if len(event[\"time\"]) == 19:\n                    # 0 fraction may have been skipped\n                    event[\"time\"] += \".0\"\n                event_time = datetime.strptime(event[\"time\"], \"%Y-%m-%dT%H:%M:%S.%f\")\n                if last_event_time:\n                    delta = event_time - last_event_time\n                    pause = delta.seconds\n                else:\n                    pause = 0\n                self.tree.set(node_id, \"pause\", str(pause if pause else \"\"))\n                self.all_events.append(event)\n\n                last_event_time = event_time\n\n        self.loading = False", "is_method": true, "class_name": "LogFrame", "function_description": "Loads a log file in JSON format, parses event data with timestamps, and populates an internal event tree structure while tracking time gaps between events. This facilitates visualizing and managing sequential log events within the LogFrame interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "replay_event", "line_number": 138, "body": "def replay_event(self, event):\n        \"this should be called with events in correct order\"\n        # print(\"log replay\", event)\n\n        if \"text_widget_id\" in event:\n            if (\n                event.get(\"text_widget_context\", None) == \"shell\"\n                or event.get(\"text_widget_class\") == \"ShellText\"\n            ):\n                self.shell.replay_event(event)\n            else:\n                self.editor_notebook.replay_event(event)", "is_method": true, "class_name": "LogFrame", "function_description": "Method of LogFrame that replays input events in sequence by delegating them to either the shell or editor notebook components based on event context, enabling consistent UI state restoration or interaction simulation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "reset", "line_number": 151, "body": "def reset(self):\n        self.shell.reset()\n        self.editor_notebook.reset()\n        self.last_event_index = -1", "is_method": true, "class_name": "LogFrame", "function_description": "Resets the LogFrame's components and internal state, clearing the shell, editor notebook, and event tracking to their initial conditions. This method prepares the LogFrame for fresh input or a new session."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "on_select", "line_number": 156, "body": "def on_select(self, event):\n        # parameter \"event\" is here tkinter event\n        if self.loading:\n            return\n        iid = self.tree.focus()\n        if iid != \"\":\n            self.select_event(self.tree.index(iid))", "is_method": true, "class_name": "LogFrame", "function_description": "Handles user selection events in the LogFrame's UI tree, triggering a callback with the selected item's index unless a loading process is active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "select_event", "line_number": 164, "body": "def select_event(self, event_index):\n        event = self.all_events[event_index]\n        self.details_frame.load_event(event)\n\n        # here event means logged event\n        if event_index > self.last_event_index:\n            # replay all events between last replayed event up to and including this event\n            while self.last_event_index < event_index:\n                self.replay_event(self.all_events[self.last_event_index + 1])\n                self.last_event_index += 1\n\n        elif event_index < self.last_event_index:\n            # Undo by resetting and replaying again\n            self.reset()\n            self.select_event(event_index)", "is_method": true, "class_name": "LogFrame", "function_description": "Method in LogFrame that selects and loads a specific logged event by index, replaying or undoing events as needed to synchronize the current state with the selected event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "load_event", "line_number": 188, "body": "def load_event(self, event):\n        self._clear_tree()\n        for name in self.order_keys(event):\n            node_id = self.tree.insert(\"\", \"end\")\n            self.tree.set(node_id, \"attribute\", name)\n            self.tree.set(node_id, \"value\", event[name])", "is_method": true, "class_name": "EventDetailsFrame", "function_description": "Utility method of EventDetailsFrame that populates a tree view with event attributes and their values, providing a structured display of event details for user interfaces or inspection purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "order_keys", "line_number": 195, "body": "def order_keys(self, event):\n        return event.keys()", "is_method": true, "class_name": "EventDetailsFrame", "function_description": "Returns the keys of a given event dictionary, allowing other methods to access the event's attribute names for further processing or display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "replay_event", "line_number": 240, "body": "def replay_event(self, event):\n        if event[\"sequence\"] in [\"TextInsert\", \"TextDelete\"]:\n            if event[\"sequence\"] == \"TextInsert\":\n                self.code_view.text.insert(\n                    event[\"index\"], event[\"text\"], ast.literal_eval(event[\"tags\"])\n                )\n\n            elif event[\"sequence\"] == \"TextDelete\":\n                if event[\"index2\"] and event[\"index2\"] != \"None\":\n                    self.code_view.text.delete(event[\"index1\"], event[\"index2\"])\n                else:\n                    self.code_view.text.delete(event[\"index1\"])\n\n            self.see_event(event)", "is_method": true, "class_name": "ReplayerEditor", "function_description": "Replays text insertion or deletion events to update the code view accordingly. It enables the ReplayerEditor to apply and visualize sequential text changes for editing or undo/redo functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "see_event", "line_number": 255, "body": "def see_event(self, event):\n        for key in [\"index\", \"index1\", \"index2\"]:\n            if key in event and event[key] and event[key] != \"None\":\n                self.code_view.text.see(event[key])", "is_method": true, "class_name": "ReplayerEditor", "function_description": "Utility method in ReplayerEditor that updates a code view to display specified event indices, facilitating navigation or highlighting of code positions during event replay."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "reset", "line_number": 260, "body": "def reset(self):\n        self.code_view.text.delete(\"1.0\", \"end\")", "is_method": true, "class_name": "ReplayerEditor", "function_description": "Method of ReplayerEditor that clears all text content from the code editing view, effectively resetting the code input area to an empty state. It is useful for starting fresh or removing existing code from the editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "set_colorer", "line_number": 269, "body": "def set_colorer(self):\n        self.colorer = SyntaxColorer(self.code_view.text)", "is_method": true, "class_name": "ReplayerEditorProper", "function_description": "Method of ReplayerEditorProper that initializes syntax highlighting for the current code view, enabling colorized code display for improved readability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "replay_event", "line_number": 272, "body": "def replay_event(self, event):\n        ReplayerEditor.replay_event(self, event)", "is_method": true, "class_name": "ReplayerEditorProper", "function_description": "Delegates an event replay action to the base ReplayerEditor's replay_event method, enabling event replay functionality within the ReplayerEditorProper context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "reset", "line_number": 277, "body": "def reset(self):\n        ReplayerEditor.reset(self)\n        self.set_colorer()", "is_method": true, "class_name": "ReplayerEditorProper", "function_description": "Resets the ReplayerEditorProper instance to its initial state and reinitializes its syntax coloring functionality to prepare for fresh editing or replay sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "clear", "line_number": 287, "body": "def clear(self):\n\n        for child in self.winfo_children():\n            child.destroy()\n\n        self._editors_by_text_widget_id = {}", "is_method": true, "class_name": "ReplayerEditorNotebook", "function_description": "Clears all child widgets and resets the editor tracking within the ReplayerEditorNotebook, effectively resetting its content and state for reuse or fresh editing sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "get_editor_by_text_widget_id", "line_number": 294, "body": "def get_editor_by_text_widget_id(self, text_widget_id):\n        if text_widget_id not in self._editors_by_text_widget_id:\n            editor = ReplayerEditorProper(self)\n            self.add(editor, text=\"<untitled>\")\n            self._editors_by_text_widget_id[text_widget_id] = editor\n\n        return self._editors_by_text_widget_id[text_widget_id]", "is_method": true, "class_name": "ReplayerEditorNotebook", "function_description": "Utility method in ReplayerEditorNotebook that fetches or creates an editor instance associated with a given text widget ID, ensuring each text widget is linked to a unique editor for editing management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "replay_event", "line_number": 302, "body": "def replay_event(self, event):\n        if \"text_widget_id\" in event:\n            editor = self.get_editor_by_text_widget_id(event[\"text_widget_id\"])\n            # print(event.editor_id, id(editor), event)\n            self.select(editor)\n            editor.replay_event(event)\n\n            if \"filename\" in event:\n                self.tab(editor, text=os.path.basename(event[\"filename\"]))", "is_method": true, "class_name": "ReplayerEditorNotebook", "function_description": "Replays a given event by locating the associated editor and applying the event\u2019s actions, optionally updating the editor\u2019s tab title based on the event\u2019s filename. Useful for reproducing user interactions in a notebook editor interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "reset", "line_number": 312, "body": "def reset(self):\n        for editor in self.winfo_children():\n            self.forget(editor)\n            editor.destroy()\n\n        self._editors_by_text_widget_id = {}", "is_method": true, "class_name": "ReplayerEditorNotebook", "function_description": "Clears all child editor widgets from the notebook and resets the internal mapping of editors, effectively returning the ReplayerEditorNotebook to an empty state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "open_replayer", "line_number": 358, "body": "def open_replayer():\n        win = ReplayWindow(get_workbench())\n        ui_utils.show_dialog(win)", "is_method": false, "function_description": "Opens and displays a replay interface window within the application, facilitating user interaction with replay features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "load_plugin", "line_number": 398, "body": "def load_plugin() -> None:\n    def cmd_open_find_dialog():\n        if _active_find_dialog is not None:\n            _active_find_dialog.focus_set()\n        else:\n            editor = get_workbench().get_editor_notebook().get_current_editor()\n            if editor:\n                FindDialog(editor._code_view)\n\n    def find_f3(event):\n        if _active_find_dialog is None:\n            cmd_open_find_dialog()\n        else:\n            _active_find_dialog._perform_find(event)\n\n    get_workbench().add_command(\n        \"OpenFindDialog\",\n        \"edit\",\n        tr(\"Find & Replace\"),\n        cmd_open_find_dialog,\n        default_sequence=select_sequence(\"<Control-f>\", \"<Command-f>\"),\n        extra_sequences=[\"<Control-Greek_phi>\"],\n    )\n\n    get_workbench().bind(\"<F3>\", find_f3, True)", "is_method": false, "function_description": "Initialization function that registers and binds commands for opening and controlling a find-and-replace dialog within the editor environment, enabling users to trigger search functionality via keyboard shortcuts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "focus_set", "line_number": 163, "body": "def focus_set(self):\n        self.find_entry.focus_set()\n        self.find_entry.selection_range(0, tk.END)", "is_method": true, "class_name": "FindDialog", "function_description": "Sets keyboard focus on the search input and selects its entire content for immediate editing within the FindDialog user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_update_button_statuses", "line_number": 168, "body": "def _update_button_statuses(self, *args):\n        find_text = self.find_entry_var.get()\n        if len(find_text) == 0:\n            self.find_button.config(state=\"disabled\")\n            self.replace_and_find_button.config(state=\"disabled\")\n            self.replace_all_button.config(state=\"disabled\")\n        else:\n            self.find_button.config(state=\"normal\")\n            self.replace_all_button.config(state=\"normal\")\n            if self.active_found_tag is not None:\n                self.replace_and_find_button.config(state=\"normal\")", "is_method": true, "class_name": "FindDialog", "function_description": "Updates the enabled or disabled state of find and replace buttons based on the current search text and active selection, controlling user interaction in the FindDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_is_search_case_sensitive", "line_number": 181, "body": "def _is_search_case_sensitive(self):\n        return self.case_var.get() != 0", "is_method": true, "class_name": "FindDialog", "function_description": "Utility method in FindDialog that determines if the current search should be case sensitive based on the case_var state. It supports toggling case sensitivity in search operations within the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_repeats_last_search", "line_number": 185, "body": "def _repeats_last_search(self, tofind):\n        return (\n            tofind == FindDialog.last_searched_word\n            and self.last_processed_indexes is not None\n            and self.last_search_case == self._is_search_case_sensitive()\n        )", "is_method": true, "class_name": "FindDialog", "function_description": "Utility method of the FindDialog class that checks if a new search term matches the previous search in both content and case sensitivity, indicating a repeated search to optimize subsequent search operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_perform_replace", "line_number": 193, "body": "def _perform_replace(self):\n\n        # nothing is currently in found status\n        if self.active_found_tag == None:\n            return\n\n        # get the found word bounds\n        del_start = self.active_found_tag[0]\n        del_end = self.active_found_tag[1]\n\n        # erase all tags - these would not be correct anyway after new word is inserted\n        self._remove_all_tags()\n        toreplace = self.replace_entry.get()  # get the text to replace\n\n        # delete the found word\n        self.codeview.text.delete(del_start, del_end)\n        # insert the new word\n        self.codeview.text.insert(del_start, toreplace)\n        # mark the inserted word boundaries\n        self.last_processed_indexes = (\n            del_start,\n            self.codeview.text.index(\"%s+%dc\" % (del_start, len(toreplace))),\n        )\n\n        get_workbench().event_generate(\n            \"Replace\",\n            widget=self.codeview.text,\n            old_text=self.codeview.text.get(del_start, del_end),\n            new_text=toreplace,\n        )", "is_method": true, "class_name": "FindDialog", "function_description": "Method of the FindDialog class that replaces the currently found text with new input, updating the text content and internal tracking to reflect the change. It enables text replacement within a dialog-based search interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_perform_replace_and_find", "line_number": 225, "body": "def _perform_replace_and_find(self):\n        if self.active_found_tag == None:\n            return\n        self._perform_replace()\n        self._perform_find()", "is_method": true, "class_name": "FindDialog", "function_description": "Private method of FindDialog that, if an active found tag exists, performs a replace operation followed by a find operation to update search results accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_perform_replace_all", "line_number": 232, "body": "def _perform_replace_all(self):\n\n        tofind = self.find_entry.get()\n        if len(tofind) == 0:\n            self.infotext_label_var.set(tr(\"Enter string to be replaced.\"))\n            return\n\n        toreplace = self.replace_entry.get()\n\n        self._remove_all_tags()\n\n        currentpos = 1.0\n        end = self.codeview.text.index(\"end\")\n\n        while True:\n            currentpos = self.codeview.text.search(\n                tofind, currentpos, end, nocase=not self._is_search_case_sensitive()\n            )\n            if currentpos == \"\":\n                break\n\n            endpos = self.codeview.text.index(\"%s+%dc\" % (currentpos, len(tofind)))\n\n            self.codeview.text.delete(currentpos, endpos)\n\n            if toreplace != \"\":\n                self.codeview.text.insert(currentpos, toreplace)\n\n            currentpos = self.codeview.text.index(\"%s+%dc\" % (currentpos, len(toreplace)))\n\n        get_workbench().event_generate(\n            \"ReplaceAll\", widget=self.codeview.text, old_text=tofind, new_text=toreplace\n        )", "is_method": true, "class_name": "FindDialog", "function_description": "Private method in FindDialog that replaces all occurrences of a specified string with a replacement string in the text editor, supporting optional case sensitivity and updating the UI accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_perform_find", "line_number": 266, "body": "def _perform_find(self, event=None):\n        self.infotext_label_var.set(\"\")  # reset the info label text\n        tofind = self.find_entry.get()  # get the text to find\n        if len(tofind) == 0:  # in the case of empty string, cancel\n            return  # TODO - set warning text to info label?\n\n        search_backwards = (\n            self.direction_var.get() == 1\n        )  # True - search backwards ('up'), False - forwards ('down')\n\n        if self._repeats_last_search(\n            tofind\n        ):  # continuing previous search, find the next occurrence\n            if search_backwards:\n                search_start_index = self.last_processed_indexes[0]\n            else:\n                search_start_index = self.last_processed_indexes[1]\n\n            if self.active_found_tag is not None:\n                self.codeview.text.tag_remove(\n                    \"current_found\", self.active_found_tag[0], self.active_found_tag[1]\n                )  # remove the active tag from the previously found string\n                self.passive_found_tags.add(\n                    (self.active_found_tag[0], self.active_found_tag[1])\n                )  # ..and set it to passive instead\n                self.codeview.text.tag_add(\n                    \"found\", self.active_found_tag[0], self.active_found_tag[1]\n                )\n\n        else:  # start a new search, start from the current insert line position\n            if self.active_found_tag is not None:\n                self.codeview.text.tag_remove(\n                    \"current_found\", self.active_found_tag[0], self.active_found_tag[1]\n                )  # remove the previous active tag if it was present\n            for tag in self.passive_found_tags:\n                self.codeview.text.tag_remove(\n                    \"found\", tag[0], tag[1]\n                )  # and remove all the previous passive tags that were present\n            search_start_index = self.codeview.text.index(\n                \"insert\"\n            )  # start searching from the current insert position\n            self._find_and_tag_all(tofind)  # set the passive tag to ALL found occurrences\n            FindDialog.last_searched_word = tofind  # set the data about last search\n            self.last_search_case = self._is_search_case_sensitive()\n\n        wordstart = self.codeview.text.search(\n            tofind,\n            search_start_index,\n            backwards=search_backwards,\n            forwards=not search_backwards,\n            nocase=not self._is_search_case_sensitive(),\n        )  # performs the search and sets the start index of the found string\n        if len(wordstart) == 0:\n            self.infotext_label_var.set(\n                tr(\"The specified text was not found!\")\n            )  # TODO - better text, also move it to the texts resources list\n            self.replace_and_find_button.config(state=\"disabled\")\n            self.replace_button.config(state=\"disabled\")\n            return\n\n        self.last_processed_indexes = (\n            wordstart,\n            self.codeview.text.index(\"%s+1c\" % wordstart),\n        )  # sets the data about last search\n        self.codeview.text.see(wordstart)  # moves the view to the found index\n        wordend = self.codeview.text.index(\n            \"%s+%dc\" % (wordstart, len(tofind))\n        )  # calculates the end index of the found string\n        self.codeview.text.tag_add(\n            \"current_found\", wordstart, wordend\n        )  # tags the found word as active\n        self.active_found_tag = (wordstart, wordend)\n        self.replace_and_find_button.config(state=\"normal\")\n        self.replace_button.config(state=\"normal\")\n\n        get_workbench().event_generate(\n            \"Find\",\n            widget=self.codeview.text,\n            text=tofind,\n            backwards=search_backwards,\n            case_sensitive=self._is_search_case_sensitive(),\n        )", "is_method": true, "class_name": "FindDialog", "function_description": "Function _perform_find in FindDialog manages the search for a specified text within a text widget, handling both new and repeated searches. It highlights occurrences, updates UI controls, and adjusts the view to the found text, supporting forward and backward case-sensitive searches."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_ok", "line_number": 349, "body": "def _ok(self, event=None):\n        \"\"\"Called when the window is closed. responsible for handling all cleanup.\"\"\"\n        self._remove_all_tags()\n        self.destroy()\n\n        global _active_find_dialog\n        _active_find_dialog = None", "is_method": true, "class_name": "FindDialog", "function_description": "Handles cleanup and closes the FindDialog window, ensuring all tags are removed and resetting the global active dialog state. It provides proper resource management when the dialog is closed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_remove_all_tags", "line_number": 358, "body": "def _remove_all_tags(self):\n        for tag in self.passive_found_tags:\n            self.codeview.text.tag_remove(\"found\", tag[0], tag[1])  # removes the passive tags\n\n        if self.active_found_tag is not None:\n            self.codeview.text.tag_remove(\n                \"current_found\", self.active_found_tag[0], self.active_found_tag[1]\n            )  # removes the currently active tag\n\n        self.active_found_tag = None\n        self.replace_and_find_button.config(state=\"disabled\")\n        self.replace_button.config(state=\"disabled\")", "is_method": true, "class_name": "FindDialog", "function_description": "Clears all highlighted search tags from the dialog's text view and disables related replace buttons. It resets the state of tag tracking within the FindDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_find_and_tag_all", "line_number": 372, "body": "def _find_and_tag_all(self, tofind, force=False):\n        # TODO - to be improved so only whole words are matched - surrounded by whitespace, parentheses, brackets, colons, semicolons, points, plus, minus\n\n        if (\n            self._repeats_last_search(tofind) and not force\n        ):  # nothing to do, all passive tags already set\n            return\n\n        currentpos = 1.0\n        end = self.codeview.text.index(\"end\")\n\n        # searches and tags until the end of codeview\n        while True:\n            currentpos = self.codeview.text.search(\n                tofind, currentpos, end, nocase=not self._is_search_case_sensitive()\n            )\n            if currentpos == \"\":\n                break\n\n            endpos = self.codeview.text.index(\"%s+%dc\" % (currentpos, len(tofind)))\n            self.passive_found_tags.add((currentpos, endpos))\n            self.codeview.text.tag_add(\"found\", currentpos, endpos)\n\n            currentpos = self.codeview.text.index(\"%s+1c\" % currentpos)", "is_method": true, "class_name": "FindDialog", "function_description": "Method of the FindDialog class that searches for all occurrences of a substring in a text widget and tags them for highlighting, supporting case sensitivity and avoiding redundant searches."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "cmd_open_find_dialog", "line_number": 399, "body": "def cmd_open_find_dialog():\n        if _active_find_dialog is not None:\n            _active_find_dialog.focus_set()\n        else:\n            editor = get_workbench().get_editor_notebook().get_current_editor()\n            if editor:\n                FindDialog(editor._code_view)", "is_method": false, "function_description": "Triggers or focuses a find dialog for the current editor's code view, facilitating text search within the active editing context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "find_f3", "line_number": 407, "body": "def find_f3(event):\n        if _active_find_dialog is None:\n            cmd_open_find_dialog()\n        else:\n            _active_find_dialog._perform_find(event)", "is_method": false, "function_description": "Triggers or performs a find operation in the active find dialog, opening the dialog if it is not already active. This function facilitates user-initiated search actions within an interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "create_bitmap_file", "line_number": 15, "body": "def create_bitmap_file(width, height, predicate, name):\n\n    cache_dir = os.path.join(thonny.THONNY_USER_DIR, \"image_cache\")\n    name = \"%s_%d_%d.xbm\" % (name, width, height)\n    filename = os.path.join(cache_dir, name)\n\n    # if os.path.exists(filename):\n    #    return filename\n\n    hex_lines = []\n\n    if width % 8 == 0:\n        row_size = width\n    else:\n        # need to pad row size so that it is multiple of 8\n        row_size = width + 8 - (width % 8)\n\n    for y in range(height):\n        byte_hexes = []\n        for byte_index in range(row_size // 8):\n            byte = 0\n            for bit_index in range(7, -1, -1):\n                x = byte_index * 8 + bit_index\n\n                byte <<= 1\n                if predicate(x, y):\n                    byte |= 1\n\n            byte_hexes.append(format(byte, \"#04x\"))\n        hex_lines.append(\",\".join(byte_hexes))\n\n    data = (\n        \"#define im_width %d\\n\" % width\n        + \"#define im_height %d\\n\" % height\n        + \"static char im_bits[] = {\\n\"\n        + \"%s\\n\" % \",\\n\".join(hex_lines)\n        + \"};\"\n    )\n\n    os.makedirs(cache_dir, exist_ok=True)\n    with open(filename, \"w\") as fp:\n        fp.write(data)\n    return filename", "is_method": false, "function_description": "Function that generates a monochrome bitmap file based on a predicate for pixel values, saving the image in XBM format with specified dimensions and name. It creates pixel data by evaluating the predicate per coordinate and writes the bitmap to a cache directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "configure_text", "line_number": 60, "body": "def configure_text(text):\n    spacing1 = 2\n    spacing3 = 3\n    text_font = text[\"font\"]\n    text.configure(spacing1=spacing1, spacing3=spacing3)\n    text.master._gutter.configure(spacing1=spacing1, spacing3=spacing3)\n    if isinstance(text_font, str):\n        text_font = font.nametofont(text_font)\n\n    indent_width = text_font.measure(\"    \")\n    bbox = text.bbox(\"1.0\")\n    if bbox is None or bbox[3] < 5:\n        # text not ready yet\n        # TODO: Text in Tk 8.6 has sync method\n        return False\n\n    line_height = bbox[3] + spacing1 + spacing3\n\n    print(indent_width, line_height)\n\n    def ver(x: int, y: int, top: bool, bottom: bool) -> bool:\n        # tells where to show pixels in vertical border of the statement\n        # It would be convenient if tiling started from the start of\n        # 1st char, but it is offset a bit\n        # In order to make computation easier, I'm offsetting x as well\n        x = (x - 5) % indent_width\n\n        stripe_width = 8\n        gap = 3\n        left = indent_width - stripe_width - gap\n\n        return (\n            left <= x < left + stripe_width\n            or top\n            and y == 0\n            and x >= left\n            or bottom\n            and y == line_height - 1\n            and x >= left\n        )\n\n    def hor(x: int, y: int, top: bool, bottom: bool) -> bool:\n        # tells where to show pixels in statement line\n        return top and y == 0 or bottom and y == line_height - 1\n\n    color = get_syntax_options_for_tag(\"GUTTER\").get(\"background\", \"gray\")\n    for orient, base_predicate in [(\"hor\", hor), (\"ver\", ver)]:\n        for top in [False, True]:\n            for bottom in [False, True]:\n\n                def predicate(\n                    x,\n                    y,\n                    # need to make base_predicate, top and bottom local\n                    base_predicate=base_predicate,\n                    top=top,\n                    bottom=bottom,\n                ):\n                    return base_predicate(x, y, top, bottom)\n\n                tag_name = \"%s_%s_%s\" % (orient, top, bottom)\n                bitmap_path = create_bitmap_file(indent_width, line_height, predicate, tag_name)\n                text.tag_configure(tag_name, background=color, bgstipple=\"@\" + bitmap_path)\n\n    return True", "is_method": false, "function_description": "Configures visual spacing, line height, and gutter styling for a text widget, enhancing its readability and appearance with custom background patterns along vertical and horizontal borders."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "print_tree", "line_number": 127, "body": "def print_tree(node, level=0):\n    from parso.python import tree as python_tree\n\n    indent = \"  \" * level\n    # if (isinstance(node, python_tree.PythonNode) and node.type == \"sim\"\n    if node.type in (\"simple_stmt\",) or isinstance(node, python_tree.Flow):\n        print(indent, node.type, node.start_pos, node.end_pos)\n\n    if hasattr(node, \"children\"):\n        for child in node.children:\n            print_tree(child, level + 1)", "is_method": false, "function_description": "Function that recursively prints the structure of a syntax tree, showing node types and positions with indentation representing tree depth. Useful for visualizing and debugging Python code parse trees."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "clear_tags", "line_number": 140, "body": "def clear_tags(text):\n    for pos in [\"ver\", \"hor\"]:\n        for top in [True, False]:\n            for bottom in [True, False]:\n                text.tag_remove(\"%s_%s_%s\" % (pos, top, bottom), \"1.0\", \"end\")", "is_method": false, "function_description": "Utility function that removes specific formatted tags from the entire text, likely used for resetting or cleaning tagged text regions in a user interface or text processing context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "add_tags", "line_number": 147, "body": "def add_tags(text):\n    source = text.get(\"1.0\", \"end\")\n    clear_tags(text)\n    tree = jedi_utils.parse_source(source)\n\n    print_tree(tree)\n    last_line = 0\n    last_col = 0\n\n    def tag_tree(node):\n        nonlocal last_line, last_col\n        from parso.python import tree as python_tree\n\n        if node.type == \"simple_stmt\" or isinstance(node, (python_tree.Flow, python_tree.Scope)):\n\n            start_line, start_col = node.start_pos\n            end_line, end_col = node.end_pos\n\n            # Before dealing with this node,\n            # handle the case, where last vertical tag was meant for\n            # same column, but there were empty or comment lines between\n            if start_col == last_col:\n                for i in range(last_line + 1, start_line):\n                    # NB! tag not visible when logically empty line\n                    # doesn't have indent prefix\n                    text.tag_add(\n                        \"ver_False_False\", \"%d.%d\" % (i, last_col - 1), \"%d.%d\" % (i, last_col)\n                    )\n                    print(\"ver_False_False\", \"%d.%d\" % (i, last_col - 1), \"%d.%d\" % (i, last_col))\n\n            print(node)\n\n            # usually end_col is 0\n            # exceptions: several statements on the same line (semicoloned statements)\n            # also unclosed parens in if-header\n            for lineno in range(start_line, end_line if end_col == 0 else end_line + 1):\n\n                top = lineno == start_line and lineno > 1\n                bottom = False  # start_line == end_line-1\n\n                # horizontal line (only for first or last line)\n                if top or bottom:\n                    text.tag_add(\n                        \"hor_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col),\n                        \"%d.%d\" % (lineno + 1 if end_col == 0 else lineno, 0),\n                    )\n\n                    print(\n                        \"hor_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col),\n                        \"%d.%d\" % (lineno + 1, 0),\n                    )\n\n                # vertical line (only for indented statements)\n                # Note that I'm using start col for all lines\n                # (statement's indent shouldn't decrease in continuation lines)\n                if start_col > 0:\n                    text.tag_add(\n                        \"ver_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col - 1),\n                        \"%d.%d\" % (lineno, start_col),\n                    )\n                    print(\n                        \"ver_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col - 1),\n                        \"%d.%d\" % (lineno, start_col),\n                    )\n\n                    last_line = lineno\n                    last_col = start_col\n\n        # Recurse\n        if node.type != \"simple_stmt\" and hasattr(node, \"children\"):\n            for child in node.children:\n                tag_tree(child)\n\n    tag_tree(tree)", "is_method": false, "function_description": "Adds visual tags representing code structure and indentation to a text widget by parsing its Python source content, enabling enhanced syntax-aware highlighting or annotation based on statement blocks and indentation levels. Useful for code editors or IDE components displaying Python code structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "handle_editor_event", "line_number": 227, "body": "def handle_editor_event(event):\n    configure_and_add_tags(event.editor.get_text_widget())", "is_method": false, "function_description": "Handles an editor event by configuring and adding tags to the editor's text widget, enabling customized text styling or behavior in response to the event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "handle_events", "line_number": 231, "body": "def handle_events(event):\n    if hasattr(event, \"text_widget\"):\n        text = event.text_widget\n    else:\n        text = event.widget\n\n    configure_and_add_tags(text)", "is_method": false, "function_description": "This function processes an event to identify its associated text widget and applies specific text formatting or tagging. It provides a utility to consistently configure and decorate text elements triggered by events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "configure_and_add_tags", "line_number": 240, "body": "def configure_and_add_tags(text):\n    if not getattr(text, \"structure_tags_configured\", False):\n        try:\n            if configure_text(text):\n                text.structure_tags_configured = True\n            else:\n                text.after(500, lambda: configure_and_add_tags(text))\n                return\n        except Exception:\n            logging.exception(\"Problem with defining structure tags\")\n            return\n\n    add_tags(text)", "is_method": false, "function_description": "Function that ensures a text object is configured with structural tags before adding additional tags, retrying configuration asynchronously if needed. It facilitates reliable tagging of text elements with error handling and repeated attempts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "_load_plugin", "line_number": 255, "body": "def _load_plugin() -> None:\n    wb = get_workbench()\n\n    wb.set_default(\"view.program_structure\", False)\n    wb.bind(\"Save\", handle_editor_event, True)\n    wb.bind(\"Open\", handle_editor_event, True)\n    wb.bind_class(\"CodeViewText\", \"<<TextChange>>\", handle_events, True)", "is_method": false, "function_description": "Initial analysis shows the function sets up event bindings and configuration in a \"workbench\" context, likely for an editor or IDE environment. Its main role is to configure plugin behavior by disabling a view and attaching event handlers for save, open, and text change actions.\n\nThis function provides plugin initialization by configuring workspace defaults and event bindings to integrate custom behavior on file and editor events.\n\nOutput:\nInitializes plugin configuration by setting workspace defaults and binding event handlers for editor save, open, and text change actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "ver", "line_number": 80, "body": "def ver(x: int, y: int, top: bool, bottom: bool) -> bool:\n        # tells where to show pixels in vertical border of the statement\n        # It would be convenient if tiling started from the start of\n        # 1st char, but it is offset a bit\n        # In order to make computation easier, I'm offsetting x as well\n        x = (x - 5) % indent_width\n\n        stripe_width = 8\n        gap = 3\n        left = indent_width - stripe_width - gap\n\n        return (\n            left <= x < left + stripe_width\n            or top\n            and y == 0\n            and x >= left\n            or bottom\n            and y == line_height - 1\n            and x >= left\n        )", "is_method": false, "function_description": "Determines whether a pixel at given coordinates should be shown in the vertical border area of a statement, supporting visual rendering of border stripes and edges based on position and line context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "hor", "line_number": 101, "body": "def hor(x: int, y: int, top: bool, bottom: bool) -> bool:\n        # tells where to show pixels in statement line\n        return top and y == 0 or bottom and y == line_height - 1", "is_method": false, "function_description": "Determines if a pixel should be displayed on the top or bottom border of a horizontal line based on its vertical position and boundary flags, aiding in rendering line edges visually."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "tag_tree", "line_number": 156, "body": "def tag_tree(node):\n        nonlocal last_line, last_col\n        from parso.python import tree as python_tree\n\n        if node.type == \"simple_stmt\" or isinstance(node, (python_tree.Flow, python_tree.Scope)):\n\n            start_line, start_col = node.start_pos\n            end_line, end_col = node.end_pos\n\n            # Before dealing with this node,\n            # handle the case, where last vertical tag was meant for\n            # same column, but there were empty or comment lines between\n            if start_col == last_col:\n                for i in range(last_line + 1, start_line):\n                    # NB! tag not visible when logically empty line\n                    # doesn't have indent prefix\n                    text.tag_add(\n                        \"ver_False_False\", \"%d.%d\" % (i, last_col - 1), \"%d.%d\" % (i, last_col)\n                    )\n                    print(\"ver_False_False\", \"%d.%d\" % (i, last_col - 1), \"%d.%d\" % (i, last_col))\n\n            print(node)\n\n            # usually end_col is 0\n            # exceptions: several statements on the same line (semicoloned statements)\n            # also unclosed parens in if-header\n            for lineno in range(start_line, end_line if end_col == 0 else end_line + 1):\n\n                top = lineno == start_line and lineno > 1\n                bottom = False  # start_line == end_line-1\n\n                # horizontal line (only for first or last line)\n                if top or bottom:\n                    text.tag_add(\n                        \"hor_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col),\n                        \"%d.%d\" % (lineno + 1 if end_col == 0 else lineno, 0),\n                    )\n\n                    print(\n                        \"hor_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col),\n                        \"%d.%d\" % (lineno + 1, 0),\n                    )\n\n                # vertical line (only for indented statements)\n                # Note that I'm using start col for all lines\n                # (statement's indent shouldn't decrease in continuation lines)\n                if start_col > 0:\n                    text.tag_add(\n                        \"ver_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col - 1),\n                        \"%d.%d\" % (lineno, start_col),\n                    )\n                    print(\n                        \"ver_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col - 1),\n                        \"%d.%d\" % (lineno, start_col),\n                    )\n\n                    last_line = lineno\n                    last_col = start_col\n\n        # Recurse\n        if node.type != \"simple_stmt\" and hasattr(node, \"children\"):\n            for child in node.children:\n                tag_tree(child)", "is_method": false, "function_description": "Recursive utility that traverses a Python code parse tree to add visual text tags reflecting code block structure and indentation levels, useful for syntax highlighting or code editor visualization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "predicate", "line_number": 110, "body": "def predicate(\n                    x,\n                    y,\n                    # need to make base_predicate, top and bottom local\n                    base_predicate=base_predicate,\n                    top=top,\n                    bottom=bottom,\n                ):\n                    return base_predicate(x, y, top, bottom)", "is_method": false, "function_description": "This function applies a predefined base predicate to two inputs with additional boundary parameters, enabling customized conditional checks or comparisons based on the base predicate's logic."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "update_coloring_on_event", "line_number": 307, "body": "def update_coloring_on_event(event):\n    if hasattr(event, \"text_widget\"):\n        text = event.text_widget\n    else:\n        text = event.widget\n\n    try:\n        update_coloring_on_text(text, event)\n    except Exception as e:\n        logger.error(\"Problem with coloring\", exc_info=e)", "is_method": false, "function_description": "Function that updates syntax or style coloring on a text widget in response to an event, handling errors gracefully to ensure UI responsiveness. It serves as an event-driven trigger for text formatting updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "update_coloring_on_text", "line_number": 319, "body": "def update_coloring_on_text(text, event=None):\n    if not hasattr(text, \"syntax_colorer\"):\n        if isinstance(text, ShellText):\n            class_ = ShellSyntaxColorer\n        elif isinstance(text, CodeViewText):\n            class_ = CodeViewSyntaxColorer\n        else:\n            return\n\n        text.syntax_colorer = class_(text)\n        # mark whole text as unprocessed\n        text.syntax_colorer.mark_dirty()\n    else:\n        text.syntax_colorer.mark_dirty(event)\n\n    text.syntax_colorer.schedule_update()", "is_method": false, "function_description": "Updates or initializes the syntax coloring state for a given text object and schedules a color refresh. This function supports dynamic syntax highlighting in text-based UI components like shells or code views."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "load_plugin", "line_number": 337, "body": "def load_plugin() -> None:\n    wb = get_workbench()\n\n    wb.set_default(\"view.syntax_coloring\", True)\n    wb.set_default(\"view.highlight_tabs\", True)\n    wb.bind(\"TextInsert\", update_coloring_on_event, True)\n    wb.bind(\"TextDelete\", update_coloring_on_event, True)\n    wb.bind_class(\"CodeViewText\", \"<<VerticalScroll>>\", update_coloring_on_event, True)\n    wb.bind(\"<<UpdateAppearance>>\", update_coloring_on_event, True)", "is_method": false, "function_description": "Sets up default syntax coloring and tab highlighting in the workbench, binding events to update text coloring dynamically during user interactions like typing and scrolling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_compile_regexes", "line_number": 40, "body": "def _compile_regexes(self):\n        from thonny.token_utils import (\n            BUILTIN,\n            COMMENT,\n            COMMENT_WITH_Q3DELIMITER,\n            KEYWORD,\n            MAGIC_COMMAND,\n            NUMBER,\n            STRING3,\n            STRING3_DELIMITER,\n            STRING_CLOSED,\n            STRING_OPEN,\n            TAB,\n        )\n\n        self.uniline_regex = re.compile(\n            KEYWORD\n            + \"|\"\n            + BUILTIN\n            + \"|\"\n            + NUMBER\n            + \"|\"\n            + COMMENT\n            + \"|\"\n            + MAGIC_COMMAND\n            + \"|\"\n            + STRING3_DELIMITER  # to avoid marking \"\"\" and ''' as single line string in uniline mode\n            + \"|\"\n            + STRING_CLOSED\n            + \"|\"\n            + STRING_OPEN\n            + \"|\"\n            + TAB,\n            re.S,  # @UndefinedVariable\n        )\n\n        # need to notice triple-quotes inside comments and magic commands\n        self.multiline_regex = re.compile(\n            \"(\" + STRING3 + \")|\" + COMMENT_WITH_Q3DELIMITER + \"|\" + MAGIC_COMMAND,\n            re.S,  # @UndefinedVariable\n        )\n\n        self.id_regex = re.compile(r\"\\s+(\\w+)\", re.S)", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Private method in SyntaxColorer that compiles regex patterns for recognizing syntax elements like keywords, strings, comments, and numbers, supporting subsequent syntax highlighting processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_config_tags", "line_number": 84, "body": "def _config_tags(self):\n        self.uniline_tags = {\n            \"comment\",\n            \"magic\",\n            \"string\",\n            \"open_string\",\n            \"keyword\",\n            \"number\",\n            \"builtin\",\n            \"definition\",\n        }\n        self.multiline_tags = {\"string3\", \"open_string3\"}\n        self._raise_tags()", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Private method of SyntaxColorer that initializes sets of syntax tags used for single-line and multi-line code highlighting. It prepares internal state for categorizing code elements during syntax coloring."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_raise_tags", "line_number": 98, "body": "def _raise_tags(self):\n        self.text.tag_raise(\"string3\")\n        self.text.tag_raise(\"open_string3\")\n        # yes, unclosed_expression is another plugin's issue,\n        # but it must be higher than *string3\n        self.text.tag_raise(\"tab\")\n        self.text.tag_raise(\"unclosed_expression\")\n        self.text.tag_raise(\"sel\")\n        \"\"\"\n        tags = self.text.tag_names()\n        # take into account that without themes some tags may be undefined\n        if \"string3\" in tags:\n            self.text.tag_raise(\"string3\")\n        if \"open_string3\" in tags:\n            self.text.tag_raise(\"open_string3\")\n        \"\"\"", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Raises the visual priority of specific text tags to control syntax highlighting layers, ensuring correct display order for string, tab, unclosed expression, and selection elements in the SyntaxColorer component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "mark_dirty", "line_number": 115, "body": "def mark_dirty(self, event=None):\n        start_index = \"1.0\"\n        end_index = \"end\"\n\n        if hasattr(event, \"sequence\"):\n            if event.sequence == \"TextInsert\":\n                index = self.text.index(event.index)\n                start_row = int(index.split(\".\")[0])\n                end_row = start_row + event.text.count(\"\\n\")\n                start_index = \"%d.%d\" % (start_row, 0)\n                end_index = \"%d.%d\" % (end_row + 1, 0)\n                if not event.trivial_for_coloring:\n                    self._multiline_dirty = True\n\n            elif event.sequence == \"TextDelete\":\n                index = self.text.index(event.index1)\n                start_row = int(index.split(\".\")[0])\n                start_index = \"%d.%d\" % (start_row, 0)\n                end_index = \"%d.%d\" % (start_row + 1, 0)\n                if not event.trivial_for_coloring:\n                    self._multiline_dirty = True\n\n        self.text.tag_add(TODO, start_index, end_index)", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Marks regions of text as \"dirty\" to indicate they need syntax recoloring, based on text insertion or deletion events. This supports efficient, incremental syntax highlighting updates in the SyntaxColorer class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "schedule_update", "line_number": 139, "body": "def schedule_update(self):\n        self._highlight_tabs = get_workbench().get_option(\"view.highlight_tabs\")\n        self._use_coloring = (\n            get_workbench().get_option(\"view.syntax_coloring\") and self.text.is_python_text()\n        )\n\n        if not self._update_scheduled:\n            self._update_scheduled = True\n            self.text.after_idle(self.perform_update)", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Schedules a syntax coloring update based on user settings and file type, ensuring the update runs efficiently after idle time. It manages state to avoid redundant scheduling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "perform_update", "line_number": 149, "body": "def perform_update(self):\n        try:\n            self._update_coloring()\n        finally:\n            self._update_scheduled = False", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Method in SyntaxColorer that executes a syntax coloring update and ensures the update scheduling flag is reset afterward, maintaining the correct update state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_update_uniline_tokens", "line_number": 158, "body": "def _update_uniline_tokens(self, start, end):\n        chars = self.text.get(start, end)\n\n        # clear old tags\n        for tag in self.uniline_tags | {\"tab\"}:\n            self.text.tag_remove(tag, start, end)\n\n        if self._use_coloring:\n            for match in self.uniline_regex.finditer(chars):\n                for token_type, token_text in match.groupdict().items():\n                    if token_text and token_type in self.uniline_tags:\n                        token_text = token_text.strip()\n                        match_start, match_end = match.span(token_type)\n\n                        self.text.tag_add(\n                            token_type, start + \"+%dc\" % match_start, start + \"+%dc\" % match_end\n                        )\n\n                        # Mark also the word following def or class\n                        if token_text in (\"def\", \"class\"):\n                            id_match = self.id_regex.match(chars, match_end)\n                            if id_match:\n                                id_match_start, id_match_end = id_match.span(1)\n                                self.text.tag_add(\n                                    \"definition\",\n                                    start + \"+%dc\" % id_match_start,\n                                    start + \"+%dc\" % id_match_end,\n                                )\n\n        if self._highlight_tabs:\n            self._update_tabs(start, end)\n\n        self.text.tag_remove(TODO, start, end)", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Highlights and updates syntax tokens by applying appropriate text tags within a specified line range, enabling syntax coloring and optional tab and definition highlighting in the SyntaxColorer text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_update_multiline_tokens", "line_number": 192, "body": "def _update_multiline_tokens(self, start, end):\n        chars = self.text.get(start, end)\n        # clear old tags\n        for tag in self.multiline_tags:\n            self.text.tag_remove(tag, start, end)\n\n        if not self._use_coloring:\n            return\n\n        for match in self.multiline_regex.finditer(chars):\n            token_text = match.group(1)\n            if token_text is None:\n                # not string3\n                continue\n\n            match_start, match_end = match.span()\n            if (\n                token_text.startswith('\"\"\"')\n                and not token_text.endswith('\"\"\"')\n                or token_text.startswith(\"'''\")\n                and not token_text.endswith(\"'''\")\n                or len(token_text) == 3\n            ):\n                token_type = \"open_string3\"\n            elif len(token_text) >= 4 and token_text[-4] == \"\\\\\":\n                token_type = \"open_string3\"\n            else:\n                token_type = \"string3\"\n\n            token_start = start + \"+%dc\" % match_start\n            token_end = start + \"+%dc\" % match_end\n            self.text.tag_add(token_type, token_start, token_end)\n\n        self._multiline_dirty = False\n        self._raise_tags()", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Utility method of the SyntaxColorer class that updates syntax highlighting for multiline string tokens within a given text range, managing tag states to accurately reflect open or closed triple-quoted strings during code coloring."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_update_tabs", "line_number": 228, "body": "def _update_tabs(self, start, end):\n        while True:\n            pos = self.text.search(\"\\t\", start, end)\n            if pos:\n                self.text.tag_add(\"tab\", pos)\n                start = self.text.index(\"%s +1 c\" % pos)\n            else:\n                break", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Private method of SyntaxColorer that identifies tab characters within a text range and applies a \"tab\" tag to each, supporting text formatting or syntax highlighting involving tab stops."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_update_coloring", "line_number": 239, "body": "def _update_coloring(self):\n        viewport_start = self.text.index(\"@0,0\")\n        viewport_end = self.text.index(\n            \"@%d,%d lineend\" % (self.text.winfo_width(), self.text.winfo_height())\n        )\n\n        search_start = viewport_start\n        search_end = viewport_end\n\n        while True:\n            res = self.text.tag_nextrange(TODO, search_start, search_end)\n            if res:\n                update_start = res[0]\n                update_end = res[1]\n            else:\n                # maybe the range started earlier\n                res = self.text.tag_prevrange(TODO, search_start)\n                if res and self.text.compare(res[1], \">\", search_end):\n                    update_start = search_start\n                    update_end = res[1]\n                else:\n                    break\n\n            if self.text.compare(update_end, \">\", search_end):\n                update_end = search_end\n\n            self._update_uniline_tokens(update_start, update_end)\n\n            if update_end == search_end:\n                break\n            else:\n                search_start = update_end\n\n        # Multiline tokens need to be searched from the whole source\n        if self._multiline_dirty:\n            self._update_multiline_tokens(\"1.0\", \"end\")\n\n        # Get rid of wrong open string tags (https://github.com/thonny/thonny/issues/943)\n        search_start = viewport_start\n        while True:\n            tag_range = self.text.tag_nextrange(\"open_string\", search_start, viewport_end)\n            if not tag_range:\n                break\n\n            if \"string3\" in self.text.tag_names(tag_range[0]):\n                self.text.tag_remove(\"open_string\", tag_range[0], tag_range[1])\n\n            search_start = tag_range[1]", "is_method": true, "class_name": "CodeViewSyntaxColorer", "function_description": "Updates the syntax highlighting within the visible text viewport by refreshing single-line and multi-line token colorings, ensuring accurate visual representation of code elements and fixing incorrect open string tags."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_update_coloring", "line_number": 290, "body": "def _update_coloring(self):\n        parts = self.text.tag_prevrange(\"command\", \"end\")\n\n        if parts:\n            end_row, end_col = map(int, self.text.index(parts[1]).split(\".\"))\n\n            if end_col != 0:  # if not just after the last linebreak\n                end_row += 1  # then extend the range to the beginning of next line\n                end_col = 0  # (otherwise open strings are not displayed correctly)\n\n            start_index = parts[0]\n            end_index = \"%d.%d\" % (end_row, end_col)\n\n            self._update_uniline_tokens(start_index, end_index)\n            self._update_multiline_tokens(start_index, end_index)", "is_method": true, "class_name": "ShellSyntaxColorer", "function_description": "Updates syntax highlighting ranges in the ShellSyntaxColorer text widget to correctly display both single-line and multi-line shell command tokens, ensuring visual accuracy of open strings and commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/common_editing_commands.py", "function": "load_plugin", "line_number": 7, "body": "def load_plugin() -> None:\n    def create_edit_command_handler(virtual_event_sequence):\n        def handler(event=None):\n            widget = get_workbench().focus_get()\n            if widget:\n                return widget.event_generate(virtual_event_sequence)\n\n            return None\n\n        return handler\n\n    get_workbench().add_command(\n        \"undo\",\n        \"edit\",\n        tr(\"Undo\"),\n        create_edit_command_handler(\"<<Undo>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-z>\", \"<Command-z>\"),\n        extra_sequences=[\"<Control-Greek_zeta>\"],\n        skip_sequence_binding=True,\n        group=10,\n    )\n\n    get_workbench().add_command(\n        \"redo\",\n        \"edit\",\n        tr(\"Redo\"),\n        create_edit_command_handler(\"<<Redo>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-y>\", \"<Command-y>\"),\n        extra_sequences=[\n            select_sequence(\"<Control-Shift-Z>\", \"<Command-Shift-Z>\"),\n            \"<Control-Greek_upsilon>\",\n            \"<Control-Shift-Greek_ZETA>\",\n        ],\n        skip_sequence_binding=True,\n        group=10,\n    )\n\n    get_workbench().add_command(\n        \"Cut\",\n        \"edit\",\n        tr(\"Cut\"),\n        create_edit_command_handler(\"<<Cut>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-x>\", \"<Command-x>\"),\n        extra_sequences=[\"<Control-Greek_chi>\"],\n        skip_sequence_binding=True,\n        group=20,\n    )\n\n    get_workbench().add_command(\n        \"Copy\",\n        \"edit\",\n        tr(\"Copy\"),\n        create_edit_command_handler(\"<<Copy>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-c>\", \"<Command-c>\"),\n        extra_sequences=[\"<Control-Greek_psi>\"],\n        skip_sequence_binding=True,\n        group=20,\n    )\n\n    get_workbench().add_command(\n        \"Paste\",\n        \"edit\",\n        tr(\"Paste\"),\n        create_edit_command_handler(\"<<Paste>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-v>\", \"<Command-v>\"),\n        extra_sequences=[\"<Control-Greek_omega>\"],\n        skip_sequence_binding=True,\n        group=20,\n    )\n\n    get_workbench().add_command(\n        \"SelectAll\",\n        \"edit\",\n        tr(\"Select all\"),\n        create_edit_command_handler(\"<<SelectAll>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-a>\", \"<Command-a>\"),\n        extra_sequences=[\"<Control-Greek_alpha>\"],\n        skip_sequence_binding=True,\n        group=20,\n    )", "is_method": false, "function_description": "Sets up standard edit commands (undo, redo, cut, copy, paste, select all) in the workbench by binding them to their respective event handlers and keyboard shortcuts for consistent text editing functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/common_editing_commands.py", "function": "create_edit_command_handler", "line_number": 8, "body": "def create_edit_command_handler(virtual_event_sequence):\n        def handler(event=None):\n            widget = get_workbench().focus_get()\n            if widget:\n                return widget.event_generate(virtual_event_sequence)\n\n            return None\n\n        return handler", "is_method": false, "function_description": "Creates and returns an event handler that triggers a specified virtual event on the currently focused widget, facilitating custom event handling in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/common_editing_commands.py", "function": "handler", "line_number": 9, "body": "def handler(event=None):\n            widget = get_workbench().focus_get()\n            if widget:\n                return widget.event_generate(virtual_event_sequence)\n\n            return None", "is_method": false, "function_description": "This function triggers a specified virtual event on the currently focused widget in the workbench, enabling event-driven interactions within the application's user interface. It serves as a utility to programmatically generate events based on UI focus."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/thonny_folders.py", "function": "load_plugin", "line_number": 9, "body": "def load_plugin() -> None:\n    def cmd_open_data_dir():\n        open_path_in_system_file_manager(THONNY_USER_DIR)\n\n    def cmd_open_program_dir():\n        open_path_in_system_file_manager(get_workbench().get_package_dir())\n\n    get_workbench().add_command(\n        \"open_program_dir\",\n        \"tools\",\n        tr(\"Open Thonny program folder...\"),\n        cmd_open_program_dir,\n        group=110,\n    )\n    get_workbench().add_command(\n        \"open_data_dir\", \"tools\", tr(\"Open Thonny data folder...\"), cmd_open_data_dir, group=110\n    )", "is_method": false, "function_description": "Registers commands in the workbench to open the Thonny program and data directories through the system file manager, facilitating quick access to these key folders."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/thonny_folders.py", "function": "cmd_open_data_dir", "line_number": 10, "body": "def cmd_open_data_dir():\n        open_path_in_system_file_manager(THONNY_USER_DIR)", "is_method": false, "function_description": "This function opens the user's data directory in the system's file manager, providing quick access to Thonny's user files and settings. It is useful for managing or inspecting application data outside the program."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/thonny_folders.py", "function": "cmd_open_program_dir", "line_number": 13, "body": "def cmd_open_program_dir():\n        open_path_in_system_file_manager(get_workbench().get_package_dir())", "is_method": false, "function_description": "Function that opens the program's package directory in the system's file manager, facilitating quick access to the application's main folder."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/birdseye_frontend.py", "function": "_start_debug_enabled", "line_number": 13, "body": "def _start_debug_enabled():\n    return (\n        get_workbench().get_editor_notebook().get_current_editor() is not None\n        and \"debug\" in get_runner().get_supported_features()\n    )", "is_method": false, "function_description": "Utility function that checks if debugging is currently enabled by verifying an active editor and support for debugging features. It helps determine whether debugging operations can be performed in the current environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/birdseye_frontend.py", "function": "start_server", "line_number": 20, "body": "def start_server():\n    global _server_process\n\n    out_err_filename = os.path.join(THONNY_USER_DIR, \"birdseye.log\")\n    output_file = open(out_err_filename, \"w\")\n    _server_process = subprocess.Popen(\n        [\n            running.get_interpreter_for_subprocess(),\n            \"-m\",\n            \"birdseye\",\n            \"-p\",\n            str(get_workbench().get_option(\"run.birdseye_port\")),\n        ],\n        stdout=output_file,\n        stderr=output_file,\n    )\n    atexit.register(close_server)", "is_method": false, "function_description": "Starts a background Birdseye server process logging output to a file and ensures it closes on program exit. This enables runtime code inspection and debugging features in the hosting environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/birdseye_frontend.py", "function": "close_server", "line_number": 39, "body": "def close_server():\n    if _server_process is not None:\n        try:\n            _server_process.kill()\n        except Exception:\n            pass", "is_method": false, "function_description": "Function that terminates a running server process if it exists, ensuring cleanup of system resources. It safely handles potential errors during the shutdown."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/birdseye_frontend.py", "function": "debug_with_birdseye", "line_number": 47, "body": "def debug_with_birdseye():\n    global _server_started\n\n    try:\n        import birdseye  # @UnusedImport\n    except ImportError:\n        if messagebox.askyesno(\n            tr(\"About Birdseye\"),\n            tr(\n                \"Birdseye is a Python debugger which needs to be installed separately.\\n\\n\"\n                + \"Do you want to open the help page and learn more?\"\n            ),\n            master=get_workbench(),\n        ):\n            get_workbench().open_help_topic(\"birdseye\")\n\n        return\n\n    if not _server_started:\n        start_server()\n        _server_started = True\n\n    os.environ[\"BIRDSEYE_PORT\"] = str(get_workbench().get_option(\"run.birdseye_port\"))\n    get_runner().execute_current(\"Birdseye\")", "is_method": false, "function_description": "This function initializes and starts the Birdseye debugger server if not already running, prompts installation help if Birdseye is missing, then executes the current code with Birdseye enabled for interactive debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/birdseye_frontend.py", "function": "load_plugin", "line_number": 78, "body": "def load_plugin():\n    get_workbench().set_default(\"run.birdseye_port\", 7777)\n    get_workbench().add_command(\n        \"birdseye\",\n        \"run\",\n        tr(\"Debug current script (birdseye)\"),\n        debug_with_birdseye,\n        caption=\"birdseye\",\n        tester=_start_debug_enabled,\n        default_sequence=\"<Control-B>\",\n        group=10,\n        image=os.path.join(os.path.dirname(__file__), \"..\", \"res\", \"birdseye.png\"),\n    )", "is_method": false, "function_description": "Provides integration of the Birdseye debugging tool by configuring default settings and adding a command to the workbench for running scripts with Birdseye debugging capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "update_highlighting", "line_number": 104, "body": "def update_highlighting(event):\n    if not get_workbench().ready:\n        # don't slow down loading process\n        return\n\n    assert isinstance(event.widget, tk.Text)\n    text = event.widget\n\n    if not hasattr(text, \"local_highlighter\"):\n        text.local_highlighter = LocalsHighlighter(text)\n\n    text.local_highlighter.schedule_update()", "is_method": false, "function_description": "Utility function that triggers or schedules an update of syntax or semantic highlighting on a text widget during user interaction, ensuring highlighting is only applied when the application is ready."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "load_plugin", "line_number": 118, "body": "def load_plugin() -> None:\n    wb = get_workbench()\n    wb.set_default(\"view.locals_highlighting\", False)\n    wb.bind_class(\"CodeViewText\", \"<<TextChange>>\", update_highlighting, True)\n    wb.bind(\"<<UpdateAppearance>>\", update_highlighting, True)", "is_method": false, "function_description": "Sets up and configures plugin behavior in the workbench, including default view settings and event bindings for updating code view highlighting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "get_positions", "line_number": 13, "body": "def get_positions(self):\n        from jedi import parser_utils\n        from parso.python import tree\n\n        locs = []\n\n        def process_scope(scope):\n            if isinstance(scope, tree.Function):\n                # process all children after name node,\n                # (otherwise name of global function will be marked as local def)\n                local_names = set()\n                global_names = set()\n                for child in scope.children[2:]:\n                    process_node(child, local_names, global_names)\n            else:\n                if hasattr(scope, \"subscopes\"):\n                    for child in scope.subscopes:\n                        process_scope(child)\n                elif hasattr(scope, \"children\"):\n                    for child in scope.children:\n                        process_scope(child)\n\n        def process_node(node, local_names, global_names):\n            if isinstance(node, tree.GlobalStmt):\n                global_names.update([n.value for n in node.get_global_names()])\n\n            elif isinstance(node, tree.Name):\n                if node.value in global_names:\n                    return\n\n                if node.is_definition():  # local def\n                    locs.append(node)\n                    local_names.add(node.value)\n                elif node.value in local_names:  # use of local\n                    locs.append(node)\n\n            elif isinstance(node, tree.BaseNode):\n                # ref: jedi/parser/grammar*.txt\n                if node.type == \"trailer\" and node.children[0].value == \".\":\n                    # this is attribute\n                    return\n\n                if isinstance(node, tree.Function):\n                    global_names = set()  # outer global statement doesn't have effect anymore\n\n                for child in node.children:\n                    process_node(child, local_names, global_names)\n\n        source = self.text.get(\"1.0\", \"end\")\n        module = jedi_utils.parse_source(source)\n        for child in module.children:\n            if isinstance(child, tree.BaseNode) and parser_utils.is_scope(child):\n                process_scope(child)\n\n        loc_pos = set(\n            (\n                \"%d.%d\" % (usage.start_pos[0], usage.start_pos[1]),\n                \"%d.%d\" % (usage.start_pos[0], usage.start_pos[1] + len(usage.value)),\n            )\n            for usage in locs\n        )\n\n        return loc_pos", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "Identifies and returns the text positions of local variable definitions and usages within Python code, distinguishing them from global names. Useful for syntax highlighting or code analysis tools focused on local scope variables."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "_highlight", "line_number": 77, "body": "def _highlight(self, pos_info):\n        for pos in pos_info:\n            start_index, end_index = pos[0], pos[1]\n            self.text.tag_add(\"local_name\", start_index, end_index)", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "Private method of LocalsHighlighter that adds highlight tags to specified text ranges, supporting visual identification of local names or variables within the text content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "schedule_update", "line_number": 82, "body": "def schedule_update(self):\n        def perform_update():\n            try:\n                self.update()\n            finally:\n                self._update_scheduled = False\n\n        if not self._update_scheduled:\n            self._update_scheduled = True\n            self.text.after_idle(perform_update)", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "Schedules a deferred update operation to avoid redundant executions, ensuring the update runs once after the current idle event completes. Useful for efficiently batching or throttling UI refreshes in the LocalsHighlighter context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "update", "line_number": 93, "body": "def update(self):\n        self.text.tag_remove(\"local_name\", \"1.0\", \"end\")\n\n        if get_workbench().get_option(\"view.locals_highlighting\") and self.text.is_python_text():\n            try:\n                highlight_positions = self.get_positions()\n                self._highlight(highlight_positions)\n            except Exception:\n                logging.exception(\"Problem when updating local variable tags\")", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "Core method of LocalsHighlighter that updates local variable highlighting in the associated text widget, conditionally applying tags based on user settings and text type while handling any errors during the process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "process_scope", "line_number": 19, "body": "def process_scope(scope):\n            if isinstance(scope, tree.Function):\n                # process all children after name node,\n                # (otherwise name of global function will be marked as local def)\n                local_names = set()\n                global_names = set()\n                for child in scope.children[2:]:\n                    process_node(child, local_names, global_names)\n            else:\n                if hasattr(scope, \"subscopes\"):\n                    for child in scope.subscopes:\n                        process_scope(child)\n                elif hasattr(scope, \"children\"):\n                    for child in scope.children:\n                        process_scope(child)", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "Recursively traverses code scopes to identify and process local and global variable uses within functions and nested structures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "process_node", "line_number": 35, "body": "def process_node(node, local_names, global_names):\n            if isinstance(node, tree.GlobalStmt):\n                global_names.update([n.value for n in node.get_global_names()])\n\n            elif isinstance(node, tree.Name):\n                if node.value in global_names:\n                    return\n\n                if node.is_definition():  # local def\n                    locs.append(node)\n                    local_names.add(node.value)\n                elif node.value in local_names:  # use of local\n                    locs.append(node)\n\n            elif isinstance(node, tree.BaseNode):\n                # ref: jedi/parser/grammar*.txt\n                if node.type == \"trailer\" and node.children[0].value == \".\":\n                    # this is attribute\n                    return\n\n                if isinstance(node, tree.Function):\n                    global_names = set()  # outer global statement doesn't have effect anymore\n\n                for child in node.children:\n                    process_node(child, local_names, global_names)", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "Utility method that recursively identifies and collects local variable definitions and usages within a syntax tree node while tracking global variable declarations, supporting code analysis and highlighting of local variables in Python code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "perform_update", "line_number": 83, "body": "def perform_update():\n            try:\n                self.update()\n            finally:\n                self._update_scheduled = False", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "Calls the update process and ensures the internal update scheduling flag is reset afterward. This method manages update execution state within the LocalsHighlighter class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_generate_timestamp_file_name", "line_number": 159, "body": "def _generate_timestamp_file_name(extension):\n    # generate log filename\n    folder = _get_log_dir()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n\n    for i in range(100):\n        filename = os.path.join(\n            folder, time.strftime(\"%Y-%m-%d_%H-%M-%S_{}.{}\".format(i, extension))\n        )\n        if not os.path.exists(filename):\n            return filename\n\n    raise RuntimeError()", "is_method": false, "function_description": "Utility function that generates a unique timestamped filename with the given extension in a log directory, ensuring no filename conflicts by appending an incrementing index."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_get_log_dir", "line_number": 175, "body": "def _get_log_dir():\n    return os.path.join(THONNY_USER_DIR, \"user_logs\")", "is_method": false, "function_description": "Utility function that provides the file path to the user logs directory within the application's user-specific folder."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "export", "line_number": 179, "body": "def export():\n    import zipfile\n\n    filename = asksaveasfilename(\n        filetypes=[(\"Zip-files\", \".zip\"), (\"all files\", \".*\")],\n        defaultextension=\".zip\",\n        initialdir=get_workbench().get_local_cwd(),\n        initialfile=time.strftime(\"ThonnyUsageLogs_%Y-%m-%d.zip\"),\n        parent=get_workbench(),\n    )\n\n    if not filename:\n        return\n\n    log_dir = _get_log_dir()\n\n    with zipfile.ZipFile(filename, \"w\", compression=zipfile.ZIP_DEFLATED) as zipf:\n        for item in os.listdir(log_dir):\n            if item.endswith(\".txt\") or item.endswith(\".zip\"):\n                zipf.write(os.path.join(log_dir, item), arcname=item)", "is_method": false, "function_description": "Function that lets users save all usage log files from a specific directory into a compressed zip archive, facilitating easy export and backup of log data via a graphical save dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "load_plugin", "line_number": 201, "body": "def load_plugin() -> None:\n    get_workbench().set_default(\"general.event_logging\", False)\n\n    if get_workbench().get_option(\"general.event_logging\"):\n        get_workbench().add_command(\n            \"export_usage_logs\", \"tools\", tr(\"Export usage logs...\"), export, group=110\n        )\n\n        filename = _generate_timestamp_file_name(\"txt\")\n        # create logger\n        EventLogger(filename)", "is_method": false, "function_description": "Sets up the plugin by disabling default event logging and conditionally enabling usage log export and event logging based on user preferences within the workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_bind_workbench", "line_number": 61, "body": "def _bind_workbench(self, sequence, only_workbench_widget=False):\n        def handle(event):\n            if not only_workbench_widget or event.widget == get_workbench():\n                self._log_event(sequence, event)\n\n        get_workbench().bind(sequence, handle, True)", "is_method": true, "class_name": "EventLogger", "function_description": "Internal method of EventLogger that attaches an event handler to the workbench, optionally filtering events to only trigger on the workbench widget, enabling selective logging of GUI events based on event sequences."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_bind_all", "line_number": 68, "body": "def _bind_all(self, sequence):\n        def handle(event):\n            self._log_event(sequence, event)\n\n        tk._default_root.bind_all(sequence, handle, True)", "is_method": true, "class_name": "EventLogger", "function_description": "Core utility of the EventLogger class that binds a handler to all widgets for a given event sequence, enabling centralized logging of those events across the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_extract_interesting_data", "line_number": 74, "body": "def _extract_interesting_data(self, event, sequence):\n        attributes = vars(event)\n\n        # generate some new attributes\n        if \"text_widget\" not in attributes:\n            if \"editor\" in attributes:\n                attributes[\"text_widget\"] = attributes[\"editor\"].get_text_widget()\n\n            if \"widget\" in attributes and isinstance(attributes[\"widget\"], tk.Text):\n                attributes[\"text_widget\"] = attributes[\"widget\"]\n\n        if \"text_widget\" in attributes:\n            widget = attributes[\"text_widget\"]\n            if isinstance(widget.master.master, ShellView):\n                attributes[\"text_widget_context\"] = \"shell\"\n\n        # select attributes\n        data = {}\n        for name in attributes:\n            # skip some attributes\n            if (\n                name.startswith(\"_\")\n                or isinstance(event, WorkbenchEvent)\n                and name in [\"update\", \"setdefault\"]\n                or isinstance(event, tk.Event)\n                and name not in [\"widget\", \"text_widget\", \"text_widget_context\"]\n            ):\n                continue\n\n            value = attributes[name]\n\n            if isinstance(value, (tk.BaseWidget, tk.Tk)):\n                data[name + \"_id\"] = id(value)\n                data[name + \"_class\"] = value.__class__.__name__\n\n            elif isinstance(value, (str, int, float)):\n                data[name] = value\n\n            else:\n                data[name] = repr(value)\n\n        return data", "is_method": true, "class_name": "EventLogger", "function_description": "Utility method of EventLogger that extracts and formats relevant attributes from an event, enhancing widget context details and filtering out unneeded data for concise event logging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_log_event", "line_number": 117, "body": "def _log_event(self, sequence, event):\n        data = self._extract_interesting_data(event, sequence)\n        data[\"sequence\"] = sequence\n        data[\"time\"] = datetime.now().isoformat()\n        if len(data[\"time\"]) == 19:\n            # 0 fraction gets skipped, but reader assumes it\n            data[\"time\"] += \".0\"\n        self._events.append(data)", "is_method": true, "class_name": "EventLogger", "function_description": "Internal method of the EventLogger class that records an event with extracted relevant data, sequence identifier, and a timestamp, appending this information to the event log. It supports event tracking with temporal context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_on_worbench_close", "line_number": 126, "body": "def _on_worbench_close(self, event=None):\n        import json\n\n        with open(self._filename, encoding=\"UTF-8\", mode=\"w\") as fp:\n            json.dump(self._events, fp, indent=\"    \")\n\n        self._check_compress_logs()", "is_method": true, "class_name": "EventLogger", "function_description": "Private method of EventLogger that saves accumulated events to a JSON file upon closing and triggers log compression if enabled."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_check_compress_logs", "line_number": 134, "body": "def _check_compress_logs(self):\n        import zipfile\n\n        # if uncompressed logs have grown over 10MB,\n        # compress these into new zipfile\n\n        log_dir = _get_log_dir()\n        total_size = 0\n        uncompressed_files = []\n        for item in os.listdir(log_dir):\n            if item.endswith(\".txt\"):\n                full_name = os.path.join(log_dir, item)\n                total_size += os.stat(full_name).st_size\n                uncompressed_files.append((item, full_name))\n\n        if total_size > 10 * 1024 * 1024:\n            zip_filename = _generate_timestamp_file_name(\"zip\")\n            with zipfile.ZipFile(zip_filename, \"w\", compression=zipfile.ZIP_DEFLATED) as zipf:\n                for item, full_name in uncompressed_files:\n                    zipf.write(full_name, arcname=item)\n\n            for _, full_name in uncompressed_files:\n                os.remove(full_name)", "is_method": true, "class_name": "EventLogger", "function_description": "Internal method of EventLogger that compresses uncompressed log files into a zip archive when their total size exceeds 10MB, helping manage disk space and organize log storage efficiently."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/clean_ui_themes.py", "function": "clean", "line_number": 9, "body": "def clean(\n    frame_background: str,\n    text_background: str,\n    normal_detail: str,\n    high_detail: str,\n    low_detail: str,\n    normal_foreground: str,\n    high_foreground: str,\n    low_foreground: str,\n    custom_menubar: Optional[\n        int\n    ] = None,  # NB! Should be 1 or 0, not True or False (Tk would convert False to \"False\")\n) -> UiThemeSettings:\n\n    # https://wiki.tcl.tk/37973 (Changing colors)\n    # https://github.com/tcltk/tk/blob/master/library/ttk/clamTheme.tcl\n    # https://github.com/tcltk/tk/blob/master/generic/ttk/ttkClamTheme.c\n\n    return {\n        \".\": {\n            \"configure\": {\n                \"foreground\": normal_foreground,\n                \"background\": frame_background,\n                \"lightcolor\": frame_background,\n                \"darkcolor\": frame_background,\n                \"bordercolor\": frame_background,\n                \"selectbackground\": high_detail,\n                \"selectforeground\": high_foreground,\n            },\n            \"map\": {\n                \"foreground\": [(\"disabled\", low_foreground), (\"active\", high_foreground)],\n                \"background\": [(\"disabled\", frame_background), (\"active\", high_detail)],\n                \"selectbackground\": [(\"!focus\", low_detail)],\n                \"selectforeground\": [(\"!focus\", normal_foreground)],\n            },\n        },\n        \"TNotebook\": {\n            # https://github.com/tcltk/tk/blob/master/generic/ttk/ttkNotebook.c\n            \"configure\": {\n                \"bordercolor\": normal_detail,\n                \"tabmargins\": [scale(1), 0, 0, 0],  # Margins around tab row\n            }\n        },\n        \"ButtonNotebook.TNotebook\": {\"configure\": {\"bordercolor\": frame_background}},\n        \"AutomaticNotebook.TNotebook\": {\"configure\": {\"bordercolor\": frame_background}},\n        \"TNotebook.Tab\": {\n            \"configure\": {\"background\": frame_background, \"bordercolor\": normal_detail},\n            \"map\": {\n                \"background\": [\n                    (\"selected\", normal_detail),\n                    (\"!selected\", \"!active\", frame_background),\n                    (\"active\", \"!selected\", high_detail),\n                ],\n                \"bordercolor\": [(\"selected\", frame_background), (\"!selected\", normal_detail)],\n                \"lightcolor\": [(\"selected\", normal_detail), (\"!selected\", frame_background)],\n            },\n        },\n        \"Treeview\": {\n            \"configure\": {\"background\": text_background, \"borderwidth\": 0, \"relief\": \"flat\"},\n            \"map\": {\n                \"background\": [\n                    (\"selected\", \"focus\", high_detail),\n                    (\"selected\", \"!focus\", low_detail),\n                ],\n                \"foreground\": [\n                    (\"selected\", \"focus\", high_foreground),\n                    (\"selected\", \"!focus\", normal_foreground),\n                ],\n            },\n        },\n        \"Treeview.Heading\": {\n            # https://stackoverflow.com/questions/32051780/how-to-edit-the-style-of-a-heading-in-treeview-python-ttk\n            \"configure\": {\n                \"background\": normal_detail,\n                \"lightcolor\": normal_detail,\n                \"borderwidth\": 0,\n            },\n            \"map\": {\"background\": [(\"!active\", normal_detail), (\"active\", normal_detail)]},\n        },\n        \"TEntry\": {\n            \"configure\": {\n                \"fieldbackground\": text_background,\n                \"lightcolor\": normal_detail,\n                \"insertcolor\": normal_foreground,\n            },\n            \"map\": {\n                \"background\": [(\"readonly\", text_background)],\n                \"bordercolor\": [],\n                \"lightcolor\": [(\"focus\", high_detail)],\n                \"darkcolor\": [],\n            },\n        },\n        \"TCombobox\": {\n            \"configure\": {\n                \"background\": text_background,\n                \"fieldbackground\": text_background,\n                \"selectbackground\": text_background,\n                \"lightcolor\": text_background,\n                \"darkcolor\": text_background,\n                \"bordercolor\": text_background,\n                \"arrowcolor\": normal_foreground,\n                \"foreground\": normal_foreground,\n                \"seleftforeground\": normal_foreground,\n                # \"padding\" : [12,2,12,2],\n            },\n            \"map\": {\n                \"background\": [(\"active\", text_background)],\n                \"fieldbackground\": [],\n                \"selectbackground\": [],\n                \"selectforeground\": [],\n                \"foreground\": [],\n                \"arrowcolor\": [],\n            },\n        },\n        \"TScrollbar\": {\n            \"configure\": {\n                \"gripcount\": 0,\n                \"borderwidth\": 0,\n                \"relief\": \"flat\",\n                \"darkcolor\": normal_detail,\n                \"lightcolor\": normal_detail,\n                \"bordercolor\": text_background,\n                \"troughcolor\": text_background,\n                # arrowcolor=\"white\"\n            },\n            \"map\": {\n                \"background\": [(\"!disabled\", normal_detail), (\"disabled\", normal_detail)],\n                \"darkcolor\": [(\"!disabled\", text_background), (\"disabled\", text_background)],\n                \"lightcolor\": [(\"!disabled\", text_background), (\"disabled\", text_background)],\n            },\n        },\n        \"Vertical.TScrollbar\": {\n            # Remove scrollbar buttons/arrows:\n            \"layout\": [\n                (\n                    \"Vertical.Scrollbar.trough\",\n                    {\n                        \"sticky\": \"ns\",\n                        \"children\": [\n                            (\"Vertical.Scrollbar.thumb\", {\"expand\": \"1\", \"sticky\": \"nswe\"})\n                        ],\n                    },\n                )\n            ]\n        },\n        \"Horizontal.TScrollbar\": {\n            # Remove scrollbar buttons/arrows:\n            \"layout\": [\n                (\n                    \"Horizontal.Scrollbar.trough\",\n                    {\n                        \"sticky\": \"we\",\n                        \"children\": [\n                            (\"Horizontal.Scrollbar.thumb\", {\"expand\": \"1\", \"sticky\": \"nswe\"})\n                        ],\n                    },\n                )\n            ],\n            \"map\": {\n                # Make disabled Hor Scrollbar invisible\n                \"background\": [(\"disabled\", frame_background), (\"!disabled\", normal_detail)],\n                \"troughcolor\": [(\"disabled\", frame_background)],\n                \"bordercolor\": [(\"disabled\", frame_background)],\n                \"darkcolor\": [(\"disabled\", frame_background)],\n                \"lightcolor\": [(\"disabled\", frame_background)],\n            },\n        },\n        \"TButton\": {\n            \"configure\": {\"background\": normal_detail, \"foreground\": normal_foreground},\n            \"map\": {\n                \"foreground\": [(\"disabled\", low_foreground), (\"alternate\", high_foreground)],\n                \"background\": [(\"pressed\", low_detail), (\"active\", high_detail)],\n                \"bordercolor\": [(\"alternate\", high_detail)],\n            },\n        },\n        \"TCheckbutton\": {\n            \"configure\": {\n                \"indicatorforeground\": normal_foreground,\n                \"indicatorbackground\": text_background,\n            },\n            \"map\": {\n                \"indicatorforeground\": [\n                    (\"disabled\", \"alternate\", low_foreground),\n                    (\"disabled\", low_foreground),\n                ],\n                \"indicatorbackground\": [\n                    (\"disabled\", \"alternate\", text_background),\n                    (\"disabled\", text_background),\n                ],\n            },\n        },\n        \"TRadiobutton\": {\n            \"configure\": {\n                \"indicatorforeground\": normal_foreground,\n                \"indicatorbackground\": text_background,\n            },\n            \"map\": {\n                \"indicatorforeground\": [\n                    (\"disabled\", \"alternate\", low_foreground),\n                    (\"disabled\", low_foreground),\n                ]\n            },\n        },\n        \"Toolbutton\": {\n            \"configure\": {\"background\": frame_background},\n            \"map\": {\"background\": [(\"disabled\", frame_background), (\"active\", high_detail)]},\n        },\n        \"TLabel\": {\"configure\": {\"foreground\": normal_foreground}},\n        \"Url.TLabel\": {\"configure\": {\"foreground\": normal_foreground}},\n        \"Tip.TLabel\": {\"configure\": {\"foreground\": normal_foreground, \"background\": low_detail}},\n        \"Tip.TFrame\": {\"configure\": {\"background\": low_detail}},\n        \"TScale\": {\n            \"configure\": {\n                \"background\": high_detail,\n                \"troughcolor\": normal_detail,\n                \"lightcolor\": high_detail,\n                \"darkcolor\": high_detail,\n                # \"bordercolor\" : \"red\",\n                # \"sliderlength\" : 40,\n                # \"sliderthickness\" : 60,\n                \"gripcount\": 0,\n            },\n            \"map\": {\"background\": [], \"troughcolor\": []},\n        },\n        \"TScale.slider\": {\n            \"configure\": {\n                \"background\": \"red\",\n                \"troughcolor\": \"yellow\",\n                \"lightcolor\": \"green\",\n                \"darkcolor\": \"white\",\n                # \"sliderlength\" : 40,\n                # \"sliderthickness\" : 60,\n            }\n        },\n        \"ViewBody.TFrame\": {\"configure\": {\"background\": text_background}},\n        \"ViewToolbar.TFrame\": {\"configure\": {\"background\": normal_detail}},\n        \"ViewToolbar.Toolbutton\": {\"configure\": {\"background\": normal_detail}},\n        \"ViewTab.TLabel\": {\"configure\": {\"background\": normal_detail, \"padding\": [5, 0]}},\n        \"ViewToolbar.TLabel\": {\n            \"configure\": {\"background\": normal_detail, \"padding\": [scale(4), 0]}\n        },\n        \"Active.ViewTab.TLabel\": {\n            \"configure\": {\n                \"foreground\": high_foreground,\n                # \"font\" : \"BoldTkDefaultFont\",\n                \"background\": text_background,\n            }\n        },\n        \"Inactive.ViewTab.TLabel\": {\n            \"configure\": {\"foreground\": normal_foreground},\n            \"map\": {\"background\": [(\"hover\", high_detail)]},\n        },\n        \"Text\": {\"configure\": {\"background\": text_background, \"foreground\": normal_foreground}},\n        \"Gutter\": {\"configure\": {\"background\": low_detail, \"foreground\": low_foreground}},\n        \"Listbox\": {\n            \"configure\": {\n                \"background\": text_background,\n                \"foreground\": normal_foreground,\n                \"selectbackground\": high_detail,\n                \"selectforeground\": high_foreground,\n                \"disabledforeground\": low_foreground,\n                \"highlightbackground\": normal_detail,\n                \"highlightcolor\": high_detail,\n                \"highlightthickness\": 1,\n            }\n        },\n        \"Menubar\": {\n            \"configure\": {\n                # Regular, system-provided Windows menubar doesn't allow changing colors.\n                # custom=True replaces it with a custom-built menubar.\n                \"custom\": running_on_windows() if custom_menubar is None else custom_menubar,\n                \"background\": frame_background,\n                \"foreground\": normal_foreground,\n                \"activebackground\": normal_foreground,\n                \"activeforeground\": frame_background,\n                \"relief\": \"flat\",\n            }\n        },\n        \"Menu\": {\n            \"configure\": {\n                \"background\": normal_detail,\n                \"foreground\": high_foreground,\n                \"selectcolor\": normal_foreground,\n                # \"borderwidth\": 0, # Interacts badly with right-clicks in Linux\n                \"activebackground\": normal_foreground,\n                \"activeforeground\": frame_background,\n                # \"activeborderwidth\": 0, # Interacts badly with right-clicks in Linux\n                \"relief\": \"flat\",\n            }\n        },\n        \"CustomMenubarLabel.TLabel\": {\n            \"configure\": {\"padding\": [scale(10), scale(2), 0, scale(15)]}\n        },\n    }", "is_method": false, "function_description": "Function that generates a comprehensive UI theme configuration dictionary based on provided color settings, enabling consistent styling of Tkinter ttk widgets for customizable application interfaces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/clean_ui_themes.py", "function": "load_plugin", "line_number": 305, "body": "def load_plugin() -> None:\n    dark_images = {\"tab-close-active\": \"tab-close-active-clam-dark\"}\n\n    get_workbench().add_ui_theme(\n        \"Clean Dark\",\n        \"Enhanced Clam\",\n        clean(\n            frame_background=\"#252525\",\n            text_background=\"#2d2d2d\",\n            normal_detail=\"#3D3D3D\",\n            high_detail=\"#6E6E6E\",\n            low_detail=\"#404040\",\n            normal_foreground=\"#9f9f9f\",\n            high_foreground=\"#eeeeee\",\n            low_foreground=\"#666666\",\n        ),\n        dark_images,\n    )\n\n    dark_tip_background = (\"#b8c28d\",)\n\n    get_workbench().add_ui_theme(\n        \"Clean Dark Green\",\n        \"Enhanced Clam\",\n        clean(\n            frame_background=\"#1D291A\",\n            text_background=\"#273627\",\n            normal_detail=\"#2D452F\",\n            high_detail=\"#3C6E40\",\n            low_detail=\"#33402F\",\n            normal_foreground=\"#9E9E9E\",\n            high_foreground=\"#eeeeee\",\n            low_foreground=\"#5a725b\",\n        ),\n        dark_images,\n    )\n\n    get_workbench().add_ui_theme(\n        \"Clean Dark Blue\",\n        \"Enhanced Clam\",\n        clean(\n            frame_background=\"#1A1C29\",\n            text_background=\"#272936\",\n            normal_detail=\"#2D3345\",\n            high_detail=\"#3C436E\",\n            low_detail=\"#2F3640\",\n            normal_foreground=\"#9E9E9E\",\n            high_foreground=\"#eeeeee\",\n            low_foreground=\"#5a5c72\",\n        ),\n        dark_images,\n    )\n\n    get_workbench().add_ui_theme(\n        \"Clean Sepia\",\n        \"Enhanced Clam\",\n        clean(\n            frame_background=\"#E8E7DC\",\n            text_background=\"#F7F6F0\",\n            normal_detail=\"#DEDCC8\",\n            high_detail=\"#eeebe7\",\n            low_detail=\"#D4D0B8\",\n            normal_foreground=\"#222222\",\n            high_foreground=\"#000000\",\n            low_foreground=\"#999999\",\n            custom_menubar=0,\n        ),\n    )", "is_method": false, "function_description": "Function that registers multiple custom UI themes with specific color schemes to enhance the workbench's visual appearance by adding dark and sepia styled themes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "scale", "line_number": 9, "body": "def scale(value) -> float:\n    # dimensions in this module were designed with a 1.67 scale\n    return get_workbench().scale(value / 1.67)", "is_method": false, "function_description": "Utility function that rescales a given value based on a predefined scale factor and the current workbench scaling setting, facilitating consistent dimension adjustments in a graphical or design context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_treeview_settings", "line_number": 14, "body": "def _treeview_settings() -> BasicUiThemeSettings:\n    light_blue = \"#ADD8E6\"\n    light_grey = \"#D3D3D3\"\n\n    if running_on_linux() or running_on_mac_os():\n        bg_sel_focus = light_blue\n        fg_sel_focus = \"black\"\n        fg_sel_notfocus = \"black\"\n    else:\n        bg_sel_focus = \"SystemHighlight\"\n        fg_sel_focus = \"SystemHighlightText\"\n        fg_sel_notfocus = \"SystemWindowText\"\n\n    return {\n        \"Treeview\": {\n            \"configure\": {\"font\": \"TreeviewFont\"},\n            \"map\": {\n                \"background\": [\n                    (\"selected\", \"focus\", bg_sel_focus),\n                    (\"selected\", \"!focus\", light_grey),\n                ],\n                \"foreground\": [\n                    (\"selected\", \"focus\", fg_sel_focus),\n                    (\"selected\", \"!focus\", fg_sel_notfocus),\n                ],\n            },\n            \"layout\": [\n                # get rid of borders\n                (\"Treeview.treearea\", {\"sticky\": \"nswe\"})\n            ],\n        },\n        \"treearea\": {\"configure\": {\"borderwidth\": 0}},\n    }", "is_method": false, "function_description": "Provides platform-specific visual settings for tree view UI elements, defining color and font themes to ensure consistent appearance across different operating systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_menubutton_settings", "line_number": 49, "body": "def _menubutton_settings() -> BasicUiThemeSettings:\n    return {\n        \"TMenubutton\": {\n            \"configure\": {\"padding\": scale(14)},\n            \"layout\": [\n                (\"Menubutton.dropdown\", {\"side\": \"right\", \"sticky\": \"ns\"}),\n                (\n                    \"Menubutton.button\",\n                    {\n                        \"children\": [\n                            # ('Menubutton.padding', {'children': [\n                            (\"Menubutton.label\", {\"sticky\": \"\"})\n                            # ], 'expand': '1', 'sticky': 'we'})\n                        ],\n                        \"expand\": \"1\",\n                        \"sticky\": \"nswe\",\n                    },\n                ),\n            ],\n        }\n    }", "is_method": false, "function_description": "Provides predefined UI theme settings for a menu button widget, specifying padding and layout details to ensure consistent styling and behavior within a graphical interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_paned_window_settings", "line_number": 72, "body": "def _paned_window_settings() -> BasicUiThemeSettings:\n    return {\"Sash\": {\"configure\": {\"sashthickness\": ems_to_pixels(0.6)}}}", "is_method": false, "function_description": "Returns UI theme settings specifying sash thickness for a paned window, facilitating consistent interface styling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_menu_settings", "line_number": 76, "body": "def _menu_settings() -> BasicUiThemeSettings:\n    return {\"Menubar\": {\"configure\": {\"activeborderwidth\": 0, \"relief\": \"flat\"}}}", "is_method": false, "function_description": "Private helper function providing default UI theme settings for menu bars, specifying appearance configurations like border width and relief style. It serves as a standardized theme configuration provider for the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_text_settings", "line_number": 80, "body": "def _text_settings() -> BasicUiThemeSettings:\n    return {\n        \"Text\": {\n            \"configure\": {\n                \"background\": \"SystemWindow\" if running_on_windows() else \"white\",\n                \"foreground\": \"SystemWindowText\" if running_on_windows() else \"black\",\n            }\n        },\n        \"Syntax.Text\": {\"map\": {\"background\": [(\"readonly\", \"Yellow\")]}},\n        \"Gutter\": {\"configure\": {\"background\": \"#e0e0e0\", \"foreground\": \"#999999\"}},\n    }", "is_method": false, "function_description": "Provides default UI theme configuration for text elements, adapting colors based on the operating system to ensure consistent visual appearance in the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_link_settings", "line_number": 93, "body": "def _link_settings() -> BasicUiThemeSettings:\n    tip_background = \"#b8c28d\"\n    tip_background = \"systemInfoBackground\"\n    return {\n        \"Url.TLabel\": {\"configure\": {\"foreground\": \"DarkBlue\"}},\n        \"Tip.TLabel\": {\"configure\": {\"background\": tip_background, \"foreground\": \"black\"}},\n        \"Tip.TFrame\": {\"configure\": {\"background\": tip_background}},\n    }", "is_method": false, "function_description": "Provides a predefined set of UI theme settings for link-related labels and frames, specifying colors for URL and tip elements to ensure consistent styling in the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_button_notebook_settings", "line_number": 103, "body": "def _button_notebook_settings() -> BasicUiThemeSettings:\n    # Adapted from https://github.com/python/cpython/blob/2.7/Demo/tkinter/ttk/notebook_closebtn.py\n    return {\n        \"closebutton\": {\n            \"element create\": (\n                \"image\",\n                \"img_close\",\n                (\"active\", \"pressed\", \"!disabled\", \"img_close_active\"),\n                (\"active\", \"!disabled\", \"img_close_active\"),\n                {\"padding\": scale(2), \"sticky\": \"\"},\n            )\n        },\n        \"ButtonNotebook.TNotebook.Tab\": {\n            \"layout\": [\n                (\n                    \"Notebook.tab\",\n                    {\n                        \"sticky\": \"nswe\",\n                        \"children\": [\n                            (\n                                \"Notebook.padding\",\n                                {\n                                    \"side\": \"top\",\n                                    \"sticky\": \"nswe\",\n                                    \"children\": [\n                                        (\n                                            \"Notebook.focus\",\n                                            {\n                                                \"side\": \"left\",\n                                                \"sticky\": \"nswe\",\n                                                \"children\": [\n                                                    (\n                                                        \"Notebook.label\",\n                                                        {\"side\": \"left\", \"sticky\": \"\"},\n                                                    )\n                                                ],\n                                            },\n                                        ),\n                                        (\"Notebook.closebutton\", {\"side\": \"right\", \"sticky\": \"\"}),\n                                    ],\n                                },\n                            )\n                        ],\n                    },\n                )\n            ]\n        },\n    }", "is_method": false, "function_description": "This function provides customized style settings for notebook tabs with close buttons in a UI theme, enabling consistent button appearance and layout in notebook interfaces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "clam", "line_number": 153, "body": "def clam() -> BasicUiThemeSettings:\n    # Transcribed from https://github.com/tcltk/tk/blob/master/library/ttk/clamTheme.tcl\n    defaultfg = \"#000000\"\n    disabledfg = \"#999999\"\n    frame = \"#dcdad5\"\n    window = \"#ffffff\"\n    dark = \"#cfcdc8\"\n    darker = \"#bab5ab\"\n    darkest = \"#9e9a91\"\n    lighter = \"#eeebe7\"\n    selectbg = \"#4a6984\"\n    selectfg = \"#ffffff\"\n    altindicator = \"#5895bc\"\n    disabledaltindicator = \"#a0a0a0\"\n\n    return {\n        \".\": {\n            \"configure\": {\n                \"background\": frame,\n                \"foreground\": defaultfg,\n                \"bordercolor\": darkest,\n                \"darkcolor\": dark,\n                \"lightcolor\": lighter,\n                \"troughcolor\": darker,\n                \"selectbackground\": selectbg,\n                \"selectforeground\": selectfg,\n                \"selectborderwidth\": 0,\n                \"font\": \"TkDefaultFont\",\n            },\n            \"map\": {\n                \"background\": [(\"disabled\", frame), (\"active\", lighter)],\n                \"foreground\": [(\"disabled\", disabledfg)],\n                \"selectbackground\": [(\"!focus\", darkest)],\n                \"selectforeground\": [(\"!focus\", \"white\")],\n            },\n        },\n        \"TButton\": {\n            \"configure\": {\n                \"anchor\": \"center\",\n                \"width\": scale(11),\n                \"padding\": scale(5),\n                \"relief\": \"raised\",\n            },\n            \"map\": {\n                \"background\": [(\"disabled\", frame), (\"pressed\", darker), (\"active\", lighter)],\n                \"lightcolor\": [(\"pressed\", darker)],\n                \"darkcolor\": [(\"pressed\", darker)],\n                \"bordercolor\": [(\"alternate\", \"#000000\")],\n            },\n        },\n        \"Toolbutton\": {\n            \"configure\": {\"anchor\": \"center\", \"padding\": scale(2), \"relief\": \"flat\"},\n            \"map\": {\n                \"relief\": [\n                    (\"disabled\", \"flat\"),\n                    (\"selected\", \"sunken\"),\n                    (\"pressed\", \"sunken\"),\n                    (\"active\", \"raised\"),\n                ],\n                \"background\": [(\"disabled\", frame), (\"pressed\", darker), (\"active\", lighter)],\n                \"lightcolor\": [(\"pressed\", darker)],\n                \"darkcolor\": [(\"pressed\", darker)],\n            },\n        },\n        \"TCheckbutton\": {\n            \"configure\": {\n                \"indicatorbackground\": \"#ffffff\",\n                \"indicatormargin\": [scale(1), scale(1), scale(6), scale(1)],\n                \"padding\": scale(2),\n            },\n            \"map\": {\n                \"indicatorbackground\": [\n                    (\"pressed\", frame),\n                    (\"!disabled\", \"alternate\", altindicator),\n                    (\"disabled\", \"alternate\", disabledaltindicator),\n                    (\"disabled\", frame),\n                ]\n            },\n        },\n        # TRadiobutton has same style as TCheckbutton\n        \"TRadiobutton\": {\n            \"configure\": {\n                \"indicatorbackground\": \"#ffffff\",\n                \"indicatormargin\": [scale(1), scale(1), scale(6), scale(1)],\n                \"padding\": scale(2),\n            },\n            \"map\": {\n                \"indicatorbackground\": [\n                    (\"pressed\", frame),\n                    (\"!disabled\", \"alternate\", altindicator),\n                    (\"disabled\", \"alternate\", disabledaltindicator),\n                    (\"disabled\", frame),\n                ]\n            },\n        },\n        \"TMenubutton\": {\"configure\": {\"width\": scale(11), \"padding\": scale(5), \"relief\": \"raised\"}},\n        \"TEntry\": {\n            \"configure\": {\"padding\": scale(1), \"insertwidth\": scale(1)},\n            \"map\": {\n                \"background\": [(\"readonly\", frame)],\n                \"bordercolor\": [(\"focus\", selectbg)],\n                \"lightcolor\": [(\"focus\", \"#6f9dc6\")],\n                \"darkcolor\": [(\"focus\", \"#6f9dc6\")],\n            },\n        },\n        \"TCombobox\": {\n            \"configure\": {\n                \"padding\": [scale(4), scale(2), scale(2), scale(2)],\n                \"insertwidth\": scale(1),\n            },\n            \"map\": {\n                \"background\": [(\"active\", lighter), (\"pressed\", lighter)],\n                \"fieldbackground\": [(\"readonly\", \"focus\", selectbg), (\"readonly\", frame)],\n                \"foreground\": [(\"readonly\", \"focus\", selectfg)],\n                \"arrowcolor\": [(\"disabled\", disabledfg)],\n            },\n        },\n        \"ComboboxPopdownFrame\": {\"configure\": {\"relief\": \"solid\", \"borderwidth\": scale(1)}},\n        \"TSpinbox\": {\n            \"configure\": {\"arrowsize\": scale(10), \"padding\": [scale(2), 0, scale(10), 0]},\n            \"map\": {\"background\": [(\"readonly\", frame)], \"arrowcolor\": [(\"disabled\", disabledfg)]},\n        },\n        \"TNotebook.Tab\": {\n            \"configure\": {\"padding\": [scale(6), scale(2), scale(6), scale(2)]},\n            \"map\": {\n                \"padding\": [(\"selected\", [scale(6), scale(4), scale(6), scale(4)])],\n                \"background\": [(\"selected\", frame), (\"\", darker)],\n                \"lightcolor\": [(\"selected\", lighter), (\"\", dark)],\n            },\n        },\n        \"Treeview\": {\n            \"configure\": {\"background\": window},\n            \"map\": {\n                \"background\": [\n                    (\"disabled\", frame),\n                    (\"!disabled\", \"!selected\", window),\n                    (\"selected\", selectbg),\n                ],\n                \"foreground\": [\n                    (\"disabled\", disabledfg),\n                    (\"!disabled\", \"!selected\", defaultfg),\n                    (\"selected\", selectfg),\n                ],\n            },\n        },\n        # Treeview heading\n        \"Heading\": {\n            \"configure\": {\n                \"font\": \"TkHeadingFont\",\n                \"relief\": \"raised\",\n                \"padding\": [scale(3), scale(3), scale(3), scale(3)],\n            }\n        },\n        \"TLabelframe\": {\"configure\": {\"labeloutside\": True, \"labelmargins\": [0, 0, 0, scale(4)]}},\n        \"TProgressbar\": {\"configure\": {\"background\": frame}},\n        \"Sash\": {\"configure\": {\"sashthickness\": ems_to_pixels(0.6), \"gripcount\": 10}},\n    }", "is_method": false, "function_description": "Function that defines and returns a comprehensive dictionary of theme settings for a Tkinter UI style named \"clam,\" providing standardized colors, layouts, and behaviors for various widget types."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "xpnative", "line_number": 312, "body": "def xpnative() -> BasicUiThemeSettings:\n    # Transcribed from https://github.com/tcltk/tk/blob/master/library/ttk/xpTheme.tcl\n    return {\n        \".\": {\n            \"configure\": {\n                \"background\": \"SystemButtonFace\",\n                \"foreground\": \"SystemWindowText\",\n                \"selectbackground\": \"SystemHighlight\",\n                \"selectforeground\": \"SystemHighlightText\",\n                \"font\": \"TkDefaultFont\",\n            },\n            \"map\": {\"foreground\": [(\"disabled\", \"SystemGrayText\")]},\n        },\n        \"TButton\": {\n            \"configure\": {\"anchor\": \"center\", \"width\": scale(11), \"padding\": [scale(1), scale(1)]}\n        },\n        \"Toolbutton\": {\"configure\": {\"padding\": [scale(4), scale(4)]}},\n        \"TCheckbutton\": {\"configure\": {\"padding\": scale(2)}},\n        # TRadiobutton has same style as TCheckbutton\n        \"TRadiobutton\": {\"configure\": {\"padding\": scale(2)}},\n        \"TMenubutton\": {\"configure\": {\"padding\": [scale(8), scale(4)]}},\n        \"TEntry\": {\n            \"configure\": {\"padding\": [scale(2), scale(2), scale(2), scale(4)]},\n            \"map\": {\n                \"selectbackground\": [(\"!focus\", \"SystemWindow\")],\n                \"selectforeground\": [(\"!focus\", \"SystemWindowText\")],\n            },\n        },\n        \"TCombobox\": {\n            \"configure\": {\"padding\": scale(2)},\n            \"map\": {\n                \"selectbackground\": [(\"!focus\", \"SystemWindow\")],\n                \"selectforeground\": [(\"!focus\", \"SystemWindowText\")],\n                \"foreground\": [\n                    (\"disabled\", \"SystemGrayText\"),\n                    (\"readonly\", \"focus\", \"SystemHighlightText\"),\n                ],\n                \"focusfill\": [(\"readonly\", \"focus\", \"SystemHighlight\")],\n            },\n        },\n        \"ComboboxPopdownFrame\": {\"configure\": {\"relief\": \"solid\", \"borderwidth\": scale(1)}},\n        \"TSpinbox\": {\n            \"configure\": {\"padding\": [scale(2), 0, scale(14), 0]},\n            \"map\": {\n                \"selectbackground\": [(\"!focus\", \"SystemWindow\")],\n                \"selectforeground\": [(\"!focus\", \"SystemWindowText\")],\n            },\n        },\n        \"TNotebook\": {\"configure\": {\"tabmargins\": [scale(2), scale(2), scale(2), 0]}},\n        \"TNotebook.Tab\": {\n            \"map\": {\"expand\": [(\"selected\", [scale(2), scale(2), scale(2), scale(2)])]}\n        },\n        \"Treeview\": {\n            \"configure\": {\"background\": \"SystemWindow\"},\n            \"map\": {\n                \"background\": [\n                    (\"disabled\", \"SystemButtonFace\"),\n                    (\"!disabled\", \"!selected\", \"SystemWindow\"),\n                    (\"selected\", \"SystemHighlight\"),\n                ],\n                \"foreground\": [\n                    (\"disabled\", \"SystemGrayText\"),\n                    (\"!disabled\", \"!selected\", \"SystemWindowText\"),\n                    (\"selected\", \"SystemHighlightText\"),\n                ],\n            },\n        },\n        \"Heading\": {\"configure\": {\"font\": \"TkHeadingFont\", \"relief\": \"raised\"}},  # Treeview heading\n        \"TLabelframe.Label\": {\"configure\": {\"foreground\": \"#0046d5\"}},\n    }", "is_method": false, "function_description": "Returns a predefined set of native Windows XP style UI theme settings for various Tkinter widgets, enabling consistent appearance configuration in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "aqua", "line_number": 384, "body": "def aqua() -> BasicUiThemeSettings:\n    # https://github.com/tcltk/tk/blob/master/library/ttk/aquaTheme.tcl\n    return {\n        \".\": {\n            \"configure\": {\n                \"font\": \"TkDefaultFont\",\n                \"background\": \"systemWindowBody\",\n                \"foreground\": \"systemModelessDialogActiveText\",\n                \"selectbackground\": \"systemHighlight\",\n                \"selectforeground\": \"systemModelessDialogActiveText\",\n                \"selectborderwidth\": 0,\n                \"insertwidth\": 1,\n                \"stipple\": \"\",\n            },\n            \"map\": {\n                \"foreground\": [\n                    (\"disabled\", \"systemModelessDialogInactiveText\"),\n                    (\"background\", \"systemModelessDialogInactiveText\"),\n                ],\n                \"selectbackground\": [\n                    (\"background\", \"systemHighlightSecondary\"),\n                    (\"!focus\", \"systemHighlightSecondary\"),\n                ],\n                \"selectforeground\": [\n                    (\"background\", \"systemModelessDialogInactiveText\"),\n                    (\"!focus\", \"systemDialogActiveText\"),\n                ],\n            },\n        },\n        \"TButton\": {\"configure\": {\"anchor\": \"center\", \"width\": \"6\"}},\n        \"Toolbutton\": {\"configure\": {\"padding\": 4}},\n        \"TNotebook\": {\n            \"configure\": {\"tabmargins\": [10, 0], \"tabposition\": \"n\", \"padding\": [18, 8, 18, 17]}\n        },\n        \"TNotebook.Tab\": {\"configure\": {\"padding\": [12, 3, 12, 2]}},\n        \"TCombobox\": {\"configure\": {\"postoffset\": [5, -2, -10, 0]}},\n        \"Heading\": {\"configure\": {\"font\": \"TkHeadingFont\"}},\n        \"Treeview\": {\n            \"configure\": {\"rowheight\": 18, \"background\": \"white\"},\n            \"map\": {\n                \"background\": [\n                    (\"disabled\", \"systemDialogBackgroundInactive\"),\n                    (\"!disabled\", \"!selected\", \"systemWindowBody\"),\n                    (\"selected\", \"background\", \"systemHighlightSecondary\"),\n                    (\"selected\", \"systemHighlight\"),\n                ],\n                \"foreground\": [\n                    (\"disabled\", \"systemModelessDialogInactiveText\"),\n                    (\"!disabled\", \"!selected\", \"black\"),\n                    (\"selected\", \"systemModelessDialogActiveText\"),\n                ],\n            },\n        },\n        \"TProgressbar\": {\"configure\": {\"period\": 100, \"maxphase\": 255}},\n        \"Labelframe\": {\"configure\": {\"labeloutside\": True, \"labelmargins\": [14, 0, 14, 4]}},\n    }", "is_method": false, "function_description": "Provides a predefined theme configuration dictionary for UI elements, specifying fonts, colors, and layout settings consistent with the Aqua style for use in Tkinter or ttk-based interfaces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "windows", "line_number": 442, "body": "def windows() -> CompoundUiThemeSettings:\n    tip_background = \"#bbbbbb\"\n    return [\n        xpnative(),\n        _treeview_settings(),\n        _menubutton_settings(),\n        _paned_window_settings(),\n        _menu_settings(),\n        _text_settings(),\n        _link_settings(),\n        _button_notebook_settings(),\n        {\n            \"Tip.TLabel\": {\"configure\": {\"background\": tip_background, \"foreground\": \"black\"}},\n            \"Tip.TFrame\": {\"configure\": {\"background\": tip_background}},\n        },\n        {\n            \"TNotebook\": {\n                \"configure\": {\n                    # With tabmargins I can get a gray line below tab, which separates\n                    # tab content from label\n                    \"tabmargins\": [scale(2), scale(2), scale(2), scale(2)]\n                }\n            },\n            \"Tab\": {\"configure\": {\"padding\": [scale(3), scale(1), scale(3), 0]}},\n            \"ButtonNotebook.TNotebook.Tab\": {\n                \"configure\": {\"padding\": (scale(4), scale(1), scale(1), 0)}\n            },\n            \"TCombobox\": {\n                \"map\": {\n                    \"selectbackground\": [\n                        (\"readonly\", \"!focus\", \"SystemWindow\"),\n                        (\"readonly\", \"focus\", \"SystemHighlight\"),\n                    ],\n                    \"selectforeground\": [\n                        (\"readonly\", \"!focus\", \"SystemWindowText\"),\n                        (\"readonly\", \"focus\", \"SystemHighlightText\"),\n                    ],\n                }\n            },\n            \"Listbox\": {\n                \"configure\": {\n                    \"background\": \"SystemWindow\",\n                    \"foreground\": \"SystemWindowText\",\n                    \"disabledforeground\": \"SystemGrayText\",\n                    \"highlightbackground\": \"SystemActiveBorder\",\n                    \"highlightcolor\": \"SystemActiveBorder\",\n                    \"highlightthickness\": scale(1),\n                }\n            },\n            \"ViewBody.TFrame\": {\n                \"configure\": {\n                    \"background\": \"SystemButtonFace\"  # to create the fine line below toolbar\n                }\n            },\n            \"ViewToolbar.TFrame\": {\"configure\": {\"background\": \"SystemWindow\"}},\n            \"ViewToolbar.Toolbutton\": {\"configure\": {\"background\": \"SystemWindow\"}},\n            \"ViewTab.TLabel\": {\n                \"configure\": {\"background\": \"SystemWindow\", \"padding\": [scale(5), 0]}\n            },\n            \"ViewToolbar.TLabel\": {\n                \"configure\": {\"background\": \"SystemWindow\", \"padding\": [scale(5), 0]}\n            },\n            \"ViewToolbar.Link.TLabel\": {\n                \"configure\": {\"background\": \"SystemWindow\", \"padding\": [scale(5), 0]}\n            },\n            \"Active.ViewTab.TLabel\": {\n                \"configure\": {\n                    # \"font\" : \"BoldTkDefaultFont\",\n                    \"relief\": \"sunken\",\n                    \"borderwidth\": scale(1),\n                }\n            },\n            \"Inactive.ViewTab.TLabel\": {\"map\": {\"relief\": [(\"hover\", \"raised\")]}},\n        },\n    ]", "is_method": false, "function_description": "Function that defines and returns a compound UI theme configuration combining multiple widget style settings and customizations for a Windows-like appearance. It provides consistent styling for GUI components in applications using this theme."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "enhanced_clam", "line_number": 519, "body": "def enhanced_clam() -> CompoundUiThemeSettings:\n    tip_background = \"#bab5ab\"\n    return [\n        clam(),\n        _treeview_settings(),\n        _menubutton_settings(),\n        _paned_window_settings(),\n        _menu_settings(),\n        _text_settings(),\n        _link_settings(),\n        {\n            \"Tip.TLabel\": {\"configure\": {\"background\": tip_background, \"foreground\": \"black\"}},\n            \"Tip.TFrame\": {\"configure\": {\"background\": tip_background}},\n        },\n        _button_notebook_settings(),\n        {\n            \"ButtonNotebook.Tab\": {\n                \"configure\": {\"padding\": (scale(6), scale(4), scale(2), scale(3))}\n            },\n            \"TScrollbar\": {\n                \"configure\": {\n                    \"gripcount\": 0,\n                    \"arrowsize\": scale(14),\n                    # \"arrowcolor\" : \"DarkGray\"\n                    # \"width\" : 99 # no effect\n                }\n            },\n            \"TCombobox\": {\n                \"configure\": {\"arrowsize\": scale(14)},\n                \"map\": {\n                    \"selectbackground\": [(\"readonly\", \"!focus\", \"#dcdad5\")],\n                    \"selectforeground\": [(\"readonly\", \"!focus\", \"#000000\")],\n                },\n            },\n            \"TCheckbutton\": {\"configure\": {\"indicatorsize\": scale(12)}},\n            \"TRadiobutton\": {\"configure\": {\"indicatorsize\": scale(12)}},\n            \"Listbox\": {\n                \"configure\": {\n                    \"background\": \"white\",\n                    \"foreground\": \"black\",\n                    \"disabledforeground\": \"#999999\",\n                    \"highlightbackground\": \"#4a6984\",\n                    \"highlightcolor\": \"#4a6984\",\n                    \"highlightthickness\": scale(1),\n                }\n            },\n            \"ViewTab.TLabel\": {\"configure\": {\"padding\": [scale(5), 0]}},\n            \"Active.ViewTab.TLabel\": {\n                \"configure\": {\n                    # \"font\" : \"BoldTkDefaultFont\",\n                    \"relief\": \"sunken\",\n                    \"borderwidth\": scale(1),\n                }\n            },\n            \"Inactive.ViewTab.TLabel\": {\"map\": {\"relief\": [(\"hover\", \"raised\")]}},\n        },\n    ]", "is_method": false, "function_description": "Function that compiles and returns a comprehensive set of customized UI theme settings by combining default clam theme with multiple specific widget style configurations for enhanced visual consistency and usability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "enhanced_aqua", "line_number": 578, "body": "def enhanced_aqua() -> CompoundUiThemeSettings:\n    return [\n        _treeview_settings(),\n        _menubutton_settings(),\n        # _paned_window_settings(),\n        _menu_settings(),\n        {\n            \"TPanedWindow\": {\"configure\": {\"background\": \"systemDialogBackgroundActive\"}},\n            \"TFrame\": {\"configure\": {\"background\": \"systemDialogBackgroundActive\"}},\n            \"Tab\": {\"map\": {\"foreground\": [(\"selected\", \"white\")]}},\n            \"ViewTab.TLabel\": {\"configure\": {\"padding\": [scale(5), 0]}},\n            \"Active.ViewTab.TLabel\": {\n                \"configure\": {\n                    # \"font\" : \"BoldTkDefaultFont\",\n                    \"relief\": \"sunken\",\n                    \"borderwidth\": scale(1),\n                }\n            },\n            \"Inactive.ViewTab.TLabel\": {\"map\": {\"relief\": [(\"hover\", \"raised\")]}},\n        },\n    ]", "is_method": false, "function_description": "This function provides a customized set of UI theme settings combining predefined component styles and additional appearance configurations, enabling consistent and enhanced visual theming for user interface elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "load_plugin", "line_number": 601, "body": "def load_plugin() -> None:\n    from tkinter import ttk\n\n    original_themes = ttk.Style().theme_names()\n\n    # load all base themes\n    for name in original_themes:\n        settings = {}  # type: Union[Dict, Callable[[], Dict]]\n        if name == \"clam\":\n            settings = clam\n        elif name == \"xpnative\":\n            settings = xpnative\n        elif name == \"aqua\":\n            settings = aqua\n\n        get_workbench().add_ui_theme(name, None, settings)\n\n    get_workbench().add_ui_theme(\n        \"Enhanced Clam\",\n        \"clam\",\n        enhanced_clam,\n        {\"tab-close\": \"tab-close-clam\", \"tab-close-active\": \"tab-close-active-clam\"},\n    )\n\n    if \"xpnative\" in original_themes:\n        get_workbench().add_ui_theme(\"Windows\", \"xpnative\", windows)\n\n    if \"aqua\" in original_themes:\n        get_workbench().add_ui_theme(\"Kind of Aqua\", \"aqua\", enhanced_aqua)", "is_method": false, "function_description": "Function that loads and registers various UI themes, including enhanced and platform-specific variants, into the workbench environment for use in the application's interface customization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_config_page.py", "function": "load_plugin", "line_number": 72, "body": "def load_plugin() -> None:\n    get_workbench().add_configuration_page(\"shell\", tr(\"Shell\"), ShellConfigurationPage, 70)", "is_method": false, "function_description": "Adds a shell configuration page to the workbench interface, enabling users to customize shell-related settings within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/dock_user_windows_frontend.py", "function": "toggle_variable", "line_number": 9, "body": "def toggle_variable():\n    var = get_workbench().get_variable(_OPTION_NAME)\n    var.set(not var.get())\n    update_environment()", "is_method": false, "function_description": "Toggles a boolean variable identified by a predefined name within the workbench environment and updates the environment accordingly. This function is useful for enabling or disabling features or settings dynamically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/dock_user_windows_frontend.py", "function": "update_environment", "line_number": 15, "body": "def update_environment():\n    os.environ[\"DOCK_USER_WINDOWS\"] = str(get_workbench().get_option(_OPTION_NAME))", "is_method": false, "function_description": "Sets an environment variable based on a configuration option from the workbench, enabling other parts of the application to access updated user-related settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/dock_user_windows_frontend.py", "function": "load_plugin", "line_number": 23, "body": "def load_plugin():\n    get_workbench().set_default(_OPTION_NAME, False)\n    get_workbench().add_command(\n        \"toggle_dock_user_windows\",\n        \"run\",\n        tr(\"Dock user windows\"),\n        toggle_variable,\n        flag_name=_OPTION_NAME,\n        group=40,\n    )\n    update_environment()\n\n    get_workbench().bind(\"UserWindowAppeared\", on_window_appear, True)", "is_method": false, "function_description": "Initializes a plugin by configuring docking options, registering toggle commands, updating the environment, and binding event handlers for user window management in the workbench interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/assistant_config_page.py", "function": "load_plugin", "line_number": 72, "body": "def load_plugin():\n    get_workbench().add_configuration_page(\"assistant\", tr(\"Assistant\"), AssistantConfigPage, 80)", "is_method": false, "function_description": "Adds an assistant configuration page to the workbench interface, enabling users to customize assistant-related settings within the application environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/assistant_config_page.py", "function": "apply", "line_number": 61, "body": "def apply(self):\n        disabled_checks_str = (\n            self.disabled_checks_box.text.get(\"1.0\", \"end\")\n            .replace(\"\\r\", \"\")\n            .replace('\"', \"\")\n            .replace(\"'\", \"\")\n            .strip()\n        )\n        get_workbench().set_option(\"assistance.disabled_checks\", disabled_checks_str.splitlines())", "is_method": true, "class_name": "AssistantConfigPage", "function_description": "Updates the application configuration to disable specified checks by extracting and applying user-inputted check identifiers from the UI to the system settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_find_closest_containing_node", "line_number": 151, "body": "def _find_closest_containing_node(tree, text_range):\n    # first look among children\n    for child in ast.iter_child_nodes(tree):\n        result = _find_closest_containing_node(child, text_range)\n        if result is not None:\n            return result\n\n    # no suitable child was found\n    if hasattr(tree, \"lineno\") and range_contains_smaller(\n        TextRange(tree.lineno, tree.col_offset, tree.end_lineno, tree.end_col_offset), text_range\n    ):\n        return tree\n    # nope\n    else:\n        return None", "is_method": false, "function_description": "Helper function that recursively finds the AST node that most closely contains a specified text range, aiding in pinpointing relevant code segments within a syntax tree."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "pretty", "line_number": 168, "body": "def pretty(node, key=\"/\", level=0):\n    \"\"\"Used for exporting ASTView content\"\"\"\n    if isinstance(node, ast.AST):\n        fields = list(ast.iter_fields(node))\n        value_label = node.__class__.__name__\n        if isinstance(node, ast.Call):\n            # Try to make 3.4 AST-s more similar to 3.5\n            if sys.version_info[:2] == (3, 4):\n                if (\"kwargs\", None) in fields:\n                    fields.remove((\"kwargs\", None))\n                if (\"starargs\", None) in fields:\n                    fields.remove((\"starargs\", None))\n\n            # TODO: translate also non-None kwargs and starargs\n\n    elif isinstance(node, list):\n        fields = list(enumerate(node))\n        if len(node) == 0:\n            value_label = \"[]\"\n        else:\n            value_label = \"[...]\"\n    else:\n        fields = []\n        value_label = repr(node)\n\n    item_text = level * \"    \" + str(key) + \"=\" + value_label\n\n    if hasattr(node, \"lineno\"):\n        item_text += \" @ \" + str(getattr(node, \"lineno\"))\n        if hasattr(node, \"col_offset\"):\n            item_text += \".\" + str(getattr(node, \"col_offset\"))\n\n        if hasattr(node, \"end_lineno\"):\n            item_text += \"  -  \" + str(getattr(node, \"end_lineno\"))\n            if hasattr(node, \"end_col_offset\"):\n                item_text += \".\" + str(getattr(node, \"end_col_offset\"))\n\n    lines = [item_text] + [\n        pretty(field_value, field_key, level + 1) for field_key, field_value in fields\n    ]\n\n    return \"\\n\".join(lines)", "is_method": false, "function_description": "Function that formats and returns a readable, indented string representation of an AST (Abstract Syntax Tree) node, including position metadata. It aids in visualizing and exporting AST structures for debugging or analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "load_plugin", "line_number": 212, "body": "def load_plugin() -> None:\n    get_workbench().add_view(AstView, tr(\"Program tree\"), \"s\")", "is_method": false, "function_description": "Adds a program tree view to the workbench interface for visualizing the abstract syntax tree (AST) of code. This enhances the user interface with a structured code representation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_update", "line_number": 49, "body": "def _update(self, event):\n        if not self.winfo_ismapped():\n            return\n\n        editor = get_workbench().get_editor_notebook().get_current_editor()\n\n        if not editor:\n            self._current_code_view = None\n            return\n\n        new_cw = editor.get_code_view()\n        new_source = new_cw.get_content_as_bytes()\n        if self._current_code_view == new_cw and self._current_source == new_source:\n            return\n\n        self._current_code_view = new_cw\n        self._current_source = new_source\n        selection = self._current_code_view.get_selected_range()\n\n        self._clear_tree()\n\n        if not self._current_source.strip():\n            return\n\n        try:\n            root = ast_utils.parse_source(self._current_source, fallback_to_one_char=True)\n            selected_ast_node = _find_closest_containing_node(root, selection)\n\n        except Exception as e:\n            self.tree.insert(\"\", \"end\", text=str(e), open=True)\n            logger.exception(\"Could not select AST node\", exc_info=e)\n            return\n\n        def _format(key, node, parent_id):\n\n            if isinstance(node, ast.AST):\n                fields = list(ast.iter_fields(node))\n\n                value_label = node.__class__.__name__\n\n            elif isinstance(node, list):\n                fields = list(enumerate(node))\n                if len(node) == 0:\n                    value_label = \"[]\"\n                else:\n                    value_label = \"[...]\"\n            else:\n                fields = []\n                value_label = repr(node)\n\n            item_text = str(key) + \"=\" + value_label\n            node_id = self.tree.insert(parent_id, \"end\", text=item_text, open=True)\n            if node == selected_ast_node:\n                self.tree.see(node_id)\n                self.tree.selection_add(node_id)\n\n            if hasattr(node, \"lineno\") and hasattr(node, \"col_offset\"):\n                self.tree.set(node_id, \"lineno\", node.lineno)\n                self.tree.set(node_id, \"col_offset\", node.col_offset)\n\n                range_str = str(node.lineno) + \".\" + str(node.col_offset)\n                if hasattr(node, \"end_lineno\") and hasattr(node, \"end_col_offset\"):\n                    self.tree.set(node_id, \"end_lineno\", node.end_lineno)\n                    self.tree.set(node_id, \"end_col_offset\", node.end_col_offset)\n                    range_str += \"  -  \" + str(node.end_lineno) + \".\" + str(node.end_col_offset)\n                else:\n                    # fallback\n                    self.tree.set(node_id, \"end_lineno\", node.lineno)\n                    self.tree.set(node_id, \"end_col_offset\", node.col_offset + 1)\n\n                self.tree.set(node_id, \"range\", range_str)\n\n            for field_key, field_value in fields:\n                _format(field_key, field_value, node_id)\n\n        _format(\"root\", root, \"\")", "is_method": true, "class_name": "AstView", "function_description": "Core method of the AstView class that updates the displayed abstract syntax tree to reflect the current code editor's content and selection, providing real-time visualization and navigation of Python source structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_locate_code", "line_number": 126, "body": "def _locate_code(self, event):\n        if self._current_code_view is None:\n            return\n\n        iid = self.tree.focus()\n\n        if iid != \"\":\n            values = self.tree.item(iid)[\"values\"]\n            if isinstance(values, list) and len(values) >= 5:\n                start_line, start_col, end_line, end_col = values[1:5]\n                self._current_code_view.select_range(\n                    TextRange(start_line, start_col, end_line, end_col)\n                )", "is_method": true, "class_name": "AstView", "function_description": "Internal method of AstView that highlights a specific code segment based on the current tree selection, enabling focused code navigation within the active code view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_clear_tree", "line_number": 140, "body": "def _clear_tree(self):\n        for child_id in self.tree.get_children():\n            self.tree.delete(child_id)", "is_method": true, "class_name": "AstView", "function_description": "Clears all nodes from the AstView's tree structure, resetting its displayed content. Useful for refreshing or reloading the tree view to show updated data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_copy_to_clipboard", "line_number": 144, "body": "def _copy_to_clipboard(self, event):\n        self.clipboard_clear()\n        if self._current_source is not None:\n            pretty_ast = pretty(ast_utils.parse_source(self._current_source))\n            self.clipboard_append(pretty_ast)", "is_method": true, "class_name": "AstView", "function_description": "Utility method in AstView that copies a formatted abstract syntax tree of the current source code to the clipboard for easy sharing or further use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_format", "line_number": 82, "body": "def _format(key, node, parent_id):\n\n            if isinstance(node, ast.AST):\n                fields = list(ast.iter_fields(node))\n\n                value_label = node.__class__.__name__\n\n            elif isinstance(node, list):\n                fields = list(enumerate(node))\n                if len(node) == 0:\n                    value_label = \"[]\"\n                else:\n                    value_label = \"[...]\"\n            else:\n                fields = []\n                value_label = repr(node)\n\n            item_text = str(key) + \"=\" + value_label\n            node_id = self.tree.insert(parent_id, \"end\", text=item_text, open=True)\n            if node == selected_ast_node:\n                self.tree.see(node_id)\n                self.tree.selection_add(node_id)\n\n            if hasattr(node, \"lineno\") and hasattr(node, \"col_offset\"):\n                self.tree.set(node_id, \"lineno\", node.lineno)\n                self.tree.set(node_id, \"col_offset\", node.col_offset)\n\n                range_str = str(node.lineno) + \".\" + str(node.col_offset)\n                if hasattr(node, \"end_lineno\") and hasattr(node, \"end_col_offset\"):\n                    self.tree.set(node_id, \"end_lineno\", node.end_lineno)\n                    self.tree.set(node_id, \"end_col_offset\", node.end_col_offset)\n                    range_str += \"  -  \" + str(node.end_lineno) + \".\" + str(node.end_col_offset)\n                else:\n                    # fallback\n                    self.tree.set(node_id, \"end_lineno\", node.lineno)\n                    self.tree.set(node_id, \"end_col_offset\", node.col_offset + 1)\n\n                self.tree.set(node_id, \"range\", range_str)\n\n            for field_key, field_value in fields:\n                _format(field_key, field_value, node_id)", "is_method": true, "class_name": "AstView", "function_description": "Private recursive helper method in AstView that formats and inserts AST nodes and their fields into a tree view widget, including location metadata for visual representation of code structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/run_debug_config_page.py", "function": "load_plugin", "line_number": 73, "body": "def load_plugin():\n    get_workbench().add_configuration_page(\"run\", tr(\"Run & Debug\"), RunDebugConfigurationPage, 50)", "is_method": false, "function_description": "Adds a \"Run & Debug\" configuration page to the workbench interface for plugin customization and development purposes. This function enhances the workbench by integrating debugging configuration support."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "handle_autocomplete_request", "line_number": 289, "body": "def handle_autocomplete_request(event=None):\n    if event is None:\n        text = get_workbench().focus_get()\n    else:\n        text = event.widget\n\n    _handle_autocomplete_request_for_text(text)", "is_method": false, "function_description": "Calls the internal autocomplete handler on text from a GUI event or the current focused widget, enabling contextual autocomplete functionality in interactive applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_handle_autocomplete_request_for_text", "line_number": 298, "body": "def _handle_autocomplete_request_for_text(text):\n    if not hasattr(text, \"autocompleter\"):\n        if isinstance(text, (CodeViewText, ShellText)) and text.is_python_text():\n            if isinstance(text, CodeViewText):\n                text.autocompleter = Completer(text)\n            elif isinstance(text, ShellText):\n                text.autocompleter = ShellCompleter(text)\n            text.bind(\"<1>\", text.autocompleter.on_text_click)\n        else:\n            return\n\n    text.autocompleter.handle_autocomplete_request()", "is_method": false, "function_description": "Handles autocomplete requests for Python code or shell text, initializing and invoking the appropriate autocompleter to provide context-sensitive code completions in supported text views."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "patched_perform_midline_tab", "line_number": 312, "body": "def patched_perform_midline_tab(text, event):\n    if text.is_python_text():\n        if isinstance(text, ShellText):\n            option_name = \"edit.tab_complete_in_shell\"\n        else:\n            option_name = \"edit.tab_complete_in_editor\"\n\n        if get_workbench().get_option(option_name):\n            if not text.has_selection():\n                _handle_autocomplete_request_for_text(text)\n                return \"break\"\n            else:\n                return None\n\n    return text.perform_dumb_tab(event)", "is_method": false, "function_description": "Function that handles tab key completion differently based on text context and user preferences, enabling autocomplete in shell or editor when no text is selected; otherwise, it falls back to default tab behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "load_plugin", "line_number": 329, "body": "def load_plugin() -> None:\n\n    get_workbench().add_command(\n        \"autocomplete\",\n        \"edit\",\n        tr(\"Auto-complete\"),\n        handle_autocomplete_request,\n        default_sequence=\"<Control-space>\"\n        # TODO: tester\n    )\n\n    get_workbench().set_default(\"edit.tab_complete_in_editor\", True)\n    get_workbench().set_default(\"edit.tab_complete_in_shell\", True)\n\n    CodeViewText.perform_midline_tab = patched_perform_midline_tab  # type: ignore\n    ShellText.perform_midline_tab = patched_perform_midline_tab", "is_method": false, "function_description": "Registers and configures autocomplete commands and behavior in the workbench environment, enabling improved code editing and shell interaction with tab completion support."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_bind_result_event", "line_number": 45, "body": "def _bind_result_event(self):\n        # TODO: remove binding when editor gets closed\n        get_workbench().bind(\"editor_autocomplete_response\", self._handle_backend_response, True)", "is_method": true, "class_name": "Completer", "function_description": "Binds a handler to process autocomplete responses from the backend, enabling the Completer to react to editor autocomplete events during its lifecycle."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "handle_autocomplete_request", "line_number": 49, "body": "def handle_autocomplete_request(self):\n        row, column = self._get_position()\n        source = self.text.get(\"1.0\", \"end-1c\")\n        get_runner().send_command(\n            InlineCommand(\n                \"editor_autocomplete\",\n                source=source,\n                row=row,\n                column=column,\n                filename=self._get_filename(),\n            )\n        )", "is_method": true, "class_name": "Completer", "function_description": "Service method of the Completer class that triggers an autocomplete command by sending the current editor text and cursor position for processing. It enables integration with an autocomplete system based on the editor state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_handle_backend_response", "line_number": 62, "body": "def _handle_backend_response(self, msg):\n        row, column = self._get_position()\n        source = self.text.get(\"1.0\", \"end-1c\")\n\n        if msg.source != source or msg.row != row or msg.column != column:\n            # situation has changed, information is obsolete\n            self._close()\n        elif msg.get(\"error\"):\n            self._close()\n            messagebox.showerror(\"Autocomplete error\", msg.error, master=self)\n        else:\n            self._present_completions(msg.completions)", "is_method": true, "class_name": "Completer", "function_description": "Handles and validates backend autocomplete responses, ensuring relevance by matching the current text position and content; it either updates suggestions, closes obsolete results, or shows errors accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_present_completions", "line_number": 75, "body": "def _present_completions(self, completions_):\n        # Check if autocompeted name starts with an underscore,\n        # if it doesn't - don't show names starting with '_'\n        source = self.text.get(\"insert linestart\", tk.INSERT)\n        try:\n            current_source_chunk = re.split(r\"\\W\", source)[-1]\n        except IndexError:\n            current_source_chunk = \"\"\n\n        if current_source_chunk.startswith(\"_\"):\n            completions = completions_\n        else:\n            completions = [c for c in completions_ if not c.get(\"name\", \"_\").startswith(\"_\")]\n\n        self.completions = completions\n\n        # broadcast logging info\n        row, column = self._get_position()\n        get_workbench().event_generate(\n            \"AutocompleteProposal\",\n            text_widget=self.text,\n            row=row,\n            column=column,\n            proposal_count=len(completions),\n        )\n\n        # present\n        if len(completions) == 0:\n            self._close()\n        elif len(completions) == 1:\n            self._insert_completion(completions[0])  # insert the only completion\n            self._close()\n        else:\n            self._show_box(completions)", "is_method": true, "class_name": "Completer", "function_description": "Handles and displays code completion suggestions based on the current typing context, filtering out names starting with underscores unless explicitly typed. It manages showing, inserting, or closing the completion interface accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_show_box", "line_number": 110, "body": "def _show_box(self, completions):\n        self.delete(0, self.size())\n        self.insert(0, *[c[\"name\"] for c in completions])\n        self.activate(0)\n        self.selection_set(0)\n\n        # place box\n        if not self._is_visible():\n\n            # _, _, _, list_box_height = self.bbox(0)\n            height = 100  # min(150, list_box_height * len(completions) * 1.15)\n            typed_name_length = len(completions[0][\"name\"]) - len(completions[0][\"complete\"])\n            text_box_x, text_box_y, _, text_box_height = self.text.bbox(\n                \"insert-%dc\" % typed_name_length\n            )\n\n            # should the box appear below or above cursor?\n            space_below = self.master.winfo_height() - text_box_y - text_box_height\n            space_above = text_box_y\n\n            if space_below >= height or space_below > space_above:\n                height = min(height, space_below)\n                y = text_box_y + text_box_height\n            else:\n                height = min(height, space_above)\n                y = text_box_y - height\n\n            width = 400\n            self.place(x=text_box_x, y=y, width=width, height=height)\n\n            self._update_doc()", "is_method": true, "class_name": "Completer", "function_description": "Displays and positions a completion suggestion box based on available completions, adjusting its size and placement dynamically relative to the cursor for optimal visibility. It updates the UI to show possible completions in the Completer component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_update_doc", "line_number": 142, "body": "def _update_doc(self):\n        c = self._get_selected_completion()\n\n        if c is None:\n            self.doc_label[\"text\"] = \"\"\n            self.doc_label.place_forget()\n        else:\n            docstring = c.get(\"docstring\", None)\n            if docstring:\n                self.doc_label[\"text\"] = docstring\n                self.doc_label.place(\n                    x=self.winfo_x() + self.winfo_width(),\n                    y=self.winfo_y(),\n                    width=400,\n                    height=self.winfo_height(),\n                )\n            else:\n                self.doc_label[\"text\"] = \"\"\n                self.doc_label.place_forget()", "is_method": true, "class_name": "Completer", "function_description": "Updates the user interface to display the docstring of the currently selected completion, showing or hiding the docstring label accordingly to provide contextual help during code completion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_is_visible", "line_number": 162, "body": "def _is_visible(self):\n        return self.winfo_ismapped()", "is_method": true, "class_name": "Completer", "function_description": "Private method of the Completer class that checks if the widget is currently visible on the screen, supporting UI state management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_insert_completion", "line_number": 165, "body": "def _insert_completion(self, completion):\n        typed_len = len(completion[\"name\"]) - len(completion[\"complete\"])\n        typed_prefix = self.text.get(\"insert-{}c\".format(typed_len), \"insert\")\n        get_workbench().event_generate(\n            \"AutocompleteInsertion\",\n            text_widget=self.text,\n            typed_prefix=typed_prefix,\n            completed_name=completion[\"name\"],\n        )\n\n        if self._is_visible():\n            self._close()\n\n        if not completion[\"name\"].startswith(typed_prefix):\n            # eg. case of the prefix was not correct\n            self.text.delete(\"insert-{}c\".format(typed_len), \"insert\")\n            self.text.insert(\"insert\", completion[\"name\"])\n        else:\n            self.text.insert(\"insert\", completion[\"complete\"])", "is_method": true, "class_name": "Completer", "function_description": "Handles inserting a selected autocomplete completion into a text widget, managing prefix matching and updating the UI accordingly. It supports text completion features within the Completer class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_get_filename", "line_number": 185, "body": "def _get_filename(self):\n        # TODO: allow completing in shell\n        if not isinstance(self.text, CodeViewText):\n            return None\n\n        codeview = self.text.master\n\n        editor = get_workbench().get_editor_notebook().get_current_editor()\n        if editor.get_code_view() is codeview:\n            return editor.get_filename()\n        else:\n            return None", "is_method": true, "class_name": "Completer", "function_description": "Returns the filename of the currently active editor if its code view matches the completer's text context; otherwise, returns None. This helps link completion suggestions to the relevant source file in the editor environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_move_selection", "line_number": 198, "body": "def _move_selection(self, delta):\n        selected = self.curselection()\n        if len(selected) == 0:\n            index = 0\n        else:\n            index = selected[0]\n\n        index += delta\n        index = max(0, min(self.size() - 1, index))\n\n        self.selection_clear(0, self.size() - 1)\n        self.selection_set(index)\n        self.activate(index)\n        self.see(index)\n        self._update_doc()", "is_method": true, "class_name": "Completer", "function_description": "Internal method of the Completer class that changes the current selection by an offset, ensuring the selection stays within bounds and updates the UI accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_get_request_id", "line_number": 214, "body": "def _get_request_id(self):\n        return \"autocomplete_\" + str(self.text.winfo_id())", "is_method": true, "class_name": "Completer", "function_description": "Private method of the Completer class that generates a unique request identifier for autocomplete operations based on the associated text widget's ID. It helps distinguish individual autocomplete requests within the UI context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_get_position", "line_number": 217, "body": "def _get_position(self):\n        return map(int, self.text.index(\"insert\").split(\".\"))", "is_method": true, "class_name": "Completer", "function_description": "Private method in Completer that returns the cursor position within the text as a tuple of integers, useful for tracking or manipulating the insertion point during text completion operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_on_text_keypress", "line_number": 220, "body": "def _on_text_keypress(self, event=None):\n        if not self._is_visible():\n            return None\n\n        if event.keysym == \"Escape\":\n            self._close()\n            return \"break\"\n        elif event.keysym in [\"Up\", \"KP_Up\"]:\n            self._move_selection(-1)\n            return \"break\"\n        elif event.keysym in [\"Down\", \"KP_Down\"]:\n            self._move_selection(1)\n            return \"break\"\n        elif event.keysym in [\"Return\", \"KP_Enter\", \"Tab\"]:\n            assert self.size() > 0\n            self._insert_current_selection()\n            return \"break\"\n\n        return None", "is_method": true, "class_name": "Completer", "function_description": "Handles keypress events in the Completer interface to navigate, select, or close the completion menu based on specific keys. Enables intuitive keyboard interaction with the autocomplete suggestions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_insert_current_selection", "line_number": 240, "body": "def _insert_current_selection(self, event=None):\n        self._insert_completion(self._get_selected_completion())", "is_method": true, "class_name": "Completer", "function_description": "Private method of the Completer class that inserts the currently selected completion into the input. It facilitates finalizing user selections during autocomplete interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_get_selected_completion", "line_number": 243, "body": "def _get_selected_completion(self):\n        sel = self.curselection()\n        if len(sel) != 1:\n            return None\n\n        return self.completions[sel[0]]", "is_method": true, "class_name": "Completer", "function_description": "Returns the currently selected completion item if exactly one is selected; otherwise, returns None. Useful for retrieving the user's choice in autocompletion interfaces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_on_text_change", "line_number": 250, "body": "def _on_text_change(self, event=None):\n        if self._is_visible():\n            self.handle_autocomplete_request()", "is_method": true, "class_name": "Completer", "function_description": "Private method of the Completer class that triggers an autocomplete request when the associated text is changed and the completer is visible. It supports interactive text input with real-time suggestions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_close", "line_number": 254, "body": "def _close(self, event=None):\n        self.place_forget()\n        self.doc_label.place_forget()\n        self.text.focus_set()", "is_method": true, "class_name": "Completer", "function_description": "Utility method of the Completer class that hides suggestion elements and returns focus to the main text input, managing the user interface during text completion interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "on_text_click", "line_number": 259, "body": "def on_text_click(self, event=None):\n        if self._is_visible():\n            self._close()", "is_method": true, "class_name": "Completer", "function_description": "Handles user clicks on the completion text by closing the completion menu if it is currently visible, managing the interface interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_bind_result_event", "line_number": 265, "body": "def _bind_result_event(self):\n        # TODO: remove binding when editor gets closed\n        get_workbench().bind(\"shell_autocomplete_response\", self._handle_backend_response, True)", "is_method": true, "class_name": "ShellCompleter", "function_description": "Binds a handler method to the shell autocomplete response event, enabling the ShellCompleter to process backend autocomplete suggestions during interactive shell usage."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "handle_autocomplete_request", "line_number": 269, "body": "def handle_autocomplete_request(self):\n        source = self._get_prefix()\n\n        get_runner().send_command(InlineCommand(\"shell_autocomplete\", source=source))", "is_method": true, "class_name": "ShellCompleter", "function_description": "Handles shell autocomplete requests by capturing the current input prefix and sending it as a command for generating autocomplete suggestions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_handle_backend_response", "line_number": 274, "body": "def _handle_backend_response(self, msg):\n        if hasattr(msg, \"source\"):\n            # check if the response is relevant for current state\n            if msg.source != self._get_prefix():\n                self._close()\n            elif msg.get(\"error\"):\n                self._close()\n                messagebox.showerror(\"Autocomplete error\", msg.error, master=self)\n            else:\n                self._present_completions(msg.completions)", "is_method": true, "class_name": "ShellCompleter", "function_description": "Handles backend autocomplete responses by validating source identity and errors, then presents completion suggestions or closes the completer upon issues. It ensures only relevant and error-free results update the shell completion UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_get_prefix", "line_number": 285, "body": "def _get_prefix(self):\n        return self.text.get(\"input_start\", \"insert\")", "is_method": true, "class_name": "ShellCompleter", "function_description": "Returns the starting position indicator of the current input text for command completion. This helps determine where the shell completion should begin based on the input context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "tomorrow", "line_number": 5, "body": "def tomorrow() -> SyntaxThemeSettings:\n    # https://github.com/chriskempson/tomorrow-theme/blob/master/GEdit/Tomorrow.xml\n    normal_fg = \"#4D4D4C\"\n    string_fg = \"#718C00\"\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#FFFFFF\"},\n        \"GUTTER\": {\"foreground\": \"#4d4d4c\", \"background\": \"#efefef\"},\n        \"current_line\": {\"background\": \"#efefef\"},\n        \"sel\": {\"foreground\": \"#4D4D4C\", \"background\": \"#D6D6D6\"},\n        \"number\": {\"foreground\": \"#718c00\"},\n        \"definition\": {\"foreground\": \"#4271AE\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string_fg},\n        \"open_string3\": {\"foreground\": string_fg},\n        \"keyword\": {\"foreground\": \"#8959A8\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#4271ae\"},\n        \"comment\": {\"foreground\": \"#8E908C\"},\n    }", "is_method": false, "function_description": "Function that provides color and font settings following the Tomorrow theme for syntax highlighting in a text editor, enabling consistent visual styling of code elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "tomorrow_night", "line_number": 27, "body": "def tomorrow_night() -> SyntaxThemeSettings:\n    # https://github.com/chriskempson/tomorrow-theme/blob/master/GEdit/Tomorrow-Night.xml\n    normal_fg = \"#c5c8c6\"\n    string_fg = \"#b5bd68\"\n    string3_fg = string_fg\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#1d1f21\"},\n        \"GUTTER\": {\"foreground\": \"#c5c8c6\", \"background\": \"#282a2e\"},\n        \"sel\": {\"foreground\": \"#c5c8c6\", \"background\": \"#373b41\"},\n        \"current_line\": {\"background\": \"#282a2e\"},\n        \"number\": {\"foreground\": \"#de935f\"},\n        \"definition\": {\"foreground\": \"#81a2be\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string3_fg},\n        \"open_string3\": {\"foreground\": string3_fg},\n        \"keyword\": {\"foreground\": \"#b294bb\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#81a2be\"},\n        \"comment\": {\"foreground\": \"#969896\"},\n        # paren matcher\n        \"surrounding_parens\": {\n            \"background\": \"#373b41\",\n            \"foreground\": \"white\",\n            \"font\": \"BoldEditorFont\",\n        },\n    }", "is_method": false, "function_description": "Function that provides a predefined syntax highlighting theme called \"Tomorrow Night\" with specified colors and styles for text editor elements, useful for consistent visual styling in code editors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "tomorrow_night_blue", "line_number": 56, "body": "def tomorrow_night_blue() -> SyntaxThemeSettings:\n    # https://github.com/chriskempson/tomorrow-theme/blob/master/GEdit/Tomorrow-Night-Blue.xml\n    normal_fg = \"#ffffff\"\n    string_fg = \"#d1f1a9\"\n    string3_fg = string_fg\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#002451\"},\n        \"GUTTER\": {\"foreground\": \"#ffffff\", \"background\": \"#00346e\"},\n        \"sel\": {\"foreground\": \"#ffffff\", \"background\": \"#003f8e\"},\n        \"current_line\": {\"background\": \"#00346e\"},\n        \"number\": {\"foreground\": \"#ffc58f\"},\n        \"definition\": {\"foreground\": \"#bbdaff\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string3_fg},\n        \"open_string3\": {\"foreground\": string3_fg},\n        \"keyword\": {\"foreground\": \"#ebbbff\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#bbdaff\"},\n        \"comment\": {\"foreground\": \"#7285b7\"},\n        # paren matcher\n        \"surrounding_parens\": {\n            \"background\": \"#00346e\",\n            \"foreground\": \"white\",\n            \"font\": \"BoldEditorFont\",\n        },\n    }", "is_method": false, "function_description": "Provides a predefined color scheme dictionary for syntax highlighting using the Tomorrow Night Blue theme, specifying colors and styles for various code elements to consistently style a code editor interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "tomorrow_night_bright", "line_number": 85, "body": "def tomorrow_night_bright() -> SyntaxThemeSettings:\n    # https://github.com/chriskempson/tomorrow-theme/blob/master/GEdit/Tomorrow-Night-Bright.xml\n    normal_fg = \"#dedede\"\n    string_fg = \"#b9ca4a\"\n    string3_fg = string_fg\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#000000\"},\n        \"GUTTER\": {\"foreground\": \"#dedede\", \"background\": \"#2a2a2a\"},\n        \"current_line\": {\"background\": \"#2a2a2a\"},\n        \"sel\": {\"foreground\": \"#dedede\", \"background\": \"#424242\"},\n        \"number\": {\"foreground\": \"#e78c45\"},\n        \"definition\": {\"foreground\": \"#7aa6da\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string3_fg},\n        \"open_string3\": {\"foreground\": string3_fg},\n        \"keyword\": {\"foreground\": \"#c397d8\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#7aa6da\"},\n        \"comment\": {\"foreground\": \"#969896\"},\n        # paren matcher\n        \"surrounding_parens\": {\n            \"background\": \"#2a2a2a\",\n            \"foreground\": \"white\",\n            \"font\": \"BoldEditorFont\",\n        },\n    }", "is_method": false, "function_description": "Function that provides a predefined color and font style configuration for a text editor's \"Tomorrow Night Bright\" syntax theme to enable consistent and visually distinct code highlighting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "tomorrow_night_eighties", "line_number": 114, "body": "def tomorrow_night_eighties() -> SyntaxThemeSettings:\n    # https://github.com/chriskempson/tomorrow-theme/blob/master/GEdit/Tomorrow-Night-Eighties.xml\n    normal_fg = \"#cccccc\"\n    string_fg = \"#99cc99\"\n    string3_fg = string_fg\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#2d2d2d\"},\n        \"GUTTER\": {\"foreground\": \"#cccccc\", \"background\": \"#393939\"},\n        \"current_line\": {\"background\": \"#393939\"},\n        \"sel\": {\"foreground\": \"#cccccc\", \"background\": \"#515151\"},\n        \"number\": {\"foreground\": \"#f99157\"},\n        \"definition\": {\"foreground\": \"#6699cc\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string3_fg},\n        \"open_string3\": {\"foreground\": string3_fg},\n        \"keyword\": {\"foreground\": \"#cc99cc\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#6699cc\"},\n        \"comment\": {\"foreground\": \"#999999\"},\n        # paren matcher\n        \"surrounding_parens\": {\n            \"background\": \"#393939\",\n            \"foreground\": \"white\",\n            \"font\": \"BoldEditorFont\",\n        },\n    }", "is_method": false, "function_description": "Function that provides color and font styling settings for a \"Tomorrow Night Eighties\" syntax highlighting theme, enabling consistent editor appearance customization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "load_plugin", "line_number": 143, "body": "def load_plugin() -> None:\n    get_workbench().add_syntax_theme(\"Tomorrow\", \"Default Light\", tomorrow)\n    get_workbench().add_syntax_theme(\"Tomorrow Night\", \"Default Dark\", tomorrow_night)\n    get_workbench().add_syntax_theme(\"Tomorrow Night Blue\", \"Tomorrow Night\", tomorrow_night_blue)\n    get_workbench().add_syntax_theme(\n        \"Tomorrow Night Bright\", \"Tomorrow Night\", tomorrow_night_bright\n    )\n    get_workbench().add_syntax_theme(\n        \"Tomorrow Night Eighties\", \"Tomorrow Night\", tomorrow_night_eighties()\n    )\n\n    get_workbench().set_default(\"view.syntax_theme\", \"Default Light\")", "is_method": false, "function_description": "Registers multiple syntax highlighting themes in the workbench and sets a default theme for the user interface, enabling customizable code appearance options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/editor_config_page.py", "function": "load_plugin", "line_number": 74, "body": "def load_plugin() -> None:\n    get_workbench().add_configuration_page(\"editor\", tr(\"Editor\"), EditorConfigurationPage, 30)", "is_method": false, "function_description": "Adds an editor configuration page to the application's workbench interface for user customization. This function integrates editor settings into the overall application configuration system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/editor_config_page.py", "function": "apply", "line_number": 69, "body": "def apply(self):\n        ConfigurationPage.apply(self)\n        get_workbench().get_editor_notebook().update_appearance()", "is_method": true, "class_name": "EditorConfigurationPage", "function_description": "Triggers the application of configuration changes and refreshes the editor notebook\u2019s appearance to reflect updated settings in the editing environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "load_plugin", "line_number": 227, "body": "def load_plugin() -> None:\n    get_workbench().add_configuration_page(\n        \"theme\", tr(\"Theme & Font\"), ThemeAndFontConfigurationPage, 40\n    )", "is_method": false, "function_description": "Adds a theme and font configuration page to the workbench's settings, enabling users to customize their interface appearance through a plugin system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_init_themes", "line_number": 29, "body": "def _init_themes(self):\n        self._original_ui_theme = get_workbench().get_option(\"view.ui_theme\")\n        self._original_syntax_theme = get_workbench().get_option(\"view.syntax_theme\")\n\n        self._ui_theme_variable = create_string_var(\n            self._original_ui_theme, modification_listener=self._update_appearance\n        )\n        self._syntax_theme_variable = create_string_var(\n            self._original_syntax_theme, modification_listener=self._update_appearance\n        )\n\n        ttk.Label(self, text=tr(\"UI theme\")).grid(\n            row=1, column=1, sticky=\"w\", pady=(0, 10), padx=(0, 5)\n        )\n        self._ui_theme_combo = ttk.Combobox(\n            self,\n            exportselection=False,\n            textvariable=self._ui_theme_variable,\n            state=\"readonly\",\n            height=15,\n            values=get_workbench().get_usable_ui_theme_names(),\n        )\n        self._ui_theme_combo.grid(row=1, column=2, sticky=\"nwe\", pady=(0, 5))\n\n        ttk.Label(self, text=tr(\"Syntax theme\")).grid(\n            row=2, column=1, sticky=\"w\", pady=(0, 10), padx=(0, 5)\n        )\n        self._syntax_theme_combo = ttk.Combobox(\n            self,\n            exportselection=False,\n            textvariable=self._syntax_theme_variable,\n            state=\"readonly\",\n            height=15,\n            values=get_workbench().get_syntax_theme_names(),\n        )\n        self._syntax_theme_combo.grid(row=2, column=2, sticky=\"nwe\", pady=(0, 5))", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Initializes and displays UI components for selecting and updating the application's UI and syntax themes, linking theme options with callback mechanisms to reflect appearance changes dynamically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_init_fonts", "line_number": 66, "body": "def _init_fonts(self):\n        self._original_editor_family = get_workbench().get_option(\"view.editor_font_family\")\n        self._original_editor_size = get_workbench().get_option(\"view.editor_font_size\")\n        self._original_io_family = get_workbench().get_option(\"view.io_font_family\")\n        self._original_io_size = get_workbench().get_option(\"view.io_font_size\")\n\n        self._editor_family_variable = create_string_var(\n            self._original_editor_family, modification_listener=self._update_appearance\n        )\n        self._editor_size_variable = create_string_var(\n            self._original_editor_size, modification_listener=self._update_appearance\n        )\n        self._io_family_variable = create_string_var(\n            self._original_io_family, modification_listener=self._update_appearance\n        )\n        self._io_size_variable = create_string_var(\n            self._original_io_size, modification_listener=self._update_appearance\n        )\n\n        ttk.Label(self, text=tr(\"Editor font\")).grid(\n            row=1, column=3, sticky=\"w\", pady=(0, 5), padx=(25, 5)\n        )\n        editor_family_combo = ttk.Combobox(\n            self,\n            exportselection=False,\n            state=\"readonly\",\n            height=15,\n            textvariable=self._editor_family_variable,\n            values=self._get_families_to_show(),\n        )\n        editor_family_combo.grid(row=1, column=4, sticky=\"nwe\", pady=(0, 5))\n        editor_size_combo = ttk.Combobox(\n            self,\n            width=4,\n            exportselection=False,\n            textvariable=self._editor_size_variable,\n            state=\"readonly\",\n            height=15,\n            values=[str(x) for x in range(3, 73)],\n        )\n        editor_size_combo.grid(row=1, column=5, sticky=\"nwe\", pady=(0, 5), padx=(5, 0))\n\n        ttk.Label(self, text=tr(\"IO font\")).grid(\n            row=2, column=3, sticky=\"w\", pady=(0, 5), padx=(25, 5)\n        )\n        io_family_combo = ttk.Combobox(\n            self,\n            exportselection=False,\n            state=\"readonly\",\n            height=15,\n            textvariable=self._io_family_variable,\n            values=self._get_families_to_show(),\n        )\n        io_family_combo.grid(row=2, column=4, sticky=\"nwe\", pady=(0, 5))\n\n        io_size_combo = ttk.Combobox(\n            self,\n            width=4,\n            exportselection=False,\n            textvariable=self._io_size_variable,\n            state=\"readonly\",\n            height=15,\n            values=[str(x) for x in range(3, 73)],\n        )\n        io_size_combo.grid(row=2, column=5, sticky=\"nwe\", pady=(0, 5), padx=(5, 0))", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Initializes font settings UI elements for editor and IO text areas, linking them to current configuration and enabling real-time appearance updates on user changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_init_previews", "line_number": 132, "body": "def _init_previews(self):\n        ttk.Label(self, text=tr(\"Preview\")).grid(\n            row=20, column=1, sticky=\"w\", pady=(5, 2), columnspan=5\n        )\n        self._preview_codeview = CodeView(\n            self, height=6, font=\"EditorFont\", relief=\"groove\", borderwidth=1, line_numbers=True\n        )\n\n        self._preview_codeview.set_content(\n            textwrap.dedent(\n                \"\"\"\n            def foo(bar):\n                if bar is None: # \"\"\"\n                + tr(\"This is a comment\")\n                + \"\"\"\n                    print('\"\"\"\n                + tr(\"The answer is\")\n                + \"\"\"', 33)\n\n            \"\"\"\n                + tr(\"unclosed_string\")\n                + ''' = \"'''\n                + tr(\"blah, blah\")\n                + \"\\n\"\n            ).strip()\n        )\n        self._preview_codeview.grid(row=21, column=1, columnspan=5, sticky=tk.NSEW)\n\n        self._shell_preview = tktextext.TextFrame(\n            self,\n            text_class=BaseShellText,\n            height=4,\n            vertical_scrollbar_style=scrollbar_style(\"Vertical\"),\n            horizontal_scrollbar_style=scrollbar_style(\"Horizontal\"),\n            horizontal_scrollbar_class=ui_utils.AutoScrollbar,\n            relief=\"groove\",\n            borderwidth=1,\n            font=\"EditorFont\",\n        )\n        self._shell_preview.grid(row=31, column=1, columnspan=5, sticky=tk.NSEW, pady=(5, 5))\n        self._shell_preview.text.set_read_only(True)\n        self._insert_shell_text()\n\n        ttk.Label(\n            self,\n            text=tr(\"NB! Some style elements change only after restarting Thonny!\"),\n            font=\"BoldTkDefaultFont\",\n        ).grid(row=40, column=1, columnspan=5, sticky=\"w\", pady=(5, 0))", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Initializes and configures preview widgets showing sample code and shell output to demonstrate theme and font settings. This method supports visual feedback for customizing appearance within the ThemeAndFontConfigurationPage interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "cancel", "line_number": 185, "body": "def cancel(self):\n        if (\n            getattr(self._editor_family_variable, \"modified\")\n            or getattr(self._editor_size_variable, \"modified\")\n            or getattr(self._ui_theme_variable, \"modified\")\n            or getattr(self._syntax_theme_variable, \"modified\")\n        ):\n            get_workbench().set_option(\"view.ui_theme\", self._original_ui_theme)\n            get_workbench().set_option(\"view.syntax_theme\", self._original_syntax_theme)\n            get_workbench().set_option(\"view.editor_font_size\", self._original_editor_size)\n            get_workbench().set_option(\"view.editor_font_family\", self._original_editor_family)\n            get_workbench().set_option(\"view.io_font_size\", self._original_io_size)\n            get_workbench().set_option(\"view.io_font_family\", self._original_io_family)\n            get_workbench().reload_themes()\n            get_workbench().update_fonts()", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Cancels any unsaved changes to theme and font settings by restoring original configurations and refreshing the interface. It ensures the UI reflects the last saved state after aborted modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_update_appearance", "line_number": 201, "body": "def _update_appearance(self):\n        get_workbench().set_option(\"view.ui_theme\", self._ui_theme_variable.get())\n        get_workbench().set_option(\"view.syntax_theme\", self._syntax_theme_variable.get())\n        get_workbench().set_option(\"view.editor_font_size\", int(self._editor_size_variable.get()))\n        get_workbench().set_option(\"view.editor_font_family\", self._editor_family_variable.get())\n        get_workbench().set_option(\"view.io_font_size\", int(self._io_size_variable.get()))\n        get_workbench().set_option(\"view.io_font_family\", self._io_family_variable.get())\n        get_workbench().reload_themes()\n        get_workbench().update_fonts()", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Updates the application's appearance settings including UI theme, syntax theme, and font styles, then applies these changes by reloading themes and updating fonts. This method ensures the visual customization is reflected immediately."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_insert_shell_text", "line_number": 211, "body": "def _insert_shell_text(self):\n        text = self._shell_preview.text\n        text._insert_prompt()\n        text.direct_insert(\"end\", \"%Run demo.py\\n\", (\"magic\", \"before_io\"))\n        text.tag_add(\"before_io\", \"1.0\", \"1.0 lineend\")\n        text.direct_insert(\"end\", tr(\"Enter an integer\") + \": \", (\"io\", \"stdout\"))\n        text.direct_insert(\"end\", \"2.5\\n\", (\"io\", \"stdin\"))\n        text.direct_insert(\n            \"end\", \"ValueError: invalid literal for int() with base 10: '2.5'\\n\", (\"io\", \"stderr\")\n        )", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Inserts a predefined shell command sequence and example input/output text into the shell preview, simulating a demo of command execution and error output for user guidance or interface preview."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_get_families_to_show", "line_number": 222, "body": "def _get_families_to_show(self):\n        # In Linux, families may contain duplicates (actually different fonts get same names)\n        return sorted(set(filter(lambda name: name[0].isalpha(), tk_font.families())))", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Returns a sorted list of unique font family names starting with alphabetic characters, filtering out duplicates common on Linux systems. This helps identify usable font families for configuration or display purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "load_plugin", "line_number": 85, "body": "def load_plugin() -> None:\n    get_workbench().add_view(HeapView, tr(\"Heap\"), \"e\")", "is_method": false, "function_description": "Adds a Heap view to the workbench interface, integrating memory analysis capabilities into the application environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "_update_data", "line_number": 45, "body": "def _update_data(self, data):\n        self._clear_tree()\n        for value_id in sorted(data.keys()):\n            node_id = self.tree.insert(\"\", \"end\")\n            self.tree.set(node_id, \"id\", format_object_id(value_id))\n            self.tree.set(\n                node_id, \"value\", shorten_repr(data[value_id].repr, MAX_REPR_LENGTH_IN_GRID)\n            )", "is_method": true, "class_name": "HeapView", "function_description": "Internal method of HeapView that refreshes the tree view by clearing existing entries and inserting sorted data items with formatted IDs and shortened representations. It supports visualizing updated heap data in a structured grid format."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "before_show", "line_number": 54, "body": "def before_show(self):\n        self._request_heap_data(even_when_hidden=True)", "is_method": true, "class_name": "HeapView", "function_description": "Triggers a heap data request prior to displaying the heap view, ensuring the latest heap information is available even if the view is not currently visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "get_object_id", "line_number": 57, "body": "def get_object_id(self):\n        iid = self.tree.focus()\n        if iid != \"\":\n            return parse_object_id(self.tree.item(iid)[\"values\"][0])\n\n        return None", "is_method": true, "class_name": "HeapView", "function_description": "Returns the identifier of the currently selected object in the HeapView's tree, or None if no selection exists. This enables other components to access or manipulate the selected heap item based on its unique ID."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "_request_heap_data", "line_number": 64, "body": "def _request_heap_data(self, msg=None, even_when_hidden=False):\n        if self.winfo_ismapped() or even_when_hidden:\n            # TODO: update itself also when it becomes visible\n            if get_runner() is not None:\n                get_runner().send_command(InlineCommand(\"get_heap\"))", "is_method": true, "class_name": "HeapView", "function_description": "Private method in HeapView that triggers a \"get_heap\" command to retrieve heap data, optionally executing even if the view is hidden. It supports updating memory state information via an external runner interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "_handle_heap_event", "line_number": 70, "body": "def _handle_heap_event(self, msg):\n        if self.winfo_ismapped():\n            if hasattr(msg, \"heap\"):\n                self._update_data(msg.heap)", "is_method": true, "class_name": "HeapView", "function_description": "Handles incoming heap-related events by updating internal data if the view is active and the message contains heap information. This supports dynamic heap visualization in the HeapView class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "_on_map", "line_number": 75, "body": "def _on_map(self, event):\n        self.info_label.grid(row=0, column=1005)", "is_method": true, "class_name": "HeapView", "function_description": "Private event handler in HeapView that displays or updates an informational label when the view is mapped or rendered. It supports UI feedback or status indication during the widget's lifecycle."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "_on_unmap", "line_number": 78, "body": "def _on_unmap(self, event):\n        try:\n            self.info_label.grid_remove()\n        except TclError:\n            pass", "is_method": true, "class_name": "HeapView", "function_description": "Handles the unmapping event by attempting to hide the info label in the HeapView interface, safely ignoring errors if the label is not currently mapped."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_fetch_url_future", "line_number": 1220, "body": "def _fetch_url_future(url, timeout=10):\n    from urllib.request import urlopen\n\n    def load_url():\n        with urlopen(url, timeout=timeout) as conn:\n            return (conn, conn.read())\n\n    from concurrent.futures.thread import ThreadPoolExecutor\n\n    executor = ThreadPoolExecutor(max_workers=1)\n    return executor.submit(load_url)", "is_method": false, "function_description": "Utility function that asynchronously fetches the content of a URL with a specified timeout, returning a future representing the eventual result of the HTTP request."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_latest_stable_version", "line_number": 1233, "body": "def _get_latest_stable_version(version_strings):\n    from distutils.version import LooseVersion\n\n    versions = []\n    for s in version_strings:\n        if s.replace(\".\", \"\").isnumeric():  # Assuming stable versions have only dots and numbers\n            versions.append(\n                LooseVersion(s)\n            )  # LooseVersion __str__ doesn't change the version string\n\n    if len(versions) == 0:\n        return None\n\n    return str(sorted(versions)[-1])", "is_method": false, "function_description": "Function that identifies and returns the latest stable version string from a list based on numeric-dot formatting, useful for selecting stable software releases among multiple version candidates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_ask_installation_details", "line_number": 1249, "body": "def _ask_installation_details(master, data, selected_version, support_update_deps_switch):\n    dlg = DetailsDialog(master, data, selected_version, support_update_deps_switch)\n    ui_utils.show_dialog(dlg, master)\n    return dlg.result", "is_method": false, "function_description": "This function displays a dialog to collect installation details from the user and returns the input data after the dialog closes, facilitating user-driven configuration during installation processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_fetching_package_info", "line_number": 1255, "body": "def _start_fetching_package_info(name, version_str, completion_handler):\n    import urllib.error\n    import urllib.parse\n\n    # Fetch info from PyPI\n    if version_str is None:\n        url = \"https://pypi.org/pypi/{}/json\".format(urllib.parse.quote(name))\n    else:\n        url = \"https://pypi.org/pypi/{}/{}/json\".format(\n            urllib.parse.quote(name), urllib.parse.quote(version_str)\n        )\n\n    url_future = _fetch_url_future(url)\n\n    def poll_fetch_complete():\n        import json\n\n        if url_future.done():\n            try:\n                _, bin_data = url_future.result()\n                raw_data = bin_data.decode(\"UTF-8\")\n                completion_handler(name, json.loads(raw_data))\n            except urllib.error.HTTPError as e:\n                completion_handler(\n                    name, {\"info\": {\"name\": name}, \"error\": str(e), \"releases\": {}}, e.code\n                )\n            except Exception as e:\n                completion_handler(\n                    name, {\"info\": {\"name\": name}, \"error\": str(e), \"releases\": {}}, e\n                )\n        else:\n            tk._default_root.after(200, poll_fetch_complete)\n\n    poll_fetch_complete()", "is_method": false, "function_description": "Utility function that asynchronously fetches package metadata from PyPI by name and optional version, then passes parsed JSON data or error details to a provided completion handler. It facilitates integration with PyPI package information retrieval workflows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_fetching_search_results", "line_number": 1291, "body": "def _start_fetching_search_results(query, completion_handler):\n    import urllib.parse\n\n    url = \"https://pypi.org/search/?q={}\".format(urllib.parse.quote(query))\n\n    url_future = _fetch_url_future(url)\n\n    def poll_fetch_complete():\n\n        if url_future.done():\n            try:\n                _, bin_data = url_future.result()\n                raw_data = bin_data.decode(\"UTF-8\")\n                completion_handler(query, _extract_search_results(raw_data))\n            except Exception as e:\n                completion_handler(query, str(e))\n        else:\n            tk._default_root.after(200, poll_fetch_complete)\n\n    poll_fetch_complete()", "is_method": false, "function_description": "Function initiating an asynchronous PyPI package search for a query and calling a completion handler with the processed search results or error once done. It enables non-blocking retrieval of search data in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_extract_search_results", "line_number": 1313, "body": "def _extract_search_results(html_data: str) -> List:\n    from html.parser import HTMLParser\n\n    def get_class(attrs):\n        for name, value in attrs:\n            if name == \"class\":\n                return value\n\n        return None\n\n    class_prefix = \"package-snippet__\"\n\n    class PypiSearchResultsParser(HTMLParser):\n        def __init__(self, data):\n            HTMLParser.__init__(self)\n            self.results = []\n            self.active_class = None\n            self.feed(data)\n\n        def handle_starttag(self, tag, attrs):\n            if tag == \"a\" and get_class(attrs) == \"package-snippet\":\n                self.results.append({})\n\n            if tag in (\"span\", \"p\"):\n                tag_class = get_class(attrs)\n                if tag_class in (\"package-snippet__name\", \"package-snippet__description\"):\n                    self.active_class = tag_class\n                else:\n                    self.active_class = None\n            else:\n                self.active_class = None\n\n        def handle_data(self, data):\n            if self.active_class is not None:\n                att_name = self.active_class[len(class_prefix) :]\n                self.results[-1][att_name] = data\n\n        def handle_endtag(self, tag):\n            self.active_class = None\n\n    return PypiSearchResultsParser(html_data).results", "is_method": false, "function_description": "Parses HTML from PyPI search results and extracts package names and descriptions into a structured list of dictionaries. It enables other functions to convert raw search HTML into usable package metadata."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_extract_click_text", "line_number": 1356, "body": "def _extract_click_text(widget, event, tag):\n    # http://stackoverflow.com/a/33957256/261181\n    try:\n        index = widget.index(\"@%s,%s\" % (event.x, event.y))\n        tag_indices = list(widget.tag_ranges(tag))\n        for start, end in zip(tag_indices[0::2], tag_indices[1::2]):\n            # check if the tag matches the mouse click index\n            if widget.compare(start, \"<=\", index) and widget.compare(index, \"<\", end):\n                return widget.get(start, end)\n    except Exception:\n        logging.exception(\"extracting click text\")\n\n    return None", "is_method": false, "function_description": "Utility function that identifies and returns the text segment tagged at the mouse click position within a text widget, allowing event handlers to respond to user interactions on specific tagged regions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_not_supported_translation", "line_number": 1371, "body": "def get_not_supported_translation():\n    return tr(\"Package manager is not available for this interpreter\")", "is_method": false, "function_description": "Returns a localized message indicating that the package manager is unavailable for the current interpreter, useful for user notifications or error handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "load_plugin", "line_number": 1375, "body": "def load_plugin() -> None:\n    def get_pip_gui_class():\n        proxy = get_runner().get_backend_proxy()\n        if proxy is None:\n            return None\n        return proxy.get_pip_gui_class()\n\n    def open_backend_pip_gui(*args):\n        pg_class = get_pip_gui_class()\n        if pg_class is None:\n            showerror(tr(\"Not supported\"), get_not_supported_translation())\n            return\n\n        if not get_runner().is_waiting_toplevel_command():\n            showerror(\n                tr(\"Not available\"),\n                tr(\"You need to stop your program before launching the package manager.\"),\n                master=get_workbench(),\n            )\n            return\n\n        pg = pg_class(get_workbench())\n        ui_utils.show_dialog(pg)\n\n    def open_backend_pip_gui_enabled():\n        return get_pip_gui_class() is not None\n\n    def open_frontend_pip_gui(*args):\n        pg = PluginsPipDialog(get_workbench())\n        ui_utils.show_dialog(pg)\n\n    get_workbench().add_command(\n        \"backendpipgui\",\n        \"tools\",\n        tr(\"Manage packages...\"),\n        open_backend_pip_gui,\n        tester=open_backend_pip_gui_enabled,\n        group=80,\n    )\n    get_workbench().add_command(\n        \"pluginspipgui\", \"tools\", tr(\"Manage plug-ins...\"), open_frontend_pip_gui, group=180\n    )", "is_method": false, "function_description": "Function that integrates and registers package and plugin management GUI commands into the application's workbench, enabling users to manage packages or plugins through appropriate dialogs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_search_button_text", "line_number": 66, "body": "def get_search_button_text(self):\n        return tr(\"Search on PyPI\")", "is_method": true, "class_name": "PipDialog", "function_description": "Returns the localized label text for the PyPI search button, supporting user interface consistency within the PipDialog class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_install_button_text", "line_number": 69, "body": "def get_install_button_text(self):\n        return tr(\"Install\")", "is_method": true, "class_name": "PipDialog", "function_description": "Returns the localized text label \"Install\" for an installation button. This method provides UI text consistent with user language preferences in the PipDialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_upgrade_button_text", "line_number": 72, "body": "def get_upgrade_button_text(self):\n        return tr(\"Upgrade\")", "is_method": true, "class_name": "PipDialog", "function_description": "Returns the localized text for an \"Upgrade\" button, supporting user interface elements that prompt users to upgrade within the PipDialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_uninstall_button_text", "line_number": 75, "body": "def get_uninstall_button_text(self):\n        return tr(\"Uninstall\")", "is_method": true, "class_name": "PipDialog", "function_description": "Returns the localized text label for the uninstall button in the PipDialog interface, supporting consistent UI wording across different languages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_delete_selected_button_text", "line_number": 78, "body": "def get_delete_selected_button_text(self):\n        return tr(\"Delete selected\")", "is_method": true, "class_name": "PipDialog", "function_description": "Returns the localized text label for the \"Delete selected\" button, supporting user interface internationalization in the PipDialog class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_create_widgets", "line_number": 81, "body": "def _create_widgets(self, parent):\n\n        header_frame = ttk.Frame(parent)\n        header_frame.grid(row=1, column=0, sticky=\"nsew\", padx=15, pady=(15, 0))\n        header_frame.columnconfigure(0, weight=1)\n        header_frame.rowconfigure(1, weight=1)\n\n        name_font = tk.font.nametofont(\"TkDefaultFont\").copy()\n        name_font.configure(size=16)\n        self.search_box = ttk.Entry(header_frame)\n        self.search_box.grid(row=1, column=0, sticky=\"nsew\")\n        self.search_box.bind(\"<Return>\", self._on_search, False)\n        self.search_box.bind(\"<KP_Enter>\", self._on_search, False)\n\n        # Selecting chars in the search box with mouse didn't make the box active on Linux without following line\n        self.search_box.bind(\"<B1-Motion>\", lambda _: self.search_box.focus_set())\n\n        self.search_button = ttk.Button(\n            header_frame, text=self.get_search_button_text(), command=self._on_search, width=25\n        )\n        self.search_button.grid(row=1, column=1, sticky=\"nse\", padx=(10, 0))\n\n        main_pw = tk.PanedWindow(\n            parent,\n            orient=tk.HORIZONTAL,\n            background=lookup_style_option(\"TPanedWindow\", \"background\"),\n            sashwidth=15,\n        )\n        main_pw.grid(row=2, column=0, sticky=\"nsew\", padx=15, pady=15)\n        parent.rowconfigure(2, weight=1)\n        parent.columnconfigure(0, weight=1)\n\n        listframe = ttk.Frame(main_pw, relief=\"flat\", borderwidth=1)\n        listframe.rowconfigure(0, weight=1)\n        listframe.columnconfigure(0, weight=1)\n\n        self.listbox = ui_utils.ThemedListbox(\n            listframe,\n            activestyle=\"dotbox\",\n            width=20,\n            height=20,\n            selectborderwidth=0,\n            relief=\"flat\",\n            # highlightthickness=4,\n            # highlightbackground=\"red\",\n            # highlightcolor=\"green\",\n            borderwidth=0,\n        )\n        self.listbox.insert(\"end\", \" <\" + tr(\"INSTALL\") + \">\")\n        self.listbox.bind(\"<<ListboxSelect>>\", self._on_listbox_select, True)\n        self.listbox.grid(row=0, column=0, sticky=\"nsew\")\n        list_scrollbar = AutoScrollbar(\n            listframe, orient=tk.VERTICAL, style=scrollbar_style(\"Vertical\")\n        )\n        list_scrollbar.grid(row=0, column=1, sticky=\"ns\")\n        list_scrollbar[\"command\"] = self.listbox.yview\n        self.listbox[\"yscrollcommand\"] = list_scrollbar.set\n\n        info_frame = ttk.Frame(main_pw)\n        info_frame.columnconfigure(0, weight=1)\n        info_frame.rowconfigure(1, weight=1)\n\n        main_pw.add(listframe)\n        main_pw.add(info_frame)\n\n        self.title_label = ttk.Label(info_frame, text=\"\", font=name_font)\n        self.title_label.grid(row=0, column=0, sticky=\"w\", padx=5, pady=(0, ems_to_pixels(1)))\n\n        info_text_frame = tktextext.TextFrame(\n            info_frame,\n            read_only=True,\n            horizontal_scrollbar=False,\n            background=lookup_style_option(\"TFrame\", \"background\"),\n            vertical_scrollbar_class=AutoScrollbar,\n            vertical_scrollbar_style=scrollbar_style(\"Vertical\"),\n            horizontal_scrollbar_style=scrollbar_style(\"Horizontal\"),\n            width=70,\n            height=10,\n        )\n        info_text_frame.configure(borderwidth=0)\n        info_text_frame.grid(row=1, column=0, columnspan=4, sticky=\"nsew\", pady=(0, 10))\n        self.info_text = info_text_frame.text\n        link_color = lookup_style_option(\"Url.TLabel\", \"foreground\", \"red\")\n        self.info_text.tag_configure(\"url\", foreground=link_color, underline=True)\n        self.info_text.tag_bind(\"url\", \"<ButtonRelease-1>\", self._handle_url_click)\n        self.info_text.tag_bind(\"url\", \"<Enter>\", lambda e: self.info_text.config(cursor=\"hand2\"))\n        self.info_text.tag_bind(\"url\", \"<Leave>\", lambda e: self.info_text.config(cursor=\"\"))\n        self.info_text.tag_configure(\"install_reqs\", foreground=link_color, underline=True)\n        self.info_text.tag_bind(\n            \"install_reqs\", \"<ButtonRelease-1>\", self._handle_install_requirements_click\n        )\n        self.info_text.tag_bind(\n            \"install_reqs\", \"<Enter>\", lambda e: self.info_text.config(cursor=\"hand2\")\n        )\n        self.info_text.tag_bind(\n            \"install_reqs\", \"<Leave>\", lambda e: self.info_text.config(cursor=\"\")\n        )\n        self.info_text.tag_configure(\"install_file\", foreground=link_color, underline=True)\n        self.info_text.tag_bind(\n            \"install_file\", \"<ButtonRelease-1>\", self._handle_install_file_click\n        )\n        self.info_text.tag_bind(\n            \"install_file\", \"<Enter>\", lambda e: self.info_text.config(cursor=\"hand2\")\n        )\n        self.info_text.tag_bind(\n            \"install_file\", \"<Leave>\", lambda e: self.info_text.config(cursor=\"\")\n        )\n\n        default_font = tk.font.nametofont(\"TkDefaultFont\")\n        self.info_text.configure(font=default_font, wrap=\"word\")\n\n        bold_font = default_font.copy()\n        # need to explicitly copy size, because Tk 8.6 on certain Ubuntus use bigger font in copies\n        bold_font.configure(weight=\"bold\", size=default_font.cget(\"size\"))\n        self.info_text.tag_configure(\"caption\", font=bold_font)\n        self.info_text.tag_configure(\"bold\", font=bold_font)\n\n        self.command_frame = ttk.Frame(info_frame)\n        self.command_frame.grid(row=2, column=0, sticky=\"w\")\n\n        self.install_button = ttk.Button(\n            self.command_frame,\n            text=\" \" + self.get_upgrade_button_text() + \" \",\n            command=self._on_install_click,\n            width=20,\n        )\n\n        self.install_button.grid(row=0, column=0, sticky=\"w\", padx=0)\n\n        self.uninstall_button = ttk.Button(\n            self.command_frame,\n            text=self.get_uninstall_button_text(),\n            command=self._on_uninstall_click,\n            width=20,\n        )\n\n        self.uninstall_button.grid(row=0, column=1, sticky=\"w\", padx=(5, 0))\n\n        self.advanced_button = ttk.Button(\n            self.command_frame,\n            text=\"...\",\n            width=3,\n            command=lambda: self._perform_pip_action(\"advanced\"),\n        )\n\n        self.advanced_button.grid(row=0, column=2, sticky=\"w\", padx=(5, 0))\n\n        self.close_button = ttk.Button(info_frame, text=tr(\"Close\"), command=self._on_close)\n        self.close_button.grid(row=2, column=3, sticky=\"e\")", "is_method": true, "class_name": "PipDialog", "function_description": "Constructs and configures the complete user interface of the PipDialog, including search controls, list display, info panel, and action buttons for package management interactions. It provides the visual elements necessary for searching, selecting, and managing pip packages within the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_set_state", "line_number": 231, "body": "def _set_state(self, state, force_normal_cursor=False):\n        self._state = state\n        action_buttons = [\n            self.install_button,\n            self.advanced_button,\n            self.uninstall_button,\n        ]\n\n        other_widgets = [\n            self.listbox,\n            # self.search_box, # looks funny when disabled\n            self.search_button,\n        ]\n\n        if state == \"idle\" and not self._read_only():\n            for widget in action_buttons:\n                widget[\"state\"] = tk.NORMAL\n        else:\n            for widget in action_buttons:\n                widget[\"state\"] = tk.DISABLED\n\n        if state == \"idle\":\n            for widget in other_widgets:\n                widget[\"state\"] = tk.NORMAL\n        else:\n            self.config(cursor=get_busy_cursor())\n            for widget in other_widgets:\n                widget[\"state\"] = tk.DISABLED\n\n        if state == \"idle\" or force_normal_cursor:\n            self.config(cursor=\"\")\n        else:\n            self.config(cursor=get_busy_cursor())", "is_method": true, "class_name": "PipDialog", "function_description": "Sets the dialog's interactive state by enabling or disabling UI buttons and widgets based on the current status, managing user interaction readiness and visual cursor feedback accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_state", "line_number": 265, "body": "def _get_state(self):\n        return self._state", "is_method": true, "class_name": "PipDialog", "function_description": "Private method in PipDialog that returns the current internal state of the dialog. It provides access to the dialog's status for other methods within the class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_instructions_for_command_line_install", "line_number": 268, "body": "def _instructions_for_command_line_install(self):\n        return (\n            \"Alternatively, if you have an older pip installed, then you can install packages \"\n            + \"on the command line (Tools \u2192 Open system shell...)\"\n        )", "is_method": true, "class_name": "PipDialog", "function_description": "Returns a user instruction string guiding how to install packages via the command line when using an older pip version."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_update_list", "line_number": 277, "body": "def _update_list(self, name_to_show):\n        self.listbox.delete(1, \"end\")\n        for name in sorted(self._active_distributions.keys()):\n            self.listbox.insert(\"end\", \" \" + name)\n\n        if name_to_show is None or name_to_show not in self._active_distributions.keys():\n            self._show_instructions()\n        else:\n            self._on_listbox_select_package(name_to_show)", "is_method": true, "class_name": "PipDialog", "function_description": "Updates a displayed list with active distribution names and either shows instructions or selects a specified distribution for detailed view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_listbox_select", "line_number": 287, "body": "def _on_listbox_select(self, event):\n        self.listbox.focus_set()\n        selection = self.listbox.curselection()\n        if len(selection) == 1:\n            self.listbox.activate(selection[0])\n            if selection[0] == 0:  # special first item\n                self._show_instructions()\n            else:\n                self._on_listbox_select_package(self.listbox.get(selection[0]).strip())", "is_method": true, "class_name": "PipDialog", "function_description": "Handles user selection in a listbox, triggering different actions based on the selected item; it either shows instructions or processes the chosen package."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_listbox_select_package", "line_number": 297, "body": "def _on_listbox_select_package(self, name):\n        self._start_show_package_info(name)", "is_method": true, "class_name": "PipDialog", "function_description": "Private method in PipDialog that initiates displaying detailed information about a selected package when its name is chosen from a list."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_search", "line_number": 300, "body": "def _on_search(self, event=None):\n        if self._get_state() != \"idle\":\n            # Search box is not made inactive for busy-states\n            return\n\n        if self.search_box.get().strip() == \"\":\n            return\n\n        self._start_search(self.search_box.get().strip())", "is_method": true, "class_name": "PipDialog", "function_description": "Handler method in PipDialog that initiates a search when the system is idle and the search box contains non-empty input, ensuring searches only start under appropriate conditions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_install_click", "line_number": 310, "body": "def _on_install_click(self):\n        self._perform_pip_action(\"install\")", "is_method": true, "class_name": "PipDialog", "function_description": "Triggers the installation process by initiating a pip install action when invoked. This private method supports executing package installation commands in the PipDialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_uninstall_click", "line_number": 313, "body": "def _on_uninstall_click(self):\n        self._perform_pip_action(\"uninstall\")", "is_method": true, "class_name": "PipDialog", "function_description": "Private method of the PipDialog class that initiates the uninstallation of a package by triggering the corresponding pip action. It supports user interaction for managing installed packages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_clear", "line_number": 316, "body": "def _clear(self):\n        self.current_package_data = None\n        self.title_label.grid_remove()\n        self.command_frame.grid_remove()\n        self._clear_info_text()", "is_method": true, "class_name": "PipDialog", "function_description": "Internal method of the PipDialog class that resets the dialog state by clearing current package data and hiding related UI elements and information text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_clear_info_text", "line_number": 322, "body": "def _clear_info_text(self):\n        self.info_text.direct_delete(\"1.0\", \"end\")", "is_method": true, "class_name": "PipDialog", "function_description": "Private method in PipDialog that clears all content from the info text display area, likely used to reset or update the dialog's informational messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_append_info_text", "line_number": 325, "body": "def _append_info_text(self, text, tags=()):\n        self.info_text.direct_insert(\"end\", text, tags)", "is_method": true, "class_name": "PipDialog", "function_description": "Private method of the PipDialog class that appends given text with optional tags to the info_text display element for updating dialog information dynamically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_instructions", "line_number": 328, "body": "def _show_instructions(self):\n        self._clear()\n        if self._read_only():\n            self._show_read_only_instructions()\n        else:\n            self._append_info_text(tr(\"Install from PyPI\") + \"\\n\", (\"caption\",))\n            self.info_text.direct_insert(\n                \"end\",\n                tr(\n                    \"If you don't know where to get the package from, \"\n                    + \"then most likely you'll want to search the Python Package Index. \"\n                    + \"Start by entering the name of the package in the search box above and pressing ENTER.\"\n                )\n                + \"\\n\\n\",\n            )\n\n            self.info_text.direct_insert(\n                \"end\", tr(\"Install from requirements file\") + \"\\n\", (\"caption\",)\n            )\n            self._append_info_text(tr(\"Click\" + \" \"))\n            self._append_info_text(tr(\"here\"), (\"install_reqs\",))\n            self.info_text.direct_insert(\n                \"end\",\n                \" \"\n                + tr(\"to locate requirements.txt file and install the packages specified in it.\")\n                + \"\\n\\n\",\n            )\n\n            self._show_instructions_about_installing_from_local_file()\n            self._show_instructions_about_existing_packages()\n\n            if self._get_target_directory():\n                self._show_instructions_about_target()\n\n        self._select_list_item(0)", "is_method": true, "class_name": "PipDialog", "function_description": "Displays contextual installation instructions based on the dialog's state, guiding users on installing Python packages from PyPI, requirements files, local files, or existing packages within the PipDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_read_only_instructions", "line_number": 364, "body": "def _show_read_only_instructions(self):\n        self._append_info_text(tr(\"Browse the packages\") + \"\\n\", (\"caption\",))\n        self.info_text.direct_insert(\n            \"end\",\n            tr(\n                \"With current interpreter you can only browse the packages here.\\n\"\n                + \"Use 'Tools \u2192 Open system shell...' for installing, upgrading or uninstalling.\"\n            )\n            + \"\\n\\n\",\n        )\n\n        if self._get_target_directory():\n            self._append_info_text(tr(\"Packages' directory\") + \"\\n\", (\"caption\",))\n            self.info_text.direct_insert(\"end\", self._get_target_directory(), (\"target_directory\"))", "is_method": true, "class_name": "PipDialog", "function_description": "Displays informational text guiding users that package browsing is read-only and directs them to use the system shell for package management, optionally showing the packages' directory if available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_instructions_about_installing_from_local_file", "line_number": 379, "body": "def _show_instructions_about_installing_from_local_file(self):\n        self._append_info_text(tr(\"Install from local file\") + \"\\n\", (\"caption\",))\n        self._append_info_text(tr(\"Click\") + \" \")\n        self._append_info_text(tr(\"here\"), (\"install_file\",))\n        self.info_text.direct_insert(\n            \"end\",\n            \" \"\n            + tr(\n                \"to locate and install the package file (usually with .whl, .tar.gz or .zip extension).\"\n            )\n            + \"\\n\\n\",\n        )", "is_method": true, "class_name": "PipDialog", "function_description": "Displays instructions guiding users on how to install a package from a local file within the PipDialog interface, enhancing user experience during package installation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_instructions_about_existing_packages", "line_number": 392, "body": "def _show_instructions_about_existing_packages(self):\n        self._append_info_text(tr(\"Upgrade or uninstall\") + \"\\n\", (\"caption\",))\n        self.info_text.direct_insert(\n            \"end\", tr(\"Start by selecting the package from the left.\") + \"\\n\\n\"\n        )", "is_method": true, "class_name": "PipDialog", "function_description": "Private method of the PipDialog class that displays user instructions on upgrading or uninstalling existing packages within the dialog interface. It guides users through selecting packages for managing their installations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_instructions_about_target", "line_number": 398, "body": "def _show_instructions_about_target(self):\n        self._append_info_text(tr(\"Target:\") + \"  \", (\"caption\",))\n        if self._should_install_to_site_packages():\n            self.info_text.direct_insert(\"end\", tr(\"virtual environment\") + \"\\n\", (\"caption\",))\n        else:\n            self.info_text.direct_insert(\"end\", tr(\"user site packages\") + \"\\n\", (\"caption\",))\n\n        self.info_text.direct_insert(\n            \"end\",\n            tr(\n                \"This dialog lists all available packages,\"\n                + \" but allows upgrading and uninstalling only packages from\"\n            )\n            + \" \",\n        )\n        self._append_info_text(self._get_target_directory(), (\"url\"))\n        self.info_text.direct_insert(\n            \"end\",\n            \". \"\n            + tr(\n                \"New packages will be also installed into this directory.\"\n                + \" Other locations must be managed by alternative means.\"\n            ),\n        )", "is_method": true, "class_name": "PipDialog", "function_description": "Provides user instructions about the package target location in the dialog, clarifying where packages can be installed, upgraded, or uninstalled, and specifying the directory managing package operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_show_package_info", "line_number": 423, "body": "def _start_show_package_info(self, name):\n        self.current_package_data = None\n        # Fetch info from PyPI\n        self._set_state(\"fetching\")\n        # Following fetches info about latest version.\n        # This is OK even when we're looking an installed older version\n        # because new version may have more relevant and complete info.\n        _start_fetching_package_info(name, None, self._show_package_info)\n\n        self._clear_info_text()\n        self.title_label[\"text\"] = \"\"\n        self.title_label.grid()\n        self.command_frame.grid()\n        self.uninstall_button[\"text\"] = self.get_uninstall_button_text()\n\n        active_dist = self._get_active_dist(name)\n        if active_dist is not None:\n            self.title_label[\"text\"] = active_dist[\"project_name\"]\n            self._append_info_text(tr(\"Installed version:\") + \" \", (\"caption\",))\n            self._append_info_text(active_dist[\"version\"] + \"\\n\")\n            self._append_info_text(tr(\"Installed to:\") + \" \", (\"caption\",))\n            # TODO: only show link if local backend\n            self.info_text.direct_insert(\n                \"end\", normpath_with_actual_case(active_dist[\"location\"]), (\"url\",)\n            )\n            self._append_info_text(\"\\n\\n\")\n            self._select_list_item(name)\n        else:\n            self._select_list_item(0)\n\n        # update gui\n        if self._is_read_only_package(name):\n            self.install_button.grid_remove()\n            self.uninstall_button.grid_remove()\n            self.advanced_button.grid_remove()\n        else:\n            self.install_button.grid(row=0, column=0)\n            self.advanced_button.grid(row=0, column=2)\n\n            if active_dist is not None:\n                # existing package in target directory\n                self.install_button[\"text\"] = self.get_upgrade_button_text()\n                self.install_button[\"state\"] = \"disabled\"\n                self.uninstall_button.grid(row=0, column=1)\n            else:\n                # new package\n                self.install_button[\"text\"] = self.get_install_button_text()\n                self.uninstall_button.grid_remove()", "is_method": true, "class_name": "PipDialog", "function_description": "Core method of the PipDialog class that initiates fetching and displaying detailed information about a specified Python package, updating the interface according to the package's installation status and user permissions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_package_info", "line_number": 472, "body": "def _show_package_info(self, name, data, error_code=None):\n        self._set_state(\"idle\")\n\n        self.current_package_data = data\n\n        def write(s, tag=None):\n            if tag is None:\n                tags = ()\n            else:\n                tags = (tag,)\n            self._append_info_text(s, tags)\n\n        def write_att(caption, value, value_tag=None):\n            write(caption + \": \", \"caption\")\n            write(value, value_tag)\n            write(\"\\n\")\n\n        if error_code is not None:\n            if error_code == 404:\n                write(tr(\"Could not find the package from PyPI.\"))\n                if not self._get_active_version(name):\n                    # new package\n                    write(\"\\n\" + tr(\"Please check your spelling!\"))\n\n            else:\n                write(\n                    tr(\"Could not find the package info from PyPI.\")\n                    + \" \"\n                    + tr(\"Error code:\")\n                    + \" \"\n                    + str(error_code)\n                )\n\n            return\n\n        info = data[\"info\"]\n        self.title_label[\"text\"] = info[\"name\"]  # search name could have been a bit different\n        latest_stable_version = _get_latest_stable_version(data[\"releases\"].keys())\n        if latest_stable_version is not None:\n            write_att(tr(\"Latest stable version\"), latest_stable_version)\n        else:\n            write_att(tr(\"Latest version\"), data[\"info\"][\"version\"])\n        write_att(tr(\"Summary\"), info[\"summary\"])\n        write_att(tr(\"Author\"), info[\"author\"])\n        write_att(tr(\"Homepage\"), info[\"home_page\"], \"url\")\n        if info.get(\"bugtrack_url\", None):\n            write_att(tr(\"Bugtracker\"), info[\"bugtrack_url\"], \"url\")\n        if info.get(\"docs_url\", None):\n            write_att(tr(\"Documentation\"), info[\"docs_url\"], \"url\")\n        if info.get(\"package_url\", None):\n            write_att(tr(\"PyPI page\"), info[\"package_url\"], \"url\")\n        if info.get(\"requires_dist\", None):\n            # Available only when release is created by a binary wheel\n            # https://github.com/pypa/pypi-legacy/issues/622#issuecomment-305829257\n            write_att(tr(\"Requires\"), \", \".join(info[\"requires_dist\"]))\n\n        if self._get_active_version(name) != latest_stable_version or not self._get_active_version(\n            name\n        ):\n            self.install_button[\"state\"] = \"normal\"\n        else:\n            self.install_button[\"state\"] = \"disabled\"", "is_method": true, "class_name": "PipDialog", "function_description": "Displays detailed package information from PyPI within the PipDialog interface, handling error cases and updating the UI to reflect the package's metadata and install availability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_is_read_only_package", "line_number": 535, "body": "def _is_read_only_package(self, name):\n        dist = self._get_active_dist(name)\n        if dist is None:\n            return False\n        else:\n            return normpath_with_actual_case(dist[\"location\"]) != self._get_target_directory()", "is_method": true, "class_name": "PipDialog", "function_description": "Checks if a package is installed as a read-only distribution by comparing its location with the target directory. This helps determine whether modifications to the package are restricted."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_normalize_name", "line_number": 542, "body": "def _normalize_name(self, name):\n        # looks like (in some cases?) pip list gives the name as it was used during install\n        # ie. the list may contain lowercase entry, when actual metadata has uppercase name\n        # Example: when you \"pip install cx-freeze\", then \"pip list\"\n        # really returns \"cx-freeze\" although correct name is \"cx_Freeze\"\n\n        # https://www.python.org/dev/peps/pep-0503/#id4\n        return re.sub(r\"[-_.]+\", \"-\", name).lower().strip()", "is_method": true, "class_name": "PipDialog", "function_description": "Utility method in PipDialog that standardizes package names by normalizing separators and casing, ensuring consistent identification regardless of input format or source variations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_search", "line_number": 551, "body": "def _start_search(self, query, discard_selection=True):\n        self.current_package_data = None\n        # Fetch info from PyPI\n        self._set_state(\"fetching\")\n        self._clear()\n        self.title_label.grid()\n        self.title_label[\"text\"] = tr(\"Search results\")\n        self.info_text.direct_insert(\"1.0\", tr(\"Searching\") + \" ...\")\n        _start_fetching_search_results(query, self._show_search_results)\n        if discard_selection:\n            self._select_list_item(0)", "is_method": true, "class_name": "PipDialog", "function_description": "Internal method of PipDialog that initiates a package search query, updates the UI to reflect the search state, and optionally resets the current selection to show relevant search results."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_search_results", "line_number": 563, "body": "def _show_search_results(self, query, results: Union[List[Dict], str]) -> None:\n        self._set_state(\"idle\")\n        self._clear_info_text()\n\n        results = self._tweak_search_results(results, query)\n\n        if isinstance(results, str) or not results:\n            if not results:\n                self._append_info_text(\"No results.\\n\\n\")\n            else:\n                self._append_info_text(\"Could not fetch search results:\\n\")\n                self._append_info_text(results + \"\\n\\n\")\n\n            self._append_info_text(\"Try opening the package directly:\\n\")\n            self._append_info_text(query, (\"url\",))\n            return\n\n        for item in results:\n            # self._append_info_text(\"\u2022\")\n            tags = (\"url\",)\n            if item[\"name\"].lower() == query.lower():\n                tags = tags + (\"bold\",)\n\n            self._append_info_text(item[\"name\"], tags)\n            self._append_info_text(\"\\n\")\n            self.info_text.direct_insert(\n                \"end\", item.get(\"description\", \"<No description>\").strip() + \"\\n\"\n            )\n            self._append_info_text(\"\\n\")", "is_method": true, "class_name": "PipDialog", "function_description": "Utility method in PipDialog that formats and displays search results or error messages related to a query, enhancing user interaction by presenting package options or guidance when no results are found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_select_list_item", "line_number": 593, "body": "def _select_list_item(self, name_or_index):\n        if isinstance(name_or_index, int):\n            index = name_or_index\n        else:\n            normalized_items = list(map(self._normalize_name, self.listbox.get(0, \"end\")))\n            try:\n                index = normalized_items.index(self._normalize_name(name_or_index))\n            except Exception:\n                exception(tr(\"Can't find package name from the list:\") + \" \" + name_or_index)\n                return\n\n        old_state = self.listbox[\"state\"]\n        try:\n            self.listbox[\"state\"] = \"normal\"\n            self.listbox.select_clear(0, \"end\")\n            self.listbox.select_set(index)\n            self.listbox.activate(index)\n            self.listbox.see(index)\n        finally:\n            self.listbox[\"state\"] = old_state", "is_method": true, "class_name": "PipDialog", "function_description": "Utility method in PipDialog that selects and highlights an item in a listbox by its name or index, ensuring the corresponding entry is visible and activated for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_install_command", "line_number": 614, "body": "def _get_install_command(self):\n        cmd = [\"install\", \"--no-cache-dir\"]\n        if self._use_user_install():\n            cmd.append(\"--user\")\n        return cmd", "is_method": true, "class_name": "PipDialog", "function_description": "Internal PipDialog method that constructs the base pip install command, optionally including a user install flag based on configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_perform_pip_action", "line_number": 620, "body": "def _perform_pip_action(self, action: str) -> bool:\n        if self._perform_pip_action_without_refresh(action):\n            if action == \"uninstall\":\n                self._show_instructions()  # Make the old package go away as fast as possible\n            self._start_update_list(\n                None if action == \"uninstall\" else self.current_package_data[\"info\"][\"name\"]\n            )\n\n            get_workbench().event_generate(\"RemoteFilesChanged\")", "is_method": true, "class_name": "PipDialog", "function_description": "Performs a specified pip action (install, uninstall, etc.) and triggers related updates and UI refreshes, ensuring package state changes are properly reflected in the environment and interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_perform_pip_action_without_refresh", "line_number": 630, "body": "def _perform_pip_action_without_refresh(self, action: str) -> bool:\n        assert self._get_state() == \"idle\"\n        assert self.current_package_data is not None\n        data = self.current_package_data\n        name = self.current_package_data[\"info\"][\"name\"]\n\n        install_cmd = self._get_install_command()\n\n        if action == \"install\":\n            title = tr(\"Installing '%s'\") % name\n            if not self._confirm_install(self.current_package_data):\n                return False\n\n            args = install_cmd\n            if self._get_active_version(name) is not None:\n                title = tr(\"Upgrading '%s'\") % name\n                args.append(\"--upgrade\")\n\n            args.append(name)\n        elif action == \"uninstall\":\n            title = tr(\"Uninstalling '%s'\") % name\n            if name in [\"pip\", \"setuptools\"] and not messagebox.askyesno(\n                tr(\"Really uninstall?\"),\n                tr(\n                    \"Package '{}' is required for installing and uninstalling other packages.\"\n                ).format(name)\n                + \"\\n\\n\"\n                + tr(\"Are you sure you want to uninstall it?\"),\n                master=self,\n            ):\n                return False\n            args = [\"uninstall\", \"-y\", name]\n        elif action == \"advanced\":\n            title = tr(\"Installing\")\n            details = _ask_installation_details(\n                self,\n                data,\n                _get_latest_stable_version(list(data[\"releases\"].keys())),\n                self.does_support_update_deps_switch(),\n            )\n            if details is None:  # Cancel\n                return False\n\n            version, package_data, upgrade_deps = details\n            if not self._confirm_install(package_data):\n                return False\n\n            args = install_cmd\n            if upgrade_deps:\n                args.append(\"--upgrade\")\n            args.append(name + \"==\" + version)\n        else:\n            raise RuntimeError(\"Unknown action\")\n\n        returncode, _, _ = self._run_pip_with_dialog(args, title=title)\n        return returncode == 0", "is_method": true, "class_name": "PipDialog", "function_description": "Service method of PipDialog that executes package installation, uninstallation, or advanced install actions via pip commands without refreshing the state, providing user confirmations and handling special cases for core packages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "does_support_update_deps_switch", "line_number": 687, "body": "def does_support_update_deps_switch(self):\n        return True", "is_method": true, "class_name": "PipDialog", "function_description": "Indicates whether the PipDialog class supports an option to update dependencies during operations. This enables conditional logic based on dependency update capability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_handle_install_file_click", "line_number": 690, "body": "def _handle_install_file_click(self, event):\n        if self._get_state() != \"idle\":\n            return\n\n        filename = askopenfilename(\n            master=self,\n            filetypes=[(tr(\"Package\"), \".whl .zip .tar.gz\"), (tr(\"all files\"), \".*\")],\n            initialdir=get_workbench().get_local_cwd(),\n            parent=self.winfo_toplevel(),\n        )\n        if filename:  # Note that missing filename may be \"\" or () depending on tkinter version\n            self._install_local_file(filename, False)", "is_method": true, "class_name": "PipDialog", "function_description": "Handles user file selection for package installation by opening a file dialog, then initiates local installation if the system is idle and a valid file is chosen."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_handle_install_requirements_click", "line_number": 703, "body": "def _handle_install_requirements_click(self, event):\n        if self._get_state() != \"idle\":\n            return\n\n        filename = askopenfilename(\n            master=self,\n            filetypes=[(\"requirements\", \".txt\"), (tr(\"all files\"), \".*\")],\n            initialdir=get_workbench().get_local_cwd(),\n            parent=self.winfo_toplevel(),\n        )\n        if filename:  # Note that missing filename may be \"\" or () depending on tkinter version\n            self._install_local_file(filename, True)", "is_method": true, "class_name": "PipDialog", "function_description": "Handles user interaction to select a requirements file and initiates installation of its packages if the system is idle."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_handle_target_directory_click", "line_number": 716, "body": "def _handle_target_directory_click(self, event):\n        if self._get_target_directory():\n            open_path_in_system_file_manager(self._get_target_directory())", "is_method": true, "class_name": "PipDialog", "function_description": "Private method in PipDialog that opens the currently selected target directory in the system's file manager when triggered. It enables quick access to specific directories through user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_install_local_file", "line_number": 720, "body": "def _install_local_file(self, filename, is_requirements_file):\n        args = [\"install\"]\n        if self._use_user_install():\n            args.append(\"--user\")\n        if is_requirements_file:\n            args.append(\"-r\")\n        args.append(filename)\n\n        returncode, out, err = self._run_pip_with_dialog(\n            args, title=tr(\"Installing '%s'\") % os.path.basename(filename)\n        )\n\n        # Try to find out the name of the package we're installing\n        name = None\n\n        # output should include a line like this:\n        # Installing collected packages: pytz, six, python-dateutil, numpy, pandas\n        inst_lines = re.findall(\n            \"^Installing collected packages:.*?$\", out, re.MULTILINE | re.IGNORECASE\n        )  # @UndefinedVariable\n        if len(inst_lines) == 1:\n            # take last element\n            elements = re.split(\",|:\", inst_lines[0])\n            name = elements[-1].strip()\n\n        self._start_update_list(name)", "is_method": true, "class_name": "PipDialog", "function_description": "Handles installation of a local package or requirements file via pip, optionally using user installs, and initiates package list updates based on the installed package name extracted from pip output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_handle_url_click", "line_number": 747, "body": "def _handle_url_click(self, event):\n        url = _extract_click_text(self.info_text, event, \"url\")\n        if url is not None:\n            if url.startswith(\"http:\") or url.startswith(\"https:\"):\n                import webbrowser\n\n                webbrowser.open(url)\n            elif os.path.sep in url:\n                os.makedirs(url, exist_ok=True)\n                open_path_in_system_file_manager(url)\n            else:\n                self._start_show_package_info(url)", "is_method": true, "class_name": "PipDialog", "function_description": "Handles URL clicks within the dialog, opening web URLs in a browser, navigating to local file paths in the system file manager, or displaying package information based on the URL format."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_close", "line_number": 760, "body": "def _on_close(self, event=None):\n        self._closed = True\n        self.destroy()", "is_method": true, "class_name": "PipDialog", "function_description": "Private method of PipDialog that marks the dialog as closed and destroys its interface, handling cleanup when the dialog window is closed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_active_version", "line_number": 764, "body": "def _get_active_version(self, name):\n        dist = self._get_active_dist(name)\n        if dist is None:\n            return None\n        else:\n            return dist[\"version\"]", "is_method": true, "class_name": "PipDialog", "function_description": "Private method in the PipDialog class that retrieves the version string of the currently active distribution for a given package name, returning None if no active distribution exists."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_active_dist", "line_number": 771, "body": "def _get_active_dist(self, name):\n        normname = self._normalize_name(name)\n        for key in self._active_distributions:\n\n            if self._normalize_name(key) == normname:\n                return self._active_distributions[key]\n\n        return None", "is_method": true, "class_name": "PipDialog", "function_description": "Utility method within PipDialog that retrieves an active distribution by normalized name, enabling consistent access to distributions regardless of name formatting differences."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_use_user_install", "line_number": 789, "body": "def _use_user_install(self):\n        return not self._should_install_to_site_packages()", "is_method": true, "class_name": "PipDialog", "function_description": "Core utility method of the PipDialog class that determines whether to use a user-level package installation based on site package installation settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_title", "line_number": 795, "body": "def _get_title(self):\n        return tr(\"Manage packages for %s\") % self._get_interpreter()", "is_method": true, "class_name": "PipDialog", "function_description": "Returns a formatted title string indicating the package management context based on the current interpreter instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_confirm_install", "line_number": 798, "body": "def _confirm_install(self, package_data):\n        return True", "is_method": true, "class_name": "PipDialog", "function_description": "Returns a confirmation for installing a package, always indicating approval. This private method serves as a placeholder or default confirmation in the PipDialog class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_read_only", "line_number": 801, "body": "def _read_only(self):\n        if self._should_install_to_site_packages():\n            return False\n        else:\n            # readonly if not in a virtual environment\n            # and user site packages is disabled\n            import site\n\n            return not site.ENABLE_USER_SITE", "is_method": true, "class_name": "PipDialog", "function_description": "Determines if the environment should be treated as read-only based on installation location and user site package settings, helping configure permissions in package management contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_tweak_search_results", "line_number": 811, "body": "def _tweak_search_results(self, results, query):\n        return results", "is_method": true, "class_name": "PipDialog", "function_description": "Returns search results unchanged; serves as a placeholder for customizing search result processing within PipDialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_extra_switches", "line_number": 814, "body": "def _get_extra_switches(self):\n        result = [\"--disable-pip-version-check\"]\n        proxy = os.environ.get(\"https_proxy\", os.environ.get(\"http_proxy\", None))\n        if proxy:\n            result.append(\"--proxy=\" + proxy)\n\n        return result", "is_method": true, "class_name": "PipDialog", "function_description": "Helper method in PipDialog that gathers additional command-line options for pip, including disabling version checks and applying proxy settings from environment variables."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_update_list", "line_number": 830, "body": "def _start_update_list(self, name_to_show=None):\n        assert self._get_state() in [None, \"idle\"]\n        self._set_state(\"listing\")\n\n        get_workbench().bind(\"get_active_distributions_response\", self._complete_update_list, True)\n        self._last_name_to_show = name_to_show\n        logger.debug(\"Sending get_active_distributions\")\n        get_runner().send_command(InlineCommand(\"get_active_distributions\"))", "is_method": true, "class_name": "BackendPipDialog", "function_description": "Starts updating the active distributions list by setting the dialog to listing state and sending a command to retrieve active distributions. It initiates the update process and binds a response handler to complete it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_complete_update_list", "line_number": 839, "body": "def _complete_update_list(self, msg):\n        if self._closed:\n            return\n\n        get_workbench().unbind(\"get_active_distributions_response\", self._complete_update_list)\n        if \"error\" in msg:\n            self._clear_info_text()\n            self.info_text.direct_insert(\"1.0\", msg[\"error\"])\n            self._set_state(\"idle\", True)\n            return\n\n        self._active_distributions = msg.distributions\n        self._set_state(\"idle\", True)\n        self._update_list(self._last_name_to_show)", "is_method": true, "class_name": "BackendPipDialog", "function_description": "Internal method of BackendPipDialog that processes update responses for active distributions, handling errors and refreshing the state and display list accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_interpreter", "line_number": 860, "body": "def _get_interpreter(self):\n        return get_runner().get_local_executable()", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Private helper method in CPythonBackendPipDialog that retrieves the local Python interpreter executable used by the system's runner environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_create_python_process", "line_number": 863, "body": "def _create_python_process(self, args):\n        proc = running.create_backend_python_process(args, stderr=subprocess.STDOUT)\n        return proc, proc.cmd", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Creates and returns a new backend Python process with specified arguments, providing both the process object and its command line. This supports managing Python subprocesses within the CPythonBackendPipDialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_confirm_install", "line_number": 867, "body": "def _confirm_install(self, package_data):\n        name = package_data[\"info\"][\"name\"]\n\n        if name.lower().startswith(\"thonny\"):\n            return messagebox.askyesno(\n                tr(\"Confirmation\"),\n                tr(\n                    \"Looks like you are installing a Thonny-related package.\\n\"\n                    + \"If you meant to install a Thonny plugin, then you should\\n\"\n                    + \"choose 'Tools \u2192 Manage plugins...' instead\\n\"\n                    + \"\\n\"\n                    + \"Are you sure you want to install %s for the back-end?\"\n                )\n                % name,\n                master=self,\n            )\n        else:\n            return True", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Confirms with the user before installing a package, warning if it's Thonny-related to prevent improper plugin installation. It ensures intentional installation decisions within the CPythonBackendPipDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_target_directory", "line_number": 886, "body": "def _get_target_directory(self):\n        if self._should_install_to_site_packages():\n            return normpath_with_actual_case(self._backend_proxy.get_site_packages())\n        else:\n            usp = self._backend_proxy.get_user_site_packages()\n            if isinstance(self._backend_proxy, CPythonProxy):\n                os.makedirs(usp, exist_ok=True)\n                return normpath_with_actual_case(usp)\n            else:\n                return usp", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Determines the appropriate directory path for package installation based on whether system-wide or user-specific site-packages should be used, ensuring the directory exists and has the correct normalized path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_should_install_to_site_packages", "line_number": 897, "body": "def _should_install_to_site_packages(self):\n        return self._targets_virtual_environment()", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Checks if installation should be performed in site-packages by determining whether the current environment is a virtual environment. This helps decide the appropriate target for package installation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_targets_virtual_environment", "line_number": 900, "body": "def _targets_virtual_environment(self):\n        return get_runner().using_venv()", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Returns whether the current Python execution environment is a virtual environment. This function helps determine if pip operations should target a virtual environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_run_pip_with_dialog", "line_number": 903, "body": "def _run_pip_with_dialog(self, args, title) -> Tuple[int, str, str]:\n        proxy = get_runner().get_backend_proxy()\n        assert isinstance(proxy, CPythonProxy)\n        sub_cmd = [proxy._reported_executable, \"-m\", \"pip\"] + args + self._get_extra_switches()\n        back_cmd = InlineCommand(\"execute_system_command\", cmd_line=sub_cmd)\n        dlg = InlineCommandDialog(\n            self,\n            back_cmd,\n            title=\"pip\",\n            instructions=title,\n            autostart=True,\n            output_prelude=subprocess.list2cmdline(sub_cmd) + \"\\n\\n\",\n        )\n        ui_utils.show_dialog(dlg)\n\n        return dlg.returncode, dlg.stdout, dlg.stderr", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Runs a pip command with a user dialog interface, displaying execution progress and capturing the command's return code, standard output, and error messages. It enables interactive package management operations within a GUI environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_update_list", "line_number": 929, "body": "def _start_update_list(self, name_to_show=None):\n        assert self._get_state() in [None, \"idle\"]\n        import pkg_resources\n\n        pkg_resources._initialize_master_working_set()\n\n        self._active_distributions = {\n            dist.key: {\n                \"project_name\": dist.project_name,\n                \"key\": dist.key,\n                \"location\": dist.location,\n                \"version\": dist.version,\n            }\n            for dist in pkg_resources.working_set  # pylint: disable=not-an-iterable\n        }\n\n        self._update_list(name_to_show)", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Initializes and updates the list of currently installed Python packages with their metadata, preparing the plugin dialog to display or manage package states."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_conflicts_with_thonny_version", "line_number": 947, "body": "def _conflicts_with_thonny_version(self, req_strings):\n        import pkg_resources\n\n        try:\n            conflicts = []\n            for req_string in req_strings:\n                req = pkg_resources.Requirement.parse(req_string)\n                if req.project_name == \"thonny\" and thonny.get_version() not in req:\n                    conflicts.append(req_string)\n\n            return conflicts\n        except Exception:\n            logging.exception(\"Problem computing conflicts\")\n            return None", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Checks if any package requirements conflict with the currently installed Thonny version, returning a list of conflicting requirement strings if found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_interpreter", "line_number": 962, "body": "def _get_interpreter(self):\n        return get_interpreter_for_subprocess(sys.executable)", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Private method of PluginsPipDialog that obtains the Python interpreter configured for subprocess execution, typically to run pip commands within the current Python environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_should_install_to_site_packages", "line_number": 965, "body": "def _should_install_to_site_packages(self):\n        return self._targets_virtual_environment()", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Private method that determines whether packages should be installed to the system site-packages directory based on the target environment being a virtual environment or not."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_targets_virtual_environment", "line_number": 968, "body": "def _targets_virtual_environment(self):\n        # https://stackoverflow.com/a/42580137/261181\n        return (\n            hasattr(sys, \"base_prefix\")\n            and sys.base_prefix != sys.prefix\n            or hasattr(sys, \"real_prefix\")\n            and getattr(sys, \"real_prefix\") != sys.prefix\n        )", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Determines if the current Python interpreter is running inside a virtual environment, enabling environment-aware operations such as dependency management or plugin installation decisions within PluginsPipDialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_confirm_install", "line_number": 977, "body": "def _confirm_install(self, package_data):\n        name = package_data[\"info\"][\"name\"]\n        reqs = package_data[\"info\"].get(\"requires_dist\", None)\n\n        other_version_text = tr(\n            \"NB! There may be another version available \"\n            + \"which is compatible with current Thonny version. \"\n            + \"Click on '...' button to choose the version to install.\"\n        )\n\n        if name.lower().startswith(\"thonny-\") and not reqs:\n            showerror(\n                tr(\"Thonny plugin without requirements\"),\n                tr(\n                    \"Looks like you are trying to install an outdated Thonny\\n\"\n                    + \"plug-in (it doesn't specify required Thonny version).\\n\\n\"\n                    + \"If you still want it, then please install it from the command line.\"\n                )\n                + \"\\n\\n\"\n                + other_version_text,\n                master=self,\n            )\n            return False\n        elif reqs:\n            conflicts = self._conflicts_with_thonny_version(reqs)\n            if conflicts:\n                showerror(\n                    tr(\"Unsuitable requirements\"),\n                    tr(\"This package requires different Thonny version:\")\n                    + \"\\n\\n  \"\n                    + \"\\n  \".join(conflicts)\n                    + \"\\n\\n\"\n                    + tr(\"If you still want it, then please install it from the command line.\")\n                    + \"\\n\\n\"\n                    + other_version_text,\n                    master=self,\n                )\n                return False\n\n        return True", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Core method of PluginsPipDialog that verifies if a plugin package is compatible with the current Thonny version, displaying error dialogs for outdated or conflicting plugin requirements to prevent incompatible installations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_target_directory", "line_number": 1018, "body": "def _get_target_directory(self):\n        if self._use_user_install():\n            import site\n\n            assert hasattr(site, \"getusersitepackages\")\n            os.makedirs(site.getusersitepackages(), exist_ok=True)\n            return normpath_with_actual_case(site.getusersitepackages())\n        else:\n            for d in sys.path:\n                if (\"site-packages\" in d or \"dist-packages\" in d) and path_startswith(\n                    d, sys.prefix\n                ):\n                    return normpath_with_actual_case(d)\n            return None", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Determines the appropriate directory path for plugin installation based on user or system settings, ensuring the target location exists and normalizing its path casing for consistent access."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_create_widgets", "line_number": 1033, "body": "def _create_widgets(self, parent):\n        banner = ttk.Frame(parent, style=\"Tip.TFrame\")\n        banner.grid(row=0, column=0, sticky=\"nsew\")\n\n        banner_msg = (\n            tr(\n                \"This dialog is for managing Thonny plug-ins and their dependencies.\\n\"\n                + \"If you want to install packages for your own programs then choose 'Tools \u2192 Manage packages...'\"\n            )\n            + \"\\n\"\n        )\n\n        runner = get_runner()\n        if (\n            runner is not None\n            and runner.get_local_executable() is not None\n            and is_same_path(self._get_interpreter(), get_runner().get_local_executable())\n        ):\n            banner_msg += (\n                tr(\n                    \"(In this case Thonny's back-end uses same interpreter, so both dialogs manage same packages.)\"\n                )\n                + \"\\n\"\n            )\n\n        banner_msg += \"\\n\" + tr(\n            \"NB! You need to restart Thonny after installing / upgrading / uninstalling a plug-in.\"\n        )\n\n        banner_text = ttk.Label(banner, text=banner_msg, style=\"Tip.TLabel\", justify=\"left\")\n        banner_text.grid(pady=10, padx=10)\n\n        PipDialog._create_widgets(self, parent)", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Creates and configures the graphical interface elements for managing Thonny plug-ins and their dependencies, including informative banners guiding users about interpreter contexts and restart requirements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_title", "line_number": 1067, "body": "def _get_title(self):\n        return tr(\"Thonny plug-ins\")", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Returns the localized title string for the Thonny plug-ins dialog, providing a consistent label for the plugin management interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_run_pip_with_dialog", "line_number": 1070, "body": "def _run_pip_with_dialog(self, args, title) -> Tuple[int, str, str]:\n        args = [\"-m\", \"pip\"] + args + self._get_extra_switches()\n        proc = running.create_frontend_python_process(args, stderr=subprocess.STDOUT)\n        cmd = proc.cmd\n        dlg = SubprocessDialog(self, proc, \"pip\", long_description=title, autostart=True)\n        ui_utils.show_dialog(dlg)\n        return dlg.returncode, dlg.stdout, dlg.stderr", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Runs a pip command in a subprocess with a user interface dialog showing progress and output, returning the command's exit status and output streams. It enables interactive package management operations within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_set_state", "line_number": 1158, "body": "def _set_state(self, state):\n        self._state = state\n        widgets = [\n            self.version_combo,\n            # self.search_box, # looks funny when disabled\n            self.ok_button,\n            self.update_deps_cb,\n        ]\n\n        if state == \"idle\":\n            self.config(cursor=\"\")\n            for widget in widgets:\n                if widget == self.version_combo:\n                    widget.state([\"!disabled\", \"readonly\"])\n                else:\n                    widget[\"state\"] = tk.NORMAL\n        else:\n            self.config(cursor=get_busy_cursor())\n            for widget in widgets:\n                widget[\"state\"] = tk.DISABLED\n\n        if self.version_var.get().strip() == \"\" or not self._version_data:\n            self.ok_button[\"state\"] = tk.DISABLED", "is_method": true, "class_name": "DetailsDialog", "function_description": "Toggles the UI state of DetailsDialog between \"idle\" and busy modes, enabling or disabling specific widgets accordingly to reflect the current interaction status and prevent user input during processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_fetching_version_info", "line_number": 1182, "body": "def _start_fetching_version_info(self):\n        self._set_state(\"busy\")\n        _start_fetching_package_info(\n            self._package_name, self.version_var.get(), self._show_version_info\n        )", "is_method": true, "class_name": "DetailsDialog", "function_description": "Private method of DetailsDialog that initiates fetching version information for a package and updates UI state accordingly to indicate the process is in progress."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_version_info", "line_number": 1188, "body": "def _show_version_info(self, name, info, error_code=None):\n        if self._closed:\n            return\n\n        self._version_data = info\n        if (\n            not error_code\n            and \"requires_dist\" in info[\"info\"]\n            and isinstance(info[\"info\"][\"requires_dist\"], list)\n        ):\n            reqs = tr(\"Requires:\") + \"\\n  * \" + \"\\n  * \".join(info[\"info\"][\"requires_dist\"])\n        elif error_code:\n            reqs = tr(\"Error code:\") + \" \" + str(error_code)\n            if \"error\" in info:\n                reqs += \"\\n\" + tr(\"Error:\") + \" \" + info[\"error\"]\n        else:\n            reqs = \"\"\n\n        self.requires_label.configure(text=reqs)\n        self._set_state(\"idle\")", "is_method": true, "class_name": "DetailsDialog", "function_description": "Displays version and dependency information or error details in the DetailsDialog, updating the UI accordingly for user reference. It manages presentation of package requirements or error messages based on provided metadata."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_ok", "line_number": 1209, "body": "def _ok(self, event=None):\n        self.result = (self.version_var.get(), self._version_data, bool(self.update_deps_var.get()))\n        self._closed = True\n        self.destroy()", "is_method": true, "class_name": "DetailsDialog", "function_description": "Sets dialog result with version details and user choices, then closes the DetailsDialog window. It provides a way to finalize and capture user input from the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_cancel", "line_number": 1214, "body": "def _cancel(self, event=None):\n        self.result = None\n        self._closed = True\n        self.destroy()", "is_method": true, "class_name": "DetailsDialog", "function_description": "Private method of DetailsDialog that handles dialog cancellation by setting the result to None, marking it closed, and closing the dialog window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_class", "line_number": 1316, "body": "def get_class(attrs):\n        for name, value in attrs:\n            if name == \"class\":\n                return value\n\n        return None", "is_method": false, "function_description": "Function that scans attribute pairs and returns the value of the first attribute named \"class,\" or None if not found; useful for extracting CSS class names from HTML-like attribute lists."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_pip_gui_class", "line_number": 1376, "body": "def get_pip_gui_class():\n        proxy = get_runner().get_backend_proxy()\n        if proxy is None:\n            return None\n        return proxy.get_pip_gui_class()", "is_method": false, "function_description": "Returns the PIP GUI class from the backend proxy of the current runner, or None if no proxy is available. It provides access to the graphical interface component associated with the pipeline execution environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "open_backend_pip_gui", "line_number": 1382, "body": "def open_backend_pip_gui(*args):\n        pg_class = get_pip_gui_class()\n        if pg_class is None:\n            showerror(tr(\"Not supported\"), get_not_supported_translation())\n            return\n\n        if not get_runner().is_waiting_toplevel_command():\n            showerror(\n                tr(\"Not available\"),\n                tr(\"You need to stop your program before launching the package manager.\"),\n                master=get_workbench(),\n            )\n            return\n\n        pg = pg_class(get_workbench())\n        ui_utils.show_dialog(pg)", "is_method": false, "function_description": "Function that opens the backend package manager GUI if supported and the program is idle, providing users an interface to manage Python packages within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "open_backend_pip_gui_enabled", "line_number": 1399, "body": "def open_backend_pip_gui_enabled():\n        return get_pip_gui_class() is not None", "is_method": false, "function_description": "This function checks whether the backend GUI for pip is available and enabled. It serves as a simple indicator for other functions to determine if pip GUI features can be used."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "open_frontend_pip_gui", "line_number": 1402, "body": "def open_frontend_pip_gui(*args):\n        pg = PluginsPipDialog(get_workbench())\n        ui_utils.show_dialog(pg)", "is_method": false, "function_description": "Opens and displays a plugin installation dialog within the application's frontend, facilitating user interaction for managing plugins via a graphical interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "write", "line_number": 477, "body": "def write(s, tag=None):\n            if tag is None:\n                tags = ()\n            else:\n                tags = (tag,)\n            self._append_info_text(s, tags)", "is_method": true, "class_name": "PipDialog", "function_description": "Core method of the PipDialog class that appends text with optional tagging to the dialog's information display, supporting organized and categorized message output within the dialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "write_att", "line_number": 484, "body": "def write_att(caption, value, value_tag=None):\n            write(caption + \": \", \"caption\")\n            write(value, value_tag)\n            write(\"\\n\")", "is_method": true, "class_name": "PipDialog", "function_description": "Utility method of the PipDialog class that formats and outputs a labeled value with optional styling, facilitating structured dialog display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "version_sort_key", "line_number": 1102, "body": "def version_sort_key(s):\n            # Trying to massage understandable versions into valid StrictVersions\n            if s.replace(\".\", \"\").isnumeric():  # stable release\n                s2 = s + \"b999\"  # make it latest beta version\n            elif \"rc\" in s:\n                s2 = s.replace(\"rc\", \"b8\")\n            else:\n                s2 = s\n            try:\n                return StrictVersion(s2)\n            except Exception:\n                # use only numbers\n                nums = re.findall(r\"\\d+\", s)\n                while len(nums) < 2:\n                    nums.append(\"0\")\n                return StrictVersion(\".\".join(nums[:3]))", "is_method": true, "class_name": "DetailsDialog", "function_description": "Provides a sorting key function that converts version strings into comparable StrictVersion objects, handling numeric, release candidate, and other version formats for accurate version sorting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "handle_starttag", "line_number": 1332, "body": "def handle_starttag(self, tag, attrs):\n            if tag == \"a\" and get_class(attrs) == \"package-snippet\":\n                self.results.append({})\n\n            if tag in (\"span\", \"p\"):\n                tag_class = get_class(attrs)\n                if tag_class in (\"package-snippet__name\", \"package-snippet__description\"):\n                    self.active_class = tag_class\n                else:\n                    self.active_class = None\n            else:\n                self.active_class = None", "is_method": true, "class_name": "PypiSearchResultsParser", "function_description": "Method of PypiSearchResultsParser that identifies relevant HTML tags during parsing to initialize result entries and track which package snippet attributes are currently being processed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "handle_data", "line_number": 1345, "body": "def handle_data(self, data):\n            if self.active_class is not None:\n                att_name = self.active_class[len(class_prefix) :]\n                self.results[-1][att_name] = data", "is_method": true, "class_name": "PypiSearchResultsParser", "function_description": "Parses and stores data corresponding to an active class attribute in the latest search result entry, enabling structured extraction of PyPI search result details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "handle_endtag", "line_number": 1350, "body": "def handle_endtag(self, tag):\n            self.active_class = None", "is_method": true, "class_name": "PypiSearchResultsParser", "function_description": "Clears the active CSS class marker when an HTML end tag is encountered during parsing. This supports managing the parsing state within the PypiSearchResultsParser class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "update_highlighting", "line_number": 329, "body": "def update_highlighting(event):\n    if not get_workbench().ready:\n        # don't slow down loading process\n        return\n\n    global tree\n    if not tree:\n        # using lazy importing to speed up Thonny loading\n        from parso.python import tree  # pylint: disable=redefined-outer-name\n\n    assert isinstance(event.widget, tk.Text)\n    text = event.widget\n\n    if not hasattr(text, \"name_highlighter\"):\n        text.name_highlighter = VariablesHighlighter(text)\n        # Alternatives:\n        # NB! usages() is too slow when used on library names\n        # text.name_highlighter = CombinedHighlighter(text)\n        # text.name_highlighter = UsagesHighlighter(text)\n\n    text.name_highlighter.schedule_update()", "is_method": false, "function_description": "Function that updates syntax or variable highlighting in a text widget, initializing and scheduling a highlighter if needed, to enhance code visibility and editing experience in an interactive workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "load_plugin", "line_number": 352, "body": "def load_plugin() -> None:\n    wb = get_workbench()\n    wb.set_default(\"view.name_highlighting\", False)\n    wb.bind_class(\"CodeViewText\", \"<<CursorMove>>\", update_highlighting, True)\n    wb.bind_class(\"CodeViewText\", \"<<TextChange>>\", update_highlighting, True)\n    wb.bind(\"<<UpdateAppearance>>\", update_highlighting, True)", "is_method": false, "function_description": "This function initializes a plugin by configuring the workbench's default settings and event bindings to enable dynamic text highlighting updates within the code view environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "get_positions", "line_number": 19, "body": "def get_positions(self):\n        index = self.text.index(\"insert\")\n\n        # ignore if cursor in open string\n        if self.text.tag_prevrange(\"open_string\", index) or self.text.tag_prevrange(\n            \"open_string3\", index\n        ):\n\n            return set()\n\n        source = self.text.get(\"1.0\", \"end\")\n        index_parts = index.split(\".\")\n        line, column = int(index_parts[0]), int(index_parts[1])\n\n        return self.get_positions_for(source, line, column)", "is_method": true, "class_name": "BaseNameHighlighter", "function_description": "Method of BaseNameHighlighter that identifies positions related to the keyword \"insert\" in text, ignoring occurrences inside open strings, useful for syntax highlighting or code analysis near that keyword."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "schedule_update", "line_number": 35, "body": "def schedule_update(self):\n        def perform_update():\n            try:\n                self.update()\n            finally:\n                self._update_scheduled = False\n\n        if not self._update_scheduled:\n            self._update_scheduled = True\n            self.text.after_idle(perform_update)", "is_method": true, "class_name": "BaseNameHighlighter", "function_description": "Core utility method of the BaseNameHighlighter class that schedules a deferred update operation to run when the system is idle, ensuring that updates do not overlap or repeat unnecessarily."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "update", "line_number": 46, "body": "def update(self):\n        self.text.tag_remove(\"matched_name\", \"1.0\", \"end\")\n\n        if get_workbench().get_option(\"view.name_highlighting\") and self.text.is_python_text():\n            try:\n                positions = self.get_positions()\n                if len(positions) > 1:\n                    for pos in positions:\n                        start_index, end_index = pos[0], pos[1]\n                        self.text.tag_add(\"matched_name\", start_index, end_index)\n            except Exception as e:\n                logger.exception(\"Problem when updating name highlighting\", exc_info=e)", "is_method": true, "class_name": "BaseNameHighlighter", "function_description": "Removes existing name highlights and, if enabled and applicable, applies highlighting to all detected name occurrences in Python text to visually emphasize them in the editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_is_name_function_call_name", "line_number": 64, "body": "def _is_name_function_call_name(self, name):\n        stmt = name.get_definition()\n        return stmt.type == \"power\" and stmt.children[0] == name", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Private helper method in VariablesHighlighter that determines if a given name corresponds to a function call by checking its definition structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_is_name_function_definition", "line_number": 68, "body": "def _is_name_function_definition(self, name):\n        scope = name.get_definition()\n        return (\n            isinstance(scope, tree.Function)\n            and hasattr(scope.children[1], \"value\")\n            and scope.children[1].value == name.value\n        )", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Internal method of VariablesHighlighter that checks if a given name corresponds to a function definition with a matching identifier, helping to distinguish function names within code analysis tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_get_def_from_function_params", "line_number": 76, "body": "def _get_def_from_function_params(self, func_node, name):\n        params = func_node.get_params()\n        for param in params:\n            if param.children[0].value == name.value:\n                return param.children[0]\n        return None", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Utility method in VariablesHighlighter that locates and returns a parameter node matching a given name within a function's parameter list. It supports identifying specific function parameters by name for further processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_get_statement_for_position", "line_number": 84, "body": "def _get_statement_for_position(self, node, pos):\n        for c in node.children:\n            # sorted here, because the end_pos property depends on the last child having the last position,\n            # there seems to be a problem with jedi, where the children of a node are not always in the right order\n            if isinstance(c, tree.Class):\n                c.children.sort(key=lambda x: x.end_pos)\n            if c.start_pos <= pos <= c.end_pos:\n                if c.type not in (\"decorated\", \"simple_stmt\", \"suite\") and not isinstance(\n                    c, (tree.Flow, tree.ClassOrFunc)\n                ):\n                    return c\n                else:\n                    try:\n                        return jedi_utils.get_statement_of_position(c, pos)\n                    except AttributeError as e:\n                        logger.exception(\"Could not get statement of position\", exc_info=e)\n        return None", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Utility method in VariablesHighlighter that identifies and returns the syntax node representing the statement at a specific position within a code structure, supporting precise code analysis or highlighting tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_is_global_stmt_with_name", "line_number": 102, "body": "def _is_global_stmt_with_name(self, node, name_str):\n        return (\n            isinstance(node, tree.BaseNode)\n            and node.type == \"simple_stmt\"\n            and isinstance(node.children[0], tree.GlobalStmt)\n            and node.children[0].children[1].value == name_str\n        )", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Helper method in VariablesHighlighter that checks if a given syntax tree node represents a global statement declaring a specific variable name. It assists in identifying global variable declarations within the code structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_find_definition", "line_number": 110, "body": "def _find_definition(self, scope, name):\n        from jedi import parser_utils\n\n        # if the name is the name of a function definition\n        if isinstance(scope, tree.Function):\n            if scope.children[1] == name:\n                return scope.children[1]  # 0th child is keyword \"def\", 1st is name\n            else:\n                definition = self._get_def_from_function_params(scope, name)\n                if definition:\n                    return definition\n\n        for c in scope.children:\n            if (\n                isinstance(c, tree.BaseNode)\n                and c.type == \"simple_stmt\"\n                and isinstance(c.children[0], tree.ImportName)\n            ):\n                for n in c.children[0].get_defined_names():\n                    if n.value == name.value:\n                        return n\n                # print(c.path_for_name(name.value))\n            if (\n                isinstance(c, tree.Function)\n                and c.children[1].value == name.value\n                and not isinstance(parser_utils.get_parent_scope(c), tree.Class)\n            ):\n                return c.children[1]\n            if isinstance(c, tree.BaseNode) and c.type == \"suite\":\n                for x in c.children:\n                    if self._is_global_stmt_with_name(x, name.value):\n                        return self._find_definition(parser_utils.get_parent_scope(scope), name)\n                    if isinstance(x, tree.Name) and x.is_definition() and x.value == name.value:\n                        return x\n                    def_candidate = self._find_def_in_simple_node(x, name)\n                    if def_candidate:\n                        return def_candidate\n\n        if not isinstance(scope, tree.Module):\n            return self._find_definition(parser_utils.get_parent_scope(scope), name)\n\n        # if name itself is the left side of an assignment statement, then the name is the definition\n        if name.is_definition():\n            return name\n\n        return None", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Core method of VariablesHighlighter that locates the definition of a variable or function name within a given scope by recursively analyzing syntax tree nodes and accounting for function parameters, imports, and global statements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_find_def_in_simple_node", "line_number": 157, "body": "def _find_def_in_simple_node(self, node, name):\n        if isinstance(node, tree.Name) and node.is_definition() and node.value == name.value:\n            return name\n        if not isinstance(node, tree.BaseNode):\n            return None\n        for c in node.children:\n            return self._find_def_in_simple_node(c, name)", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Helper method in VariablesHighlighter that searches through a syntax tree node to find a definition matching a given name, supporting variable definition identification during code analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_get_dot_names", "line_number": 165, "body": "def _get_dot_names(self, stmt):\n        try:\n            if (\n                hasattr(stmt, \"children\")\n                and len(stmt.children) >= 2\n                and hasattr(stmt.children[1], \"children\")\n                and len(stmt.children[1].children) >= 1\n                and hasattr(stmt.children[1].children[0], \"value\")\n                and stmt.children[1].children[0].value == \".\"\n            ):\n                return stmt.children[0], stmt.children[1].children[1]\n        except Exception as e:\n            logger.exception(\"_get_dot_names\", exc_info=e)\n            return ()\n        return ()", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Private helper method in VariablesHighlighter that identifies and returns components involved in a dot notation expression (e.g., object.attribute) within a statement node. Useful for parsing and highlighting variable accesses in code analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_find_usages", "line_number": 181, "body": "def _find_usages(self, name, stmt):\n        from jedi import parser_utils\n\n        # check if stmt is dot qualified, disregard these\n        dot_names = self._get_dot_names(stmt)\n        if len(dot_names) > 1 and dot_names[1].value == name.value:\n            return set()\n\n        # search for definition\n        definition = self._find_definition(parser_utils.get_parent_scope(name), name)\n\n        searched_scopes = set()\n\n        is_function_definition = (\n            self._is_name_function_definition(definition) if definition else False\n        )\n\n        def find_usages_in_node(node, global_encountered=False):\n            names = []\n            if isinstance(node, tree.BaseNode):\n                if parser_utils.is_scope(node):\n                    global_encountered = False\n                    if node in searched_scopes:\n                        return names\n                    searched_scopes.add(node)\n                    if isinstance(node, tree.Function):\n                        d = self._get_def_from_function_params(node, name)\n                        if d and d != definition:\n                            return []\n\n                for c in node.children:\n                    dot_names = self._get_dot_names(c)\n                    if len(dot_names) > 1 and dot_names[1].value == name.value:\n                        continue\n                    sub_result = find_usages_in_node(c, global_encountered=global_encountered)\n\n                    if sub_result is None:\n                        if not parser_utils.is_scope(node):\n                            return (\n                                None\n                                if definition and node != parser_utils.get_parent_scope(definition)\n                                else [definition]\n                            )\n                        else:\n                            sub_result = []\n                    names.extend(sub_result)\n                    if self._is_global_stmt_with_name(c, name.value):\n                        global_encountered = True\n            elif isinstance(node, tree.Name) and node.value == name.value:\n                if definition and definition != node:\n                    if self._is_name_function_definition(node):\n                        if isinstance(\n                            parser_utils.get_parent_scope(parser_utils.get_parent_scope(node)),\n                            tree.Class,\n                        ):\n                            return []\n                        else:\n                            return None\n                    if (\n                        node.is_definition()\n                        and not global_encountered\n                        and (\n                            is_function_definition\n                            or parser_utils.get_parent_scope(node)\n                            != parser_utils.get_parent_scope(definition)\n                        )\n                    ):\n                        return None\n                    if self._is_name_function_definition(definition) and isinstance(\n                        parser_utils.get_parent_scope(parser_utils.get_parent_scope(definition)),\n                        tree.Class,\n                    ):\n                        return None\n                names.append(node)\n            return names\n\n        if definition:\n            if self._is_name_function_definition(definition):\n                scope = parser_utils.get_parent_scope(parser_utils.get_parent_scope(definition))\n            else:\n                scope = parser_utils.get_parent_scope(definition)\n        else:\n            scope = parser_utils.get_parent_scope(name)\n\n        usages = find_usages_in_node(scope)\n        return usages", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Utility method of VariablesHighlighter that finds all usage occurrences of a given variable name within its relevant code scope, enabling tracking of variable references for features like highlighting or analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "get_positions_for", "line_number": 268, "body": "def get_positions_for(self, source, line, column):\n        module_node = jedi_utils.parse_source(source)\n        pos = (line, column)\n        stmt = self._get_statement_for_position(module_node, pos)\n\n        name = None\n        if isinstance(stmt, tree.Name):\n            name = stmt\n        elif isinstance(stmt, tree.BaseNode):\n            name = stmt.get_name_of_position(pos)\n\n        if not name:\n            return set()\n\n        # format usage positions as tkinter text widget indices\n        return set(\n            (\n                \"%d.%d\" % (usage.start_pos[0], usage.start_pos[1]),\n                \"%d.%d\" % (usage.start_pos[0], usage.start_pos[1] + len(name.value)),\n            )\n            for usage in self._find_usages(name, stmt)\n        )", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Provides the positions of all usages of a variable located at a specific line and column in the source code, formatted for highlighting in a tkinter text widget. Useful for variable occurrence highlighting and code navigation features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "get_positions_for", "line_number": 303, "body": "def get_positions_for(self, source, line, column):\n        # https://github.com/davidhalter/jedi/issues/897\n        from jedi import Script\n\n        script = Script(source + \")\")\n        usages = script.get_references(line, column, include_builtins=False)\n\n        result = {\n            (\n                \"%d.%d\" % (usage.line, usage.column),\n                \"%d.%d\" % (usage.line, usage.column + len(usage.name)),\n            )\n            for usage in usages\n            if usage.module_name == \"\"\n        }\n\n        return result", "is_method": true, "class_name": "UsagesHighlighter", "function_description": "Method of UsagesHighlighter that identifies all positions in a source code where a symbol at a given line and column is referenced, excluding built-in modules, to support code analysis or highlighting features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "get_positions_for", "line_number": 323, "body": "def get_positions_for(self, source, line, column):\n        usages = UsagesHighlighter.get_positions_for(self, source, line, column)\n        variables = VariablesHighlighter.get_positions_for(self, source, line, column)\n        return usages | variables", "is_method": true, "class_name": "CombinedHighlighter", "function_description": "Method of CombinedHighlighter that aggregates highlight positions by combining usage and variable highlights at a given source location, supporting comprehensive code element identification for tools like code editors or analyzers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "perform_update", "line_number": 36, "body": "def perform_update():\n            try:\n                self.update()\n            finally:\n                self._update_scheduled = False", "is_method": true, "class_name": "BaseNameHighlighter", "function_description": "Resets the update scheduling flag after attempting to perform an update operation within the BaseNameHighlighter class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "find_usages_in_node", "line_number": 198, "body": "def find_usages_in_node(node, global_encountered=False):\n            names = []\n            if isinstance(node, tree.BaseNode):\n                if parser_utils.is_scope(node):\n                    global_encountered = False\n                    if node in searched_scopes:\n                        return names\n                    searched_scopes.add(node)\n                    if isinstance(node, tree.Function):\n                        d = self._get_def_from_function_params(node, name)\n                        if d and d != definition:\n                            return []\n\n                for c in node.children:\n                    dot_names = self._get_dot_names(c)\n                    if len(dot_names) > 1 and dot_names[1].value == name.value:\n                        continue\n                    sub_result = find_usages_in_node(c, global_encountered=global_encountered)\n\n                    if sub_result is None:\n                        if not parser_utils.is_scope(node):\n                            return (\n                                None\n                                if definition and node != parser_utils.get_parent_scope(definition)\n                                else [definition]\n                            )\n                        else:\n                            sub_result = []\n                    names.extend(sub_result)\n                    if self._is_global_stmt_with_name(c, name.value):\n                        global_encountered = True\n            elif isinstance(node, tree.Name) and node.value == name.value:\n                if definition and definition != node:\n                    if self._is_name_function_definition(node):\n                        if isinstance(\n                            parser_utils.get_parent_scope(parser_utils.get_parent_scope(node)),\n                            tree.Class,\n                        ):\n                            return []\n                        else:\n                            return None\n                    if (\n                        node.is_definition()\n                        and not global_encountered\n                        and (\n                            is_function_definition\n                            or parser_utils.get_parent_scope(node)\n                            != parser_utils.get_parent_scope(definition)\n                        )\n                    ):\n                        return None\n                    if self._is_name_function_definition(definition) and isinstance(\n                        parser_utils.get_parent_scope(parser_utils.get_parent_scope(definition)),\n                        tree.Class,\n                    ):\n                        return None\n                names.append(node)\n            return names", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Core method of VariablesHighlighter that recursively identifies all usages of a variable within a given syntax node, respecting scope and global declarations. It supports precise variable reference tracking for code analysis and highlighting purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "load_plugin", "line_number": 137, "body": "def load_plugin() -> None:\n    get_workbench().add_view(VariablesView, tr(\"Variables\"), \"ne\", default_position_key=\"AAA\")", "is_method": false, "function_description": "Adds a Variables view panel to the workbench interface, integrating variable inspection into the user environment. This enables users to interact with variables within the application workspace."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_update_back_button", "line_number": 33, "body": "def _update_back_button(self, visible):\n        if visible:\n            assert self._last_active_info is not None\n            self.back_button.configure(text=tr(\"Back to\\n%s\") % self._last_active_info[-1])\n            self.back_button.place(relx=1, x=-5, y=5, anchor=\"ne\")\n        else:\n            self.back_button.place_forget()", "is_method": true, "class_name": "VariablesView", "function_description": "Updates the visibility and label of the back button based on the given flag, providing a way to navigate back to the last active variable context in the VariablesView interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_handle_back_button", "line_number": 41, "body": "def _handle_back_button(self):\n        assert self._last_active_info is not None\n        if len(self._last_active_info) == 2:\n            self.show_globals(*self._last_active_info)\n        else:\n            assert len(self._last_active_info) == 4\n            self.show_frame_variables(*self._last_active_info)", "is_method": true, "class_name": "VariablesView", "function_description": "Core method of VariablesView that handles navigation to the previous variable scope by restoring either global or frame-specific variables based on saved state information. It supports backward navigation within variable views."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_handle_backend_restart", "line_number": 49, "body": "def _handle_backend_restart(self, event):\n        self._clear_tree()", "is_method": true, "class_name": "VariablesView", "function_description": "Handles backend restart events by clearing the current variable view tree to ensure the interface stays updated and consistent after a restart."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_handle_get_globals_response", "line_number": 52, "body": "def _handle_get_globals_response(self, event):\n        if \"error\" in event:\n            self._clear_tree()\n            messagebox.showerror(\"Error querying global variables\", event[\"error\"], master=self)\n        elif \"globals\" not in event:\n            self._clear_tree()\n            messagebox.showerror(\"Error querying global variables\", str(event), master=self)\n        else:\n            self.show_globals(event[\"globals\"], event[\"module_name\"])", "is_method": true, "class_name": "VariablesView", "function_description": "Handles the response from a global variables query by refreshing the variable view or displaying error messages based on the event content. It supports updating the displayed globals within the VariablesView context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_handle_toplevel_response", "line_number": 62, "body": "def _handle_toplevel_response(self, event):\n        if \"globals\" in event:\n            self.show_globals(event[\"globals\"], \"__main__\")\n        else:\n            # MicroPython\n            get_runner().send_command(InlineCommand(\"get_globals\", module_name=\"__main__\"))", "is_method": true, "class_name": "VariablesView", "function_description": "Handles top-level events by displaying global variables if available, otherwise requests them; enables viewing or refreshing the global variable context in a debugging or runtime inspection environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "show_globals", "line_number": 69, "body": "def show_globals(self, globals_, module_name, is_active=True):\n        # TODO: update only if something has changed\n        self.update_variables(globals_)\n        if module_name == \"__main__\":\n            self._set_tab_caption(tr(\"Variables\"))\n        else:\n            self._set_tab_caption(tr(\"Variables\") + \" (%s)\" % module_name)\n\n        if is_active:\n            self._last_active_info = (globals_, module_name)\n\n        self._update_back_button(not is_active)", "is_method": true, "class_name": "VariablesView", "function_description": "Provides an updated view of global variables for a given module, adjusting the display title and activation state. It helps manage and present variable information contextually within the VariablesView interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "show_frame_variables", "line_number": 82, "body": "def show_frame_variables(self, locals_, globals_, freevars, frame_name, is_active=True):\n        # TODO: update only if something has changed\n        actual_locals = {}\n        nonlocals = {}\n        for name in locals_:\n            if name in freevars:\n                nonlocals[name] = locals_[name]\n            else:\n                actual_locals[name] = locals_[name]\n\n        groups = [(\"LOCALS\", actual_locals), (\"GLOBALS\", globals_)]\n        if nonlocals:\n            groups.insert(1, (\"NONLOCALS\", nonlocals))\n\n        self.update_variables(groups)\n        self._set_tab_caption(\"Variables (%s)\" % frame_name)\n\n        if is_active:\n            self._last_active_info = (locals_, globals_, freevars, frame_name)\n\n        self._update_back_button(not is_active)", "is_method": true, "class_name": "VariablesView", "function_description": "This method of VariablesView organizes and displays local, global, and nonlocal variables from a code frame, updating the view with variable groups and managing UI state based on frame activity. It supports visualizing variable scopes during debugging or code inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_handle_frame_info_event", "line_number": 104, "body": "def _handle_frame_info_event(self, frame_info):\n        if frame_info.get(\"error\"):\n            \"probably non-existent frame\"\n            return\n        else:\n            is_active = frame_info[\n                \"location\"\n            ] == \"stack\" or (  # same __main__ globals can be in different frames\n                frame_info[\"code_name\"] == \"<module>\"\n                and frame_info[\"module_name\"] == \"__main__\"\n                and self._last_active_info[-1] == \"__main__\"\n                and self._last_active_info[0] == frame_info[\"globals\"]\n            )\n\n            if frame_info[\"code_name\"] == \"<module>\":\n                self.show_globals(frame_info[\"globals\"], frame_info[\"module_name\"], is_active)\n            else:\n                self.show_frame_variables(\n                    frame_info[\"locals\"],\n                    frame_info[\"globals\"],\n                    frame_info[\"freevars\"],\n                    frame_info[\"code_name\"],\n                    is_active,\n                )", "is_method": true, "class_name": "VariablesView", "function_description": "Processes frame information events to update the display of global or local variables based on the frame's context and activity status within the VariablesView class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_set_tab_caption", "line_number": 129, "body": "def _set_tab_caption(self, text):\n        # pylint: disable=no-member\n        if self.hidden:\n            return\n\n        self.home_widget.master.tab(self.home_widget, text=text)", "is_method": true, "class_name": "VariablesView", "function_description": "Sets the caption text of a visible tab in the VariablesView interface, updating its display label dynamically when the tab is not hidden."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "load_plugin", "line_number": 146, "body": "def load_plugin():\n    get_workbench().set_default(\"ssh.host\", \"\")\n    get_workbench().set_default(\"ssh.user\", \"\")\n    get_workbench().set_default(\"ssh.auth_method\", \"password\")\n    get_workbench().set_default(\"ssh.executable\", \"python3\")\n    get_workbench().set_default(\"ssh.cwd\", \"~\")\n    get_workbench().add_backend(\n        \"SSHProxy\", SshCPythonProxy, tr(\"Remote Python 3 (SSH)\"), SshProxyConfigPage, sort_key=\"15\"\n    )", "is_method": false, "function_description": "Initializes and configures the SSH plugin by setting default SSH connection parameters and registering the SSH backend for remote Python 3 execution within the workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "_get_launcher_with_args", "line_number": 20, "body": "def _get_launcher_with_args(self):\n        return [\n            \"-m\",\n            \"thonny.plugins.cpython_ssh\",\n            repr(\n                {\n                    \"host\": self._host,\n                    \"user\": self._user,\n                    \"password\": get_ssh_password(\"ssh\"),\n                    \"interpreter\": self._remote_interpreter,\n                    \"cwd\": self._get_initial_cwd(),\n                }\n            ),\n        ]", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Internal method of SshCPythonProxy that constructs the command-line argument list to launch a remote Python process over SSH with specific connection and environment settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "_get_initial_cwd", "line_number": 38, "body": "def _get_initial_cwd(self):\n        return get_workbench().get_option(\"ssh.cwd\")", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Returns the initial working directory path configured for an SSH session, enabling consistent environment setup when establishing remote connections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "_publish_cwd", "line_number": 41, "body": "def _publish_cwd(self, cwd):\n        return get_workbench().set_option(\"ssh.cwd\", cwd)", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Sets the current working directory option for the SSH session within the workbench environment, allowing other components to access or update the SSH session's active directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "interrupt", "line_number": 44, "body": "def interrupt(self):\n        # Don't interrupt local process, but direct it to device\n        self._send_msg(ImmediateCommand(\"interrupt\"))", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Interrupts the remote process managed by the SshCPythonProxy by sending an immediate interrupt command to the connected device, without affecting the local process. This enables controlled interruption of code execution on the remote device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "fetch_next_message", "line_number": 48, "body": "def fetch_next_message(self):\n        msg = super().fetch_next_message()\n        if msg and \"welcome_text\" in msg:\n            assert hasattr(self, \"_reported_executable\")\n            msg[\"welcome_text\"] += \" (\" + self._reported_executable + \" on \" + self._host + \")\"\n        return msg", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Method in SshCPythonProxy that retrieves the next incoming message, appending execution context info to any welcome text for enhanced identification or debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "supports_remote_files", "line_number": 55, "body": "def supports_remote_files(self):\n        return self._proc is not None", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Indicates whether a remote process is active, determining if remote file operations are supported. This helps manage capabilities based on the remote connection state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "uses_local_filesystem", "line_number": 58, "body": "def uses_local_filesystem(self):\n        return False", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Indicates whether the proxy uses the local filesystem, explicitly returning False to denote remote file access. Useful for distinguishing between local and remote file handling within the SshCPythonProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "ready_for_remote_file_operations", "line_number": 61, "body": "def ready_for_remote_file_operations(self):\n        return self._proc is not None and get_runner().is_waiting_toplevel_command()", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Indicates whether the proxy is prepared to execute remote file operations by checking if its process is active and the command runner is awaiting a new top-level command. This helps coordinate safe remote interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "supports_remote_directories", "line_number": 64, "body": "def supports_remote_directories(self):\n        return self._cwd is not None and self._cwd != \"\"", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Returns whether the current working directory on the remote system is set, indicating support for remote directory operations. This helps determine if remote file path functionality is available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "supports_trash", "line_number": 67, "body": "def supports_trash(self):\n        return False", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Indicates whether the SSH Python proxy supports trash or recycle bin functionality. Always returns False, showing this feature is not available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "is_connected", "line_number": 70, "body": "def is_connected(self):\n        return self._proc is not None", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Checks if the SshCPythonProxy currently has an active connection by verifying the existence of its internal process. This method helps determine connectivity status for SSH-based operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "_show_error", "line_number": 73, "body": "def _show_error(self, text):\n        get_shell().print_error(\"\\n\" + text + \"\\n\")", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Private helper method in SshCPythonProxy that displays error messages to the user via the shell interface. It provides a standardized way to present errors within the class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "disconnect", "line_number": 76, "body": "def disconnect(self):\n        self.destroy()", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Terminates the SSH connection managed by the proxy by invoking its cleanup process, ensuring all related resources are properly released."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "get_node_label", "line_number": 79, "body": "def get_node_label(self):\n        return self._host", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Returns the hostname label of the SSH proxy node. This method provides a simple way to identify the node associated with the proxy instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "get_exe_dirs", "line_number": 82, "body": "def get_exe_dirs(self):\n        return []", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Returns an empty list representing executable directories. This placeholder method indicates no executable directories are available or configured."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "destroy", "line_number": 85, "body": "def destroy(self):\n        try:\n            self.send_command(ImmediateCommand(\"kill\"))\n        except BrokenPipeError:\n            pass\n        except OSError:\n            pass\n        super().destroy()", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Terminates the SSH proxy connection by sending a kill command and handling potential disconnection errors to ensure cleanup. Provides a reliable way to close the proxy session gracefully."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "can_run_remote_files", "line_number": 94, "body": "def can_run_remote_files(self):\n        return True", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Indicates whether the SSH Python proxy supports executing files remotely. This capability check helps clients determine if remote file execution is feasible through this proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "can_run_local_files", "line_number": 97, "body": "def can_run_local_files(self):\n        return False", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Indicates whether the proxy supports running local files; for this SSH-based proxy, it always returns False, signaling no local file execution capability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "should_show_in_switcher", "line_number": 101, "body": "def should_show_in_switcher(cls):\n        # Show when the executable, user and host are configured\n        return (\n            get_workbench().get_option(\"ssh.host\")\n            and get_workbench().get_option(\"ssh.user\")\n            and get_workbench().get_option(\"ssh.executable\")\n        )", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Determines if the SSH proxy should appear in a switcher interface based on the presence of configured executable, user, and host settings. This enables conditional UI presentation depending on SSH connection readiness."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "get_switcher_entries", "line_number": 110, "body": "def get_switcher_entries(cls):\n        if cls.should_show_in_switcher():\n            return [(cls.get_current_switcher_configuration(), cls.backend_description)]\n        else:\n            return []", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "This method provides switcher entries for a class if enabled, returning configuration and backend details. It supports dynamic backend selection or configuration display within the SshCPythonProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "get_pip_gui_class", "line_number": 116, "body": "def get_pip_gui_class(self):\n        from thonny.plugins import pip_gui\n\n        return pip_gui.CPythonBackendPipDialog", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Returns the class used for displaying the pip package management GUI in the CPython backend environment of the Thonny IDE."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "has_custom_system_shell", "line_number": 121, "body": "def has_custom_system_shell(self):\n        return True", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Indicates that the SshCPythonProxy uses a custom system shell. This method signals shell customization support to other components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "open_custom_system_shell", "line_number": 124, "body": "def open_custom_system_shell(self):\n        if not shutil.which(\"ssh\"):\n            messagebox.showerror(\n                \"Command not found\", \"Command 'ssh' not found\", master=get_workbench()\n            )\n            return\n\n        from thonny import terminal\n\n        userhost = \"%s@%s\" % (self._user, self._host)\n        terminal.run_in_terminal(\n            [\"ssh\", userhost], cwd=get_workbench().get_local_cwd(), keep_open=False, title=userhost\n        )", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Provides a method to open a system SSH shell to a remote host using stored user and host information, allowing direct terminal access from the application if the SSH command is available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_handle_eof_command", "line_number": 38, "body": "def _handle_eof_command(self, msg: EOFCommand) -> None:\n        self._forward_incoming_command(msg)", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Handles EOFCommand messages by forwarding them to the appropriate processing method, facilitating command flow within the SSH backend communication system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_handle_user_input", "line_number": 41, "body": "def _handle_user_input(self, msg: InputSubmission) -> None:\n        self._forward_incoming_command(msg)", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Internal method in SshCPythonBackend that processes a user's input command by forwarding it for execution or further handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_handle_normal_command", "line_number": 44, "body": "def _handle_normal_command(self, cmd: CommandToBackend) -> None:\n        if cmd.name[0].isupper():\n            if \"expected_cwd\" in cmd:\n                self._cwd = cmd[\"expected_cwd\"]\n            self._restart_main_backend()\n\n        handler = getattr(self, \"_cmd_\" + cmd.name, None)\n        if handler is not None:\n            # SFTP methods defined in SshMixin\n            try:\n                response = handler(cmd)\n            except Exception as e:\n                response = {\"error\": str(e)}  # TODO:\n\n            self.send_message(self._prepare_command_response(response, cmd))\n        else:\n            # other methods running in the remote process\n            self._forward_incoming_command(cmd)", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Handles incoming commands by dispatching them to corresponding internal methods or forwarding them for remote execution, managing command-related state and responses within the SSH backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_handle_immediate_command", "line_number": 63, "body": "def _handle_immediate_command(self, cmd: ImmediateCommand) -> None:\n        SshMixin._handle_immediate_command(self, cmd)\n        # It is possible that there is a command being executed both in the local and remote process,\n        # interrupt them both\n        with self._interrupt_lock:\n            interrupt_local_process()\n            self._proc.stdin.write(\"\\x03\")", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Internal method of SshCPythonBackend that handles immediate commands by interrupting both local and remote processes to stop their current execution. It ensures synchronized command interruption across local and SSH environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "send_message", "line_number": 71, "body": "def send_message(self, msg: MessageFromBackend) -> None:\n        with self._response_lock:\n            super().send_message(msg)", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "This method sends a message to the backend while ensuring thread-safe access through locking. It provides a synchronized way to transmit messages within the SshCPythonBackend context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_forward_incoming_command", "line_number": 75, "body": "def _forward_incoming_command(self, msg):\n        self._proc.stdin.write(serialize_message(msg) + \"\\n\")", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Internal method of SshCPythonBackend that forwards serialized incoming messages to the stdin of a subprocess for execution or processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_start_response_forwarder", "line_number": 78, "body": "def _start_response_forwarder(self):\n        self._response_forwarder = Thread(target=self._forward_main_responses, daemon=True)\n        self._response_forwarder.start()", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Private method of SshCPythonBackend that initiates a background thread to asynchronously forward main responses, supporting non-blocking communication handling within the SSH backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_forward_main_responses", "line_number": 82, "body": "def _forward_main_responses(self):\n        while self._should_keep_going():\n            line = self._proc.stdout.readline()\n            if self._main_backend_is_fresh and self._looks_like_echo(line):\n                # In the beginning the backend may echo commands sent to it (perhaps this echo-avoiding trick\n                # takes time). Don't forward those lines.\n                continue\n\n            if not line:\n                break\n            with self._response_lock:\n                sys.stdout.write(line)\n                sys.stdout.flush()\n                self._main_backend_is_fresh = False", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Continuously reads and forwards output lines from the backend process to standard output, while filtering out initial command echoes to ensure clean output streaming during SSH communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_looks_like_echo", "line_number": 97, "body": "def _looks_like_echo(self, line):\n        return line.startswith(\"^B\")", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Checks if a given line starts with a specific control character sequence, likely to identify echoed command outputs in the SSH backend context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_should_keep_going", "line_number": 100, "body": "def _should_keep_going(self) -> bool:\n        return self._proc is not None and self._proc.poll() is None", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Private method of SshCPythonBackend that checks if the associated process is still running, indicating whether ongoing operations should continue."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_start_main_backend", "line_number": 103, "body": "def _start_main_backend(self) -> RemoteProcess:\n        env = {\"THONNY_USER_DIR\": \"~/.config/Thonny\", \"THONNY_FRONTEND_SYS_PATH\": \"[]\"}\n        self._main_backend_is_fresh = True\n        return self._create_remote_process(\n            [self._remote_interpreter, \"-m\", \"thonny.plugins.cpython\", self._cwd],\n            cwd=self._get_remote_program_directory(),\n            env=env,\n        )", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Internal method of SshCPythonBackend that initiates the main remote Python backend process with specific environment settings for managing user configuration and frontend paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_restart_main_backend", "line_number": 112, "body": "def _restart_main_backend(self):\n        self._proc.kill()\n        self._proc = None\n        self._response_forwarder.join()\n        self._proc = self._start_main_backend()\n        self._start_response_forwarder()", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Internal method of SshCPythonBackend that restarts the main backend process by terminating the current one and initializing a new process along with its response handler. It ensures backend connectivity is refreshed during runtime."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_get_remote_program_directory", "line_number": 119, "body": "def _get_remote_program_directory(self):\n        return \"/tmp/thonny-backend-\" + thonny.get_version()", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Returns the path to a temporary backend directory on the remote system, uniquely identified by the current Thonny version. It supports consistent location referencing for remote backend operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_upload_main_backend", "line_number": 122, "body": "def _upload_main_backend(self):\n        launch_dir = self._get_remote_program_directory()\n        if self._get_stat_mode_for_upload(launch_dir) and not launch_dir.endswith(\"-dev\"):\n            # don't overwrite unless in dev mode\n            return\n\n        ensure_posix_directory(\n            launch_dir + \"/thonny/plugins/cpython\",\n            self._get_stat_mode_for_upload,\n            self._mkdir_for_upload,\n        )\n\n        import thonny.ast_utils\n        import thonny.jedi_utils\n        import thonny.backend\n        import thonny.common\n        import thonny.plugins.cpython.cpython_backend\n\n        local_context = os.path.dirname(os.path.dirname(thonny.__file__))\n        for local_path in [\n            thonny.__file__,\n            thonny.common.__file__,\n            thonny.ast_utils.__file__,\n            thonny.jedi_utils.__file__,\n            thonny.backend.__file__,\n            thonny.plugins.cpython.cpython_backend.__file__,\n            thonny.plugins.cpython.__file__.replace(\"__init__\", \"__main__\"),\n        ]:\n            local_suffix = local_path[len(local_context) :]\n            remote_path = launch_dir + local_suffix.replace(\"\\\\\", \"/\")\n            self._perform_sftp_operation_with_retry(lambda sftp: sftp.put(local_path, remote_path))\n\n        def create_empty_cpython_init(sftp):\n            with sftp.open(thonny.plugins.cpython.__file__, \"w\") as fp:\n                fp.close(self._perform_sftp_operation_with_retry(create_empty_cpython_init))", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Uploads necessary Thonny backend files to a remote Python environment via SFTP, ensuring directory structure and file transfers for the CPython plugin backend setup. It conditionally skips upload unless in development mode."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pi/__init__.py", "function": "pix", "line_number": 17, "body": "def pix():\n    MAIN_BACKGROUND = \"#ededed\"\n    detail_bg = \"#d0d0d0\"\n    detail_bg2 = \"#cfcdc8\"\n    res_dir = os.path.join(os.path.dirname(__file__), \"res\")\n    scrollbar_button_settings = {}\n    for direction, element_name in [\n        (\"up\", \"Vertical.Scrollbar.uparrow\"),\n        (\"down\", \"Vertical.Scrollbar.downarrow\"),\n        (\"left\", \"Horizontal.Scrollbar.leftarrow\"),\n        (\"right\", \"Horizontal.Scrollbar.rightarrow\"),\n    ]:\n        # load the image\n        img_name = \"scrollbar-button-\" + direction\n        for suffix in [\"\", \"-insens\"]:\n            get_workbench().get_image(\n                os.path.join(res_dir, img_name + suffix + \".png\"), img_name + suffix\n            )\n\n        scrollbar_button_settings[element_name] = {\n            \"element create\": (\n                \"image\",\n                img_name,\n                (\"!disabled\", img_name),\n                (\"disabled\", img_name + \"-insens\"),\n            )\n        }\n\n    settings = {\n        \".\": {\"configure\": {\"background\": MAIN_BACKGROUND}},\n        \"Toolbutton\": {\n            \"configure\": {\"borderwidth\": 1},\n            \"map\": {\n                \"relief\": [(\"disabled\", \"flat\"), (\"hover\", \"groove\"), (\"!hover\", \"flat\")],\n                \"background\": [\n                    (\"disabled\", MAIN_BACKGROUND),\n                    (\"!hover\", MAIN_BACKGROUND),\n                    (\"hover\", \"#ffffff\"),\n                ],\n            },\n        },\n        \"Treeview.Heading\": {\n            \"configure\": {\n                \"background\": \"#f0f0f0\",\n                \"foreground\": \"#808080\",\n                \"relief\": \"flat\",\n                \"borderwidth\": 1,\n            },\n            \"map\": {\"foreground\": [(\"active\", \"black\")]},\n        },\n        \"TNotebook.Tab\": {\n            \"map\": {\"background\": [(\"!selected\", detail_bg), (\"selected\", MAIN_BACKGROUND)]}\n        },\n        \"ButtonNotebook.TNotebook.Tab\": {\n            \"map\": {\n                \"background\": [(\"!selected\", detail_bg), (\"selected\", MAIN_BACKGROUND)],\n                \"padding\": [\n                    (\"selected\", [scale(4), scale(2), scale(4), scale(3)]),\n                    (\"!selected\", [scale(4), scale(2), scale(4), scale(3)]),\n                ],\n            }\n        },\n        \"TScrollbar\": {\n            \"configure\": {\n                \"gripcount\": 0,\n                \"borderwidth\": 0,\n                \"padding\": scale(1),\n                \"relief\": \"solid\",\n                \"background\": \"#9e9e9e\",\n                \"darkcolor\": \"#d6d6d6\",\n                \"lightcolor\": \"#d6d6d6\",\n                \"bordercolor\": \"#d6d6d6\",\n                \"troughcolor\": \"#d6d6d6\",\n                \"arrowsize\": scale(1),\n                \"arrowcolor\": \"gray\",\n            },\n            \"map\": {\"background\": [], \"darkcolor\": [], \"lightcolor\": []},\n        },\n        # Padding allows twaking thumb width\n        \"Vertical.TScrollbar\": {\n            \"layout\": [\n                (\n                    \"Vertical.Scrollbar.trough\",\n                    {\n                        \"sticky\": \"ns\",\n                        \"children\": [\n                            (\"Vertical.Scrollbar.uparrow\", {\"side\": \"top\", \"sticky\": \"\"}),\n                            (\"Vertical.Scrollbar.downarrow\", {\"side\": \"bottom\", \"sticky\": \"\"}),\n                            (\n                                \"Vertical.Scrollbar.padding\",\n                                {\n                                    \"sticky\": \"nswe\",\n                                    \"children\": [\n                                        (\n                                            \"Vertical.Scrollbar.thumb\",\n                                            {\"expand\": 1, \"sticky\": \"nswe\"},\n                                        )\n                                    ],\n                                },\n                            ),\n                        ],\n                    },\n                )\n            ]\n        },\n        \"Horizontal.TScrollbar\": {\n            \"layout\": [\n                (\n                    \"Horizontal.Scrollbar.trough\",\n                    {\n                        \"sticky\": \"we\",\n                        \"children\": [\n                            (\"Horizontal.Scrollbar.leftarrow\", {\"side\": \"left\", \"sticky\": \"\"}),\n                            (\"Horizontal.Scrollbar.rightarrow\", {\"side\": \"right\", \"sticky\": \"\"}),\n                            (\n                                \"Horizontal.Scrollbar.padding\",\n                                {\n                                    \"sticky\": \"nswe\",\n                                    \"children\": [\n                                        (\n                                            \"Horizontal.Scrollbar.thumb\",\n                                            {\"expand\": 1, \"sticky\": \"nswe\"},\n                                        )\n                                    ],\n                                },\n                            ),\n                        ],\n                    },\n                )\n            ],\n            \"map\": {\n                # Make disabled Hor Scrollbar invisible\n                \"background\": [(\"disabled\", \"#d6d6d6\")],\n                \"troughcolor\": [(\"disabled\", \"#d6d6d6\")],\n                \"bordercolor\": [(\"disabled\", \"#d6d6d6\")],\n                \"darkcolor\": [(\"disabled\", \"#d6d6d6\")],\n                \"lightcolor\": [(\"disabled\", \"#d6d6d6\")],\n            },\n        },\n        \"TCombobox\": {\"configure\": {\"arrowsize\": scale(10)}},\n        \"Menubar\": {\n            \"configure\": {\n                \"background\": MAIN_BACKGROUND,\n                \"relief\": \"flat\",\n                \"activebackground\": \"#ffffff\",\n                \"activeborderwidth\": 0,\n            }\n        },\n        \"Menu\": {\n            \"configure\": {\n                \"background\": \"#ffffff\",\n                \"relief\": \"flat\",\n                \"borderwidth\": 1,\n                \"activeborderwidth\": 0,\n                # \"activebackground\" : bg, # updated below\n                # \"activeforeground\" : fg,\n            }\n        },\n        \"Tooltip\": {\n            \"configure\": {\n                \"background\": \"#808080\",\n                \"foreground\": \"#ffffff\",\n                \"borderwidth\": 0,\n                \"padx\": 10,\n                \"pady\": 10,\n            }\n        },\n        \"Tip.TLabel\": {\"configure\": {\"background\": detail_bg2, \"foreground\": \"black\"}},\n        \"Tip.TFrame\": {\"configure\": {\"background\": detail_bg2}},\n        \"OPTIONS\": {\"configure\": {\"icons_in_menus\": False, \"shortcuts_in_tooltips\": False}},\n    }\n\n    settings.update(scrollbar_button_settings)\n\n    # try to refine settings according to system configuration\n    \"\"\"Note that fonts are set globally, \n    ie. all themes will later inherit these\"\"\"\n    update_fonts()\n\n    for path in [GLOBAL_CONFIGURATION_PATH, CONFIGURATION_PATH]:\n        if os.path.exists(path):\n            with open(path) as fp:\n                try:\n                    for line in fp:\n                        if \"sGtk/ColorScheme\" in line:\n                            if \"selected_bg_color\" in line:\n                                bgr = re.search(\n                                    r\"selected_bg_color:#([0-9a-fA-F]*)\", line, re.M\n                                ).group(\n                                    1\n                                )  # @UndefinedVariable\n                                color = \"#\" + bgr[0:2] + bgr[4:6] + bgr[8:10]\n                                if is_good_color(color):\n                                    settings[\"Menu\"][\"configure\"][\"activebackground\"] = color\n                            if \"selected_fg_color\" in line:\n                                fgr = re.search(\n                                    r\"selected_fg_color:#([0-9a-fA-F]*)\", line, re.M\n                                ).group(\n                                    1\n                                )  # @UndefinedVariable\n                                color = \"#\" + fgr[0:2] + fgr[4:6] + fgr[8:10]\n                                if is_good_color(color):\n                                    settings[\"Menu\"][\"configure\"][\"activeforeground\"] = color\n                except Exception as e:\n                    logger.error(\"Could not update colors\", exc_info=e)\n\n    return settings", "is_method": false, "function_description": "Function that generates and returns a comprehensive dictionary of GUI style configurations, including colors, images, and widget appearance settings, enabling consistent theming and customization of application interface elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pi/__init__.py", "function": "is_good_color", "line_number": 226, "body": "def is_good_color(s):\n    return bool(re.match(\"^#[0-9a-fA-F]{6}$\", s))", "is_method": false, "function_description": "Utility function that checks if a string is a valid hex color code in the format #RRGGBB, commonly used for color validation in UI or graphical applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pi/__init__.py", "function": "update_fonts", "line_number": 235, "body": "def update_fonts():\n    from tkinter import font\n\n    options = {}\n    for path in [GLOBAL_CONFIGURATION_PATH, CONFIGURATION_PATH]:\n        if os.path.exists(path):\n            try:\n                with open(path) as fp:\n                    for line in fp:\n                        if \"sGtk/FontName\" in line:\n                            result = re.search(\n                                r\"=([^0-9]*) ([0-9]*)\", line, re.M\n                            )  # @UndefinedVariable\n                            family = result.group(1)\n                            options[\"size\"] = int(result.group(2))\n\n                            if re.search(r\"\\bBold\\b\", family):\n                                options[\"weight\"] = \"bold\"\n                            else:\n                                options[\"weight\"] = \"normal\"\n\n                            if re.search(r\"\\bItalic\\b\", family):\n                                options[\"slant\"] = \"italic\"\n                            else:\n                                options[\"slant\"] = \"roman\"\n\n                            options[\"family\"] = family.replace(\" Bold\", \"\").replace(\" Italic\", \"\")\n            except Exception as e:\n                logger.error(\"Could not update fonts\", exc_info=e)\n\n    if options:\n        for name in [\"TkDefaultFont\", \"TkMenuFont\", \"TkTextFont\", \"TkHeadingFont\"]:\n            font.nametofont(name).configure(**options)", "is_method": false, "function_description": "Function that reads font configuration from system files to update default Tkinter font styles (family, size, weight, slant) for various UI elements, ensuring consistent appearance based on user or system preferences."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pi/__init__.py", "function": "load_plugin", "line_number": 270, "body": "def load_plugin():\n\n    # set custom images\n    if get_workbench().get_ui_mode() == \"simple\" and get_workbench().winfo_screenwidth() >= 1280:\n        images = {\n            \"run-current-script\": \"media-playback-start48.png\",\n            \"stop\": \"process-stop48.png\",\n            \"new-file\": \"document-new48.png\",\n            \"open-file\": \"document-open48.png\",\n            \"save-file\": \"document-save48.png\",\n            \"debug-current-script\": \"debug-run48.png\",\n            \"step-over\": \"debug-step-over48.png\",\n            \"step-into\": \"debug-step-into48.png\",\n            \"step-out\": \"debug-step-out48.png\",\n            \"run-to-cursor\": \"debug-run-cursor48.png\",\n            \"tab-close\": \"window-close.png\",\n            \"tab-close-active\": \"window-close-act.png\",\n            \"resume\": \"resume48.png\",\n            \"zoom\": \"zoom48.png\",\n            \"quit\": \"quit48.png\",\n        }\n    else:\n        images = {\n            \"run-current-script\": \"media-playback-start.png\",\n            \"stop\": \"process-stop.png\",\n            \"new-file\": \"document-new.png\",\n            \"open-file\": \"document-open.png\",\n            \"save-file\": \"document-save.png\",\n            \"debug-current-script\": \"debug-run.png\",\n            \"step-over\": \"debug-step-over.png\",\n            \"step-into\": \"debug-step-into.png\",\n            \"step-out\": \"debug-step-out.png\",\n            \"run-to-cursor\": \"debug-run-cursor.png\",\n            \"tab-close\": \"window-close.png\",\n            \"tab-close-active\": \"window-close-act.png\",\n            \"resume\": \"resume.png\",\n            \"zoom\": \"zoom.png\",\n            \"quit\": \"quit.png\",\n        }\n\n    res_dir = os.path.join(os.path.dirname(__file__), \"res\")\n    theme_image_map = {}\n    for image in images:\n        theme_image_map[image] = os.path.join(res_dir, images[image])\n\n    get_workbench().add_ui_theme(\"Raspberry Pi\", \"Enhanced Clam\", pix, theme_image_map)\n    get_workbench().add_ui_theme(\"Raspberry Pi Dark\", \"Clean Dark\", pix_dark, theme_image_map)", "is_method": false, "function_description": "Utility function that configures and loads custom UI themes with appropriate icon sets based on screen resolution and UI mode, enhancing the user interface appearance in the workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "load_plugin", "line_number": 156, "body": "def load_plugin():\n    add_micropython_backend(\n        \"microbit\",\n        MicrobitProxy,\n        \"MicroPython (BBC micro:bit)\",\n        MicrobitConfigPage,\n        sort_key=\"31\",\n        validate_time=False,\n        sync_time=False,\n        write_block_size=128,\n    )\n\n    # Don't consider micro:bit in generic backends\n    # The main reason is to reduce the number of items in the backend switcher menu\n    import thonny.plugins.circuitpython\n    import thonny.plugins.micropython\n\n    thonny.plugins.circuitpython.VIDS_PIDS_TO_AVOID.update(MicrobitProxy.get_known_usb_vids_pids())\n    thonny.plugins.micropython.VIDS_PIDS_TO_AVOID_IN_GENERIC_BACKEND.update(\n        MicrobitProxy.get_known_usb_vids_pids()\n    )", "is_method": false, "function_description": "Registers and configures the BBC micro:bit MicroPython backend plugin, updating device ID lists to avoid conflicts with generic MicroPython and CircuitPython backends within the Thonny IDE."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_start_background_process", "line_number": 23, "body": "def _start_background_process(self, clean=None, extra_args=[]):\n        # NB! Sometimes disconnecting and reconnecting (on macOS?)\n        # too quickly causes anomalies\n        # https://github.com/pyserial/pyserial/issues/176\n        # In my Sierra, Calliope and micro:bit seemed to soft-reboot\n        # when reconnected too quickly.\n\n        if clean and sys.platform == \"darwin\":\n            sleep(1.0)\n\n        super()._start_background_process(clean)", "is_method": true, "class_name": "MicrobitProxy", "function_description": "Internal method of MicrobitProxy that initiates a background process, optionally handling platform-specific timing issues on macOS to avoid hardware reconnect anomalies."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "supports_remote_directories", "line_number": 35, "body": "def supports_remote_directories(self):\n        return False", "is_method": true, "class_name": "MicrobitProxy", "function_description": "Indicates whether the MicrobitProxy supports interaction with remote directories. It consistently returns False, signaling no such capability is available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "should_consider_unknown_devices", "line_number": 39, "body": "def should_consider_unknown_devices(cls):\n        return False", "is_method": true, "class_name": "MicrobitProxy", "function_description": "Returns whether unknown devices should be considered, always indicating they should not. This method informs device filtering behavior in the MicrobitProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 43, "body": "def get_known_usb_vids_pids(self):\n        return {(0x0D28, 0x0204)}", "is_method": true, "class_name": "MicrobitProxy", "function_description": "Returns a set of known USB vendor and product ID pairs associated with the device, enabling identification and filtering of compatible USB hardware."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_usb_driver_url", "line_number": 48, "body": "def _get_usb_driver_url(self):\n        return \"https://microbit-micropython.readthedocs.io/en/latest/devguide/repl.html\"", "is_method": true, "class_name": "MicrobitConfigPage", "function_description": "Returns the URL for the USB driver documentation related to Microbit MicroPython, providing a reference link for USB driver installation or usage information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_intro_text", "line_number": 51, "body": "def _get_intro_text(self):\n        return (\n            super()._get_intro_text()\n            + \"\\n\\n\"\n            + tr(\"Make sure MicroPython has been installed to your micro:bit.\")\n            + \"\\n(\"\n            + tr(\"Don't forget that main.py only works without embedded main script.\")\n            + \")\"\n        )", "is_method": true, "class_name": "MicrobitConfigPage", "function_description": "Constructs and returns an introductory message for the MicrobitConfigPage, including reminders specific to MicroPython installation and script usage on the micro:bit device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_has_flashing_dialog", "line_number": 61, "body": "def _has_flashing_dialog(self):\n        return True", "is_method": true, "class_name": "MicrobitConfigPage", "function_description": "Indicates that a flashing dialog should be displayed on the micro:bit configuration page, serving as a flag to trigger that UI element."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_open_flashing_dialog", "line_number": 64, "body": "def _open_flashing_dialog(self):\n        dlg = MicrobitFlashingDialog(self)\n        ui_utils.show_dialog(dlg)", "is_method": true, "class_name": "MicrobitConfigPage", "function_description": "Private method in MicrobitConfigPage that initiates and displays the Microbit flashing dialog, facilitating the firmware update process for the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_instructions", "line_number": 70, "body": "def get_instructions(self) -> Optional[str]:\n        return (\n            \"This dialog allows you to install or update MicroPython firmware on your micro:bit.\\n\"\n            \"\\n\"\n            \"1. Plug in your micro:bit.\\n\"\n            \"2. Wait until device information appears.\\n\"\n            \"3. Click 'Install' and wait for some seconds until done.\\n\"\n            \"4. Close the dialog and start programming!\\n\"\n            \"\\n\"\n            \"NB! Installing a new firmware will erase all files you may have on your\\n\"\n            \"device. Make sure you have important files backed up!\"\n        )", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Provides user instructions for installing or updating MicroPython firmware on a micro:bit device, guiding through connection, installation steps, and important data backup warnings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_release_info_url", "line_number": 83, "body": "def _get_release_info_url(self):\n        return \"https://raw.githubusercontent.com/thonny/thonny/master/data/microbit-firmware.json\"", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Returns the URL of the JSON file containing Microbit firmware release information, enabling access to the latest firmware data for flashing updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_unknown_version_text", "line_number": 86, "body": "def get_unknown_version_text(self):\n        return \"?\"", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Returns a placeholder string indicating an unknown version, useful for displaying undefined or unavailable version information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_firmware_description", "line_number": 89, "body": "def get_firmware_description(self):\n        info = self._get_latest_firmware_info_for_current_device()\n        if info is None:\n            return None\n        return \"%s (%s)\" % (info[\"version\"], info[\"date\"])", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Returns the latest firmware version and release date description for the current device, aiding users in identifying the firmware details before flashing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_latest_firmware_info_for_current_device", "line_number": 95, "body": "def _get_latest_firmware_info_for_current_device(self):\n        if self._possible_targets is None or len(self._possible_targets) != 1:\n            return None\n        else:\n            board_id = self._possible_targets[0][1]\n            return self._get_latest_firmware_info_for_device(board_id)", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Retrieves the latest firmware information for the currently selected micro:bit device if exactly one target is identified. It enables firmware update checks specific to the detected device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_latest_firmware_info_for_device", "line_number": 102, "body": "def _get_latest_firmware_info_for_device(self, board_id):\n        if self._release_info is None:\n            return None\n        else:\n            return self._release_info[\"latest_firmwares\"].get(board_id, None)", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Utility method in MicrobitFlashingDialog that retrieves the latest firmware information for a given board ID from release data, supporting device-specific firmware management during flashing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_download_url_and_size", "line_number": 108, "body": "def get_download_url_and_size(self, board_id):\n        info = self._get_latest_firmware_info_for_device(board_id)\n        if info is None:\n            return None\n\n        return info[\"hex_download\"], info[\"size\"]", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Utility method of MicrobitFlashingDialog that retrieves the download URL and file size of the latest firmware for a specified board ID, facilitating firmware update or flashing processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_target_filename", "line_number": 115, "body": "def get_target_filename(self):\n        return \"firmware.hex\"", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Returns the fixed target filename \"firmware.hex\" used for flashing firmware in the MicrobitFlashingDialog context. This provides a standard reference for the firmware file throughout the flashing process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "find_device_board_id_and_model", "line_number": 119, "body": "def find_device_board_id_and_model(cls, mount_path):\n        info_path = os.path.join(mount_path, \"DETAILS.TXT\")\n        if not os.path.isfile(info_path):\n            return None\n\n        # https://tech.microbit.org/latest-revision/editors/\n        models = {\n            \"9900\": \"BBC micro:bit v1.3\",\n            \"9901\": \"BBC micro:bit v1.5\",\n            \"9903\": \"BBC micro:bit v2.0 (9903)\",\n            \"9904\": \"BBC micro:bit v2.0\",\n        }\n\n        with open(info_path, \"r\", encoding=\"UTF-8\", errors=\"replace\") as fp:\n            id_marker = \"Unique ID:\"\n            for line in fp:\n                if line.startswith(id_marker):\n                    board_id = line[len(id_marker) :].strip()[:4]\n                    if board_id in models:\n                        return board_id, models[board_id]\n\n            # With older bootloaders, the file may be different\n            fp.seek(0)\n            for line in fp:\n                if \"Version: 0234\" in line:\n                    board_id = \"9900\"\n                    return board_id, models[board_id]\n\n        return None", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Identifies the board ID and model of a BBC micro:bit device by reading its DETAILS.TXT file in a given mount path, enabling recognition of specific micro:bit hardware versions for flashing or management purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_title", "line_number": 149, "body": "def get_title(self):\n        return \"Install MicroPython firmware for BBC micro:bit\"", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Returns the fixed title string indicating the dialog\u2019s purpose to install MicroPython firmware on a BBC micro:bit device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_vid_pids_to_wait_for", "line_number": 152, "body": "def _get_vid_pids_to_wait_for(self):\n        return MicrobitProxy.get_known_usb_vids_pids()", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Returns the list of known USB vendor and product IDs relevant to micro:bit devices for connection detection and management purposes within the flashing dialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "load_plugin", "line_number": 389, "body": "def load_plugin():\n    add_micropython_backend(\n        \"ESP32\",\n        ESP32Proxy,\n        \"MicroPython (ESP32)\",\n        ESP32ConfigPage,\n        sort_key=\"35\",\n    )\n    add_micropython_backend(\n        \"ESP8266\", ESP8266Proxy, \"MicroPython (ESP8266)\", ESP8266ConfigPage, sort_key=\"36\"\n    )", "is_method": false, "function_description": "Registers MicroPython backends for ESP32 and ESP8266 devices, enabling integration and configuration support for these hardware platforms within the plugin system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_is_potential_port", "line_number": 31, "body": "def _is_potential_port(cls, p):\n        # They have UART adapter\n        return (\n            (p.vid, p.pid) in cls.get_known_usb_vids_pids()\n            or (p.vid, None) in cls.get_known_usb_vids_pids()\n            or p.description in cls.get_known_port_descriptions()\n            or cls.should_consider_unknown_devices()\n            and (p.vid, p.pid) not in cls.get_vids_pids_to_avoid()\n            and (\n                (\"USB\" in p.description and \"serial\" in p.description.lower())\n                or \"UART\" in p.description\n                or \"DAPLink\" in p.description\n                or \"STLink\" in p.description\n            )\n            and getattr(p, \"manufacturer\", \"\") != \"MicroPython\"  # adapter can't have this?\n            and \"python\" not in p.description.lower()\n        )", "is_method": true, "class_name": "ESPProxy", "function_description": "Determines if a USB device is likely a serial port based on VID/PID, description, and manufacturer filters. Useful for identifying potential UART adapters or debugging ports in hardware communication contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_vids_pids_to_avoid", "line_number": 50, "body": "def get_vids_pids_to_avoid(self):\n        # micro:bit\n        return {(0x0D28, 0x0204)}", "is_method": true, "class_name": "ESPProxy", "function_description": "Returns a set of vendor and product ID tuples representing devices to be avoided, likely for connection filtering or exclusion purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 60, "body": "def get_known_usb_vids_pids(cls):\n        return cls.get_uart_adapter_vids_pids()", "is_method": true, "class_name": "ESP8266Proxy", "function_description": "Utility class method in ESP8266Proxy that returns a list of known USB vendor and product IDs associated with UART adapters, aiding device identification and connection management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_get_api_stubs_path", "line_number": 63, "body": "def _get_api_stubs_path(self):\n        return os.path.join(os.path.dirname(__file__), \"esp8266_api_stubs\")", "is_method": true, "class_name": "ESP8266Proxy", "function_description": "Returns the filesystem path to the ESP8266 API stubs directory, facilitating access to mock or placeholder API definitions within the ESP8266Proxy class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 69, "body": "def get_known_usb_vids_pids(cls):\n        return cls.get_uart_adapter_vids_pids()", "is_method": true, "class_name": "ESP32Proxy", "function_description": "Utility method of the ESP32Proxy class that retrieves known USB vendor and product IDs by delegating to the UART adapter VID/PID retrieval function. This aids in identifying compatible USB devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_get_api_stubs_path", "line_number": 72, "body": "def _get_api_stubs_path(self):\n        return os.path.join(os.path.dirname(__file__), \"esp32_api_stubs\")", "is_method": true, "class_name": "ESP32Proxy", "function_description": "Private helper method of ESP32Proxy that provides the file system path to the ESP32 API stubs directory for internal use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_has_flashing_dialog", "line_number": 82, "body": "def _has_flashing_dialog(self):\n        return True", "is_method": true, "class_name": "ESPConfigPage", "function_description": "Returns a fixed indicator that a flashing dialog is present, possibly serving as a placeholder or default behavior within the ESPConfigPage class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_open_flashing_dialog", "line_number": 85, "body": "def _open_flashing_dialog(self):\n        dlg = ESPFlashingDialog(self.winfo_toplevel(), self._chip, self._firmware_start_address)\n        ui_utils.show_dialog(dlg)", "is_method": true, "class_name": "ESPConfigPage", "function_description": "Opens and displays the flashing dialog window for ESP device firmware updates, facilitating user interaction during the flashing process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "allow_webrepl", "line_number": 90, "body": "def allow_webrepl(self):\n        return True", "is_method": true, "class_name": "ESPConfigPage", "function_description": "Simple configuration method in ESPConfigPage that indicates WebREPL (web-based REPL) access is permitted. It provides a boolean flag used to enable or disable remote interactive Python sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_title", "line_number": 121, "body": "def get_title(self):\n        return \"%s firmware installer\" % self._chip.upper()", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Returns the firmware installer title formatted with the chip's name in uppercase, providing a descriptive label for the flashing dialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_instructions", "line_number": 124, "body": "def get_instructions(self) -> Optional[str]:\n        return (\n            \"This dialog allows installing or updating firmware on %s using the most common settings.\\n\"\n            % self._chip.upper()\n            + \"If you need to set other options, then please use 'esptool' on the command line.\\n\\n\"\n            + \"Note that there are many variants of MicroPython for ESP devices. If the firmware provided\\n\"\n            + \"at micropython.org/download doesn't work for your device, then there may exist better\\n\"\n            + \"alternatives -- look around in your device's documentation or at MicroPython forum.\"\n        )", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Provides user instructions for firmware installation/updating on the specified ESP chip, guiding on default settings and alternative tools or firmware options for MicroPython devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "is_ready_for_work", "line_number": 134, "body": "def is_ready_for_work(self):\n        return self._port_desc_variable.get() and self._firmware_entry.get()", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Utility method of the ESPFlashingDialog class that checks if the necessary port descriptor and firmware entry fields are provided, indicating readiness to begin the flashing process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_action_text_max_length", "line_number": 137, "body": "def get_action_text_max_length(self):\n        return 35", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Returns the maximum allowed length for action text, enforcing consistent UI text sizing within the ESPFlashingDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "populate_main_frame", "line_number": 140, "body": "def populate_main_frame(self):\n        epadx = self.get_padding()\n        ipadx = self.get_internal_padding()\n        epady = epadx\n        ipady = ipadx\n\n        # Port\n        port_label = ttk.Label(self.main_frame, text=\"Port\")\n        port_label.grid(row=1, column=1, sticky=\"w\", padx=(epadx, 0), pady=(epady, 0))\n\n        self._port_desc_variable = tk.StringVar(value=\"\")\n        self._port_combo = ttk.Combobox(\n            self.main_frame, exportselection=False, textvariable=self._port_desc_variable, values=[]\n        )\n        self._port_combo.state([\"!disabled\", \"readonly\"])\n        self._port_combo.grid(row=1, column=2, sticky=\"nsew\", padx=ipadx, pady=(epady, 0))\n\n        port_reload_button = ttk.Button(self.main_frame, text=\"Reload\", command=self._reload_ports)\n        port_reload_button.grid(row=1, column=3, sticky=\"ew\", padx=(0, epadx), pady=(epady, 0))\n\n        # Firmware\n        firmware_label = ttk.Label(self.main_frame, text=\"Firmware\")\n        firmware_label.grid(row=2, column=1, sticky=\"w\", padx=(epadx, 0), pady=(ipady, 0))\n\n        self._firmware_entry = ttk.Entry(self.main_frame, width=55)\n        self._firmware_entry.grid(row=2, column=2, sticky=\"nsew\", padx=ipadx, pady=(ipady, 0))\n\n        browse_button = ttk.Button(self.main_frame, text=\"Browse...\", command=self._browse)\n        browse_button.grid(row=2, column=3, sticky=\"we\", padx=(0, epadx), pady=(ipady, 0))\n\n        # FLASH_MODE\n        self._flashmode = tk.StringVar(None, \"keep\")\n        flashmode_group = ttk.Labelframe(self.main_frame, text=\"Flash mode\")\n        flashmode_group.grid(\n            row=4, column=1, columnspan=2, sticky=\"w\", padx=(epadx, 0), pady=(ipady * 2, 0)\n        )\n\n        self._flashmode_keep_radiobutton = ttk.Radiobutton(\n            flashmode_group, text=\"From image file (keep)\", variable=self._flashmode, value=\"keep\"\n        )\n        self._flashmode_keep_radiobutton.grid(row=0, column=0, sticky=\"w\")\n\n        # self._flashmode_variable.value=False\n        self._flashmode_qio_radiobutton = ttk.Radiobutton(\n            flashmode_group, text=\"Quad I/O (qio)\", variable=self._flashmode, value=\"qio\"\n        )\n        self._flashmode_qio_radiobutton.grid(row=0, column=1, sticky=\"w\")\n\n        self._flashmode_dio_radiobutton = ttk.Radiobutton(\n            flashmode_group, text=\"Dual I/O (dio)\", variable=self._flashmode, value=\"dio\"\n        )\n        self._flashmode_dio_radiobutton.grid(row=1, column=0, sticky=\"w\")\n\n        self._flashmode_dout_radiobutton = ttk.Radiobutton(\n            flashmode_group, text=\"Dual Output (dout)\", variable=self._flashmode, value=\"dout\"\n        )\n        self._flashmode_dout_radiobutton.grid(row=1, column=1, sticky=\"w\")\n\n        # Erase\n        self._erase_variable = tk.BooleanVar(value=True)\n        self._erase_checkbutton = ttk.Checkbutton(\n            self.main_frame, text=\"Erase flash before installing\", variable=self._erase_variable\n        )\n        self._erase_checkbutton.grid(\n            row=6, column=1, columnspan=2, sticky=\"w\", padx=(epadx, 0), pady=(ipady, epady)\n        )\n\n        self._reload_ports()", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Sets up and arranges the user interface elements in the main frame of the ESPFlashingDialog, including port selection, firmware input, flash mode options, and flash erase control, preparing the dialog for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_get_esptool_command", "line_number": 209, "body": "def _get_esptool_command(self):\n        try:\n            import esptool\n\n            return [get_interpreter_for_subprocess(), \"-u\", \"-m\", \"esptool\"]\n        except ImportError:\n            import shutil\n\n            result = shutil.which(\"esptool\")\n            if result:\n                return [result]\n            else:\n                result = shutil.which(\"esptool.py\")\n                if result:\n                    return [result]\n                else:\n                    return None", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Utility method in ESPFlashingDialog that locates the esptool command or module for subprocess execution, supporting both direct module invocation and system-installed executable detection. It enables flashing ESP devices by preparing the appropriate command call."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_reload_ports", "line_number": 227, "body": "def _reload_ports(self):\n        pairs = list_serial_ports_with_descriptions()\n        self._ports_by_desc = OrderedDict(pairs)\n        self._port_combo.configure(values=list(self._ports_by_desc.keys()))", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Reloads and updates the list of available serial ports with their descriptions for the ESPFlashingDialog, refreshing the port selection options in the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_browse", "line_number": 232, "body": "def _browse(self):\n        initialdir = os.path.normpath(os.path.expanduser(\"~/Downloads\"))\n        if not os.path.isdir(initialdir):\n            initialdir = None\n\n        path = ui_utils.askopenfilename(\n            filetypes=[(\"bin-files\", \".bin\"), (\"all files\", \".*\")],\n            parent=self.winfo_toplevel(),\n            initialdir=initialdir,\n        )\n        if path:\n            self._firmware_entry.delete(0, \"end\")\n            self._firmware_entry.insert(0, path)", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Provides a file selection dialog for choosing a firmware binary file, then updates the related input field with the selected file path. It facilitates user interaction for firmware file selection in ESPFlashingDialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_check_connection", "line_number": 246, "body": "def _check_connection(self, port):\n        # wait a bit in case existing connection was just closed\n        time.sleep(1.5)\n\n        # Maybe another program is connected\n        # or the user doesn't have sufficient permissions?\n        try:\n            import serial\n\n            conn = serial.Serial(port)\n            conn.close()\n            return True\n        except Exception as e:\n            messagebox.showerror(\"Can't connect\", str(e), master=self)\n            return False", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Utility method in ESPFlashingDialog that verifies if a serial connection to a specified port can be established, alerting the user to any connection issues or permission problems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "start_work", "line_number": 262, "body": "def start_work(self):\n        port = self._ports_by_desc[self._port_desc_variable.get()]\n        if not self._port_desc_variable.get():\n            messagebox.showerror(\"Select port\", \"Please select port\", parent=self)\n            return False\n\n        firmware_path = self._firmware_entry.get()\n        if not os.path.exists(firmware_path):\n            messagebox.showerror(\n                \"Bad firmware path\", \"Can't find firmware, please check path\", master=self\n            )\n            return False\n\n        flash_mode = self._flashmode.get()\n        erase_flash = self._erase_variable.get()\n\n        proxy = get_runner().get_backend_proxy()\n        port_was_used_in_thonny = (\n            isinstance(proxy, BareMetalMicroPythonProxy) and proxy._port == port\n        )\n        if port_was_used_in_thonny:\n            proxy.disconnect()\n\n        commands = []\n        threading.Thread(\n            target=self.work_in_thread,\n            daemon=True,\n            args=[port, firmware_path, flash_mode, erase_flash, port_was_used_in_thonny],\n        ).start()", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Starts the firmware flashing process by validating selected port and firmware path, then initiates a background thread to perform flashing with specified options and safely disconnects the port if in use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "work_in_thread", "line_number": 292, "body": "def work_in_thread(self, port, firmware_path, flash_mode, erase_flash, port_was_used_in_thonny):\n        if port_was_used_in_thonny:\n            time.sleep(1.5)\n\n        erase_command = self._esptool_command + [\n            \"--chip\",\n            self._chip,\n            \"--port\",\n            port,\n            \"erase_flash\",\n        ]\n\n        write_command = self._esptool_command + [\n            \"--chip\",\n            self._chip,\n            \"--port\",\n            port,\n            \"write_flash\",\n            \"--flash_mode\",\n            flash_mode,\n            \"--flash_size\",  # default changed in esptool 3.0\n            \"detect\",\n            self._start_address,\n            firmware_path,\n        ]\n\n        if not self._check_connection(port):\n            self.set_action_text(\"Problem\")\n            self.append_text(\"Could not connect to port\\n\")\n            self.report_done(False)\n            return\n\n        if erase_flash:\n            self.set_action_text(\"Erasing flash\")\n            self.append_text(subprocess.list2cmdline(erase_command) + \"\\n\")\n            self._proc = self._create_subprocess(erase_command)\n            while True:\n                line = self._proc.stdout.readline()\n                if not line:\n                    break\n                self.append_text(line)\n                self.set_action_text_smart(line)\n            returncode = self._proc.wait()\n            if returncode:\n                self.set_action_text(\"Error\")\n                self.append_text(\"\\nErase command returned with error code %s\" % returncode)\n                self.report_done(False)\n                return\n            else:\n                self.append_text(\"Erasing done\\n------------------------------------\\n\\n\")\n\n        self.set_action_text(\"Writing firmware\")\n        self.append_text(subprocess.list2cmdline(write_command) + \"\\n\")\n        self._proc = self._create_subprocess(write_command)\n        while True:\n            line = self._proc.stdout.readline()\n            if not line:\n                break\n            self.append_text(line)\n            self.set_action_text_smart(line)\n        returncode = self._proc.wait()\n        if returncode:\n            self.set_action_text(\"Error\")\n            self.append_text(\"\\nWrite command returned with error code %s\" % returncode)\n        else:\n            self.set_action_text(\"Done!\")\n            self.append_text(\"Done!\")\n        self.report_done(returncode == 0)", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Method of ESPFlashingDialog that manages firmware flashing on a specified port, including optional flash erasure, while providing progress updates and error reporting throughout the process. It automates connection checking, command execution, and status display for ESP device flashing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_create_subprocess", "line_number": 361, "body": "def _create_subprocess(self, cmd) -> subprocess.Popen:\n        return subprocess.Popen(\n            cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True\n        )", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Private helper method of ESPFlashingDialog that initiates a subprocess with redirected output streams, enabling external command execution while capturing its combined standard output and error messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_ok_text", "line_number": 366, "body": "def get_ok_text(self):\n        return tr(\"Install\")", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Returns the localized text label \"Install\" for the confirmation button in the ESPFlashingDialog interface. It standardizes the OK button's display text during the flashing process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "cancel_work", "line_number": 369, "body": "def cancel_work(self):\n        super().cancel_work()\n        # try gently first\n        try:\n            try:\n                if running_on_windows():\n                    os.kill(self._proc.pid, signal.CTRL_BREAK_EVENT)  # pylint: disable=no-member\n                else:\n                    os.kill(self._proc.pid, signal.SIGINT)\n\n                self._proc.wait(2)\n            except subprocess.TimeoutExpired:\n                if self._proc.poll() is None:\n                    # now let's be more concrete\n                    self._proc.kill()\n        except OSError as e:\n            messagebox.showerror(\"Error\", \"Could not kill subprocess: \" + str(e), master=self)\n            logger.error(\"Could not kill subprocess\", exc_info=e)", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Method of ESPFlashingDialog that attempts to gracefully terminate a subprocess, escalating to forceful termination if necessary, ensuring the subprocess is properly stopped and handling any termination errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "open_help", "line_number": 75, "body": "def open_help():\n    get_workbench().show_view(\"HelpView\")", "is_method": false, "function_description": "This function opens the help interface within the application workspace, providing users with access to assistance or documentation resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "load_plugin", "line_number": 79, "body": "def load_plugin() -> None:\n    get_workbench().add_view(HelpView, tr(\"Help\"), \"ne\")\n    get_workbench().add_command(\"help_contents\", \"help\", tr(\"Help contents\"), open_help, group=30)", "is_method": false, "function_description": "Adds a Help view and command to the application workbench, integrating help resources into the user interface for easy access."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "on_workbench_ready", "line_number": 40, "body": "def on_workbench_ready(self, event=None):\n        self.load_index()", "is_method": true, "class_name": "HelpView", "function_description": "This method triggers the loading of an index once the workbench component is ready, ensuring necessary data or resources are initialized for subsequent operations in the HelpView interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "on_show", "line_number": 43, "body": "def on_show(self):\n        self.load_index()", "is_method": true, "class_name": "HelpView", "function_description": "Triggers the loading of an index whenever the HelpView is displayed, ensuring relevant data is prepared and available for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "load_index", "line_number": 46, "body": "def load_index(self):\n        self.load_rst_file(\"index.rst\")", "is_method": true, "class_name": "HelpView", "function_description": "Loads the primary RST file named \"index.rst\" to display or process the main help content. This function serves as the entry point for initializing the help view's documentation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "load_topic", "line_number": 49, "body": "def load_topic(self, topic, fragment=None):\n        self.load_rst_file(topic + \".rst\")", "is_method": true, "class_name": "HelpView", "function_description": "Loads and displays the content of a specified reStructuredText (.rst) help topic, optionally handling a fragment for fine-grained navigation. This supports dynamic loading of help documentation in the HelpView context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "load_rst_file", "line_number": 53, "body": "def load_rst_file(self, filename):\n        self.text.clear()\n        self.text.direct_insert(\"1.0\", \"\\n\")\n\n        if os.path.isabs(filename):\n            full_path = filename\n        else:\n            # try to access filename in a language subdirectory\n            full_path = os.path.join(self.language_dir, filename)\n            if not os.path.exists(full_path):\n                # if the localized file does not exist, default to English\n                full_path = os.path.join(os.path.dirname(__file__), filename)\n\n        with open(full_path, encoding=\"UTF-8\") as fp:\n            rst_source = fp.read()\n\n        if not filename.endswith(\"index.rst\"):\n            rst_source = \"`\" + tr(\"Home\") + \" <index.rst>`_\\n\\n\" + rst_source\n\n        self.text.append_rst(rst_source)", "is_method": true, "class_name": "HelpView", "function_description": "Loads and displays a reStructuredText (RST) help file, automatically resolving language-specific or default paths. It integrates navigation to the home page for non-index files, supporting multilingual documentation views in the HelpView class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "prepare_hooks", "line_number": 1221, "body": "def prepare_hooks(method):\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        try:\n            sys.meta_path.insert(0, self)\n            self._backend._install_custom_import()\n            return method(self, *args, **kwargs)\n        finally:\n            del sys.meta_path[0]\n            if hasattr(self._backend, \"_original_import\"):\n                self._backend._restore_original_import()\n\n    return wrapper", "is_method": false, "function_description": "Utility decorator that temporarily modifies the import system during the execution of a method, enabling custom import behavior and ensuring cleanup afterward."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "return_execution_result", "line_number": 1236, "body": "def return_execution_result(method):\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = method(self, *args, **kwargs)\n            if result is not None:\n                return result\n            return {\"context_info\": \"after normal execution\"}\n        except Exception:\n            return {\"user_exception\": self._backend._prepare_user_exception()}\n\n    return wrapper", "is_method": false, "function_description": "Decorator function that standardizes method outputs by returning the original result if available or a default context dictionary, and captures exceptions to provide a user-friendly error response."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_frame_prefix", "line_number": 2716, "body": "def _get_frame_prefix(frame):\n    return str(id(frame)) + \" \" + \">\" * len(inspect.getouterframes(frame, 0)) + \" \"", "is_method": false, "function_description": "Returns a unique string prefix for a stack frame, combining its memory ID and a visual depth indicator based on its nesting level in the call stack. This can help distinguish and represent frames in debugging or stack trace analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_fetch_frame_source_info", "line_number": 2720, "body": "def _fetch_frame_source_info(frame):\n    if frame.f_code.co_filename is None or not os.path.exists(frame.f_code.co_filename):\n        return None, None, True\n\n    is_libra = _is_library_file(frame.f_code.co_filename)\n\n    if frame.f_code.co_name == \"<lambda>\":\n        source = inspect.getsource(frame.f_code)\n        return source, frame.f_code.co_firstlineno, is_libra\n    elif frame.f_code.co_name == \"<module>\":\n        # inspect.getsource and getsourcelines don't help here\n        with tokenize.open(frame.f_code.co_filename) as fp:\n            return fp.read(), 1, is_libra\n    else:\n        # function or class\n        try:\n            source = inspect.getsource(frame.f_code)\n\n            # inspect.getsource is not reliable, see eg:\n            # https://bugs.python.org/issue35101\n            # If the code name is not present as definition\n            # in the beginning of the source,\n            # then play safe and return the whole script\n            first_line = source.splitlines()[0]\n            if re.search(r\"\\b(class|def)\\b\\s+\\b%s\\b\" % frame.f_code.co_name, first_line) is None:\n                with tokenize.open(frame.f_code.co_filename) as fp:\n                    return fp.read(), 1, is_libra\n\n            else:\n                return source, frame.f_code.co_firstlineno, is_libra\n        except OSError:\n            logger.exception(\"Problem getting source\")\n            return None, None, True", "is_method": false, "function_description": "Private utility extracting source code and metadata from a stack frame, identifying if the frame originates from library code. Useful for debugging or introspection tools that analyze or display frame-specific source information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "format_exception_with_frame_info", "line_number": 2755, "body": "def format_exception_with_frame_info(e_type, e_value, e_traceback, shorten_filenames=False):\n    \"\"\"Need to suppress thonny frames to avoid confusion\"\"\"\n\n    _traceback_message = \"Traceback (most recent call last):\\n\"\n\n    _cause_message = getattr(\n        traceback,\n        \"_cause_message\",\n        (\"\\nThe above exception was the direct cause \" + \"of the following exception:\") + \"\\n\\n\",\n    )\n\n    _context_message = getattr(\n        traceback,\n        \"_context_message\",\n        (\"\\nDuring handling of the above exception, \" + \"another exception occurred:\") + \"\\n\\n\",\n    )\n\n    def rec_format_exception_with_frame_info(etype, value, tb, chain=True):\n        # Based on\n        # https://www.python.org/dev/peps/pep-3134/#enhanced-reporting\n        # and traceback.format_exception\n\n        if etype is None:\n            etype = type(value)\n\n        if tb is None:\n            tb = value.__traceback__\n\n        if chain:\n            if value.__cause__ is not None:\n                yield from rec_format_exception_with_frame_info(None, value.__cause__, None)\n                yield (_cause_message, None, None, None)\n            elif value.__context__ is not None and not value.__suppress_context__:\n                yield from rec_format_exception_with_frame_info(None, value.__context__, None)\n                yield (_context_message, None, None, None)\n\n        if tb is not None:\n            yield (_traceback_message, None, None, None)\n\n            tb_temp = tb\n            for entry in traceback.extract_tb(tb):\n                assert tb_temp is not None  # actual tb doesn't end before extract_tb\n                if (\n                    \"cpython_backend\" not in entry.filename\n                    and \"thonny/backend\" not in entry.filename.replace(\"\\\\\", \"/\")\n                    and (\n                        not entry.filename.endswith(os.sep + \"ast.py\")\n                        or entry.name != \"parse\"\n                        or etype is not SyntaxError\n                    )\n                ):\n                    fmt = '  File \"{}\", line {}, in {}\\n'.format(\n                        entry.filename, entry.lineno, entry.name\n                    )\n\n                    if entry.line:\n                        fmt += \"    {}\\n\".format(entry.line.strip())\n\n                    yield (fmt, id(tb_temp.tb_frame), entry.filename, entry.lineno)\n\n                tb_temp = tb_temp.tb_next\n\n            assert tb_temp is None  # tb was exhausted\n\n        for line in traceback.format_exception_only(etype, value):\n            if etype is SyntaxError and line.endswith(\"^\\n\"):\n                # for some reason it may add several empty lines before ^-line\n                partlines = line.splitlines()\n                while len(partlines) >= 2 and partlines[-2].strip() == \"\":\n                    del partlines[-2]\n                line = \"\\n\".join(partlines) + \"\\n\"\n\n            yield (line, None, None, None)\n\n    items = rec_format_exception_with_frame_info(e_type, e_value, e_traceback)\n\n    return list(items)", "is_method": false, "function_description": "Function that formats exception tracebacks with detailed frame information while filtering out specific internal frames, providing enhanced and clearer error tracebacks for debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "in_debug_mode", "line_number": 2834, "body": "def in_debug_mode():\n    return os.environ.get(\"THONNY_DEBUG\", False) in [1, \"1\", True, \"True\", \"true\"]", "is_method": false, "function_description": "Function that checks if the application is running in debug mode by inspecting the \"THONNY_DEBUG\" environment variable, supporting multiple truthy formats. Useful for toggling debug-specific behavior in the program."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_library_file", "line_number": 2838, "body": "def _is_library_file(filename):\n    return (\n        filename is None\n        or path_startswith(filename, sys.prefix)\n        or hasattr(sys, \"base_prefix\")\n        and path_startswith(filename, sys.base_prefix)\n        or hasattr(sys, \"real_prefix\")\n        and path_startswith(filename, getattr(sys, \"real_prefix\"))\n        or site.ENABLE_USER_SITE\n        and path_startswith(filename, site.getusersitepackages())\n    )", "is_method": false, "function_description": "Determines if a given filename belongs to the Python standard library or site-packages directories, useful for distinguishing user code from library files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "get_backend", "line_number": 2851, "body": "def get_backend():\n    return _backend", "is_method": false, "function_description": "Returns the current backend instance used by the system. This function provides access to the underlying backend service or component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_install_signal_handler", "line_number": 159, "body": "def _install_signal_handler(self):\n        import signal\n\n        def signal_handler(signal_, frame):\n            raise KeyboardInterrupt(\"Execution interrupted\")\n\n        if os.name == \"nt\":\n            signal.signal(signal.SIGBREAK, signal_handler)  # pylint: disable=no-member\n        else:\n            signal.signal(signal.SIGINT, signal_handler)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Core utility method of MainCPythonBackend that sets up custom signal handlers to raise KeyboardInterrupt on interruption signals, enabling consistent and controlled handling of execution interrupts across platforms."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_fetch_next_incoming_message", "line_number": 170, "body": "def _fetch_next_incoming_message(self, timeout=None) -> CommandToBackend:\n        # Reading must be done synchronously\n        # https://github.com/thonny/thonny/issues/1363\n        self._read_one_incoming_message()\n        return self._incoming_message_queue.get()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Private method of MainCPythonBackend that synchronously fetches the next incoming command message, optionally waiting up to a specified timeout. It supports command processing by retrieving messages from the internal queue."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_command", "line_number": 176, "body": "def add_command(self, command_name, handler):\n        \"\"\"Handler should be 1-argument function taking command object.\n\n        Handler may return None (in this case no response is sent to frontend)\n        or a BackendResponse\n        \"\"\"\n        self._command_handlers[command_name] = handler", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Adds a command handler function to the backend, associating it with a command name for processing incoming commands. This allows dynamic extension of supported commands with custom handling logic."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_object_info_tweaker", "line_number": 184, "body": "def add_object_info_tweaker(self, tweaker):\n        \"\"\"Tweaker should be 2-argument function taking value and export record\"\"\"\n        self._object_info_tweakers.append(tweaker)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Adds a function that modifies object information during export, enabling customizable adjustments based on the value and its export record. This supports flexible data transformation within the MainCPythonBackend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_import_handler", "line_number": 188, "body": "def add_import_handler(self, module_name, handler):\n        if module_name not in self._import_handlers:\n            self._import_handlers[module_name] = []\n        self._import_handlers[module_name].append(handler)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Core method of MainCPythonBackend that registers callback handlers for specific module imports, enabling customized or extended behavior when those modules are imported."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_source_preprocessor", "line_number": 193, "body": "def add_source_preprocessor(self, func):\n        self._source_preprocessors.append(func)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Adds a preprocessing function to the backend's list for modifying source code before further processing. This enables customizable source code transformations or adaptations within the MainCPythonBackend workflow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_ast_postprocessor", "line_number": 196, "body": "def add_ast_postprocessor(self, func):\n        self._ast_postprocessors.append(func)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Adds a function to the list of AST postprocessors, enabling customization or modification of the abstract syntax tree after its initial processing. This supports extensible AST transformations within the MainCPythonBackend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "get_main_module", "line_number": 199, "body": "def get_main_module(self):\n        return __main__", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Returns the Python main module object, providing access to the script's top-level namespace for other components or functions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_read_incoming_msg_line", "line_number": 202, "body": "def _read_incoming_msg_line(self) -> str:\n        return self._original_stdin.readline()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal method of MainCPythonBackend that reads and returns a single line from the original standard input stream. It provides a low-level input retrieval mechanism for processing incoming data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_user_input", "line_number": 205, "body": "def _handle_user_input(self, msg: InputSubmission) -> None:\n        self._input_queue.put(msg)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal method of MainCPythonBackend that enqueues user input messages for processing, facilitating asynchronous handling of user commands or data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_eof_command", "line_number": 208, "body": "def _handle_eof_command(self, msg: EOFCommand) -> None:\n        self.send_message(ToplevelResponse(SystemExit=True))\n        sys.exit()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Handles an end-of-file command by sending a system exit response and terminating the program immediately. This method enables orderly shutdown signaling within the MainCPythonBackend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_normal_command", "line_number": 212, "body": "def _handle_normal_command(self, cmd: CommandToBackend) -> None:\n        assert isinstance(cmd, (ToplevelCommand, InlineCommand))\n\n        if isinstance(cmd, ToplevelCommand):\n            self._source_info_by_frame = {}\n            self._input_queue = queue.Queue()\n\n        if cmd.name in self._command_handlers:\n            handler = self._command_handlers[cmd.name]\n        else:\n            handler = getattr(self, \"_cmd_\" + cmd.name, None)\n\n        if handler is None:\n            response = {\"error\": \"Unknown command: \" + cmd.name}\n        else:\n            try:\n                response = handler(cmd)\n            except SystemExit as e:\n                # Must be caused by Thonny or plugins code\n                if isinstance(cmd, ToplevelCommand):\n                    logger.exception(\"Unexpected SystemExit\", exc_info=e)\n                response = {\"SystemExit\": True}\n            except UserError as e:\n                sys.stderr.write(str(e) + \"\\n\")\n                response = {}\n            except KeyboardInterrupt:\n                response = {\"user_exception\": self._prepare_user_exception()}\n            except Exception as e:\n                self._report_internal_exception(e)\n                response = {\"context_info\": \"other unhandled exception\"}\n\n        if response is False:\n            # Command doesn't want to send any response\n            return\n\n        real_response = self._prepare_command_response(response, cmd)\n\n        if isinstance(real_response, ToplevelResponse):\n            real_response[\"gui_is_active\"] = (\n                self._get_tcl() is not None or self._get_qt_app() is not None\n            )\n\n        self.send_message(real_response)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Handles a command by selecting and executing the appropriate handler, managing exceptions, preparing the response, and sending it back, thus facilitating robust and dynamic command processing in the backend system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_immediate_command", "line_number": 256, "body": "def _handle_immediate_command(self, cmd: ImmediateCommand) -> None:\n        if cmd.name == \"interrupt\":\n            with self._interrupt_lock:\n                interrupt_local_process()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Handles an immediate \"interrupt\" command by safely triggering a process interruption, ensuring thread-safe execution within the MainCPythonBackend system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_should_keep_going", "line_number": 261, "body": "def _should_keep_going(self) -> bool:\n        return True", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Private method in MainCPythonBackend indicating whether to continue processing, always returning True to signal uninterrupted operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "get_option", "line_number": 264, "body": "def get_option(self, name, default=None):\n        section, subname = self._parse_option_name(name)\n        val = self._get_ini().get(section, subname, fallback=default)\n        try:\n            return ast.literal_eval(val)\n        except Exception:\n            return val", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Method of MainCPythonBackend that retrieves a configuration option by name, returning its parsed value or a default if not found, supporting flexible configuration handling with automatic type evaluation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "set_option", "line_number": 272, "body": "def set_option(self, name, value):\n        ini = self._get_ini()\n        section, subname = self._parse_option_name(name)\n        if not ini.has_section(section):\n            ini.add_section(section)\n        if not isinstance(value, str):\n            value = repr(value)\n        ini.set(section, subname, value)\n        self.save_settings()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Core method of MainCPythonBackend that sets or updates a configuration option by name and value, storing it persistently in an INI-style settings file. It supports automatic section creation and value serialization for flexible configuration management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_parse_option_name", "line_number": 282, "body": "def _parse_option_name(self, name):\n        if \".\" in name:\n            return name.split(\".\", 1)\n        else:\n            return \"general\", name", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal utility of MainCPythonBackend that splits a configuration option name into a namespace and key, defaulting to a general namespace if none is specified."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_ini", "line_number": 288, "body": "def _get_ini(self):\n        if self._ini is None:\n            import configparser\n\n            self._ini = configparser.ConfigParser(interpolation=None)\n            self._ini.read(_CONFIG_FILENAME)\n\n        return self._ini", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal method of MainCPythonBackend that loads and caches configuration settings from an INI file for later access, ensuring the configuration is read only once per instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "save_settings", "line_number": 297, "body": "def save_settings(self):\n        if self._ini is None:\n            return\n\n        with open(_CONFIG_FILENAME, \"w\") as fp:\n            self._ini.write(fp)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Core utility method of the MainCPythonBackend class that saves current configuration settings to a file, ensuring persistent storage of application preferences or parameters."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "switch_env_to_script_mode", "line_number": 304, "body": "def switch_env_to_script_mode(self, cmd):\n        if \"\" in sys.path:\n            sys.path.remove(\"\")  # current directory\n\n        filename = cmd.args[0]\n        if os.path.isfile(filename):\n            sys.path.insert(0, os.path.abspath(os.path.dirname(filename)))\n            __main__.__dict__[\"__file__\"] = filename", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Method of MainCPythonBackend that prepares the Python environment to run a script by adjusting the module search path and setting the script filename, ensuring correct execution context for the given command."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_custom_import", "line_number": 313, "body": "def _custom_import(self, *args, **kw):\n        module = self._original_import(*args, **kw)\n\n        if not hasattr(module, \"__name__\"):\n            return module\n\n        # module specific handlers\n        for handler in self._import_handlers.get(module.__name__, []):\n            try:\n                handler(module)\n            except Exception as e:\n                self._report_internal_exception(e)\n\n        # general handlers\n        for handler in self._import_handlers.get(\"*\", []):\n            try:\n                handler(module)\n            except Exception as e:\n                self._report_internal_exception(e)\n\n        return module", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Core method of MainCPythonBackend that customizes module import by invoking specific and general post-import handlers, enabling extension or modification of imported modules dynamically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_load_plugins", "line_number": 335, "body": "def _load_plugins(self):\n        # built-in plugins\n        try:\n            import thonny.plugins.backend  # pylint: disable=redefined-outer-name\n        except ImportError:\n            # May happen eg. in ssh session\n            return\n\n        try_load_modules_with_frontend_sys_path(\"thonnycontrib\")\n        self._load_plugins_from_path(thonny.plugins.backend.__path__, \"thonny.plugins.backend.\")\n\n        # 3rd party plugins from namespace package\n        try:\n            import thonnycontrib.backend  # @UnresolvedImport\n        except ImportError:\n            # No 3rd party plugins installed\n            pass\n        else:\n            self._load_plugins_from_path(thonnycontrib.backend.__path__, \"thonnycontrib.backend.\")", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Loads built-in and third-party backend plugins, enabling the extension of MainCPythonBackend functionality through modular plugin support."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_load_plugins_from_path", "line_number": 355, "body": "def _load_plugins_from_path(self, path, prefix):\n        load_function_name = \"load_plugin\"\n        for _, module_name, _ in sorted(pkgutil.iter_modules(path, prefix), key=lambda x: x[1]):\n            try:\n                m = importlib.import_module(module_name)\n                if hasattr(m, load_function_name):\n                    f = getattr(m, load_function_name)\n                    sig = inspect.signature(f)\n                    if len(sig.parameters) == 0:\n                        f()\n                    else:\n                        f(self)\n            except Exception as e:\n                logger.exception(\"Failed loading plugin '\" + module_name + \"'\", exc_info=e)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Core method of MainCPythonBackend that dynamically discovers and loads plugin modules from a specified path, invoking their load functions to extend or customize backend functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_environment_info", "line_number": 370, "body": "def _cmd_get_environment_info(self, cmd):\n        return ToplevelResponse(\n            main_dir=self._main_dir,\n            sys_path=sys.path,\n            usersitepackages=site.getusersitepackages() if site.ENABLE_USER_SITE else None,\n            prefix=sys.prefix,\n            welcome_text=\"Python \" + get_python_version_string(),\n            executable=sys.executable,\n            exe_dirs=get_exe_dirs(),\n            in_venv=(\n                hasattr(sys, \"base_prefix\")\n                and sys.base_prefix != sys.prefix\n                or hasattr(sys, \"real_prefix\")\n                and getattr(sys, \"real_prefix\") != sys.prefix\n            ),\n            python_version=get_python_version_string(),\n            cwd=os.getcwd(),\n        )", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides comprehensive information about the current Python environment, including paths, executable details, version, and virtual environment status, supporting environment introspection and diagnostics in the MainCPythonBackend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_cd", "line_number": 389, "body": "def _cmd_cd(self, cmd):\n        if len(cmd.args) == 1:\n            path = cmd.args[0]\n            try:\n                os.chdir(path)\n                return ToplevelResponse()\n            except FileNotFoundError:\n                raise UserError(\"No such folder: \" + path)\n            except OSError as e:\n                raise UserError(\"\\n\".join(traceback.format_exception_only(type(e), e)))\n        else:\n            raise UserError(\"cd takes one parameter\")", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides a command to change the current working directory, validating arguments and handling errors for invalid paths or usage. It enables directory navigation in the MainCPythonBackend context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_Run", "line_number": 402, "body": "def _cmd_Run(self, cmd):\n        self.switch_env_to_script_mode(cmd)\n        return self._execute_file(cmd, SimpleRunner)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal method of MainCPythonBackend that switches the environment to script mode and executes the given command using a simple runner. It facilitates running Python code or scripts within a controlled environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_run", "line_number": 406, "body": "def _cmd_run(self, cmd):\n        return self._execute_file(cmd, SimpleRunner)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Private method in MainCPythonBackend that executes a command string using a simple runner, serving as a utility to run code snippets or scripts within the backend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_FastDebug", "line_number": 409, "body": "def _cmd_FastDebug(self, cmd):\n        self.switch_env_to_script_mode(cmd)\n        return self._execute_file(cmd, FastTracer)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal method of MainCPythonBackend that switches to script mode and executes a command using a fast tracing debugger, facilitating efficient debugging of Python scripts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_Debug", "line_number": 413, "body": "def _cmd_Debug(self, cmd):\n        self.switch_env_to_script_mode(cmd)\n        return self._execute_file(cmd, NiceTracer)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal method of MainCPythonBackend that switches to script mode and executes a command file with tracing support, primarily used for debugging script execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_debug", "line_number": 417, "body": "def _cmd_debug(self, cmd):\n        return self._execute_file(cmd, NiceTracer)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal method of MainCPythonBackend that executes a given command file with debugging/tracing capabilities using the NiceTracer tool."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_execute_source", "line_number": 420, "body": "def _cmd_execute_source(self, cmd):\n        \"\"\"Executes Python source entered into shell\"\"\"\n        self._check_update_tty_mode(cmd)\n        filename = \"<pyshell>\"\n        source = cmd.source.strip()\n\n        try:\n            root = ast.parse(source, filename=filename, mode=\"exec\")\n        except SyntaxError as e:\n            error = \"\".join(traceback.format_exception_only(type(e), e))\n            sys.stderr.write(error)\n            return ToplevelResponse()\n\n        assert isinstance(root, ast.Module)\n\n        result_attributes = self._execute_source(\n            source,\n            filename,\n            \"repl\",\n            NiceTracer if getattr(cmd, \"debug_mode\", False) else SimpleRunner,\n            cmd,\n        )\n\n        return ToplevelResponse(command_name=\"execute_source\", **result_attributes)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Executes Python source code from an interactive shell command, handling syntax errors and returning execution results. It supports debugging modes and manages terminal update states during code execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_execute_system_command", "line_number": 445, "body": "def _cmd_execute_system_command(self, cmd):\n        self._check_update_tty_mode(cmd)\n        try:\n            returncode = execute_system_command(cmd, disconnect_stdin=True)\n            return {\"returncode\": returncode}\n        except Exception as e:\n            logger.exception(\"Could not execute system command %s\", cmd, exc_info=e)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Utility method in MainCPythonBackend that executes a system command safely, returning its exit code and handling any execution errors by logging them."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_process_gui_events", "line_number": 453, "body": "def _cmd_process_gui_events(self, cmd):\n        # advance the event loop\n        try:\n            # First try Tkinter.\n            # Need to update even when tkinter._default_root is None\n            # because otherwise destroyed window will stay up in macOS.\n\n            # When switching between closed user Tk window and another window,\n            # the closed window may reappear in IDLE and CLI REPL\n            tcl = self._get_tcl()\n            if tcl is not None and tcl.has_default_root or tcl.updates_without_root < 1:\n                # http://bugs.python.org/issue989712\n                # http://bugs.python.org/file6090/run.py.diff\n                # https://bugs.python.org/review/989712/diff/4528/Lib/idlelib/run.py\n                tcl.eval(\"update\")\n                # if not tcl.has_default_root:\n                #    tcl.updates_without_root += 1\n            else:\n                # Try Qt only when Tkinter is not used\n                app = self._get_qt_app()\n                if app is not None:\n                    app.processEvents()\n\n        except Exception:\n            pass\n\n        return False", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Handles GUI event processing by advancing the event loop for Tkinter or Qt applications, ensuring the UI remains responsive and windows update correctly during runtime. It enables the backend to manage GUI events seamlessly across supported frameworks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_globals", "line_number": 481, "body": "def _cmd_get_globals(self, cmd):\n        # warnings.warn(\"_cmd_get_globals is deprecated for CPython\")\n        try:\n            return InlineResponse(\n                \"get_globals\",\n                module_name=cmd.module_name,\n                globals=self.export_globals(cmd.module_name),\n            )\n        except Exception as e:\n            return InlineResponse(\"get_globals\", module_name=cmd.module_name, error=str(e))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Utility method in MainCPythonBackend that retrieves and packages the global variables of a specified module, providing error handling for retrieval issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_frame_info", "line_number": 492, "body": "def _cmd_get_frame_info(self, cmd):\n        atts = {}\n        try:\n            # TODO: make it work also in past states\n            frame, location = self._lookup_frame_by_id(cmd[\"frame_id\"])\n            if frame is None:\n                atts[\"error\"] = \"Frame not found\"\n            else:\n                atts[\"code_name\"] = frame.f_code.co_name\n                atts[\"module_name\"] = frame.f_globals[\"__name__\"]\n                atts[\"locals\"] = (\n                    None\n                    if frame.f_locals is frame.f_globals\n                    else self.export_variables(frame.f_locals)\n                )\n                atts[\"globals\"] = self.export_variables(frame.f_globals)\n                atts[\"freevars\"] = frame.f_code.co_freevars\n                atts[\"location\"] = location\n        except Exception as e:\n            atts[\"error\"] = str(e)\n\n        return InlineResponse(\"get_frame_info\", frame_id=cmd.frame_id, **atts)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides detailed information about a specific execution frame, including code name, module, local and global variables, and free variables, facilitating inspection of program state during debugging or runtime analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_active_distributions", "line_number": 515, "body": "def _cmd_get_active_distributions(self, cmd):\n        try:\n            # if it is called after first installation to user site packages\n            # this dir is not yet in sys.path\n            if (\n                site.ENABLE_USER_SITE\n                and site.getusersitepackages()\n                and os.path.exists(site.getusersitepackages())\n                and site.getusersitepackages() not in sys.path\n            ):\n                # insert before first site packages item\n                for i, item in enumerate(sys.path):\n                    if \"site-packages\" in item or \"dist-packages\" in item:\n                        sys.path.insert(i, site.getusersitepackages())\n                        break\n                else:\n                    sys.path.append(site.getusersitepackages())\n\n            import pkg_resources\n\n            pkg_resources._initialize_master_working_set()\n            dists = {\n                dist.key: {\n                    \"project_name\": dist.project_name,\n                    \"key\": dist.key,\n                    \"location\": dist.location,\n                    \"version\": dist.version,\n                }\n                for dist in pkg_resources.working_set  # pylint: disable=not-an-iterable\n            }\n\n            return InlineResponse(\n                \"get_active_distributions\",\n                distributions=dists,\n                usersitepackages=site.getusersitepackages() if site.ENABLE_USER_SITE else None,\n            )\n        except Exception:\n            return InlineResponse(\"get_active_distributions\", error=traceback.format_exc())", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides a snapshot of all active Python package distributions in the current environment, including user site-packages path if enabled. This function aids in inspecting installed packages and their metadata for package management or diagnostics."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_locals", "line_number": 554, "body": "def _cmd_get_locals(self, cmd):\n        for frame in inspect.stack():\n            if id(frame) == cmd.frame_id:\n                return InlineResponse(\"get_locals\", locals=self.export_variables(frame.f_locals))\n\n        raise RuntimeError(\"Frame '{0}' not found\".format(cmd.frame_id))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal method in MainCPythonBackend that retrieves and exports local variables from a specific stack frame identified by a command. It enables inspecting variable states during runtime for debugging or introspection purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_heap", "line_number": 561, "body": "def _cmd_get_heap(self, cmd):\n        result = {}\n        for key in self._heap:\n            result[key] = self.export_value(self._heap[key])\n\n        return InlineResponse(\"get_heap\", heap=result)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Returns a snapshot of the internal heap by exporting its stored values, enabling inspection or debugging of the current backend state within the MainCPythonBackend class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_shell_autocomplete", "line_number": 568, "body": "def _cmd_shell_autocomplete(self, cmd):\n        try_load_modules_with_frontend_sys_path([\"jedi\", \"parso\"])\n\n        error = None\n        try:\n            import jedi\n        except ImportError:\n            jedi = None\n            completions = []\n            error = \"Could not import jedi\"\n        else:\n            try:\n                with warnings.catch_warnings():\n                    jedi_completions = jedi_utils.get_interpreter_completions(\n                        cmd.source, [__main__.__dict__]\n                    )\n                    completions = self._export_completions(jedi_completions)\n            except Exception as e:\n                completions = []\n                logger.info(\"Autocomplete error\", exc_info=e)\n                error = \"Autocomplete error: \" + str(e)\n\n        return InlineResponse(\n            \"shell_autocomplete\", source=cmd.source, completions=completions, error=error\n        )", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides shell command auto-completion by generating possible completions for a given input using the Jedi library, enhancing interactive coding experience with real-time suggestions and error reporting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_editor_autocomplete", "line_number": 594, "body": "def _cmd_editor_autocomplete(self, cmd):\n        try_load_modules_with_frontend_sys_path([\"jedi\", \"parso\"])\n\n        error = None\n        try:\n            import jedi\n\n            self._debug(jedi.__file__, sys.path)\n            with warnings.catch_warnings():\n                jedi_completions = jedi_utils.get_script_completions(\n                    cmd.source, cmd.row, cmd.column, cmd.filename\n                )\n                completions = self._export_completions(jedi_completions)\n\n        except ImportError:\n            jedi = None\n            completions = []\n            error = \"Could not import jedi\"\n        except Exception as e:\n            completions = []\n            logger.info(\"Autocomplete error\", exc_info=e)\n            error = \"Autocomplete error: \" + str(e)\n\n        return InlineResponse(\n            \"editor_autocomplete\",\n            source=cmd.source,\n            row=cmd.row,\n            column=cmd.column,\n            filename=cmd.filename,\n            completions=completions,\n            error=error,\n        )", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides autocomplete suggestions for an editor command using Jedi, returning possible completions or error information to assist code editing and interactive development workflows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_object_info", "line_number": 627, "body": "def _cmd_get_object_info(self, cmd):\n        if isinstance(self._current_executor, NiceTracer) and self._current_executor.is_in_past():\n            info = {\"id\": cmd.object_id, \"error\": \"past info not available\"}\n\n        elif cmd.object_id in self._heap:\n            value = self._heap[cmd.object_id]\n            attributes = {}\n            if cmd.include_attributes:\n                for name in dir(value):\n                    if not name.startswith(\"__\") or cmd.all_attributes:\n                        # attributes[name] = inspect.getattr_static(value, name)\n                        try:\n                            attributes[name] = getattr(value, name)\n                        except Exception:\n                            pass\n\n            self._heap[id(type(value))] = type(value)\n            info = {\n                \"id\": cmd.object_id,\n                \"repr\": repr(value),\n                \"type\": str(type(value)),\n                \"full_type_name\": str(type(value))\n                .replace(\"<class '\", \"\")\n                .replace(\"'>\", \"\")\n                .strip(),\n                \"attributes\": self.export_variables(attributes),\n            }\n\n            if isinstance(value, io.TextIOWrapper):\n                self._add_file_handler_info(value, info)\n            elif isinstance(\n                value,\n                (\n                    types.BuiltinFunctionType,\n                    types.BuiltinMethodType,\n                    types.FunctionType,\n                    types.LambdaType,\n                    types.MethodType,\n                ),\n            ):\n                self._add_function_info(value, info)\n            elif isinstance(value, (list, tuple, set)):\n                self._add_elements_info(value, info)\n            elif isinstance(value, dict):\n                self._add_entries_info(value, info)\n            elif isinstance(value, float):\n                self._add_float_info(value, info)\n            elif hasattr(value, \"image_data\"):\n                info[\"image_data\"] = value.image_data\n\n            for tweaker in self._object_info_tweakers:\n                try:\n                    tweaker(value, info, cmd)\n                except Exception:\n                    logger.exception(\"Failed object info tweaker: \" + str(tweaker))\n\n        else:\n            info = {\"id\": cmd.object_id, \"error\": \"object info not available\"}\n\n        return InlineResponse(\"get_object_info\", id=cmd.object_id, info=info)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Method of MainCPythonBackend that gathers detailed information and metadata about a referenced object, including its attributes and type-specific details, facilitating introspection and debugging within the execution environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_mkdir", "line_number": 688, "body": "def _cmd_mkdir(self, cmd):\n        os.mkdir(cmd.path)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Creates a directory at the specified path. This internal method provides basic directory creation functionality within the MainCPythonBackend class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_delete", "line_number": 691, "body": "def _cmd_delete(self, cmd):\n        for path in cmd.paths:\n            try:\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    import shutil\n\n                    shutil.rmtree(path)\n            except Exception as e:\n                print(\"Could not delete %s: %s\" % (path, str(e)), file=sys.stderr)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal method of MainCPythonBackend that attempts to delete given files or directories, handling errors gracefully without stopping execution. It supports cleanup operations possibly triggered by external commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_sep", "line_number": 703, "body": "def _get_sep(self) -> str:\n        return os.path.sep", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Returns the operating system's default file path separator, facilitating platform-independent file path handling within the MainCPythonBackend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_dir_children_info", "line_number": 706, "body": "def _get_dir_children_info(\n        self, path: str, include_hidden: bool = False\n    ) -> Optional[Dict[str, Dict]]:\n        return get_single_dir_child_data(path, include_hidden)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal helper method of MainCPythonBackend that returns metadata about the contents of a directory, optionally including hidden files or folders. It serves to gather directory child information for further processing or inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_path_info", "line_number": 711, "body": "def _get_path_info(self, path: str) -> Optional[Dict]:\n\n        try:\n            if not os.path.exists(path):\n                return None\n        except OSError:\n            pass\n\n        try:\n            kind = \"dir\" if os.path.isdir(path) else \"file\"\n            return {\n                \"path\": path,\n                \"kind\": kind,\n                \"size\": None if kind == \"dir\" else os.path.getsize(path),\n                \"modified\": os.path.getmtime(path),\n                \"error\": None,\n            }\n        except OSError as e:\n            return {\n                \"path\": path,\n                \"kind\": None,\n                \"size\": None,\n                \"modified\": None,\n                \"error\": str(e),\n            }", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Utility method in MainCPythonBackend that retrieves metadata about a filesystem path, including its type, size, modification time, and error status, to facilitate filesystem-related operations and error handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_export_completions", "line_number": 737, "body": "def _export_completions(self, jedi_completions):\n        result = []\n        for c in jedi_completions:\n            if not c.name.startswith(\"__\"):\n                record = {\n                    \"name\": c.name,\n                    \"complete\": c.complete,\n                    \"type\": c.type,\n                    \"description\": c.description,\n                }\n                \"\"\" TODO: \n                try:\n                    if c.type in [\"class\", \"module\", \"function\"]:\n                        if c.type == \"function\":\n                            record[\"docstring\"] = c.docstring()\n                        else:\n                            record[\"docstring\"] = c.description + \"\\n\" + c.docstring()\n                except Exception:\n                    pass\n                \"\"\"\n                result.append(record)\n        return result", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Creates a filtered list of completion suggestions by extracting relevant attributes from raw completions, excluding special names. It provides simplified and clean completion data for use in code auto-completion features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_tcl", "line_number": 760, "body": "def _get_tcl(self):\n        if self._tcl is not None:\n            return self._tcl\n\n        tkinter = sys.modules.get(\"tkinter\")\n        if tkinter is None:\n            return None\n\n        if self._tcl is None:\n            try:\n                self._tcl = tkinter.Tcl()\n                self._tcl.updates_without_root = 0\n            except Exception as e:\n                logger.error(\"Could not get Tcl\", exc_info=e)\n                self._tcl = None\n                return None\n\n        self._tcl.has_default_root = tkinter._default_root is not None\n        return self._tcl", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides access to a cached Tcl interpreter instance from the tkinter module, initializing it if needed. It supports tkinter-based operations by managing Tcl availability and default root status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_qt_app", "line_number": 780, "body": "def _get_qt_app(self):\n        mod = sys.modules.get(\"PyQt5.QtCore\")\n        if mod is None:\n            mod = sys.modules.get(\"PyQt4.QtCore\")\n        if mod is None:\n            mod = sys.modules.get(\"PySide.QtCore\")\n        if mod is None:\n            return None\n\n        app_class = getattr(mod, \"QCoreApplication\", None)\n        if app_class is not None:\n            try:\n                return app_class.instance()\n            except Exception:\n                return None\n        else:\n            return None", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides access to the existing Qt application instance from multiple Qt bindings (PyQt5, PyQt4, PySide), enabling integration with Qt-based GUI frameworks when available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_add_file_handler_info", "line_number": 798, "body": "def _add_file_handler_info(self, value, info):\n        try:\n            assert isinstance(value.name, str)\n            assert value.mode in (\"r\", \"rt\", \"tr\", \"br\", \"rb\")\n            assert value.errors in (\"strict\", None)\n            assert value.newlines is None or value.tell() > 0\n            # TODO: cache the content\n            # TODO: don't read too big files\n            with open(value.name, encoding=value.encoding) as f:\n                info[\"file_encoding\"] = f.encoding\n                info[\"file_content\"] = f.read()\n                info[\"file_tell\"] = value.tell()\n        except Exception as e:\n            info[\"file_error\"] = \"Could not get file content, error:\" + str(e)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Service method of MainCPythonBackend that attempts to extract and add detailed file handler information, including encoding and content, into a dictionary for further use or diagnostics."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_add_function_info", "line_number": 813, "body": "def _add_function_info(self, value, info):\n        try:\n            info[\"source\"] = inspect.getsource(value)\n        except Exception:\n            pass", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Adds the source code of a given function to an info dictionary, enhancing metadata with the function's implementation details when available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_add_elements_info", "line_number": 819, "body": "def _add_elements_info(self, value, info):\n        info[\"elements\"] = []\n        for element in value:\n            info[\"elements\"].append(self.export_value(element))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Utility method in MainCPythonBackend that adds detailed representations of each element from an iterable value into an info dictionary, supporting structured export of complex data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_add_entries_info", "line_number": 824, "body": "def _add_entries_info(self, value, info):\n        info[\"entries\"] = []\n        for key in value:\n            info[\"entries\"].append((self.export_value(key), self.export_value(value[key])))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Utility method in MainCPythonBackend that populates a given info dictionary with key-value pairs converted via export_value, facilitating structured representation of entries for further processing or export."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_add_float_info", "line_number": 829, "body": "def _add_float_info(self, value, info):\n        if not value.is_integer():\n            info[\"as_integer_ratio\"] = value.as_integer_ratio()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Adds the integer ratio representation of a float to the info dictionary if the float is not an integer. This function supports detailed float analysis within the MainCPythonBackend class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_execute_file", "line_number": 833, "body": "def _execute_file(self, cmd, executor_class):\n        self._check_update_tty_mode(cmd)\n\n        if len(cmd.args) >= 1:\n            sys.argv = cmd.args\n            filename = cmd.args[0]\n            if filename == \"-c\" or os.path.isabs(filename):\n                full_filename = filename\n            else:\n                full_filename = os.path.abspath(filename)\n\n            if full_filename == \"-c\":\n                source = cmd.source\n            else:\n                with tokenize.open(full_filename) as fp:\n                    source = fp.read()\n\n            for preproc in self._source_preprocessors:\n                source = preproc(source, cmd)\n\n            result_attributes = self._execute_source(\n                source, full_filename, \"exec\", executor_class, cmd, self._ast_postprocessors\n            )\n            result_attributes[\"filename\"] = full_filename\n            return ToplevelResponse(command_name=cmd.name, **result_attributes)\n        else:\n            raise UserError(\"Command '%s' takes at least one argument\" % cmd.name)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Core method of MainCPythonBackend that executes a Python source file or command string, supporting preprocessing and customized execution environments, and returns detailed execution results including file context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_execute_source", "line_number": 861, "body": "def _execute_source(\n        self, source, filename, execution_mode, executor_class, cmd, ast_postprocessors=[]\n    ):\n        self._current_executor = executor_class(self, cmd)\n\n        try:\n            return self._current_executor.execute_source(\n                source, filename, execution_mode, ast_postprocessors\n            )\n        finally:\n            self._current_executor = None", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Core method in MainCPythonBackend that executes given source code using a specified executor class and execution mode, supporting AST postprocessing and managing the executor lifecycle."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_install_repl_helper", "line_number": 873, "body": "def _install_repl_helper(self):\n        def _handle_repl_value(obj):\n            if obj is not None:\n                try:\n                    obj_repr = repr(obj)\n                    if len(obj_repr) > 5000:\n                        obj_repr = obj_repr[:5000] + \"\u2026\"\n                except Exception as e:\n                    obj_repr = \"<repr error: \" + str(e) + \">\"\n                print(OBJECT_LINK_START % id(obj), obj_repr, OBJECT_LINK_END, sep=\"\")\n                self._heap[id(obj)] = obj\n                builtins._ = obj\n\n        setattr(builtins, _REPL_HELPER_NAME, _handle_repl_value)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Sets up a helper function that captures and displays Python REPL evaluation results with truncated representations while tracking objects for later reference within the MainCPythonBackend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_install_fake_streams", "line_number": 888, "body": "def _install_fake_streams(self):\n        self._original_stdin = sys.stdin\n        self._original_stdout = sys.stdout\n        self._original_stderr = sys.stderr\n\n        # yes, both out and err will be directed to out (but with different tags)\n        # this allows client to see the order of interleaving writes to stdout/stderr\n        sys.stdin = FakeInputStream(self, sys.stdin)\n        sys.stdout = FakeOutputStream(self, sys.stdout, \"stdout\")\n        sys.stderr = FakeOutputStream(self, sys.stdout, \"stderr\")\n\n        # fake it properly: replace also \"backup\" streams\n        sys.__stdin__ = sys.stdin\n        sys.__stdout__ = sys.stdout\n        sys.__stderr__ = sys.stderr", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Sets up custom fake input and output streams in place of the standard system streams to intercept and tag all stdin, stdout, and stderr data for controlled input/output handling within the MainCPythonBackend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_install_custom_import", "line_number": 904, "body": "def _install_custom_import(self):\n        self._original_import = builtins.__import__\n        builtins.__import__ = self._custom_import", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Sets up a custom import mechanism by replacing Python's built-in import function with a user-defined one, enabling control over module loading behavior within the MainCPythonBackend class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_restore_original_import", "line_number": 908, "body": "def _restore_original_import(self):\n        builtins.__import__ = self._original_import", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Restores the original Python import function by resetting the built-in __import__ to its initial state, ensuring normal module import behavior after temporary overrides."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "send_message", "line_number": 911, "body": "def send_message(self, msg: MessageFromBackend) -> None:\n        sys.stdout.flush()\n\n        if isinstance(msg, ToplevelResponse):\n            if \"cwd\" not in msg:\n                msg[\"cwd\"] = os.getcwd()\n            if \"globals\" not in msg:\n                msg[\"globals\"] = self.export_globals()\n\n        self._original_stdout.write(serialize_message(msg) + \"\\n\")\n        self._original_stdout.flush()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Service method of MainCPythonBackend that sends a serialized backend message to the original standard output, ensuring essential context (like current working directory and globals) is included for top-level responses."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "export_value", "line_number": 923, "body": "def export_value(self, value, max_repr_length=5000):\n        self._heap[id(value)] = value\n        try:\n            rep = repr(value)\n        except Exception:\n            # See https://bitbucket.org/plas/thonny/issues/584/problem-with-thonnys-back-end-obj-no\n            rep = \"??? <repr error>\"\n\n        if len(rep) > max_repr_length:\n            rep = rep[:max_repr_length] + \"\u2026\"\n\n        return ValueInfo(id(value), rep)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides a summarized representation of a Python value, storing it internally and returning its ID and truncated string form for safe display or transmission. Useful for safely handling and representing arbitrary Python objects in external systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "export_variables", "line_number": 936, "body": "def export_variables(self, variables):\n        result = {}\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            for name in variables:\n                if not name.startswith(\"__\"):\n                    result[name] = self.export_value(variables[name], 100)\n\n        return result", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Utility method of MainCPythonBackend that converts given variables into a serialized export format, filtering out system/private names and suppressing warnings during the export process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "export_globals", "line_number": 946, "body": "def export_globals(self, module_name=\"__main__\"):\n        if module_name in sys.modules:\n            return self.export_variables(sys.modules[module_name].__dict__)\n        else:\n            raise RuntimeError(\"Module '{0}' is not loaded\".format(module_name))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Exports the global variables of a specified module, defaulting to \"__main__\". It enables extraction of a module's global state for external use or inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_debug", "line_number": 952, "body": "def _debug(self, *args):\n        logger.debug(\"MainCPythonBackend: \" + str(args))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Private debugging utility of MainCPythonBackend that logs debug messages with a class-specific prefix, aiding in tracing and diagnosing runtime behavior during development or troubleshooting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_enter_io_function", "line_number": 955, "body": "def _enter_io_function(self):\n        self._io_level += 1", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal method of MainCPythonBackend that tracks and increments the current input/output operation depth level to manage nested IO contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_exit_io_function", "line_number": 958, "body": "def _exit_io_function(self):\n        self._io_level -= 1", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Private method in MainCPythonBackend that decreases the internal IO nesting level counter, helping manage the state of nested IO operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "is_doing_io", "line_number": 961, "body": "def is_doing_io(self):\n        return self._io_level > 0", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Checks if the backend is currently performing any input/output operations by indicating whether the IO activity level is above zero. Useful for monitoring or managing concurrent IO processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_export_stack", "line_number": 964, "body": "def _export_stack(self, newest_frame, relevance_checker=None):\n        result = []\n\n        system_frame = newest_frame\n\n        while system_frame is not None:\n            module_name = system_frame.f_globals[\"__name__\"]\n            code_name = system_frame.f_code.co_name\n\n            if not relevance_checker or relevance_checker(system_frame):\n                source, firstlineno, in_library = self._get_frame_source_info(system_frame)\n\n                result.insert(\n                    0,\n                    FrameInfo(\n                        # TODO: can this id be reused by a later frame?\n                        # Need to store the reference to avoid GC?\n                        # I guess it is not required, as id will be required\n                        # only for stacktrace inspection, and sys.last_exception\n                        # will have the reference anyway\n                        # (NiceTracer has its own reference keeping)\n                        id=id(system_frame),\n                        filename=system_frame.f_code.co_filename,\n                        module_name=module_name,\n                        code_name=code_name,\n                        locals=self.export_variables(system_frame.f_locals),\n                        globals=self.export_variables(system_frame.f_globals),\n                        freevars=system_frame.f_code.co_freevars,\n                        source=source,\n                        lineno=system_frame.f_lineno,\n                        firstlineno=firstlineno,\n                        in_library=in_library,\n                        event=\"line\",\n                        focus=TextRange(system_frame.f_lineno, 0, system_frame.f_lineno + 1, 0),\n                        node_tags=None,\n                        current_statement=None,\n                        current_evaluations=None,\n                        current_root_expression=None,\n                    ),\n                )\n\n            if module_name == \"__main__\" and code_name == \"<module>\":\n                # this was last frame relevant to the user\n                break\n\n            system_frame = system_frame.f_back\n\n        assert result  # not empty\n        return result", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Constructs a detailed, ordered list of frame information from the newest stack frame backward, optionally filtering frames, to capture the execution stack trace for debugging or inspection purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_lookup_frame_by_id", "line_number": 1014, "body": "def _lookup_frame_by_id(self, frame_id):\n        def lookup_from_stack(frame):\n            if frame is None:\n                return None\n            elif id(frame) == frame_id:\n                return frame\n            else:\n                return lookup_from_stack(frame.f_back)\n\n        def lookup_from_tb(entry):\n            if entry is None:\n                return None\n            elif id(entry.tb_frame) == frame_id:\n                return entry.tb_frame\n            else:\n                return lookup_from_tb(entry.tb_next)\n\n        result = lookup_from_stack(inspect.currentframe())\n        if result is not None:\n            return result, \"stack\"\n\n        if getattr(sys, \"last_traceback\"):\n            result = lookup_from_tb(getattr(sys, \"last_traceback\"))\n            if result:\n                return result, \"last_traceback\"\n\n        _, _, tb = sys.exc_info()\n        return lookup_from_tb(tb), \"current_exception\"", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Method in MainCPythonBackend that locates and returns a Python execution frame by its ID from the current call stack, last traceback, or active exception, aiding debugging and introspection tools in frame retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_frame_source_info", "line_number": 1043, "body": "def _get_frame_source_info(self, frame):\n        fid = id(frame)\n        if fid not in self._source_info_by_frame:\n            self._source_info_by_frame[fid] = _fetch_frame_source_info(frame)\n\n        return self._source_info_by_frame[fid]", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides cached retrieval of source information for a given frame, optimizing repeated access to frame metadata within the MainCPythonBackend context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_prepare_user_exception", "line_number": 1050, "body": "def _prepare_user_exception(self):\n        e_type, e_value, e_traceback = sys.exc_info()\n        sys.last_type, sys.last_value, sys.last_traceback = (e_type, e_value, e_traceback)\n\n        processed_tb = traceback.extract_tb(e_traceback)\n\n        tb = e_traceback\n        while tb.tb_next is not None:\n            tb = tb.tb_next\n        last_frame = tb.tb_frame\n\n        if e_type is SyntaxError:\n            # Don't show ast frame\n            while last_frame.f_code.co_filename and last_frame.f_code.co_filename == ast.__file__:\n                last_frame = last_frame.f_back\n\n        if e_type is SyntaxError:\n            msg = (\n                traceback.format_exception_only(e_type, e_value)[-1]\n                .replace(e_type.__name__ + \":\", \"\")\n                .strip()\n            )\n        else:\n            msg = str(e_value)\n\n        return {\n            \"type_name\": e_type.__name__,\n            \"message\": msg,\n            \"stack\": self._export_stack(last_frame),\n            \"items\": format_exception_with_frame_info(e_type, e_value, e_traceback),\n            \"filename\": getattr(e_value, \"filename\", processed_tb[-1].filename),\n            \"lineno\": getattr(e_value, \"lineno\", processed_tb[-1].lineno),\n            \"col_offset\": getattr(e_value, \"offset\", None),\n            \"line\": getattr(e_value, \"text\", processed_tb[-1].line),\n        }", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Utility method in MainCPythonBackend that captures and formats details of the current Python exception, providing structured information such as type, message, stack trace, and relevant source code context for error handling or reporting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_check_update_tty_mode", "line_number": 1086, "body": "def _check_update_tty_mode(self, cmd):\n        if \"tty_mode\" in cmd:\n            self._tty_mode = cmd[\"tty_mode\"]", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Private method of MainCPythonBackend that updates the terminal mode setting based on the provided command dictionary. It ensures the backend's tty_mode reflects the latest configuration when specified."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "isatty", "line_number": 1097, "body": "def isatty(self):\n        return self._backend._tty_mode and (os.name != \"nt\" or \"click\" not in sys.modules)", "is_method": true, "class_name": "FakeStream", "function_description": "Checks if the stream is connected to a terminal enabling interactive features, considering platform and environment specifics for compatibility. This helps determine if terminal-dependent behavior should be enabled."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "__getattr__", "line_number": 1100, "body": "def __getattr__(self, name):\n        # TODO: is it safe to perform those other functions without notifying backend\n        # via _enter_io_function?\n        return getattr(self._target_stream, name)", "is_method": true, "class_name": "FakeStream", "function_description": "This method forwards attribute access to an internal target stream, enabling the FakeStream to transparently mimic another stream object's interface. It supports seamless delegation of operations to the wrapped stream."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "write", "line_number": 1111, "body": "def write(self, data):\n        try:\n            self._backend._enter_io_function()\n            # click may send bytes instead of strings\n            if isinstance(data, bytes):\n                data = data.decode(errors=\"replace\")\n\n            if data != \"\":\n                self._backend._send_output(data=data, stream_name=self._stream_name)\n                self._processed_symbol_count += len(data)\n        finally:\n            self._backend._exit_io_function()", "is_method": true, "class_name": "FakeOutputStream", "function_description": "Utility method of FakeOutputStream that processes and sends string or byte data to a backend output stream, tracking the amount of data processed during the operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "writelines", "line_number": 1124, "body": "def writelines(self, lines):\n        try:\n            self._backend._enter_io_function()\n            self.write(\"\".join(lines))\n        finally:\n            self._backend._exit_io_function()", "is_method": true, "class_name": "FakeOutputStream", "function_description": "Provides a method to write multiple lines to the output stream as a single concatenated string, managing associated I/O operation lifecycle hooks. It facilitates batch writing combined with backend I/O state control."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_generic_read", "line_number": 1138, "body": "def _generic_read(self, method, original_limit):\n        if original_limit is None:\n            effective_limit = -1\n        elif method == \"readlines\" and original_limit > -1:\n            # NB! size hint is defined in weird way\n            # \"no more lines will be read if the total size (in bytes/characters)\n            # of all lines so far **exceeds** the hint\".\n            effective_limit = original_limit + 1\n        else:\n            effective_limit = original_limit\n\n        try:\n            self._backend._enter_io_function()\n            while True:\n                if effective_limit == 0:\n                    result = \"\"\n                    break\n\n                elif effective_limit > 0 and len(self._buffer) >= effective_limit:\n                    result = self._buffer[:effective_limit]\n                    self._buffer = self._buffer[effective_limit:]\n                    if method == \"readlines\" and not result.endswith(\"\\n\") and \"\\n\" in self._buffer:\n                        # limit is just a hint\n                        # https://docs.python.org/3/library/io.html#io.IOBase.readlines\n                        extra = self._buffer[: self._buffer.find(\"\\n\") + 1]\n                        result += extra\n                        self._buffer = self._buffer[len(extra) :]\n                    break\n\n                elif method == \"readline\" and \"\\n\" in self._buffer:\n                    pos = self._buffer.find(\"\\n\") + 1\n                    result = self._buffer[:pos]\n                    self._buffer = self._buffer[pos:]\n                    break\n\n                elif self._eof:\n                    result = self._buffer\n                    self._buffer = \"\"\n                    self._eof = False  # That's how official implementation does\n                    break\n\n                else:\n                    self._backend.send_message(\n                        BackendEvent(\"InputRequest\", method=method, limit=original_limit)\n                    )\n                    msg = self._backend._fetch_next_incoming_message()\n                    if isinstance(msg, InputSubmission):\n                        self._buffer += msg.data\n                        self._processed_symbol_count += len(msg.data)\n                    elif isinstance(msg, EOFCommand):\n                        self._eof = True\n                    elif isinstance(msg, InlineCommand):\n                        self._backend._handle_normal_command(msg)\n                    else:\n                        raise RuntimeError(\n                            \"Wrong type of command (%r) when waiting for input\" % (msg,)\n                        )\n\n            return result\n\n        finally:\n            self._backend._exit_io_function()", "is_method": true, "class_name": "FakeInputStream", "function_description": "Method of FakeInputStream that handles reading data with various limits and modes, managing an internal buffer and asynchronously obtaining input from a backend until requested data is available or EOF is reached. It supports read, readline, and readlines behaviors with input coordination."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "read", "line_number": 1201, "body": "def read(self, limit=-1):\n        return self._generic_read(\"read\", limit)", "is_method": true, "class_name": "FakeInputStream", "function_description": "This method provides a read operation that returns data from the input stream up to a specified limit, acting as a standard interface for reading stream content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "readline", "line_number": 1204, "body": "def readline(self, limit=-1):\n        return self._generic_read(\"readline\", limit)", "is_method": true, "class_name": "FakeInputStream", "function_description": "Method of the FakeInputStream class that reads and returns a single line from the input stream, optionally limited by a specified number of characters."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "readlines", "line_number": 1207, "body": "def readlines(self, limit=-1):\n        return self._generic_read(\"readlines\", limit).splitlines(True)", "is_method": true, "class_name": "FakeInputStream", "function_description": "Provides a lines-reading capability that returns the content as a list of lines, optionally limited by the given parameter. It supports reading text line-by-line from the FakeInputStream source."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "__next__", "line_number": 1210, "body": "def __next__(self):\n        result = self.readline()\n        if not result:\n            raise StopIteration\n\n        return result", "is_method": true, "class_name": "FakeInputStream", "function_description": "Implements iteration for FakeInputStream, returning the next line until the stream ends. Enables the object to be used as an iterator producing lines sequentially."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "__iter__", "line_number": 1217, "body": "def __iter__(self):\n        return self", "is_method": true, "class_name": "FakeInputStream", "function_description": "Enables iteration over the FakeInputStream instance by returning itself as an iterator. This supports using the object directly in loops or other iterable contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "execute_source", "line_number": 1256, "body": "def execute_source(self, source, filename, mode, ast_postprocessors):\n        if isinstance(source, str):\n            # TODO: simplify this or make sure encoding is correct\n            source = source.encode(\"utf-8\")\n\n        if os.path.exists(filename):\n            self._main_module_path = filename\n\n        global_vars = __main__.__dict__\n\n        try:\n            if mode == \"repl\":\n                assert not ast_postprocessors\n                # Useful in shell to get last expression value in multi-statement block\n                root = self._prepare_ast(source, filename, \"exec\")\n                # https://bugs.python.org/issue35894\n                # https://github.com/pallets/werkzeug/pull/1552/files#diff-9e75ca133f8601f3b194e2877d36df0eR950\n                module = ast.parse(\"\")\n                module.body = root.body\n                self._instrument_repl_code(module)\n                statements = compile(module, filename, \"exec\")\n            elif mode == \"exec\":\n                root = self._prepare_ast(source, filename, mode)\n                for func in ast_postprocessors:\n                    func(root)\n                statements = compile(root, filename, mode)\n            else:\n                raise ValueError(\"Unknown mode\", mode)\n\n            return self._execute_prepared_user_code(statements, global_vars)\n        except SyntaxError:\n            return {\"user_exception\": self._backend._prepare_user_exception()}\n        except SystemExit:\n            return {\"SystemExit\": True}\n        except Exception as e:\n            self._backend._report_internal_exception(e)\n            return {}", "is_method": true, "class_name": "Executor", "function_description": "Method of the Executor class that compiles and runs Python source code with optional AST modifications, supporting REPL and script execution modes while handling syntax and runtime exceptions gracefully."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_execute_prepared_user_code", "line_number": 1296, "body": "def _execute_prepared_user_code(self, statements, global_vars):\n        exec(statements, global_vars)", "is_method": true, "class_name": "Executor", "function_description": "Internal method of the Executor class that runs given Python code statements within a specified global variable context. It enables dynamic execution of preprocessed user code segments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_prepare_ast", "line_number": 1303, "body": "def _prepare_ast(self, source, filename, mode):\n        return ast.parse(source, filename, mode)", "is_method": true, "class_name": "Executor", "function_description": "Private method in Executor that parses Python source code into an abstract syntax tree (AST) for further analysis or execution. It serves as a utility to convert code text into a structured format for processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_instrument_repl_code", "line_number": 1306, "body": "def _instrument_repl_code(self, root):\n        # modify all expression statements to print and register their non-None values\n        for node in ast.walk(root):\n            if (\n                isinstance(node, ast.FunctionDef)\n                or hasattr(ast, \"AsyncFunctionDef\")\n                and isinstance(node, ast.AsyncFunctionDef)\n            ):\n                first_stmt = node.body[0]\n                if isinstance(first_stmt, ast.Expr) and isinstance(first_stmt.value, ast.Str):\n                    first_stmt.contains_docstring = True\n            if isinstance(node, ast.Expr) and not getattr(node, \"contains_docstring\", False):\n                node.value = ast.Call(\n                    func=ast.Name(id=_REPL_HELPER_NAME, ctx=ast.Load()),\n                    args=[node.value],\n                    keywords=[],\n                )\n                ast.fix_missing_locations(node)", "is_method": true, "class_name": "Executor", "function_description": "Adds instrumentation to code by modifying expressions to print and register their non-None results, supporting interactive REPL environments with enhanced output tracking and value capturing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_canonic_path", "line_number": 1362, "body": "def _get_canonic_path(self, path):\n        # adapted from bdb\n        result = self._canonic_path_cache.get(path)\n        if result is None:\n            if path.startswith(\"<\"):\n                result = path\n            else:\n                result = os.path.normcase(os.path.abspath(path))\n\n            self._canonic_path_cache[path] = result\n\n        return result", "is_method": true, "class_name": "Tracer", "function_description": "Returns a normalized, absolute file path for a given path string, caching results for efficiency. This helps ensure consistent path representations within tracing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_execute_prepared_user_code", "line_number": 1378, "body": "def _execute_prepared_user_code(self, statements, global_vars):\n        try:\n            sys.settrace(self._trace)\n            if hasattr(sys, \"breakpointhook\"):\n                old_breakpointhook = sys.breakpointhook\n                sys.breakpointhook = self._breakpointhook\n\n            return super()._execute_prepared_user_code(statements, global_vars)\n        finally:\n            sys.settrace(None)\n            if hasattr(sys, \"breakpointhook\"):\n                sys.breakpointhook = old_breakpointhook", "is_method": true, "class_name": "Tracer", "function_description": "Core method of the Tracer class that runs user-provided code with tracing enabled, allowing custom breakpoint and trace handling during execution. It ensures trace settings are properly applied and restored around the code run."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_interesting_frame", "line_number": 1391, "body": "def _is_interesting_frame(self, frame):\n        code = frame.f_code\n\n        return not (\n            code is None\n            or code.co_filename is None\n            or not self._is_interesting_module_file(code.co_filename)\n            or code.co_flags & _CO_GENERATOR\n            and code.co_flags & _CO_COROUTINE\n            and code.co_flags & _CO_ITERABLE_COROUTINE\n            and code.co_flags & _CO_ASYNC_GENERATOR\n            # or \"importlib._bootstrap\" in code.co_filename\n            or code.co_name in [\"<listcomp>\", \"<setcomp>\", \"<dictcomp>\"]\n        )", "is_method": true, "class_name": "Tracer", "function_description": "Determines whether a given stack frame is relevant for tracing by filtering out frames from uninteresting files, generator/coroutine frames, and specific internal or comprehension-related code frames."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_interesting_module_file", "line_number": 1406, "body": "def _is_interesting_module_file(self, path):\n        # interesting files are the files in the same directory as main module\n        # or the ones with breakpoints\n        # When command is \"resume\", then only modules with breakpoints are interesting\n        # (used to be more flexible, but this caused problems\n        # when main script was in ~/. Then user site library became interesting as well)\n\n        result = self._file_interest_cache.get(path, None)\n        if result is not None:\n            return result\n\n        _, extension = os.path.splitext(path.lower())\n\n        result = (\n            self._get_breakpoints_in_file(path)\n            or self._main_module_path is not None\n            and is_same_path(path, self._main_module_path)\n            or extension in (\".py\", \".pyw\")\n            and (\n                self._current_command.get(\"allow_stepping_into_libraries\", False)\n                or (\n                    path_startswith(path, os.path.dirname(self._main_module_path))\n                    # main module may be at the root of the fs\n                    and not path_startswith(path, sys.prefix)\n                    and not path_startswith(path, sys.base_prefix)\n                    and not path_startswith(path, site.getusersitepackages() or \"usersitenotexists\")\n                )\n            )\n            and not path_startswith(path, self._thonny_src_dir)\n        )\n\n        self._file_interest_cache[path] = result\n\n        return result", "is_method": true, "class_name": "Tracer", "function_description": "Determines if a file path is \"interesting\" for debugging by checking breakpoints, location relative to the main module, file extension, and user settings. This helps the Tracer focus on relevant code files during debugging sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_interesting_exception", "line_number": 1441, "body": "def _is_interesting_exception(self, frame, arg):\n        return arg[0] not in (StopIteration, StopAsyncIteration)", "is_method": true, "class_name": "Tracer", "function_description": "Utility method in Tracer that determines if an exception should be considered noteworthy by excluding common iteration-ending exceptions like StopIteration and StopAsyncIteration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_fetch_next_debugger_command", "line_number": 1444, "body": "def _fetch_next_debugger_command(self, current_frame):\n        while True:\n            cmd = self._backend._fetch_next_incoming_message()\n            if isinstance(cmd, InlineCommand):\n                self._backend._handle_normal_command(cmd)\n            else:\n                assert isinstance(cmd, DebuggerCommand)\n                self._prev_breakpoints = self._current_command.breakpoints\n                self._current_command = cmd\n                self._initialize_new_command(current_frame)\n                return", "is_method": true, "class_name": "Tracer", "function_description": "Internal method of the Tracer class that processes and updates the next debugger command from the backend, handling inline commands until a new debugger command is ready for execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_initialize_new_command", "line_number": 1456, "body": "def _initialize_new_command(self, current_frame):\n        self._command_completion_handler = getattr(\n            self, \"_cmd_%s_completed\" % self._current_command.name\n        )\n\n        if self._current_command.breakpoints != self._prev_breakpoints:\n            self._file_interest_cache = {}  # because there may be new breakpoints\n            self._file_breakpoints_cache = {}\n            for path, linenos in self._current_command.breakpoints.items():\n                self._file_breakpoints_cache[path] = linenos\n                self._file_breakpoints_cache[self._get_canonic_path(path)] = linenos", "is_method": true, "class_name": "Tracer", "function_description": "Initializes a new debugging command by setting its completion handler and updating breakpoint caches when breakpoint configurations change. This facilitates accurate breakpoint tracking during command execution in the Tracer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_register_affected_frame", "line_number": 1468, "body": "def _register_affected_frame(self, exception_obj, frame):\n        # I used to store the frame ids in a new field inside exception object,\n        # but Python 3.8 doesn't allow this (https://github.com/thonny/thonny/issues/1403)\n        exc_id = id(exception_obj)\n        if exc_id not in self._affected_frame_ids_per_exc_id:\n            self._affected_frame_ids_per_exc_id[exc_id] = set()\n        self._affected_frame_ids_per_exc_id[exc_id].add(id(frame))", "is_method": true, "class_name": "Tracer", "function_description": "Internal method of the Tracer class that tracks and records identifiers of stack frames affected by a specific exception instance during execution, supporting exception-frame correlation for debugging or tracing purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_breakpoints_in_file", "line_number": 1476, "body": "def _get_breakpoints_in_file(self, filename):\n        result = self._file_breakpoints_cache.get(filename, None)\n\n        if result is not None:\n            return result\n\n        canonic_path = self._get_canonic_path(filename)\n        result = self._file_breakpoints_cache.get(canonic_path, set())\n        self._file_breakpoints_cache[filename] = result\n        return result", "is_method": true, "class_name": "Tracer", "function_description": "Core utility method of the Tracer class that retrieves cached breakpoints for a given file, supporting both original and canonical file paths to enable efficient breakpoint management during debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_current_exception", "line_number": 1487, "body": "def _get_current_exception(self):\n        if self._fresh_exception is not None:\n            return self._fresh_exception\n        else:\n            return sys.exc_info()", "is_method": true, "class_name": "Tracer", "function_description": "Private method of the Tracer class that returns the current active exception, prioritizing a stored fresh exception if available, otherwise retrieving the most recent exception info from the system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_export_exception_info", "line_number": 1493, "body": "def _export_exception_info(self):\n        exc = self._get_current_exception()\n\n        if exc[0] is None:\n            return {\n                \"id\": None,\n                \"msg\": None,\n                \"type_name\": None,\n                \"lines_with_frame_info\": None,\n                \"affected_frame_ids\": set(),\n                \"is_fresh\": False,\n            }\n        else:\n            return {\n                \"id\": id(exc[1]),\n                \"msg\": str(exc[1]),\n                \"type_name\": exc[0].__name__,\n                \"lines_with_frame_info\": format_exception_with_frame_info(*exc),\n                \"affected_frame_ids\": self._affected_frame_ids_per_exc_id.get(id(exc[1]), set()),\n                \"is_fresh\": exc == self._fresh_exception,\n            }", "is_method": true, "class_name": "Tracer", "function_description": "Returns detailed information about the current exception, including its type, message, stack frames, and related metadata for error tracing and debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_check_notify_return", "line_number": 1518, "body": "def _check_notify_return(self, frame_id):\n        if frame_id in self._last_reported_frame_ids:\n            # Need extra notification, because it may be long time until next interesting event\n            self._backend.send_message(InlineResponse(\"debugger_return\", frame_id=frame_id))", "is_method": true, "class_name": "Tracer", "function_description": "Internal method of Tracer that triggers a debug notification when a frame return event repeats, ensuring timely updates during potentially long periods without other debugger events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_check_store_main_frame_id", "line_number": 1523, "body": "def _check_store_main_frame_id(self, frame):\n        # initial command doesn't have a frame id\n        if self._current_command.frame_id is None and self._get_canonic_path(\n            frame.f_code.co_filename\n        ) == self._get_canonic_path(self._main_module_path):\n            self._current_command.frame_id = id(frame)", "is_method": true, "class_name": "Tracer", "function_description": "Private method in Tracer that assigns a unique frame identifier to the main module frame of the current command if it hasn't been set, ensuring correct frame tracking during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_initialize_new_command", "line_number": 1539, "body": "def _initialize_new_command(self, current_frame):\n        super()._initialize_new_command(current_frame)\n        self._command_frame_returned = False\n        if self._current_command.breakpoints != self._prev_breakpoints:\n            self._code_breakpoints_cache = {}\n\n            # restore tracing for active frames which were skipped before\n            # but have breakpoints now\n            frame = current_frame\n            while frame is not None:\n                if (\n                    frame.f_trace is None\n                    and frame.f_code is not None\n                    and self._get_breakpoints_in_code(frame.f_code)\n                ):\n                    frame.f_trace = self._trace\n\n                frame = frame.f_back", "is_method": true, "class_name": "FastTracer", "function_description": "Initializes a new tracing command by resetting state and ensuring frames with updated breakpoints are actively traced, enabling accurate breakpoint management during program execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_breakpointhook", "line_number": 1558, "body": "def _breakpointhook(self, *args, **kw):\n        frame = inspect.currentframe()\n        while not self._is_interesting_frame(frame):\n            frame = frame.f_back\n        self._report_current_state(frame)\n        self._fetch_next_debugger_command(frame)", "is_method": true, "class_name": "FastTracer", "function_description": "Internal debugging method of the FastTracer class that identifies the relevant stack frame and handles debugger commands during breakpoint execution. It supports interactive tracing by managing the current program state and user inputs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_should_skip_frame", "line_number": 1565, "body": "def _should_skip_frame(self, frame, event):\n        if event == \"call\":\n            # new frames\n            return (\n                (\n                    self._current_command.name == \"resume\"\n                    and not self._get_breakpoints_in_code(frame.f_code)\n                    or self._current_command.name == \"step_over\"\n                    and not self._get_breakpoints_in_code(frame.f_code)\n                    and id(frame) not in self._last_reported_frame_ids\n                    or self._current_command.name == \"step_out\"\n                    and not self._get_breakpoints_in_code(frame.f_code)\n                )\n                or not self._is_interesting_frame(frame)\n                or self._backend.is_doing_io()\n            )\n\n        else:\n            # once we have entered a frame, we need to reach the return event\n            return False", "is_method": true, "class_name": "FastTracer", "function_description": "Determines whether a debugging frame should be skipped based on the current tracing command, breakpoint presence, frame relevance, and ongoing I/O, helping optimize which frames the debugger processes during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_trace", "line_number": 1586, "body": "def _trace(self, frame, event, arg):\n        if self._should_skip_frame(frame, event):\n            return None\n\n        # return None\n        # return self._trace\n\n        frame_id = id(frame)\n\n        if event == \"call\":\n            self._check_store_main_frame_id(frame)\n\n            self._fresh_exception = None\n            # can we skip this frame?\n            if self._current_command.name == \"step_over\" and not self._current_command.breakpoints:\n                return None\n\n        elif event == \"return\":\n            self._fresh_exception = None\n            if frame_id == self._current_command[\"frame_id\"]:\n                self._command_frame_returned = True\n            self._check_notify_return(frame_id)\n\n        elif event == \"exception\":\n            if self._is_interesting_exception(frame, arg):\n                self._fresh_exception = arg\n                self._register_affected_frame(arg[1], frame)\n                # UI doesn't know about separate exception events\n                self._report_current_state(frame)\n                self._fetch_next_debugger_command(frame)\n\n        elif event == \"line\":\n            self._fresh_exception = None\n\n            if self._command_completion_handler(frame):\n                self._report_current_state(frame)\n                self._fetch_next_debugger_command(frame)\n\n        else:\n            self._fresh_exception = None\n\n        return self._trace", "is_method": true, "class_name": "FastTracer", "function_description": "Core tracing method of the FastTracer class that monitors and handles different execution events (call, return, exception, line) to support debugging commands and state reporting during program execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_report_current_state", "line_number": 1629, "body": "def _report_current_state(self, frame):\n        stack = self._backend._export_stack(frame, self._is_interesting_frame)\n        msg = DebuggerResponse(\n            stack=stack,\n            in_present=True,\n            io_symbol_count=None,\n            exception_info=self._export_exception_info(),\n            tracer_class=\"FastTracer\",\n        )\n\n        self._last_reported_frame_ids = set(map(lambda f: f.id, stack))\n\n        self._backend.send_message(msg)", "is_method": true, "class_name": "FastTracer", "function_description": "Internal method of FastTracer that compiles and sends the current execution stack and exception details to the backend for debugging and tracing purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_into_completed", "line_number": 1643, "body": "def _cmd_step_into_completed(self, frame):\n        return True", "is_method": true, "class_name": "FastTracer", "function_description": "Core method in FastTracer that signals the completion of a step-into debugging command, always indicating the step is done."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_over_completed", "line_number": 1646, "body": "def _cmd_step_over_completed(self, frame):\n        return (\n            id(frame) == self._current_command.frame_id\n            or self._command_frame_returned\n            or self._at_a_breakpoint(frame)\n        )", "is_method": true, "class_name": "FastTracer", "function_description": "Private method of FastTracer that determines if the current step-over command has finished by checking frame identity, return status, or breakpoint presence. It helps control execution flow during debugging operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_out_completed", "line_number": 1653, "body": "def _cmd_step_out_completed(self, frame):\n        return self._command_frame_returned or self._at_a_breakpoint(frame)", "is_method": true, "class_name": "FastTracer", "function_description": "Private method checking if a step-out debugging command has finished by verifying if the command's return frame is reached or a breakpoint is encountered. It helps manage control flow during code tracing in debugging sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_resume_completed", "line_number": 1656, "body": "def _cmd_resume_completed(self, frame):\n        return self._at_a_breakpoint(frame)", "is_method": true, "class_name": "FastTracer", "function_description": "Private method in FastTracer that checks if the given frame is currently at a breakpoint, indicating whether execution should resume."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_breakpoints_in_code", "line_number": 1659, "body": "def _get_breakpoints_in_code(self, f_code):\n\n        bps_in_file = self._get_breakpoints_in_file(f_code.co_filename)\n\n        code_id = id(f_code)\n        result = self._code_breakpoints_cache.get(code_id, None)\n\n        if result is None:\n            if not bps_in_file:\n                result = set()\n            else:\n                co_linenos = self._code_linenos_cache.get(code_id, None)\n                if co_linenos is None:\n                    co_linenos = {pair[1] for pair in dis.findlinestarts(f_code)}\n                    self._code_linenos_cache[code_id] = co_linenos\n\n                result = bps_in_file.intersection(co_linenos)\n\n            self._code_breakpoints_cache[code_id] = result\n\n        return result", "is_method": true, "class_name": "FastTracer", "function_description": "Core utility method of FastTracer that identifies and caches breakpoints located within a given code object, enabling efficient detection of active breakpoints relevant to that specific piece of code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_at_a_breakpoint", "line_number": 1681, "body": "def _at_a_breakpoint(self, frame):\n        # TODO: try re-entering same line in loop\n        return frame.f_lineno in self._get_breakpoints_in_code(frame.f_code)", "is_method": true, "class_name": "FastTracer", "function_description": "Internal utility method of the FastTracer class that checks if the current execution frame is at a set breakpoint line, facilitating breakpoint management during code tracing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_interesting_exception", "line_number": 1685, "body": "def _is_interesting_exception(self, frame, arg):\n        return super()._is_interesting_exception(frame, arg) and (\n            self._current_command.name in [\"step_into\", \"step_over\"]\n            and (\n                # in command frame or its parent frames\n                id(frame) == self._current_command[\"frame_id\"]\n                or self._command_frame_returned\n            )\n        )", "is_method": true, "class_name": "FastTracer", "function_description": "Determines if an exception is relevant based on the current debugging command and frame context, aiding controlled exception tracing during stepping commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_breakpointhook", "line_number": 1710, "body": "def _breakpointhook(self, *args, **kw):\n        self._report_state(len(self._saved_states) - 1)\n        self._fetch_next_debugger_command(None)", "is_method": true, "class_name": "NiceTracer", "function_description": "Internal method of NiceTracer that handles breakpoint actions by reporting the current debugger state and fetching the next debugging command during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_install_marker_functions", "line_number": 1714, "body": "def _install_marker_functions(self):\n        # Make dummy marker functions universally available by putting them\n        # into builtin scope\n        self.marker_function_names = {\n            BEFORE_STATEMENT_MARKER,\n            AFTER_STATEMENT_MARKER,\n            BEFORE_EXPRESSION_MARKER,\n            AFTER_EXPRESSION_MARKER,\n        }\n\n        for name in self.marker_function_names:\n            if not hasattr(builtins, name):\n                setattr(builtins, name, getattr(self, name))", "is_method": true, "class_name": "NiceTracer", "function_description": "Internal method of NiceTracer that injects marker functions into the built-in namespace to enable tracing hooks before and after statements and expressions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_prepare_ast", "line_number": 1728, "body": "def _prepare_ast(self, source, filename, mode):\n        # ast_utils need to be imported after asttokens\n        # is (custom-)imported\n        try_load_modules_with_frontend_sys_path([\"asttokens\", \"six\", \"astroid\"])\n        from thonny import ast_utils\n\n        root = ast.parse(source, filename, mode)\n\n        ast_utils.mark_text_ranges(root, source)\n        self._tag_nodes(root)\n        self._insert_expression_markers(root)\n        self._insert_statement_markers(root)\n        self._insert_for_target_markers(root)\n        self._instrumented_files.add(filename)\n\n        return root", "is_method": true, "class_name": "NiceTracer", "function_description": "Core method of NiceTracer that prepares and annotates an abstract syntax tree (AST) from source code, enabling detailed tracing and instrumentation of Python code execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_should_skip_frame", "line_number": 1745, "body": "def _should_skip_frame(self, frame, event):\n        # nice tracer can't skip any of the frames which need to be\n        # shown in the stacktrace\n        code = frame.f_code\n        if code is None:\n            return True\n\n        if event == \"call\":\n            # new frames\n            if code.co_name in self.marker_function_names:\n                return False\n\n            else:\n                return not self._is_interesting_frame(frame) or self._backend.is_doing_io()\n\n        else:\n            # once we have entered a frame, we need to reach the return event\n            return False", "is_method": true, "class_name": "NiceTracer", "function_description": "Determines whether a given stack frame should be excluded from tracing output based on its relevance and execution state, helping to filter unimportant frames during stack trace generation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_interesting_frame", "line_number": 1764, "body": "def _is_interesting_frame(self, frame):\n        return (\n            frame.f_code.co_filename in self._instrumented_files\n            and super()._is_interesting_frame(frame)\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "Utility method in NiceTracer that determines whether a stack frame originates from instrumented files and meets the base class criteria, aiding selective tracing during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "find_spec", "line_number": 1770, "body": "def find_spec(self, fullname, path=None, target=None):\n        spec = PathFinder.find_spec(fullname, path, target)\n\n        if (\n            spec is not None\n            and isinstance(spec.loader, SourceFileLoader)\n            and getattr(spec, \"origin\", None)\n            and self._is_interesting_module_file(spec.origin)\n        ):\n            spec.loader = FancySourceFileLoader(fullname, spec.origin, self)\n            return spec\n        else:\n            return super().find_spec(fullname, path, target)", "is_method": true, "class_name": "NiceTracer", "function_description": "Provides a customized module finder that intercepts and modifies loading of certain source files deemed \"interesting,\" allowing special handling during Python module import within the NiceTracer context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "is_in_past", "line_number": 1784, "body": "def is_in_past(self):\n        return self._current_state_index < len(self._saved_states) - 1", "is_method": true, "class_name": "NiceTracer", "function_description": "Checks if the tracer's current state is earlier than the latest saved state, indicating a position in the past relative to its saved history. Useful for navigation through state changes or undo functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_trace", "line_number": 1787, "body": "def _trace(self, frame, event, arg):\n        try:\n            return self._trace_and_catch(frame, event, arg)\n        except BaseException as e:\n            logger.exception(\"Exception in _trace\", exc_info=e)\n            sys.settrace(None)\n            return None", "is_method": true, "class_name": "NiceTracer", "function_description": "Internal tracing method of NiceTracer that delegates tracing to another handler and disables tracing on exceptions to ensure stable execution and logging of any errors during tracing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_trace_and_catch", "line_number": 1795, "body": "def _trace_and_catch(self, frame, event, arg):\n        \"\"\"\n        1) Detects marker calls and responds to client queries in these spots\n        2) Maintains a customized view of stack\n        \"\"\"\n        # frame skipping test should be done both in new frames and old ones (because of Resume)\n        # Note that intermediate frames can't be skipped when jumping to a breakpoint\n        # because of the need to maintain custom stack\n        if self._should_skip_frame(frame, event):\n            return None\n\n        code_name = frame.f_code.co_name\n\n        if event == \"call\":\n            self._fresh_exception = (\n                None  # some code is running, therefore exception is not fresh anymore\n            )\n\n            if code_name in self.marker_function_names:\n                self._check_store_main_frame_id(frame.f_back)\n\n                # the main thing\n                if code_name == BEFORE_STATEMENT_MARKER:\n                    event = \"before_statement\"\n                elif code_name == AFTER_STATEMENT_MARKER:\n                    event = \"after_statement\"\n                elif code_name == BEFORE_EXPRESSION_MARKER:\n                    event = \"before_expression\"\n                elif code_name == AFTER_EXPRESSION_MARKER:\n                    event = \"after_expression\"\n                else:\n                    raise AssertionError(\"Unknown marker function\")\n\n                marker_function_args = frame.f_locals.copy()\n                node = self._nodes[marker_function_args[\"node_id\"]]\n\n                del marker_function_args[\"self\"]\n\n                if \"call_function\" not in node.tags:\n                    self._handle_progress_event(frame.f_back, event, marker_function_args, node)\n                self._try_interpret_as_again_event(frame.f_back, event, marker_function_args, node)\n\n                # Don't need any more events from these frames\n                return None\n\n            else:\n                # Calls to proper functions.\n                # Client doesn't care about these events,\n                # it cares about \"before_statement\" events in the first statement of the body\n                self._custom_stack.append(CustomStackFrame(frame, \"call\"))\n\n        elif event == \"exception\":\n            # Note that Nicer can't filter out exception based on current command\n            # because it must be possible to go back and replay with different command\n            if self._is_interesting_exception(frame, arg):\n                self._fresh_exception = arg\n                self._register_affected_frame(arg[1], frame)\n\n                # Last command (step_into or step_over) produced this exception\n                # Show red after-state for this focus\n                # use the state prepared by previous event\n                last_custom_frame = self._custom_stack[-1]\n                assert last_custom_frame.system_frame == frame\n\n                # TODO: instead of producing an event here, next before_-event\n                # should create matching after event for each before event\n                # which would remain unclosed because of this exception.\n                # Existence of these after events would simplify step_over management\n\n                assert last_custom_frame.event.startswith(\"before_\")\n                pseudo_event = last_custom_frame.event.replace(\"before_\", \"after_\").replace(\n                    \"_again\", \"\"\n                )\n                # print(\"handle\", pseudo_event, {}, last_custom_frame.node)\n                self._handle_progress_event(frame, pseudo_event, {}, last_custom_frame.node)\n\n        elif event == \"return\":\n            self._fresh_exception = None\n\n            if code_name not in self.marker_function_names:\n                frame_id = id(self._custom_stack[-1].system_frame)\n                self._check_notify_return(frame_id)\n                self._custom_stack.pop()\n                if len(self._custom_stack) == 0:\n                    # We popped last frame, this means our program has ended.\n                    # There may be more events coming from upper (system) frames\n                    # but we're not interested in those\n                    sys.settrace(None)\n            else:\n                pass\n\n        else:\n            self._fresh_exception = None\n\n        return self._trace", "is_method": true, "class_name": "NiceTracer", "function_description": "Core method of NiceTracer that monitors Python execution events to detect special marker calls, manage a custom stack view, and handle client queries for accurate tracing and stepwise program analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_progress_event", "line_number": 1891, "body": "def _handle_progress_event(self, frame, event, args, node):\n        self._save_current_state(frame, event, args, node)\n        self._respond_to_commands()", "is_method": true, "class_name": "NiceTracer", "function_description": "Internal method of the NiceTracer class that updates the tracer's state based on the current execution frame and processes any pending commands. It supports tracking execution progress for debugging or analysis purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_save_current_state", "line_number": 1895, "body": "def _save_current_state(self, frame, event, args, node):\n        \"\"\"\n        Updates custom stack and stores the state\n\n        self._custom_stack always keeps last info,\n        which gets exported as FrameInfos to _saved_states[\"stack\"]\n        \"\"\"\n        focus = TextRange(node.lineno, node.col_offset, node.end_lineno, node.end_col_offset)\n\n        custom_frame = self._custom_stack[-1]\n        custom_frame.event = event\n        custom_frame.focus = focus\n        custom_frame.node = node\n        custom_frame.node_tags = node.tags\n\n        if self._saved_states:\n            prev_state = self._saved_states[-1]\n            prev_state_frame = self._create_actual_active_frame(prev_state)\n        else:\n            prev_state = None\n            prev_state_frame = None\n\n        # store information about current statement / expression\n        if \"statement\" in event:\n            custom_frame.current_statement = focus\n\n            if event == \"before_statement_again\":\n                # keep the expression information from last event\n                pass\n            else:\n                custom_frame.current_root_expression = None\n                custom_frame.current_evaluations = []\n        else:\n            assert \"expression\" in event\n            assert prev_state_frame is not None\n\n            # may need to update current_statement, because the parent statement was\n            # not the last one visited (eg. with test expression of a loop,\n            # starting from 2nd iteration)\n            if hasattr(node, \"parent_statement_focus\"):\n                custom_frame.current_statement = node.parent_statement_focus\n\n            # see whether current_root_expression needs to be updated\n            prev_root_expression = prev_state_frame.current_root_expression\n            if event == \"before_expression\" and (\n                id(frame) != id(prev_state_frame.system_frame)\n                or \"statement\" in prev_state_frame.event\n                or prev_root_expression\n                and not range_contains_smaller_or_equal(prev_root_expression, focus)\n            ):\n                custom_frame.current_root_expression = focus\n                custom_frame.current_evaluations = []\n\n            if event == \"after_expression\" and \"value\" in args:\n                # value is missing in case of exception\n                custom_frame.current_evaluations.append(\n                    (focus, self._backend.export_value(args[\"value\"]))\n                )\n\n        # Save the snapshot.\n        # Check if we can share something with previous state\n        if (\n            prev_state is not None\n            and id(prev_state_frame.system_frame) == id(frame)\n            and prev_state[\"exception_value\"] is self._get_current_exception()[1]\n            and prev_state[\"fresh_exception_id\"] == id(self._fresh_exception)\n            and (\"before\" in event or \"skipexport\" in node.tags)\n        ):\n\n            exception_info = prev_state[\"exception_info\"]\n            # share the stack ...\n            stack = prev_state[\"stack\"]\n            # ... but override certain things\n            active_frame_overrides = {\n                \"event\": custom_frame.event,\n                \"focus\": custom_frame.focus,\n                \"node_tags\": custom_frame.node_tags,\n                \"current_root_expression\": custom_frame.current_root_expression,\n                \"current_evaluations\": custom_frame.current_evaluations.copy(),\n                \"current_statement\": custom_frame.current_statement,\n            }\n        else:\n            # make full export\n            stack = self._export_stack()\n            exception_info = self._export_exception_info()\n            active_frame_overrides = {}\n\n        msg = {\n            \"stack\": stack,\n            \"active_frame_overrides\": active_frame_overrides,\n            \"in_client_log\": False,\n            \"io_symbol_count\": (\n                sys.stdin._processed_symbol_count\n                + sys.stdout._processed_symbol_count\n                + sys.stderr._processed_symbol_count\n            ),\n            \"exception_value\": self._get_current_exception()[1],\n            \"fresh_exception_id\": id(self._fresh_exception),\n            \"exception_info\": exception_info,\n        }\n\n        self._saved_states.append(msg)", "is_method": true, "class_name": "NiceTracer", "function_description": "Captures and updates the current execution state by maintaining a custom stack and saving detailed snapshots including statements, expressions, exceptions, and evaluations for precise traceability in code execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_respond_to_commands", "line_number": 1998, "body": "def _respond_to_commands(self):\n        \"\"\"Tries to respond to client commands with states collected so far.\n        Returns if these states don't suffice anymore and Python needs\n        to advance the program\"\"\"\n\n        # while the state for current index is already saved:\n        while self._current_state_index < len(self._saved_states):\n            state = self._saved_states[self._current_state_index]\n\n            # Get current state's most recent frame (together with overrides\n            frame = self._create_actual_active_frame(state)\n\n            # Is this state meant to be seen?\n            if \"skip_\" + frame.event not in frame.node_tags:\n                # if True:\n                # Has the command completed?\n                tester = getattr(self, \"_cmd_\" + self._current_command.name + \"_completed\")\n                cmd_complete = tester(frame, self._current_command)\n\n                if cmd_complete:\n                    state[\"in_client_log\"] = True\n                    self._report_state(self._current_state_index)\n                    self._fetch_next_debugger_command(frame)\n\n            if self._current_command.name == \"step_back\":\n                if self._current_state_index == 0:\n                    # Already in first state. Remain in this loop\n                    pass\n                else:\n                    assert self._current_state_index > 0\n                    # Current event is no longer present in GUI \"undo log\"\n                    self._saved_states[self._current_state_index][\"in_client_log\"] = False\n                    self._current_state_index -= 1\n            else:\n                # Other commands move the pointer forward\n                self._current_state_index += 1", "is_method": true, "class_name": "NiceTracer", "function_description": "Core internal method of NiceTracer that processes and responds to debugger commands by evaluating saved program states, managing state indices, and determining whether execution should advance or remain paused based on command completion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_create_actual_active_frame", "line_number": 2035, "body": "def _create_actual_active_frame(self, state):\n        return state[\"stack\"][-1]._replace(**state[\"active_frame_overrides\"])", "is_method": true, "class_name": "NiceTracer", "function_description": "Internal method of NiceTracer that constructs the currently active stack frame by applying specified overrides to the top frame in the execution state. It supports customized inspection or manipulation of the active frame during tracing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_report_state", "line_number": 2038, "body": "def _report_state(self, state_index):\n        in_present = state_index == len(self._saved_states) - 1\n        if in_present:\n            # For reported new events re-export stack to make sure it is not shared.\n            # (There is tiny chance that sharing previous state\n            # after executing BinOp, Attribute, Compare or Subscript\n            # was not the right choice. See tag_nodes for more.)\n            # Re-exporting reduces the harm by showing correct data at least\n            # for present states.\n            self._saved_states[state_index][\"stack\"] = self._export_stack()\n\n        # need to make a copy for applying overrides\n        # and removing helper fields without modifying original\n        state = self._saved_states[state_index].copy()\n        state[\"stack\"] = state[\"stack\"].copy()\n\n        state[\"in_present\"] = in_present\n        if not in_present:\n            # for past states fix the newest frame\n            state[\"stack\"][-1] = self._create_actual_active_frame(state)\n\n        del state[\"exception_value\"]\n        del state[\"active_frame_overrides\"]\n\n        # Convert stack of TempFrameInfos to stack of FrameInfos\n        new_stack = []\n        self._last_reported_frame_ids = set()\n        for tframe in state[\"stack\"]:\n            system_frame = tframe.system_frame\n            module_name = system_frame.f_globals[\"__name__\"]\n            code_name = system_frame.f_code.co_name\n\n            source, firstlineno, in_library = self._backend._get_frame_source_info(system_frame)\n\n            assert firstlineno is not None, \"nofir \" + str(system_frame)\n            frame_id = id(system_frame)\n            new_stack.append(\n                FrameInfo(\n                    id=frame_id,\n                    filename=system_frame.f_code.co_filename,\n                    module_name=module_name,\n                    code_name=code_name,\n                    locals=tframe.locals,\n                    globals=tframe.globals,\n                    freevars=system_frame.f_code.co_freevars,\n                    source=source,\n                    lineno=system_frame.f_lineno,\n                    firstlineno=firstlineno,\n                    in_library=in_library,\n                    event=tframe.event,\n                    focus=tframe.focus,\n                    node_tags=tframe.node_tags,\n                    current_statement=tframe.current_statement,\n                    current_evaluations=tframe.current_evaluations,\n                    current_root_expression=tframe.current_root_expression,\n                )\n            )\n\n            self._last_reported_frame_ids.add(frame_id)\n\n        state[\"stack\"] = new_stack\n        state[\"tracer_class\"] = \"NiceTracer\"\n\n        self._backend.send_message(DebuggerResponse(**state))", "is_method": true, "class_name": "NiceTracer", "function_description": "Transforms and reports a specific saved program state with detailed stack frame info, preparing it for debugging visualization or analysis by sending it to the backend. It supports accurate state inspection during current or past execution points."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_try_interpret_as_again_event", "line_number": 2103, "body": "def _try_interpret_as_again_event(self, frame, original_event, original_args, original_node):\n        \"\"\"\n        Some after_* events can be interpreted also as\n        \"before_*_again\" events (eg. when last argument of a call was\n        evaluated, then we are just before executing the final stage of the call)\n        \"\"\"\n\n        if original_event == \"after_expression\":\n            value = original_args.get(\"value\")\n\n            if (\n                \"last_child\" in original_node.tags\n                or \"or_arg\" in original_node.tags\n                and value\n                or \"and_arg\" in original_node.tags\n                and not value\n            ):\n\n                # there may be explicit exceptions\n                if (\n                    \"skip_after_statement_again\" in original_node.parent_node.tags\n                    or \"skip_after_expression_again\" in original_node.parent_node.tags\n                ):\n                    return\n\n                # next step will be finalizing evaluation of parent of current expr\n                # so let's say we're before that parent expression\n                again_args = {\"node_id\": id(original_node.parent_node)}\n                again_event = (\n                    \"before_expression_again\"\n                    if \"child_of_expression\" in original_node.tags\n                    else \"before_statement_again\"\n                )\n\n                self._handle_progress_event(\n                    frame, again_event, again_args, original_node.parent_node\n                )", "is_method": true, "class_name": "NiceTracer", "function_description": "Internal method of NiceTracer that attempts to reclassify certain \"after\" events as \"before_*_again\" events to reflect precise program evaluation stages for improved event handling during code tracing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_over_completed", "line_number": 2141, "body": "def _cmd_step_over_completed(self, frame, cmd):\n        \"\"\"\n        Identifies the moment when piece of code indicated by cmd.frame_id and cmd.focus\n        has completed execution (either successfully or not).\n        \"\"\"\n\n        if self._at_a_breakpoint(frame, cmd):\n            return True\n\n        # Make sure the correct frame_id is selected\n        if id(frame.system_frame) == cmd.frame_id:\n            # We're in the same frame\n            if \"before_\" in cmd.state:\n                if not range_contains_smaller_or_equal(cmd.focus, frame.focus):\n                    # Focus has changed, command has completed\n                    return True\n                else:\n                    # Keep running\n                    return False\n            elif \"after_\" in cmd.state:\n                if (\n                    frame.focus != cmd.focus\n                    or \"before_\" in frame.event\n                    or \"_expression\" in cmd.state\n                    and \"_statement\" in frame.event\n                    or \"_statement\" in cmd.state\n                    and \"_expression\" in frame.event\n                ):\n                    # The state has changed, command has completed\n                    return True\n                else:\n                    # Keep running\n                    return False\n        else:\n            # We're in another frame\n            if self._frame_is_alive(cmd.frame_id):\n                # We're in a successor frame, keep running\n                return False\n            else:\n                # Original frame has completed, assumedly because of an exception\n                # We're done\n                return True\n\n        return True", "is_method": true, "class_name": "NiceTracer", "function_description": "Determines whether the execution of a specified code segment (identified by frame and focus) has finished, supporting step-over debugging by detecting completion states and frame transitions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_into_completed", "line_number": 2186, "body": "def _cmd_step_into_completed(self, frame, cmd):\n        return frame.event != \"after_statement\"", "is_method": true, "class_name": "NiceTracer", "function_description": "Private method in NiceTracer that determines whether the \"step into\" debugging command has completed based on the current frame's event status. It assists in controlling debugger execution flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_back_completed", "line_number": 2189, "body": "def _cmd_step_back_completed(self, frame, cmd):\n        # Check if the selected message has been previously sent to front-end\n        return (\n            self._saved_states[self._current_state_index][\"in_client_log\"]\n            or self._current_state_index == 0\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "Checks if the current state corresponds to a previously communicated message or is the initial state, aiding in managing command step-back logic within NiceTracer's state tracking."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_out_completed", "line_number": 2196, "body": "def _cmd_step_out_completed(self, frame, cmd):\n        if self._current_state_index == 0:\n            return False\n\n        if frame.event == \"after_statement\":\n            return False\n\n        if self._at_a_breakpoint(frame, cmd):\n            return True\n\n        prev_state_frame = self._saved_states[self._current_state_index - 1][\"stack\"][-1]\n\n        return (\n            # the frame has completed\n            not self._frame_is_alive(cmd.frame_id)\n            # we're in the same frame but on higher level\n            # TODO: expression inside statement expression has same range as its parent\n            or id(frame.system_frame) == cmd.frame_id\n            and range_contains_smaller(frame.focus, cmd.focus)\n            # or we were there in prev state\n            or id(prev_state_frame.system_frame) == cmd.frame_id\n            and range_contains_smaller(prev_state_frame.focus, cmd.focus)\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "Checks whether the current debugging step-out command has completed based on frame state, event, breakpoints, and frame liveliness within the NiceTracer debugger."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_resume_completed", "line_number": 2220, "body": "def _cmd_resume_completed(self, frame, cmd):\n        return self._at_a_breakpoint(frame, cmd)", "is_method": true, "class_name": "NiceTracer", "function_description": "Internal method of NiceTracer that determines if execution has reached a breakpoint upon resuming a command, facilitating breakpoint handling during code tracing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_at_a_breakpoint", "line_number": 2223, "body": "def _at_a_breakpoint(self, frame, cmd, breakpoints=None):\n        if breakpoints is None:\n            breakpoints = cmd[\"breakpoints\"]\n\n        return (\n            frame.event in [\"before_statement\", \"before_expression\"]\n            and frame.system_frame.f_code.co_filename in breakpoints\n            and frame.focus.lineno in breakpoints[frame.system_frame.f_code.co_filename]\n            # consider only first event on a line\n            # (but take into account that same line may be reentered)\n            and (\n                cmd.focus is None\n                or (cmd.focus.lineno != frame.focus.lineno)\n                or (cmd.focus == frame.focus and cmd.state == frame.event)\n                or id(frame.system_frame) != cmd.frame_id\n            )\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "Determines if the current execution frame matches a specified breakpoint, considering event types and location to control debugger behavior. It supports precise breakpoint detection for tracing program execution within the NiceTracer class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_frame_is_alive", "line_number": 2241, "body": "def _frame_is_alive(self, frame_id):\n        for frame in self._custom_stack:\n            if id(frame.system_frame) == frame_id:\n                return True\n\n        return False", "is_method": true, "class_name": "NiceTracer", "function_description": "Checks if a frame with the specified ID exists in the current custom stack. This function helps track active frames within the NiceTracer's tracing context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_export_stack", "line_number": 2248, "body": "def _export_stack(self):\n        result = []\n\n        exported_globals_per_module = {}\n\n        def export_globals(module_name, frame):\n            if module_name not in exported_globals_per_module:\n                exported_globals_per_module[module_name] = self._backend.export_variables(\n                    frame.f_globals\n                )\n            return exported_globals_per_module[module_name]\n\n        for custom_frame in self._custom_stack:\n            system_frame = custom_frame.system_frame\n            module_name = system_frame.f_globals[\"__name__\"]\n\n            result.append(\n                TempFrameInfo(\n                    # need to store the reference to the frame to avoid it being GC-d\n                    # otherwise frame id-s would be reused and this would\n                    # mess up communication with the frontend.\n                    system_frame=system_frame,\n                    locals=None\n                    if system_frame.f_locals is system_frame.f_globals\n                    else self._backend.export_variables(system_frame.f_locals),\n                    globals=export_globals(module_name, system_frame),\n                    event=custom_frame.event,\n                    focus=custom_frame.focus,\n                    node_tags=custom_frame.node_tags,\n                    current_evaluations=custom_frame.current_evaluations.copy(),\n                    current_statement=custom_frame.current_statement,\n                    current_root_expression=custom_frame.current_root_expression,\n                )\n            )\n\n        assert result  # not empty\n        return result", "is_method": true, "class_name": "NiceTracer", "function_description": "Exports detailed information about the current custom stack frames, including locals and shared global variables, to support communication or introspection in tracing workflows. It consolidates frame data efficiently by caching exported globals per module."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_thonny_hidden_before_stmt", "line_number": 2286, "body": "def _thonny_hidden_before_stmt(self, node_id):\n        # The code to be debugged will be instrumented with this function\n        # inserted before each statement.\n        # Entry into this function indicates that statement as given\n        # by the code range is about to be evaluated next.\n        return None", "is_method": true, "class_name": "NiceTracer", "function_description": "Returns None before executing a statement during debugging instrumentation; primarily acts as a placeholder hook signaling the upcoming statement evaluation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_thonny_hidden_before_expr", "line_number": 2300, "body": "def _thonny_hidden_before_expr(self, node_id):\n        # Entry into this function indicates that expression as given\n        # by the code range is about to be evaluated next\n        return node_id", "is_method": true, "class_name": "NiceTracer", "function_description": "Private method in NiceTracer that marks the upcoming evaluation of a specific expression by returning its node identifier."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_thonny_hidden_after_expr", "line_number": 2305, "body": "def _thonny_hidden_after_expr(self, node_id, value):\n        # The code to be debugged will be instrumented with this function\n        # wrapped around each expression (given as 2nd argument).\n        # Entry into this function indicates that expression as given\n        # by the code range was just evaluated to given value\n        return value", "is_method": true, "class_name": "NiceTracer", "function_description": "Private helper method in NiceTracer that intercepts evaluated expressions during debugging, returning their computed value for tracing expression results within instrumented code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_tag_nodes", "line_number": 2312, "body": "def _tag_nodes(self, root):\n        \"\"\"Marks interesting properties of AST nodes\"\"\"\n        # ast_utils need to be imported after asttokens\n        # is (custom-)imported\n        try_load_modules_with_frontend_sys_path([\"asttokens\", \"six\", \"astroid\"])\n        from thonny import ast_utils\n\n        def add_tag(node, tag):\n            if not hasattr(node, \"tags\"):\n                node.tags = set()\n                node.tags.add(\"class=\" + node.__class__.__name__)\n            node.tags.add(tag)\n\n        # ignore module docstring if it is before from __future__ import\n        if (\n            isinstance(root.body[0], ast.Expr)\n            and isinstance(root.body[0].value, ast.Str)\n            and len(root.body) > 1\n            and isinstance(root.body[1], ast.ImportFrom)\n            and root.body[1].module == \"__future__\"\n        ):\n            add_tag(root.body[0], \"ignore\")\n            add_tag(root.body[0].value, \"ignore\")\n            add_tag(root.body[1], \"ignore\")\n\n        for node in ast.walk(root):\n            if not isinstance(node, (ast.expr, ast.stmt)):\n                if isinstance(node, ast.comprehension):\n                    for expr in node.ifs:\n                        add_tag(expr, \"comprehension.if\")\n\n                continue\n\n            # tag last children\n            last_child = ast_utils.get_last_child(node)\n            assert last_child in [True, False, None] or isinstance(\n                last_child, (ast.expr, ast.stmt, type(None))\n            ), (\"Bad last child \" + str(last_child) + \" of \" + str(node))\n            if last_child is not None:\n                add_tag(node, \"has_children\")\n\n                if isinstance(last_child, ast.AST):\n                    last_child.parent_node = node\n                    add_tag(last_child, \"last_child\")\n                    if isinstance(node, _ast.expr):\n                        add_tag(last_child, \"child_of_expression\")\n                    else:\n                        add_tag(last_child, \"child_of_statement\")\n\n                    if isinstance(node, ast.Call):\n                        add_tag(last_child, \"last_call_arg\")\n\n            # other cases\n            if isinstance(node, ast.Call):\n                add_tag(node.func, \"call_function\")\n                node.func.parent_node = node\n\n            if isinstance(node, ast.BoolOp) and node.op == ast.Or():\n                for child in node.values:\n                    add_tag(child, \"or_arg\")\n                    child.parent_node = node\n\n            if isinstance(node, ast.BoolOp) and node.op == ast.And():\n                for child in node.values:\n                    add_tag(child, \"and_arg\")\n                    child.parent_node = node\n\n            # TODO: assert (it doesn't evaluate msg when test == True)\n\n            if isinstance(node, ast.stmt):\n                for child in ast.iter_child_nodes(node):\n                    child.parent_node = node\n                    child.parent_statement_focus = TextRange(\n                        node.lineno, node.col_offset, node.end_lineno, node.end_col_offset\n                    )\n\n            if isinstance(node, ast.Str):\n                add_tag(node, \"skipexport\")\n\n            if hasattr(ast, \"JoinedStr\") and isinstance(node, ast.JoinedStr):\n                # can't present children normally without\n                # ast giving correct locations for them\n                # https://bugs.python.org/issue29051\n                add_tag(node, \"ignore_children\")\n\n            elif isinstance(node, ast.Num):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.List):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Tuple):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Set):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Dict):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Name):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.NameConstant):\n                add_tag(node, \"skipexport\")\n\n            elif hasattr(ast, \"Constant\") and isinstance(node, ast.Constant):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Expr):\n                if not isinstance(node.value, (ast.Yield, ast.YieldFrom)):\n                    add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.If):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Return):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.While):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Continue):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Break):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Pass):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.For):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Try):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.ListComp):\n                add_tag(node.elt, \"ListComp.elt\")\n                if len(node.generators) > 1:\n                    add_tag(node, \"ignore_children\")\n\n            elif isinstance(node, ast.SetComp):\n                add_tag(node.elt, \"SetComp.elt\")\n                if len(node.generators) > 1:\n                    add_tag(node, \"ignore_children\")\n\n            elif isinstance(node, ast.DictComp):\n                add_tag(node.key, \"DictComp.key\")\n                add_tag(node.value, \"DictComp.value\")\n                if len(node.generators) > 1:\n                    add_tag(node, \"ignore_children\")\n\n            elif isinstance(node, ast.BinOp):\n                # TODO: use static analysis to detect type of left child\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Attribute):\n                # TODO: use static analysis to detect type of left child\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Subscript):\n                # TODO: use static analysis to detect type of left child\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Compare):\n                # TODO: use static analysis to detect type of left child\n                add_tag(node, \"skipexport\")\n\n            if isinstance(node, (ast.Assign)):\n                # value will be presented in assignment's before_statement_again\n                add_tag(node.value, \"skip_after_expression\")\n\n            if isinstance(node, (ast.Expr, ast.While, ast.For, ast.If, ast.Try, ast.With)):\n                add_tag(node, \"skip_after_statement_again\")\n\n            # make sure every node has this field\n            if not hasattr(node, \"tags\"):\n                node.tags = set()", "is_method": true, "class_name": "NiceTracer", "function_description": "Core helper of NiceTracer that analyzes and annotates AST nodes with descriptive tags to mark their properties and relationships, enabling detailed inspections or transformations of Python code structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_should_instrument_as_expression", "line_number": 2492, "body": "def _should_instrument_as_expression(self, node):\n        return (\n            isinstance(node, _ast.expr)\n            and hasattr(node, \"end_lineno\")\n            and hasattr(node, \"end_col_offset\")\n            and not getattr(node, \"incorrect_range\", False)\n            and \"ignore\" not in node.tags\n            and (not hasattr(node, \"ctx\") or isinstance(node.ctx, ast.Load))\n            # TODO: repeatedly evaluated subexpressions of comprehensions\n            # can be supported (but it requires some redesign both in backend and GUI)\n            and \"ListComp.elt\" not in node.tags\n            and \"SetComp.elt\" not in node.tags\n            and \"DictComp.key\" not in node.tags\n            and \"DictComp.value\" not in node.tags\n            and \"comprehension.if\" not in node.tags\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "Determines whether a given AST node qualifies for instrumentation as an expression based on its type, attributes, context, and specific tagging rules. This helps decide if code tracing should be applied to the node during program analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_should_instrument_as_statement", "line_number": 2509, "body": "def _should_instrument_as_statement(self, node):\n        return (\n            isinstance(node, _ast.stmt)\n            and not getattr(node, \"incorrect_range\", False)\n            and \"ignore\" not in node.tags\n            # Shouldn't insert anything before from __future__ import\n            # as this is not a normal statement\n            # https://bitbucket.org/plas/thonny/issues/183/thonny-throws-false-positive-syntaxerror\n            and (not isinstance(node, ast.ImportFrom) or node.module != \"__future__\")\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "Determines whether a given AST node should be instrumented as a statement by checking its type, tags, and special import conditions. This helps control code instrumentation to avoid errors or unnecessary processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_insert_statement_markers", "line_number": 2520, "body": "def _insert_statement_markers(self, root):\n        # find lists of statements and insert before/after markers for each statement\n        for name, value in ast.iter_fields(root):\n            if isinstance(root, ast.Try) and name == \"handlers\":\n                # contains statements but is not statement itself\n                for handler in value:\n                    self._insert_statement_markers(handler)\n            elif isinstance(value, ast.AST):\n                self._insert_statement_markers(value)\n            elif isinstance(value, list):\n                if len(value) > 0:\n                    new_list = []\n                    for node in value:\n                        if self._should_instrument_as_statement(node):\n                            # self._debug(\"EBFOMA\", node)\n                            # add before marker\n                            new_list.append(\n                                self._create_statement_marker(node, BEFORE_STATEMENT_MARKER)\n                            )\n\n                        # original statement\n                        if self._should_instrument_as_statement(node):\n                            self._insert_statement_markers(node)\n                        new_list.append(node)\n\n                        if (\n                            self._should_instrument_as_statement(node)\n                            and \"skipexport\" not in node.tags\n                        ):\n                            # add after marker\n                            new_list.append(\n                                self._create_statement_marker(node, AFTER_STATEMENT_MARKER)\n                            )\n                    setattr(root, name, new_list)", "is_method": true, "class_name": "NiceTracer", "function_description": "Core method of the NiceTracer class that recursively traverses an AST to insert instrumentation markers before and after relevant statements, enabling detailed code execution tracing and analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_create_statement_marker", "line_number": 2555, "body": "def _create_statement_marker(self, node, function_name):\n        call = self._create_simple_marker_call(node, function_name)\n        stmt = ast.Expr(value=call)\n        ast.copy_location(stmt, node)\n        ast.fix_missing_locations(stmt)\n        return stmt", "is_method": true, "class_name": "NiceTracer", "function_description": "Creates an AST expression statement that marks a function call within code tracing, facilitating instrumentation or analysis by the NiceTracer class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_insert_for_target_markers", "line_number": 2562, "body": "def _insert_for_target_markers(self, root):\n        \"\"\"inserts markers which notify assignment to for-loop variables\"\"\"\n        for node in ast.walk(root):\n            if isinstance(node, ast.For):\n                old_target = node.target\n                # print(vars(old_target))\n                temp_name = \"__for_loop_var\"\n                node.target = ast.Name(temp_name, ast.Store())\n\n                name_load = ast.Name(temp_name, ast.Load())\n                # value will be visible in parent's before_statement_again event\n                name_load.tags = {\"skip_before_expression\", \"skip_after_expression\", \"last_child\"}\n                name_load.lineno, name_load.col_offset = (node.iter.lineno, node.iter.col_offset)\n                name_load.end_lineno, name_load.end_col_offset = (\n                    node.iter.end_lineno,\n                    node.iter.end_col_offset,\n                )\n\n                before_name_load = self._create_simple_marker_call(\n                    name_load, BEFORE_EXPRESSION_MARKER\n                )\n                after_name_load = ast.Call(\n                    func=ast.Name(id=AFTER_EXPRESSION_MARKER, ctx=ast.Load()),\n                    args=[before_name_load, name_load],\n                    keywords=[],\n                )\n\n                ass = ast.Assign([old_target], after_name_load)\n                ass.lineno, ass.col_offset = old_target.lineno, old_target.col_offset\n                ass.end_lineno, ass.end_col_offset = (\n                    node.iter.end_lineno,\n                    node.iter.end_col_offset,\n                )\n                ass.tags = {\"skip_before_statement\"}  # before_statement_again will be shown\n\n                name_load.parent_node = ass\n\n                ass_before = self._create_statement_marker(ass, BEFORE_STATEMENT_MARKER)\n                node.body.insert(0, ass_before)\n                node.body.insert(1, ass)\n                node.body.insert(2, self._create_statement_marker(ass, AFTER_STATEMENT_MARKER))\n\n                ast.fix_missing_locations(node)", "is_method": true, "class_name": "NiceTracer", "function_description": "In the NiceTracer class, this method inserts special markers around for-loop variable assignments in an AST to facilitate tracing or instrumentation of the variable\u2019s value changes during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_insert_expression_markers", "line_number": 2606, "body": "def _insert_expression_markers(self, node):\n        \"\"\"\n        TODO: this docstring is outdated\n        each expression e gets wrapped like this:\n            _after(_before(_loc, _node_is_zoomable), e, _node_role, _parent_range)\n        where\n            _after is function that gives the resulting value\n            _before is function that signals the beginning of evaluation of e\n            _loc gives the code range of e\n            _node_is_zoomable indicates whether this node has subexpressions\n            _node_role is either 'last_call_arg', 'last_op_arg', 'first_or_arg',\n                                 'first_and_arg', 'function' or None\n        \"\"\"\n        tracer = self\n\n        class ExpressionVisitor(ast.NodeTransformer):\n            def generic_visit(self, node):\n                if isinstance(node, _ast.expr):\n                    if isinstance(node, ast.Starred):\n                        # keep this node as is, but instrument its children\n                        return ast.NodeTransformer.generic_visit(self, node)\n                    elif tracer._should_instrument_as_expression(node):\n                        # before marker\n                        before_marker = tracer._create_simple_marker_call(\n                            node, BEFORE_EXPRESSION_MARKER\n                        )\n                        ast.copy_location(before_marker, node)\n\n                        if \"ignore_children\" in node.tags:\n                            transformed_node = node\n                        else:\n                            transformed_node = ast.NodeTransformer.generic_visit(self, node)\n\n                        # after marker\n                        after_marker = ast.Call(\n                            func=ast.Name(id=AFTER_EXPRESSION_MARKER, ctx=ast.Load()),\n                            args=[before_marker, transformed_node],\n                            keywords=[],\n                        )\n                        ast.copy_location(after_marker, node)\n                        ast.fix_missing_locations(after_marker)\n                        # further transformations may query original node location from after marker\n                        if hasattr(node, \"end_lineno\"):\n                            after_marker.end_lineno = node.end_lineno\n                            after_marker.end_col_offset = node.end_col_offset\n\n                        return after_marker\n                    else:\n                        # This expression (and its children) should be ignored\n                        return node\n                else:\n                    # Descend into statements\n                    return ast.NodeTransformer.generic_visit(self, node)\n\n        return ExpressionVisitor().visit(node)", "is_method": true, "class_name": "NiceTracer", "function_description": "Core method of NiceTracer that wraps each expression node in an AST with custom before-and-after markers to trace evaluation, enabling detailed instrumentation of code execution flow for debugging or analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_create_simple_marker_call", "line_number": 2662, "body": "def _create_simple_marker_call(self, node, fun_name, extra_args=[]):\n        args = [self._export_node(node)] + extra_args\n\n        return ast.Call(func=ast.Name(id=fun_name, ctx=ast.Load()), args=args, keywords=[])", "is_method": true, "class_name": "NiceTracer", "function_description": "Creates an AST call node invoking a specified function with an exported node and additional arguments, facilitating dynamic tracing or instrumentation within the NiceTracer class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_export_node", "line_number": 2667, "body": "def _export_node(self, node):\n        assert isinstance(node, (ast.expr, ast.stmt))\n        node_id = id(node)\n        self._nodes[node_id] = node\n        return ast.Num(node_id)", "is_method": true, "class_name": "NiceTracer", "function_description": "Helper method in NiceTracer that registers an AST node and returns a numeric AST node uniquely identifying it for internal tracking or referencing purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_debug", "line_number": 2673, "body": "def _debug(self, *args):\n        logger.debug(\"TRACER: \" + str(args))", "is_method": true, "class_name": "NiceTracer", "function_description": "Private method of NiceTracer that logs debugging information by outputting given arguments with a tracer prefix for diagnostic purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_execute_prepared_user_code", "line_number": 2676, "body": "def _execute_prepared_user_code(self, statements, global_vars):\n        try:\n            return Tracer._execute_prepared_user_code(self, statements, global_vars)\n        finally:\n            \"\"\"\n            from thonny.misc_utils import _win_get_used_memory\n            print(\"Memory:\", _win_get_used_memory() / 1024 / 1024)\n            print(\"States:\", len(self._saved_states))\n            print(self._fulltags.most_common())\n            \"\"\"", "is_method": true, "class_name": "NiceTracer", "function_description": "This method extends code execution functionality by running prepared user statements while ensuring post-execution resource or state-related operations can be triggered, supporting enhanced tracing and debugging capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "source_to_code", "line_number": 2706, "body": "def source_to_code(self, data, path, *, _optimize=-1):\n        old_tracer = sys.gettrace()\n        sys.settrace(None)\n        try:\n            root = self._tracer._prepare_ast(data, path, \"exec\")\n            return super().source_to_code(root, path)\n        finally:\n            sys.settrace(old_tracer)", "is_method": true, "class_name": "FancySourceFileLoader", "function_description": "Method of FancySourceFileLoader that converts source code data into a code object, disabling tracing during compilation to avoid interference. It enables safe compilation of source into executable code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "rec_format_exception_with_frame_info", "line_number": 2772, "body": "def rec_format_exception_with_frame_info(etype, value, tb, chain=True):\n        # Based on\n        # https://www.python.org/dev/peps/pep-3134/#enhanced-reporting\n        # and traceback.format_exception\n\n        if etype is None:\n            etype = type(value)\n\n        if tb is None:\n            tb = value.__traceback__\n\n        if chain:\n            if value.__cause__ is not None:\n                yield from rec_format_exception_with_frame_info(None, value.__cause__, None)\n                yield (_cause_message, None, None, None)\n            elif value.__context__ is not None and not value.__suppress_context__:\n                yield from rec_format_exception_with_frame_info(None, value.__context__, None)\n                yield (_context_message, None, None, None)\n\n        if tb is not None:\n            yield (_traceback_message, None, None, None)\n\n            tb_temp = tb\n            for entry in traceback.extract_tb(tb):\n                assert tb_temp is not None  # actual tb doesn't end before extract_tb\n                if (\n                    \"cpython_backend\" not in entry.filename\n                    and \"thonny/backend\" not in entry.filename.replace(\"\\\\\", \"/\")\n                    and (\n                        not entry.filename.endswith(os.sep + \"ast.py\")\n                        or entry.name != \"parse\"\n                        or etype is not SyntaxError\n                    )\n                ):\n                    fmt = '  File \"{}\", line {}, in {}\\n'.format(\n                        entry.filename, entry.lineno, entry.name\n                    )\n\n                    if entry.line:\n                        fmt += \"    {}\\n\".format(entry.line.strip())\n\n                    yield (fmt, id(tb_temp.tb_frame), entry.filename, entry.lineno)\n\n                tb_temp = tb_temp.tb_next\n\n            assert tb_temp is None  # tb was exhausted\n\n        for line in traceback.format_exception_only(etype, value):\n            if etype is SyntaxError and line.endswith(\"^\\n\"):\n                # for some reason it may add several empty lines before ^-line\n                partlines = line.splitlines()\n                while len(partlines) >= 2 and partlines[-2].strip() == \"\":\n                    del partlines[-2]\n                line = \"\\n\".join(partlines) + \"\\n\"\n\n            yield (line, None, None, None)", "is_method": false, "function_description": "Utility function that formats exceptions into detailed tracebacks including frame and source code information, supporting chained exceptions for enhanced error reporting and debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "signal_handler", "line_number": 162, "body": "def signal_handler(signal_, frame):\n            raise KeyboardInterrupt(\"Execution interrupted\")", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Utility function in MainCPythonBackend that handles specific signals by raising a KeyboardInterrupt, allowing graceful interruption of program execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_repl_value", "line_number": 874, "body": "def _handle_repl_value(obj):\n            if obj is not None:\n                try:\n                    obj_repr = repr(obj)\n                    if len(obj_repr) > 5000:\n                        obj_repr = obj_repr[:5000] + \"\u2026\"\n                except Exception as e:\n                    obj_repr = \"<repr error: \" + str(e) + \">\"\n                print(OBJECT_LINK_START % id(obj), obj_repr, OBJECT_LINK_END, sep=\"\")\n                self._heap[id(obj)] = obj\n                builtins._ = obj", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Internal method of MainCPythonBackend that processes and prints a concise representation of a REPL evaluation result, stores it for reference, and updates the built-in underscore variable with the latest expression value."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "lookup_from_stack", "line_number": 1015, "body": "def lookup_from_stack(frame):\n            if frame is None:\n                return None\n            elif id(frame) == frame_id:\n                return frame\n            else:\n                return lookup_from_stack(frame.f_back)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Recursively searches backward through the call stack from a given frame to find and return a specific frame matching a target identifier. This enables stack frame inspection for debugging or introspection purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "lookup_from_tb", "line_number": 1023, "body": "def lookup_from_tb(entry):\n            if entry is None:\n                return None\n            elif id(entry.tb_frame) == frame_id:\n                return entry.tb_frame\n            else:\n                return lookup_from_tb(entry.tb_next)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Recursively searches a traceback linked list to find and return the frame matching a specific frame ID, enabling identification of stack frames within traceback objects."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "export_globals", "line_number": 2253, "body": "def export_globals(module_name, frame):\n            if module_name not in exported_globals_per_module:\n                exported_globals_per_module[module_name] = self._backend.export_variables(\n                    frame.f_globals\n                )\n            return exported_globals_per_module[module_name]", "is_method": true, "class_name": "NiceTracer", "function_description": "Core function in NiceTracer that exports and caches global variables of a given module from a stack frame, enabling efficient access to module-level state for tracing or debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_tag", "line_number": 2319, "body": "def add_tag(node, tag):\n            if not hasattr(node, \"tags\"):\n                node.tags = set()\n                node.tags.add(\"class=\" + node.__class__.__name__)\n            node.tags.add(tag)", "is_method": true, "class_name": "NiceTracer", "function_description": "Utility method of the NiceTracer class that attaches tags to a node, initializing a tag set if missing, helping identify and categorize nodes for tracing or debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "generic_visit", "line_number": 2622, "body": "def generic_visit(self, node):\n                if isinstance(node, _ast.expr):\n                    if isinstance(node, ast.Starred):\n                        # keep this node as is, but instrument its children\n                        return ast.NodeTransformer.generic_visit(self, node)\n                    elif tracer._should_instrument_as_expression(node):\n                        # before marker\n                        before_marker = tracer._create_simple_marker_call(\n                            node, BEFORE_EXPRESSION_MARKER\n                        )\n                        ast.copy_location(before_marker, node)\n\n                        if \"ignore_children\" in node.tags:\n                            transformed_node = node\n                        else:\n                            transformed_node = ast.NodeTransformer.generic_visit(self, node)\n\n                        # after marker\n                        after_marker = ast.Call(\n                            func=ast.Name(id=AFTER_EXPRESSION_MARKER, ctx=ast.Load()),\n                            args=[before_marker, transformed_node],\n                            keywords=[],\n                        )\n                        ast.copy_location(after_marker, node)\n                        ast.fix_missing_locations(after_marker)\n                        # further transformations may query original node location from after marker\n                        if hasattr(node, \"end_lineno\"):\n                            after_marker.end_lineno = node.end_lineno\n                            after_marker.end_col_offset = node.end_col_offset\n\n                        return after_marker\n                    else:\n                        # This expression (and its children) should be ignored\n                        return node\n                else:\n                    # Descend into statements\n                    return ast.NodeTransformer.generic_visit(self, node)", "is_method": true, "class_name": "ExpressionVisitor", "function_description": "Core method of ExpressionVisitor that traverses and conditionally instruments AST expression nodes by wrapping them with pre- and post-expression markers for tracing or analysis purposes during code transformation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_private_venv_path", "line_number": 304, "body": "def get_private_venv_path():\n    if is_bundled_python(sys.executable.lower()):\n        prefix = \"BundledPython\"\n    else:\n        prefix = \"Python\"\n    return os.path.join(\n        THONNY_USER_DIR, prefix + \"%d%d\" % (sys.version_info[0], sys.version_info[1])\n    )", "is_method": false, "function_description": "Returns the file system path to a user-specific virtual environment directory based on the current Python version and whether Python is bundled. Enables consistent environment management tailored to the Python interpreter in use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_private_venv_executable", "line_number": 314, "body": "def get_private_venv_executable():\n    venv_path = get_private_venv_path()\n\n    if running_on_windows():\n        exe = os.path.join(venv_path, \"Scripts\", WINDOWS_EXE)\n    else:\n        exe = os.path.join(venv_path, \"bin\", \"python3\")\n\n    return exe", "is_method": false, "function_description": "Utility function that returns the file path of the Python executable within a private virtual environment, adapting the path for the current operating system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_venv_info", "line_number": 325, "body": "def _get_venv_info(venv_path):\n    cfg_path = os.path.join(venv_path, \"pyvenv.cfg\")\n    result = {}\n\n    with open(cfg_path, encoding=\"UTF-8\") as fp:\n        for line in fp:\n            if \"=\" in line:\n                key, val = line.split(\"=\", maxsplit=1)\n                result[key.strip()] = val.strip()\n\n    return result", "is_method": false, "function_description": "Internal utility function that reads and parses the pyvenv.cfg file in a virtual environment directory, returning its configuration settings as a dictionary for use in environment management or inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_interpreters", "line_number": 498, "body": "def _get_interpreters():\n    result = set()\n\n    if running_on_windows():\n        # registry\n        result.update(_get_interpreters_from_windows_registry())\n\n        for minor in [6, 7, 8, 9, 10]:\n            for dir_ in [\n                \"C:\\\\Python3%d\" % minor,\n                \"C:\\\\Python3%d-32\" % minor,\n                \"C:\\\\Python3%d-64\" % minor,\n                \"C:\\\\Program Files\\\\Python 3.%d\" % minor,\n                \"C:\\\\Program Files\\\\Python 3.%d-64\" % minor,\n                \"C:\\\\Program Files (x86)\\\\Python 3.%d\" % minor,\n                \"C:\\\\Program Files (x86)\\\\Python 3.%d-32\" % minor,\n                \"C:\\\\Program Files (x86)\\\\Python 3.%d-32\" % minor,\n                os.path.expanduser(\"~\\\\AppData\\Local\\Programs\\Python\\Python3%d\" % minor),\n                os.path.expanduser(\"~\\\\AppData\\Local\\Programs\\Python\\Python3%d-32\" % minor),\n            ]:\n                path = os.path.join(dir_, WINDOWS_EXE)\n                if os.path.exists(path):\n                    result.add(normpath_with_actual_case(path))\n\n        # other locations\n        for dir_ in [\n            \"C:\\\\Anaconda3\",\n            \"C:\\\\ProgramData\\\\Anaconda3\",\n            os.path.expanduser(\"~\\\\Anaconda3\"),\n        ]:\n            path = os.path.join(dir_, WINDOWS_EXE)\n            if os.path.exists(path):\n                result.add(normpath_with_actual_case(path))\n\n    else:\n        # Common unix locations\n        dirs = [\n            \"/bin\",\n            \"/usr/bin\",\n            \"/usr/local/bin\",\n            os.path.expanduser(\"~/.local/bin\"),\n            os.path.expanduser(\"~/anaconda3/bin\"),\n        ]\n        for dir_ in dirs:\n            # if the dir_ is just a link to another dir_, skip it\n            # (not to show items twice)\n            # for example on Fedora /bin -> usr/bin\n            if not os.path.exists(dir_):\n                continue\n\n            apath = normpath_with_actual_case(dir_)\n            if apath != dir_ and apath in dirs:\n                continue\n            for name in [\"python3\", \"python3.5\", \"python3.6\", \"python3.7\", \"python3.8\"]:\n                path = os.path.join(dir_, name)\n                if os.path.exists(path):\n                    result.add(path)\n\n    if running_on_mac_os():\n        for version in [\"3.6\", \"3.7\", \"3.8\", \"3.9\"]:\n            dir_ = os.path.join(\"/Library/Frameworks/Python.framework/Versions\", version, \"bin\")\n            path = os.path.join(dir_, \"python3\")\n\n            if os.path.exists(path):\n                result.add(path)\n\n    from shutil import which\n\n    for command in [\"python3\", \"python3.6\", \"python3.7\", \"python3.8\", \"python3.9\"]:\n        path = which(command)\n        if path is not None and os.path.isabs(path):\n            result.add(path)\n\n    for path in get_workbench().get_option(\"CustomInterpreter.used_paths\"):\n        if os.path.exists(path):\n            result.add(normpath_with_actual_case(path))\n\n    return sorted(result)", "is_method": false, "function_description": "Function that searches and returns a sorted list of existing Python interpreter executable paths across common system locations, registry entries, and user-defined settings for multiple OS environments. It enables discovering available Python installations for environments or tool setup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_interpreters_from_windows_registry", "line_number": 578, "body": "def _get_interpreters_from_windows_registry():\n    # https://github.com/python/cpython/blob/master/Tools/msi/README.txt\n    # https://www.python.org/dev/peps/pep-0514/#installpath\n    import winreg\n\n    result = set()\n    for key in [winreg.HKEY_LOCAL_MACHINE, winreg.HKEY_CURRENT_USER]:\n        for version in [\n            \"3.6\",\n            \"3.6-32\",\n            \"3.6-64\",\n            \"3.7\",\n            \"3.7-32\",\n            \"3.7-64\",\n            \"3.8\",\n            \"3.8-32\",\n            \"3.8-64\",\n            \"3.9\",\n            \"3.9-32\",\n            \"3.9-64\",\n            \"3.10\",\n            \"3.10-32\",\n            \"3.10-64\",\n        ]:\n            for subkey in [\n                \"SOFTWARE\\\\Python\\\\PythonCore\\\\\" + version + \"\\\\InstallPath\",\n                \"SOFTWARE\\\\Python\\\\PythonCore\\\\Wow6432Node\\\\\" + version + \"\\\\InstallPath\",\n            ]:\n                try:\n                    dir_ = winreg.QueryValue(key, subkey)\n                    if dir_:\n                        path = os.path.join(dir_, WINDOWS_EXE)\n                        if os.path.exists(path):\n                            result.add(path)\n                except Exception:\n                    pass\n\n    return result", "is_method": false, "function_description": "Function that scans the Windows registry to identify installed Python interpreters by checking known install paths across various Python versions. It returns a set of valid interpreter executable paths detected on the system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_check_venv_installed", "line_number": 618, "body": "def _check_venv_installed(parent):\n    try:\n        import venv\n\n        return True\n    except ImportError:\n        messagebox.showerror(\"Error\", \"Package 'venv' is not available.\", parent=parent)\n        return False", "is_method": false, "function_description": "Utility function that verifies if the 'venv' module is installed and available, displaying an error dialog if not; it supports environment setup validation in graphical applications requiring virtual environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "load_plugin", "line_number": 628, "body": "def load_plugin():\n    wb = get_workbench()\n    wb.set_default(\"run.backend_name\", \"SameAsFrontend\")\n    wb.set_default(\"CustomInterpreter.used_paths\", [])\n    wb.set_default(\"CustomInterpreter.path\", \"\")\n\n    wb.add_backend(\n        \"SameAsFrontend\",\n        SameAsFrontendCPythonProxy,\n        tr(\"The same interpreter which runs Thonny (default)\"),\n        SameAsFrontEndConfigurationPage,\n        \"01\",\n    )\n\n    wb.add_backend(\n        \"CustomCPython\",\n        CustomCPythonProxy,\n        tr(\"Alternative Python 3 interpreter or virtual environment\"),\n        CustomCPythonConfigurationPage,\n        \"02\",\n    )\n\n    wb.add_backend(\n        \"PrivateVenv\",\n        PrivateVenvCPythonProxy,\n        tr(\"A special virtual environment (deprecated)\"),\n        PrivateVenvConfigurationPage,\n        \"zz\",\n    )", "is_method": false, "function_description": "Initializes and registers multiple Python interpreter backends with default settings in the workbench, enabling flexible selection and configuration of interpreters within the application environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_initial_cwd", "line_number": 41, "body": "def _get_initial_cwd(self):\n        return get_workbench().get_local_cwd()", "is_method": true, "class_name": "CPythonProxy", "function_description": "Returns the initial current working directory as provided by the workbench environment. This method helps retrieve the starting local directory context for operations within the CPythonProxy class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_launch_cwd", "line_number": 44, "body": "def _get_launch_cwd(self):\n        # launch in the directory containing thonny package, so that other interpreters can import it as well\n        return os.path.dirname(os.path.dirname(thonny.__file__))", "is_method": true, "class_name": "CPythonProxy", "function_description": "Returns the directory path from which to launch, ensuring the Thonny package can be imported by other interpreters. This supports consistent interpreter environment setup within the CPythonProxy class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_launcher_with_args", "line_number": 48, "body": "def _get_launcher_with_args(self):\n        return [\"-m\", \"thonny.plugins.cpython\", self.get_cwd()]", "is_method": true, "class_name": "CPythonProxy", "function_description": "Returns the command-line arguments required to launch the CPython plugin with the current working directory set. This facilitates starting the CPython environment configured for Thonny's plugin system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_store_state_info", "line_number": 51, "body": "def _store_state_info(self, msg):\n        super()._store_state_info(msg)\n\n        if \"gui_is_active\" in msg:\n            self._update_gui_updating(msg)", "is_method": true, "class_name": "CPythonProxy", "function_description": "Internal method in CPythonProxy that extends state information storage by updating GUI activity status when relevant data is present in the message. It supports synchronization of GUI state with the proxy's internal status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_clear_environment", "line_number": 57, "body": "def _clear_environment(self):\n        self._close_backend()\n        self._start_background_process()", "is_method": true, "class_name": "CPythonProxy", "function_description": "Private method of CPythonProxy that resets the execution environment by closing the backend and restarting the associated background process. It enables clean state management for subsequent operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_close_backend", "line_number": 61, "body": "def _close_backend(self):\n        self._cancel_gui_update_loop()\n        super()._close_backend()", "is_method": true, "class_name": "CPythonProxy", "function_description": "Internal method of CPythonProxy that stops GUI updates and performs necessary cleanup when closing the backend, ensuring proper resource release and shutdown processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_local_executable", "line_number": 65, "body": "def get_local_executable(self):\n        return self._executable", "is_method": true, "class_name": "CPythonProxy", "function_description": "Returns the local executable path or object associated with the CPythonProxy instance, providing access to the underlying Python executable used by this proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_update_gui_updating", "line_number": 68, "body": "def _update_gui_updating(self, msg):\n        \"\"\"Enables running Tkinter or Qt programs which doesn't call mainloop.\n\n        When mainloop is omitted, then program can be interacted with\n        from the shell after it runs to the end.\n\n        Each ToplevelResponse is supposed to tell, whether gui is active\n        and needs updating.\n        \"\"\"\n        if not \"gui_is_active\" in msg:\n            return\n\n        if msg[\"gui_is_active\"] and self._gui_update_loop_id is None:\n            # Start updating\n            self._loop_gui_update(True)\n        elif not msg[\"gui_is_active\"] and self._gui_update_loop_id is not None:\n            self._cancel_gui_update_loop()", "is_method": true, "class_name": "CPythonProxy", "function_description": "Manages and triggers GUI update cycles for Tkinter or Qt applications that do not run a main event loop, enabling interactive GUI responsiveness from a non-blocking shell environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_loop_gui_update", "line_number": 86, "body": "def _loop_gui_update(self, force=False):\n        if force or get_runner().is_waiting_toplevel_command():\n            try:\n                self.send_command(InlineCommand(\"process_gui_events\"))\n            except OSError:\n                # the backend process may have been closed already\n                # https://github.com/thonny/thonny/issues/966\n                logger.exception(\"Could not send process_gui_events\")\n\n        self._gui_update_loop_id = get_workbench().after(50, self._loop_gui_update)", "is_method": true, "class_name": "CPythonProxy", "function_description": "Utility method in CPythonProxy that repeatedly triggers GUI event processing to keep the interface responsive, optionally forcing updates during command waits."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_cancel_gui_update_loop", "line_number": 97, "body": "def _cancel_gui_update_loop(self):\n        if self._gui_update_loop_id is not None:\n            try:\n                get_workbench().after_cancel(self._gui_update_loop_id)\n            finally:\n                self._gui_update_loop_id = None", "is_method": true, "class_name": "CPythonProxy", "function_description": "Internal method of CPythonProxy that cancels a scheduled GUI update callback to stop ongoing periodic interface refreshes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "interrupt", "line_number": 104, "body": "def interrupt(self):\n        import signal\n\n        if self._proc is not None and self._proc.poll() is None:\n            if running_on_windows():\n                try:\n                    os.kill(self._proc.pid, signal.CTRL_BREAK_EVENT)  # pylint: disable=no-member\n                except Exception:\n                    logging.exception(\"Could not interrupt backend process\")\n            else:\n                self._proc.send_signal(signal.SIGINT)", "is_method": true, "class_name": "CPythonProxy", "function_description": "Interrupts the running backend process managed by CPythonProxy, sending an appropriate interrupt signal based on the operating system to halt execution safely. Useful for gracefully stopping or canceling long-running tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "run_script_in_terminal", "line_number": 116, "body": "def run_script_in_terminal(self, script_path, args, interactive, keep_open):\n        cmd = [self._executable]\n        if interactive:\n            cmd.append(\"-i\")\n        cmd.append(os.path.basename(script_path))\n        cmd.extend(args)\n\n        run_in_terminal(cmd, os.path.dirname(script_path), keep_open=keep_open)", "is_method": true, "class_name": "CPythonProxy", "function_description": "Utility method of CPythonProxy that executes a Python script in a terminal with optional interaction and terminal persistence, facilitating script runs with customizable arguments and environment control."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_supported_features", "line_number": 125, "body": "def get_supported_features(self):\n        return {\"run\", \"debug\", \"run_in_terminal\", \"pip_gui\", \"system_shell\"}", "is_method": true, "class_name": "CPythonProxy", "function_description": "This function provides a list of features supported by the CPythonProxy class, enabling clients to query its capabilities such as running code, debugging, and accessing system shell functions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_pip_gui_class", "line_number": 128, "body": "def get_pip_gui_class(self):\n        from thonny.plugins.pip_gui import CPythonBackendPipDialog\n\n        return CPythonBackendPipDialog", "is_method": true, "class_name": "CPythonProxy", "function_description": "Returns the class object for the pip GUI dialog specific to the CPython backend, enabling integration or customization of the package management interface within the CPythonProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "can_run_remote_files", "line_number": 133, "body": "def can_run_remote_files(self):\n        return False", "is_method": true, "class_name": "CPythonProxy", "function_description": "Indicates whether the system supports executing files remotely. Always returns False, signaling no remote execution capability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "can_run_local_files", "line_number": 136, "body": "def can_run_local_files(self):\n        return True", "is_method": true, "class_name": "CPythonProxy", "function_description": "Simple method in CPythonProxy that indicates if local files can be executed, returning a constant affirmative response for capability checking."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_prepare_private_venv", "line_number": 145, "body": "def _prepare_private_venv(self):\n        path = get_private_venv_path()\n        if os.path.isdir(path) and os.path.isfile(os.path.join(path, \"pyvenv.cfg\")):\n            self._check_upgrade_private_venv(path)\n        else:\n            self._create_private_venv(\n                path, \"Please wait!\\nThonny prepares its virtual environment.\"\n            )", "is_method": true, "class_name": "PrivateVenvCPythonProxy", "function_description": "Ensures a private Python virtual environment is properly set up by verifying, upgrading, or creating it as needed for isolated package management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_check_upgrade_private_venv", "line_number": 154, "body": "def _check_upgrade_private_venv(self, path):\n        # If home is wrong then regenerate\n        # If only micro version is different, then upgrade\n        info = _get_venv_info(path)\n\n        if not is_same_path(info[\"home\"], os.path.dirname(sys.executable)):\n            self._create_private_venv(\n                path,\n                \"Thonny's virtual environment was created for another interpreter.\\n\"\n                + \"Regenerating the virtual environment for current interpreter.\\n\"\n                + \"(You may need to reinstall your 3rd party packages)\\n\"\n                + \"Please wait!.\",\n                clear=True,\n            )\n        else:\n            venv_version = tuple(map(int, info[\"version\"].split(\".\")))\n            sys_version = sys.version_info[:3]\n            assert venv_version[0] == sys_version[0]\n            assert venv_version[1] == sys_version[1]\n\n            if venv_version[2] != sys_version[2]:\n                self._create_private_venv(\n                    path, \"Please wait!\\nUpgrading Thonny's virtual environment.\", upgrade=True\n                )", "is_method": true, "class_name": "PrivateVenvCPythonProxy", "function_description": "PrivateVenvCPythonProxy method that ensures a private virtual environment matches the current Python interpreter, regenerating or upgrading it when interpreter paths or micro versions differ to maintain compatibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_create_private_venv", "line_number": 179, "body": "def _create_private_venv(self, path, description, clear=False, upgrade=False):\n        if not _check_venv_installed(self):\n            return\n        # Don't include system site packages\n        # This way all students will have similar configuration\n        # independently of system Python (if Thonny is used with system Python)\n\n        # NB! Cant run venv.create directly, because in Windows bundle\n        # it tries to link venv to thonny.exe.\n        # Need to run it via proper python\n        args = [\"-m\", \"venv\"]\n        if clear:\n            args.append(\"--clear\")\n        if upgrade:\n            args.append(\"--upgrade\")\n\n        try:\n            import ensurepip\n        except ImportError:\n            args.append(\"--without-pip\")\n\n        args.append(path)\n\n        proc = create_frontend_python_process(args)\n\n        from thonny.workdlg import SubprocessDialog\n\n        dlg = SubprocessDialog(\n            get_workbench(),\n            proc,\n            \"Preparing the backend\",\n            long_description=description,\n            autostart=True,\n        )\n        try:\n            ui_utils.show_dialog(dlg)\n        except Exception:\n            # if using --without-pip the dialog may close very quickly\n            # and for some reason wait_window would give error then\n            logging.exception(\"Problem with waiting for venv creation dialog\")\n        get_workbench().become_active_window()  # Otherwise focus may get stuck somewhere\n\n        bindir = os.path.dirname(get_private_venv_executable())\n        # create private env marker\n        marker_path = os.path.join(bindir, \"is_private\")\n        with open(marker_path, mode=\"w\") as fp:\n            fp.write(\"# This file marks Thonny-private venv\")\n\n        # Create recommended pip conf to get rid of list deprecation warning\n        # https://github.com/pypa/pip/issues/4058\n        pip_conf = \"pip.ini\" if running_on_windows() else \"pip.conf\"\n        with open(os.path.join(path, pip_conf), mode=\"w\") as fp:\n            fp.write(\"[list]\\nformat = columns\")\n\n        assert os.path.isdir(path)", "is_method": true, "class_name": "PrivateVenvCPythonProxy", "function_description": "Creates and configures a private Python virtual environment at a specified path with optional clearing or upgrading, ensuring consistent student environments independent of the system Python setup. It also sets markers and pip configuration to optimize package management within the environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_switcher_entries", "line_number": 236, "body": "def get_switcher_entries(cls):\n        return []", "is_method": true, "class_name": "PrivateVenvCPythonProxy", "function_description": "Returns an empty list of switcher entries, indicating no switcher options are available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "fetch_next_message", "line_number": 244, "body": "def fetch_next_message(self):\n        msg = super().fetch_next_message()\n        if msg and \"welcome_text\" in msg:\n            if is_bundled_python(self._executable):\n                msg[\"welcome_text\"] += \" (bundled)\"\n            else:\n                msg[\"welcome_text\"] += \" (\" + self._executable + \")\"\n        return msg", "is_method": true, "class_name": "SameAsFrontendCPythonProxy", "function_description": "Service method in SameAsFrontendCPythonProxy that fetches the next message and appends executable context to its welcome text, aiding identification of the Python environment source in message handling workflows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_clean_description", "line_number": 253, "body": "def get_clean_description(self):\n        return \"Python \" + get_python_version_string()", "is_method": true, "class_name": "SameAsFrontendCPythonProxy", "function_description": "Returns a clean description string containing the current Python version, useful for displaying environment information in the SameAsFrontendCPythonProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "fetch_next_message", "line_number": 269, "body": "def fetch_next_message(self):\n        msg = super().fetch_next_message()\n        if msg and \"welcome_text\" in msg:\n            msg[\"welcome_text\"] += \" (\" + self._executable + \")\"\n        return msg", "is_method": true, "class_name": "CustomCPythonProxy", "function_description": "Method of CustomCPythonProxy that retrieves the next message and appends executable information to any included welcome text, enhancing message context for downstream processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_clean_description", "line_number": 275, "body": "def get_clean_description(self):\n        desc = get_workbench().get_option(\"CustomInterpreter.path\")\n        if not desc:\n            desc = sys.executable\n\n        return desc", "is_method": true, "class_name": "CustomCPythonProxy", "function_description": "This method retrieves the configured path of a custom Python interpreter or defaults to the current Python executable path if none is set, supporting environment-specific interpreter resolution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_switcher_entry_for_executable", "line_number": 283, "body": "def _get_switcher_entry_for_executable(cls, executable):\n        return (\n            {\"run.backend_name\": cls.backend_name, \"CustomInterpreter.path\": executable},\n            executable,\n        )", "is_method": true, "class_name": "CustomCPythonProxy", "function_description": "Returns a dictionary pairing backend and executable path details with the executable itself, facilitating identification and selection of execution contexts for the CustomCPythonProxy class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_current_switcher_configuration", "line_number": 290, "body": "def get_current_switcher_configuration(cls):\n        return cls._get_switcher_entry_for_executable(\n            get_workbench().get_option(\"CustomInterpreter.path\")\n        )[0]", "is_method": true, "class_name": "CustomCPythonProxy", "function_description": "Retrieves the current switcher configuration based on the configured custom interpreter path. This allows other components to access execution settings tied to the active interpreter environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_switcher_entries", "line_number": 296, "body": "def get_switcher_entries(cls):\n        return [\n            cls._get_switcher_entry_for_executable(executable)\n            for executable in _get_interpreters()\n            if os.path.exists(executable)\n        ]", "is_method": true, "class_name": "CustomCPythonProxy", "function_description": "Returns a list of switcher entries for all existing interpreter executables, enabling dynamic retrieval of available Python interpreter configurations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "should_restart", "line_number": 344, "body": "def should_restart(self):\n        return False", "is_method": true, "class_name": "SameAsFrontEndConfigurationPage", "function_description": "Simple configuration check method in SameAsFrontEndConfigurationPage that indicates no restart is required after configuration changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "should_restart", "line_number": 360, "body": "def should_restart(self):\n        return False", "is_method": true, "class_name": "PrivateVenvConfigurationPage", "function_description": "Returns a boolean indicating whether the private virtual environment configuration requires a restart, always signaling no restart is needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_select_executable", "line_number": 416, "body": "def _select_executable(self):\n        # TODO: get dir of current interpreter\n        options = {\"parent\": self.winfo_toplevel()}\n        if running_on_windows():\n            options[\"filetypes\"] = [\n                (tr(\"Python interpreters\"), \"python.exe\"),\n                (tr(\"all files\"), \".*\"),\n            ]\n\n        filename = askopenfilename(**options)\n        if not filename:\n            return\n\n        if filename.endswith(\"/activate\"):\n            filename = filename[: -len(\"activate\")] + \"python3\"\n\n        if filename:\n            self._configuration_variable.set(filename)", "is_method": true, "class_name": "CustomCPythonConfigurationPage", "function_description": "Internal method of CustomCPythonConfigurationPage that lets users select a Python interpreter executable file and updates the configuration variable accordingly, supporting platform-specific file filtering during selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_create_venv", "line_number": 435, "body": "def _create_venv(self, event=None):\n        if not _check_venv_installed(self):\n            return\n\n        messagebox.showinfo(\n            \"Creating new virtual environment\",\n            \"After clicking 'OK' you need to choose an empty directory, \"\n            \"which will be the root of your new virtual environment.\",\n            parent=self,\n        )\n        path = None\n        while True:\n            path = askdirectory(\n                parent=self.winfo_toplevel(),\n                initialdir=path,\n                title=tr(\"Select empty directory for new virtual environment\"),\n            )\n            if not path:\n                return\n\n            if os.listdir(path):\n                messagebox.showerror(\n                    tr(\"Bad directory\"),\n                    tr(\"Selected directory is not empty.\\nSelect another or cancel.\"),\n                    master=self,\n                )\n            else:\n                break\n        assert os.path.isdir(path)\n        path = normpath_with_actual_case(path)\n\n        proc = subprocess.Popen(\n            [running.get_interpreter_for_subprocess(), \"-m\", \"venv\", path],\n            stdin=None,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            universal_newlines=True,\n        )\n        from thonny.workdlg import SubprocessDialog\n\n        dlg = SubprocessDialog(self, proc, tr(\"Creating virtual environment\"), autostart=True)\n        ui_utils.show_dialog(dlg)\n\n        if running_on_windows():\n            exe_path = normpath_with_actual_case(os.path.join(path, \"Scripts\", \"python.exe\"))\n        else:\n            exe_path = os.path.join(path, \"bin\", \"python3\")\n\n        if os.path.exists(exe_path):\n            self._configuration_variable.set(exe_path)", "is_method": true, "class_name": "CustomCPythonConfigurationPage", "function_description": "Creates a new Python virtual environment by prompting the user to select an empty directory and running the venv module, then updates the configuration with the new environment's Python executable path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "should_restart", "line_number": 486, "body": "def should_restart(self):\n        return self._configuration_variable.modified", "is_method": true, "class_name": "CustomCPythonConfigurationPage", "function_description": "Indicates whether the configuration has been modified and thus requires a restart. This helps dependent processes decide if a restart is necessary to apply changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "apply", "line_number": 489, "body": "def apply(self):\n        if not self.should_restart():\n            return\n\n        path = self._configuration_variable.get()\n        if os.path.isfile(path):\n            get_workbench().set_option(\"CustomInterpreter.path\", path)", "is_method": true, "class_name": "CustomCPythonConfigurationPage", "function_description": "Updates the interpreter path in the workbench configuration if a restart is required and the specified path points to a valid file. This method ensures the custom interpreter setting is applied when appropriate."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/birdseye_backend.py", "function": "_cmd_Birdseye", "line_number": 11, "body": "def _cmd_Birdseye(cmd):\n    backend = get_backend()\n    backend.switch_env_to_script_mode(cmd)\n    return backend._execute_file(cmd, BirdsEyeRunner)", "is_method": false, "function_description": "Executes a command in a specialized script mode using a backend service designed for BirdsEyeRunner. This function enables running bird\u2019s-eye view scripts within the backend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/birdseye_backend.py", "function": "load_plugin", "line_number": 42, "body": "def load_plugin():\n    try:\n        os.environ[\"OUTDATED_IGNORE\"] = \"1\"\n        # TODO: it would be good to do this here, but it's slow\n        # import birdseye.bird  # need to import at plugin load time, because later it may not be in path\n    except ImportError:\n        pass\n    get_backend().add_command(\"Birdseye\", _cmd_Birdseye)", "is_method": false, "function_description": "Registers the Birdseye debugging plugin with the backend, ensuring it is available as a command while handling potential import issues silently."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/birdseye_backend.py", "function": "execute_source", "line_number": 20, "body": "def execute_source(self, source, filename, mode, ast_postprocessors):\n        import webbrowser\n\n        assert mode == \"exec\"\n        # ignore ast_postprocessors, because birdseye requires source\n\n        if isinstance(source, bytes):\n            source = source.decode(\"utf-8\")\n\n        import __main__  # @UnresolvedImport\n\n        global_vars = __main__.__dict__\n\n        # Following is a trick, which allows importing birdseye in the backends,\n        # which doesn't have it installed (provided it is installed for frontend Python)\n        from birdseye.bird import eye\n\n        eye.exec_string(source, filename, globs=global_vars, locs=global_vars, deep=True)\n        port = os.environ.get(\"BIRDSEYE_PORT\", \"7777\")\n        webbrowser.open_new_tab(\"http://localhost:%s/ipython_call/\" % port + eye._last_call_id)", "is_method": true, "class_name": "BirdsEyeRunner", "function_description": "Runs Python source code with Birdseye tracing enabled and opens a web browser to display its execution details visually. This method facilitates interactive debugging by executing code under Birdseye\u2019s instrumentation within the current global context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/pgzero_backend.py", "function": "augment_ast", "line_number": 8, "body": "def augment_ast(root):\n    mode = os.environ.get(\"PGZERO_MODE\", \"False\")\n    assert mode != \"False\"\n\n    warning_prelude = \"WARNING: Pygame Zero mode is turned on (Run \u2192 Pygame Zero mode)\"\n    try:\n        import pgzero  # @UnusedImport\n    except ImportError:\n        if mode == \"True\":\n            print(\n                warning_prelude\n                + \",\\nbut pgzero module is not found. Running program in regular mode.\\n\",\n                file=sys.stderr,\n            )\n        else:\n            assert mode == \"auto\"\n\n        return\n\n    # Check if draw is defined\n    for stmt in root.body:\n        if isinstance(stmt, ast.FunctionDef) and stmt.name == \"draw\":\n            break\n    else:\n        if mode == \"auto\":\n            return\n        else:\n            print(\n                warning_prelude\n                + \",\\nbut your program doesn't look like usual Pygame Zero program\\n\"\n                + \"(draw function is missing).\\n\",\n                file=sys.stderr,\n            )\n\n    # need more checks in auto mode\n    if mode == \"auto\":\n        # check that draw method is not called in the code\n        for node in ast.walk(root):\n            if (\n                isinstance(node, ast.Call)\n                and isinstance(node.func, ast.Name)\n                and node.func.id == \"draw\"\n            ):\n                return\n\n    # prepend \"import pgzrun as __pgzrun\"\n    imp = ast.Import([ast.alias(\"pgzrun\", \"__pgzrun\")])\n    imp.lineno = 0\n    imp.col_offset = 0\n    ast.fix_missing_locations(imp)\n    imp.tags = {\"ignore\"}\n    root.body.insert(0, imp)\n\n    # append \"__pgzrun.go()\"\n    go = ast.Expr(\n        ast.Call(ast.Attribute(ast.Name(\"__pgzrun\", ast.Load()), \"go\", ast.Load()), [], [])\n    )\n    go.lineno = 1000000\n    go.col_offset = 0\n    ast.fix_missing_locations(go)\n    go.tags = {\"ignore\"}\n    root.body.append(go)", "is_method": false, "function_description": "Function that modifies an abstract syntax tree to enable Pygame Zero mode by injecting import and execution calls, supporting automatic mode detection and warnings for typical usage issues. It facilitates running Python programs with Pygame Zero integration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/pgzero_backend.py", "function": "patched_editor_autocomplete", "line_number": 72, "body": "def patched_editor_autocomplete(self, cmd):\n    # Make extra builtins visible for Jedi\n    prefix = \"from pgzero.builtins import *\\n\"\n    cmd[\"source\"] = prefix + cmd[\"source\"]\n    cmd[\"row\"] = cmd[\"row\"] + 1\n\n    result = get_backend()._original_editor_autocomplete(cmd)\n    result[\"row\"] = result[\"row\"] - 1\n    result[\"source\"] = result[\"source\"][len(prefix) :]\n\n    return result", "is_method": false, "function_description": "Provides code autocompletion for an editor by injecting additional built-in imports temporarily, enhancing autocomplete results without altering the original source code context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/pgzero_backend.py", "function": "load_plugin", "line_number": 85, "body": "def load_plugin():\n    if os.environ.get(\"PGZERO_MODE\", \"False\").lower() == \"false\":\n        return\n\n    get_backend().add_ast_postprocessor(augment_ast)\n    MainCPythonBackend._original_editor_autocomplete = MainCPythonBackend._cmd_editor_autocomplete\n    MainCPythonBackend._cmd_editor_autocomplete = patched_editor_autocomplete", "is_method": false, "function_description": "Enables plugin integration by modifying the backend and editor autocomplete behavior when a specific environment mode is active. It activates plugin-related AST processing and editor enhancements conditionally."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/flask_backend.py", "function": "augment_source", "line_number": 6, "body": "def augment_source(source, cmd):\n    if \"Flask\" not in source:\n        # don't bother analyzing further\n        return source\n\n    try:\n        tree = ast.parse(source)\n    except SyntaxError:\n        return source\n\n    var_name = None\n    found_run = False\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, ast.Assign)\n            and isinstance(node.value, ast.Call)\n            and isinstance(node.value.func, ast.Name)  # TODO: could be also flask.Flask\n            and node.value.func.id == \"Flask\"\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], ast.Name)\n        ):\n            var_name = node.targets[0].id\n        elif (\n            isinstance(node, ast.Call)\n            and isinstance(node.func, ast.Attribute)\n            and isinstance(node.func.value, ast.Name)\n            and node.func.value.id == var_name\n            and node.func.attr == \"run\"\n        ):\n            found_run = True\n\n    if not var_name or found_run:\n        return source\n    else:\n        return (\n            source\n            + \"\"\"\n\nif \"{app_name}\" in globals():\n    import os as __temp_os__\n    if \"FLASK_ENV\" not in __temp_os__.environ:\n        __temp_os__.environ[\"FLASK_ENV\"] = \"development\"\n    del __temp_os__\n    \n    # Conservative options for minimum technical risks.\n    # Users who need more control should call run explicitly.\n    print(\" # Running the app with options chosen by Thonny. See Help for details.\")\n    {app_name}.run(threaded=False, debug=False, use_reloader=False)\n\"\"\".format(\n                app_name=var_name\n            )\n        )", "is_method": false, "function_description": "Function that detects a Flask app instance in source code and appends a safe default app.run invocation if none exists, enabling automatic development server startup with minimal configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/matplotlib_backend.py", "function": "set_default_backend", "line_number": 13, "body": "def set_default_backend(matplotlib):\n    global done\n\n    # Tried with overwriting settings only when MacOSX backend is selected\n    # but querying this failed because of strange import behavior\n    if (\n        done\n        or \"MPLBACKEND\" in os.environ\n        or os.path.exists(local_conf_file)\n        or os.path.exists(user_conf_file1)\n        or os.path.exists(user_conf_file2)\n    ):\n        # done or the user knows what (s)he's doing\n        pass\n    else:\n\n        try:\n            import tkinter  # @UnusedImport\n\n            os.environ[\"MPLBACKEND\"] = \"TkAgg\"\n        except ImportError:\n            pass\n\n    done = True", "is_method": false, "function_description": "Sets the default Matplotlib backend to \"TkAgg\" if no backend is specified and no user configuration exists, ensuring a usable GUI backend is selected for plotting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/dock_user_windows_backend.py", "function": "on_configure", "line_number": 11, "body": "def on_configure(event):\n    global _last_pos, _notification_is_sent\n    pos = event.x, event.y\n    if pos != _last_pos:\n        get_backend().set_option(_LAST_POS_SETTING, pos)\n\n    if not _notification_is_sent:\n        get_backend().send_message(BackendEvent(\"UserWindowAppeared\"))\n        _notification_is_sent = True", "is_method": false, "function_description": "Function handling configuration events by updating position settings and sending a one-time notification when a user window appears. It supports event-driven UI state management and user interaction tracking."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/dock_user_windows_backend.py", "function": "patch_tkinter", "line_number": 22, "body": "def patch_tkinter(module):\n    flag_name = \"has_docking_patch\"\n    if getattr(module, flag_name, False):\n        return\n\n    original_constructor = module.Tk.__init__\n\n    def patched_Tk_constructor(self, *args, **kw):\n        original_constructor(self, *args, **kw)\n\n        try:\n            # move window to the same place it was previously\n            last_pos = get_backend().get_option(_LAST_POS_SETTING)\n            if isinstance(last_pos, tuple):\n                self.geometry(\"+%d+%d\" % last_pos)\n\n            self.wm_attributes(\"-topmost\", 1)\n            # self.overrideredirect(1)\n\n            # I'm using bind_class because turtle._Screen later overwrites the bind handler\n            self.bind_class(\"Tk\", \"<Configure>\", on_configure, True)\n        except Exception:\n            # expected to fail when constructing Tcl for _cmd_process_gui_events\n            pass\n\n    module.Tk.__init__ = patched_Tk_constructor\n    setattr(module, flag_name, True)", "is_method": false, "function_description": "Patches the tkinter module to enhance the Tk window constructor by restoring the previous window position, setting it always on top, and binding configuration events, enabling improved window behavior customization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/dock_user_windows_backend.py", "function": "patch_turtle", "line_number": 51, "body": "def patch_turtle(module):\n    # Turtle needs more tweaking because it later overrides the position set in the Tk constructor\n    turtle_config = getattr(module, \"_CFG\", None)\n    if isinstance(turtle_config, dict):\n        last_pos = get_backend().get_option(_LAST_POS_SETTING)\n        if isinstance(last_pos, tuple):\n            turtle_config[\"leftright\"], turtle_config[\"topbottom\"] = last_pos", "is_method": false, "function_description": "Utility function that adjusts the turtle module's internal position settings based on stored backend options, ensuring consistent turtle graphics positioning across sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/dock_user_windows_backend.py", "function": "load_plugin", "line_number": 60, "body": "def load_plugin():\n    if os.environ.get(\"DOCK_USER_WINDOWS\", \"False\").lower() == \"true\":\n        backend = get_backend()\n        backend.add_import_handler(\"tkinter\", patch_tkinter)\n        backend.add_import_handler(\"turtle\", patch_turtle)", "is_method": false, "function_description": "Enables dynamic import handling for specific plugins when running in a Windows environment, modifying backends to support patched versions of certain modules. This function facilitates environment-specific plugin integration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/dock_user_windows_backend.py", "function": "patched_Tk_constructor", "line_number": 29, "body": "def patched_Tk_constructor(self, *args, **kw):\n        original_constructor(self, *args, **kw)\n\n        try:\n            # move window to the same place it was previously\n            last_pos = get_backend().get_option(_LAST_POS_SETTING)\n            if isinstance(last_pos, tuple):\n                self.geometry(\"+%d+%d\" % last_pos)\n\n            self.wm_attributes(\"-topmost\", 1)\n            # self.overrideredirect(1)\n\n            # I'm using bind_class because turtle._Screen later overwrites the bind handler\n            self.bind_class(\"Tk\", \"<Configure>\", on_configure, True)\n        except Exception:\n            # expected to fail when constructing Tcl for _cmd_process_gui_events\n            pass", "is_method": false, "function_description": "Modifies the Tkinter Tk window constructor to restore the window\u2019s last position, keep it on top, and bind configuration events for customized window behavior. It enhances window state persistence and interactivity in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "print_current_script", "line_number": 10, "body": "def print_current_script():\n    editor = _get_current_editor()\n    assert editor is not None\n\n    template_fn = os.path.join(os.path.dirname(__file__), \"template.html\")\n    with open(template_fn, encoding=\"utf-8\") as f:\n        template_html = f.read()\n\n    script_html = _export_text_as_html(editor.get_text_widget())\n    title_html = escape_html(editor.get_title())\n    full_html = template_html.replace(\"%title%\", title_html).replace(\"%script%\", script_html)\n\n    import tempfile\n\n    temp_handle, temp_fn = tempfile.mkstemp(\n        suffix=\".html\", prefix=\"thonny_\", dir=get_workbench().get_temp_dir()\n    )\n    with os.fdopen(temp_handle, \"w\", encoding=\"utf-8\") as f:\n        f.write(full_html)\n\n    if platform.system() == \"Darwin\":\n        subprocess.Popen([\"open\", temp_fn])\n    else:\n        import webbrowser\n\n        webbrowser.open(temp_fn)", "is_method": false, "function_description": "This function generates an HTML preview of the current script from the editor and opens it in a web browser, facilitating script review or printing with a styled template."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "can_print_current_script", "line_number": 38, "body": "def can_print_current_script():\n    return _get_current_editor() is not None", "is_method": false, "function_description": "Checks if there is an active editor available to print the current script, indicating whether printing the script is possible in the current context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "_export_text_as_html", "line_number": 42, "body": "def _export_text_as_html(text):\n    last_line = int(float(text.index(\"end-1c\")))\n    result = \"\"\n    for i in range(1, last_line + 1):\n        result += \"<code>\" + _export_line_as_html(text, i) + \"</code>\\n\"\n    return result", "is_method": false, "function_description": "Utility function that converts a multiline text object into an HTML-formatted string by exporting each line wrapped in <code> tags, useful for displaying text content with preserved line structure in HTML."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "_export_line_as_html", "line_number": 50, "body": "def _export_line_as_html(text, lineno):\n    s = text.get(\"%d.0\" % lineno, \"%d.0 lineend\" % lineno).strip(\"\\r\\n\")\n\n    parts = []\n    for i in range(len(s)):\n        tag_names = text.tag_names(\"%d.%d\" % (lineno, i))\n        if not parts or parts[-1][1] != tag_names:\n            parts.append([s[i], tag_names])\n        else:\n            parts[-1][0] += s[i]\n\n    # print(lineno, parts)\n    result = \"\"\n    for s, tags in parts:\n        if tags:\n            result += \"<span class='%s'>%s</span>\" % (\" \".join(tags), escape_html(s))\n        else:\n            result += escape_html(s)\n\n    return result", "is_method": false, "function_description": "Generates an HTML-formatted string representing a specific line of text with its associated tags as CSS classes, enabling styled rendering of text content line-by-line in an HTML context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "escape_html", "line_number": 72, "body": "def escape_html(s):\n    return s.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")", "is_method": false, "function_description": "Function that converts special HTML characters in a string into their corresponding escape sequences to prevent HTML injection or rendering issues. Useful for safely displaying user-generated content in web pages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "load_plugin", "line_number": 80, "body": "def load_plugin():\n    get_workbench().add_command(\n        \"printcurrent\",\n        \"file\",\n        tr(\"Print...\"),\n        print_current_script,\n        can_print_current_script,\n        default_sequence=select_sequence(\"<Control-p>\", \"<Command-p>\"),\n        extra_sequences=[\"<Control-Greek_pi>\"],\n        group=11,\n    )", "is_method": false, "function_description": "Registers a plugin command to print the current script in the workbench interface, enabling users to invoke printing via keyboard shortcuts or menu options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 27, "body": "def get_known_usb_vids_pids(cls):\n        \"\"\"Information gathered from\n        https://github.com/mu-editor/mu/blob/master/mu/modes/circuitpython.py\n        https://github.com/microsoft/uf2-samdx1\n        \"\"\"\n        return {\n            (0x03EB, 0x2402),  # Generic Corp., SAMD21 or SAME54 Board\n            (0x04D8, 0xEC72),  # XinaBox CC03\n            (0x04D8, 0xEC75),  # XinaBox CS11\n            (0x04D8, 0xED94),  # PyCubed\n            (0x04D8, 0xED5E),  # XinaBox CW03\n            (0x04D8, 0xEDB3),  # Capable Robot Components, Programmable USB Hub\n            (0x04D8, 0xEDBE),  # maholli, SAM32\n            (0x04D8, 0xEF66),  # eduSense, senseBox MCU\n            (0x1209, 0x2017),  # Benjamin Shockley, Mini SAM M4\n            (0x1209, 0x4D44),  # Robotics Masters, Robo HAT MM1 M4\n            (0x1209, 0x7102),  # Mini SAM M0\n            (0x1209, 0xBAB1),  # Electronic Cats Meow Meow\n            (0x1209, 0xBAB2),  # Electronic Cats CatWAN USBStick\n            (0x1209, 0xBAB3),  # Electronic Cats Bast Pro Mini M0\n            (0x1209, 0xBAB6),  # Electronic Cats Escornabot Makech\n            (0x16D0, 0x0CDA),  # dadamachines, automat\n            (0x1B4F, 0x0016),  # Sparkfun Thing Plus - SAMD51\n            (0x1B4F, 0x8D22),  # SparkFun SAMD21 Mini Breakout\n            (0x1B4F, 0x8D23),  # SparkFun SAMD21 Dev Breakout\n            (0x1D50, 0x60E8),  # PewPew Game Console\n            (0x1D50, 0x6110),  # Eitech, Robotics\n            (0x1D50, 0x6112),  # Watterott electronic, Wattuino RC\n            (0x2341, 0x8053),  # Arduino LLC, Arduino MKR1300\n            (0x2341, 0x8057),  # Arduino Nano 33 IoT board\n            (0x239A, None),  # Adafruit\n            (0x2886, 0x802D),  # Seeed Wio Terminal\n            (0x2886, 0x000D),  # Seeed Studio, Grove Zero\n            (0x2B04, 0xC00C),  # Particle Argon\n            (0x2B04, 0xC00D),  # Particle Boron\n            (0x2B04, 0xC00E),  # Particle Xenon\n            (0x3171, 0x0101),  # 8086.net Commander\n        }", "is_method": true, "class_name": "CircuitPythonProxy", "function_description": "Returns a set of known USB vendor and product ID pairs associated with CircuitPython-compatible devices, facilitating device identification and filtering in USB communication contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "get_vids_pids_to_avoid", "line_number": 67, "body": "def get_vids_pids_to_avoid(self):\n        return VIDS_PIDS_TO_AVOID", "is_method": true, "class_name": "CircuitPythonProxy", "function_description": "Returns a predefined list of vendor and product IDs to avoid, supporting device filtering in the CircuitPythonProxy class. This helps other functions exclude incompatible or problematic hardware identifiers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_get_usb_driver_url", "line_number": 72, "body": "def _get_usb_driver_url(self):\n        return \"https://learn.adafruit.com/welcome-to-circuitpython/installing-circuitpython\"", "is_method": true, "class_name": "CircuitPythonConfigPage", "function_description": "Returns the URL for downloading the CircuitPython USB driver, providing users with a direct link to installation instructions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_has_flashing_dialog", "line_number": 75, "body": "def _has_flashing_dialog(self):\n        return True", "is_method": true, "class_name": "CircuitPythonConfigPage", "function_description": "Returns a constant value indicating that a flashing dialog is always present. This method likely signals the availability of a flashing interface in CircuitPythonConfigPage."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_open_flashing_dialog", "line_number": 78, "body": "def _open_flashing_dialog(self):\n        dlg = CircuitPythonFlashingDialog(self)\n        ui_utils.show_dialog(dlg)", "is_method": true, "class_name": "CircuitPythonConfigPage", "function_description": "Launches and displays a dialog for flashing CircuitPython firmware, facilitating user interaction during the flashing process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "get_instructions", "line_number": 88, "body": "def get_instructions(self) -> Optional[str]:\n        return (\n            \"This dialog allows you to install or update CircuitPython firmware on your device.\\n\"\n            \"\\n\"\n            \"1. Plug in your device into bootloader mode by double-pressing the reset button.\\n\"\n            \"2. Wait until device information appears.\\n\"\n            \"3. (If nothing happens in 10 seconds, then try shorter or longer pauses between presses.)\\n\"\n            \"4. Click 'Install' and wait until done.\\n\"\n            \"5. Close the dialog and start programming!\"\n        )", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Provides user instructions for installing or updating CircuitPython firmware via the dialog, guiding through device preparation, installation steps, and post-installation actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_get_release_info_url", "line_number": 99, "body": "def _get_release_info_url(self):\n        return \"https://api.github.com/repos/adafruit/circuitpython/releases/latest\"", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Returns the URL for accessing the latest release information of the CircuitPython repository on GitHub. This serves as a reference endpoint for checking current version details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_get_devices_info_url", "line_number": 102, "body": "def _get_devices_info_url(self):\n        # use the master version, not bundled version\n        return \"https://raw.githubusercontent.com/thonny/thonny/master/thonny/plugins/circuitpython/devices.json\"", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Returns the URL for the master version of the CircuitPython devices information JSON, ensuring access to the latest device data for firmware flashing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_download_release_info", "line_number": 106, "body": "def _download_release_info(self):\n        # First download devices\n        import json\n        from urllib.request import urlopen\n\n        try:\n            with urlopen(self._get_devices_info_url()) as fp:\n                self._devices_info = json.loads(fp.read().decode(\"UTF-8\"))\n        except Exception as e:\n            logger.warning(\n                \"Could not find release info from %s\", self._get_release_info_url(), exc_info=e\n            )\n            return\n\n        # ... and then release\n        super(CircuitPythonFlashingDialog, self)._download_release_info()", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Downloads device information as JSON from a specified URL and stores it, then proceeds to download release information. It supports updating device and release data for CircuitPython flashing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "get_download_url_and_size", "line_number": 123, "body": "def get_download_url_and_size(self, board_id):\n        # TODO: should take vid/pid also into account. It looks like different models may have same board_id\n        if self._release_info is None or self._devices_info is None:\n            return None\n\n        if not \"tag_name\" in self._release_info:\n            raise RuntimeError(\"Could not find tag_name from %s\" % self._get_release_info_url())\n\n        release = self._release_info[\"tag_name\"]\n\n        if not self._devices_info.get(board_id, {}).get(\"FIRMWARE_DOWNLOAD\", None):\n            raise RuntimeError(\n                \"Could not find your board (%s) or its download url from %s (consider making a PR). \"\n                % (board_id, self._get_devices_info_url())\n                + \"Please find the firmware from https://circuitpython.org/ and install it manually.\"\n            )\n\n        url = self._devices_info[board_id][\"FIRMWARE_DOWNLOAD\"].format(\n            lang=\"en_US\", release=release\n        )\n\n        # reporting approximate size for now. Downloader can take precise value from the header later\n        size = 2 ** 20  # 1 MiB\n        return (url, size)", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Retrieves the download URL and approximate file size of the firmware for a specific board, facilitating automated CircuitPython firmware flashing by linking board identifiers to their release resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "get_title", "line_number": 152, "body": "def get_title(self):\n        return \"Install CircuitPython firmware for your device\"", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Returns the dialog title indicating the process to install CircuitPython firmware on a device, providing a clear UI label for user guidance during firmware installation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_get_vid_pids_to_wait_for", "line_number": 155, "body": "def _get_vid_pids_to_wait_for(self):\n        return CircuitPythonProxy.get_known_usb_vids_pids()", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Utility method in CircuitPythonFlashingDialog that retrieves known USB vendor and product IDs to identify devices to wait for during the flashing process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/update_firmware_mapping.py", "function": "update_info", "line_number": 24, "body": "def update_info(existing_map, name, info_path):\n    info = {}\n    with open(info_path, encoding=\"utf-8\") as fp:\n        for line in fp:\n            if \" //\" in line:\n                line = line[: line.find(\" //\")]\n            parts = list(map(str.strip, line.strip().split(maxsplit=2)))\n            if len(parts) == 3 and parts[0] == \"#define\" and parts[1] in relevant_vars:\n                value = parts[2]\n                if value.startswith('\"'):\n                    value = value[1:-1]\n                info[parts[1]] = value\n\n    if \"BOARD_ID\" in info:\n        combined_record = existing_map.get(info[\"BOARD_ID\"], {})\n        combined_record.update(info)\n        if \"FIRMWARE_DOWNLOAD\" in combined_record:\n            combined_record[\"FIRMWARE_DOWNLOAD\"] = \"\"\n        if \"CP_URL\" not in combined_record:\n            combined_record[\"CP_URL\"] = \"\"\n        existing_map[info[\"BOARD_ID\"]] = combined_record\n\n        if combined_record[\"CP_URL\"] and not combined_record[\"FIRMWARE_DOWNLOAD\"]:\n            board_key = combined_record[\"CP_URL\"].strip(\"/\").split(\"/\")[-1]\n            url = DOWNLOAD_URL_PATTERN.replace(\"BOARD_KEY\", board_key)\n            # print(url.format(lang=\"en_US\", release=CP_LATEST_VER))\n            combined_record[\"FIRMWARE_DOWNLOAD\"] = url", "is_method": false, "function_description": "Updates a mapping with board-specific information parsed from a definition file, ensuring firmware download URLs are set or reset based on extracted metadata for hardware board management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/cirpy_backend.py", "function": "_soft_reboot_without_running_main", "line_number": 14, "body": "def _soft_reboot_without_running_main(self):\n        logger.debug(\"_soft_reboot_without_running_main\")\n        # no point in going to raw mode at all\n        self._write(SOFT_REBOOT_CMD + INTERRUPT_CMD)\n\n        logger.debug(\"Extra interrupts for CP\")\n        # CP runs code.py after soft-reboot even in raw repl, so I'll send some Ctrl-C to intervene\n        # # (they don't do anything when already in raw repl)\n        self._write(INTERRUPT_CMD)\n        time.sleep(0.05)\n        self._write(INTERRUPT_CMD)\n        time.sleep(0.3)\n        self._write(INTERRUPT_CMD)\n        time.sleep(0.05)\n        self._write(INTERRUPT_CMD)\n\n        self._capture_output_until_active_prompt()", "is_method": true, "class_name": "CircuitPythonBackend", "function_description": "Core method of CircuitPythonBackend that performs a soft reboot on the device while preventing automatic execution of the main script, enabling safe intervention after reboot without running user code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "load_plugin", "line_number": 101, "body": "def load_plugin():\n    add_micropython_backend(\n        \"RPiPico\",\n        RaspberryPiPicoBackendProxy,\n        \"MicroPython (Raspberry Pi Pico)\",\n        RaspberryPiPicoBackendConfigPage,\n        bare_metal=True,\n        sort_key=\"32\",\n        validate_time=False,\n        sync_time=True,\n        write_block_size=64,\n    )\n\n    # Don't consider Pico in generic backends\n    # The main reason is to reduce the number of items in the backend switcher menu\n    import thonny.plugins.circuitpython\n    import thonny.plugins.micropython\n\n    thonny.plugins.micropython.VIDS_PIDS_TO_AVOID_IN_GENERIC_BACKEND.update(\n        RaspberryPiPicoBackendProxy.get_known_usb_vids_pids()\n    )", "is_method": false, "function_description": "Registers and configures the Raspberry Pi Pico MicroPython backend within the system, ensuring it is distinct from generic backends and updating USB device filters accordingly. This function enables seamless integration of the Pico device in the environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "consider_unknown_devices", "line_number": 18, "body": "def consider_unknown_devices(self):\n        return False", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Returns a fixed response indicating that unknown devices should not be considered or processed by the backend proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "should_consider_unknown_devices", "line_number": 22, "body": "def should_consider_unknown_devices(cls):\n        return False", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Returns a class-level decision indicating whether unknown devices should be considered. This can govern device filtering behavior in the RaspberryPiPicoBackendProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "known_usb_vids_pids", "line_number": 26, "body": "def known_usb_vids_pids(self):\n        # Required for backward compatibility\n        return RaspberryPiPicoBackendProxy.get_known_usb_vids_pids()", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Provides a backward-compatible way to retrieve known USB vendor and product IDs recognized by the RaspberryPiPicoBackendProxy class. Useful for identifying compatible USB devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 31, "body": "def get_known_usb_vids_pids(cls):\n        return {(0x2E8A, 0x0005)}", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Returns a set of known USB vendor and product ID pairs for Raspberry Pi Pico devices, facilitating device identification and communication setup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "device_is_present_in_bootloader_mode", "line_number": 35, "body": "def device_is_present_in_bootloader_mode(cls):\n        return bool(PicoFlashingDialog.get_possible_targets())", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Utility method in RaspberryPiPicoBackendProxy that checks if any Raspberry Pi Pico device is currently available in bootloader mode, supporting device detection for firmware flashing processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "get_node_label", "line_number": 38, "body": "def get_node_label(self):\n        return \"Raspberry Pi Pico\"", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Returns a fixed label identifying the node as \"Raspberry Pi Pico,\" allowing other functions to recognize or display the device type associated with this backend proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_propose_install_firmware", "line_number": 41, "body": "def _propose_install_firmware(self):\n        dlg = PicoFlashingDialog(get_workbench())\n        show_dialog(dlg)\n        return dlg.success", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Internal method of RaspberryPiPicoBackendProxy that initiates a firmware installation dialog and returns whether the installation was successful, facilitating device firmware management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_has_flashing_dialog", "line_number": 48, "body": "def _has_flashing_dialog(self):\n        return True", "is_method": true, "class_name": "RaspberryPiPicoBackendConfigPage", "function_description": "Always indicates that the flashing dialog should be shown, serving as a constant flag within the RaspberryPiPicoBackendConfigPage configuration flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_open_flashing_dialog", "line_number": 51, "body": "def _open_flashing_dialog(self):\n        dlg = PicoFlashingDialog(self.winfo_toplevel())\n        ui_utils.show_dialog(dlg)", "is_method": true, "class_name": "RaspberryPiPicoBackendConfigPage", "function_description": "Opens and displays a dialog interface for flashing firmware onto a Raspberry Pi Pico device, enabling users to initiate or manage the flashing process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "get_instructions", "line_number": 57, "body": "def get_instructions(self) -> Optional[str]:\n        return (\n            \"Here you can install or update MicroPython firmware on Raspberry Pi Pico.\\n\"\n            \"\\n\"\n            \"1. Plug in your Pico while holding the BOOTSEL button.\\n\"\n            \"2. Wait until device information appears.\\n\"\n            \"3. Click 'Install'.\\n\"\n            \"\\n\"\n            \"When the process finishes, your Pico will be running the latest version of\\n\"\n            \"MicroPython. Close the dialog and start programming!\"\n        )", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "Provides users with step-by-step instructions for installing or updating MicroPython firmware on a Raspberry Pi Pico within the PicoFlashingDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_get_release_info_url", "line_number": 69, "body": "def _get_release_info_url(self):\n        return \"https://raw.githubusercontent.com/thonny/thonny/master/data/rpi-pico-firmware.json\"", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "Private method in PicoFlashingDialog that provides the URL for retrieving Raspberry Pi Pico firmware release information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "get_download_url_and_size", "line_number": 72, "body": "def get_download_url_and_size(self, board_id):\n        if self._release_info is None:\n            return None\n\n        logger.info(\n            \"Assets from %s: %r\", self._get_release_info_url(), self._release_info[\"assets\"]\n        )\n        candidates = self._release_info[\"assets\"]\n\n        if len(candidates) == 0:\n            raise RuntimeError(\n                \"Could not find the right file from the release info (%s)\"\n                % self._get_release_info_url()\n            )\n        else:\n            # The json is meant for Thonny, so take the first one for now\n            return (candidates[0][\"browser_download_url\"], candidates[0][\"size\"])", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "Provides the download URL and file size for a specified board's firmware from release assets, facilitating firmware retrieval within the PicoFlashingDialog class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_is_relevant_board_id", "line_number": 91, "body": "def _is_relevant_board_id(cls, board_id):\n        return \"RPI\" in board_id", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "Checks if a given board ID belongs to the Raspberry Pi family by detecting the substring \"RPI\". This helps filter or validate board identifiers relevant to Raspberry Pi devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "get_title", "line_number": 94, "body": "def get_title(self):\n        return \"Install MicroPython firmware for Raspberry Pi Pico\"", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "Returns the consistent dialog title indicating the firmware installation for Raspberry Pi Pico. This provides a standardized UI label for the flashing dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_get_vid_pids_to_wait_for", "line_number": 97, "body": "def _get_vid_pids_to_wait_for(self):\n        return RaspberryPiPicoBackendProxy.get_known_usb_vids_pids()", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "Returns a list of USB vendor and product IDs to wait for, aiding device detection specific to Raspberry Pi Pico hardware."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/rpi_pico_backend.py", "function": "_sync_time", "line_number": 11, "body": "def _sync_time(self):\n        \"\"\"Sets the time to match the time on the host.\"\"\"\n\n        logger.info(\"Syncing time in Pico\")\n\n        # RTC works on UTC\n        now = self._get_time_for_rtc()\n\n        specific_script = dedent(\n            \"\"\"\n            try:\n                __th_dt_ts = {datetime_ts}\n                from machine import RTC as __thonny_RTC\n                try:\n                    __thonny_RTC().datetime(__th_dt_ts)\n                except:\n                    __thonny_RTC().init({init_ts})\n                del __thonny_RTC\n            except ImportError:\n                assert __thonny_helper.os.uname().sysname == 'rp2'\n                from machine import mem32 as __th_mem32\n                __th_mem32[0x4005c004] =  __th_dt_ts[0] << 12 | __th_dt_ts[1] << 8 | __th_dt_ts[2]\n                __th_mem32[0x4005c008] = (__th_dt_ts[3] % 7) << 24 | __th_dt_ts[4] << 16 | __th_dt_ts[5] << 8 | __th_dt_ts[6]\n                __th_mem32[0x4005c00c] |= 0x10\n                del __th_mem32\n            finally:\n                del __th_dt_ts\n                    \n        \"\"\"\n        ).format(\n            datetime_ts=(\n                now.tm_year,\n                now.tm_mon,\n                now.tm_mday,\n                now.tm_wday + 1,\n                now.tm_hour,\n                now.tm_min,\n                now.tm_sec,\n                0,\n            ),\n            init_ts=tuple(now)[:6] + (0, 0),\n        )\n\n        script = (\n            dedent(\n                \"\"\"\n            try:\n            %s\n                __thonny_helper.print_mgmt_value(True)\n            except Exception as e:\n                import sys\n                sys.print_exception(e)\n                __thonny_helper.print_mgmt_value(str(e))\n        \"\"\"\n            )\n            % indent(specific_script, \"    \")\n        )\n\n        val = self._evaluate(script)\n        if isinstance(val, str):\n            print(\"WARNING: Could not sync device's clock: \" + val)", "is_method": true, "class_name": "RaspberryPiPicoBackend", "function_description": "Sets the Raspberry Pi Pico's real-time clock to match the host computer's current time, ensuring device time synchronization for accurate timestamping and time-dependent operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_resolve_executable", "line_number": 71, "body": "def _resolve_executable(self, executable):\n        result = self._which(executable)\n        if result:\n            return result\n        else:\n            msg = \"Executable '%s' not found. Please check your configuration!\" % executable\n            if not executable.startswith(\"/\"):\n                msg += \" You may need to provide its absolute path.\"\n            raise ConnectionFailedException(msg)", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Private method in UnixMicroPythonBackend that locates the full path of a given executable or raises an error if it cannot be found, ensuring correct command execution configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_tweak_welcome_text", "line_number": 87, "body": "def _tweak_welcome_text(self, original: str) -> str:\n        return (\n            original.replace(\"Use Ctrl-D to exit, Ctrl-E for paste mode\\n\", \"\").strip()\n            + \" (\"\n            + self._interpreter\n            + \")\\n\"\n        )", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Private method in UnixMicroPythonBackend that customizes the welcome message by removing default exit instructions and appending the interpreter name for clearer user context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_get_custom_helpers", "line_number": 95, "body": "def _get_custom_helpers(self):\n        return textwrap.dedent(\n            \"\"\"\n            # https://github.com/pfalcon/pycopy-lib/blob/master/os/os/__init__.py\n            \n            import ffi\n            \n            libc = ffi.open(\n                \"libc.so.6\" if sys.platform == \"linux\" else \"libc.dylib\"\n            )\n            \n            @classmethod\n            def check_error(cls, ret):\n                if ret == -1:\n                    raise OSError(cls.os.errno())\n            \n            _getcwd = libc.func(\"s\", \"getcwd\", \"si\")\n            @classmethod\n            def getcwd(cls):\n                buf = bytearray(512)\n                return cls._getcwd(buf, 512)\n\n            _chdir = libc.func(\"i\", \"chdir\", \"s\")\n            @classmethod\n            def chdir(cls, dir):\n                r = cls._chdir(dir)\n                cls.check_error(r)\n            \n            _rmdir = libc.func(\"i\", \"rmdir\", \"s\")\n            @classmethod\n            def rmdir(cls, name):\n                e = cls._rmdir(name)\n                cls.check_error(e)                                    \n            \"\"\"\n        )", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Provides a predefined string of Python helper functions for filesystem operations using FFI with libc, enabling error-checked getcwd, chdir, and rmdir methods in a Unix MicroPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_process_until_initial_prompt", "line_number": 131, "body": "def _process_until_initial_prompt(self, clean):\n        # This will be called only when the interpreter gets run without script.\n        # (%Run script.py does not create a new instance of this class)\n        output = []\n\n        def collect_output(data, stream_name):\n            output.append(data)\n\n        self._report_time(\"befini\")\n        self._forward_output_until_active_prompt(collect_output, \"stdout\")\n        self._original_welcome_text = \"\".join(output).replace(\"\\r\\n\", \"\\n\")\n        self._welcome_text = self._tweak_welcome_text(self._original_welcome_text)\n        self._report_time(\"afini\")", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Collects and processes the interpreter's initial output until the active prompt appears, capturing and customizing the welcome message for the UnixMicroPythonBackend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_fetch_builtin_modules", "line_number": 145, "body": "def _fetch_builtin_modules(self):\n        return FALLBACK_BUILTIN_MODULES", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Returns a predefined list of built-in modules as a fallback reference for the backend environment. This supports module management when native module detection is unavailable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_execute_with_consumer", "line_number": 148, "body": "def _execute_with_consumer(\n        self, script: str, output_consumer: Callable[[str, str], None]\n    ) -> None:\n        \"\"\"Ensures prompt and submits the script.\n        Returns (out, value_repr, err) if there are no problems, ie. all parts of the\n        output are present and it reaches active prompt.\n        Otherwise raises ManagementError.\n\n        The execution may block. In this case the user should do something (eg. provide\n        required input or issue an interrupt). The UI should remind the interrupt in case\n        of Thonny commands.\n        \"\"\"\n        end_marker = \"#uIuIu\"\n        self._connection.write(PASTE_MODE_CMD)\n        self._connection.read_until(PASTE_MODE_LINE_PREFIX)\n        self._connection.write(script + end_marker)\n        self._connection.read_until(end_marker.encode(\"ascii\"))\n        self._connection.write(EOT)\n        self._connection.read_until(b\"\\n\")\n\n        out = self._connection.read_until(NORMAL_PROMPT)[: -len(NORMAL_PROMPT)]\n        output_consumer(self._decode(out), \"stdout\")", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Executes a Python script on a Unix MicroPython backend, processing its output through a provided consumer function. It manages script submission and output retrieval while handling blocking execution conditions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_forward_output_until_active_prompt", "line_number": 171, "body": "def _forward_output_until_active_prompt(\n        self, output_consumer: Callable[[str, str], None], stream_name=\"stdout\"\n    ):\n        INCREMENTAL_OUTPUT_BLOCK_CLOSERS = re.compile(\n            b\"|\".join(map(re.escape, [LF, NORMAL_PROMPT]))\n        )\n\n        pending = b\"\"\n        while True:\n            # There may be an input submission waiting\n            # and we can't progress without resolving it first\n            self._check_for_side_commands()\n\n            # Prefer whole lines, but allow also incremental output to single line\n            new_data = self._connection.soft_read_until(\n                INCREMENTAL_OUTPUT_BLOCK_CLOSERS, timeout=0.05\n            )\n            if not new_data:\n                continue\n\n            pending += new_data\n\n            if pending.endswith(LF):\n                output_consumer(self._decode(pending), stream_name)\n                pending = b\"\"\n\n            elif pending.endswith(NORMAL_PROMPT):\n                out = pending[: -len(NORMAL_PROMPT)]\n                output_consumer(self._decode(out), stream_name)\n                return NORMAL_PROMPT\n\n            elif ends_overlap(pending, NORMAL_PROMPT):\n                # Maybe we have a prefix of the prompt and the rest is still coming?\n                follow_up = self._connection.soft_read(1, timeout=0.1)\n                if not follow_up:\n                    # most likely not a Python prompt, let's forget about it\n                    output_consumer(self._decode(pending), stream_name)\n                    pending = b\"\"\n                else:\n                    # Let's withhold this for now\n                    pending += follow_up\n\n            else:\n                # No prompt in sight.\n                # Output and keep working.\n                output_consumer(self._decode(pending), stream_name)\n                pending = b\"\"", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Method of UnixMicroPythonBackend that processes incremental output from a connection, forwarding it to a consumer until an active prompt is detected, enabling synchronization with the device's command prompt for interactive communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_forward_unexpected_output", "line_number": 219, "body": "def _forward_unexpected_output(self, stream_name=\"stdout\"):\n        \"Invoked between commands\"\n        data = self._connection.read_all()\n        if data.endswith(NORMAL_PROMPT):\n            out = data[: -len(NORMAL_PROMPT)]\n        else:\n            out = data\n        self._send_output(self._decode(out), \"stdout\")", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Internal method of UnixMicroPythonBackend that captures and processes any unexpected output from the device stream, forwarding the cleaned output to the designated output handler."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_write", "line_number": 228, "body": "def _write(self, data):\n        self._connection.write(data)", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Private method in UnixMicroPythonBackend that sends raw data through an established connection, facilitating communication with a device or service."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_cmd_Run", "line_number": 231, "body": "def _cmd_Run(self, cmd):\n        self._connection.close()\n        self._report_time(\"befconn\")\n        args = cmd.args\n        if cmd.source and args[0] == \"-c\":\n            if len(args) > 1:\n                self._send_error_message(\n                    \"Warning: MicroPython doesn't allow program arguments (%s) together with '-c'\"\n                    % \" \".join(map(shlex.quote, args[1:]))\n                )\n            args = [\"-c\", cmd.source]\n\n        self._connection = self._create_connection(args)\n        self._report_time(\"afconn\")\n        self._forward_output_until_active_prompt(self._send_output, \"stdout\")\n        self._report_time(\"afforv\")\n        self.send_message(\n            BackendEvent(event_type=\"HideTrailingOutput\", text=self._original_welcome_text)\n        )\n        self._report_time(\"beffhelp\")\n        self._prepare_after_soft_reboot()\n        self._report_time(\"affhelp\")", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Core method of UnixMicroPythonBackend that executes a command by managing connection lifecycle, forwarding command output, and handling post-execution setup to ensure proper backend state and output delivery."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_cmd_execute_system_command", "line_number": 254, "body": "def _cmd_execute_system_command(self, cmd):\n        assert cmd.cmd_line.startswith(\"!\")\n        cmd_line = cmd.cmd_line[1:]\n        # \"or None\" in order to avoid MP repl to print its value\n        self._execute(\"__thonny_helper.os.system(%r) or None\" % cmd_line)", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Executes a system shell command prefixed with \"!\" within the UnixMicroPythonBackend environment, allowing running of external commands directly from the backend interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_cmd_get_fs_info", "line_number": 261, "body": "def _cmd_get_fs_info(self, cmd):\n        script = \"\"\"__thonny_helper.os.system(\"stat -f -c '%b %f %a %S' {path}\") or None\"\"\".format(\n            path=cmd.path\n        )\n        out, err = self._execute(script, capture_output=True)\n\n        try:\n            total, free, available, block_size = map(int, out.strip().split())\n            return {\n                \"total\": total * block_size,\n                \"free\": available * block_size,\n                \"used\": (total - free) * block_size,\n            }\n        except Exception:\n            raise ManagementError(script, out, err)", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Provides filesystem usage statistics for a given path, returning total, free, and used space in bytes; useful for monitoring storage on Unix MicroPython devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_is_connected", "line_number": 277, "body": "def _is_connected(self):\n        return not self._connection._error", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Checks the internal connection status by verifying if any errors exist, indicating whether the UnixMicroPythonBackend is currently connected."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_get_epoch_offset", "line_number": 280, "body": "def _get_epoch_offset(self) -> int:\n        try:\n            return super()._get_epoch_offset()\n        except NotImplementedError:\n            return 0", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Method in UnixMicroPythonBackend that attempts to retrieve the epoch offset from its superclass, defaulting to zero if the superclass does not implement the method. It provides a fallback mechanism for time epoch calculations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_resolve_unknown_epoch", "line_number": 286, "body": "def _resolve_unknown_epoch(self) -> int:\n        return 1970", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Returns the default epoch year used when an unknown or unspecified epoch time is encountered, serving as a fallback in time-related computations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_sync_time", "line_number": 289, "body": "def _sync_time(self):\n        self._show_error(\"WARNING: Automatic time synchronization by Thonny is not supported.\")", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "This method informs users that automatic time synchronization is unsupported in the UnixMicroPythonBackend, serving as a notification mechanism rather than performing time sync."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_get_utc_timetuple_from_device", "line_number": 292, "body": "def _get_utc_timetuple_from_device(self) -> Union[tuple, str]:\n        out, err = self._execute(\"__thonny_helper.os.system('date -u +%s')\", capture_output=True)\n        if err:\n            return err\n\n        if not out:\n            return \"Failed querying device's UTC time\"\n\n        try:\n            secs = int(out.splitlines()[0].strip())\n            return tuple(time.gmtime(secs))\n        except Exception as e:\n            return str(e)", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Utility method in UnixMicroPythonBackend that obtains the device's current UTC time as a structured time tuple, providing standardized time information for further processing or synchronization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_create_connection", "line_number": 308, "body": "def _create_connection(self, run_args=[]):\n        from thonny.plugins.micropython.subprocess_connection import SubprocessConnection\n\n        return SubprocessConnection(self._interpreter, [\"-i\"] + run_args)", "is_method": true, "class_name": "LocalUnixMicroPythonBackend", "function_description": "Creates and returns a subprocess-based connection to a local MicroPython interpreter, optionally using additional startup arguments. This enables communication with MicroPython for executing code or managing runtime interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_which", "line_number": 313, "body": "def _which(self, executable):\n        import shutil\n\n        return shutil.which(executable)", "is_method": true, "class_name": "LocalUnixMicroPythonBackend", "function_description": "Utility method in LocalUnixMicroPythonBackend that locates the full path of a given executable on the system, facilitating command availability checks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_cmd_cd", "line_number": 318, "body": "def _cmd_cd(self, cmd):\n        result = super()._cmd_cd(cmd)\n        os.chdir(self._cwd)\n        return result", "is_method": true, "class_name": "LocalUnixMicroPythonBackend", "function_description": "Utility method of LocalUnixMicroPythonBackend that changes directory based on a command and ensures the current working directory stays synchronized afterward. It supports consistent environment state management during command execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_get_sep", "line_number": 323, "body": "def _get_sep(self) -> str:\n        return os.path.sep", "is_method": true, "class_name": "LocalUnixMicroPythonBackend", "function_description": "Utility method of LocalUnixMicroPythonBackend that returns the system-specific path separator character, enabling consistent file path handling across different Unix-like environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_decode", "line_number": 326, "body": "def _decode(self, data: bytes) -> str:\n        return data.decode(errors=\"replace\")", "is_method": true, "class_name": "LocalUnixMicroPythonBackend", "function_description": "Private utility method of LocalUnixMicroPythonBackend that decodes byte data to string, replacing decoding errors to ensure robustness."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_which", "line_number": 337, "body": "def _which(self, executable):\n        cmd_str = \" \".join(map(shlex.quote, [\"which\", executable]))\n        _, stdout, _ = self._client.exec_command(cmd_str, bufsize=0, timeout=3, get_pty=False)\n        return stdout.readline().strip() or None", "is_method": true, "class_name": "SshUnixMicroPythonBackend", "function_description": "Utility method in SshUnixMicroPythonBackend that checks the presence and location of a given executable on a remote Unix system via SSH, assisting in verifying availability of required commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_create_connection", "line_number": 342, "body": "def _create_connection(self, run_args=[]):\n        # NB! It's connection to the micropython process, not to the host\n        from thonny.plugins.micropython.ssh_connection import SshProcessConnection\n\n        return SshProcessConnection(self._client, self._cwd, self._interpreter, [\"-i\"] + run_args)", "is_method": true, "class_name": "SshUnixMicroPythonBackend", "function_description": "Creates and returns an SSH connection to a MicroPython process with specified runtime arguments, facilitating remote interaction with the MicroPython interpreter environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_tweak_welcome_text", "line_number": 348, "body": "def _tweak_welcome_text(self, original):\n        return (\n            super()._tweak_welcome_text(original).strip()\n            + \"\\n\"\n            + self._user\n            + \"@\"\n            + self._host\n            + \"\\n\"\n        )", "is_method": true, "class_name": "SshUnixMicroPythonBackend", "function_description": "Private method in SshUnixMicroPythonBackend that customizes the welcome text by appending the user and host information, enhancing terminal session identification."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_get_sep", "line_number": 358, "body": "def _get_sep(self) -> str:\n        return \"/\"", "is_method": true, "class_name": "SshUnixMicroPythonBackend", "function_description": "Returns the file path separator used in the Unix-based MicroPython SSH backend, providing consistent path formatting across related operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_decode", "line_number": 361, "body": "def _decode(self, data: bytes) -> str:\n        return data.decode(ENCODING, errors=\"replace\")", "is_method": true, "class_name": "SshUnixMicroPythonBackend", "function_description": "Private method of SshUnixMicroPythonBackend that decodes byte data into a string using a specified encoding, handling errors by replacement."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "debug", "line_number": 168, "body": "def debug(*args, file=sys.stderr):\n    print(*args, file=file)", "is_method": false, "function_description": "Utility function that prints debug messages to a specified output stream, defaulting to standard error, facilitating flexible and convenient logging during development or troubleshooting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "write", "line_number": 82, "body": "def write(self, data):\n        size = self._serial.write(data)\n        # print(data.decode(), end=\"\")\n        assert size == len(data)\n        return len(data)", "is_method": true, "class_name": "SerialConnection", "function_description": "Core method of the SerialConnection class that writes data to the serial port and confirms the entire data was successfully sent, returning the number of bytes written."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "_listen_serial", "line_number": 88, "body": "def _listen_serial(self):\n        \"NB! works in background thread\"\n        try:\n            data = b\"\"\n            while not self._reader_stopped:\n                data += self._serial.read(1)  # To avoid busy loop\n                if len(data) == 0:\n                    self._error = \"EOF\"\n                    # print(\"LISTEN EOFFFFFFFFFF\")\n                    break\n                data += self._serial.read_all()\n\n                # don't publish incomplete utf-8 data\n                try:\n                    if self.unicode_guard:\n                        data.decode(\"utf-8\")  # testing if data decodes\n                    to_be_published = data\n                    data = b\"\"\n                except UnicodeDecodeError as e:\n                    if e.start == 0:\n                        # Invalid start byte, ie. we have missed first byte(s) of the codepoint.\n                        # No use of waiting, output everything\n                        to_be_published = data\n                        data = b\"\"\n                    else:\n                        to_be_published = data[: e.start]\n                        data = data[e.start :]\n\n                if to_be_published:\n                    self._make_output_available(to_be_published)\n\n        except Exception as e:\n            self._error = str(e)", "is_method": true, "class_name": "SerialConnection", "function_description": "Background thread method of SerialConnection that continuously reads and decodes incoming serial data, ensuring only complete UTF-8 sequences are processed and made available for further handling or output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "incoming_is_empty", "line_number": 122, "body": "def incoming_is_empty(self):\n        return self._serial.in_waiting == 0 and super().incoming_is_empty()", "is_method": true, "class_name": "SerialConnection", "function_description": "Checks if there is no incoming data waiting in the serial buffer and also confirms this with the parent class's status. It determines whether the serial connection currently has no pending inbound information to read."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "outgoing_is_empty", "line_number": 125, "body": "def outgoing_is_empty(self):\n        return self._serial.out_waiting == 0", "is_method": true, "class_name": "SerialConnection", "function_description": "Utility method of the SerialConnection class that checks if the outgoing serial buffer is empty, indicating readiness to send more data or that all data has been transmitted."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "reset_output_buffer", "line_number": 128, "body": "def reset_output_buffer(self):\n        self._serial.reset_output_buffer()", "is_method": true, "class_name": "SerialConnection", "function_description": "Utility method of the SerialConnection class that clears the serial port\u2019s output buffer, ensuring that any unsent data is discarded before new data transmission."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "close", "line_number": 131, "body": "def close(self):\n        if self._serial is not None:\n            try:\n                self._serial.cancel_read()\n                if self._reading_thread:\n                    self._reading_thread.join()\n            finally:\n                try:\n                    self._serial.close()\n                    self._serial = None\n                except Exception:\n                    logging.exception(\"Couldn't close serial\")", "is_method": true, "class_name": "SerialConnection", "function_description": "Closes the serial connection safely by stopping ongoing reads and terminating reading threads, ensuring proper resource cleanup and preventing further communication over the connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "_make_output_available", "line_number": 148, "body": "def _make_output_available(self, data, block=True):\n\n        # output prompts in parts\n        if FIRST_RAW_PROMPT in data or NORMAL_PROMPT in data:\n            if FIRST_RAW_PROMPT in data:\n                start = data.find(FIRST_RAW_PROMPT)\n                end = start + len(FIRST_RAW_PROMPT)\n            else:\n                start = data.find(NORMAL_PROMPT)\n                end = start + len(NORMAL_PROMPT)\n\n            super()._make_output_available(data[: start + 1], block=block)\n            time.sleep(0.1)\n            super()._make_output_available(data[start + 1 : end - 1], block=block)\n            time.sleep(0.1)\n            super()._make_output_available(data[end - 1 :], block=block)\n        else:\n            super()._make_output_available(data, block=block)", "is_method": true, "class_name": "DifficultSerialConnection", "function_description": "Internal method of DifficultSerialConnection that manages segmented output transmission by splitting specific prompts into parts with pauses, ensuring controlled and orderly data delivery over the connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "soft_read", "line_number": 30, "body": "def soft_read(self, size, timeout=1):\n        return self.read(size, timeout, True)", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Utility method in the MicroPythonConnection class that performs a non-blocking read operation with a specified timeout and size, facilitating efficient data retrieval without waiting indefinitely."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "read", "line_number": 33, "body": "def read(self, size, timeout=10, timeout_is_soft=False):\n        if timeout == 0:\n            if timeout_is_soft:\n                return b\"\"\n            else:\n                raise TimeoutError()\n\n        timer = TimeHelper(timeout)\n\n        while len(self._read_buffer) < size:\n            self._check_for_error()\n\n            try:\n                self._read_buffer.extend(self._read_queue.get(True, timer.time_left))\n            except queue.Empty:\n                if timeout_is_soft:\n                    return b\"\"\n                else:\n                    raise TimeoutError(\"Reaction timeout. Bytes read: %s\" % self._read_buffer)\n\n        try:\n            data = self._read_buffer[:size]\n            return data\n        finally:\n            del self._read_buffer[:size]", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Reads a specified number of bytes from an internal buffer within a configurable timeout, optionally returning partial data or raising a timeout error. It supports controlled reading with error checks, suitable for managing data streams in MicroPython communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "soft_read_until", "line_number": 59, "body": "def soft_read_until(self, terminator, timeout=1000000):\n        return self.read_until(terminator, timeout, timeout_is_soft=True)", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Utility method in MicroPythonConnection that reads data until a specified terminator or a soft timeout occurs, allowing flexible read operations with adjustable timing constraints."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "read_until", "line_number": 62, "body": "def read_until(self, terminator, timeout=1000000, timeout_is_soft=False):\n        timer = TimeHelper(timeout)\n\n        if isinstance(terminator, str):\n            terminator = re.compile(re.escape(terminator))\n\n        match = None\n        while True:\n            self._check_for_error()\n\n            match = re.search(terminator, self._read_buffer)\n            if match:\n                break\n\n            try:\n                data = self._read_queue.get(True, timer.time_left)\n                # print(\"RR\", repr(data), file=sys.stderr)\n                assert len(data) > 0\n                self._read_buffer.extend(data)\n            except queue.Empty:\n                if timeout_is_soft:\n                    break\n                else:\n                    raise TimeoutError(\"Reaction timeout. Bytes read: %s\" % self._read_buffer)\n\n        if match:\n            size = match.end()\n        else:\n            assert timeout_is_soft\n            size = len(self._read_buffer)\n\n        data = self._read_buffer[:size]\n        del self._read_buffer[:size]\n        return data", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Method of MicroPythonConnection that reads incoming data until a specified terminator pattern is found or a timeout occurs, supporting both strict and soft timeout behaviors for flexible data retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "_fetch_to_buffer", "line_number": 97, "body": "def _fetch_to_buffer(self):\n        while not self._read_queue.empty():\n            self._read_buffer.extend(self._read_queue.get(True))", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Internal method of MicroPythonConnection that transfers all available data from the read queue into a buffer for subsequent processing or consumption."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "peek_incoming", "line_number": 101, "body": "def peek_incoming(self):\n        self._fetch_to_buffer()\n        return self._read_buffer", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Utility method of MicroPythonConnection that fetches new incoming data and returns the current read buffer content without consuming it, enabling non-destructive inspection of received data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "read_all", "line_number": 105, "body": "def read_all(self, check_error=True):\n        self._fetch_to_buffer()\n\n        if len(self._read_buffer) == 0 and check_error:\n            self._check_for_error()\n\n        try:\n            return self._read_buffer\n        finally:\n            self._read_buffer = bytearray()", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Utility method of MicroPythonConnection that reads all available data from an internal buffer, optionally checking for errors, and then clears the buffer for subsequent reads."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "read_all_expected", "line_number": 116, "body": "def read_all_expected(self, expected, timeout=None):\n        actual = self.read(len(expected), timeout=timeout)\n        actual += self.read_all()\n        assert expected == actual, \"Expected %r, got %r\" % (expected, actual)", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Method of MicroPythonConnection that reads and verifies the exact expected byte sequence from the connection within an optional timeout, raising an assertion error if the received data does not match."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "_check_for_error", "line_number": 121, "body": "def _check_for_error(self):\n        if self._error is None:\n            return\n\n        raise ConnectionClosedException(self._error)", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Core utility method of MicroPythonConnection that checks for connection errors and raises an exception if any error has occurred, ensuring error states are properly handled during communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "unread", "line_number": 127, "body": "def unread(self, data):\n        if not data:\n            return\n\n        if isinstance(data, str):\n            data = data.encode(self.encoding)\n        elif isinstance(data, bytes):\n            data = bytearray(data)\n\n        self._read_buffer = data + self._read_buffer", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Adds given data back into the connection's read buffer to be read again, supporting both string and byte input formats for flexible data handling. This method enables reprocessing or pushing back of previously read data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "_log_data", "line_number": 141, "body": "def _log_data(self, data):\n        print(\n            data.decode(self.encoding, errors=\"replace\")\n            .replace(\"\\r\\n\", \"\\n\")\n            .replace(\"\\x01\", \"\u2460\")\n            .replace(\"\\x02\", \"\u2461\")\n            .replace(\"\\x03\", \"\u2462\")\n            .replace(\"\\x04\", \"\u2463\"),\n            end=\"\",\n        )", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Utility method in MicroPythonConnection that decodes and formats binary data for readable console output, replacing control characters with symbols to aid debugging and logging communication details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "_make_output_available", "line_number": 152, "body": "def _make_output_available(self, data, block=True):\n        # self._log_data(data)\n        if data:\n            self._read_queue.put(data, block=block)\n            self.num_bytes_received += len(data)", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Internal method of MicroPythonConnection that stores incoming data into a read queue and tracks the total number of bytes received, enabling buffered data handling for subsequent processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "incoming_is_empty", "line_number": 158, "body": "def incoming_is_empty(self):\n        return self._read_queue.empty() and len(self._read_buffer) == 0", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Utility method of MicroPythonConnection that checks if there is no incoming data waiting to be read, combining both queue and buffer states. It helps determine if the connection currently has no pending incoming input."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "outgoing_is_empty", "line_number": 161, "body": "def outgoing_is_empty(self):\n        return True", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Method of the MicroPythonConnection class indicating that there are no outgoing messages or data pending for transmission. It signals that the outgoing buffer or queue is empty."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "buffers_are_empty", "line_number": 164, "body": "def buffers_are_empty(self):\n        return self.incoming_is_empty() and self.outgoing_is_empty()", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Utility method in MicroPythonConnection that checks if both incoming and outgoing data buffers are empty, indicating no pending data for processing or transmission."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "reset_input_buffer", "line_number": 167, "body": "def reset_input_buffer(self):\n        return self.read_all()", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Clears the input buffer by reading and discarding all available data, ensuring no residual input remains. This facilitates clean communication resets within the MicroPythonConnection interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "set_unicode_guard", "line_number": 173, "body": "def set_unicode_guard(self, value):\n        self.unicode_guard = value", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Sets the unicode guard value for the MicroPythonConnection instance, likely controlling how Unicode data is handled during communication or processing. This function allows configuration of Unicode handling behavior within the connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "stop_reader", "line_number": 176, "body": "def stop_reader(self):\n        self._reader_stopped = True\n        self._read_queue = Queue()\n        self._read_buffer = bytearray()", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Stops the reader process by marking it as stopped and resetting the read queue and buffer, effectively halting any ongoing data reading operations. This method is useful for safely terminating read activities in MicroPythonConnection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "version", "line_number": 40, "body": "def version():\n    print(\"Python version 3.2 or above is required.\")\n    sys.exit(1)", "is_method": false, "function_description": "Terminates execution with a message indicating Python version 3.2 or above is required, enforcing a minimum Python version prerequisite."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "read_line", "line_number": 56, "body": "def read_line(sock):\n    ret = b\"\"\n    while True:\n        c = sock.recv(1)\n        if c == b\"\":\n            break\n        elif c == b\"\\n\":\n            ret += c\n            break\n        else:\n            ret += c\n    return ret", "is_method": false, "function_description": "Function that reads bytes from a socket until a newline or connection close occurs, returning the full line including the newline character. It facilitates line-by-line reading of data streams over network sockets."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "read_lines", "line_number": 71, "body": "def read_lines(sock):\n    s = b\"\"\n    while True:\n        s1 = read_line(sock)\n        s += s1\n        if s1 == b\"\\r\\n\" or s1 == b\"\":\n            break\n    return s", "is_method": false, "function_description": "Function that reads and concatenates lines from a socket until an empty line or line break is encountered, useful for processing stream-based protocols or reading segmented socket data blocks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "_makedirs", "line_number": 82, "body": "def _makedirs(name):\n    dirname = os.path.dirname(name)\n\n    def split_path(lst, path):\n        q = os.path.split(path)\n        if q[1] != \"\":\n            lst.append(q[1])\n            split_path(lst, q[0])\n\n    lst = []\n    split_path(lst, dirname)\n    lst.reverse()\n    mypath = os.path.abspath(\"/\")\n    for elem in lst:\n        mypath = os.path.join(mypath, elem)\n        if not os.path.exists(mypath):\n            try:\n                os.mkdir(mypath)\n            except OSError as e:\n                if e.args[0] != errno.EEXIST and e.args[0] != errno.EISDIR:\n                    raise", "is_method": false, "function_description": "Utility function that recursively creates all directories leading up to the specified path if they do not already exist."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "install_tar", "line_number": 105, "body": "def install_tar(f, prefix):\n    meta = {}\n    for info in f:\n        # print(info)\n        fname = info.name\n        try:\n            fname = fname[fname.index(\"/\") + 1 :]\n        except ValueError:\n            fname = \"\"\n\n        save = True\n        for p in (\"setup.\", \"PKG-INFO\", \"README\"):\n            # print(fname, p)\n            if fname.startswith(p) or \".egg-info\" in fname:\n                if fname.endswith(\"/requires.txt\"):\n                    meta[\"deps\"] = f.extractfile(info).read()\n                save = False\n                if debug:\n                    print(\"Skipping\", fname)\n                break\n\n        if save:\n            outfname = prefix + fname\n            if info.type != tarfile.DIRTYPE:\n                if debug:\n                    print(\"Extracting \" + outfname)\n                _makedirs(outfname)\n                subf = f.extractfile(info)\n                with open(outfname, \"wb\") as outf:\n                    outf.write(subf.read())\n    return meta", "is_method": false, "function_description": "Function that extracts files from a tar archive into a specified directory, skipping certain metadata files and collecting dependency information when available. It facilitates selective installation or unpacking of tar archive contents while gathering relevant metadata."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "url_open", "line_number": 141, "body": "def url_open(url):\n    global warn_ussl\n\n    if debug:\n        print(url)\n\n    proto, _, host, urlpath = url.split(\"/\", 3)\n    try:\n        ai = usocket.getaddrinfo(host, 443)\n    except OSError as e:\n        print(\"Unable to resolve %s (no Internet?)\" % host)\n        raise\n    addr = ai[0][4]\n    s = usocket.socket(ai[0][0])\n    try:\n        if proto == \"https:\":\n            s = ussl.wrap_socket(s)\n            if warn_ussl:\n                print(\"Warning: %s SSL certificate is not validated\" % host)\n                warn_ussl = False\n        s.connect(addr)\n        s.setblocking(True)\n\n        s.send((\"GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n\" % (urlpath, host)).encode(\"UTF8\"))\n        l = read_line(s)\n        protover, status, msg = l.split(None, 2)\n        if status != b\"200\":\n            if status == b\"404\" or status == b\"301\":\n                raise NotFoundError(\"Package not found\")\n            raise ValueError(status)\n        while 1:\n            l = read_line(s)\n            if not l:\n                raise ValueError(\"Unexpected EOF in HTTP headers\")\n            if l == b\"\\r\\n\":\n                break\n    except Exception as e:\n        s.close()\n        raise e\n\n    return s", "is_method": false, "function_description": "Function that opens an HTTPS connection to a given URL, sends a GET request, and returns the connected socket for reading the response body. It handles DNS resolution, SSL wrapping without certificate validation, and basic HTTP error status checks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "get_pkg_metadata", "line_number": 185, "body": "def get_pkg_metadata(pkg_spec):\n    if \"==\" in pkg_spec:\n        name, ver = pkg_spec.split(\"==\", maxsplit=1)\n        f = url_open(\"https://pypi.org/pypi/%s/%s/json\" % (name, ver))\n    else:\n        try:\n            f = url_open(MICROPYTHON_ORG_JSON % pkg_spec)\n        except:\n            f = url_open(\"https://pypi.org/pypi/%s/json\" % pkg_spec)\n    s = read_lines(f)\n    try:\n        return json.loads(s.decode(\"UTF8\"))\n    finally:\n        f.close()", "is_method": false, "function_description": "Function that fetches and returns metadata for a specified Python package from PyPI or MicroPython sources, supporting exact version queries and defaulting to the latest metadata if no version is specified."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "fatal", "line_number": 201, "body": "def fatal(msg):\n    print(\"Error:\", msg)\n    sys.exit(1)", "is_method": false, "function_description": "Function that prints an error message and terminates the program immediately, providing a standard way to handle fatal errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "install_pkg", "line_number": 206, "body": "def install_pkg(pkg_spec, install_path):\n    data = get_pkg_metadata(pkg_spec)\n\n    latest_ver = data[\"info\"][\"version\"]\n    packages = data[\"releases\"][latest_ver]\n    assert len(packages) == 1, \"This doesn't look like MicroPython package\"\n    package_url = packages[0][\"url\"]\n    print(\"Installing %s %s from %s\" % (pkg_spec, latest_ver, package_url))\n    f1 = url_open(package_url)\n    s = read_lines(f1)\n    try:\n        str1 = zlib.decompress(s, gzdict_sz)\n        with tempfile.TemporaryFile() as temp_file:\n            temp_file.write(str1)\n            temp_file.seek(0)\n            with tarfile.TarFile(fileobj=temp_file) as tar_file:  # Expects a file object\n                meta = install_tar(tar_file, install_path)\n    finally:\n        f1.close()\n    return meta", "is_method": false, "function_description": "Installs a MicroPython package specified by pkg_spec into a given install_path by downloading, decompressing, and extracting the package archive. Returns metadata about the installed package."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "install", "line_number": 228, "body": "def install(to_install):\n    install_path = g_install_path\n    install_path = os.path.join(install_path, \"\")  # Append final /\n    if not isinstance(to_install, list):\n        to_install = [to_install]\n    print(\"Installing to: \" + install_path)\n    # sets would be perfect here, but don't depend on them\n    installed = []\n    try:\n        while to_install:\n            if debug:\n                print(\"Queue:\", to_install)\n            pkg_spec = to_install.pop(0)\n            if pkg_spec in installed:\n                continue\n            meta = install_pkg(pkg_spec, install_path)\n            installed.append(pkg_spec)\n            if debug:\n                print(meta)\n            deps = meta.get(\"deps\", \"\").rstrip()\n            if deps:\n                deps = deps.decode(\"utf-8\").split(\"\\n\")\n                to_install.extend(deps)\n        return True\n    except Exception as e:\n        print(\n            \"Error installing '{}': {}\".format(pkg_spec, e),\n            file=sys.stderr,\n        )\n        return False", "is_method": false, "function_description": "Function that installs one or multiple packages and their dependencies to a specified path, handling recursive dependency resolution to ensure all required packages are installed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "help_msg", "line_number": 260, "body": "def help_msg():\n    print(\n        \"\"\"\\\nmicropip - Simple PyPI package manager for MicroPython\nRuns on a PC under Python 3.2 or above, and installs to a PC directory for\nsubsequent transfer to target hardware.\n\nUsage: micropip.py install [-p <path>] <package>... | -r <requirements.txt>\nThe above requires micropip.py to have executable permission.\nAlternatively: python3 -m micropip install [-p <path>] <package>... | -r <requirements.txt>\n\nIf <path> is not given, packages will be installed into the current directory.\n\nNote: only MicroPython packages (usually, named micropython-*) are supported\nfor installation, upip does not support arbitrary code in setup.py.\n\"\"\"\n    )", "is_method": false, "function_description": "Function that prints usage instructions and general information about the micropip package manager for MicroPython. It serves as a help guide for users to understand command usage and installation options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "main", "line_number": 279, "body": "def main():\n    global debug\n    global g_install_path\n\n    if len(sys.argv) < 2 or sys.argv[1] == \"-h\" or sys.argv[1] == \"--help\":\n        help_msg()\n        return\n\n    if sys.argv[1] != \"install\":\n        fatal(\"Only 'install' command supported\")\n\n    to_install = []\n\n    i = 2\n    while i < len(sys.argv) and sys.argv[i][0] == \"-\":\n        opt = sys.argv[i]\n        i += 1\n        if opt == \"-h\" or opt == \"--help\":\n            help_msg()\n            return\n        elif opt == \"-p\":\n            g_install_path = sys.argv[i]\n            i += 1\n        elif opt == \"-r\":\n            list_file = sys.argv[i]\n            i += 1\n            with open(list_file) as f:\n                while True:\n                    l = f.readline()\n                    if not l:\n                        break\n                    if l[0] == \"#\":\n                        continue\n                    to_install.append(l.rstrip())\n        elif opt == \"--debug\":\n            debug = True\n        else:\n            fatal(\"Unknown/unsupported option: \" + opt)\n\n    to_install.extend(sys.argv[i:])\n    if not to_install:\n        help_msg()\n        return\n\n    g_install_path = os.path.expanduser(g_install_path)\n    g_install_path = os.path.abspath(g_install_path)\n    if not install(to_install):\n        sys.exit(1)", "is_method": false, "function_description": "Main entry point that processes command-line arguments to support an \"install\" command with options for specifying install path, debug mode, and package lists, then initiates installation of specified items accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "split_path", "line_number": 85, "body": "def split_path(lst, path):\n        q = os.path.split(path)\n        if q[1] != \"\":\n            lst.append(q[1])\n            split_path(lst, q[0])", "is_method": false, "function_description": "Recursively extracts and appends each component of a filesystem path to a list, breaking down the path from its basename up to the root. Useful for path decomposition and analysis tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "populate_main_frame", "line_number": 38, "body": "def populate_main_frame(self):\n        pad = self.get_padding()\n        inpad = self.get_internal_padding()\n\n        latest_ver_caption = tr(\"Version to be installed\")\n        version_caption_label = ttk.Label(self.main_frame, text=latest_ver_caption + \":\")\n        version_caption_label.grid(\n            row=0, column=0, sticky=\"w\", padx=(pad, inpad), pady=(pad, inpad)\n        )\n        self._version_label = ttk.Label(self.main_frame, text=tr(\"please wait\") + \" ...\")\n        self._version_label.grid(row=0, column=1, padx=(0, pad), pady=(pad, inpad), sticky=\"w\")\n\n        device_location_caption = tr(\"Target device location\")\n        self.target_caption_label = ttk.Label(self.main_frame, text=device_location_caption + \":\")\n        self.target_caption_label.grid(\n            row=1, column=0, padx=(pad, inpad), pady=(0, inpad), sticky=\"w\"\n        )\n\n        # add width, so that this label prescribes the width of the dialog and it doesn't grow\n        # when the progressbar and action text are gridded\n        self.target_label = ttk.Label(self.main_frame, text=\"\", width=self.get_info_text_width())\n        self.target_label.grid(row=1, column=1, padx=(0, pad), pady=(0, inpad), sticky=\"w\")\n\n        device_model_caption = tr(\"Target device model\")\n        self.model_caption_label = ttk.Label(self.main_frame, text=device_model_caption + \":\")\n        self.model_caption_label.grid(\n            row=2, column=0, padx=(pad, inpad), pady=(0, inpad), sticky=\"w\"\n        )\n        self.model_label = ttk.Label(self.main_frame, text=\"\", width=self.get_info_text_width())\n        self.model_label.grid(row=2, column=1, padx=(0, pad), pady=(0, inpad), sticky=\"w\")\n\n        # Resize progress bar to align with this grid\n        default_font = tkfont.nametofont(\"TkDefaultFont\")\n        max_caption_len = max(\n            [\n                default_font.measure(caption + \":\")\n                for caption in [latest_ver_caption, device_location_caption, device_model_caption]\n            ]\n        )\n        self._progress_bar[\"length\"] = max_caption_len", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Sets up and arranges labeled UI elements in the main frame of the Uf2FlashingDialog, displaying device version, location, model info, and aligning the progress bar size for consistent dialog layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_info_text_width", "line_number": 79, "body": "def get_info_text_width(self):\n        return 40", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Utility method of the Uf2FlashingDialog class that returns a fixed width value for displaying informational text. It standardizes the text display layout in the dialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_action_text_max_length", "line_number": 82, "body": "def get_action_text_max_length(self):\n        return 20", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Returns the maximum allowed length for action text in the Uf2FlashingDialog, ensuring UI elements maintain consistent sizing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_instructions", "line_number": 85, "body": "def get_instructions(self) -> Optional[str]:\n        return (\n            \"This dialog allows you to install or update MicroPython on your device.\\n\"\n            \"\\n\"\n            \"1. Put your device into bootloader mode.\\n\"\n            \"2. Wait until device information appears.\\n\"\n            \"3. Click 'Install' and wait for some seconds until done.\\n\"\n            \"4. Close the dialog and start programming!\"\n        )", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Provides user instructions for installing or updating MicroPython on a device within the Uf2FlashingDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_ok_text", "line_number": 95, "body": "def get_ok_text(self):\n        return tr(\"Install\")", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Returns the localized label text \"Install\" for the confirmation button in the Uf2FlashingDialog user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_start_downloading_release_info", "line_number": 101, "body": "def _start_downloading_release_info(self):\n        self._release_info = None  # invalidate last info if downloading again\n        threading.Thread(target=self._download_release_info, daemon=True).start()", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Internal method of Uf2FlashingDialog that asynchronously initiates downloading of release information by starting a background thread, ensuring the latest release data is fetched without blocking the main execution flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_download_release_info", "line_number": 105, "body": "def _download_release_info(self):\n        import json\n        from urllib.request import urlopen\n\n        try:\n            req = urllib.request.Request(\n                self._get_release_info_url(),\n                data=None,\n                headers={\n                    \"User-Agent\": FAKE_USER_AGENT,\n                    \"Cache-Control\": \"no-cache\",\n                },\n            )\n            with urlopen(req) as fp:\n                json_str = fp.read().decode(\"UTF-8\")\n                logger.debug(\"Release info: %r\", json_str)\n                self._release_info = json.loads(json_str)\n                if self._release_info.get(\"message\", \"\") == \"Not Found\":\n                    self._release_info = None\n        except Exception as e:\n            self.append_text(\"Could not find release info from %s\\n\" % self._get_release_info_url())\n            self.set_action_text(\"Error!\")\n            self.grid_progress_widgets()", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Downloads and parses release information from a remote URL, updating the dialog with an error message if retrieving the data fails. It supports obtaining release metadata for flashing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "update_ui", "line_number": 129, "body": "def update_ui(self):\n        if self._state == \"idle\":\n            self._possible_targets = self.get_possible_targets()\n            if not self._possible_targets:\n                set_text_if_different(self.target_label, \"\")\n                set_text_if_different(self.model_label, \"\")\n            else:\n                unpacked = list(zip(*self._possible_targets))\n                set_text_if_different(self.target_label, \"\\n\".join(unpacked[0]))\n                model_changed = set_text_if_different(self.model_label, \"\\n\".join(unpacked[2]))\n\n            desc = self.get_firmware_description()\n            if desc is None:\n                set_text_if_different(self._version_label, self.get_unknown_version_text())\n            else:\n                set_text_if_different(self._version_label, desc)\n\n        super(Uf2FlashingDialog, self).update_ui()", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Updates the UI of Uf2FlashingDialog based on current device state and available targets, showing relevant labels and firmware descriptions. It ensures the interface reflects the latest flashing options and version info during idle state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_unknown_version_text", "line_number": 148, "body": "def get_unknown_version_text(self):\n        return tr(\"Please wait\") + \"...\"", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Returns a user-friendly message indicating that the system is processing an unknown firmware version, typically displayed while waiting for further information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_firmware_description", "line_number": 154, "body": "def get_firmware_description(self):\n        if self._release_info is None:\n            return None\n        else:\n            return (\n                self._release_info[\"tag_name\"]\n                + \" (\"\n                + self._release_info[\"published_at\"][:10]\n                + \")\"\n            )", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Returns a descriptive string of the firmware's release tag and publication date, or None if release information is unavailable, providing an easy way to display firmware version details in the Uf2FlashingDialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_download_url_and_size", "line_number": 165, "body": "def get_download_url_and_size(self, board_id):\n        if self._release_info is None:\n            return None\n\n        candidates = [\n            asset\n            for asset in self._release_info[\"assets\"]\n            if self._is_suitable_asset(asset, board_id)\n        ]\n\n        logger.info(\n            \"Assets from %s: %r\", self._get_release_info_url(), self._release_info[\"assets\"]\n        )\n        if len(candidates) == 0:\n            raise RuntimeError(\n                \"Could not find the right file from the release info (%s)\"\n                % self._get_release_info_url()\n            )\n        elif len(candidates) > 1:\n            raise RuntimeError(\n                \"Found several possible files from the release info (%s)\"\n                % self._get_release_info_url()\n            )\n        else:\n            return (candidates[0][\"browser_download_url\"], candidates[0][\"size\"])", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Method of Uf2FlashingDialog that identifies and returns the download URL and file size of the appropriate firmware asset for a given board from release information, ensuring exactly one suitable file is found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "is_ready_for_work", "line_number": 194, "body": "def is_ready_for_work(self):\n        # Called after update_ui\n        return self._possible_targets and self._release_info", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Checks if the Uf2FlashingDialog instance has selectable targets and release information, indicating readiness to proceed with flashing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_possible_targets", "line_number": 199, "body": "def get_possible_targets(cls):\n        all_vol_infos = [\n            (vol, cls.find_device_board_id_and_model(vol))\n            for vol in list_volumes(skip_letters=[\"A\"])\n        ]\n\n        return [(info[0], info[1][0], info[1][1]) for info in all_vol_infos if info[1] is not None]", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Utility method in Uf2FlashingDialog that identifies and returns all available target devices by detecting their board IDs and models from connected volumes, excluding those with specified drive letters."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "start_work", "line_number": 207, "body": "def start_work(self):\n        if len(self._possible_targets) > 1:\n            # size 0 is checked elsewhere\n            messagebox.showerror(\n                \"Can't proceed\",\n                \"You seem to have plugged in %d compatible devices.\\n\"\n                + \"Please leave only one and unplug the others!\",\n                parent=self,\n            )\n            return False\n\n        target_dir, board_id, _ = self._possible_targets[0]\n\n        try:\n            download_url, size = self.get_download_url_and_size(board_id)\n        except Exception as e:\n            logger.error(\"Could not determine download url\", exc_info=e)\n            messagebox.showerror(\"Could not determine download url\", str(e), parent=self)\n            return False\n\n        self.report_progress(0, size)\n        proxy = get_runner().get_backend_proxy()\n        if isinstance(proxy, BareMetalMicroPythonProxy):\n            proxy.disconnect()\n\n        threading.Thread(\n            target=self._perform_work, args=[download_url, size, target_dir], daemon=True\n        ).start()\n        return True", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Initiates the flashing process for a single connected compatible device by validating device count, obtaining firmware download details, handling errors, and starting the flashing operation asynchronously."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "find_device_board_id_and_model", "line_number": 238, "body": "def find_device_board_id_and_model(cls, mount_path):\n        info_path = os.path.join(mount_path, \"INFO_UF2.TXT\")\n        if not os.path.isfile(info_path):\n            return None\n\n        board_id = None\n        model = None\n        with open(info_path, \"r\", encoding=\"UTF-8\", errors=\"replace\") as fp:\n            for line in fp:\n                parts = list(map(str.strip, line.split(\":\", maxsplit=1)))\n                if len(parts) == 2:\n                    if parts[0] == \"Model\":\n                        model = parts[1]\n                    elif parts[0] == \"Board-ID\":\n                        board_id = parts[1]\n                        if not cls._is_relevant_board_id(board_id):\n                            return None\n\n                    if board_id and model:\n                        return board_id, model\n\n        return None", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Method of Uf2FlashingDialog that identifies and returns the board ID and model name from a device's UF2 info file if the board ID is relevant. It aids in recognizing connected devices for flashing or interaction purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_is_relevant_board_id", "line_number": 262, "body": "def _is_relevant_board_id(cls, board_id):\n        return True", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Always returns True, indicating all board IDs are considered relevant. This method likely serves as a placeholder or default filter in the Uf2FlashingDialog class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_get_vid_pids_to_wait_for", "line_number": 265, "body": "def _get_vid_pids_to_wait_for(self):\n        \"\"\"If result is non-empty then the process completes until a device with one of the vid-pid pairs appears\"\"\"\n        return set()", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Returns an empty set indicating no specific USB vendor-product IDs are awaited for device connection completion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_perform_work", "line_number": 269, "body": "def _perform_work(self, download_url, size, target_dir):\n        try:\n            self._download_to_the_device(download_url, size, target_dir)\n            if self._state == \"working\" and self._get_vid_pids_to_wait_for():\n                self._wait_for_vid_pids()\n        except Exception as e:\n            self.append_text(\"\\n\" + \"\".join(traceback.format_exc()))\n            self.set_action_text(\"Error...\")\n            self.report_done(False)\n            return\n\n        if self._state == \"working\":\n            self.append_text(\"\\nDone!\\n\")\n            self.set_action_text(\"Done!\")\n            self.report_done(True)\n        else:\n            assert self._state == \"cancelling\"\n            self.append_text(\"\\nCancelled\\n\")\n            self.set_action_text(\"Cancelled\")\n            self.report_done(False)", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Core method of Uf2FlashingDialog that manages the downloading process to a device, monitors its state, and reports completion, errors, or cancellation status accordingly during the flashing operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_wait_for_vid_pids", "line_number": 290, "body": "def _wait_for_vid_pids(self):\n        target_set = set(self._get_vid_pids_to_wait_for())\n        if not target_set:\n            return\n\n        self.append_text(\"\\nWaiting for the port...\\n\")\n        self.set_action_text(\"Waiting for the port...\")\n\n        wait_time = 0\n        step = 0.2\n        while wait_time < 10:\n            for p in list_serial_ports():\n                vidpid = (p.vid, p.pid)\n                if vidpid in target_set or (p.vid, None) in target_set:\n                    self.append_text(\"Found %s at %s\\n\" % (\"%04x:%04x\" % vidpid, p.device))\n                    self.set_action_text(\"Found port\")\n                    return\n            if self._state == \"cancelling\":\n                return\n            time.sleep(step)\n            wait_time += step\n        else:\n            self.set_action_text(\"Warning: Could not find port\")\n            self.append_text(\"Warning: Could not find port in %s seconds\\n\" % int(wait_time))\n            # leave some time to see the warning\n            time.sleep(2)", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Core method of Uf2FlashingDialog that waits up to 10 seconds for a USB device with specific vendor/product IDs to appear, updating the interface status and handling cancellation or timeout events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_download_to_the_device", "line_number": 317, "body": "def _download_to_the_device(self, download_url, size, target_dir):\n        \"\"\"Running in a bg thread\"\"\"\n        target_path = os.path.join(target_dir, self.get_target_filename())\n        logger.debug(\"Downloading %d bytes from %s to %s\", size, download_url, target_path)\n\n        self.set_action_text(\"Starting...\")\n        self.append_text(\"Downloading %d bytes from %s\\n\" % (size, download_url))\n\n        req = urllib.request.Request(\n            download_url,\n            data=None,\n            headers={\n                \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.47 Safari/537.36\"\n            },\n        )\n\n        with urlopen(req, timeout=5) as fsrc:\n            bytes_copied = 0\n            self.append_text(\"Writing to %s\\n\" % target_path)\n            self.append_text(\"Starting...\")\n            if fsrc.length:\n                # override (possibly inaccurate) size\n                size = fsrc.length\n\n            block_size = 8 * 1024\n            with open(target_path, \"wb\") as fdst:\n                while True:\n\n                    block = fsrc.read(block_size)\n                    if not block:\n                        break\n\n                    if self._state == \"cancelling\":\n                        break\n\n                    fdst.write(block)\n                    fdst.flush()\n                    os.fsync(fdst.fileno())\n                    bytes_copied += len(block)\n                    percent_str = \"%.0f%%\" % (bytes_copied / size * 100)\n                    self.set_action_text(\"Copying... \" + percent_str)\n                    self.report_progress(bytes_copied, size)\n                    self.replace_last_line(percent_str)", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Downloads a file from a given URL to a specified directory while providing progress updates and supporting cancellation, facilitating background flashing operations on a device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_target_filename", "line_number": 361, "body": "def get_target_filename(self):\n        return \"firmware\"", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Returns the default target filename used in the flashing process, typically representing the firmware file to be written. This provides a consistent reference name for firmware flashing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_title", "line_number": 364, "body": "def get_title(self):\n        return \"Install MicroPython firmware\"", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Returns the fixed title string for the firmware installation dialog. Used to display the dialog's heading in the Uf2FlashingDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "list_serial_ports", "line_number": 874, "body": "def list_serial_ports():\n    # serial.tools.list_ports.comports() can be too slow\n    # because os.path.islink can be too slow (https://github.com/pyserial/pyserial/pull/303)\n    # Workarond: temporally patch os.path.islink\n    import serial.tools.list_ports\n\n    try:\n        old_islink = os.path.islink\n        if platform.system() == \"Windows\":\n            os.path.islink = lambda _: False\n        return list(serial.tools.list_ports.comports())\n    finally:\n        os.path.islink = old_islink", "is_method": false, "function_description": "Function that lists available serial ports on the system, implementing a platform-specific workaround to improve performance during port enumeration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "port_exists", "line_number": 889, "body": "def port_exists(device):\n    for port in list_serial_ports():\n        if port.device == device:\n            return True\n\n    return False", "is_method": false, "function_description": "Checks whether a specified serial port device is available among the system's current serial ports. This function is useful for validating device connectivity before attempting communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "list_serial_ports_with_descriptions", "line_number": 897, "body": "def list_serial_ports_with_descriptions():\n    def port_order(p):\n        name = p.device\n        if name is None:\n            return \"\"\n        elif name.startswith(\"COM\") and len(name) == 4:\n            # Make one-digit COM ports go before COM10\n            return name.replace(\"COM\", \"COM0\")\n        else:\n            return name\n\n    sorted_ports = sorted(list_serial_ports(), key=port_order)\n\n    return [\n        (\n            p.description if p.device in p.description else p.description + \" (\" + p.device + \")\",\n            p.device,\n        )\n        for p in sorted_ports\n    ]", "is_method": false, "function_description": "Function that lists available serial ports with user-friendly descriptions, sorting ports to prioritize single-digit COM ports before others. Useful for applications needing an organized display of serial communication interfaces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_port_info", "line_number": 919, "body": "def get_port_info(port):\n    for info in list_serial_ports():\n        if info.device == port:\n            return info\n    raise RuntimeError(\"Port %s not found\" % port)", "is_method": false, "function_description": "Function that fetches detailed information about a specified serial port from the available system ports and raises an error if the port is not found. It enables users to verify and access port-specific metadata for communication setup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "add_micropython_backend", "line_number": 926, "body": "def add_micropython_backend(\n    name,\n    proxy_class,\n    description,\n    config_page,\n    bare_metal=True,\n    sort_key=None,\n    validate_time=True,\n    sync_time=None,\n    utc_clock=False,\n    write_block_size=None,\n    write_block_delay=None,\n    dtr=None,\n    rts=None,\n):\n    if bare_metal:\n        get_workbench().set_default(name + \".port\", \"auto\")\n        get_workbench().set_default(name + \".webrepl_url\", DEFAULT_WEBREPL_URL)\n        get_workbench().set_default(name + \".webrepl_password\", \"\")\n        get_workbench().set_default(name + \".write_block_size\", write_block_size)\n        # write_block_delay is used only with \"raw\" submit_mode\n        get_workbench().set_default(name + \".write_block_delay\", write_block_delay)\n        get_workbench().set_default(name + \".used_vidpids\", set())\n        get_workbench().set_default(name + \".dtr\", dtr)\n        get_workbench().set_default(name + \".rts\", rts)\n        get_workbench().set_default(name + \".submit_mode\", None)\n\n        if sync_time is None:\n            sync_time = True\n    else:\n        if sync_time is None:\n            sync_time = False\n\n    get_workbench().set_default(name + \".sync_time\", sync_time)\n    get_workbench().set_default(name + \".utc_clock\", utc_clock)\n    get_workbench().set_default(name + \".validate_time\", validate_time)\n    get_workbench().add_backend(name, proxy_class, description, config_page, sort_key=sort_key)", "is_method": false, "function_description": "Function that registers and configures a Micropython backend with customizable hardware and synchronization settings, integrating it into the workbench environment for device management and interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "load_plugin", "line_number": 965, "body": "def load_plugin():\n    add_micropython_backend(\n        \"GenericMicroPython\",\n        GenericBareMetalMicroPythonProxy,\n        tr(\"MicroPython (generic)\"),\n        GenericBareMetalMicroPythonConfigPage,\n        sort_key=\"49\",\n    )\n\n    if platform.system() in (\"Linux\", \"Darwin\"):\n        add_micropython_backend(\n            \"LocalMicroPython\",\n            LocalMicroPythonProxy,\n            tr(\"MicroPython (local)\"),\n            LocalMicroPythonConfigPage,\n            bare_metal=False,\n            sort_key=\"21\",\n        )\n        get_workbench().set_default(\"LocalMicroPython.executable\", \"micropython\")\n\n    add_micropython_backend(\n        \"SshMicroPython\",\n        SshMicroPythonProxy,\n        tr(\"MicroPython (SSH)\"),\n        SshMicroPythonConfigPage,\n        bare_metal=False,\n        sort_key=\"22\",\n    )\n    get_workbench().set_default(\"SshMicroPython.executable\", \"micropython\")\n    get_workbench().set_default(\"SshMicroPython.cwd\", None)\n    get_workbench().set_default(\"SshMicroPython.host\", \"\")\n    get_workbench().set_default(\"SshMicroPython.user\", \"\")\n    get_workbench().set_default(\"SshMicroPython.auth_method\", \"password\")", "is_method": false, "function_description": "Function that registers multiple MicroPython backends and configures default settings based on the operating system, enabling support for different MicroPython environments in a development workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_pip_gui_class", "line_number": 41, "body": "def get_pip_gui_class(self):\n        from thonny.plugins.micropython.pip_gui import MicroPythonPipDialog\n\n        return MicroPythonPipDialog", "is_method": true, "class_name": "MicroPythonProxy", "function_description": "Returns the MicroPythonPipDialog class, providing access to the GUI component for managing MicroPython package installations within the Thonny environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_pip_target_dir", "line_number": 46, "body": "def get_pip_target_dir(self) -> Optional[str]:\n\n        lib_dirs = self.get_lib_dirs()\n        if not lib_dirs:\n            return None\n\n        for path in lib_dirs:\n            if path.startswith(\"/home/\"):\n                return path\n\n        for path in [\"/lib\", \"/flash/lib\"]:\n            if path in lib_dirs:\n                return path\n\n        return lib_dirs[0]", "is_method": true, "class_name": "MicroPythonProxy", "function_description": "Returns the most suitable directory path for installing Python packages in the MicroPython environment based on predefined priority rules. This helps determine where pip should target installations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_lib_dirs", "line_number": 62, "body": "def get_lib_dirs(self):\n        return self._lib_dirs", "is_method": true, "class_name": "MicroPythonProxy", "function_description": "Returns the list of library directories configured in the MicroPythonProxy instance, providing access to its library paths. This is useful for components needing to reference or verify available libraries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_store_state_info", "line_number": 65, "body": "def _store_state_info(self, msg):\n        super(MicroPythonProxy, self)._store_state_info(msg)\n        if \"lib_dirs\" in msg:\n            self._lib_dirs = msg[\"lib_dirs\"]", "is_method": true, "class_name": "MicroPythonProxy", "function_description": "Stores state information from a message and updates the internal list of library directories if provided. This supports maintaining runtime environment details within the MicroPythonProxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_time_args", "line_number": 70, "body": "def _get_time_args(self):\n        result = {\n            \"sync_time\": get_workbench().get_option(self.backend_name + \".sync_time\", False),\n            \"validate_time\": get_workbench().get_option(\n                self.backend_name + \".validate_time\", False\n            ),\n            \"utc_clock\": get_workbench().get_option(self.backend_name + \".utc_clock\", False),\n        }\n        return result", "is_method": true, "class_name": "MicroPythonProxy", "function_description": "Returns a dictionary of time-related configuration options specific to the backend, supporting synchronization, validation, and UTC clock settings. This enables consistent access to time settings for backend operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_fix_port", "line_number": 94, "body": "def _fix_port(self):\n        if self._port == \"webrepl\":\n            return\n\n        elif self._port == \"auto\":\n            potential = self._detect_potential_ports()\n            if len(potential) == 1:\n                self._port = potential[0][0]\n            else:\n                if not potential and self.device_is_present_in_bootloader_mode():\n                    if self._propose_install_firmware():\n                        print(\"POSITIVE\")\n                        return self._fix_port()\n\n                self._port = None\n                message = dedent(\n                    \"\"\"\\\n                    Couldn't find the device automatically. \n                    Check the connection (making sure the device is not in bootloader mode) or choose\n                    \"Configure interpreter\" in the interpreter menu (bottom-right corner of the window)\n                    to select specific port or another interpreter.\"\"\"\n                )\n\n                if len(potential) > 1:\n                    _, descriptions = zip(*potential)\n                    message += \"\\n\\nLikely candidates are:\\n * \" + \"\\n * \".join(descriptions)\n\n                self._show_error(message)\n        elif not port_exists(self._port):\n            if self.device_is_present_in_bootloader_mode():\n                self._port = None\n                self._propose_install_firmware()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Utility method in BareMetalMicroPythonProxy that determines and sets the correct communication port automatically or prompts user action when the device is not detected or in bootloader mode."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_propose_install_firmware", "line_number": 127, "body": "def _propose_install_firmware(self):\n        \"\"\"Subclass may show firmware installation dialog and return True if installation succeeds\"\"\"\n        self._show_error(\n            \"Your device seems to be in bootloader mode.\\n\"\n            \"In this mode you can install or upgrade MicroPython firmware.\\n\\n\"\n            \"If your device already has MicroPython, then you can start using it after you put it into normal mode.\"\n        )\n\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "This method notifies the user that the device is in bootloader mode and hints at firmware installation availability but always returns False, indicating no actual firmware installation is performed here."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_start_background_process", "line_number": 137, "body": "def _start_background_process(self, clean=None, extra_args=[]):\n        if self._port is None:\n            return\n\n        super()._start_background_process(clean=clean, extra_args=extra_args)", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Starts a background process on the device if a port is set, optionally cleaning or passing extra arguments. It manages execution context setup within the BareMetalMicroPythonProxy environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_launcher_with_args", "line_number": 143, "body": "def _get_launcher_with_args(self):\n        import thonny.plugins.micropython.bare_metal_backend\n\n        args = {\n            \"clean\": self._clean_start,\n            \"port\": self._port,\n            \"dtr\": get_workbench().get_option(self.backend_name + \".dtr\"),\n            \"rts\": get_workbench().get_option(self.backend_name + \".rts\"),\n            \"submit_mode\": get_workbench().get_option(self.backend_name + \".submit_mode\"),\n            \"api_stubs_path\": self._get_api_stubs_path(),\n            \"write_block_size\": self._get_write_block_size(),\n            \"write_block_delay\": self._get_write_block_delay(),\n            \"proxy_class\": self.__class__.__name__,\n        }\n        if self._port == \"webrepl\":\n            args[\"url\"] = get_workbench().get_option(self.backend_name + \".webrepl_url\")\n            args[\"password\"] = get_workbench().get_option(self.backend_name + \".webrepl_password\")\n\n        args.update(self._get_time_args())\n\n        cmd = [\n            thonny.plugins.micropython.bare_metal_backend.__file__,\n            repr(args),\n        ]\n\n        return cmd", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Constructs and returns a launcher command with configuration arguments for initiating a Bare Metal MicroPython backend session, tailoring connection and communication settings based on the current proxy state and environment options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_write_block_size", "line_number": 170, "body": "def _get_write_block_size(self):\n        return get_workbench().get_option(self.backend_name + \".write_block_size\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Internal method of BareMetalMicroPythonProxy that retrieves the configured block size for write operations from the backend settings, supporting optimized data transmission."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_write_block_delay", "line_number": 173, "body": "def _get_write_block_delay(self):\n        return get_workbench().get_option(self.backend_name + \".write_block_delay\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Returns the configured delay time for write block operations specific to the backend, enabling synchronization or throttling in hardware communication via the BareMetalMicroPythonProxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "interrupt", "line_number": 176, "body": "def interrupt(self):\n        # Don't interrupt local process, but direct it to device\n        self._send_msg(ImmediateCommand(\"interrupt\"))", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Sends an interrupt command to a connected device without affecting the local process, enabling external control or interruption of device operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "send_command", "line_number": 180, "body": "def send_command(self, cmd: CommandToBackend) -> Optional[str]:\n        if isinstance(cmd, EOFCommand):\n            get_shell().restart()  # Runner doesn't notice restart\n\n        return super().send_command(cmd)", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Method of BareMetalMicroPythonProxy that sends a command to the backend and handles special restart commands by triggering a shell restart before forwarding the command."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_detect_potential_ports", "line_number": 190, "body": "def _detect_potential_ports(cls):\n        all_ports = list_serial_ports()\n        \"\"\"\n        for p in all_ports:\n            print(vars(p))\n        \"\"\"\n        return [(p.device, p.description) for p in all_ports if cls._is_potential_port(p)]", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Utility method in BareMetalMicroPythonProxy that identifies serial ports potentially compatible with the proxy based on predefined criteria, facilitating connection setup for microcontroller communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_is_potential_port", "line_number": 199, "body": "def _is_potential_port(cls, p):\n        return (\n            (p.vid, p.pid) in cls.get_known_usb_vids_pids()\n            or (p.vid, None) in cls.get_known_usb_vids_pids()\n            or p.description in cls.get_known_port_descriptions()\n            or cls.should_consider_unknown_devices()\n            and (p.vid, p.pid) not in cls.get_vids_pids_to_avoid()\n            and (\n                getattr(p, \"manufacturer\", \"\") == \"MicroPython\"\n                or (\"USB\" in p.description and \"serial\" in p.description.lower())\n                or \"UART\" in p.description\n                or \"DAPLink\" in p.description\n                or \"STLink\" in p.description\n                or \"python\" in p.description.lower()\n            )\n        )", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Class method that determines if a given port is likely associated with a MicroPython device by checking USB IDs, descriptions, and manufacturer details, aiding in identifying compatible hardware ports."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 217, "body": "def get_known_usb_vids_pids(cls):\n        \"\"\"Return set of pairs of USB device VID, PID\"\"\"\n        return cls.get_used_usb_vidpids()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Utility method in BareMetalMicroPythonProxy that returns known USB device vendor and product ID pairs, facilitating identification or filtering of supported USB devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_vids_pids_to_avoid", "line_number": 222, "body": "def get_vids_pids_to_avoid(cls):\n        \"\"\"Return set of pairs of USB device VID, PID to explicitly not consider\n        either because they are not compatible or to reduce the number of choices\n        in the switcher.\n        \"\"\"\n        return set()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Returns a set of USB device vendor and product ID pairs to exclude, helping filter incompatible or undesired devices during device selection processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_used_usb_vidpids", "line_number": 230, "body": "def get_used_usb_vidpids(cls):\n        return get_workbench().get_option(cls.backend_name + \".used_vidpids\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Retrieves the list of USB vendor and product IDs currently used by the specified backend, facilitating hardware identification and management in the BareMetalMicroPythonProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_uart_adapter_vids_pids", "line_number": 234, "body": "def get_uart_adapter_vids_pids(cls):\n        return {\n            (0x1A86, 0x7523),  # HL-340\n            (0x10C4, 0xEA60),  # CP210x\"),\n            (0x0403, 0x6001),  # FT232/FT245 (XinaBox CW01, CW02)\n            (0x0403, 0x6010),  # FT2232C/D/L/HL/Q (ESP-WROVER-KIT)\n            (0x0403, 0x6011),  # FT4232\n            (0x0403, 0x6014),  # FT232H\n            (0x0403, 0x6015),  # FT X-Series (Sparkfun ESP32)\n            (0x0403, 0x601C),  # FT4222H\n        }", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Returns a set of USB vendor and product ID pairs identifying supported UART adapter devices for communication with BareMetalMicroPythonProxy. This enables device recognition for serial communication management in microcontroller interfacing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_consider_unknown_devices", "line_number": 247, "body": "def should_consider_unknown_devices(cls):\n        return True", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Static method in BareMetalMicroPythonProxy that indicates whether the system should include devices not explicitly recognized; always returns True to allow handling of unknown devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_known_port_descriptions", "line_number": 251, "body": "def get_known_port_descriptions(cls):\n        return set()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Returns an empty set indicating no known port descriptions are available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_api_stubs_path", "line_number": 254, "body": "def _get_api_stubs_path(self):\n        import inspect\n\n        return os.path.join(os.path.dirname(inspect.getfile(self.__class__)), \"api_stubs\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Returns the file system path to the \"api_stubs\" directory located alongside the class definition, facilitating access to API stub resources within the BareMetalMicroPythonProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_files", "line_number": 259, "body": "def supports_remote_files(self):\n        return self.is_connected()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Indicates whether the proxy is currently connected, implying support for accessing remote files. This check enables dependent functions to conditionally perform remote file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "uses_local_filesystem", "line_number": 262, "body": "def uses_local_filesystem(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Indicates whether the proxy uses a local filesystem, consistently returning False to denote it does not. This informs consumers about the storage mechanism the proxy relies on."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "ready_for_remote_file_operations", "line_number": 265, "body": "def ready_for_remote_file_operations(self):\n        return self.is_connected() and get_runner().is_waiting_toplevel_command()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Checks if the proxy is connected and ready to accept top-level remote file operation commands. It ensures that remote file actions can be safely initiated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_directories", "line_number": 268, "body": "def supports_remote_directories(self):\n        return self._cwd is not None and self._cwd != \"\"", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Checks if the proxy currently has a valid remote working directory set, indicating support for remote directory operations. This helps determine if directory-based remote commands can be executed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_trash", "line_number": 271, "body": "def supports_trash(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Indicates whether the BareMetalMicroPythonProxy supports a trash or recycle functionality. It always returns False, signaling no trash capability is provided."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "is_connected", "line_number": 274, "body": "def is_connected(self):\n        return self._port is not None and self._proc is not None", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Checks if the proxy currently maintains an active connection by verifying the presence of both a communication port and a running process. This helps other functions confirm connection status before performing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_show_error", "line_number": 277, "body": "def _show_error(self, text):\n        get_shell().print_error(\"\\n\" + text + \"\\n\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Private method in BareMetalMicroPythonProxy that displays an error message formatted with surrounding newlines in the shell interface. It serves as a utility for consistent error reporting within the class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "disconnect", "line_number": 280, "body": "def disconnect(self):\n        self.destroy()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Utility method in BareMetalMicroPythonProxy that terminates the connection by invoking the cleanup process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_node_label", "line_number": 283, "body": "def get_node_label(self):\n        if \"CircuitPython\" in self._welcome_text:\n            return tr(\"CircuitPython device\")\n        elif \"micro:bit\" in self._welcome_text.lower():\n            return \"micro:bit\"\n        else:\n            return tr(\"MicroPython device\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Determines and returns the type label of a connected device based on its welcome message, identifying whether it is a CircuitPython, micro:bit, or generic MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_full_label", "line_number": 291, "body": "def get_full_label(self):\n        if self.is_connected():\n            return self.get_node_label() + \" @ \" + self._port\n        else:\n            return self.get_node_label() + \" (\" + tr(\"Not connected\") + \")\"", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Returns a descriptive label indicating the device's node label combined with its connection status and port, helping to identify the device clearly in user interfaces or logs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_exe_dirs", "line_number": 297, "body": "def get_exe_dirs(self):\n        return []", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Returns an empty list indicating no executable directories are available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_local_files", "line_number": 300, "body": "def can_run_local_files(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Indicates whether the proxy supports executing local files, always returning False to signify that this capability is unavailable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_remote_files", "line_number": 303, "body": "def can_run_remote_files(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Indicates that running remote files is not supported by this proxy. It serves as a capability check within the BareMetalMicroPythonProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "fetch_next_message", "line_number": 306, "body": "def fetch_next_message(self):\n        msg = super(BareMetalMicroPythonProxy, self).fetch_next_message()\n        if (\n            not self._have_stored_pidwid\n            and getattr(msg, \"event_type\", None) == \"ToplevelResponse\"\n            and self._port != \"webrepl\"\n        ):\n            # Let's remember that this vidpid was used with this backend\n            # need to copy and store explicitly, because otherwise I may change the default value\n            used_vidpids = get_workbench().get_option(self.backend_name + \".used_vidpids\").copy()\n            from serial.tools.list_ports_common import ListPortInfo\n\n            info = get_port_info(self._port)\n            used_vidpids.add((info.vid, info.pid))\n            self._have_stored_pidwid = True\n            get_workbench().set_option(self.backend_name + \".used_vidpids\", used_vidpids)\n\n        return msg", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Method in BareMetalMicroPythonProxy that retrieves the next communication message and records the USB vendor and product IDs upon receiving a specific response, facilitating device identification tracking for non-webrepl backends."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "device_is_present_in_bootloader_mode", "line_number": 326, "body": "def device_is_present_in_bootloader_mode(cls):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Always returns False indicating that the device is not detected in bootloader mode. This placeholder signals the absence of bootloader detection functionality in the BareMetalMicroPythonProxy class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_show_in_switcher", "line_number": 330, "body": "def should_show_in_switcher(cls):\n        if cls.device_is_present_in_bootloader_mode():\n            return True\n\n        # Show only if it looks like we can connect using current configuration\n        port = get_workbench().get_option(cls.backend_name + \".port\")\n        if port == \"webrepl\":\n            return True\n        if port == \"auto\":\n            potential_ports = cls._detect_potential_ports()\n            return len(potential_ports) > 0\n        else:\n            for p in list_serial_ports():\n                if p.device == port:\n                    return True\n\n            return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Determines if the device should appear in the switcher UI by checking bootloader mode or validating connection availability via configured ports. Useful for dynamically showing connectable devices in a hardware interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_switcher_entries", "line_number": 349, "body": "def get_switcher_entries(cls):\n        if cls.should_show_in_switcher():\n            return [(cls.get_current_switcher_configuration(), cls.backend_description)]\n        else:\n            return []", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Utility method of BareMetalMicroPythonProxy that returns the current switcher configuration and backend description if it should be shown; otherwise, provides an empty list for managing backend switcher entries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "has_custom_system_shell", "line_number": 355, "body": "def has_custom_system_shell(self):\n        return self._port and self._port != \"webrepl\"", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Checks whether a custom system shell is active by verifying the port is set and not equal to \"webrepl\". This helps determine if a non-default shell interface is in use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "open_custom_system_shell", "line_number": 358, "body": "def open_custom_system_shell(self):\n        from thonny import terminal\n\n        get_runner().send_command_and_wait(InlineCommand(\"prepare_disconnect\"), \"Disconnecting\")\n\n        self.disconnect()\n\n        terminal.run_in_terminal(\n            [\n                running.get_interpreter_for_subprocess(sys.executable),\n                \"-m\",\n                # \"serial.tools.miniterm\",\n                \"thonny.plugins.micropython.miniterm_wrapper\",\n                \"--exit-char\",\n                \"20\",\n                \"--menu-char\",\n                \"29\",\n                \"--filter\",\n                \"direct\",\n                \"--quiet\",\n                self._port,\n                \"115200\",\n            ],\n            cwd=get_workbench().get_local_cwd(),\n            keep_open=False,\n            title=self._port,\n        )", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Provides a way to disconnect from a MicroPython device and open a custom system shell for direct serial communication using specified settings and port in the BareMetalMicroPythonProxy class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_supported_features", "line_number": 386, "body": "def get_supported_features(self):\n        return {\"run\", \"run_in_terminal\"}", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Returns a set of features supported by the BareMetalMicroPythonProxy, indicating available execution capabilities for client interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "run_script_in_terminal", "line_number": 389, "body": "def run_script_in_terminal(self, script_path, args, interactive, keep_open):\n        messagebox.showinfo(\n            \"Running in terminal\",\n            \"In order to run your script in terminal, save it on the device\\n\"\n            \"as main script, select 'Tools => Open system shell' and press Ctrl+D\",\n        )", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Displays an informational message guiding the user on how to run a script in the terminal by saving it as the main script and using the system shell. This aids users in executing scripts outside the application interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_on_click_firmware_installer_link", "line_number": 479, "body": "def _on_click_firmware_installer_link(self, event=None):\n        self._open_flashing_dialog()\n        self._has_opened_firmware_flasher = True", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Private method in BareMetalMicroPythonConfigPage that triggers the firmware flashing dialog and flags that the firmware installer has been opened."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_intro_text", "line_number": 486, "body": "def _get_intro_text(self):\n        result = (\n            tr(\"Connect your device to the computer and select corresponding port below\")\n            + \"\\n\"\n            + \"(\"\n            + tr('look for your device name, \"USB Serial\" or \"UART\"')\n            + \").\\n\"\n            + tr(\"If you can't find it, you may need to install proper USB driver first.\")\n        )\n        if self.allow_webrepl:\n            result = (\n                (\"Connecting via USB cable:\")\n                + \"\\n\"\n                + result\n                + \"\\n\\n\"\n                + (\"Connecting via WebREPL (EXPERIMENTAL):\")\n                + \"\\n\"\n                + (\n                    \"If your device supports WebREPL, first connect via serial, make sure WebREPL is enabled\\n\"\n                    + \"(import webrepl_setup), connect your computer and device to same network and select\\n\"\n                    + \"< WebREPL > below\"\n                )\n            )\n\n        return result", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Generates instructional text guiding users to connect their device via USB or optionally WebREPL. It provides connection setup tips and troubleshooting advice for the BareMetalMicroPythonConfigPage interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_webrepl_frame", "line_number": 512, "body": "def _get_webrepl_frame(self):\n\n        if self._webrepl_frame is not None:\n            return self._webrepl_frame\n\n        self._webrepl_frame = ttk.Frame(self)\n\n        self._webrepl_url_var = create_string_var(\n            get_workbench().get_option(self.backend_name + \".webrepl_url\")\n        )\n        url_label = ttk.Label(self._webrepl_frame, text=\"URL (eg. %s)\" % DEFAULT_WEBREPL_URL)\n        url_label.grid(row=0, column=0, sticky=\"nw\", pady=(10, 0))\n        url_entry = ttk.Entry(self._webrepl_frame, textvariable=self._webrepl_url_var, width=30)\n        url_entry.grid(row=1, column=0, sticky=\"nw\")\n\n        self._webrepl_password_var = create_string_var(\n            get_workbench().get_option(self.backend_name + \".webrepl_password\")\n        )\n        pw_label = ttk.Label(self._webrepl_frame, text=tr(\"Password\"))\n        pw_label.grid(row=0, column=1, sticky=\"nw\", pady=(10, 0), padx=(10, 0))\n        pw_entry = ttk.Entry(self._webrepl_frame, textvariable=self._webrepl_password_var, width=15)\n        pw_entry.grid(row=1, column=1, sticky=\"nw\", padx=(10, 0))\n\n        return self._webrepl_frame", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Constructs and returns a GUI frame for WebREPL settings, including fields to configure the WebREPL URL and password, initializing them from stored backend options. This supports user interaction with WebREPL connection parameters in the configuration page."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_stored_port_desc", "line_number": 537, "body": "def get_stored_port_desc(self):\n        name = get_workbench().get_option(self.backend_name + \".port\")\n        for desc in self._ports_by_desc:\n            if self._ports_by_desc[desc] == name:\n                return desc\n\n        return \"\"", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Returns the description of the currently stored port name in the configuration, enabling identification of the port by its user-friendly label."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_selected_port_name", "line_number": 545, "body": "def get_selected_port_name(self):\n        port_desc = self._port_desc_variable.get()\n        if not port_desc:\n            return None\n        return self._ports_by_desc[port_desc]", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Utility method in BareMetalMicroPythonConfigPage that returns the port name corresponding to the currently selected port description, or None if no selection exists."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "is_modified", "line_number": 551, "body": "def is_modified(self):\n        return (\n            self._port_desc_variable.modified\n            or self.webrepl_selected()\n            and self._webrepl_password_var.modified\n            or self.webrepl_selected()\n            and self._webrepl_url_var.modified\n        )", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Checks if any configuration related to port description or webrepl settings has been changed, indicating the page's modification status for potential saving or updating actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "webrepl_selected", "line_number": 560, "body": "def webrepl_selected(self):\n        return self.get_selected_port_name() == \"webrepl\"", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Utility method in BareMetalMicroPythonConfigPage that checks if the selected port is set to \"webrepl,\" enabling conditional behaviors based on the WebREPL port selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_restart", "line_number": 563, "body": "def should_restart(self):\n        return self.is_modified() or self._has_opened_firmware_flasher", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Determines whether the configuration page requires a restart based on modifications or the firmware flasher being active. It supports managing update workflows in the BareMetalMicroPythonConfigPage interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "apply", "line_number": 566, "body": "def apply(self):\n        if not self.is_modified():\n            return\n\n        else:\n            port_name = self.get_selected_port_name()\n            get_workbench().set_option(self.backend_name + \".port\", port_name)\n            if self.webrepl_selected():\n                get_workbench().set_option(\n                    self.backend_name + \".webrepl_url\", self._webrepl_url_var.get()\n                )\n                get_workbench().set_option(\n                    self.backend_name + \".webrepl_password\", self._webrepl_password_var.get()\n                )", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Updates device connection settings based on user modifications, including port selection and optional WebREPL configuration, to persist these options in the workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_on_change_port", "line_number": 581, "body": "def _on_change_port(self, *args):\n        if self._port_desc_variable.get() == self._WEBREPL_OPTION_DESC:\n            self._get_webrepl_frame().grid(row=6, column=0, sticky=\"nwe\")\n        else:\n            if self._webrepl_frame and self._webrepl_frame.winfo_ismapped():\n                self._webrepl_frame.grid_forget()", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Handles UI updates when the port selection changes, showing or hiding the WebREPL configuration frame based on the selected option. It ensures the interface reflects relevant settings dynamically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_usb_driver_url", "line_number": 588, "body": "def _get_usb_driver_url(self) -> Optional[str]:\n        return None", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Returns None, indicating no USB driver URL is provided or available in the current configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_has_flashing_dialog", "line_number": 591, "body": "def _has_flashing_dialog(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "This method indicates whether a flashing dialog is available, always returning False. It signals the absence of a flashing interface in the BareMetalMicroPythonConfigPage context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "allow_webrepl", "line_number": 598, "body": "def allow_webrepl(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Returns a fixed value indicating web REPL access is not allowed. This method signals that the web-based remote Python shell is disabled for this configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 604, "body": "def get_known_usb_vids_pids(cls):\n        \"\"\"Return set of pairs of USB device (VID, PID)\"\"\"\n        return {\n            # Generic MicroPython Board, see http://pid.codes/org/MicroPython/\n            (0x1209, 0xADDA)\n        } | cls.get_uart_adapter_vids_pids()", "is_method": true, "class_name": "GenericBareMetalMicroPythonProxy", "function_description": "Provides a set of known USB vendor and product ID pairs associated with Generic MicroPython boards and UART adapters, aiding device identification and connection management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_vids_pids_to_avoid", "line_number": 612, "body": "def get_vids_pids_to_avoid(self):\n        return VIDS_PIDS_TO_AVOID_IN_GENERIC_BACKEND", "is_method": true, "class_name": "GenericBareMetalMicroPythonProxy", "function_description": "Returns a predefined list of USB vendor and product IDs that should be excluded when using the generic backend, helping to avoid compatibility issues with specific devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "allow_webrepl", "line_number": 618, "body": "def allow_webrepl(self):\n        return False", "is_method": true, "class_name": "GenericBareMetalMicroPythonConfigPage", "function_description": "Indicates whether the web-based REPL (Read-Eval-Print Loop) interface is permitted. Always returns False, effectively disabling web REPL access."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_launcher_with_args", "line_number": 627, "body": "def _get_launcher_with_args(self):\n        import thonny.plugins.micropython.os_mp_backend\n\n        cmd = [\n            thonny.plugins.micropython.os_mp_backend.__file__,\n            repr(\n                {\n                    \"interpreter\": self._mp_executable,\n                    \"api_stubs_path\": self._get_api_stubs_path(),\n                    \"cwd\": self.get_cwd(),\n                }\n            ),\n        ]\n        return cmd", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Constructs and returns a command list containing the MicroPython launcher script and its runtime arguments, facilitating the setup of MicroPython execution with specific interpreter and environment configurations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "interrupt", "line_number": 642, "body": "def interrupt(self):\n        # Don't interrupt local process, but direct it to the device\n        self._send_msg(ImmediateCommand(\"interrupt\"))", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Method of LocalMicroPythonProxy that sends an interrupt command to the connected device, enabling external control to halt or interrupt device execution without affecting the local process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "send_command", "line_number": 646, "body": "def send_command(self, cmd: CommandToBackend) -> Optional[str]:\n        if isinstance(cmd, EOFCommand):\n            get_shell().restart()  # Runner doesn't notice restart\n\n        return super().send_command(cmd)", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Method of LocalMicroPythonProxy that sends a command to the backend, restarting the shell if an end-of-file command is detected before forwarding the command. It manages command dispatch with special handling for shell restarts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_api_stubs_path", "line_number": 652, "body": "def _get_api_stubs_path(self):\n        import inspect\n\n        return os.path.join(os.path.dirname(inspect.getfile(self.__class__)), \"api_stubs\")", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Private helper method in LocalMicroPythonProxy that returns the filesystem path to the 'api_stubs' directory relative to the class file location."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_initial_cwd", "line_number": 657, "body": "def _get_initial_cwd(self):\n        return get_workbench().get_local_cwd()", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Internal utility method of LocalMicroPythonProxy that provides the initial local current working directory from the associated workbench environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_files", "line_number": 660, "body": "def supports_remote_files(self):\n        return False", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Indicates that remote file operations are not supported by this LocalMicroPythonProxy class. It signals the limitation on handling files outside the local environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "uses_local_filesystem", "line_number": 664, "body": "def uses_local_filesystem(self):\n        return True", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Indicates that LocalMicroPythonProxy operates using the local filesystem. This function confirms the proxy\u2019s reliance on local file storage."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "ready_for_remote_file_operations", "line_number": 667, "body": "def ready_for_remote_file_operations(self):\n        return False", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "This method indicates whether the LocalMicroPythonProxy is prepared to perform file operations on a remote device. It always returns False, signaling that remote file operations are not supported in this context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_directories", "line_number": 670, "body": "def supports_remote_directories(self):\n        return False", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Indicates whether the proxy supports access to remote directories, consistently returning False. This function signals that remote directory operations are not available through this proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_trash", "line_number": 673, "body": "def supports_trash(self):\n        return True", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Indicates whether the LocalMicroPythonProxy supports trash functionality, allowing other components to check if trash operations are available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "is_connected", "line_number": 676, "body": "def is_connected(self):\n        return self._proc is not None", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Checks whether the LocalMicroPythonProxy currently has an active connection to its process. This enables other functions to verify connection status before performing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_show_error", "line_number": 679, "body": "def _show_error(self, text):\n        get_shell().print_error(\"\\n\" + text + \"\\n\")", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Private helper method in LocalMicroPythonProxy that displays an error message to the user via the shell interface for clear communication of issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "disconnect", "line_number": 682, "body": "def disconnect(self):\n        self.destroy()", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Simple method in LocalMicroPythonProxy that terminates the current connection by invoking the proxy's destruction process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_node_label", "line_number": 685, "body": "def get_node_label(self):\n        return \"Local\"", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Returns a fixed label identifying the node as \"Local\" within the LocalMicroPythonProxy context. This function provides a simple way to denote the proxy's node type or origin."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_full_label", "line_number": 688, "body": "def get_full_label(self):\n        return self._mp_executable", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Returns the full executable label or identifier associated with the LocalMicroPythonProxy instance, providing a way to access the underlying MicroPython executable reference."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_exe_dirs", "line_number": 691, "body": "def get_exe_dirs(self):\n        return []", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Returns an empty list indicating no executable directories are available. This may serve as a placeholder or default implementation in the LocalMicroPythonProxy class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_pip_gui_class", "line_number": 694, "body": "def get_pip_gui_class(self):\n        from thonny.plugins.micropython.pip_gui import LocalMicroPythonPipDialog\n\n        return LocalMicroPythonPipDialog", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Returns the GUI dialog class used for managing MicroPython package installations within the LocalMicroPython environment. This enables other components to access the specific pip interface for package management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_local_files", "line_number": 699, "body": "def can_run_local_files(self):\n        return True", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Indicates that the LocalMicroPythonProxy supports execution of local files. This method confirms the capability to run files stored on the local system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_remote_files", "line_number": 702, "body": "def can_run_remote_files(self):\n        return False", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Indicates that this proxy does not support executing files on remote devices. It informs other components that remote file execution capability is unavailable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_show_in_switcher", "line_number": 706, "body": "def should_show_in_switcher(cls):\n        # Show when the executable is configured and exists\n        executable = get_workbench().get_option(\"LocalMicroPython.executable\")\n        import shutil\n\n        return bool(executable) and (\n            os.path.isabs(executable) and os.path.exists(executable) or shutil.which(executable)\n        )", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Determines if the LocalMicroPython executable is properly configured and accessible, indicating whether it should appear in the environment switcher interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_switcher_entries", "line_number": 716, "body": "def get_switcher_entries(cls):\n        if cls.should_show_in_switcher():\n            return [(cls.get_current_switcher_configuration(), cls.backend_description)]\n        else:\n            return []", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Returns configuration entries for switching interfaces if the class is set to appear in the switcher; otherwise, it provides an empty list. This enables dynamic management of backend configurations for interface switching."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_on_change", "line_number": 734, "body": "def _on_change(self):\n        self._changed = True", "is_method": true, "class_name": "LocalMicroPythonConfigPage", "function_description": "Marks the configuration page as modified when a change occurs, signaling that updates need to be saved or processed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "apply", "line_number": 737, "body": "def apply(self):\n        get_workbench().set_option(\"LocalMicroPython.executable\", self._executable_var.get())", "is_method": true, "class_name": "LocalMicroPythonConfigPage", "function_description": "Sets the LocalMicroPython executable path in the application settings based on the current configuration page input. This allows other components to access the specified MicroPython executable location."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_restart", "line_number": 740, "body": "def should_restart(self):\n        return self._changed", "is_method": true, "class_name": "LocalMicroPythonConfigPage", "function_description": "Returns whether the configuration has changed and indicates if a restart is needed. This helps determine if system settings require reloading after updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_launcher_with_args", "line_number": 752, "body": "def _get_launcher_with_args(self):\n        import thonny.plugins.micropython.os_mp_backend\n\n        args = {\n            \"cwd\": get_workbench().get_option(\"SshMicroPython.cwd\") or \"\",\n            \"interpreter\": self._mp_executable,\n            \"api_stubs_path\": self._get_api_stubs_path(),\n            \"host\": self._host,\n            \"user\": self._user,\n            \"password\": get_ssh_password(\"SshMicroPython\"),\n        }\n\n        args.update(self._get_time_args())\n\n        cmd = [\n            thonny.plugins.micropython.os_mp_backend.__file__,\n            repr(args),\n        ]\n        return cmd", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Constructs and returns a command list to launch the MicroPython backend over SSH, including connection parameters and runtime configuration for use by the SshMicroPythonProxy class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "interrupt", "line_number": 772, "body": "def interrupt(self):\n        # Don't interrupt local process, but direct it to the device\n        self._send_msg(ImmediateCommand(\"interrupt\"))", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Service method of SshMicroPythonProxy that sends an interrupt command to the connected device without affecting the local process, enabling remote interruption control."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "send_command", "line_number": 776, "body": "def send_command(self, cmd: CommandToBackend) -> Optional[str]:\n        if isinstance(cmd, EOFCommand):\n            get_shell().restart()  # Runner doesn't notice restart\n\n        return super().send_command(cmd)", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Method of SshMicroPythonProxy that sends a command to the backend, handling EOF commands by restarting the shell before forwarding the command for processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_api_stubs_path", "line_number": 782, "body": "def _get_api_stubs_path(self):\n        import inspect\n\n        return os.path.join(os.path.dirname(inspect.getfile(self.__class__)), \"api_stubs\")", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Returns the file system path to the \"api_stubs\" directory located alongside the class definition, enabling access to MicroPython API stub files for this proxy class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_initial_cwd", "line_number": 787, "body": "def _get_initial_cwd(self):\n        return get_workbench().get_option(\"SshMicroPython.cwd\")", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Retrieves the initial current working directory configured for the SSH MicroPython environment from the workbench settings. This utility supports consistent path resolution when establishing remote SSH sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_publish_cwd", "line_number": 790, "body": "def _publish_cwd(self, cwd):\n        return get_workbench().set_option(\"SshMicroPython.cwd\", cwd)", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Sets the current working directory option specific to the SshMicroPython environment, enabling other components to access or track the active directory context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_files", "line_number": 793, "body": "def supports_remote_files(self):\n        return True", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Indicates whether the proxy supports accessing remote files. This function signals that remote file operations are available through the SshMicroPythonProxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "uses_local_filesystem", "line_number": 797, "body": "def uses_local_filesystem(self):\n        return False", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Indicates that the SshMicroPythonProxy does not utilize the local filesystem. This method helps determine the file system context for operations within the proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "ready_for_remote_file_operations", "line_number": 800, "body": "def ready_for_remote_file_operations(self):\n        return self.is_connected()", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Checks if the SSH connection is established and ready to perform remote file operations. This method allows other functions to verify connection status before executing file-related commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_directories", "line_number": 803, "body": "def supports_remote_directories(self):\n        return True", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Indicates whether the SSH MicroPython proxy supports operations on remote directories. This function informs other components about remote directory handling capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_trash", "line_number": 806, "body": "def supports_trash(self):\n        return False", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Indicates whether the SshMicroPythonProxy class supports a trash or recycle bin feature, consistently returning False to show that such functionality is not available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "is_connected", "line_number": 809, "body": "def is_connected(self):\n        return self._proc is not None", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Utility method of SshMicroPythonProxy that checks whether an active SSH connection process exists, indicating the proxy's current connection status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_show_error", "line_number": 812, "body": "def _show_error(self, text):\n        get_shell().print_error(\"\\n\" + text + \"\\n\")", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Private helper method in SshMicroPythonProxy that displays error messages via the shell interface, formatting the text with surrounding newlines for clarity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "disconnect", "line_number": 815, "body": "def disconnect(self):\n        self.destroy()", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Terminates the SSH connection by performing all necessary cleanup actions. This function ensures the proxy properly releases resources when disconnecting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_node_label", "line_number": 818, "body": "def get_node_label(self):\n        return self._host", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Returns the SSH host identifier as the node label, providing a simple way to reference the remote device in the SshMicroPythonProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_full_label", "line_number": 821, "body": "def get_full_label(self):\n        return self._mp_executable + \" @ \" + self._host", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "This method provides a combined label string indicating the MicroPython executable and its host, useful for identifying the SSH proxy instance it represents."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_exe_dirs", "line_number": 824, "body": "def get_exe_dirs(self):\n        return []", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Returns an empty list indicating no executable directories are available. This placeholder method signals that executable directory retrieval is not implemented or not applicable in this context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_local_files", "line_number": 827, "body": "def can_run_local_files(self):\n        return False", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Indicates that running local files is not supported in the SshMicroPythonProxy environment. This method signals clients that only remote execution is available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_remote_files", "line_number": 830, "body": "def can_run_remote_files(self):\n        return True", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Returns whether the proxy supports executing files on a remote MicroPython device, indicating its capability to run remote files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_show_in_switcher", "line_number": 834, "body": "def should_show_in_switcher(cls):\n        # Show when the executable, user and host are configured\n        return (\n            get_workbench().get_option(\"SshMicroPython.host\")\n            and get_workbench().get_option(\"SshMicroPython.user\")\n            and get_workbench().get_option(\"SshMicroPython.executable\")\n        )", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Determines if the SSH MicroPython proxy should be visible in the switcher based on configured host, user, and executable settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_switcher_entries", "line_number": 843, "body": "def get_switcher_entries(cls):\n        if cls.should_show_in_switcher():\n            return [(cls.get_current_switcher_configuration(), cls.backend_description)]\n        else:\n            return []", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Provides switcher configuration entries if the class is eligible to be shown in the switcher; otherwise, returns an empty list. Useful for managing backend switching options in the SshMicroPythonProxy context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "has_custom_system_shell", "line_number": 849, "body": "def has_custom_system_shell(self):\n        return True", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Indicates whether the SSH MicroPython proxy uses a custom system shell. This function signals that the proxy supports a specialized shell environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "open_custom_system_shell", "line_number": 852, "body": "def open_custom_system_shell(self):\n        if not shutil.which(\"ssh\"):\n            messagebox.showerror(\n                \"Command not found\", \"Command 'ssh' not found\", master=get_workbench()\n            )\n            return\n\n        from thonny import terminal\n\n        userhost = \"%s@%s\" % (self._user, self._host)\n        terminal.run_in_terminal(\n            [\"ssh\", userhost], cwd=get_workbench().get_local_cwd(), keep_open=False, title=userhost\n        )", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Opens an SSH terminal session to the configured MicroPython device's host if the SSH command is available, enabling direct system shell access from the development environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "port_order", "line_number": 898, "body": "def port_order(p):\n        name = p.device\n        if name is None:\n            return \"\"\n        elif name.startswith(\"COM\") and len(name) == 4:\n            # Make one-digit COM ports go before COM10\n            return name.replace(\"COM\", \"COM0\")\n        else:\n            return name", "is_method": false, "function_description": "Function that normalizes serial port names to ensure one-digit COM ports are sorted before higher numbered ones, aiding consistent ordering in applications managing serial device connections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "port_order", "line_number": 430, "body": "def port_order(p):\n            _, name = p\n            if name is None:\n                return \"\"\n            elif name.startswith(\"COM\") and len(name) == 4:\n                # Make one-digit COM ports go before COM10\n                return name.replace(\"COM\", \"COM0\")\n            else:\n                return name", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Helper function to determine sorting order for port names, prioritizing single-digit COM ports before others for consistent port listing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/ssh_connection.py", "function": "write", "line_number": 28, "body": "def write(self, data, block_size=255, delay=0.01):\n        if isinstance(data, str):\n            data = data.encode(self.encoding)\n        self._stdin.write(data)\n        self._stdin.flush()\n        return len(data)", "is_method": true, "class_name": "SshProcessConnection", "function_description": "Method of SshProcessConnection that sends byte or string data to the SSH process input stream, ensuring the data is encoded and flushed for transmission. Useful for writing commands or data to an active SSH session."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/ssh_connection.py", "function": "_listen_output", "line_number": 35, "body": "def _listen_output(self):\n        \"NB! works in background thread\"\n        try:\n            while not self._reader_stopped:\n                data = self._stdout.read(1)\n                if len(data) > 0:\n                    self._make_output_available(data)\n                else:\n                    self._error = \"EOF\"\n                    break\n\n        except Exception as e:\n            self._error = str(e)", "is_method": true, "class_name": "SshProcessConnection", "function_description": "Private method of SshProcessConnection that continuously reads and processes output from the SSH subprocess in a background thread, enabling real-time capture and handling of remote command outputs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/ssh_connection.py", "function": "close", "line_number": 49, "body": "def close(self):\n        self._client.exec_command(\"kill -s SIGKILL %s\" % self._pid)\n        self._reading_thread.join()\n        self._client = None\n        self._reading_thread = None", "is_method": true, "class_name": "SshProcessConnection", "function_description": "Terminates the remote process managed by the SSH connection and cleans up related client and thread resources to ensure a proper shutdown of the connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_report_internal_error", "line_number": 1376, "body": "def _report_internal_error(exception=None):\n    logger.exception(\"PROBLEM WITH THONNY'S BACK-END:\", exc_info=exception)", "is_method": false, "function_description": "Logs detailed backend error information for Thonny's environment, aiding in troubleshooting and debugging internal issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "parse_api_information", "line_number": 1380, "body": "def parse_api_information(file_path):\n    import tokenize\n\n    with tokenize.open(file_path) as fp:\n        source = fp.read()\n\n    tree = ast.parse(source)\n\n    defs = {}\n\n    # TODO: read also docstrings ?\n\n    for toplevel_item in tree.body:\n        if isinstance(toplevel_item, ast.ClassDef):\n            class_name = toplevel_item.name\n            member_names = []\n            for item in toplevel_item.body:\n                if isinstance(item, ast.FunctionDef):\n                    member_names.append(item.name)\n                elif isinstance(item, ast.Assign):\n                    # TODO: check Python 3.4\n                    \"TODO: item.targets[0].id\"\n\n            defs[class_name] = member_names\n\n    return defs", "is_method": false, "function_description": "Utility function that parses a Python file to extract and return a dictionary mapping class names to their method names, supporting static analysis or API overview generation from source code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "unix_dirname_basename", "line_number": 1408, "body": "def unix_dirname_basename(path):\n    if path == \"/\":\n        return (\"/\", \"\")\n\n    if \"/\" not in path:  # micro:bit\n        return \"\", path\n\n    path = path.rstrip(\"/\")\n    dir_, file_ = path.rsplit(\"/\", maxsplit=1)\n    if dir_ == \"\":\n        dir_ = \"/\"\n\n    return dir_, file_", "is_method": false, "function_description": "Function that splits a Unix-style file path into its directory and basename components, correctly handling root and edge cases for path parsing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "to_remote_path", "line_number": 1423, "body": "def to_remote_path(path):\n    return path.replace(\"\\\\\", \"/\")", "is_method": false, "function_description": "Converts local file system paths to a remote-compatible format by replacing backslashes with forward slashes, facilitating consistent path handling across different operating systems or network environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "ends_overlap", "line_number": 1427, "body": "def ends_overlap(left, right) -> int:\n    \"\"\"Returns the length of maximum overlap between end of the first and start of the second\"\"\"\n    max_overlap = min(len(left), len(right))\n    for i in range(max_overlap, 0, -1):\n        if left.endswith(right[:i]):\n            return i\n\n    return 0", "is_method": false, "function_description": "Function that determines the maximum length where the end of one string overlaps with the start of another, useful for merging or aligning sequences based on overlapping substrings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_prepare_after_soft_reboot", "line_number": 150, "body": "def _prepare_after_soft_reboot(self, clean):\n        self._report_time(\"bef preparing helpers\")\n        script = self._get_all_helpers()\n        self._check_perform_just_in_case_gc()\n        self._execute_without_output(script)\n        self._report_time(\"prepared helpers\")\n\n        self._update_cwd()\n        self._report_time(\"got cwd\")\n        self._sys_path = self._fetch_sys_path()\n\n        self._report_time(\"prepared\")\n        self._check_perform_just_in_case_gc()\n        logger.info(\"Prepared\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Prepares the MicroPython environment after a soft reboot by loading helper scripts, updating the current working directory, and refreshing the system path to ensure proper runtime setup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_prepare_rtc", "line_number": 165, "body": "def _prepare_rtc(self):\n        if self._epoch_year is None:\n            self._epoch_year = self._fetch_epoch_year()\n\n        self._check_sync_time()\n        if self._args.get(\"validate_time\"):\n            self._validate_time()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Internal method of MicroPythonBackend that ensures the real-time clock is properly initialized, synchronized, and optionally validated, supporting accurate timekeeping for dependent operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_check_perform_just_in_case_gc", "line_number": 173, "body": "def _check_perform_just_in_case_gc(self):\n        if self._connected_to_microbit():\n            # May fail to allocate memory without this\n            self._perform_gc()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Internal method of MicroPythonBackend that triggers garbage collection when connected to a Micro:bit device to prevent memory allocation failures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_check_sync_time", "line_number": 178, "body": "def _check_sync_time(self):\n        if self._args.get(\"sync_time\"):\n            self._sync_time()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Calls a time synchronization routine if the \"sync_time\" argument is enabled, ensuring the system clock is updated when needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_perform_gc", "line_number": 182, "body": "def _perform_gc(self):\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n            import gc as __thonny_gc\n            __thonny_gc.collect()\n            del __thonny_gc\n        \"\"\"\n            )\n        )", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Internal method of MicroPythonBackend that triggers garbage collection on the connected MicroPython device to free up memory without producing output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_all_helpers", "line_number": 196, "body": "def _get_all_helpers(self):\n        # Can't import functions into class context:\n        # https://github.com/micropython/micropython/issues/6198\n        return (\n            dedent(\n                \"\"\"\n            class __thonny_helper:\n                try:\n                    import uos as os\n                except ImportError:\n                    import os\n                import sys\n                \n                # for object inspector\n                inspector_values = dict()\n                last_repl_values = []\n                @classmethod\n                def print_repl_value(cls, obj):\n                    if obj is not None:\n                        cls.last_repl_values.append(obj)\n                        cls.last_repl_values = cls.last_repl_values[-{num_values_to_keep}:]\n                        print({start_marker!r} % id(obj), repr(obj), {end_marker!r}, sep='')\n                \n                @staticmethod\n                def print_mgmt_value(obj):\n                    print({mgmt_start!r}, repr(obj), {mgmt_end!r}, sep='', end='')\n                    \n                @staticmethod\n                def repr(obj):\n                    try:\n                        s = repr(obj)\n                        if len(s) > 50:\n                            s = s[:50] + \"...\"\n                        return s\n                    except Exception as e:\n                        return \"<could not serialize: \" + str(e) + \">\"\n                    \n                @classmethod\n                def listdir(cls, x):\n                    if hasattr(cls.os, \"listdir\"):\n                        return cls.os.listdir(x)\n                    else:\n                        return [rec[0] for rec in cls.os.ilistdir(x) if rec[0] not in ('.', '..')]\n            \"\"\"\n            ).format(\n                num_values_to_keep=self._get_num_values_to_keep(),\n                start_marker=OBJECT_LINK_START,\n                end_marker=OBJECT_LINK_END,\n                mgmt_start=MGMT_VALUE_START.decode(ENCODING),\n                mgmt_end=MGMT_VALUE_END.decode(ENCODING),\n            )\n            + \"\\n\"\n            + textwrap.indent(self._get_custom_helpers(), \"    \")\n        )", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides a string containing the full source code of helper classes and functions used internally by the MicroPython backend for object inspection, printing, and filesystem operations, including customizable extensions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_num_values_to_keep", "line_number": 254, "body": "def _get_num_values_to_keep(self):\n        \"\"\"How many last evaluated REPL values and visited Object inspector values to keep\n        in internal lists for the purpose of retrieving them by id for Object inspector\"\"\"\n        return 5", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Returns the fixed number of recent REPL and Object inspector values to retain for retrieval by ID, supporting state tracking in the MicroPythonBackend\u2019s interactive environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_time_for_rtc", "line_number": 262, "body": "def _get_time_for_rtc(self):\n        if self._args[\"utc_clock\"]:\n            return datetime.datetime.now(tz=datetime.timezone.utc).timetuple()\n        else:\n            return datetime.datetime.now().timetuple()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Utility method in MicroPythonBackend that returns the current time as a time tuple, choosing UTC or local time based on configuration. It supports time-based operations requiring precise temporal context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_validate_time", "line_number": 268, "body": "def _validate_time(self):\n        this_computer = self._get_time_for_rtc()\n        remote = self._get_utc_timetuple_from_device()\n        if isinstance(remote, tuple):\n            # tweak the format if required\n            remote = remote[:8]\n            while len(remote) < 8:\n                remote += (0,)\n            remote += (-1,)  # unknown DST\n            diff = int(time.mktime(this_computer) - time.mktime(remote))\n            if abs(diff) > 10:\n                print(\"WARNING: Device's real-time clock seems to be off by %s seconds\" % diff)\n        else:\n            assert isinstance(remote, str)\n            print(\"WARNING: Could not validate time: \" + remote)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Utility method within MicroPythonBackend that checks and warns if the device's real-time clock differs significantly from the host system time, aiding in time synchronization validation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_perform_idle_tasks", "line_number": 296, "body": "def _perform_idle_tasks(self):\n        self._forward_unexpected_output()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Utility method in MicroPythonBackend that handles background or idle tasks by processing any unexpected output during idle periods."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_handle_user_input", "line_number": 299, "body": "def _handle_user_input(self, msg: InputSubmission) -> None:\n        self._submit_input(msg.data)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Private method of MicroPythonBackend that processes user input messages by submitting the contained data for execution or evaluation within the backend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_handle_immediate_command", "line_number": 305, "body": "def _handle_immediate_command(self, cmd: ImmediateCommand) -> None:\n        if cmd[\"name\"] == \"interrupt\":\n            # don't interrupt while command or input is being written\n            with self._interrupt_lock:\n                if self._current_command:\n                    self._current_command.interrupted = True\n                self._write(INTERRUPT_CMD)\n                time.sleep(0.1)\n                self._write(INTERRUPT_CMD)\n                time.sleep(0.1)\n                self._write(INTERRUPT_CMD)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Handles immediate interrupt commands to safely stop ongoing MicroPython commands without disrupting current writes, ensuring controlled command interruption in the MicroPythonBackend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_handle_normal_command", "line_number": 317, "body": "def _handle_normal_command(self, cmd: CommandToBackend) -> None:\n        logger.info(\"Handling command '%s'\", cmd.name)\n        self._report_time(\"before \" + cmd.name)\n        assert isinstance(cmd, (ToplevelCommand, InlineCommand))\n\n        if \"local_cwd\" in cmd:\n            self._local_cwd = cmd[\"local_cwd\"]\n\n        def create_error_response(**kw):\n            if \"error\" not in kw:\n                kw[\"error\"] = traceback.format_exc()\n\n            if isinstance(cmd, ToplevelCommand):\n                return ToplevelResponse(command_name=cmd.name, **kw)\n            else:\n                return InlineResponse(command_name=cmd.name, **kw)\n\n        handler = getattr(self, \"_cmd_\" + cmd.name, None)\n\n        if handler is None:\n            response = create_error_response(error=\"Unknown command: \" + cmd.name)\n        else:\n            try:\n                response = handler(cmd)\n            except SystemExit as e:\n                # Must be caused by Thonny or plugins code\n                if isinstance(cmd, ToplevelCommand):\n                    logger.exception(\"Unexpected SystemExit\", exc_info=e)\n                response = create_error_response(SystemExit=True)\n            except UserError as e:\n                sys.stderr.write(str(e) + \"\\n\")\n                response = create_error_response()\n            except KeyboardInterrupt:\n                response = create_error_response(error=\"Interrupted\", interrupted=True)\n            except ConnectionClosedException as e:\n                self._on_connection_closed(e)\n            except ManagementError as e:\n                if \"KeyboardInterrupt\" in e.err:\n                    response = create_error_response(error=\"Interrupted\", interrupted=True)\n                else:\n                    self._send_output(\"THONNY FAILED TO EXECUTE COMMAND %s\\n\" % cmd.name, \"stderr\")\n                    # traceback.print_exc() # I'll know the trace from command\n                    self._show_error(\"\\n\")\n                    self._show_error(\"SCRIPT:\\n\" + e.script + \"\\n\")\n                    self._show_error(\"STDOUT:\\n\" + e.out + \"\\n\")\n                    self._show_error(\"STDERR:\\n\" + e.err + \"\\n\")\n\n                    response = create_error_response(error=\"ManagementError\")\n            except Exception as e:\n                _report_internal_error(e)\n                response = create_error_response(context_info=\"other unhandled exception\")\n\n        if response is None:\n            response = {}\n\n        if response is False:\n            # Command doesn't want to send any response\n            return\n\n        elif isinstance(response, dict):\n            if isinstance(cmd, ToplevelCommand):\n                response = ToplevelResponse(command_name=cmd.name, **response)\n            elif isinstance(cmd, InlineCommand):\n                response = InlineResponse(cmd.name, **response)\n\n        debug(\"cmd: \" + str(cmd) + \", respin: \" + str(response))\n        self.send_message(self._prepare_command_response(response, cmd))\n\n        self._check_perform_just_in_case_gc()\n\n        self._report_time(\"after \" + cmd.name)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Method of MicroPythonBackend that processes commands by dispatching them to specific handlers, managing errors, and sending formatted responses, enabling robust and flexible command execution management within the backend system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_should_keep_going", "line_number": 389, "body": "def _should_keep_going(self) -> bool:\n        return self._is_connected()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Utility method in MicroPythonBackend that indicates if the backend should continue operation based on its connection status. It helps manage ongoing processes by checking connectivity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_connected_to_microbit", "line_number": 395, "body": "def _connected_to_microbit(self):\n        return \"micro:bit\" in self._welcome_text.lower()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Checks if the current device connection is to a micro:bit by inspecting the welcome text. Useful for verifying device type before performing micro:bit-specific operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_connected_to_pyboard", "line_number": 398, "body": "def _connected_to_pyboard(self):\n        return \"pyb\" in self._welcome_text.lower() or \"pyb\" in self._builtin_modules", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Determines if the current MicroPython backend is connected to a Pyboard device by checking identifying keywords in its welcome text or built-in modules. This helps conditionally execute Pyboard-specific logic."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_connected_to_circuitpython", "line_number": 401, "body": "def _connected_to_circuitpython(self):\n        return \"circuitpython\" in self._welcome_text.lower()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Checks if the backend environment is running CircuitPython by detecting a specific identifier in the welcome text. This helps tailor operations based on the MicroPython variant in use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_connected_to_pycom", "line_number": 404, "body": "def _connected_to_pycom(self):\n        return \"pycom\" in self._welcome_text.lower()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Utility method of MicroPythonBackend that checks if the current device is a Pycom board by detecting \"pycom\" in its welcome text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_fetch_sys_path", "line_number": 413, "body": "def _fetch_sys_path(self):\n        if not self._supports_directories():\n            return []\n        else:\n            return self._evaluate(\"__thonny_helper.sys.path\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Internal utility of MicroPythonBackend that retrieves the system path if directory support is available, enabling environment inspection or module resolution within the MicroPython context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_fetch_builtins_info", "line_number": 419, "body": "def _fetch_builtins_info(self):\n        result = {}\n\n        for name in [\"builtins.py\", \"builtins.pyi\"]:\n            path = os.path.join(self._api_stubs_path, name)\n            if os.path.exists(path):\n                result = parse_api_information(path)\n\n        return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Internal method of MicroPythonBackend that retrieves parsed API information from existing built-in stub files, supporting introspection or documentation generation of MicroPython built-in modules."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_fetch_epoch_year", "line_number": 429, "body": "def _fetch_epoch_year(self):\n        if self._connected_to_microbit():\n            return None\n\n        # The proper solution would be to query time.gmtime, but most devices don't have this function.\n        # Luckily, time.localtime is good enough for deducing 1970 vs 2000 epoch.\n\n        # Most obvious solution would be to query for 0-time, but CP doesn't support anything below Y2000,\n        # so I'm querying this and adjusting later.\n        val = self._evaluate(\n            dedent(\n                \"\"\"\n            try:\n                from time import localtime as __thonny_localtime\n                __thonny_helper.print_mgmt_value(tuple(__thonny_localtime(%d)))\n                del __thonny_localtime\n            except Exception as e:\n                __thonny_helper.print_mgmt_value(str(e))\n        \"\"\"\n                % Y2000_EPOCH_OFFSET\n            )\n        )\n\n        if val[0] in (2000, 1999):\n            # when it gives 2000 (or end of 1999) for 2000-01-01 counted from Posix epoch, then it uses Posix epoch\n            # Used by Unix port, CP and Pycom\n            return 1970\n        elif val[0] in (2030, 2029):\n            # when it looks 30 years off, then it must be 2000 epoch\n            # Used by Pyboard and ESP-s\n            return 2000\n        else:\n            result = self._resolve_unknown_epoch()\n            if self._args.get(\"sync_time\") or self._args.get(\"validate_time\"):\n                print(\"WARNING: Could not determine epoch year (%s), assuming %s\" % (val, result))\n            return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Determines the epoch year (1970 or 2000) used by the connected MicroPython device to correctly interpret timestamps. This allows other functions to handle time data accurately despite differing device time standards."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_update_cwd", "line_number": 466, "body": "def _update_cwd(self):\n        if not self._connected_to_microbit():\n            self._cwd = self._evaluate(\"__thonny_helper.getcwd()\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Updates the current working directory by querying the MicroPython device when not connected to a Micro:bit, enabling the backend to track the device's file system context accurately."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_send_ready_message", "line_number": 470, "body": "def _send_ready_message(self):\n        args = dict(cwd=self._cwd)\n        args[\"welcome_text\"] = self._welcome_text\n\n        self.send_message(ToplevelResponse(**args))", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Utility method of MicroPythonBackend that constructs and sends a readiness notification message including the current working directory and welcome text. It informs connected clients that the backend is ready to operate."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "send_message", "line_number": 482, "body": "def send_message(self, msg: MessageFromBackend) -> None:\n        if \"cwd\" not in msg:\n            msg[\"cwd\"] = self._cwd\n\n        if \"sys_path\" not in msg:\n            msg[\"sys_path\"] = self._sys_path\n\n        if \"lib_dirs\" not in msg:\n            msg[\"lib_dirs\"] = self._get_library_paths()\n\n        super().send_message(msg)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Method of MicroPythonBackend that sends messages, automatically enriching them with current working directory, system path, and library directories to ensure contextual completeness before transmission."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_send_error_message", "line_number": 494, "body": "def _send_error_message(self, msg):\n        self._send_output(\"\\n\" + msg + \"\\n\", \"stderr\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Private helper method of MicroPythonBackend that sends error messages to the standard error output stream, facilitating error reporting within the backend's communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_execute", "line_number": 497, "body": "def _execute(self, script, capture_output=False) -> Tuple[str, str]:\n        if capture_output:\n            output_lists = {\"stdout\": [], \"stderr\": []}\n\n            def consume_output(data, stream_name):\n                assert isinstance(data, str)\n                output_lists[stream_name].append(data)\n\n            self._execute_with_consumer(script, consume_output)\n            result = [\"\".join(output_lists[name]) for name in [\"stdout\", \"stderr\"]]\n            return result[0], result[1]\n        else:\n            self._execute_with_consumer(script, self._send_output)\n            return \"\", \"\"", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Executes a MicroPython script, optionally capturing and returning its standard output and error streams as strings for further processing or inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_execute_without_output", "line_number": 529, "body": "def _execute_without_output(self, script):\n        \"\"\"Meant for management tasks.\"\"\"\n        out, err = self._execute(script, capture_output=True)\n        if out or err:\n            raise ManagementError(script, out, err)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Utility method in MicroPythonBackend that runs a script for management tasks without returning output, raising an error if any output or error occurs during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_evaluate", "line_number": 535, "body": "def _evaluate(self, script):\n        \"\"\"Evaluate the output of the script or raise ManagementError, if anything looks wrong.\n\n        Adds printing code if the script contains single expression and doesn't\n        already contain printing code\"\"\"\n        try:\n            ast.parse(script, mode=\"eval\")\n            prefix = \"__thonny_helper.print_mgmt_value(\"\n            suffix = \")\"\n            if not script.strip().startswith(prefix):\n                script = prefix + script + suffix\n        except SyntaxError:\n            pass\n\n        out, err = self._execute(script, capture_output=True)\n        if (\n            err\n            or MGMT_VALUE_START.decode(ENCODING) not in out\n            or MGMT_VALUE_END.decode(ENCODING) not in out\n        ):\n            raise ManagementError(script, out, err)\n\n        start_token_pos = out.index(MGMT_VALUE_START.decode(ENCODING))\n        end_token_pos = out.index(MGMT_VALUE_END.decode(ENCODING))\n\n        # a thread or IRQ handler may have written something before or after mgmt value\n        prefix = out[:start_token_pos]\n        value_str = out[start_token_pos + len(MGMT_VALUE_START) : end_token_pos]\n        suffix = out[end_token_pos + len(MGMT_VALUE_END) :]\n\n        try:\n            value = ast.literal_eval(value_str)\n            self._send_output(prefix, \"stdout\")\n            self._send_output(suffix, \"stdout\")\n            return value\n        except SyntaxError:\n            raise ManagementError(script, out, err)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Core method of MicroPythonBackend that evaluates a script expression, captures its output, and returns the evaluated result or raises a ManagementError if execution output is invalid or contains errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_check_for_side_commands", "line_number": 577, "body": "def _check_for_side_commands(self):\n        # NB! EOFCommand gets different treatment depending whether it is read during processing a command\n        # (ie. here) or it gets read when REPL is idle (ie. in mainloop)\n\n        # most likely the queue is empty\n        if self._incoming_message_queue.empty():\n            return\n\n        postponed = []\n        while not self._incoming_message_queue.empty():\n            cmd = self._incoming_message_queue.get()\n            if isinstance(cmd, InputSubmission):\n                self._submit_input(cmd.data)\n            elif isinstance(cmd, EOFCommand):\n                # in this context it is not supposed to soft-reboot\n                self._write(b\"\\x04\")\n            else:\n                postponed.append(cmd)\n\n        # put back postponed commands\n        while postponed:\n            self._incoming_message_queue.put(postponed.pop(0))", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Checks and processes specific command types from an incoming queue, handling input submissions and EOF signals while postponing other commands for later processing. This method manages side commands in a MicroPython REPL context to support input handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_supports_directories", "line_number": 600, "body": "def _supports_directories(self):\n        # NB! make sure self._cwd is queried first\n        return bool(self._cwd)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method checks whether the backend supports directory functionality by verifying if the current working directory is set. It informs other components about directory handling capability within the MicroPythonBackend context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_cd", "line_number": 604, "body": "def _cmd_cd(self, cmd):\n        if len(cmd.args) == 1:\n            if not self._supports_directories():\n                raise UserError(\"This device doesn't have directories\")\n\n            path = cmd.args[0]\n            self._execute(\"__thonny_helper.chdir(%r)\" % path)\n            self._update_cwd()\n            return {}\n        else:\n            raise UserError(\"%cd takes one parameter\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Private method of MicroPythonBackend that changes the current working directory on a device supporting directories, validating the command argument and updating the backend's directory state accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_execute_source", "line_number": 619, "body": "def _cmd_execute_source(self, cmd):\n        # TODO: clear last object inspector requests dictionary\n        if cmd.source:\n            source = self._add_expression_statement_handlers(cmd.source)\n            self._report_time(\"befexeccc\")\n            self._execute(source, capture_output=False)\n            self._check_prepare()\n            self._report_time(\"affexeccc\")\n        # TODO: assign last value to _\n        return {}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Internal method of MicroPythonBackend that executes given source code commands, handling expression statements and timing execution. It primarily supports running dynamic code snippets within the backend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_get_globals", "line_number": 633, "body": "def _cmd_get_globals(self, cmd):\n        if cmd.module_name == \"__main__\":\n            globs = self._evaluate(\n                \"{name : (__thonny_helper.repr(value), id(value)) for (name, value) in globals().items() if not name.startswith('__')}\"\n            )\n        else:\n            globs = self._evaluate(\n                dedent(\n                    \"\"\"\n                import %s as __mod_for_globs\n                __thonny_helper.print_mgmt_value(\n                    {name : (__thonny_helper.repr(getattr(__mod_for_globs, name)), \n                             id(getattr(__mod_for_globs, name)))\n                        in dir(__mod_for_globs) \n                        if not name.startswith('__')}\n                )\n                del __mod_for_globs\n            \"\"\"\n                )\n            )\n\n        value_infos = {}\n        for name, pair in globs.items():\n            value_infos[name] = ValueInfo(pair[1], pair[0])\n\n        return {\"module_name\": cmd.module_name, \"globals\": value_infos}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides a listing of global variables and their representations from a specified module or the __main__ module, enabling inspection of the module's global state and value identities for debugging or interactive use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_get_object_info", "line_number": 663, "body": "def _cmd_get_object_info(self, cmd):\n        context_id = cmd.get(\"context_id\", None)\n        basic_info = self._find_basic_object_info(cmd.object_id, context_id)\n        if basic_info is None:\n            return {\"id\": cmd.object_id, \"error\": \"object info not available\"}\n\n        type_name = basic_info[\"type\"].replace(\"<class '\", \"\").replace(\"'>\", \"\").strip()\n        info = {\n            \"id\": cmd.object_id,\n            \"repr\": basic_info[\"repr\"],\n            \"type\": basic_info[\"type\"],\n            \"full_type_name\": type_name,\n            \"attributes\": {},\n        }\n\n        info.update(self._get_object_info_extras(type_name))\n        if cmd.include_attributes:\n            info[\"attributes\"] = self._get_object_attributes(cmd.all_attributes)\n\n        # need to keep the reference corresponding to object_id so that it can be later found as next context object\n        # remove non-relevant items\n        # TODO: add back links\n        # relevant = set([cmd.object_id] + cmd.back_links + cmd.forward_links)\n        self._execute(\n            dedent(\n                \"\"\"\n                if id(__thonny_helper.object_info) not in __thonny_helper.inspector_values:\n                    __thonny_helper.inspector_values[id(__thonny_helper.object_info)] = __thonny_helper.object_info\n            \"\"\"\n            )\n        )\n\n        return {\"id\": cmd.object_id, \"info\": info}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides detailed information about a given object, including its type, representation, and optionally its attributes, facilitating object inspection and debugging within a MicroPython context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_find_basic_object_info", "line_number": 697, "body": "def _find_basic_object_info(self, object_id, context_id):\n        \"\"\"If object is found then returns basic info and leaves object reference\n        to __thonny_helper.object_info.\n\n        Can't leave it in a global object, because when querying globals(),\n        repr(globals()) would cause inifite recursion.\"\"\"\n\n        result = self._evaluate(\n            dedent(\n                \"\"\"\n                for __thonny_helper.object_info in (\n                        list(globals().values()) \n                        + __thonny_helper.last_repl_values\n                        + list(__thonny_helper.inspector_values.values())):\n                    if id(__thonny_helper.object_info) == %d:\n                        __thonny_helper.print_mgmt_value({\n                            \"repr\" : repr(__thonny_helper.object_info),\n                            \"type\": str(type(__thonny_helper.object_info))\n                        })\n                        break\n                else:\n                    __thonny_helper.object_info = None\n                    __thonny_helper.print_mgmt_value(None)\n            \"\"\"\n                % object_id\n            )\n        )\n\n        if result is not None:\n            return result\n        elif context_id is not None:\n            return self._evaluate(\n                dedent(\n                    \"\"\"\n                __thonny_helper.context_value = __thonny_helper.inspector_values.get(%d, None)\n                \n                if __thonny_helper.context_value is None:\n                    __thonny_helper.object_info = None\n                    __thonny_helper.print_mgmt_value(None)\n                else:\n                    __thonny_helper.context_children = [\n                         getattr(__thonny_helper.context_value, name)\n                         for name in dir(__thonny_helper.context_value)\n                    ]\n                    if isinstance(__thonny_helper.context_value, (set, tuple, list)):\n                        __thonny_helper.context_children += list(__thonny_helper.context_value)\n                    elif isinstance(__thonny_helper.context_value, dict):\n                        __thonny_helper.context_children += list(__thonny_helper.context_value.values())\n                    \n                    for __thonny_helper.object_info in __thonny_helper.context_children:\n                        if id(__thonny_helper.object_info) == %d:\n                            __thonny_helper.print_mgmt_value({\n                                \"repr\" : __thonny_helper.repr(__thonny_helper.object_info),\n                                \"type\": str(type(__thonny_helper.object_info))\n                            })\n                            break\n                    else:\n                        __thonny_helper.object_info = None\n                        \n                __thonny_helper.context_value = None\n                __thonny_helper.context_children = None\n            \"\"\"\n                    % (context_id, object_id)\n                )\n            )\n        else:\n            return None", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides basic information (type and string representation) about a Python object identified by its ID, searching global and contextual scopes to aid in object inspection within the MicroPythonBackend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_object_attributes", "line_number": 765, "body": "def _get_object_attributes(self, all_attributes):\n        \"\"\"object is given in __thonny_helper.object_info \"\"\"\n        atts = self._evaluate(\n            \"{name : (\"\n            \"   id(getattr(__thonny_helper.object_info, name)),\"\n            \"    __thonny_helper.repr(getattr(__thonny_helper.object_info, name))\"\n            \") for name in dir(__thonny_helper.object_info)}\"\n        )\n        return {\n            name: ValueInfo(atts[name][0], atts[name][1])\n            for name in atts\n            if not name.startswith(\"__\") or all_attributes\n        }", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Core utility of MicroPythonBackend that retrieves attribute names with their ids and string representations from a given object, optionally including all attributes or filtering out special ones."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_object_info_extras", "line_number": 779, "body": "def _get_object_info_extras(self, type_name):\n        \"\"\"object is given in __thonny_helper.object_info \"\"\"\n        if type_name in (\"list\", \"tuple\", \"set\"):\n            items = self._evaluate(\n                \"[(id(x), __thonny_helper.repr(x)) for x in __thonny_helper.object_info]\"\n            )\n            return {\"elements\": [ValueInfo(x[0], x[1]) for x in items]}\n        elif type_name == \"dict\":\n            items = self._evaluate(\n                \"[((id(key), __thonny_helper.repr(key)), (id(__thonny_helper.object_info[key]), \"\n                \"__thonny_helper.repr(__thonny_helper.object_info[key]))) for key in __thonny_helper.object_info]\"\n            )\n            return {\n                \"entries\": [\n                    (ValueInfo(x[0][0], x[0][1]), ValueInfo(x[1][0], x[1][1])) for x in items\n                ]\n            }\n        else:\n            return {}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides detailed extra information about container-type objects (list, tuple, set, dict) by extracting their elements or key-value entries, enhancing introspection capabilities in the MicroPythonBackend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_delete", "line_number": 799, "body": "def _cmd_delete(self, cmd):\n        assert cmd.paths\n        self._delete_sorted_paths(sorted(cmd.paths, key=len, reverse=True))", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Internal method of MicroPythonBackend that deletes specified file paths, prioritizing longer paths first to ensure proper removal order."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_get_active_distributions", "line_number": 803, "body": "def _cmd_get_active_distributions(self, cmd):\n        try:\n            dists = {}\n            for path in self._get_library_paths():\n                children = self._get_dir_children_info(path)\n                if children is None:\n                    continue\n                for name, info in children.items():\n                    if info[\"kind\"] == \"dir\":\n                        key = name\n                    elif name.endswith(\".py\"):\n                        key = name[:-3]\n                    elif name.endswith(\".mpy\"):\n                        key = name[:-4]\n                    else:\n                        continue\n\n                    dists[key] = {\n                        \"project_name\": key,\n                        \"key\": key,\n                        \"guessed_pypi_name\": self._guess_package_pypi_name(key),\n                        \"location\": path,\n                        \"version\": \"n/a\",\n                    }\n\n            return dict(\n                distributions=dists,\n                usersitepackages=None,\n            )\n        except Exception:\n            return InlineResponse(\"get_active_distributions\", error=traceback.format_exc())", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Returns information about active Python packages in library paths, including their names and guessed PyPI names, supporting package management or inspection in a MicroPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_get_module_info", "line_number": 835, "body": "def _cmd_get_module_info(self, cmd):\n        location = None\n        effective_items = []\n        shadowed_items = []\n\n        for lib_dir in self._get_library_paths():\n            dir_children = self._get_dir_children_info(lib_dir)\n            if not dir_children:\n                continue\n\n            # print(lib_dir, dir_children)\n\n            if cmd.module_name in dir_children and dir_children[cmd.module_name][\"kind\"] == \"dir\":\n                # dir takes precedence over .py and .mpy\n                # presence of __init__.py is not required\n                dir_full_path = lib_dir + \"/\" + cmd.module_name\n                descendants = self._get_dir_descendants_info(dir_full_path)\n                # print(\"desc\", dir_full_path, descendants)\n                desc_paths = list(sorted(descendants.keys()))\n\n                if not effective_items:  # ie. it's the first one found\n                    effective_items.append(dir_full_path)\n                    effective_items.extend(desc_paths)\n                    location = lib_dir\n                else:\n                    shadowed_items.extend(desc_paths)\n\n            for suffix in [\".py\", \".mpy\"]:\n                with_suffix = cmd.module_name + suffix\n                if with_suffix in dir_children and dir_children[with_suffix][\"kind\"] == \"file\":\n                    full_path = lib_dir + \"/\" + with_suffix\n                    if not effective_items:\n                        effective_items.append(full_path)\n                        location = lib_dir\n                    else:\n                        shadowed_items.append(full_path)\n\n        return {\n            \"location\": location,\n            \"effective_items\": effective_items,\n            \"shadowed_items\": shadowed_items,\n            \"module_name\": cmd.module_name,\n        }", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides detailed information about a MicroPython module's location and contents by identifying its effective and shadowed files or directories across library paths, supporting module resolution and inspection processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_library_paths", "line_number": 879, "body": "def _get_library_paths(self) -> [str]:\n        \"\"\"Returns list of directories which are supposed to contain library code\"\"\"\n        if self._sys_path is None:\n            return None\n\n        return [path for path in self._sys_path if \"lib\" in path and path.startswith(\"/\")]", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides a list of filesystem directories from the system path that are designated to hold library code, aiding in locating MicroPython library resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_guess_package_pypi_name", "line_number": 886, "body": "def _guess_package_pypi_name(self, installed_name) -> str:\n        return \"micropython-\" + installed_name", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Returns the expected PyPI package name for a MicroPython package based on its installed name, facilitating package identification or retrieval in MicroPython contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_mkdir", "line_number": 889, "body": "def _mkdir(self, path: str) -> None:\n        # assumes part path exists and path doesn't\n        self._execute_without_output(\"__thonny_helper.os.mkdir(%r)\" % path)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Private method in MicroPythonBackend that creates a new directory at a specified path, assuming the parent path exists. It provides filesystem management capabilities within the MicroPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_delete_sorted_paths", "line_number": 893, "body": "def _delete_sorted_paths(self, paths):\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n            def __thonny_delete(path):\n                if __thonny_helper.os.stat(path)[0] & 0o170000 == 0o040000:\n                    for name in __thonny_helper.listdir(path):\n                        child_path = path + \"/\" + name\n                        __thonny_delete(child_path)\n                    __thonny_helper.rmdir(path)\n                else:\n                    __thonny_helper.os.remove(path)\n            \n            for __thonny_path in %r: \n                __thonny_delete(__thonny_path)\n                \n            del __thonny_path\n            del __thonny_delete\n            \n        \"\"\"\n            )\n            % paths\n        )", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Core utility method of MicroPythonBackend that recursively deletes given filesystem paths, handling both files and directories, ensuring comprehensive removal of all specified paths without output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_stat", "line_number": 917, "body": "def _get_stat(\n        self, path: str\n    ) -> Optional[Tuple[int, int, int, int, int, int, int, int, int, int]]:\n        if not self._supports_directories():\n            func = \"size\"\n        else:\n            func = \"stat\"\n\n        stat = self._evaluate(\n            dedent(\n                \"\"\"\n            try:\n                __thonny_helper.print_mgmt_value(__thonny_helper.os.%s(%r))\n            except Exception:\n                __thonny_helper.print_mgmt_value(None)\n            \"\"\"\n            )\n            % (func, path)\n        )\n\n        if stat is None:\n            return None\n        elif isinstance(stat, int):\n            return (0b1000000000000000, 0, 0, 0, 0, 0, stat, 0, 0, 0)\n        else:\n            return stat", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Utility method in MicroPythonBackend that retrieves file or directory metadata for a given path, adapting to environments with or without directory support."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_mkdir", "line_number": 944, "body": "def _cmd_mkdir(self, cmd):\n        assert self._supports_directories()\n        assert cmd.path.startswith(\"/\")\n        assert not cmd.path.startswith(\"//\")\n        self._mkdir(cmd.path)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Internal method of MicroPythonBackend that validates and creates a directory at a specified absolute path, ensuring the backend supports directories before proceeding."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_editor_autocomplete", "line_number": 950, "body": "def _cmd_editor_autocomplete(self, cmd):\n        # template for the response\n        result = dict(source=cmd.source, row=cmd.row, column=cmd.column)\n\n        try:\n            from thonny import jedi_utils\n\n            completions = jedi_utils.get_script_completions(\n                cmd.source,\n                cmd.row,\n                cmd.column,\n                filename=cmd.filename,\n                sys_path=[self._api_stubs_path],\n            )\n            result[\"completions\"] = self._filter_completions(completions)\n        except Exception as e:\n            logger.exception(\"Problem with editor autocomplete\", exc_info=e)\n            result[\"error\"] = \"Autocomplete error\"\n\n        return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides autocompletion suggestions for editor commands by analyzing the given source code context, enhancing user typing efficiency with context-aware code completions in the MicroPythonBackend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_filter_completions", "line_number": 971, "body": "def _filter_completions(self, completions):\n        # filter out completions not applicable to MicroPython\n        result = []\n        for completion in completions:\n            if completion.name.startswith(\"__\"):\n                continue\n\n            if completion.parent() and completion.full_name:\n                parent_name = completion.parent().name\n                name = completion.name\n                root = completion.full_name.split(\".\")[0]\n\n                # jedi proposes names from CPython builtins\n                if root in self._builtins_info and name not in self._builtins_info[root]:\n                    continue\n\n                if parent_name == \"builtins\" and name not in self._builtins_info:\n                    continue\n\n            result.append({\"name\": completion.name, \"complete\": completion.complete})\n\n        return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Filters a list of code completions to exclude those not compatible with MicroPython, ensuring suggestions are relevant by removing unsupported builtins and special methods."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_shell_autocomplete", "line_number": 994, "body": "def _cmd_shell_autocomplete(self, cmd):\n        source = cmd.source\n\n        # TODO: combine dynamic results and jedi results\n        if source.strip().startswith(\"import \") or source.strip().startswith(\"from \"):\n            # this needs the power of jedi\n            response = {\"source\": cmd.source}\n\n            try:\n                from thonny import jedi_utils\n\n                # at the moment I'm assuming source is the code before cursor, not whole input\n                lines = source.split(\"\\n\")\n                completions = jedi_utils.get_script_completions(\n                    source, len(lines), len(lines[-1]), \"<shell>\", sys_path=[self._api_stubs_path]\n                )\n                response[\"completions\"] = self._filter_completions(completions)\n            except Exception as e:\n                logger.exception(\"Problem with shell autocomplete\", exc_info=e)\n                response[\"error\"] = \"Autocomplete error\"\n\n            return response\n        else:\n            # use live data\n            match = re.search(\n                r\"(\\w+\\.)*(\\w+)?$\", source\n            )  # https://github.com/takluyver/ubit_kernel/blob/master/ubit_kernel/kernel.py\n            if match:\n                prefix = match.group()\n                if \".\" in prefix:\n                    obj, prefix = prefix.rsplit(\".\", 1)\n                    names = self._evaluate(\n                        \"dir({obj}) if '{obj}' in locals() or '{obj}' in globals() else []\".format(\n                            obj=obj\n                        )\n                    )\n                else:\n                    names = self._evaluate(\"dir()\")\n            else:\n                names = []\n                prefix = \"\"\n\n            completions = []\n\n            # prevent TypeError (iterating over None)\n            names = names if names else []\n\n            for name in names:\n                if name.startswith(prefix) and not name.startswith(\"__\"):\n                    completions.append({\"name\": name, \"complete\": name[len(prefix) :]})\n\n            return {\"completions\": completions, \"source\": source}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides shell command autocompletion by generating possible completions for Python import statements using Jedi or live namespace introspection for other expressions, enhancing user interactive coding experience in a MicroPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_dump_api_info", "line_number": 1047, "body": "def _cmd_dump_api_info(self, cmd):\n        \"For use during development of the plug-in\"\n\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n            def __get_object_atts(obj):\n                result = []\n                errors = []\n                for name in dir(obj):\n                    try:\n                        val = getattr(obj, name)\n                        result.append((name, repr(val), repr(type(val))))\n                    except BaseException as e:\n                        errors.append(\"Couldn't get attr '%s' from object '%r', Err: %r\" % (name, obj, e))\n                return (result, errors)\n        \"\"\"\n            )\n        )\n\n        for module_name in sorted(self._fetch_builtin_modules()):\n            if (\n                not module_name.startswith(\"_\")\n                and not module_name.startswith(\"adafruit\")\n                # and not module_name == \"builtins\"\n            ):\n                file_name = os.path.join(\n                    self._api_stubs_path, module_name.replace(\".\", \"/\") + \".py\"\n                )\n                self._dump_module_stubs(module_name, file_name)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Utility method in MicroPythonBackend that dumps API information by introspecting built-in modules and generating stub files, aiding plug-in development and API exploration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_dump_module_stubs", "line_number": 1078, "body": "def _dump_module_stubs(self, module_name, file_name):\n        self._execute_without_output(\"import {0}\".format(module_name))\n\n        os.makedirs(os.path.dirname(file_name), exist_ok=True)\n        with io.open(file_name, \"w\", encoding=\"utf-8\", newline=\"\\n\") as fp:\n            if module_name not in [\n                \"webrepl\",\n                \"_webrepl\",\n                \"gc\",\n                \"http_client\",\n                \"http_client_ssl\",\n                \"http_server\",\n                \"framebuf\",\n                \"example_pub_button\",\n                \"flashbdev\",\n            ]:\n                self._dump_object_stubs(fp, module_name, \"\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Core method of MicroPythonBackend that imports a module and generates its stub file, creating necessary directories and selectively skipping specific modules to aid in module interface representation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_dump_object_stubs", "line_number": 1096, "body": "def _dump_object_stubs(self, fp, object_expr, indent):\n        if object_expr in [\n            \"docs.conf\",\n            \"pulseio.PWMOut\",\n            \"adafruit_hid\",\n            \"upysh\",\n            # \"webrepl\",\n            # \"gc\",\n            # \"http_client\",\n            # \"http_server\",\n        ]:\n            print(\"SKIPPING problematic name:\", object_expr)\n            return\n\n        print(\"DUMPING\", indent, object_expr)\n        items, errors = self._evaluate(\"__get_object_atts({0})\".format(object_expr))\n\n        if errors:\n            print(\"ERRORS\", errors)\n\n        for name, rep, typ in sorted(items, key=lambda x: x[0]):\n            if name.startswith(\"__\"):\n                continue\n\n            print(\"DUMPING\", indent, object_expr, name)\n            print(\"  * \" + name + \" : \" + typ)\n\n            if typ in [\"<class 'function'>\", \"<class 'bound_method'>\"]:\n                fp.write(indent + \"def \" + name + \"():\\n\")\n                fp.write(indent + \"    pass\\n\\n\")\n            elif typ in [\"<class 'str'>\", \"<class 'int'>\", \"<class 'float'>\"]:\n                fp.write(indent + name + \" = \" + rep + \"\\n\")\n            elif typ == \"<class 'type'>\" and indent == \"\":\n                # full expansion only on toplevel\n                fp.write(\"\\n\")\n                fp.write(indent + \"class \" + name + \":\\n\")  # What about superclass?\n                fp.write(indent + \"    ''\\n\")\n                self._dump_object_stubs(fp, \"{0}.{1}\".format(object_expr, name), indent + \"    \")\n            else:\n                # keep only the name\n                fp.write(indent + name + \" = None\\n\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Generates Python stub definitions for an object's attributes, writing them to a file-like object; it helps create skeletal code representations for functions, classes, and variables for tools like code completion or static analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_join_remote_path_parts", "line_number": 1138, "body": "def _join_remote_path_parts(self, left, right):\n        if left == \"\":  # micro:bit\n            assert not self._supports_directories()\n            return right.strip(\"/\")\n\n        return left.rstrip(\"/\") + \"/\" + right.strip(\"/\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Private helper method in MicroPythonBackend that constructs a valid remote file path by joining two path segments while handling platform-specific directory support and formatting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_file_size", "line_number": 1145, "body": "def _get_file_size(self, path: str) -> int:\n        stat = self._get_stat(path)\n        if stat is None:\n            raise RuntimeError(\"Path '%s' does not exist\" % path)\n\n        return stat[STAT_SIZE_INDEX]", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Utility function in MicroPythonBackend that returns the file size in bytes for a given path, raising an error if the path does not exist."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_stat_mode", "line_number": 1152, "body": "def _get_stat_mode(self, path: str) -> Optional[int]:\n        stat = self._get_stat(path)\n        if stat is None:\n            return None\n        return stat[0]", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides the file mode (permission and type information) for a given path by retrieving and extracting stat data. Useful for checking file attributes within the MicroPythonBackend context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_path_info", "line_number": 1158, "body": "def _get_path_info(self, path: str) -> Optional[Dict]:\n        stat = self._get_stat(path)\n\n        if stat is None:\n            return None\n\n        _, basename = unix_dirname_basename(path)\n        return self._expand_stat(stat, basename)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Internal helper method of MicroPythonBackend that retrieves and expands file or directory metadata for a given path, returning detailed information if the path exists."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_dir_children_info", "line_number": 1167, "body": "def _get_dir_children_info(\n        self, path: str, include_hidden: bool = False\n    ) -> Optional[Dict[str, Dict]]:\n        \"\"\"The key of the result dict is simple name\"\"\"\n        if self._supports_directories():\n            raw_data = self._evaluate(\n                dedent(\n                    \"\"\"\n                __thonny_result = {} \n                try:\n                    __thonny_names = __thonny_helper.listdir(%r)\n                except OSError:\n                    __thonny_helper.print_mgmt_value(None) \n                else:\n                    for __thonny_name in __thonny_names:\n                        if not __thonny_name.startswith(\".\") or %r:\n                            try:\n                                __thonny_result[__thonny_name] = __thonny_helper.os.stat(%r + __thonny_name)\n                            except OSError as e:\n                                __thonny_result[__thonny_name] = str(e)\n                    __thonny_helper.print_mgmt_value(__thonny_result)\n            \"\"\"\n                )\n                % (path, include_hidden, path.rstrip(\"/\") + \"/\")\n            )\n            if raw_data is None:\n                return None\n        elif path == \"\":\n            # used to represent all files in micro:bit\n            raw_data = self._evaluate(\n                \"{name : __thonny_helper.os.size(name) for name in __thonny_helper.os.listdir()}\"\n            )\n        else:\n            return None\n\n        return {name: self._expand_stat(raw_data[name], name) for name in raw_data}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides detailed information about files and directories within a given path on a MicroPython device, optionally including hidden files, supporting directory listing and file metadata retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_on_connection_closed", "line_number": 1204, "body": "def _on_connection_closed(self, error=None):\n        self._forward_unexpected_output(\"stderr\")\n        message = \"Connection lost\"\n        if error:\n            message += \" (\" + str(error) + \")\"\n        self._send_output(\"\\n\" + message + \"\\n\", \"stderr\")\n        self._send_output(\"\\n\" + \"Use Stop/Restart to reconnect.\" + \"\\n\", \"stderr\")\n        sys.exit(EXPECTED_TERMINATION_CODE)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Handles cleanup and user notification when the MicroPython backend connection closes unexpectedly, signaling termination and prompting reconnection actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_show_error", "line_number": 1213, "body": "def _show_error(self, msg):\n        self._send_output(msg + \"\\n\", \"stderr\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Private helper method that outputs error messages to the standard error stream for displaying or logging within the MicroPythonBackend context. It standardizes error reporting across the backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_add_expression_statement_handlers", "line_number": 1216, "body": "def _add_expression_statement_handlers(self, source):\n        try:\n            root = ast.parse(source)\n\n            from thonny.ast_utils import mark_text_ranges\n\n            mark_text_ranges(root, source)\n\n            expr_stmts = []\n            for node in ast.walk(root):\n                if isinstance(node, ast.Expr):\n                    expr_stmts.append(node)\n\n            marker_prefix = \"__thonny_helper.print_repl_value(\"\n            marker_suffix = \")\"\n\n            lines = source.splitlines(keepends=True)\n            for node in reversed(expr_stmts):\n                lines[node.end_lineno - 1] = (\n                    lines[node.end_lineno - 1][: node.end_col_offset]\n                    + marker_suffix\n                    + lines[node.end_lineno - 1][node.end_col_offset :]\n                )\n\n                lines[node.lineno - 1] = (\n                    lines[node.lineno - 1][: node.col_offset]\n                    + marker_prefix\n                    + lines[node.lineno - 1][node.col_offset :]\n                )\n\n            new_source = \"\".join(lines)\n            # make sure it parses\n            ast.parse(new_source)\n            return new_source\n        except SyntaxError:\n            return source\n        except Exception as e:\n            logger.warning(\"Problem adding Expr handlers\", exc_info=e)\n            return source", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "In the MicroPythonBackend class, this function transforms standalone expressions in the source code to include calls that print their values, enabling interactive expression evaluation and result display within a REPL environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_avoid_printing_expression_statements", "line_number": 1256, "body": "def _avoid_printing_expression_statements(self, source):\n        # temporary solution for https://github.com/thonny/thonny/issues/1441\n        try:\n            root = ast.parse(source)\n\n            from thonny.ast_utils import mark_text_ranges\n\n            mark_text_ranges(root, source)\n\n            expr_stmts = []\n            for node in ast.walk(root):\n                if isinstance(node, ast.Expr):\n                    expr_stmts.append(node)\n\n            marker_prefix = \"\"\n            marker_suffix = \" and None or None\"\n\n            lines = source.splitlines(keepends=True)\n            for node in reversed(expr_stmts):\n                lines[node.end_lineno - 1] = (\n                    lines[node.end_lineno - 1][: node.end_col_offset]\n                    + marker_suffix\n                    + lines[node.end_lineno - 1][node.end_col_offset :]\n                )\n\n                lines[node.lineno - 1] = (\n                    lines[node.lineno - 1][: node.col_offset]\n                    + marker_prefix\n                    + lines[node.lineno - 1][node.col_offset :]\n                )\n\n            new_source = \"\".join(lines)\n            # make sure it parses\n            ast.parse(new_source)\n            return new_source\n        except SyntaxError:\n            return source\n        except Exception as e:\n            logger.warning(\"Problem adding Expr handlers\", exc_info=e)\n            return source", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Modifies Python source code to prevent expression statements from printing their results, ensuring compatibility with MicroPython execution. This serves as a workaround to control output behavior in the MicroPythonBackend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_report_time", "line_number": 1297, "body": "def _report_time(self, caption):\n        new_time = time.time()\n        # print(\"TIME %s: %.3f\" % (caption, new_time - self._prev_time))\n        self._prev_time = new_time", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Private method in MicroPythonBackend that records the current time under a given caption, supporting performance measurement or timing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_system_time_to_posix_time", "line_number": 1302, "body": "def _system_time_to_posix_time(self, value: float) -> float:\n        result = value + self._get_epoch_offset()\n        if not self._args[\"utc_clock\"]:\n            # convert to UTC\n            result += time.timezone\n\n        return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Converts a system-specific time value to POSIX (Unix) time, adjusting for epoch offset and optionally converting local time to UTC. Useful for consistent timestamp handling across different time representations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_epoch_offset", "line_number": 1310, "body": "def _get_epoch_offset(self) -> int:\n        if self._epoch_year == 1970:\n            return 0\n        elif self._epoch_year == 2000:\n            return Y2000_EPOCH_OFFSET\n        else:\n            raise NotImplementedError()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Private method within MicroPythonBackend that returns the time offset based on the configured epoch year, supporting 1970 and 2000 epochs for time calculations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_expand_stat", "line_number": 1318, "body": "def _expand_stat(self, stat: Union[Tuple, int, str], basename: str) -> Dict:\n        error = None\n        if isinstance(stat, int):\n            # file size is only info available for micro:bit files\n            size = stat\n            modified = None\n            kind = \"file\"\n        elif isinstance(stat, str):\n            kind = None\n            size = None\n            modified = None\n            error = stat\n        else:\n            assert isinstance(stat, tuple)\n            if stat[STAT_KIND_INDEX] & 0o170000 == 0o040000:\n                kind = \"dir\"\n                size = None\n            else:\n                kind = \"file\"\n                size = stat[STAT_SIZE_INDEX]\n\n            modified = self._system_time_to_posix_time(stat[STAT_MTIME_INDEX])\n\n        result = {\n            \"kind\": kind,\n            \"size\": size,\n            \"modified\": modified,\n            \"hidden\": basename.startswith(\".\"),\n        }\n        if error:\n            result[\"error\"] = error\n        return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Method in MicroPythonBackend that interprets and normalizes file system metadata into a consistent dictionary format describing file type, size, modification time, and visibility, handling errors gracefully for microcontroller environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_decode", "line_number": 1351, "body": "def _decode(self, data: bytes) -> str:\n        return data.decode(encoding=\"UTF-8\", errors=\"replace\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Utility method in MicroPythonBackend that decodes byte data into a UTF-8 string, ensuring decoding errors are safely replaced for reliable text conversion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "create_error_response", "line_number": 325, "body": "def create_error_response(**kw):\n            if \"error\" not in kw:\n                kw[\"error\"] = traceback.format_exc()\n\n            if isinstance(cmd, ToplevelCommand):\n                return ToplevelResponse(command_name=cmd.name, **kw)\n            else:\n                return InlineResponse(command_name=cmd.name, **kw)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Constructs and returns an appropriate error response object containing error details, distinguishing between top-level and inline command contexts for the MicroPythonBackend class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "consume_output", "line_number": 501, "body": "def consume_output(data, stream_name):\n                assert isinstance(data, str)\n                output_lists[stream_name].append(data)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Appends string data to a designated output list based on the stream name, facilitating organized collection of stream-specific output in MicroPythonBackend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "starts_with_continuation_byte", "line_number": 1552, "body": "def starts_with_continuation_byte(data):\n    return data and is_continuation_byte(data[0])", "is_method": false, "function_description": "Determines if the first byte in the given data is a UTF-8 continuation byte, enabling validation or parsing of multi-byte character sequences."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "is_continuation_byte", "line_number": 1556, "body": "def is_continuation_byte(byte):\n    return (byte & 0b11000000) == 0b10000000", "is_method": false, "function_description": "Checks if a given byte is a UTF-8 continuation byte, which is useful for validating or parsing UTF-8 encoded data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_check_prepare", "line_number": 157, "body": "def _check_prepare(self):\n        out, err = self._execute(\"print('__thonny_helper' in dir())\", capture_output=True)\n        if out.strip() == \"True\":\n            return\n\n        self._prepare_after_soft_reboot(False)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Private method in BareMetalMicroPythonBackend that verifies whether the environment is prepared by checking for a helper object and triggers preparation steps after a soft reboot if needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_custom_helpers", "line_number": 164, "body": "def _get_custom_helpers(self):\n        if self._connected_to_microbit():\n            return \"\"\n\n        return dedent(\n            \"\"\"\n            @classmethod\n            def getcwd(cls):\n                if hasattr(cls, \"getcwd\"):\n                    return cls.os.getcwd()\n                else:\n                    # micro:bit\n                    return \"\"\n            \n            @classmethod\n            def chdir(cls, x):\n                return cls.os.chdir(x)\n            \n            @classmethod\n            def rmdir(cls, x):\n                return cls.os.rmdir(x)\n        \"\"\"\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provides custom OS-related helper methods for MicroPython backends, supplying dummy or adapted implementations depending on the target device connection status. Useful for ensuring consistent filesystem method availability across different MicroPython platforms."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_process_until_initial_prompt", "line_number": 188, "body": "def _process_until_initial_prompt(self, clean):\n        logger.debug(\"_process_until_initial_prompt, clean=%s\", clean)\n        if clean:\n            self._interrupt_to_raw_prompt()\n            self._soft_reboot_in_raw_prompt_without_running_main()\n        else:\n            # Discard what's printed by now and order a prompt, so that we get to know\n            # if the REPL is already idle\n            discarded = self._connection.read_all()\n            self._write(RAW_MODE_CMD)\n            self._forward_output_until_active_prompt(self._send_output)\n\n        if self._submit_mode is None:\n            self._choose_submit_mode()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Method of BareMetalMicroPythonBackend that prepares the MicroPython REPL until it reaches the initial prompt, optionally resetting the environment or clearing output to ensure the REPL is ready for further commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_choose_submit_mode", "line_number": 203, "body": "def _choose_submit_mode(self):\n        if self._connected_over_webrepl():\n            logger.info(\"Choosing paste submit mode because of WebREPL\")\n            self._submit_mode = PASTE_SUBMIT_MODE\n            return\n\n        # at least sometimes, we end up at normal prompt, although we asked for raw prompt\n        self._ensure_raw_mode()\n        self._write(RAW_PASTE_COMMAND)\n        response = self._connection.soft_read(2)\n        assert len(response) == 2, \"Could not read response for raw paste command: \" + response\n        if response == RAW_PASTE_CONFIRMATION:\n            logger.info(\"Choosing raw paste submit mode\")\n            self._submit_mode = RAW_PASTE_SUBMIT_MODE\n            self._write(EOT)\n            discarding = self._connection.read_until(RAW_PROMPT)\n        else:\n            discarding = self._connection.read_until(RAW_PROMPT)\n            logger.info(\"Choosing raw submit mode (%r)\", response + discarding)\n            self._submit_mode = RAW_SUBMIT_MODE\n\n        discarding += self._connection.read_all()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Determines and sets the appropriate code submission mode based on connection type and prompt response, optimizing how commands are sent to a BareMetalMicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_fetch_welcome_text", "line_number": 226, "body": "def _fetch_welcome_text(self) -> str:\n        self._write(NORMAL_MODE_CMD)\n        out, err = self._capture_output_until_active_prompt()\n        welcome_text = out.strip(\"\\r\\n >\")\n        if os.name != \"nt\":\n            welcome_text = welcome_text.replace(\"\\r\\n\", \"\\n\")\n\n        return welcome_text", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Utility method in BareMetalMicroPythonBackend that retrieves and cleans the initial welcome message from the device's command-line interface upon connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_fetch_builtin_modules", "line_number": 235, "body": "def _fetch_builtin_modules(self):\n        script = \"help('modules')\"\n        out, err = self._execute(script, capture_output=True)\n        if err or not out:\n            self._send_error_message(\n                \"Could not query builtin modules. Code completion may not work properly.\"\n            )\n            return FALLBACK_BUILTIN_MODULES\n\n        modules_str_lines = out.strip().splitlines()\n\n        last_line = modules_str_lines[-1].strip()\n        if last_line.count(\" \") > 0 and \"  \" not in last_line and \"\\t\" not in last_line:\n            # probably something like \"plus any modules on the filesystem\"\n            # (can be in different languages)\n            modules_str_lines = modules_str_lines[:-1]\n\n        modules_str = (\n            \" \".join(modules_str_lines)\n            .replace(\"/__init__\", \"\")\n            .replace(\"__main__\", \"\")\n            .replace(\"/\", \".\")\n        )\n\n        return modules_str.split()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provides a list of available builtin modules from a MicroPython environment by querying the system, enabling features like code completion and module introspection. Returns a fallback module list if the query fails."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_resolve_unknown_epoch", "line_number": 261, "body": "def _resolve_unknown_epoch(self) -> int:\n        if self._connected_to_circuitpython() or self._connected_to_pycom():\n            return 1970\n        else:\n            return 2000", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Determines the default epoch year based on the connected device type, returning 1970 for CircuitPython or Pycom and 2000 otherwise. This aids in time-related operations specific to the device environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_sync_time", "line_number": 267, "body": "def _sync_time(self):\n        \"\"\"Sets the time to match the time on the host.\"\"\"\n\n        now = self._get_time_for_rtc()\n\n        if self._connected_to_microbit():\n            return\n        elif self._connected_to_circuitpython():\n            specific_script = dedent(\n                \"\"\"\n                from rtc import RTC as __thonny_RTC\n                __thonny_RTC().datetime = {ts}\n                del __thonny_RTC\n            \"\"\"\n            ).format(ts=tuple(now))\n        else:\n            specific_script = dedent(\n                \"\"\"\n                from machine import RTC as __thonny_RTC\n                try:\n                    __thonny_RTC().datetime({datetime_ts})\n                except:\n                    __thonny_RTC().init({init_ts})\n                del __thonny_RTC\n\n            \"\"\"\n            ).format(\n                datetime_ts=(\n                    now.tm_year,\n                    now.tm_mon,\n                    now.tm_mday,\n                    now.tm_wday + 1,\n                    now.tm_hour,\n                    now.tm_min,\n                    now.tm_sec,\n                    0,\n                ),\n                init_ts=tuple(now)[:6] + (0, 0),\n            )\n\n        script = (\n            dedent(\n                \"\"\"\n            try:\n            %s\n                __thonny_helper.print_mgmt_value(True)\n            except Exception as e:\n                __thonny_helper.print_mgmt_value(str(e))\n        \"\"\"\n            )\n            % indent(specific_script, \"    \")\n        )\n\n        val = self._evaluate(script)\n        if isinstance(val, str):\n            print(\"WARNING: Could not sync device's clock: \" + val)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Synchronizes the device's real-time clock to match the host system time across different MicroPython backends. It enables accurate timekeeping on connected microcontroller devices by executing backend-specific synchronization scripts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_utc_timetuple_from_device", "line_number": 324, "body": "def _get_utc_timetuple_from_device(self) -> Union[tuple, str]:\n        if self._connected_to_microbit():\n            return \"This device does not have a real-time clock\"\n        elif self._connected_to_circuitpython():\n            specific_script = dedent(\n                \"\"\"\n                from rtc import RTC as __thonny_RTC\n                __thonny_helper.print_mgmt_value(tuple(__thonny_RTC().datetime)[:6])\n                del __thonny_RTC\n                \"\"\"\n            )\n        else:\n            specific_script = dedent(\n                \"\"\"\n                from machine import RTC as __thonny_RTC\n                try:\n                    # now() on some devices also gives weekday, so prefer datetime\n                    __thonny_temp = tuple(__thonny_RTC().datetime())\n                    # remove weekday from index 3\n                    __thonny_helper.print_mgmt_value(__thonny_temp[0:3] + __thonny_temp[4:7])\n                    del __thonny_temp\n                except:\n                    __thonny_helper.print_mgmt_value(tuple(__thonny_RTC().now())[:6])\n                del __thonny_RTC\n                \"\"\"\n            )\n\n        script = (\n            dedent(\n                \"\"\"\n            try:\n            %s\n            except Exception as e:\n                __thonny_helper.print_mgmt_value(str(e))\n        \"\"\"\n            )\n            % indent(specific_script, \"    \")\n        )\n\n        val = self._evaluate(script)\n        return val", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Retrieves the current UTC date and time tuple from a connected MicroPython device, adapting to different device types or returning an error message if unsupported. Useful for synchronizing or timestamping operations with device-specific real-time clocks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_actual_time_tuple_on_device", "line_number": 366, "body": "def _get_actual_time_tuple_on_device(self):\n        script = dedent(\n            \"\"\"\n            try:\n                try:\n                    from time import localtime as __thonny_localtime\n                    __thonny_helper.print_mgmt_value(tuple(__thonny_localtime()))\n                    del __thonny_localtime\n                except:\n                    # some CP boards\n                    from rtc import RTC as __thonny_RTC\n                    __thonny_helper.print_mgmt_value(tuple(__thonny_RTC().datetime))\n                    del __thonny_RTC\n            except Exception as e:\n                __thonny_helper.print_mgmt_value(str(e))\n        \"\"\"\n        )\n\n        return self._evaluate(script)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Utility method of BareMetalMicroPythonBackend that retrieves the current local time tuple directly from a MicroPython device, accommodating different time sources on various boards."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_update_cwd", "line_number": 386, "body": "def _update_cwd(self):\n        if self._connected_to_microbit():\n            self._cwd = \"\"\n        else:\n            super()._update_cwd()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Updates the current working directory based on connection status, setting it to empty when connected to the microbit or delegating to the parent method otherwise. This supports managing file paths appropriately for different execution environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_handle_eof_command", "line_number": 392, "body": "def _handle_eof_command(self, msg: EOFCommand) -> None:\n        self._soft_reboot_for_restarting_user_program()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Handles the end-of-file command by performing a soft reboot to restart the user program in the BareMetalMicroPythonBackend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_interrupt_to_raw_prompt", "line_number": 395, "body": "def _interrupt_to_raw_prompt(self):\n        # NB! Sometimes disconnecting and reconnecting (on macOS?)\n        # too quickly causes anomalies. See CalliopeMiniProxy for more details\n        logger.debug(\"_interrupt_to_raw_prompt\")\n        discarded_bytes = b\"\"\n\n        for delay in [0.05, 0.5, 0.1, 1.0, 3.0, 5.0]:\n            # Interrupt several times, because with some drivers first interrupts seem to vanish\n            if delay >= 1:\n                self._show_error(\n                    \"Could not enter REPL. Trying again with %d second waiting time...\" % delay\n                )\n            self._connection.reset_output_buffer()  # cancels previous writes\n            self._write(INTERRUPT_CMD)\n            self._write(RAW_MODE_CMD)\n            time.sleep(delay)\n            self._capture_output_until_active_prompt()\n            if self._last_prompt in [FIRST_RAW_PROMPT, W600_FIRST_RAW_PROMPT]:\n                break\n        else:\n            max_tail_length = 500\n            if len(discarded_bytes) > max_tail_length:\n                discarded_bytes_str = (\n                    \"[skipping %d bytes] ...\" % (len(discarded_bytes) - max_tail_length)\n                ) + repr(discarded_bytes[:-max_tail_length])\n            else:\n                discarded_bytes_str = repr(discarded_bytes)\n            self._show_error(\n                \"Could not enter REPL. Giving up. Read bytes:\\n\"\n                + discarded_bytes_str\n                + \"\\n\\nYour options:\\n\\n\"\n                + \"  - check connection properties;\\n\"\n                + \"  - make sure the device has suitable firmware;\\n\"\n                + \"  - make sure the device is not in bootloader mode;\\n\"\n                + \"  - reset the device and try again;\\n\"\n                + \"  - try other serial clients (Putty, TeraTerm, screen, ...);\\n\"\n                + \"  - ask for help in Thonny's forum or issue tracker.\"\n            )\n            sys.exit()\n\n        logger.debug(\"Done _interrupt_to_raw_prompt\")", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Method of BareMetalMicroPythonBackend that attempts to reliably interrupt the device and enter raw REPL mode, ensuring a direct communication prompt for executing low-level commands. It handles retries and reports connection issues if entering raw REPL fails."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_soft_reboot_in_raw_prompt_without_running_main", "line_number": 437, "body": "def _soft_reboot_in_raw_prompt_without_running_main(self):\n        logger.debug(\"_soft_reboot_in_raw_prompt_without_running_main\")\n        self._write(SOFT_REBOOT_CMD + INTERRUPT_CMD)\n        self._check_reconnect()\n        self._capture_output_until_active_prompt()\n\n        logger.debug(\"Done soft reboot in raw prompt\")", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Private method in BareMetalMicroPythonBackend that performs a soft reboot into raw REPL mode without executing the main script, preparing the device for direct command input or interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_ensure_raw_mode", "line_number": 445, "body": "def _ensure_raw_mode(self):\n        if self._last_prompt in [\n            RAW_PROMPT,\n            EOT + RAW_PROMPT,\n            FIRST_RAW_PROMPT,\n            W600_FIRST_RAW_PROMPT,\n        ]:\n            return\n        logger.debug(\"requesting raw mode at %r\", self._last_prompt)\n\n        # assuming we are currently on a normal prompt\n        self._write(RAW_MODE_CMD)\n        out, err = self._capture_output_until_active_prompt()\n        if self._last_prompt == NORMAL_PROMPT:\n            # Don't know why this happens sometimes (eg. when interrupting a Ctrl+D or restarted\n            # program, which is outputting text on ESP32)\n            logger.info(\"Found normal prompt instead of expected raw prompt. Trying again.\")\n            self._write(RAW_MODE_CMD)\n            time.sleep(0.5)\n            out, err = self._capture_output_until_active_prompt()\n\n        if self._last_prompt not in [FIRST_RAW_PROMPT, W600_FIRST_RAW_PROMPT]:\n            raise AssertionError(\n                \"Could not enter raw prompt, got %r\"\n                % ((out + err).encode(ENCODING) + self._last_prompt)\n            )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Ensures the device is operating in raw input mode by sending the appropriate command and verifying the prompt, facilitating direct and uninterrupted interaction with the hardware's MicroPython interpreter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_ensure_normal_mode", "line_number": 472, "body": "def _ensure_normal_mode(self):\n        if self._last_prompt == NORMAL_PROMPT:\n            return\n\n        logger.debug(\"requesting normal mode at %r\", self._last_prompt)\n        self._write(NORMAL_MODE_CMD)\n        self._capture_output_until_active_prompt()\n        assert self._last_prompt == NORMAL_PROMPT, (\n            \"Could not get normal prompt, got %s\" % self._last_prompt\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Core method of BareMetalMicroPythonBackend that ensures the system is in normal interactive mode, facilitating consistent command execution by switching prompts if necessary."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_soft_reboot_without_running_main", "line_number": 483, "body": "def _soft_reboot_without_running_main(self):\n        logger.debug(\"_soft_reboot_without_running_main\")\n        self._interrupt_to_raw_prompt()\n        self._soft_reboot_in_raw_prompt_without_running_main()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Internal method of BareMetalMicroPythonBackend that performs a soft reboot without executing the main script, enabling device reset while preserving a raw prompt state for further commands or debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_soft_reboot_for_restarting_user_program", "line_number": 488, "body": "def _soft_reboot_for_restarting_user_program(self):\n        # Need to go to normal mode. MP doesn't run user code in raw mode\n        # (CP does, but it doesn't hurt to do it there as well)\n        self._ensure_normal_mode()\n        self._write(SOFT_REBOOT_CMD)\n        self._check_reconnect()\n        self._forward_output_until_active_prompt(self._send_output)\n        logger.debug(\"Restoring helpers\")\n        self._prepare_after_soft_reboot(False)\n        self.send_message(ToplevelResponse(cwd=self._cwd))", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Triggers a controlled soft reboot of a MicroPython device to exit raw mode and restart the user program, ensuring the device is ready for interaction and restoring necessary helpers after reboot."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_check_reconnect", "line_number": 499, "body": "def _check_reconnect(self):\n        if self._connected_over_webrepl():\n            time.sleep(1)\n            self._connection = self._connection.close_and_return_new_connection()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Internal method of BareMetalMicroPythonBackend that ensures reconnection over WebREPL by closing and re-establishing the connection when needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_connected_over_webrepl", "line_number": 504, "body": "def _connected_over_webrepl(self):\n        from thonny.plugins.micropython.webrepl_connection import WebReplConnection\n\n        return isinstance(self._connection, WebReplConnection)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Checks if the current connection is established via WebREPL, indicating the communication method used by the BareMetalMicroPythonBackend. This helps manage WebREPL-specific behaviors or features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_transform_output", "line_number": 509, "body": "def _transform_output(self, data, stream_name):\n        # Any keypress wouldn't work\n        return data.replace(\n            \"Press any key to enter the REPL. Use CTRL-D to reload.\",\n            \"Press Ctrl-C to enter the REPL. Use CTRL-D to reload.\",\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Utility method in BareMetalMicroPythonBackend that modifies specific output text prompts for clarity, replacing keypress instructions with recommended control key commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_write", "line_number": 516, "body": "def _write(self, data):\n        self._connection.write(data)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Private method in BareMetalMicroPythonBackend that sends data through the backend's connection interface, enabling data transmission over the established communication channel."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_submit_input", "line_number": 519, "body": "def _submit_input(self, cdata: str) -> None:\n        # TODO: what if there is a previous unused data waiting\n        assert self._connection.outgoing_is_empty()\n\n        assert cdata.endswith(\"\\n\")\n        if not cdata.endswith(\"\\r\\n\"):\n            # submission is done with CRLF\n            cdata = cdata[:-1] + \"\\r\\n\"\n\n        bdata = cdata.encode(ENCODING)\n        to_be_written = bdata\n        echo = b\"\"\n        with self._interrupt_lock:\n            while to_be_written:\n                block = self._extract_block_without_splitting_chars(to_be_written)\n                self._write(to_be_written)\n                # Try to consume the echo\n                echo += self._connection.soft_read(len(block), timeout=1)\n                to_be_written = to_be_written[len(block) :]\n\n        if echo != bdata:\n            # because of autoreload? timing problems? interruption?\n            # Leave it.\n            logging.warning(\"Unexpected echo. Expected %r, got %r\" % (bdata, echo))\n            self._connection.unread(echo)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Core method of BareMetalMicroPythonBackend that sends a command string over a connection ensuring proper line endings and handles echoed responses to maintain communication synchronization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_submit_code", "line_number": 545, "body": "def _submit_code(self, script):\n        \"\"\"\n        Code is submitted via paste mode, because this provides echo, which can be used as flow control.\n\n        The echo of a written block must be read before next block is written.\n        Safe USB block size is 64 bytes (may be larger for some devices),\n        but we need to account for b\"=== \" added by the paste mode in the echo, so each block is sized such that\n        its echo doesn't exceed self._write_block_size (some devices may have problem with outputs bigger than that).\n        (OK, most likely the reading thread will eliminate the problem with output buffer, but just in case...)\n        \"\"\"\n        assert script\n\n        # assuming we are already at a prompt, but threads may have produced something\n        self._forward_unexpected_output()\n\n        to_be_sent = script.encode(\"UTF-8\")\n        logger.debug(\"Submitting via %s: %r\", self._submit_mode, to_be_sent[:50])\n        with self._interrupt_lock:\n            if self._submit_mode == PASTE_SUBMIT_MODE:\n                self._submit_code_via_paste_mode(to_be_sent)\n            elif self._submit_mode == RAW_PASTE_SUBMIT_MODE:\n                try:\n                    self._submit_code_via_raw_paste_mode(to_be_sent)\n                except RawPasteNotSupportedError:\n                    logger.info(\"WARNING: Could not use expected raw paste, falling back to raw\")\n                    self._submit_code_via_raw_mode(to_be_sent)\n            else:\n                self._submit_code_via_raw_mode(to_be_sent)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Handles submission of a Python script to a MicroPython device, choosing the appropriate paste or raw mode for reliable code transfer with flow control and output echo management. It ensures safe, synchronized transmission over USB or serial connections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_submit_code_via_paste_mode", "line_number": 574, "body": "def _submit_code_via_paste_mode(self, script_bytes: bytes) -> None:\n        # Go to paste mode\n        self._ensure_normal_mode()\n        self._connection.write(PASTE_MODE_CMD)\n        self._connection.read_until(PASTE_MODE_LINE_PREFIX)\n\n        # Send script\n        while script_bytes:\n            block = script_bytes[: self._write_block_size]\n            script_bytes = script_bytes[self._write_block_size :]\n\n            # find proper block boundary\n            while True:\n                expected_echo = block.replace(b\"\\r\\n\", b\"\\r\\n\" + PASTE_MODE_LINE_PREFIX)\n                if (\n                    len(expected_echo) > self._write_block_size\n                    or block.endswith(b\"\\r\")\n                    or len(block) > 2\n                    and starts_with_continuation_byte(script_bytes)\n                ):\n                    # move last byte to the next block\n                    script_bytes = block[-1:] + script_bytes\n                    block = block[:-1]\n                    continue\n                else:\n                    break\n\n            self._write(block)\n            self._connection.read_all_expected(expected_echo, timeout=WAIT_OR_CRASH_TIMEOUT)\n\n        # push and read comfirmation\n        self._connection.write(EOT)\n        expected_confirmation = b\"\\r\\n\"\n        actual_confirmation = self._connection.read(\n            len(expected_confirmation), timeout=WAIT_OR_CRASH_TIMEOUT\n        )\n        assert actual_confirmation == expected_confirmation, \"Expected %r, got %r\" % (\n            expected_confirmation,\n            actual_confirmation,\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Utility method in BareMetalMicroPythonBackend that sends Python scripts to a device via paste mode, ensuring proper block boundaries and confirming successful transmission for reliable code upload."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_submit_code_via_raw_mode", "line_number": 615, "body": "def _submit_code_via_raw_mode(self, script_bytes: bytes) -> None:\n        self._ensure_raw_mode()\n\n        to_be_written = script_bytes + EOT\n\n        while to_be_written:\n            block = self._extract_block_without_splitting_chars(to_be_written)\n            self._write(block)\n            to_be_written = to_be_written[len(block) :]\n            if to_be_written:\n                time.sleep(self._write_block_delay)\n\n        # fetch command confirmation\n        confirmation = self._connection.soft_read(2, timeout=WAIT_OR_CRASH_TIMEOUT)\n\n        if confirmation != OK:\n            data = confirmation + self._connection.read_all()\n            data += self._connection.read(1, timeout=1, timeout_is_soft=True)\n            data += self._connection.read_all()\n            raise AssertionError(\n                \"Could not read command confirmation. Got \"\n                + repr(data)\n                + \"\\n\\nSCRIPT:\\n\"\n                + repr(script_bytes)\n            )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Core method of BareMetalMicroPythonBackend that sends a MicroPython script in raw mode, ensuring proper transmission and verifying command confirmation to enable direct code execution on the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_submit_code_via_raw_paste_mode", "line_number": 641, "body": "def _submit_code_via_raw_paste_mode(self, script_bytes: bytes) -> None:\n        self._ensure_raw_mode()\n        self._connection.set_unicode_guard(False)\n        self._write(RAW_PASTE_COMMAND)\n        response = self._connection.soft_read(2, timeout=WAIT_OR_CRASH_TIMEOUT)\n        if response != RAW_PASTE_CONFIRMATION:\n            # Occasionally, the device initially supports raw paste but later doesn't allow it\n            # https://github.com/thonny/thonny/issues/1545\n            time.sleep(0.01)\n            response += self._connection.read_all()\n            if response == FIRST_RAW_PROMPT:\n                self._last_prompt = FIRST_RAW_PROMPT\n                raise RawPasteNotSupportedError()\n            else:\n                raise AssertionError(\"Got %r instead of raw-paste confirmation\" % response)\n\n        self._raw_paste_write(script_bytes)\n        self._connection.set_unicode_guard(True)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Handles submitting Python code to a device using raw paste mode, ensuring compatibility and managing device communication errors during the upload process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_raw_paste_write", "line_number": 660, "body": "def _raw_paste_write(self, command_bytes):\n        # Adapted from https://github.com/micropython/micropython/commit/a59282b9bfb6928cd68b696258c0dd2280244eb3#diff-cf10d3c1fe676599a983c0ec85b78c56c9a6f21b2d896c69b3e13f34d454153e\n\n        # Read initial header, with window size.\n        data = self._connection.soft_read(2, timeout=2)\n        assert len(data) == 2, \"Could not read initial header, got %r\" % (\n            data + self._connection.read_all()\n        )\n        window_size = data[0] | data[1] << 8\n        window_remain = window_size\n\n        # Write out the command_bytes data.\n        i = 0\n        while i < len(command_bytes):\n            while window_remain == 0 or not self._connection.incoming_is_empty():\n                data = self._connection.soft_read(1, timeout=WAIT_OR_CRASH_TIMEOUT)\n                if data == b\"\\x01\":\n                    # Device indicated that a new window of data can be sent.\n                    window_remain += window_size\n                elif data == b\"\\x04\":\n                    # Device indicated abrupt end, most likely a syntax error.\n                    # Acknowledge it and finish.\n                    self._connection.write(b\"\\x04\")\n                    logger.debug(\n                        \"Abrupt end of raw paste submit after submitting %s bytes out of %s\",\n                        i,\n                        len(command_bytes),\n                    )\n                    return\n                else:\n                    # Unexpected data from device.\n                    raise AssertionError(\"Unexpected read during raw paste: {}\".format(data))\n            # Send out as much data as possible that fits within the allowed window.\n            b = command_bytes[i : min(i + window_remain, len(command_bytes))]\n            self._write(b)\n            window_remain -= len(b)\n            i += len(b)\n\n        # Indicate end of data.\n        self._write(b\"\\x04\")\n\n        # Wait for device to acknowledge end of data.\n        data = self._connection.soft_read_until(b\"\\x04\", timeout=WAIT_OR_CRASH_TIMEOUT)\n        if not data.endswith(b\"\\x04\"):\n            raise AssertionError(\"could not complete raw paste: {}\".format(data))", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Handles low-level transmission of raw byte commands through a MicroPython device's connection using a windowed flow control protocol, ensuring reliable and ordered data transfer with error handling during paste operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_execute_with_consumer", "line_number": 706, "body": "def _execute_with_consumer(self, script, output_consumer: Callable[[str, str], None]):\n        self._report_time(\"befsubcode\")\n        self._submit_code(script)\n        self._report_time(\"affsubcode\")\n        self._forward_output_until_active_prompt(output_consumer)\n        self._report_time(\"affforw\")", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Core method of BareMetalMicroPythonBackend that executes a script and processes its output via a provided consumer function, enabling customizable handling of execution results and timing in MicroPython contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_forward_output_until_active_prompt", "line_number": 713, "body": "def _forward_output_until_active_prompt(\n        self, output_consumer: Callable[[str, str], None], stream_name=\"stdout\"\n    ):\n        \"\"\"Meant for incrementally forwarding stdout from user statements,\n        scripts and soft-reboots. Also used for forwarding side-effect output from\n        expression evaluations and for capturing help(\"modules\") output.\n        In these cases it is expected to arrive to an EOT.\n\n        Also used for initial prompt searching or for recovering from a protocol error.\n        In this case it must work until active normal prompt or first raw prompt.\n\n        The code may have been submitted in any of the REPL modes or\n        automatically via (soft-)reset.\n\n        NB! The processing may end in normal mode even if the command was started\n        in raw mode (eg. when user presses reset during processing in some devices)!\n\n        The processing may also end in FIRST_RAW_REPL, when it was started in\n        normal REPL and Ctrl+A was issued during processing (ie. before Ctrl+C in\n        this example):\n\n            6\n            7\n            8\n            9\n            10\n            Traceback (most recent call last):\n              File \"main.py\", line 5, in <module>\n            KeyboardInterrupt:\n            MicroPython v1.11-624-g210d05328 on 2019-12-09; ESP32 module with ESP32\n            Type \"help()\" for more information.\n            >>>\n            raw REPL; CTRL-B to exit\n            >\n\n        (Preceding output does not contain EOT)\n        Note that this Ctrl+A may have been issued even before Thonny connected to\n        the device.\n\n        Note that interrupt does not affect the structure of the output -- it is\n        presented just like any other exception.\n\n        The method returns EOT, RAW_PROMPT or NORMAL_PROMPT, depending on which terminator\n        ended the processing.\n\n        The terminating EOT may be either the first EOT from normal raw-REPL\n        output or the starting EOT from Thonny expression (or, in principle, even\n        the second raw-REPL EOT or terminating Thonny expression EOT)\n        -- the caller will do the interpretation.\n\n        Because ot the special role of EOT and NORMAL_PROMT, we assume user code\n        will not output these. If it does, processing may break.\n        It may succeed if the prompt is followed by something (quickly enough)\n        -- that's why we look for *active* prompt, ie. prompt without following text.\n        TODO: Experiment with this!\n\n        Output produced by background threads (eg. in WiPy ESP32) cause even more difficulties,\n        because it becomes impossible to say whether we are at prompt and output\n        is from another thread or the main thread is still running.\n        For now I'm ignoring these problems and assume all output comes from the main thread.\n        \"\"\"\n\n        # Don't want to block on lone EOT (the first EOT), because finding the second EOT\n        # together with raw prompt marker is the most important.\n        INCREMENTAL_OUTPUT_BLOCK_CLOSERS = re.compile(\n            b\"|\".join(\n                map(\n                    re.escape,\n                    [NORMAL_PROMPT, LF, EOT + RAW_PROMPT, FIRST_RAW_PROMPT, W600_FIRST_RAW_PROMPT],\n                )\n            )\n        )\n\n        prompts = [EOT + RAW_PROMPT, NORMAL_PROMPT, FIRST_RAW_PROMPT, W600_FIRST_RAW_PROMPT]\n\n        pending = b\"\"\n        while True:\n            # There may be an input submission waiting\n            # and we can't progress without resolving it first\n            self._check_for_side_commands()\n\n            # Prefer whole lines, but allow also incremental output to single line\n            new_data = self._connection.soft_read_until(\n                INCREMENTAL_OUTPUT_BLOCK_CLOSERS, timeout=0.05\n            )\n\n            # Try to separate stderr from stdout in raw mode\n            eot_pos = new_data.find(EOT)\n            if (\n                eot_pos >= 0\n                and new_data[eot_pos : eot_pos + 2] != EOT + RAW_PROMPT\n                and stream_name == \"stdout\"\n            ):\n                # start of stderr in raw mode\n                out, err = new_data.split(EOT, maxsplit=1)\n                pending += out\n                output_consumer(self._decode(pending), stream_name)\n                pending = b\"\"\n                new_data = err\n                stream_name = \"stderr\"\n            elif self._submit_mode == PASTE_SUBMIT_MODE and TRACEBACK_MARKER in new_data:\n                # start of stderr in paste mode\n                stream_name = \"stderr\"\n\n            if not new_data:\n                # In case we are still waiting for the first bits after connecting ...\n                # TODO: this suggestion should be implemented in Shell\n                if (\n                    self._connection.num_bytes_received == 0\n                    and not self._interrupt_suggestion_given\n                    and time.time() - self._connection.startup_time > 2.5\n                ):\n                    self._show_error(\n                        \"\\n\"\n                        + \"Device is busy or does not respond. Your options:\\n\\n\"\n                        + \"  - wait until it completes current work;\\n\"\n                        + \"  - use Ctrl+C to interrupt current work;\\n\"\n                        + \"  - use Stop/Restart to interrupt more and enter REPL.\\n\"\n                    )\n                    self._interrupt_suggestion_given = True\n\n                if not pending:\n                    # nothing to parse\n                    continue\n\n            pending += new_data\n\n            for current_prompt in prompts:\n                if pending.endswith(current_prompt):\n                    break\n            else:\n                current_prompt = None\n\n            if current_prompt:\n                # This looks like prompt.\n                # Make sure it is not followed by anything.\n                follow_up = self._connection.soft_read(1, timeout=0.01)\n                if follow_up:\n                    # Nope, the prompt is not active.\n                    # (Actually it may be that a background thread has produced this follow up,\n                    # but this would be too hard to consider.)\n                    # Don't output yet, because the follow up may turn into another prompt\n                    # and they can be captured all together.\n                    self._connection.unread(follow_up)\n                    # read prompt must remain in pending\n                    continue\n                else:\n                    # let's hope it is an active prompt\n                    # Strip all trailing prompts\n                    while True:\n                        for potential_prompt in prompts:\n                            if pending.endswith(potential_prompt):\n                                pending = pending[: -len(potential_prompt)]\n                        else:\n                            break\n                    output_consumer(self._decode(pending), stream_name)\n                    self._last_prompt = current_prompt\n                    # logger.debug(\"Found prompt %r\", current_prompt)\n                    return current_prompt\n\n            if pending.endswith(LF):\n                # Maybe it's a penultimate char in a first raw repl?\n                if pending.endswith(FIRST_RAW_PROMPT[:-1]) or pending.endswith(\n                    W600_FIRST_RAW_PROMPT[:-1]\n                ):\n                    pending += self._connection.soft_read(1)\n                    self._connection.unread(pending)\n                    pending = b\"\"\n                else:\n                    output_consumer(self._decode(pending), stream_name)\n                    pending = b\"\"\n                continue\n\n            for potential_prompt in prompts:\n                if ends_overlap(pending, potential_prompt):\n                    # Maybe we have a prefix of the prompt and the rest is still coming?\n                    # (it's OK to wait a bit, as the user output usually ends with a newline, ie not\n                    # with a prompt prefix)\n                    follow_up = self._connection.soft_read(1, timeout=0.3)\n                    if not follow_up:\n                        # most likely not a Python prompt, let's forget about it\n                        output_consumer(self._decode(pending), stream_name)\n                        pending = b\"\"\n                        continue\n                    else:\n                        # Let's try the possible prefix again in the next iteration\n                        # (I'm unreading otherwise the read_until won't see the whole prompt\n                        # and needs to wait for the timeout)\n                        n = ends_overlap(pending, potential_prompt)\n\n                        try_again = pending[-n:]\n                        pending = pending[:-n]\n                        self._connection.unread(try_again + follow_up)\n                        continue\n\n            else:\n                # No prompt in sight.\n                # Output and keep working.\n                output_consumer(self._decode(pending), stream_name)\n                pending = b\"\"\n                continue", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Method of BareMetalMicroPythonBackend that incrementally processes and forwards device output until an active REPL prompt or end-of-transmission is detected, supporting script execution, user input, and error handling. Useful for managing interactive communication with MicroPython devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_capture_output_until_active_prompt", "line_number": 915, "body": "def _capture_output_until_active_prompt(self):\n        output = {\"stdout\": \"\", \"stderr\": \"\"}\n\n        def collect_output(data, stream):\n            output[stream] += data\n\n        self._forward_output_until_active_prompt(collect_output)\n\n        return output[\"stdout\"], output[\"stderr\"]", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Utility method in BareMetalMicroPythonBackend that captures and returns all standard output and error streams until the active prompt appears, enabling downstream processing of device responses."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_forward_unexpected_output", "line_number": 925, "body": "def _forward_unexpected_output(self, stream_name=\"stdout\"):\n        \"Invoked between commands\"\n        # TODO: This should be as careful as _forward_output_until_active_prompt\n        data = self._connection.read_all(check_error=False)\n        if data:\n            met_prompt = False\n            while data.endswith(NORMAL_PROMPT) or data.endswith(FIRST_RAW_PROMPT):\n                # looks like the device was resetted\n                if data.endswith(NORMAL_PROMPT):\n                    prompt = NORMAL_PROMPT\n                else:\n                    prompt = FIRST_RAW_PROMPT\n\n                if not met_prompt:\n                    met_prompt = True\n                    self._last_prompt = prompt\n\n                # hide the prompt from the output ...\n                data = data[: -len(prompt)]\n\n            self._send_output(data.decode(ENCODING, \"replace\"), stream_name)\n            if met_prompt:\n                self._check_prepare()\n                # ... and recreate Thonny prompt\n                self.send_message(ToplevelResponse())", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Handles unexpected output from the device by reading and filtering prompt data, then forwarding the cleaned output to the specified stream, ensuring prompt state is updated and the interactive interface remains synchronized."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_Run", "line_number": 951, "body": "def _cmd_Run(self, cmd):\n        \"\"\"Only for %run $EDITOR_CONTENT. start runs will be handled differently.\"\"\"\n        if cmd.get(\"source\"):\n            self._soft_reboot_without_running_main()\n            if self._submit_mode == PASTE_SUBMIT_MODE:\n                source = self._avoid_printing_expression_statements(cmd.source)\n            else:\n                source = cmd.source\n\n            self._execute(source, capture_output=False)\n            self._prepare_after_soft_reboot(False)\n        return {}", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Private method in BareMetalMicroPythonBackend that executes provided source code commands, managing device reboot and output handling for different submission modes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_execute_system_command", "line_number": 964, "body": "def _cmd_execute_system_command(self, cmd):\n        # Can't use stdin, because a thread is draining it\n        returncode = execute_system_command(cmd, cwd=self._local_cwd, disconnect_stdin=True)\n        return {\"returncode\": returncode}", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Private method in BareMetalMicroPythonBackend that executes a system command in a specific directory and returns its exit status. Useful for running shell commands within the backend's local environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_get_fs_info", "line_number": 969, "body": "def _cmd_get_fs_info(self, cmd):\n        result = self._evaluate(\n            dedent(\n                \"\"\"\n            try:\n                from os import statvfs as __thonny_statvfs\n                __thonny_stat = __thonny_statvfs(%r)\n                __thonny_total = __thonny_stat[2] * __thonny_stat[0]\n                __thonny_free = __thonny_stat[3] * __thonny_stat[0]\n                __thonny_used = __thonny_total - __thonny_free\n                __thonny_sizes = None\n                del __thonny_statvfs\n                del __thonny_stat \n            except ImportError:\n                __thonny_sizes = [__thonny_helper.os.size(name) for name in __thonny_helper.os.listdir()]\n                __thonny_used = None\n                __thonny_total = None\n                __thonny_free = None\n            \n            __thonny_helper.print_mgmt_value({\n                \"total\" : __thonny_total,\n                \"used\" : __thonny_used,\n                \"free\": __thonny_free,\n                \"sizes\": __thonny_sizes\n            })  \n                \n            del __thonny_total\n            del __thonny_free\n            del __thonny_used\n            del __thonny_sizes\n            \"\"\"\n            )\n            % cmd.path\n        )\n\n        if result[\"sizes\"] is not None:\n            if self._connected_to_microbit():\n                comment = \"Assuming around 30 kB of storage space for user files.\"\n            else:\n                comment = \"Don't know the size of storage space on this device.\"\n\n            files_total_size = sum(result[\"sizes\"])\n\n            # TODO: compute number of used blocks\n            if files_total_size > 0:\n                comment += \"\\n\\n\" + \"At least %s of it is used by %d file(s).\" % (\n                    sizeof_fmt(files_total_size),\n                    len(result[\"sizes\"]),\n                )\n\n            result[\"comment\"] = comment\n            del result[\"sizes\"]\n\n        return result", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provides detailed file system storage information from a device, including total, used, and free space or individual file sizes, with contextual comments based on device type. Useful for monitoring and reporting storage usage in embedded MicroPython environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_upload", "line_number": 1024, "body": "def _cmd_upload(self, cmd):\n        self._check_sync_time()\n        return super(BareMetalMicroPythonBackend, self)._cmd_upload(cmd)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method ensures the system time is synchronized before executing an upload command, providing a reliable way to maintain timing consistency during uploads in the BareMetalMicroPythonBackend class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_write_file", "line_number": 1028, "body": "def _cmd_write_file(self, cmd):\n        self._check_sync_time()\n        return super(BareMetalMicroPythonBackend, self)._cmd_write_file(cmd)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method ensures synchronization before delegating file write commands to its superclass. It provides a synchronized file writing capability within the BareMetalMicroPythonBackend context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_prepare_disconnect", "line_number": 1032, "body": "def _cmd_prepare_disconnect(self, cmd):\n        logger.info(\"Preparing disconnect\")\n        # NB! Don't let the mainloop see the prompt and act on it\n        self._connection.stop_reader()\n        self._write(NORMAL_MODE_CMD)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Prepares the backend connection for disconnection by stopping input reading and resetting the device to normal command mode, ensuring a clean disconnection process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_delete_sorted_paths", "line_number": 1038, "body": "def _delete_sorted_paths(self, paths):\n        if not self._supports_directories():\n            # micro:bit\n            self._execute_without_output(\n                dedent(\n                    \"\"\"\n                for __thonny_path in %r: \n                    __thonny_helper.os.remove(__thonny_path)\n                    \n                del __thonny_path\n                \n            \"\"\"\n                )\n                % paths\n            )\n        else:\n            try:\n                super()._delete_sorted_paths(paths)\n            except Exception as e:\n                if \"read-only\" in str(e).lower():\n                    self._delete_via_mount(paths)\n\n            self._sync_remote_filesystem()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provides a method to delete multiple file paths on a MicroPython device, adapting deletion strategy based on directory support and handling read-only errors to ensure filesystem consistency."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_internal_path_to_mounted_path", "line_number": 1062, "body": "def _internal_path_to_mounted_path(self, path):\n        mount_path = self._get_fs_mount()\n        if mount_path is None:\n            return None\n\n        flash_prefix = self._get_flash_prefix()\n        if not path.startswith(flash_prefix):\n            return None\n\n        path_suffix = path[len(flash_prefix) :]\n\n        return os.path.join(mount_path, os.path.normpath(path_suffix))", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Converts an internal flash filesystem path to its corresponding mounted filesystem path, if applicable. It is useful for mapping device-specific flash storage paths to accessible mount points."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_stat_mode_for_upload", "line_number": 1075, "body": "def _get_stat_mode_for_upload(self, path: str) -> Optional[int]:\n        return self._get_stat_mode(path)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Internal helper method of BareMetalMicroPythonBackend that retrieves file mode information for a given path, primarily used to determine permissions or file type before uploading."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_mkdir_for_upload", "line_number": 1078, "body": "def _mkdir_for_upload(self, path: str) -> None:\n        self._mkdir(path)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Private method that ensures the creation of a directory at the specified path to prepare for an upload operation within the BareMetalMicroPythonBackend class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_read_file", "line_number": 1081, "body": "def _read_file(\n        self, source_path: str, target_fp: BinaryIO, callback: Callable[[int, int], None]\n    ) -> None:\n        start_time = time.time()\n\n        if self._connected_over_webrepl():\n            size = self._read_file_via_webrepl_file_protocol(source_path, target_fp, callback)\n        else:\n            # TODO: Is it better to read from mount when possible? Is the mount up to date when the file\n            # is written via serial? Does the MP API give up to date bytes when the file is written via mount?\n            size = self._read_file_via_serial(source_path, target_fp, callback)\n\n        logger.info(\"Read %s in %.1f seconds\", source_path, time.time() - start_time)\n        return size", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Core method of BareMetalMicroPythonBackend that reads a file from a device using the appropriate protocol (WebREPL or serial) and reports progress via callback, enabling flexible file transfers in different connection scenarios."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_read_file_via_serial", "line_number": 1096, "body": "def _read_file_via_serial(\n        self, source_path: str, target_fp: BinaryIO, callback: Callable[[int, int], None]\n    ) -> None:\n\n        hex_mode = self._should_hexlify(source_path)\n\n        self._execute_without_output(\"__thonny_fp = open(%r, 'rb')\" % source_path)\n        if hex_mode:\n            self._execute_without_output(\"from binascii import hexlify as __temp_hexlify\")\n\n        block_size = self._get_file_operation_block_size()\n        file_size = self._get_file_size(source_path)\n        num_bytes_read = 0\n        while True:\n            if self._current_command_is_interrupted():\n                raise KeyboardInterrupt()\n            callback(num_bytes_read, file_size)\n            if hex_mode:\n                block = binascii.unhexlify(\n                    self._evaluate(\"__temp_hexlify(__thonny_fp.read(%s))\" % block_size)\n                )\n            else:\n                block = self._evaluate(\"__thonny_fp.read(%s)\" % block_size)\n\n            if block:\n                target_fp.write(block)\n                num_bytes_read += len(block)\n\n            if len(block) < block_size:\n                break\n\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n            __thonny_fp.close()\n            del __thonny_fp\n            try:\n                del __temp_hexlify\n            except:\n                pass\n            \"\"\"\n            )\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Method of BareMetalMicroPythonBackend that reads a file from a remote device via serial, writing its contents to a local binary stream with progress callback support and optional hex decoding. Useful for transferring files efficiently over serial connections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_read_file_via_webrepl_file_protocol", "line_number": 1140, "body": "def _read_file_via_webrepl_file_protocol(\n        self, source_path: str, target_fp: BinaryIO, callback: Callable[[int, int], None]\n    ):\n        \"\"\"\n        Adapted from https://github.com/micropython/webrepl/blob/master/webrepl_cli.py\n        \"\"\"\n        assert self._connected_over_webrepl()\n\n        file_size = self._get_file_size(source_path)\n\n        src_fname = source_path.encode(\"utf-8\")\n        rec = struct.pack(\n            WEBREPL_REQ_S, b\"WA\", WEBREPL_GET_FILE, 0, 0, 0, len(src_fname), src_fname\n        )\n        self._write(WebreplBinaryMsg(rec))\n        assert self._read_websocket_response() == 0\n\n        bytes_read = 0\n        callback(bytes_read, file_size)\n        while True:\n            # report ready\n            self._write(WebreplBinaryMsg(b\"\\0\"))\n\n            (block_size,) = struct.unpack(\"<H\", self._connection.read(2))\n            if block_size == 0:\n                break\n            while block_size:\n                buf = self._connection.read(block_size)\n                if not buf:\n                    raise OSError()\n                bytes_read += len(buf)\n                target_fp.write(buf)\n                block_size -= len(buf)\n                callback(bytes_read, file_size)\n\n        assert self._read_websocket_response() == 0", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provides a method to download a remote file over a WebREPL connection, writing its contents to a local binary stream while reporting progress through a callback function. Useful for retrieving files from a MicroPython device via WebREPL protocol."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_write_file", "line_number": 1177, "body": "def _write_file(\n        self,\n        source_fp: BinaryIO,\n        target_path: str,\n        file_size: int,\n        callback: Callable[[int, int], None],\n    ) -> None:\n        start_time = time.time()\n\n        if self._connected_over_webrepl():\n            self._write_file_via_webrepl_file_protocol(source_fp, target_path, file_size, callback)\n        else:\n            try:\n                self._write_file_via_serial(source_fp, target_path, file_size, callback)\n            except ReadOnlyFilesystemError:\n                self._write_file_via_mount(source_fp, target_path, file_size, callback)\n\n        logger.info(\"Wrote %s in %.1f seconds\", target_path, time.time() - start_time)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Internal method of BareMetalMicroPythonBackend that writes binary data to a target path on the device using the best available transfer protocol, supporting progress callbacks and handling different connection types transparently."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_write_file_via_mount", "line_number": 1197, "body": "def _write_file_via_mount(\n        self,\n        source: BinaryIO,\n        target_path: str,\n        file_size: int,\n        callback: Callable[[int, int], None],\n    ) -> None:\n        mounted_target_path = self._internal_path_to_mounted_path(target_path)\n        with open(mounted_target_path, \"wb\") as f:\n            bytes_written = 0\n            block_size = 4 * 1024\n            while True:\n                callback(bytes_written, file_size)\n                block = source.read(block_size)\n                if block:\n                    bytes_written += f.write(block)\n                    f.flush()\n                    os.fsync(f)\n\n                if len(block) < block_size:\n                    break\n\n        assert bytes_written == file_size\n\n        return bytes_written", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Utility method in BareMetalMicroPythonBackend that writes binary data from a source stream to a target file path with progress callback support, ensuring data integrity through flushing and syncing during the write process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_write_file_via_serial", "line_number": 1223, "body": "def _write_file_via_serial(\n        self,\n        source_fp: BinaryIO,\n        target_path: str,\n        file_size: int,\n        callback: Callable[[int, int], None],\n    ) -> None:\n        out, err = self._execute(\n            dedent(\n                \"\"\"\n            try:\n                __thonny_path = '{path}'\n                __thonny_written = 0\n                __thonny_fp = open(__thonny_path, 'wb')\n            except Exception as e:\n                print(str(e))\n            \"\"\"\n            ).format(path=target_path),\n            capture_output=True,\n        )\n\n        if \"readonly\" in (out + err).replace(\"-\", \"\").lower():\n            raise ReadOnlyFilesystemError()\n        elif out + err:\n            raise RuntimeError(\n                \"Could not open file %s for writing, output:\\n%s\" % (target_path, out + err)\n            )\n\n        # Define function to allow shorter write commands\n        hex_mode = self._should_hexlify(target_path)\n        if hex_mode:\n            self._execute_without_output(\n                dedent(\n                    \"\"\"\n                from binascii import unhexlify as __thonny_unhex\n                def __W(x):\n                    global __thonny_written\n                    __thonny_written += __thonny_fp.write(__thonny_unhex(x))\n                    __thonny_fp.flush()\n                    if hasattr(__thonny_helper.os, \"sync\"):\n                        __thonny_helper.os.sync()\n            \"\"\"\n                )\n            )\n        elif self._connected_to_microbit():\n            # doesn't have neither BytesIO.flush, nor os.sync\n            self._execute_without_output(\n                dedent(\n                    \"\"\"\n                def __W(x):\n                    global __thonny_written\n                    __thonny_written += __thonny_fp.write(x)\n            \"\"\"\n                )\n            )\n        else:\n            self._execute_without_output(\n                dedent(\n                    \"\"\"\n                def __W(x):\n                    global __thonny_written\n                    __thonny_written += __thonny_fp.write(x)\n                    __thonny_fp.flush()\n                    if hasattr(__thonny_helper.os, \"sync\"):\n                        __thonny_helper.os.sync()\n            \"\"\"\n                )\n            )\n\n        bytes_sent = 0\n        block_size = self._get_file_operation_block_size()\n\n        while True:\n            callback(bytes_sent, file_size)\n            block = source_fp.read(block_size)\n\n            if block:\n                if hex_mode:\n                    script = \"__W(%r)\" % binascii.hexlify(block)\n                else:\n                    script = \"__W(%r)\" % block\n                out, err = self._execute(script, capture_output=True)\n                if out or err:\n                    self._show_error(\n                        \"\\nCould not write next block after having written %d bytes to %s\"\n                        % (bytes_sent, target_path)\n                    )\n                    if bytes_sent > 0:\n                        self._show_error(\n                            \"Make sure your device's filesystem has enough free space. \"\n                            + \"(When overwriting a file, the old content may occupy space \"\n                            \"until the end of the operation.)\\n\"\n                        )\n                    raise ManagementError(script, out, err)\n                bytes_sent += len(block)\n\n            if len(block) < block_size:\n                break\n\n        bytes_received = self._evaluate(\"__thonny_written\")\n\n        if bytes_received != bytes_sent:\n            raise UserError(\"Expected %d written bytes but wrote %d\" % (bytes_sent, bytes_received))\n\n        # clean up\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n                try:\n                    del __W\n                    del __thonny_written\n                    del __thonny_path\n                    __thonny_fp.close()\n                    del __thonny_fp\n                    del __thonny_result\n                    del __thonny_unhex\n                except:\n                    pass\n            \"\"\"\n            )\n        )\n\n        return bytes_sent", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Method of BareMetalMicroPythonBackend that writes a file to a target path on a connected device via serial communication, handling partial writes, callbacks, and filesystem errors to ensure data is fully and correctly transferred."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_write_file_via_webrepl_file_protocol", "line_number": 1347, "body": "def _write_file_via_webrepl_file_protocol(\n        self,\n        source: BinaryIO,\n        target_path: str,\n        file_size: int,\n        callback: Callable[[int, int], None],\n    ) -> None:\n        \"\"\"\n        Adapted from https://github.com/micropython/webrepl/blob/master/webrepl_cli.py\n        \"\"\"\n        assert self._connected_over_webrepl()\n\n        dest_fname = target_path.encode(\"utf-8\")\n        rec = struct.pack(\n            WEBREPL_REQ_S, b\"WA\", WEBREPL_PUT_FILE, 0, 0, file_size, len(dest_fname), dest_fname\n        )\n        self._write(WebreplBinaryMsg(rec[:10]))\n        self._write(WebreplBinaryMsg(rec[10:]))\n        assert self._read_websocket_response() == 0\n\n        bytes_sent = 0\n        callback(bytes_sent, file_size)\n        while True:\n            block = source.read(1024)\n            if not block:\n                break\n            self._write(WebreplBinaryMsg(block))\n            bytes_sent += len(block)\n            callback(bytes_sent, file_size)\n\n        assert self._read_websocket_response() == 0\n\n        return bytes_sent", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Uploads a binary file to a target path on a MicroPython device over WebREPL while providing progress updates via a callback."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_read_websocket_response", "line_number": 1381, "body": "def _read_websocket_response(self):\n        data = self._connection.read(4)\n        sig, code = struct.unpack(\"<2sH\", data)\n        assert sig == b\"WB\"\n        return code", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Internal method of BareMetalMicroPythonBackend that reads and validates a WebSocket response header, returning the associated status code for further processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_sync_remote_filesystem", "line_number": 1387, "body": "def _sync_remote_filesystem(self):\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n            if hasattr(__thonny_helper.os, \"sync\"):\n                __thonny_helper.os.sync()        \n        \"\"\"\n            )\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Internal method of BareMetalMicroPythonBackend that triggers a file system sync operation on the remote device to ensure file integrity without producing output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_sync_local_filesystem", "line_number": 1397, "body": "def _sync_local_filesystem(self):\n        if hasattr(os, \"sync\"):\n            os.sync()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Internal utility of BareMetalMicroPythonBackend that synchronizes the local filesystem to ensure data integrity when supported by the operating system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_mkdir", "line_number": 1401, "body": "def _mkdir(self, path):\n        if path == \"/\":\n            return\n\n        try:\n            super()._mkdir(path)\n        except ManagementError as e:\n            if \"read-only\" in e.err.lower():\n                self._makedirs_via_mount(path)\n\n        self._sync_remote_filesystem()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Handles directory creation on a remote filesystem, falling back to a mount-based method if the target is read-only, and synchronizes the filesystem afterward. It ensures reliable directory setup in constrained remote environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_makedirs_via_mount", "line_number": 1413, "body": "def _makedirs_via_mount(self, path):\n        mounted_path = self._internal_path_to_mounted_path(path)\n        assert mounted_path is not None, \"Couldn't find mounted path for \" + path\n        os.makedirs(mounted_path, exist_ok=True)\n        self._sync_local_filesystem()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Utility method in BareMetalMicroPythonBackend that creates directories at a mounted filesystem path and synchronizes the local filesystem afterward to ensure consistency."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_delete_via_mount", "line_number": 1419, "body": "def _delete_via_mount(self, paths):\n        for path in paths:\n            mounted_path = self._internal_path_to_mounted_path(path)\n            assert mounted_path is not None\n            if os.path.isdir(mounted_path):\n                import shutil\n\n                shutil.rmtree(mounted_path)\n            else:\n                os.remove(mounted_path)\n\n        self._sync_local_filesystem()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Private method in BareMetalMicroPythonBackend that deletes files or directories by translating internal paths to mounted filesystem paths and removing them, then syncing the local filesystem to reflect changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_fs_mount_label", "line_number": 1432, "body": "def _get_fs_mount_label(self):\n        # This method is most likely required with CircuitPython,\n        # so try its approach first\n        # https://learn.adafruit.com/welcome-to-circuitpython/the-circuitpy-drive\n        result = self._evaluate(\n            dedent(\n                \"\"\"\n            try:\n                from storage import getmount as __thonny_getmount\n                try:\n                    __thonny_result = __thonny_getmount(\"/\").label\n                finally:\n                    del __thonny_getmount\n            except ImportError:\n                __thonny_result = None \n            except OSError:\n                __thonny_result = None \n            \n            __thonny_helper.print_mgmt_value(__thonny_result)\n            \n            del __thonny_result\n            \"\"\"\n            )\n        )\n\n        if result is not None:\n            return result\n\n        if self._welcome_text is None:\n            return None\n\n        \"\"\"\n        # following is not reliable and probably not needed \n        markers_by_name = {\"PYBFLASH\": {\"pyb\"}, \"CIRCUITPY\": {\"circuitpython\"}}\n\n        for name in markers_by_name:\n            for marker in markers_by_name[name]:\n                if marker.lower() in self._welcome_text.lower():\n                    return name\n        \"\"\"\n\n        return None", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Method of BareMetalMicroPythonBackend that attempts to retrieve the filesystem mount label from a CircuitPython device, providing identification of the mounted drive for device interaction or diagnostics."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_flash_prefix", "line_number": 1475, "body": "def _get_flash_prefix(self):\n        if not self._supports_directories():\n            return \"\"\n        elif (\n            \"LoBo\" in self._welcome_text\n            or \"WiPy with ESP32\" in self._welcome_text\n            or \"PYBLITE\" in self._welcome_text\n            or \"PYBv\" in self._welcome_text\n            or \"PYBOARD\" in self._welcome_text.upper()\n        ):\n            return \"/flash/\"\n        else:\n            return \"/\"", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Determines the appropriate flash memory path prefix based on device support and welcome message content, facilitating correct file system access on various MicroPython hardware platforms."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_fs_mount", "line_number": 1489, "body": "def _get_fs_mount(self):\n        label = self._get_fs_mount_label()\n        if label is None:\n            return None\n        else:\n            candidates = find_volumes_by_name(\n                self._get_fs_mount_label(),\n                # querying A can be very slow\n                skip_letters=\"A\",\n            )\n            if len(candidates) == 0:\n                raise RuntimeError(\"Could not find volume \" + self._get_fs_mount_label())\n            elif len(candidates) > 1:\n                raise RuntimeError(\"Found several possible mount points: %s\" % candidates)\n            else:\n                return candidates[0]", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provides the mount point of the filesystem by locating a unique volume matching a specific label, raising errors if none or multiple matches are found. This supports backend operations requiring access to the correct filesystem volume."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_should_hexlify", "line_number": 1506, "body": "def _should_hexlify(self, path):\n        if \"binascii\" not in self._builtin_modules and \"ubinascii\" not in self._builtin_modules:\n            return False\n\n        for ext in (\".py\", \".txt\", \".csv\"):\n            if path.lower().endswith(ext):\n                return False\n\n        return True", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Determines whether a file should be converted to a hexlify format based on its extension and availability of binascii modules. Useful for deciding file encoding before deployment in a BareMetalMicroPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_is_connected", "line_number": 1516, "body": "def _is_connected(self):\n        return self._connection._error is None", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Private method in BareMetalMicroPythonBackend that checks if the current connection is active by verifying the absence of connection errors. It helps confirm connectivity status within backend operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_epoch_offset", "line_number": 1519, "body": "def _get_epoch_offset(self) -> int:\n        # https://docs.micropython.org/en/latest/library/utime.html\n        # NB! Some boards (eg Pycom) may use Posix epoch!\n        try:\n            return super()._get_epoch_offset()\n        except NotImplementedError:\n            return Y2000_EPOCH_OFFSET", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Utility method of BareMetalMicroPythonBackend that provides the epoch offset for time calculations, defaulting to a Y2000 offset if the superclass method is unimplemented."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_sep", "line_number": 1527, "body": "def _get_sep(self):\n        if self._supports_directories():\n            return \"/\"\n        else:\n            return \"\"", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Returns the appropriate path separator based on whether directory support is available, facilitating file path construction in different environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_decode", "line_number": 1533, "body": "def _decode(self, data: bytes) -> str:\n        return data.decode(ENCODING, errors=\"replace\")", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Private method in BareMetalMicroPythonBackend that decodes byte data into a string using a specified encoding, ensuring robustness by replacing decoding errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_extract_block_without_splitting_chars", "line_number": 1536, "body": "def _extract_block_without_splitting_chars(self, source_bytes: bytes) -> bytes:\n        i = self._write_block_size\n        while i > 1 and i < len(source_bytes) and is_continuation_byte(source_bytes[i]):\n            i -= 1\n\n        return source_bytes[:i]", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Utility method in BareMetalMicroPythonBackend that extracts a byte block from source data ensuring it does not split multibyte characters, preserving data integrity during byte-level operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_file_operation_block_size", "line_number": 1543, "body": "def _get_file_operation_block_size(self):\n        # don't forget that the size may be expanded up to 4x where converted to Python\n        # bytes literal\n        if self._connected_to_microbit():\n            return 512\n        else:\n            return 1024", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Returns the appropriate block size for file operations depending on whether the system is connected to a MicroBit device, supporting efficient data transfer specific to the hardware context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/subprocess_connection.py", "function": "write", "line_number": 33, "body": "def write(self, data):\n        if isinstance(data, (bytes, bytearray)):\n            data = data.decode(self.encoding)\n        self._proc.write(data)\n        self._proc.flush()\n        return len(data)", "is_method": true, "class_name": "SubprocessConnection", "function_description": "Utility method of SubprocessConnection that writes string data to the subprocess input, ensuring encoding consistency and immediate flushing, and returns the number of characters written."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/subprocess_connection.py", "function": "_listen_output", "line_number": 40, "body": "def _listen_output(self):\n        \"NB! works in background thread\"\n        try:\n            while True:\n                chars = self._proc.read(1)\n                if len(chars) > 0:\n                    as_bytes = chars.encode(self.encoding)\n                    self._make_output_available(as_bytes)\n                else:\n                    self._error = \"EOF\"\n                    break\n\n        except Exception as e:\n            self._error = str(e)", "is_method": true, "class_name": "SubprocessConnection", "function_description": "Background thread method that continuously reads output from a subprocess, converting and making the output available until EOF or an error occurs. It supports asynchronous capturing of subprocess output streams."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/subprocess_connection.py", "function": "close", "line_number": 55, "body": "def close(self):\n        if self._proc is not None:\n            self._proc.kill(signal.SIGKILL)\n            # self._reading_thread.join() # 0.2 secs!\n            self._proc = None\n            self._reading_thread = None", "is_method": true, "class_name": "SubprocessConnection", "function_description": "Method of SubprocessConnection that forcefully terminates the associated subprocess and clears its internal process and thread references to release resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/webrepl_connection.py", "function": "debug", "line_number": 160, "body": "def debug(*args):\n    if DEBUG:\n        print(*args, file=sys.stderr)", "is_method": false, "function_description": "Utility function that prints debug messages to standard error when debugging is enabled, assisting developers in tracing program execution details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/webrepl_connection.py", "function": "_wrap_ws_main", "line_number": 49, "body": "def _wrap_ws_main(self):\n        import asyncio\n\n        loop = asyncio.new_event_loop()\n        loop.set_debug(DEBUG)\n        loop.run_until_complete(self._ws_main())", "is_method": true, "class_name": "WebReplConnection", "function_description": "Internal method of the WebReplConnection class that initializes an asynchronous event loop to run the main WebSocket routine, facilitating WebSocket communication handling within a controlled asyncio environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/webrepl_connection.py", "function": "write", "line_number": 130, "body": "def write(self, data):\n        self._write_queue.put_nowait(data)\n        return self._write_responses.get()", "is_method": true, "class_name": "WebReplConnection", "function_description": "Core method of WebReplConnection that sends data asynchronously via an internal queue and waits for a corresponding response, enabling command communication over the WebREPL protocol."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/webrepl_connection.py", "function": "close_and_return_new_connection", "line_number": 137, "body": "def close_and_return_new_connection(self):\n        self.close()\n        return WebReplConnection(self._url, self._password)", "is_method": true, "class_name": "WebReplConnection", "function_description": "Service method of WebReplConnection that closes the current connection and establishes a new one with the same URL and password, enabling connection reset or renewal functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/webrepl_connection.py", "function": "__len__", "line_number": 156, "body": "def __len__(self):\n        return len(self.data)", "is_method": true, "class_name": "WebreplBinaryMsg", "function_description": "Returns the length of the binary message data, providing a way to get the size of the stored content in the WebreplBinaryMsg object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_start_fetching_micropython_org_info", "line_number": 374, "body": "def _start_fetching_micropython_org_info(name, completion_handler):\n    import urllib.error\n    import urllib.parse\n\n    # Fetch info from PyPI\n    url = MICROPYTHON_ORG_JSON % urllib.parse.quote(name)\n\n    url_future = _fetch_url_future(url)\n\n    def poll_fetch_complete():\n        import json\n\n        if url_future.done():\n            try:\n                _, bin_data = url_future.result()\n                raw_data = bin_data.decode(\"UTF-8\")\n                completion_handler(name, json.loads(raw_data), None)\n            except urllib.error.HTTPError as e:\n                completion_handler(\n                    name, {\"info\": {\"name\": name}, \"error\": str(e), \"releases\": {}}, e.code\n                )\n        else:\n            tk._default_root.after(200, poll_fetch_complete)\n\n    poll_fetch_complete()", "is_method": false, "function_description": "Internal utility function that asynchronously fetches and parses JSON metadata for a given package name from micropython.org, invoking a callback with the results or error details upon completion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_create_pip_process", "line_number": 33, "body": "def _create_pip_process(self, args):\n        return self._create_python_process([\"-m\", \"thonny.plugins.micropython.micropip\"] + args)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Utility method in MicroPythonPipDialog that initiates a Python subprocess to run the MicroPython pip module with specified arguments, enabling package management operations within the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_on_install_click", "line_number": 40, "body": "def _on_install_click(self):\n        if self.install_button[\"text\"] == self.get_install_button_text():\n            super()._on_install_click()\n        elif self.install_button[\"text\"] == self.get_search_button_text():\n            self.search_box.delete(0, \"end\")\n            self.search_box.insert(\n                0, \"micropython pycopy \" + self.current_package_data[\"info\"][\"name\"]\n            )\n            self._on_search(None)\n        else:\n            raise RuntimeError(\n                \"Unexpected text '%s' on install button\" % self.install_button[\"text\"]\n            )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Handles the install button click by triggering installation, initiating a package search, or raising an error based on the button's current label. It manages user interactions for installing or searching MicroPython packages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_on_uninstall_click", "line_number": 54, "body": "def _on_uninstall_click(self):\n        if self.uninstall_button[\"text\"] == self.get_uninstall_button_text():\n            super()._on_uninstall_click()\n        elif self.uninstall_button[\"text\"] == self.get_delete_selected_button_text():\n            self._delete_selected()\n        else:\n            raise RuntimeError(\n                \"Unexpected text '%s' on install button\" % self.install_button[\"text\"]\n            )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Handles uninstall button clicks by executing uninstall or delete actions based on the button's current label, ensuring appropriate responses within the MicroPythonPipDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_delete_selected", "line_number": 64, "body": "def _delete_selected(self):\n        paths = []\n        for cb in self._checkboxes:\n            if cb.variable.get():\n                paths.append(cb.full_path)\n\n        if paths:\n            self._delete_paths(paths)\n            self._start_update_list(self.current_package_data[\"info\"][\"name\"])", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Private method in MicroPythonPipDialog that deletes all user-selected items and refreshes the package list accordingly. It supports managing and updating package selections within the dialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_delete_paths", "line_number": 74, "body": "def _delete_paths(self, paths):\n        get_runner().send_command_and_wait(\n            InlineCommand(\"delete\", paths=paths),\n            dialog_title=tr(\"Deleting\"),\n        )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Private method in MicroPythonPipDialog that sends a command to delete specified file system paths, supporting cleanup or removal operations through an interface command."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_get_install_command", "line_number": 80, "body": "def _get_install_command(self):\n        return [\"install\", \"-p\", self._current_temp_dir]", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Returns the pip install command configured to install packages into the dialog's current temporary directory. This supports isolated package installation for MicroPython environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_perform_pip_action", "line_number": 83, "body": "def _perform_pip_action(self, action: str) -> bool:\n        if self._perform_pip_action_without_refresh(action):\n            self._show_instructions()  # Make the old package go away as fast as possible\n\n            # don't know which module to show, therefore None arg\n            self._start_update_list(None)\n            get_workbench().event_generate(\"RemoteFilesChanged\")", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Internal method of MicroPythonPipDialog that executes a pip-related action, refreshes the interface, updates the package list, and notifies the system of remote file changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_perform_pip_action_without_refresh", "line_number": 91, "body": "def _perform_pip_action_without_refresh(self, action: str) -> bool:\n        assert action in [\"install\", \"advanced\"]\n\n        self._current_temp_dir = tempfile.mkdtemp()\n        try:\n            return super()._perform_pip_action_without_refresh(action)\n        finally:\n            shutil.rmtree(self._current_temp_dir, ignore_errors=True)\n            self._current_temp_dir = None", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Utility method in MicroPythonPipDialog that executes a specified pip action within a temporary directory, ensuring cleanup afterward without refreshing the environment. It supports controlled installation or advanced pip operations safely."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_create_upload_command", "line_number": 101, "body": "def _create_upload_command(self) -> InlineCommand:\n        paths = []\n        for (dirpath, dirnames, filenames) in os.walk(self._current_temp_dir):\n            if dirpath != self._current_temp_dir:\n                paths.append(dirpath)\n\n            for filename in filenames:\n                source_path = os.path.join(dirpath, filename)\n                paths.append(source_path)\n\n        items = []\n        for path in paths:\n            for item in prepare_upload_items(\n                path, self._current_temp_dir, self._get_target_directory()\n            ):\n                if item not in items:\n                    items.append(item)\n\n        if not items:\n            raise RuntimeError(\"Could not find anything in temp directory. Was it a dummy package?\")\n\n        return InlineCommand(\"upload\", items=items)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Generates an upload command containing all file and directory paths from a temporary directory, preparing them for transfer to a target location. This supports packaging and uploading file sets in the MicroPythonPipDialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_create_python_process", "line_number": 124, "body": "def _create_python_process(self, args):\n        proc = running.create_frontend_python_process(args, stderr=subprocess.STDOUT)\n        return proc, proc.cmd", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Internal helper method of MicroPythonPipDialog that starts a Python subprocess with specified arguments and returns the process handle and its command for managing Python-related operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_on_listbox_select_package", "line_number": 128, "body": "def _on_listbox_select_package(self, name):\n        self._start_show_module_info(name)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Handles the event when a package is selected in the listbox, triggering display of the selected module's information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_start_show_module_info", "line_number": 131, "body": "def _start_show_module_info(self, name):\n        self._clear_info_text()\n        self.command_frame.grid_remove()\n        self.title_label[\"text\"] = tr(\"Module\") + (\" '%s'\" % name)\n        self.title_label.grid()\n        self._set_state(\"fetching\")\n        self.advanced_button.grid_remove()\n\n        get_workbench().bind(\"get_module_info_response\", self._complete_display_module_info, True)\n        get_runner().send_command(InlineCommand(\"get_module_info\", module_name=name))", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Sets up the dialog interface to display detailed information about a specified module by initiating a request and adjusting the UI to reflect the loading state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_complete_display_module_info", "line_number": 142, "body": "def _complete_display_module_info(self, msg):\n        self._set_state(\"idle\")\n        self.current_package_data = {\"info\": {\"name\": msg.module_name}}\n        get_workbench().unbind(\"get_module_info_response\", self._complete_display_module_info)\n\n        self._append_info_text(tr(\"Installed to:\") + \" \", (\"caption\",))\n        self._append_info_text(msg[\"location\"] + \"\\n\")\n\n        for cb in self._checkboxes:\n            cb.destroy()\n        self._checkboxes.clear()\n\n        for item in msg[\"effective_items\"]:\n            self._append_file_checkbox(item, msg[\"location\"])\n\n        if msg[\"shadowed_items\"]:\n            self._append_info_text(\"\\n\")\n            self._append_info_text(tr(\"Shadowed items (not importable):\") + \"\\n\", (\"caption\",))\n            for item in msg[\"shadowed_items\"]:\n                self._append_file_checkbox(item, None)\n\n        self.command_frame.grid()\n        self.uninstall_button.grid()\n        self.install_button[\"text\"] = self.get_search_button_text()\n        self.uninstall_button[\"text\"] = self.get_delete_selected_button_text()\n        self.uninstall_button[\"state\"] = \"normal\" if self._checkboxes else \"disabled\"\n        self._select_list_item(msg.module_name)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Sets up and displays detailed information about an installed module, including its location and file items, while updating the UI to allow installation management and selection within the MicroPythonPipDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_append_file_checkbox", "line_number": 170, "body": "def _append_file_checkbox(self, full_path, context_dir):\n        if context_dir:\n            text = full_path[len(context_dir) :].strip(\"/\")\n        else:\n            text = full_path\n\n        if self._can_delete(full_path):\n            cb = ttk.Checkbutton(self.info_text, text=text)\n            var = tk.IntVar(value=1)\n            cb.variable = var  # to avoid it being gc-d\n            cb[\"variable\"] = var\n            cb.full_path = full_path\n            self._checkboxes.append(cb)\n            self.info_text.window_create(\"end\", window=cb)\n        else:\n            self._append_info_text(\"\u2022 \" + text)\n\n        self._append_info_text(\"\\n\")", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Adds a file entry as a selectable checkbox or plain text in the dialog, enabling users to choose files for deletion or just view them within the MicroPythonPipDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_show_package_info", "line_number": 189, "body": "def _show_package_info(self, name, data, error_code=None):\n        super(MicroPythonPipDialog, self)._show_package_info(name, data, error_code)\n\n        if name.lower().startswith(\"micropython-\"):\n            self._set_state(\"fetching\")\n            self._append_info_text(\"\\n\\n\")\n            self.info_text.mark_set(\"wait\", \"end-1c\")\n            self.info_text.mark_gravity(\"wait\", \"left\")\n            self._append_info_text(\"Querying micropython.org, please wait...\")\n            _start_fetching_micropython_org_info(name, self._add_micropython_org_info)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Displays detailed package information and, for MicroPython packages, asynchronously fetches additional data from micropython.org to enrich the shown info within the MicroPythonPipDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_add_micropython_org_info", "line_number": 200, "body": "def _add_micropython_org_info(self, name, data, error_code=None):\n        self._set_state(\"idle\")\n        self.info_text.direct_delete(\"wait\", \"end\")\n        self.info_text.mark_unset(\"wait\")\n        self._append_info_text(\"\\n\")\n\n        if error_code == 404:\n            self._append_info_text(\n                tr(\n                    \"Package is not available at micropython.org. \"\n                    \"Version at PyPI will be installed.\"\n                )\n            )\n        elif error_code:\n            self._append_info_text(\"Error %s\\n\" % error_code)\n            self._append_info_text(data.get(\"error\", \"\") + \"\\n\")\n        else:\n            ver = data[\"info\"][\"version\"]\n            self._append_info_text(\n                tr(\n                    \"NB! micropython.org has published version %s of this package \"\n                    \"and this will be installed by default.\"\n                )\n                % ver\n                + \"\\n\",\n                (\"bold\",),\n            )\n            self._append_info_text(\n                \"If you want to install a version from PyPI, then use the advanced install button '...'. \"\n                \"Note that PyPI version may require a specific fork of MicroPython.\"\n            )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Provides user feedback in the MicroPythonPipDialog by displaying package availability or error information from micropython.org, guiding installation choices between micropython.org and PyPI versions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_can_delete", "line_number": 232, "body": "def _can_delete(self, path):\n        return not path.startswith(\"/usr/lib\")", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Determines whether a given file path is deletable by ensuring it does not reside within the protected \"/usr/lib\" system directory. This helps prevent unintended modification of critical system files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_get_target_directory", "line_number": 235, "body": "def _get_target_directory(self):\n        target_dir = self._backend_proxy.get_pip_target_dir()\n        return target_dir", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "This method retrieves the target directory path used by the backend for installing Python packages, supporting package management operations in MicroPython environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_read_only", "line_number": 239, "body": "def _read_only(self):\n        return self._get_target_directory() is None", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Checks if the target directory is unspecified, indicating a read-only state for the MicroPythonPipDialog instance. This helper method helps determine if modifications are permitted."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_show_instructions_about_existing_packages", "line_number": 242, "body": "def _show_instructions_about_existing_packages(self):\n        self._append_info_text(tr(\"Upgrade or uninstall\") + \"\\n\", (\"caption\",))\n        self.info_text.direct_insert(\n            \"end\", tr(\"For upgrading simply install the package again.\") + \"\\n\"\n        )\n        self.info_text.direct_insert(\n            \"end\", tr(\"For uninstalling delete corresponding files.\") + \"\\n\\n\"\n        )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Provides informational instructions on upgrading or uninstalling existing packages, displayed within the MicroPythonPipDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_use_user_install", "line_number": 255, "body": "def _use_user_install(self):\n        return False", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Always returns False, indicating that user-level installation is not used."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "does_support_update_deps_switch", "line_number": 258, "body": "def does_support_update_deps_switch(self):\n        return False", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Indicates whether the update dependencies switch is supported in the MicroPythonPipDialog. This function always returns False, signaling no support for that feature."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_show_instructions_about_target", "line_number": 261, "body": "def _show_instructions_about_target(self):\n        self._append_info_text(tr(\"Scope\") + \"\\n\", (\"caption\",))\n\n        if isinstance(self._backend_proxy, LocalMicroPythonProxy):\n            dir_tags = (\"url\",)\n        else:\n            dir_tags = ()\n\n        if len(self._backend_proxy.get_lib_dirs()) == 1:\n            self._append_info_text(self._get_target_directory(), dir_tags)\n            self._append_info_text(\"\\n\")\n        else:\n\n            self.info_text.direct_insert(\n                \"end\", tr(\"This dialog lists top-level modules from following directories:\\n\")\n            )\n\n            for path in self._backend_proxy.get_lib_dirs():\n                self._append_info_text(\"\u2022 \")\n                self._append_info_text(path, dir_tags)\n                self._append_info_text(\"\\n\")\n\n            self._append_info_text(\"\\n\")\n            self._append_info_text(tr(\"New packages will be installed to\") + \"\\n\")\n            self._append_info_text(\"\u2022 \")\n            self._append_info_text(self._get_target_directory(), dir_tags)\n            self._append_info_text(\"\\n\")", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Displays explanatory information about the package installation target, listing relevant library directories and indicating where new packages will be installed in the MicroPythonPipDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_show_read_only_instructions", "line_number": 289, "body": "def _show_read_only_instructions(self):\n        self._append_info_text(tr(\"Not available\") + \"\\n\", (\"caption\",))\n        if not self._get_target_directory():\n            reason = \" (\" + tr(\"no absolute lib directory in sys.path\") + \")\"\n        else:\n            reason = \"\"\n        self.info_text.direct_insert(\n            \"end\",\n            get_not_supported_translation() + reason + \"\\n\\n\",\n        )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Provides a read-only status message with reasons why certain operations are unavailable, informing users of the limitations in the MicroPythonPipDialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_tweak_search_results", "line_number": 300, "body": "def _tweak_search_results(self, results, query):\n        if results is None:\n            return results\n        query = query.lower()\n\n        def get_order(item):\n            name = item[\"name\"].lower()\n            if name == query:\n                return 0\n            elif name == \"micropython-\" + query:\n                return 1\n            elif name == \"pycopy-\" + query:\n                return 2\n            elif \"micropython\" in name:\n                return 3\n            elif \"pycopy\" in name:\n                return 4\n            elif item.get(\"description\"):\n                description = item[\"description\"]\n                if \"micropython\" in description.lower() or \"pycopy\" in description.lower():\n                    return 5\n\n            return 6\n\n        return sorted(results, key=get_order)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Method of MicroPythonPipDialog that prioritizes and sorts package search results based on their relevance to the query, favoring exact matches and MicroPython/ Pycopy-related packages for more accurate recommendations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_get_interpreter", "line_number": 326, "body": "def _get_interpreter(self):\n        return self._backend_proxy.get_full_label()", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Returns the full label of the interpreter associated with the backend proxy in the MicroPythonPipDialog context. This provides information about the specific Python interpreter environment being used."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_get_extra_switches", "line_number": 329, "body": "def _get_extra_switches(self):\n        return []", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Returns an empty list of additional command-line options or switches. This private method likely serves as a placeholder for subclasses or future extensions to specify extra switches."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_run_pip_with_dialog", "line_number": 332, "body": "def _run_pip_with_dialog(self, args, title) -> Tuple[int, str, str]:\n        args = [\"-m\", \"thonny.plugins.micropython.micropip\"] + args\n        proc = running.create_frontend_python_process(args, stderr=subprocess.STDOUT)\n        cmd = proc.cmd\n        dlg = InstallAndUploadDialog(\n            self,\n            proc,\n            back_cmd=self._create_upload_command,\n            title=\"micropip\",\n            instructions=title,\n            autostart=True,\n            output_prelude=subprocess.list2cmdline(cmd) + \"\\n\",\n        )\n        ui_utils.show_dialog(dlg)\n        assert dlg.returncode is not None\n        return dlg.returncode, dlg.stdout, dlg.stderr", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Provides a user-interactive dialog to run a pip-related MicroPython command, capturing its output and status. This enables executing package management tasks with visual feedback and control within MicroPythonPipDialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_get_install_command", "line_number": 351, "body": "def _get_install_command(self):\n        return [\"install\", \"-p\", self._get_target_directory()]", "is_method": true, "class_name": "LocalMicroPythonPipDialog", "function_description": "Utility method of LocalMicroPythonPipDialog that constructs the package installation command targeting a specific directory. It supports consistent installation path specification for package management operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_delete_paths", "line_number": 357, "body": "def _delete_paths(self, paths):\n        # assuming all files are listed if their directory is listed\n        for path in sorted(paths, key=len, reverse=True):\n            if os.path.isfile(path):\n                os.remove(path)\n            else:\n                os.removedirs(path)", "is_method": true, "class_name": "LocalMicroPythonPipDialog", "function_description": "Utility method in LocalMicroPythonPipDialog that deletes files or directories from given paths, ensuring directories are removed after their contents are deleted. It supports cleanup operations by handling nested file system entries safely."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_run_pip_with_dialog", "line_number": 365, "body": "def _run_pip_with_dialog(self, args, title) -> Tuple[int, str, str]:\n        args = [\"-m\", \"thonny.plugins.micropython.micropip\"] + args\n        proc = running.create_frontend_python_process(args, stderr=subprocess.STDOUT)\n        cmd = proc.cmd\n        dlg = SubprocessDialog(self, proc, \"micropip\", long_description=title, autostart=True)\n        ui_utils.show_dialog(dlg)\n        return dlg.returncode, dlg.stdout, dlg.stderr", "is_method": true, "class_name": "LocalMicroPythonPipDialog", "function_description": "Core method of LocalMicroPythonPipDialog that runs a specified micropip command in a subprocess with a UI dialog, returning the process's exit code, standard output, and error output. It facilitates interactive package management within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "start_work", "line_number": 416, "body": "def start_work(self):\n        threading.Thread(target=self.work_in_thread, daemon=True).start()", "is_method": true, "class_name": "InstallAndUploadDialog", "function_description": "Starts a background daemon thread to run the class's work_in_thread method asynchronously, enabling non-blocking execution of installation and upload tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "work_in_thread", "line_number": 419, "body": "def work_in_thread(self):\n        self.set_action_text(\"Installing to temp directory\")\n        self.append_text(\"Installing to temp directory\\n\")\n        while True:\n            line = self._proc.stdout.readline()\n            if not line:\n                break\n            self.append_text(line)\n            self.set_action_text_smart(line)\n        self.returncode = self._proc.wait()\n        if self.returncode:\n            self.set_action_text(\"Error\")\n            self.append_text(\"\\nmicropip returned with error code %s\\n\" % self.returncode)\n        else:\n            self.set_action_text(\"Copying to the device\")\n            self.append_text(\"Copying to the device\\n\")\n        self.report_done(self.returncode == 0)", "is_method": true, "class_name": "InstallAndUploadDialog", "function_description": "Runs an installation process asynchronously, updates the dialog with real-time output and status, and reports success or failure upon completion. Useful for non-blocking installation and upload workflows in a user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "on_done", "line_number": 437, "body": "def on_done(self, success):\n        if not success or self._stage == \"upload\":\n            super().on_done(success)\n            if self._stage == \"upload\":\n                # Returcode is required by the superclass\n                if success:\n                    self.returncode = 0\n                else:\n                    self.returncode = -1\n            return\n\n        assert self._stage == \"install\"\n        # only half of the work is done\n        self._stage = \"upload\"\n        super().send_command_to_backend()", "is_method": true, "class_name": "InstallAndUploadDialog", "function_description": "Handles completion logic for installation and upload stages, advancing the process or reporting final success status in the InstallAndUploadDialog workflow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "get_order", "line_number": 305, "body": "def get_order(item):\n            name = item[\"name\"].lower()\n            if name == query:\n                return 0\n            elif name == \"micropython-\" + query:\n                return 1\n            elif name == \"pycopy-\" + query:\n                return 2\n            elif \"micropython\" in name:\n                return 3\n            elif \"pycopy\" in name:\n                return 4\n            elif item.get(\"description\"):\n                description = item[\"description\"]\n                if \"micropython\" in description.lower() or \"pycopy\" in description.lower():\n                    return 5\n\n            return 6", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Returns a ranking score for a package item based on how closely its name or description matches the query, aiding in prioritized sorting of MicroPython-related package results."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pylint/__init__.py", "function": "load_plugin", "line_number": 127, "body": "def load_plugin():\n    add_program_analyzer(PylintAnalyzer)\n    get_workbench().set_default(\"assistance.use_pylint\", True)", "is_method": false, "function_description": "This function configures the environment to use a specific code analysis plugin by adding a Pylint analyzer and enabling its usage by default. It is useful for setting up automated code quality checks in the development workspace."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pylint/__init__.py", "function": "is_enabled", "line_number": 14, "body": "def is_enabled(self):\n        return get_workbench().get_option(\"assistance.use_pylint\")", "is_method": true, "class_name": "PylintAnalyzer", "function_description": "Method of PylintAnalyzer that checks if Pylint integration is enabled in the user\u2019s settings, guiding whether linting features should be active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pylint/__init__.py", "function": "start_analysis", "line_number": 17, "body": "def start_analysis(self, main_file_path, imported_file_paths):\n        relevant_symbols = {\n            checks_by_id[key][\"msg_sym\"]\n            for key in checks_by_id\n            if checks_by_id[key][\"usage\"] == \"warning\"\n        }\n\n        if \"bad-python3-import\" in relevant_symbols:\n            # https://github.com/PyCQA/pylint/issues/2453\n            # TODO: allow if this is fixed in minimum version\n            relevant_symbols.remove(\"bad-python3-import\")\n\n        # remove user-disabled checks\n        relevant_symbols = relevant_symbols - set(\n            get_workbench().get_option(\"assistance.disabled_checks\")\n        )\n\n        ignored_modules = {\"turtle\"}  # has dynamically generated attributes\n\n        options = [\n            # \"--rcfile=None\", # TODO: make it ignore any rcfiles that can be somewhere\n            \"--persistent=n\",\n            # \"--confidence=HIGH\", # Leave empty to show all. Valid levels: HIGH, INFERENCE, INFERENCE_FAILURE, UNDEFINED\n            # \"--disable=missing-docstring,invalid-name,trailing-whitespace,trailing-newlines,missing-final-newline,locally-disabled,suppressed-message\",\n            \"--disable=all\",\n            \"--enable=\" + \",\".join(relevant_symbols),\n            \"--ignored-modules=\" + \",\".join(ignored_modules),\n            \"--max-line-length=120\",\n            \"--output-format=text\",\n            \"--reports=n\",\n            \"--msg-template={{'filename':{abspath!r}, 'lineno':{line}, 'col_offset':{column}, 'symbol':{symbol!r}, 'msg':{msg!r}, 'msg_id':{msg_id!r}, 'category' : {C!r} }}\",\n        ]\n\n        # disallow unused globals only in main script\n        \"\"\"\n        Not good idea, because unused * imports also count as unused global vars\n        from pylint.__pkginfo__ import numversion\n\n        if not imported_file_paths and numversion >= (1, 7):\n            # (unfortunately can't separate main script when user modules are present)\n            options.append(\"--allow-global-unused-variables=no\")\n        \"\"\"\n\n        self._proc = ui_utils.popen_with_ui_thread_callback(\n            [get_interpreter_for_subprocess(), \"-m\", \"pylint\"]\n            + options\n            + [main_file_path]\n            + list(imported_file_paths),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            universal_newlines=True,\n            on_completion=self._parse_and_output_warnings,\n        )", "is_method": true, "class_name": "PylintAnalyzer", "function_description": "Starts a Pylint static analysis subprocess on a main Python file and its imports, customizing enabled warnings and ignored modules, then processes the output asynchronously for integration with a user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pylint/__init__.py", "function": "_parse_and_output_warnings", "line_number": 71, "body": "def _parse_and_output_warnings(self, pylint_proc, out_lines, err_lines):\n        # print(\"COMPL\", out, err)\n        # get rid of non-error\n        err = (\n            \"\".join(err_lines)\n            .replace(\"No config file found, using default configuration\", \"\")\n            .strip()\n        )\n\n        if err:\n            logger.error(\"Pylint: \" + err)\n\n        warnings = []\n        for line in out_lines:\n            if line.startswith(\"{\"):\n                try:\n                    atts = ast.literal_eval(line.strip())\n                except SyntaxError:\n                    logging.error(\"Can't parse Pylint line: \" + line)\n                    continue\n                else:\n                    check = checks_by_id[atts[\"msg_id\"]]\n                    if check.get(\"tho_xpln\"):\n                        explanation = check[\"tho_xpln\"]\n                    else:\n                        explanation = check[\"msg_xpln\"]\n\n                    if explanation.startswith(\"Used when an \"):\n                        explanation = \"It looks like the \" + explanation[(len(\"Used when an \")) :]\n                    elif explanation.startswith(\"Emitted when an \"):\n                        explanation = (\n                            \"It looks like the \" + explanation[(len(\"Emitted when an \")) :]\n                        )\n                    elif explanation.startswith(\"Used when a \"):\n                        explanation = \"It looks like the \" + explanation[(len(\"Used when a \")) :]\n                    elif explanation.startswith(\"Emitted when a \"):\n                        explanation = \"It looks like the \" + explanation[(len(\"Emitted when a \")) :]\n                    elif explanation.startswith(\"Used when \"):\n                        explanation = \"It looks like \" + explanation[(len(\"Used when \")) :]\n                    elif explanation.startswith(\"Emitted when \"):\n                        explanation = \"It looks like \" + explanation[(len(\"Emitted when \")) :]\n\n                    atts[\"explanation\"] = explanation\n\n                    if check.get(\"tho_xpln_rst\"):\n                        atts[\"explanation_rst\"] = check[\"tho_xpln_rst\"]\n\n                    if atts[\"category\"] in (\"I\", \"F\"):\n                        atts[\"msg\"] = \"INTERNAL ERROR when analyzing the code: \" + atts[\"msg\"]\n\n                    # atts[\"more_info_url\"] = \"http://pylint-messages.wikidot.com/messages:%s\" % atts[\"msg_id\"].lower()\n                    warnings.append(atts)\n\n        self.completion_handler(self, warnings)", "is_method": true, "class_name": "PylintAnalyzer", "function_description": "Processes Pylint output lines to extract, format, and enrich warning messages with explanations, then passes these structured warnings to a completion handler for further use or display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "_clear_screen", "line_number": 7, "body": "def _clear_screen():\n    if platform.system() == \"Windows\":\n        os.system(\"cls\")\n    else:\n        os.system(\"clear\")", "is_method": false, "function_description": "Utility function that clears the terminal screen by issuing the appropriate system command based on the operating system platform."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "equivalent_realpath", "line_number": 14, "body": "def equivalent_realpath(p):\n    pdir = os.path.dirname(p)\n    if os.path.isfile(os.path.join(pdir, \"activate\")):\n        # it's a virtual environment\n        # can use realpath only if it doesn't move out of its dir\n        real = os.path.realpath(p)\n        if os.path.dirname(real) == pdir:\n            return real\n        try:\n            link = os.readlink(p)\n            if not os.path.isabs(link):\n                link = os.path.join(pdir, link)\n            link = os.path.normpath(link)\n            if os.path.dirname(link) == pdir:\n                return link\n            return p\n        except Exception:\n            return p\n    else:\n        return os.path.realpath(p)", "is_method": false, "function_description": "Function that resolves a given path to its real or linked location while preserving virtual environment boundaries, ensuring path resolution does not escape the environment directory. Useful for safely handling file paths within virtual environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "is_virtual_exe", "line_number": 36, "body": "def is_virtual_exe(p):\n    pdir = os.path.dirname(p)\n    return os.path.exists(os.path.join(pdir, \"activate\")) or os.path.exists(\n        os.path.join(pdir, \"activate.bat\")\n    )", "is_method": false, "function_description": "This function checks if a given executable path belongs to a virtual environment by verifying the presence of activation scripts in its directory. It helps identify whether the executable is part of a Python virtual environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "is_bundled_exe", "line_number": 43, "body": "def is_bundled_exe(p):\n    pdir = os.path.dirname(p)\n    return os.path.exists(os.path.join(pdir, \"thonny_python.ini\"))", "is_method": false, "function_description": "This function checks if a given executable is part of a bundled Thonny Python environment by verifying the presence of a specific configuration file in its directory. It helps determine the packaging context of the executable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "list_commands", "line_number": 48, "body": "def list_commands(prefix, highlighted_reals, highlighted_dirs):\n    for suffix in [\"\", \"3\", \"3.5\", \"3.6\", \"3.7\", \"3.8\"]:\n        cmd = prefix + suffix\n        import shutil\n\n        target = shutil.which(cmd)\n        if target is not None:\n            target = os.path.abspath(target)\n            target = normpath_with_actual_case(target)\n            real = equivalent_realpath(target)\n\n            if target == real:\n                relation = \"==\"\n            else:\n                relation = \"->\"\n\n            line = \" - \" + cmd.ljust(9) + \" \" + relation + \" \" + real\n            if (\n                real in highlighted_reals\n                or os.path.dirname(real) in highlighted_dirs\n                or os.path.dirname(target) in highlight_dirs\n            ):\n                print(wrap_in_ansi_code(line, \"1\"))\n            else:\n                print(wrap_in_ansi_code(line, \"2\"))", "is_method": false, "function_description": "Function that lists executable commands with various suffixes, showing their resolved file paths and highlighting those in specified directories or matching given real paths for easier identification in command discovery contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "wrap_in_ansi_code", "line_number": 75, "body": "def wrap_in_ansi_code(text, code):\n    if can_use_ansi_codes():\n        return \"\\033[\" + code + \"m\" + text + \"\\033[0m\"\n    else:\n        return text", "is_method": false, "function_description": "Utility function that conditionally wraps text with ANSI escape codes for formatting, enabling colored or styled terminal output when supported."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "can_use_ansi_codes", "line_number": 82, "body": "def can_use_ansi_codes():\n    if platform.system() == \"Windows\":\n        ver = platform.win32_ver()\n        try:\n            return int(ver[0]) >= 10\n        except Exception:\n            warnings.warn(\"Can't determine Windows version %s\" % (ver,))\n            return False\n    else:\n        return True", "is_method": false, "function_description": "Utility function that checks if the current system supports ANSI escape codes, primarily detecting Windows 10 or newer for compatibility. It helps other functions conditionally enable ANSI-based terminal formatting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "normpath_with_actual_case", "line_number": 94, "body": "def normpath_with_actual_case(name):\n    \"\"\"In Windows return the path with the case it is stored in the filesystem\"\"\"\n    # copied from thonny.common to make this script independent\n    assert os.path.isabs(name) or os.path.ismount(name), \"Not abs nor mount: \" + name\n    assert os.path.exists(name), \"Not exists: \" + name\n\n    if os.name == \"nt\":\n        # https://stackoverflow.com/questions/2113822/python-getting-filename-case-as-stored-in-windows/2114975\n        name = os.path.normpath(name)\n\n        from ctypes import create_unicode_buffer, windll\n\n        buf = create_unicode_buffer(512)\n        # GetLongPathNameW alone doesn't fix filename part\n        windll.kernel32.GetShortPathNameW(name, buf, 512)  # @UndefinedVariable\n        windll.kernel32.GetLongPathNameW(buf.value, buf, 512)  # @UndefinedVariable\n        result = buf.value\n\n        if result.casefold() != name.casefold():\n            # Sometimes GetShortPathNameW + GetLongPathNameW doesn't work\n            # see eg. https://github.com/thonny/thonny/issues/925\n            windll.kernel32.GetLongPathNameW(name, buf, 512)  # @UndefinedVariable\n            result = buf.value\n\n            if result.casefold() != name.casefold():\n                result = name\n\n        if result[1] == \":\":\n            # ensure drive letter is capital\n            return result[0].upper() + result[1:]\n        else:\n            return result\n    else:\n        # easy on Linux\n        # too difficult on mac\n        # https://stackoverflow.com/questions/14515073/in-python-on-osx-with-hfs-how-can-i-get-the-correct-case-of-an-existing-filenam\n        # Hopefully only correct case comes into Thonny (eg. via open dialog)\n        return os.path.normpath(name)", "is_method": false, "function_description": "Utility function that returns an absolute filesystem path with the actual case as stored on Windows, ensuring correct case-sensitivity; on other OSes, it normalizes the path without case corrections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/__init__.py", "function": "_open_system_shell", "line_number": 13, "body": "def _open_system_shell():\n    \"\"\"Main task is to modify path and open terminal window.\n    Bonus (and most difficult) part is executing a script in this window\n    for recommending commands for running given python and related pip\"\"\"\n\n    cwd = get_workbench().get_local_cwd()\n\n    proxy = get_runner().get_backend_proxy()\n    if proxy and proxy.has_custom_system_shell():\n        proxy.open_custom_system_shell()\n        return\n    if proxy and proxy.get_local_executable():\n        target_executable = proxy.get_local_executable()\n    else:\n        target_executable = sys.executable\n\n    exe_dirs = get_exe_dirs()\n    if hasattr(proxy, \"get_exe_dirs\") and proxy.get_exe_dirs():\n        # use both backend and frontend exe dirs\n        exe_dirs = proxy.get_exe_dirs() + exe_dirs\n\n    env_overrides = get_environment_overrides_for_python_subprocess(target_executable)\n    env_overrides[\"PATH\"] = get_augmented_system_path(exe_dirs)\n\n    explainer = os.path.join(os.path.dirname(__file__), \"explain_environment.py\")\n    cmd = [target_executable, explainer]\n\n    activate = os.path.join(\n        os.path.dirname(target_executable),\n        \"activate.bat\" if platform.system() == \"Windows\" else \"activate\",\n    )\n\n    if os.path.isfile(activate):\n        del env_overrides[\"PATH\"]\n        if platform.system() == \"Windows\":\n            cmd = [activate, \"&\"] + cmd\n        else:\n            cmd = [\"source\", activate, \";\"] + cmd\n\n    return terminal.run_in_terminal(cmd, cwd, env_overrides, True)", "is_method": false, "function_description": "This function opens a system terminal with a modified environment path and attempts to run a Python script recommending commands for Python and pip usage. It adapts to custom shells, virtual environments, and backend proxies for flexible terminal execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/__init__.py", "function": "load_plugin", "line_number": 55, "body": "def load_plugin() -> None:\n    get_workbench().add_command(\n        \"OpenSystemShell\",\n        \"tools\",\n        tr(\"Open system shell...\"),\n        _open_system_shell,\n        group=80,\n        image=\"terminal\",\n    )", "is_method": false, "function_description": "Registers the \"Open system shell\" command in the workbench interface, enabling users to access the system shell through the tools menu."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/mypy/__init__.py", "function": "load_plugin", "line_number": 112, "body": "def load_plugin():\n    add_program_analyzer(MyPyAnalyzer)\n    get_workbench().set_default(\"assistance.use_mypy\", True)", "is_method": false, "function_description": "Enables static type checking by adding the MyPy analyzer plugin and configuring the workbench to use MyPy assistance by default."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/mypy/__init__.py", "function": "is_enabled", "line_number": 16, "body": "def is_enabled(self):\n        return get_workbench().get_option(\"assistance.use_mypy\")", "is_method": true, "class_name": "MyPyAnalyzer", "function_description": "This function checks if MyPy analysis is enabled in the application's configuration options. It provides a simple way for other components to determine whether MyPy type checking should be used."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/mypy/__init__.py", "function": "start_analysis", "line_number": 19, "body": "def start_analysis(self, main_file_path, imported_file_paths: Iterable[str]) -> None:\n\n        self.interesting_files = [main_file_path] + list(imported_file_paths)\n\n        args = [\n            get_interpreter_for_subprocess(),\n            \"-m\",\n            \"mypy\",\n            \"--ignore-missing-imports\",\n            \"--check-untyped-defs\",\n            \"--warn-redundant-casts\",\n            \"--warn-unused-ignores\",\n            \"--show-column-numbers\",\n            main_file_path,\n        ] + list(imported_file_paths)\n\n        # TODO: ignore \"... need type annotation\" messages\n\n        from mypy.version import __version__\n\n        try:\n            ver = tuple(map(int, __version__.split(\".\")))\n        except Exception:\n            ver = (0, 470)  # minimum required version\n\n        if ver >= (0, 520):\n            args.insert(3, \"--no-implicit-optional\")\n\n        if ver >= (0, 590):\n            args.insert(3, \"--python-executable\")\n            args.insert(4, get_runner().get_local_executable())\n\n        if ver >= (0, 730):\n            args.insert(3, \"--warn-unreachable\")\n            args.insert(3, \"--allow-redefinition\")\n            args.insert(3, \"--strict-equality\")\n            args.insert(3, \"--no-color-output\")\n            args.insert(3, \"--no-error-summary\")\n\n        env = os.environ.copy()\n        env[\"MYPYPATH\"] = os.path.join(os.path.dirname(__file__), \"typeshed_extras\")\n\n        self._proc = ui_utils.popen_with_ui_thread_callback(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            universal_newlines=True,\n            env=env,\n            on_completion=self._parse_and_output_warnings,\n            # Specify a cwd which is not ancestor of user files.\n            # This gives absolute filenames in the output.\n            # Note that mypy doesn't accept when cwd is sys.prefix\n            # or dirname(sys.executable)\n            cwd=os.path.dirname(__file__),\n        )", "is_method": true, "class_name": "MyPyAnalyzer", "function_description": "Starts a mypy static type analysis subprocess for the given main file and its imports, configuring run options based on mypy version and handling analysis warnings asynchronously."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/mypy/__init__.py", "function": "_parse_and_output_warnings", "line_number": 75, "body": "def _parse_and_output_warnings(self, pylint_proc, out_lines, err_lines):\n        if err_lines:\n            logger.warning(\"MyPy: \" + \"\".join(err_lines))\n\n        warnings = []\n        for line in out_lines:\n            m = re.match(r\"(.*?):(\\d+)(:(\\d+))?:(.*?):(.*)\", line.strip())\n            if m is not None:\n                message = m.group(6).strip()\n                if message == \"invalid syntax\":\n                    continue  # user will see this as Python error\n\n                filename = m.group(1)\n                if filename not in self.interesting_files:\n                    logger.warning(\"MyPy: \" + line)\n                    continue\n\n                atts = {\n                    \"filename\": filename,\n                    \"lineno\": int(m.group(2)),\n                    \"kind\": m.group(5).strip(),  # always \"error\" ?\n                    \"msg\": message,\n                    \"group\": \"warnings\",\n                }\n                if m.group(3):\n                    # https://github.com/thonny/thonny/issues/598\n                    atts[\"col_offset\"] = max(int(m.group(4)) - 1, 0)\n\n                # TODO: add better categorization and explanation\n                atts[\"symbol\"] = \"mypy-\" + atts[\"kind\"]\n                warnings.append(atts)\n            else:\n                logging.error(\"Can't parse MyPy line: \" + line.strip())\n\n        self.completion_handler(self, warnings)", "is_method": true, "class_name": "MyPyAnalyzer", "function_description": "Processes MyPy output to extract and log warnings from specified files, then passes structured warning details to a completion handler for further handling or display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/test/plugins/test_name_highlighter.py", "function": "test_all", "line_number": 81, "body": "def test_all():\n    if sys.version_info >= (3, 8):\n        warnings.warn(\"Skipping name matcher tests in Python above 3.7\")\n        return\n\n    import jedi\n\n    if (\n        jedi.__version__.startswith(\"0.13.\")\n        or jedi.__version__.startswith(\"0.14.\")\n        or jedi.__version__.startswith(\"0.15.\")\n        or jedi.__version__.startswith(\"0.16.\")\n    ):\n        warnings.warn(\"Skipping name matcher tests for Jedi \" + jedi.__version__)\n        return\n\n    for i, test in enumerate(TEST_GROUPS):\n        print(\"Running test group %d: \" % (i + 1))\n        _assert_returns_correct_indices(test[0], test[1], test[2])", "is_method": false, "function_description": "Function that conditionally runs a series of name matcher tests based on Python and Jedi versions, ensuring compatibility by skipping tests for unsupported versions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/test/plugins/test_name_highlighter.py", "function": "_assert_returns_correct_indices", "line_number": 102, "body": "def _assert_returns_correct_indices(insert_pos_groups, expected_indices, input_str):\n    text_widget = tkinter.Text()\n    text_widget.insert(\"end\", input_str)\n\n    nh = VariablesHighlighter(text_widget)\n    for i, group in enumerate(insert_pos_groups):\n        for insert_pos in group:\n            text_widget.mark_set(\"insert\", insert_pos)\n\n            actual = nh.get_positions()\n            expected = expected_indices[i]\n\n            assert actual == expected, (\n                \"\\nInsert position: %s\"\n                \"\\nExpected: %s\"\n                \"\\nGot: %s\" % (insert_pos, expected, actual)\n            )\n        print(\"\\rPassed %d of %d\" % (i + 1, len(insert_pos_groups)), end=\"\")\n    print()", "is_method": false, "function_description": "Internal test utility that verifies the VariablesHighlighter returns the expected indices at specified cursor positions within a text widget. It ensures highlight positions correspond correctly to given insertion points."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "stdout_write_bytes", "line_number": 82, "body": "def stdout_write_bytes(b):\n    b = b.replace(b\"\\x04\", b\"\")\n    stdout.write(b)\n    stdout.flush()", "is_method": false, "function_description": "Function that writes byte data to standard output after removing all occurrences of the byte representing EOF, ensuring immediate output by flushing the buffer. Useful for controlled binary data streaming to stdout."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "execfile", "line_number": 469, "body": "def execfile(filename, device=\"/dev/ttyACM0\", baudrate=115200, user=\"micro\", password=\"python\"):\n    pyb = Pyboard(device, baudrate, user, password)\n    pyb.enter_raw_repl()\n    output = pyb.execfile(filename)\n    stdout_write_bytes(output)\n    pyb.exit_raw_repl()\n    pyb.close()", "is_method": false, "function_description": "Executes a Python script on a connected Pyboard device and outputs the execution result. This function facilitates remote script running and communication with microcontroller hardware."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "filesystem_command", "line_number": 478, "body": "def filesystem_command(pyb, args):\n    def fname_remote(src):\n        if src.startswith(\":\"):\n            src = src[1:]\n        return src\n\n    def fname_cp_dest(src, dest):\n        src = src.rsplit(\"/\", 1)[-1]\n        if dest is None or dest == \"\":\n            dest = src\n        elif dest == \".\":\n            dest = \"./\" + src\n        elif dest.endswith(\"/\"):\n            dest += src\n        return dest\n\n    cmd = args[0]\n    args = args[1:]\n    try:\n        if cmd == \"cp\":\n            srcs = args[:-1]\n            dest = args[-1]\n            if srcs[0].startswith(\"./\") or dest.startswith(\":\"):\n                op = pyb.fs_put\n                fmt = \"cp %s :%s\"\n                dest = fname_remote(dest)\n            else:\n                op = pyb.fs_get\n                fmt = \"cp :%s %s\"\n            for src in srcs:\n                src = fname_remote(src)\n                dest2 = fname_cp_dest(src, dest)\n                print(fmt % (src, dest2))\n                op(src, dest2)\n        else:\n            op = {\n                \"ls\": pyb.fs_ls,\n                \"cat\": pyb.fs_cat,\n                \"mkdir\": pyb.fs_mkdir,\n                \"rmdir\": pyb.fs_rmdir,\n                \"rm\": pyb.fs_rm,\n            }[cmd]\n            if cmd == \"ls\" and not args:\n                args = [\"\"]\n            for src in args:\n                src = fname_remote(src)\n                print(\"%s :%s\" % (cmd, src))\n                op(src)\n    except PyboardError as er:\n        print(str(er.args[2], \"ascii\"))\n        pyb.exit_raw_repl()\n        pyb.close()\n        sys.exit(1)", "is_method": false, "function_description": "Utility function that interprets and executes file system commands (e.g., copy, list, create, remove) on a remote device via a pyboard interface, handling both local-to-remote and remote-to-local file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "main", "line_number": 561, "body": "def main():\n    import argparse\n\n    cmd_parser = argparse.ArgumentParser(description=\"Run scripts on the pyboard.\")\n    cmd_parser.add_argument(\n        \"-d\",\n        \"--device\",\n        default=os.environ.get(\"PYBOARD_DEVICE\", \"/dev/ttyACM0\"),\n        help=\"the serial device or the IP address of the pyboard\",\n    )\n    cmd_parser.add_argument(\n        \"-b\",\n        \"--baudrate\",\n        default=os.environ.get(\"PYBOARD_BAUDRATE\", \"115200\"),\n        help=\"the baud rate of the serial device\",\n    )\n    cmd_parser.add_argument(\"-u\", \"--user\", default=\"micro\", help=\"the telnet login username\")\n    cmd_parser.add_argument(\"-p\", \"--password\", default=\"python\", help=\"the telnet login password\")\n    cmd_parser.add_argument(\"-c\", \"--command\", help=\"program passed in as string\")\n    cmd_parser.add_argument(\n        \"-w\",\n        \"--wait\",\n        default=0,\n        type=int,\n        help=\"seconds to wait for USB connected board to become available\",\n    )\n    group = cmd_parser.add_mutually_exclusive_group()\n    group.add_argument(\n        \"--follow\",\n        action=\"store_true\",\n        help=\"follow the output after running the scripts [default if no scripts given]\",\n    )\n    group.add_argument(\n        \"--no-follow\",\n        action=\"store_true\",\n        help=\"Do not follow the output after running the scripts.\",\n    )\n    cmd_parser.add_argument(\n        \"-f\", \"--filesystem\", action=\"store_true\", help=\"perform a filesystem action\"\n    )\n    cmd_parser.add_argument(\"files\", nargs=\"*\", help=\"input files\")\n    args = cmd_parser.parse_args()\n\n    # open the connection to the pyboard\n    try:\n        pyb = Pyboard(args.device, args.baudrate, args.user, args.password, args.wait)\n    except PyboardError as er:\n        print(er)\n        sys.exit(1)\n\n    # run any command or file(s)\n    if args.command is not None or args.filesystem or len(args.files):\n        # we must enter raw-REPL mode to execute commands\n        # this will do a soft-reset of the board\n        try:\n            pyb.enter_raw_repl()\n        except PyboardError as er:\n            print(er)\n            pyb.close()\n            sys.exit(1)\n\n        def execbuffer(buf):\n            try:\n                if args.no_follow:\n                    pyb.exec_raw_no_follow(buf)\n                    ret_err = None\n                else:\n                    ret, ret_err = pyb.exec_raw(\n                        buf, timeout=None, data_consumer=stdout_write_bytes\n                    )\n            except PyboardError as er:\n                print(er)\n                pyb.close()\n                sys.exit(1)\n            except KeyboardInterrupt:\n                sys.exit(1)\n            if ret_err:\n                pyb.exit_raw_repl()\n                pyb.close()\n                stdout_write_bytes(ret_err)\n                sys.exit(1)\n\n        # do filesystem commands, if given\n        if args.filesystem:\n            filesystem_command(pyb, args.files)\n            del args.files[:]\n\n        # run the command, if given\n        if args.command is not None:\n            execbuffer(args.command.encode(\"utf-8\"))\n\n        # run any files\n        for filename in args.files:\n            with open(filename, \"rb\") as f:\n                pyfile = f.read()\n                if filename.endswith(\".mpy\") and pyfile[0] == ord(\"M\"):\n                    pyb.exec_(\"_injected_buf=\" + repr(pyfile))\n                    pyfile = _injected_import_hook_code\n                execbuffer(pyfile)\n\n        # exiting raw-REPL just drops to friendly-REPL mode\n        pyb.exit_raw_repl()\n\n    # if asked explicitly, or no files given, then follow the output\n    if args.follow or (args.command is None and not args.filesystem and len(args.files) == 0):\n        try:\n            ret, ret_err = pyb.follow(timeout=None, data_consumer=stdout_write_bytes)\n        except PyboardError as er:\n            print(er)\n            sys.exit(1)\n        except KeyboardInterrupt:\n            sys.exit(1)\n        if ret_err:\n            pyb.close()\n            stdout_write_bytes(ret_err)\n            sys.exit(1)\n\n    # close the connection to the pyboard\n    pyb.close()", "is_method": false, "function_description": "Main entry point function that parses command-line arguments to connect to a pyboard device and execute commands, files, or filesystem actions, optionally following the device output for interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "__del__", "line_number": 118, "body": "def __del__(self):\n        self.close()", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Destructor method for TelnetToSerial that ensures the connection is properly closed when the instance is deleted, preventing resource leaks."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "close", "line_number": 121, "body": "def close(self):\n        if self.tn:\n            self.tn.close()", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Closes the active Telnet connection managed by the TelnetToSerial class, ensuring proper release of network resources. This function is essential for cleanly terminating communication sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "read", "line_number": 125, "body": "def read(self, size=1):\n        while len(self.fifo) < size:\n            timeout_count = 0\n            data = self.tn.read_eager()\n            if len(data):\n                self.fifo.extend(data)\n                timeout_count = 0\n            else:\n                time.sleep(0.25)\n                if self.read_timeout is not None and timeout_count > 4 * self.read_timeout:\n                    break\n                timeout_count += 1\n\n        data = b\"\"\n        while len(data) < size and len(self.fifo) > 0:\n            data += bytes([self.fifo.popleft()])\n        return data", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Provides a data reading interface that collects a specified number of bytes from a Telnet connection buffer, handling timeouts and partial reads to ensure reliable serial-like data retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "write", "line_number": 143, "body": "def write(self, data):\n        self.tn.write(data)\n        return len(data)", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Provides a method to send data through a Telnet connection, returning the number of bytes written. This enables writing raw data to a serial device over Telnet within the TelnetToSerial class."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "inWaiting", "line_number": 147, "body": "def inWaiting(self):\n        n_waiting = len(self.fifo)\n        if not n_waiting:\n            data = self.tn.read_eager()\n            self.fifo.extend(data)\n            return len(data)\n        else:\n            return n_waiting", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Method of TelnetToSerial that returns the number of bytes available to read, reading new data from the telnet connection into a buffer if none is currently waiting."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "close", "line_number": 186, "body": "def close(self):\n        import signal\n\n        os.killpg(os.getpgid(self.subp.pid), signal.SIGTERM)", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Terminates the process group associated with the subprocess, ensuring all related processes are cleanly stopped. This is useful for safely shutting down spawned child processes managed by ProcessToSerial."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "read", "line_number": 191, "body": "def read(self, size=1):\n        data = b\"\"\n        while len(data) < size:\n            data += self.subp.stdout.read(size - len(data))\n        return data", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Reads and returns a specified number of bytes from the subprocess's standard output, ensuring the exact amount is retrieved before returning. Useful for controlled, incremental reading of process output streams."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "write", "line_number": 197, "body": "def write(self, data):\n        self.subp.stdin.write(data)\n        return len(data)", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Utility method of ProcessToSerial that writes data to a subprocess's standard input stream and returns the number of bytes written."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "inWaiting", "line_number": 201, "body": "def inWaiting(self):\n        # res = self.sel.select(0)\n        res = self.poll.poll(0)\n        if res:\n            return 1\n        return 0", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Method in the ProcessToSerial class that checks if there is data available to read from a serial connection, returning a simple indicator of data readiness."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "close", "line_number": 239, "body": "def close(self):\n        import signal\n\n        os.killpg(os.getpgid(self.subp.pid), signal.SIGTERM)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Terminates the entire process group of a subprocess managed by ProcessPtyToTerminal, ensuring all related child processes are cleanly stopped."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "read", "line_number": 244, "body": "def read(self, size=1):\n        return self.ser.read(size)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Provides a simple interface to read a specified number of bytes from the serial terminal connection within the ProcessPtyToTerminal class. Enables controlled data retrieval from the underlying serial device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "write", "line_number": 247, "body": "def write(self, data):\n        return self.ser.write(data)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Provides a method to send data bytes directly to the underlying serial terminal connection, enabling communication through the ProcessPtyToTerminal interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "inWaiting", "line_number": 250, "body": "def inWaiting(self):\n        return self.ser.inWaiting()", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "This method provides the current count of bytes available to read from the terminal's input buffer, enabling non-blocking checks for incoming data in terminal communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "close", "line_number": 287, "body": "def close(self):\n        self.serial.close()", "is_method": true, "class_name": "Pyboard", "function_description": "Closes the serial connection managed by the Pyboard class, ensuring proper release of the communication resource. This is useful for safely terminating interactions with the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "read_until", "line_number": 290, "body": "def read_until(self, min_num_bytes, ending, timeout=10, data_consumer=None):\n        # if data_consumer is used then data is not accumulated and the ending must be 1 byte long\n        assert data_consumer is None or len(ending) == 1\n\n        data = self.serial.read(min_num_bytes)\n        if data_consumer:\n            data_consumer(data)\n        timeout_count = 0\n        while True:\n            if data.endswith(ending):\n                break\n            elif self.serial.inWaiting() > 0:\n                new_data = self.serial.read(1)\n                if data_consumer:\n                    data_consumer(new_data)\n                    data = new_data\n                else:\n                    data = data + new_data\n                timeout_count = 0\n            else:\n                timeout_count += 1\n                if timeout is not None and timeout_count >= 100 * timeout:\n                    break\n                time.sleep(0.01)\n        return data", "is_method": true, "class_name": "Pyboard", "function_description": "Provides a way to read data from a serial connection until a specified ending sequence is detected or a timeout occurs, optionally processing incoming data incrementally through a consumer callback. Useful for managing streaming input with flexible termination conditions."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "enter_raw_repl", "line_number": 316, "body": "def enter_raw_repl(self):\n        self.serial.write(b\"\\r\\x03\\x03\")  # ctrl-C twice: interrupt any running program\n\n        # flush input (without relying on serial.flushInput())\n        n = self.serial.inWaiting()\n        while n > 0:\n            self.serial.read(n)\n            n = self.serial.inWaiting()\n\n        self.serial.write(b\"\\r\\x01\")  # ctrl-A: enter raw REPL\n        data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n>\")\n        if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n>\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")\n\n        self.serial.write(b\"\\x04\")  # ctrl-D: soft reset\n        data = self.read_until(1, b\"soft reboot\\r\\n\")\n        if not data.endswith(b\"soft reboot\\r\\n\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")\n        # By splitting this into 2 reads, it allows boot.py to print stuff,\n        # which will show up after the soft reboot and before the raw REPL.\n        data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n\")\n        if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")", "is_method": true, "class_name": "Pyboard", "function_description": "Utility method of the Pyboard class that interrupts running code and switches the device into raw REPL mode for direct command execution and interaction over serial communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "exit_raw_repl", "line_number": 343, "body": "def exit_raw_repl(self):\n        self.serial.write(b\"\\r\\x02\")", "is_method": true, "class_name": "Pyboard", "function_description": "Exits the raw REPL mode on the Pyboard by sending the appropriate control sequence via serial communication. This allows transitioning the board back to normal REPL operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "follow", "line_number": 346, "body": "def follow(self, timeout, data_consumer=None):\n        # wait for normal output\n        data = self.read_until(1, b\"\\x04\", timeout=timeout, data_consumer=data_consumer)\n        if not data.endswith(b\"\\x04\"):\n            raise PyboardError(\"timeout waiting for first EOF reception\")\n        data = data[:-1]\n\n        # wait for error output\n        data_err = self.read_until(1, b\"\\x04\", timeout=timeout)\n        if not data_err.endswith(b\"\\x04\"):\n            raise PyboardError(\"timeout waiting for second EOF reception\")\n        data_err = data_err[:-1]\n\n        # return normal and error output\n        return data, data_err", "is_method": true, "class_name": "Pyboard", "function_description": "Method of the Pyboard class that captures and returns both normal and error output streams until an end-of-file marker, supporting optional data consumption and timeout handling for interaction with the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "exec_raw_no_follow", "line_number": 362, "body": "def exec_raw_no_follow(self, command):\n        if isinstance(command, bytes):\n            command_bytes = command\n        else:\n            command_bytes = bytes(command, encoding=\"utf8\")\n\n        # check we have a prompt\n        data = self.read_until(1, b\">\")\n        if not data.endswith(b\">\"):\n            raise PyboardError(\"could not enter raw repl\")\n\n        # write command\n        for i in range(0, len(command_bytes), 256):\n            self.serial.write(command_bytes[i : min(i + 256, len(command_bytes))])\n            time.sleep(0.01)\n        self.serial.write(b\"\\x04\")\n\n        # check if we could exec command\n        data = self.serial.read(2)\n        if data != b\"OK\":\n            raise PyboardError(\"could not exec command (response: %r)\" % data)", "is_method": true, "class_name": "Pyboard", "function_description": "Method of the Pyboard class that sends a raw Python command to the device for execution without waiting for the command's output, ensuring proper communication and error detection during the transmission."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "exec_raw", "line_number": 384, "body": "def exec_raw(self, command, timeout=10, data_consumer=None):\n        self.exec_raw_no_follow(command)\n        return self.follow(timeout, data_consumer)", "is_method": true, "class_name": "Pyboard", "function_description": "Executes a raw command on the Pyboard device and waits for its output within a specified timeout. It optionally processes the device output using a provided data consumer function."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "eval", "line_number": 388, "body": "def eval(self, expression):\n        ret = self.exec_(\"print({})\".format(expression))\n        ret = ret.strip()\n        return ret", "is_method": true, "class_name": "Pyboard", "function_description": "Core method of the Pyboard class that evaluates a Python expression and returns its output as a stripped string, enabling dynamic expression execution with immediate result retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "exec_", "line_number": 393, "body": "def exec_(self, command, data_consumer=None):\n        ret, ret_err = self.exec_raw(command, data_consumer=data_consumer)\n        if ret_err:\n            raise PyboardError(\"exception\", ret, ret_err)\n        return ret", "is_method": true, "class_name": "Pyboard", "function_description": "Executes a raw command on the Pyboard device and returns the output, raising an error if the command causes an exception. This method facilitates running and handling remote code execution results on the Pyboard."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "execfile", "line_number": 399, "body": "def execfile(self, filename):\n        with open(filename, \"rb\") as f:\n            pyfile = f.read()\n        return self.exec_(pyfile)", "is_method": true, "class_name": "Pyboard", "function_description": "Executes a Python script file on the Pyboard device by reading its contents and running the code. This enables dynamic code execution from external script files within the Pyboard environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "get_time", "line_number": 404, "body": "def get_time(self):\n        t = str(self.eval(\"pyb.RTC().datetime()\"), encoding=\"utf8\")[1:-1].split(\", \")\n        return int(t[4]) * 3600 + int(t[5]) * 60 + int(t[6])", "is_method": true, "class_name": "Pyboard", "function_description": "Utility method of the Pyboard class that retrieves the current time from the device's real-time clock and returns it as the total number of seconds elapsed since midnight."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_ls", "line_number": 408, "body": "def fs_ls(self, src):\n        cmd = (\n            \"import uos\\nfor f in uos.ilistdir(%s):\\n\"\n            \" print('{:12} {}{}'.format(f[3]if len(f)>3 else 0,f[0],'/'if f[1]&0x4000 else ''))\"\n            % ((\"'%s'\" % src) if src else \"\")\n        )\n        self.exec_(cmd, data_consumer=stdout_write_bytes)", "is_method": true, "class_name": "Pyboard", "function_description": "Lists files and directories in a specified filesystem path on the Pyboard device, formatting output to show file size and indicate directories. Useful for inspecting remote filesystem contents within embedded Python environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_cat", "line_number": 416, "body": "def fs_cat(self, src, chunk_size=256):\n        cmd = (\n            \"with open('%s') as f:\\n while 1:\\n\"\n            \"  b=f.read(%u)\\n  if not b:break\\n  print(b,end='')\" % (src, chunk_size)\n        )\n        self.exec_(cmd, data_consumer=stdout_write_bytes)", "is_method": true, "class_name": "Pyboard", "function_description": "Method of the Pyboard class that reads and outputs the contents of a specified file in fixed-size chunks, facilitating efficient file content retrieval over a stream or connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_get", "line_number": 423, "body": "def fs_get(self, src, dest, chunk_size=256):\n        self.exec_(\"f=open('%s','rb')\\nr=f.read\" % src)\n        with open(dest, \"wb\") as f:\n            while True:\n                data = bytearray()\n                self.exec_(\"print(r(%u))\" % chunk_size, data_consumer=lambda d: data.extend(d))\n                assert data.endswith(b\"\\r\\n\\x04\")\n                try:\n                    data = ast.literal_eval(str(data[:-3], \"ascii\"))\n                    if not isinstance(data, bytes):\n                        raise ValueError(\"Not bytes\")\n                except (UnicodeError, ValueError) as e:\n                    raise PyboardError(\"fs_get: Could not interpret received data: %s\" % str(e))\n                if not data:\n                    break\n                f.write(data)\n        self.exec_(\"f.close()\")", "is_method": true, "class_name": "Pyboard", "function_description": "Transfers a file from the device's filesystem to the local system in chunks, ensuring reliable and incremental data retrieval. Useful for downloading files from a Pyboard device to the host machine."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_put", "line_number": 441, "body": "def fs_put(self, src, dest, chunk_size=256):\n        self.exec_(\"f=open('%s','wb')\\nw=f.write\" % dest)\n        with open(src, \"rb\") as f:\n            while True:\n                data = f.read(chunk_size)\n                if not data:\n                    break\n                if sys.version_info < (3,):\n                    self.exec_(\"w(b\" + repr(data) + \")\")\n                else:\n                    self.exec_(\"w(\" + repr(data) + \")\")\n        self.exec_(\"f.close()\")", "is_method": true, "class_name": "Pyboard", "function_description": "Uploads a local file to a remote filesystem by writing its contents in chunks, supporting both Python 2 and 3 environments. This enables efficient file transfer to the device managed by the Pyboard class."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_mkdir", "line_number": 454, "body": "def fs_mkdir(self, dir):\n        self.exec_(\"import uos\\nuos.mkdir('%s')\" % dir)", "is_method": true, "class_name": "Pyboard", "function_description": "Creates a new directory on the device's filesystem by executing a command to make the specified folder. This function enables dynamic directory management within the Pyboard environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_rmdir", "line_number": 457, "body": "def fs_rmdir(self, dir):\n        self.exec_(\"import uos\\nuos.rmdir('%s')\" % dir)", "is_method": true, "class_name": "Pyboard", "function_description": "Provides a method to remove a directory on the Pyboard device's filesystem by executing the appropriate MicroPython command remotely. Useful for managing storage by deleting unwanted folders."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_rm", "line_number": 460, "body": "def fs_rm(self, src):\n        self.exec_(\"import uos\\nuos.remove('%s')\" % src)", "is_method": true, "class_name": "Pyboard", "function_description": "Removes a specified file from the filesystem of the Pyboard device by executing a remove command remotely. Useful for managing files directly on the board's storage."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fname_remote", "line_number": 479, "body": "def fname_remote(src):\n        if src.startswith(\":\"):\n            src = src[1:]\n        return src", "is_method": false, "function_description": "This function processes a string source by removing a leading colon if present, standardizing remote source identifiers for further use. It facilitates consistent handling of source strings in contexts requiring normalized inputs."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fname_cp_dest", "line_number": 484, "body": "def fname_cp_dest(src, dest):\n        src = src.rsplit(\"/\", 1)[-1]\n        if dest is None or dest == \"\":\n            dest = src\n        elif dest == \".\":\n            dest = \"./\" + src\n        elif dest.endswith(\"/\"):\n            dest += src\n        return dest", "is_method": false, "function_description": "Constructs a destination filename by appending or replacing the source filename based on the given destination path input, ensuring a valid target filename for file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "execbuffer", "line_number": 622, "body": "def execbuffer(buf):\n            try:\n                if args.no_follow:\n                    pyb.exec_raw_no_follow(buf)\n                    ret_err = None\n                else:\n                    ret, ret_err = pyb.exec_raw(\n                        buf, timeout=None, data_consumer=stdout_write_bytes\n                    )\n            except PyboardError as er:\n                print(er)\n                pyb.close()\n                sys.exit(1)\n            except KeyboardInterrupt:\n                sys.exit(1)\n            if ret_err:\n                pyb.exit_raw_repl()\n                pyb.close()\n                stdout_write_bytes(ret_err)\n                sys.exit(1)", "is_method": false, "function_description": "Executes a given code buffer on a connected MicroPython board, handling output and errors based on runtime flags. It ensures graceful termination on execution errors or user interruption."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/docukatse.py", "function": "reet_role", "line_number": 18, "body": "def reet_role(role, rawtext, text, lineno, inliner, options={}, content=[]):\n    \"\"\"\"\"\"\n    # Once nested inline markup is implemented, this and other methods should\n    # recursively call inliner.nested_parse().\n    options[\"classes\"] = \"reet\"\n    return [nodes.inline(rawtext, docutils.utils.unescape(text), **options)], []", "is_method": false, "function_description": "This function creates a custom inline node with a specific CSS class for rendering text in a document, supporting lightweight markup processing with styling. It serves as a utility for customizing inline text appearance in document parsing workflows."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/iterf.py", "function": "print_ast", "line_number": 13, "body": "def print_ast(node, level):\n    print(\" \" * level, node)\n    for name, child in ast.iter_fields(node):\n        if isinstance(child, ast.AST):\n            print(\" \" * level, name, \":\")\n            print_ast(child, level + 1)\n        elif isinstance(child, list):\n            print(\" \" * level, name, \":[\")\n            for elem in child:\n                print_ast(elem, level + 1)\n            print(\" \" * level, \"]\")\n        else:\n            pass", "is_method": false, "function_description": "Function that recursively prints an abstract syntax tree (AST) node and its children with indentation according to depth, providing a readable hierarchical view of the tree structure. It is useful for debugging or visualizing ASTs."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/widget_wraps.py", "function": "string_width", "line_number": 9, "body": "def string_width(s):\n    temp_label = ttk.Label(root, text=s)\n    result = temp_label.winfo_reqwidth()\n    temp_label.destroy()\n    return result", "is_method": false, "function_description": "Utility function that calculates the display width in pixels of a given string using GUI label measurement, useful for dynamic layout adjustments in Tkinter applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/trace_katse.py", "function": "trace", "line_number": 4, "body": "def trace(frame, event, arg):\n    if \"trace_katse\" in frame.f_code.co_filename:\n        print(frame, event, sys.exc_info())\n    return trace", "is_method": false, "function_description": "This function sets a trace callback that continuously monitors Python execution frames, printing details when the filename contains \"trace_katse\". It is useful for debugging code segments related to that filename."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp_thread_exp.py", "function": "forward_until", "line_number": 13, "body": "def forward_until(marker, must_include=None):\n    total = b\"\"\n    while not total.endswith(marker):\n        b = s.read(1)\n        total += b\n        print(b.decode(\"UTF-8\"), end=\"\")\n\n    if must_include and must_include not in total:\n        raise RuntimeError(\"Did not find expected data in the output (%s)\"\n                           % (total + s.read_all()))", "is_method": false, "function_description": "Reads from a stream until a specified marker sequence is detected, optionally verifying that the read data includes a required substring, raising an error if not found. Useful for consuming output data streams with expected delimiters or content checks."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/punktid.py", "function": "arvuta", "line_number": 28, "body": "def arvuta(punktid):\n    momo()\n\n    def fafa(n):\n        pass\n\n    fafa(0)\n    kokku = len(punktid)\n    kaugused_ja_vastavad_punktid = {}\n    m = 0\n    n = 0\n    for punkt in punktid:\n        for i in range(len(punktid)):\n            n += 1\n            esim_punkti_nr = str(punktid.index(punkt) + 1)\n            teise_punkti_nr = str(i + 1)\n            # fafa(n)\n            if punktid.index(punkt) == i:\n                continue\n            firstx = punkt[0]\n            firsty = punkt[1]\n            secondx = punktid[i][0]\n            secondy = punktid[i][1]\n            kaugus = sqrt((secondx - firstx) ** 2 + (secondy - firsty) ** 2)\n            kaugused_ja_vastavad_punktid[kaugus] = esim_punkti_nr, \"ja\", teise_punkti_nr\n    v\u00e4him = min(kaugused_ja_vastavad_punktid)\n    v\u00e4hima_paari_nimi = kaugused_ja_vastavad_punktid[v\u00e4him]\n    return v\u00e4hima_paari_nimi", "is_method": false, "function_description": "Function arvuta calculates the closest pair of points among a list by computing all distances and returning the pair with the smallest distance. It serves to identify the nearest two points in a given coordinate set."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/fullscreen.py", "function": "toggle_fullscreen", "line_number": 23, "body": "def toggle_fullscreen(self, event=None):\n        self.state = not self.state  # Just toggling the boolean\n        self.tk.attributes(\"-fullscreen\", self.state)\n        return \"break\"", "is_method": true, "class_name": "Fullscreen_Window", "function_description": "Toggle fullscreen mode on or off for the application window, enabling users to switch display states interactively."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/fullscreen.py", "function": "end_fullscreen", "line_number": 28, "body": "def end_fullscreen(self, event=None):\n        self.state = False\n        self.tk.attributes(\"-fullscreen\", False)\n        return \"break\"", "is_method": true, "class_name": "Fullscreen_Window", "function_description": "Method of the Fullscreen_Window class that exits fullscreen mode by resetting the state and window attribute. It enables other parts of the program to stop fullscreen display when needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/kbd.py", "function": "check", "line_number": 9, "body": "def check(event):\n    print(\n        \"keycode:\",\n        event.keycode,\n        \"state:\",\n        event.state,\n        \"char:\",\n        repr(event.char),\n        \"keysym\",\n        event.keysym,\n        \"keysym_num\",\n        event.keysym_num,\n    )", "is_method": false, "function_description": "Function that logs detailed information about a keyboard event's attributes, useful for debugging or handling keyboard inputs in event-driven programs."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp_repl_experiment.py", "function": "forward_until", "line_number": 39, "body": "def forward_until(marker, must_include=None):\n    total = b\"\"\n    while not total.endswith(marker):\n        b = s.read(1)\n        total += b\n        print(b.decode(\"UTF-8\"), end=\"\")\n\n    if must_include and must_include not in total:\n        raise RuntimeError(\"Did not find expected data in the output (%s)\"\n                           % (total + s.read_all()))", "is_method": false, "function_description": "Reads and accumulates bytes from a stream until a specified marker is encountered, optionally ensuring that certain data is included before completion. Useful for processing streamed data with expected delimiters and content validation."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp_repl_experiment.py", "function": "start_raw_mode", "line_number": 60, "body": "def start_raw_mode():\n    s.write(b\"\\x01\")\n    forward_until(b\"exit\\r\\n>\")\n    print(\"Got raw prompt. Executing code...\")", "is_method": false, "function_description": "Enables a raw communication mode with an external device or interface, allowing direct code execution by signaling readiness and waiting for a raw prompt response."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/can.py", "function": "on_move", "line_number": 15, "body": "def on_move(event):\n    if active_id is not None:\n        canvas.move(active_id, event.x, event.y)\n        print(\"Move\", event.x, event.y)", "is_method": false, "function_description": "This function handles an object's movement on a canvas by updating its position based on user input events. It enables interactive dragging or repositioning of graphical elements during user interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/can.py", "function": "on_click", "line_number": 21, "body": "def on_click(event):\n    stack = canvas.find_overlapping(event.x, event.y, event.x, event.y)\n    print(stack)\n    canvas.tag_raise(stack[-1])\n    global active_id\n    active_id = stack[-1]", "is_method": false, "function_description": "Handles a click event by identifying and bringing the topmost canvas item at the click position to the front, updating the current active item for further interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/log_utils/log_utils.py", "function": "parse_log_file", "line_number": 9, "body": "def parse_log_file(filename):\n    f = open(filename, encoding=\"UTF-8\")\n    events = []\n    for line in f:\n        events.append(parse_log_line(line))\n\n    f.close()\n    return events", "is_method": false, "function_description": "Function that reads a log file and extracts structured event data by parsing each line. It provides a list of parsed events for further analysis or processing in log management workflows."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/log_utils/log_utils.py", "function": "parse_log_line", "line_number": 19, "body": "def parse_log_line(line):\n    split_pos = line.rfind(\" at \")\n    assert split_pos > 0\n    left = line[0:split_pos]\n    right = line[split_pos + 4 :].strip()\n\n    tree = ast.parse(left, mode=\"eval\")\n    assert isinstance(tree, ast.Expression)\n    assert isinstance(tree.body, ast.Call)\n\n    attributes = {\n        \"event_kind\": tree.body.func.id,\n        \"event_time\": strptime(right, \"%Y-%m-%dT%H:%M:%S.%f\"),\n    }\n\n    for kw in tree.body.keywords:\n        attributes[kw.arg] = ast.literal_eval(kw.value)\n\n    return attributes", "is_method": false, "function_description": "Parses a log line string into a dictionary of event attributes, extracting the event type, timestamp, and associated key-value parameters for structured log analysis and processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/log_utils/log_utils.py", "function": "get_log_file_time", "line_number": 40, "body": "def get_log_file_time(filename):\n    \"\"\"\n    Go from  2014-10-30_10-16-08\n    to       2014-10-30T10:16:08\n    \"\"\"\n\n    chars = list(filename[:19])\n    try:\n        assert chars[10] == \"_\" and chars[13] == \"-\" and chars[16] == \"-\"\n    except Exception:\n        print(filename)\n    chars[10] = \"T\"\n    chars[13] = \":\"\n    chars[16] = \":\"\n    return \"\".join(chars)", "is_method": false, "function_description": "Utility function that converts a specific timestamp format in a log filename from \"YYYY-MM-DD_HH-MM-SS\" to ISO 8601-like \"YYYY-MM-DDTHH:MM:SS\" format for standardized time representation."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "stdout_write_bytes", "line_number": 82, "body": "def stdout_write_bytes(b):\n    b = b.replace(b\"\\x04\", b\"\")\n    stdout.write(b)\n    stdout.flush()", "is_method": false, "function_description": "Utility function that writes byte data to standard output after removing specific control characters, ensuring immediate output by flushing the buffer."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "execfile", "line_number": 524, "body": "def execfile(filename, device=\"/dev/ttyACM0\", baudrate=115200, user=\"micro\", password=\"python\"):\n    pyb = Pyboard(device, baudrate, user, password)\n    pyb.enter_raw_repl()\n    output = pyb.execfile(filename)\n    stdout_write_bytes(output)\n    pyb.exit_raw_repl()\n    pyb.close()", "is_method": false, "function_description": "Utility function that executes a Python script file on a connected MicroPython board via serial communication, handling the device connection and raw REPL mode automatically. It facilitates remote script execution and output retrieval on embedded hardware."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "filesystem_command", "line_number": 533, "body": "def filesystem_command(pyb, args):\n    def fname_remote(src):\n        if src.startswith(\":\"):\n            src = src[1:]\n        return src\n\n    def fname_cp_dest(src, dest):\n        src = src.rsplit(\"/\", 1)[-1]\n        if dest is None or dest == \"\":\n            dest = src\n        elif dest == \".\":\n            dest = \"./\" + src\n        elif dest.endswith(\"/\"):\n            dest += src\n        return dest\n\n    cmd = args[0]\n    args = args[1:]\n    try:\n        if cmd == \"cp\":\n            srcs = args[:-1]\n            dest = args[-1]\n            if srcs[0].startswith(\"./\") or dest.startswith(\":\"):\n                op = pyb.fs_put\n                fmt = \"cp %s :%s\"\n                dest = fname_remote(dest)\n            else:\n                op = pyb.fs_get\n                fmt = \"cp :%s %s\"\n            for src in srcs:\n                src = fname_remote(src)\n                dest2 = fname_cp_dest(src, dest)\n                print(fmt % (src, dest2))\n                op(src, dest2)\n        else:\n            op = {\n                \"ls\": pyb.fs_ls,\n                \"cat\": pyb.fs_cat,\n                \"mkdir\": pyb.fs_mkdir,\n                \"rmdir\": pyb.fs_rmdir,\n                \"rm\": pyb.fs_rm,\n            }[cmd]\n            if cmd == \"ls\" and not args:\n                args = [\"\"]\n            for src in args:\n                src = fname_remote(src)\n                print(\"%s :%s\" % (cmd, src))\n                op(src)\n    except PyboardError as er:\n        print(str(er.args[2], \"ascii\"))\n        pyb.exit_raw_repl()\n        pyb.close()\n        sys.exit(1)", "is_method": false, "function_description": "Function that interprets and executes remote filesystem commands via a pyboard interface, supporting file operations like copy, list, read, create, and delete on local or remote paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "main", "line_number": 616, "body": "def main():\n    import argparse\n\n    cmd_parser = argparse.ArgumentParser(description=\"Run scripts on the pyboard.\")\n    cmd_parser.add_argument(\n        \"-d\",\n        \"--device\",\n        default=os.environ.get(\"PYBOARD_DEVICE\", \"/dev/ttyACM0\"),\n        help=\"the serial device or the IP address of the pyboard\",\n    )\n    cmd_parser.add_argument(\n        \"-b\",\n        \"--baudrate\",\n        default=os.environ.get(\"PYBOARD_BAUDRATE\", \"115200\"),\n        help=\"the baud rate of the serial device\",\n    )\n    cmd_parser.add_argument(\"-u\", \"--user\", default=\"micro\", help=\"the telnet login username\")\n    cmd_parser.add_argument(\"-p\", \"--password\", default=\"python\", help=\"the telnet login password\")\n    cmd_parser.add_argument(\"-c\", \"--command\", help=\"program passed in as string\")\n    cmd_parser.add_argument(\n        \"-w\",\n        \"--wait\",\n        default=0,\n        type=int,\n        help=\"seconds to wait for USB connected board to become available\",\n    )\n    group = cmd_parser.add_mutually_exclusive_group()\n    group.add_argument(\n        \"--follow\",\n        action=\"store_true\",\n        help=\"follow the output after running the scripts [default if no scripts given]\",\n    )\n    group.add_argument(\n        \"--no-follow\",\n        action=\"store_true\",\n        help=\"Do not follow the output after running the scripts.\",\n    )\n    cmd_parser.add_argument(\n        \"-f\",\n        \"--filesystem\",\n        action=\"store_true\",\n        help=\"perform a filesystem action: \"\n        \"cp local :device | cp :device local | cat path | ls [path] | rm path | mkdir path | rmdir path\",\n    )\n    cmd_parser.add_argument(\"files\", nargs=\"*\", help=\"input files\")\n    args = cmd_parser.parse_args()\n\n    # open the connection to the pyboard\n    try:\n        pyb = Pyboard(args.device, args.baudrate, args.user, args.password, args.wait)\n    except PyboardError as er:\n        print(er)\n        sys.exit(1)\n\n    # run any command or file(s)\n    if args.command is not None or args.filesystem or len(args.files):\n        # we must enter raw-REPL mode to execute commands\n        # this will do a soft-reset of the board\n        try:\n            pyb.enter_raw_repl()\n        except PyboardError as er:\n            print(er)\n            pyb.close()\n            sys.exit(1)\n\n        def execbuffer(buf):\n            try:\n                if args.no_follow:\n                    pyb.exec_raw_no_follow(buf)\n                    ret_err = None\n                else:\n                    ret, ret_err = pyb.exec_raw(\n                        buf, timeout=None, data_consumer=stdout_write_bytes\n                    )\n            except PyboardError as er:\n                print(er)\n                pyb.close()\n                sys.exit(1)\n            except KeyboardInterrupt:\n                sys.exit(1)\n            if ret_err:\n                pyb.exit_raw_repl()\n                pyb.close()\n                stdout_write_bytes(ret_err)\n                sys.exit(1)\n\n        # do filesystem commands, if given\n        if args.filesystem:\n            filesystem_command(pyb, args.files)\n            del args.files[:]\n\n        # run the command, if given\n        if args.command is not None:\n            execbuffer(args.command.encode(\"utf-8\"))\n\n        # run any files\n        for filename in args.files:\n            with open(filename, \"rb\") as f:\n                pyfile = f.read()\n                if filename.endswith(\".mpy\") and pyfile[0] == ord(\"M\"):\n                    pyb.exec_(\"_injected_buf=\" + repr(pyfile))\n                    pyfile = _injected_import_hook_code\n                execbuffer(pyfile)\n\n        # exiting raw-REPL just drops to friendly-REPL mode\n        pyb.exit_raw_repl()\n\n    # if asked explicitly, or no files given, then follow the output\n    if args.follow or (args.command is None and not args.filesystem and len(args.files) == 0):\n        try:\n            ret, ret_err = pyb.follow(timeout=None, data_consumer=stdout_write_bytes)\n        except PyboardError as er:\n            print(er)\n            sys.exit(1)\n        except KeyboardInterrupt:\n            sys.exit(1)\n        if ret_err:\n            pyb.close()\n            stdout_write_bytes(ret_err)\n            sys.exit(1)\n\n    # close the connection to the pyboard\n    pyb.close()", "is_method": false, "function_description": "Main executable function that parses command-line arguments to connect to a Pyboard device, execute commands or scripts, perform filesystem operations, and optionally follow the device output interactively. It coordinates device interaction, error handling, and I/O for scripted or interactive Pyboard control."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "__del__", "line_number": 118, "body": "def __del__(self):\n        self.close()", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Destructor method in TelnetToSerial that ensures the connection is properly closed when the instance is deleted, helping manage resource cleanup automatically."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "close", "line_number": 121, "body": "def close(self):\n        if self.tn:\n            self.tn.close()", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Closes the active Telnet connection if it exists, ensuring proper release of network resources managed by the TelnetToSerial class."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "read", "line_number": 125, "body": "def read(self, size=1):\n        while len(self.fifo) < size:\n            timeout_count = 0\n            data = self.tn.read_eager()\n            if len(data):\n                self.fifo.extend(data)\n                timeout_count = 0\n            else:\n                time.sleep(0.25)\n                if self.read_timeout is not None and timeout_count > 4 * self.read_timeout:\n                    break\n                timeout_count += 1\n\n        data = b\"\"\n        while len(data) < size and len(self.fifo) > 0:\n            data += bytes([self.fifo.popleft()])\n        return data", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Reads a specified number of bytes from a Telnet connection buffering incoming data until the requested size is reached or a timeout occurs, enabling smooth serial communication via Telnet."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "write", "line_number": 143, "body": "def write(self, data):\n        self.tn.write(data)\n        return len(data)", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Utility method of the TelnetToSerial class that sends data through a telnet connection and returns the number of bytes written, facilitating data transmission over telnet as if it were a serial connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "inWaiting", "line_number": 147, "body": "def inWaiting(self):\n        n_waiting = len(self.fifo)\n        if not n_waiting:\n            data = self.tn.read_eager()\n            self.fifo.extend(data)\n            return len(data)\n        else:\n            return n_waiting", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Utility method of TelnetToSerial that returns the number of bytes available to read from its internal buffer, fetching new data from the Telnet connection if none is currently buffered."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "close", "line_number": 186, "body": "def close(self):\n        import signal\n\n        os.killpg(os.getpgid(self.subp.pid), signal.SIGTERM)", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Terminates the entire process group associated with the subprocess, ensuring all related processes are cleanly stopped."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "read", "line_number": 191, "body": "def read(self, size=1):\n        data = b\"\"\n        while len(data) < size:\n            data += self.subp.stdout.read(size - len(data))\n        return data", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Reads and returns a specified number of bytes from the subprocess's standard output stream, ensuring the exact amount requested is retrieved. Useful for precise, controlled reading of subprocess output data."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "write", "line_number": 197, "body": "def write(self, data):\n        self.subp.stdin.write(data)\n        return len(data)", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Method in ProcessToSerial that writes data to the subprocess's standard input stream and returns the number of bytes written. It enables sending data to an underlying process for further handling or processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "inWaiting", "line_number": 201, "body": "def inWaiting(self):\n        # res = self.sel.select(0)\n        res = self.poll.poll(0)\n        if res:\n            return 1\n        return 0", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Checks if there is incoming data available to read on the associated resource, indicating readiness for non-blocking input operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "close", "line_number": 239, "body": "def close(self):\n        import signal\n\n        os.killpg(os.getpgid(self.subp.pid), signal.SIGTERM)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Terminates the entire process group associated with the subprocess, ensuring that all related processes are cleanly stopped."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "read", "line_number": 244, "body": "def read(self, size=1):\n        return self.ser.read(size)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Reads and returns a specified number of bytes from a serial connection, enabling data retrieval from the underlying serial interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "write", "line_number": 247, "body": "def write(self, data):\n        return self.ser.write(data)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Utility method in ProcessPtyToTerminal that sends data to the associated serial interface, enabling communication through the terminal connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "inWaiting", "line_number": 250, "body": "def inWaiting(self):\n        return self.ser.inWaiting()", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Returns the number of bytes currently available to read from the underlying serial connection, enabling non-blocking input checks in terminal processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "close", "line_number": 288, "body": "def close(self):\n        self.serial.close()", "is_method": true, "class_name": "Pyboard", "function_description": "Closes the serial connection managed by the Pyboard instance, ensuring proper release of communication resources. This is essential for terminating interactions with the connected device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "read_until", "line_number": 291, "body": "def read_until(self, min_num_bytes, ending, timeout=10, data_consumer=None):\n        # if data_consumer is used then data is not accumulated and the ending must be 1 byte long\n        assert data_consumer is None or len(ending) == 1\n\n        data = self.serial.read(min_num_bytes)\n        if data_consumer:\n            data_consumer(data)\n        timeout_count = 0\n        while True:\n            if data.endswith(ending):\n                break\n            elif self.serial.inWaiting() > 0:\n                new_data = self.serial.read(1)\n                if data_consumer:\n                    data_consumer(new_data)\n                    data = new_data\n                else:\n                    data = data + new_data\n                timeout_count = 0\n            else:\n                timeout_count += 1\n                if timeout is not None and timeout_count >= 100 * timeout:\n                    break\n                time.sleep(0.01)\n        return data", "is_method": true, "class_name": "Pyboard", "function_description": "Reads data from a serial interface until a specified ending sequence is reached or a timeout occurs, optionally processing incoming data incrementally via a callback. Useful for streaming or buffered serial communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "enter_raw_repl", "line_number": 317, "body": "def enter_raw_repl(self):\n        self.serial.write(b\"\\r\\x03\\x03\")  # ctrl-C twice: interrupt any running program\n\n        # flush input (without relying on serial.flushInput())\n        n = self.serial.inWaiting()\n        while n > 0:\n            self.serial.read(n)\n            n = self.serial.inWaiting()\n\n        self.serial.write(b\"\\r\\x01\")  # ctrl-A: enter raw REPL\n        data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n>\")\n        if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n>\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")\n\n        self.serial.write(b\"\\x04\")  # ctrl-D: soft reset\n        data = self.read_until(1, b\"soft reboot\\r\\n\")\n        if not data.endswith(b\"soft reboot\\r\\n\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")\n        # By splitting this into 2 reads, it allows boot.py to print stuff,\n        # which will show up after the soft reboot and before the raw REPL.\n        data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n\")\n        if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")", "is_method": true, "class_name": "Pyboard", "function_description": "Method of the Pyboard class that interrupts running code and switches the board into raw REPL mode, enabling direct execution of raw Python commands on the device. It ensures the board is ready and responsive for interactive communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "exit_raw_repl", "line_number": 344, "body": "def exit_raw_repl(self):\n        self.serial.write(b\"\\r\\x02\")", "is_method": true, "class_name": "Pyboard", "function_description": "Terminates the raw REPL mode on the Pyboard by sending the appropriate control sequence over the serial connection. This allows transitioning from raw code execution back to the normal REPL state."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "follow", "line_number": 347, "body": "def follow(self, timeout, data_consumer=None):\n        # wait for normal output\n        data = self.read_until(1, b\"\\x04\", timeout=timeout, data_consumer=data_consumer)\n        if not data.endswith(b\"\\x04\"):\n            raise PyboardError(\"timeout waiting for first EOF reception\")\n        data = data[:-1]\n\n        # wait for error output\n        data_err = self.read_until(1, b\"\\x04\", timeout=timeout)\n        if not data_err.endswith(b\"\\x04\"):\n            raise PyboardError(\"timeout waiting for second EOF reception\")\n        data_err = data_err[:-1]\n\n        # return normal and error output\n        return data, data_err", "is_method": true, "class_name": "Pyboard", "function_description": "Utility method of the Pyboard class that reads and returns both normal and error output streams from a device until an EOF marker or timeout occurs, supporting optional data consumption during reading."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "raw_paste_write", "line_number": 363, "body": "def raw_paste_write(self, command_bytes):\n        # Read initial header, with window size.\n        data = self.serial.read(2)\n        window_size = data[0] | data[1] << 8\n        window_remain = window_size\n\n        # Write out the command_bytes data.\n        i = 0\n        while i < len(command_bytes):\n            while window_remain == 0 or self.serial.inWaiting():\n                data = self.serial.read(1)\n                if data == b\"\\x01\":\n                    # Device indicated that a new window of data can be sent.\n                    window_remain += window_size\n                elif data == b\"\\x04\":\n                    # Device indicated abrupt end.  Acknowledge it and finish.\n                    self.serial.write(b\"\\x04\")\n                    return\n                else:\n                    # Unexpected data from device.\n                    raise PyboardError(\"unexpected read during raw paste: {}\".format(data))\n            # Send out as much data as possible that fits within the allowed window.\n            b = command_bytes[i : min(i + window_remain, len(command_bytes))]\n            self.serial.write(b)\n            window_remain -= len(b)\n            i += len(b)\n\n        # Indicate end of data.\n        self.serial.write(b\"\\x04\")\n\n        # Wait for device to acknowledge end of data.\n        data = self.read_until(1, b\"\\x04\")\n        if not data.endswith(b\"\\x04\"):\n            raise PyboardError(\"could not complete raw paste: {}\".format(data))", "is_method": true, "class_name": "Pyboard", "function_description": "Provides a mechanism to send raw command bytes to a Pyboard device over serial, managing flow control windows and ensuring reliable data transfer with device acknowledgments."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "exec_raw_no_follow", "line_number": 398, "body": "def exec_raw_no_follow(self, command):\n        if isinstance(command, bytes):\n            command_bytes = command\n        else:\n            command_bytes = bytes(command, encoding=\"utf8\")\n\n        # check we have a prompt\n        data = self.read_until(1, b\">\")\n        if not data.endswith(b\">\"):\n            raise PyboardError(\"could not enter raw repl\")\n\n        if self.use_raw_paste:\n            # Try to enter raw-paste mode.\n            self.serial.write(b\"\\x05A\\x01\")\n            data = self.serial.read(2)\n            if data == b\"R\\x00\":\n                # Device understood raw-paste command but doesn't support it.\n                pass\n            elif data == b\"R\\x01\":\n                # Device supports raw-paste mode, write out the command using this mode.\n                return self.raw_paste_write(command_bytes)\n            else:\n                # Device doesn't support raw-paste, fall back to normal raw REPL.\n                data = self.read_until(1, b\"w REPL; CTRL-B to exit\\r\\n>\")\n                if not data.endswith(b\"w REPL; CTRL-B to exit\\r\\n>\"):\n                    print(data)\n                    raise PyboardError(\"could not enter raw repl\")\n            # Don't try to use raw-paste mode again for this connection.\n            self.use_raw_paste = False\n\n        # Write command using standard raw REPL, 256 bytes every 10ms.\n        for i in range(0, len(command_bytes), 256):\n            self.serial.write(command_bytes[i : min(i + 256, len(command_bytes))])\n            time.sleep(0.01)\n        self.serial.write(b\"\\x04\")\n\n        # check if we could exec command\n        data = self.serial.read(2)\n        if data != b\"OK\":\n            raise PyboardError(\"could not exec command (response: %r)\" % data)", "is_method": true, "class_name": "Pyboard", "function_description": "Provides a method to execute raw bytecode commands on a Pyboard device via serial connection, handling different raw REPL modes to send and run code directly for flexible remote script execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "exec_raw", "line_number": 439, "body": "def exec_raw(self, command, timeout=10, data_consumer=None):\n        self.exec_raw_no_follow(command)\n        return self.follow(timeout, data_consumer)", "is_method": true, "class_name": "Pyboard", "function_description": "Method of the Pyboard class that executes a raw command on the device and then monitors its output or response within a specified timeout, optionally processing the received data."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "eval", "line_number": 443, "body": "def eval(self, expression):\n        ret = self.exec_(\"print({})\".format(expression))\n        ret = ret.strip()\n        return ret", "is_method": true, "class_name": "Pyboard", "function_description": "Evaluates a Python expression on the Pyboard device and returns its printed result as a string. This function enables dynamic expression evaluation and output retrieval from the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "exec_", "line_number": 448, "body": "def exec_(self, command, data_consumer=None):\n        ret, ret_err = self.exec_raw(command, data_consumer=data_consumer)\n        if ret_err:\n            raise PyboardError(\"exception\", ret, ret_err)\n        return ret", "is_method": true, "class_name": "Pyboard", "function_description": "Executes a command on the Pyboard device, raising an error if execution fails, and returns the command's output. It provides a simple interface for running remote code on the Pyboard with error handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "execfile", "line_number": 454, "body": "def execfile(self, filename):\n        with open(filename, \"rb\") as f:\n            pyfile = f.read()\n        return self.exec_(pyfile)", "is_method": true, "class_name": "Pyboard", "function_description": "Provides a way to execute a Python script file by reading its contents and running it within the Pyboard environment. Useful for running external Python code on a microcontroller via the Pyboard interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "get_time", "line_number": 459, "body": "def get_time(self):\n        t = str(self.eval(\"pyb.RTC().datetime()\"), encoding=\"utf8\")[1:-1].split(\", \")\n        return int(t[4]) * 3600 + int(t[5]) * 60 + int(t[6])", "is_method": true, "class_name": "Pyboard", "function_description": "Method of the Pyboard class that retrieves the current time from the board's real-time clock and returns it as the total number of seconds elapsed since midnight."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_ls", "line_number": 463, "body": "def fs_ls(self, src):\n        cmd = (\n            \"import uos\\nfor f in uos.ilistdir(%s):\\n\"\n            \" print('{:12} {}{}'.format(f[3]if len(f)>3 else 0,f[0],'/'if f[1]&0x4000 else ''))\"\n            % ((\"'%s'\" % src) if src else \"\")\n        )\n        self.exec_(cmd, data_consumer=stdout_write_bytes)", "is_method": true, "class_name": "Pyboard", "function_description": "Lists files and directories at a given path on the Pyboard filesystem, formatting their names, sizes, and directory indicators for display. Useful for exploring and inspecting remote file storage on the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_cat", "line_number": 471, "body": "def fs_cat(self, src, chunk_size=256):\n        cmd = (\n            \"with open('%s') as f:\\n while 1:\\n\"\n            \"  b=f.read(%u)\\n  if not b:break\\n  print(b,end='')\" % (src, chunk_size)\n        )\n        self.exec_(cmd, data_consumer=stdout_write_bytes)", "is_method": true, "class_name": "Pyboard", "function_description": "Utility method in Pyboard that reads and outputs the contents of a specified file in fixed-size chunks, enabling efficient file content retrieval over a board connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_get", "line_number": 478, "body": "def fs_get(self, src, dest, chunk_size=256):\n        self.exec_(\"f=open('%s','rb')\\nr=f.read\" % src)\n        with open(dest, \"wb\") as f:\n            while True:\n                data = bytearray()\n                self.exec_(\"print(r(%u))\" % chunk_size, data_consumer=lambda d: data.extend(d))\n                assert data.endswith(b\"\\r\\n\\x04\")\n                try:\n                    data = ast.literal_eval(str(data[:-3], \"ascii\"))\n                    if not isinstance(data, bytes):\n                        raise ValueError(\"Not bytes\")\n                except (UnicodeError, ValueError) as e:\n                    raise PyboardError(\"fs_get: Could not interpret received data: %s\" % str(e))\n                if not data:\n                    break\n                f.write(data)\n        self.exec_(\"f.close()\")", "is_method": true, "class_name": "Pyboard", "function_description": "Method of Pyboard class that retrieves a file from the device's filesystem and saves it locally by reading it in chunks, enabling efficient transfer of files from the device to the host system."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_put", "line_number": 496, "body": "def fs_put(self, src, dest, chunk_size=256):\n        self.exec_(\"f=open('%s','wb')\\nw=f.write\" % dest)\n        with open(src, \"rb\") as f:\n            while True:\n                data = f.read(chunk_size)\n                if not data:\n                    break\n                if sys.version_info < (3,):\n                    self.exec_(\"w(b\" + repr(data) + \")\")\n                else:\n                    self.exec_(\"w(\" + repr(data) + \")\")\n        self.exec_(\"f.close()\")", "is_method": true, "class_name": "Pyboard", "function_description": "Utility method of the Pyboard class that uploads a local file to a remote filesystem by writing it in chunks, enabling efficient file transfer and storage on the target device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_mkdir", "line_number": 509, "body": "def fs_mkdir(self, dir):\n        self.exec_(\"import uos\\nuos.mkdir('%s')\" % dir)", "is_method": true, "class_name": "Pyboard", "function_description": "Creates a new directory at the specified path on the Pyboard filesystem by executing the appropriate command. This function enables programmatic folder management within the device's storage environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_rmdir", "line_number": 512, "body": "def fs_rmdir(self, dir):\n        self.exec_(\"import uos\\nuos.rmdir('%s')\" % dir)", "is_method": true, "class_name": "Pyboard", "function_description": "Core utility method of the Pyboard class that removes a specified directory from the device's filesystem by executing the corresponding command remotely. It enables programmatic directory management on the board."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_rm", "line_number": 515, "body": "def fs_rm(self, src):\n        self.exec_(\"import uos\\nuos.remove('%s')\" % src)", "is_method": true, "class_name": "Pyboard", "function_description": "Utility method of the Pyboard class that deletes a file at a specified path on the connected device's filesystem by executing a remove command remotely. It enables remote file management through direct filesystem access."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fname_remote", "line_number": 534, "body": "def fname_remote(src):\n        if src.startswith(\":\"):\n            src = src[1:]\n        return src", "is_method": false, "function_description": "This function removes a leading colon from a string if present, returning the modified or original string. It is useful for normalizing or preprocessing source identifiers that may have optional prefixes."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fname_cp_dest", "line_number": 539, "body": "def fname_cp_dest(src, dest):\n        src = src.rsplit(\"/\", 1)[-1]\n        if dest is None or dest == \"\":\n            dest = src\n        elif dest == \".\":\n            dest = \"./\" + src\n        elif dest.endswith(\"/\"):\n            dest += src\n        return dest", "is_method": false, "function_description": "Utility function that determines the destination file path based on a source filename and a destination input, handling cases like empty, current directory, or directory paths. It simplifies specifying target file locations in file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "execbuffer", "line_number": 681, "body": "def execbuffer(buf):\n            try:\n                if args.no_follow:\n                    pyb.exec_raw_no_follow(buf)\n                    ret_err = None\n                else:\n                    ret, ret_err = pyb.exec_raw(\n                        buf, timeout=None, data_consumer=stdout_write_bytes\n                    )\n            except PyboardError as er:\n                print(er)\n                pyb.close()\n                sys.exit(1)\n            except KeyboardInterrupt:\n                sys.exit(1)\n            if ret_err:\n                pyb.exit_raw_repl()\n                pyb.close()\n                stdout_write_bytes(ret_err)\n                sys.exit(1)", "is_method": false, "function_description": "Executes a buffer of Python code on a connected Pyboard device, handling output consumption and error management, facilitating remote code execution with optional follow mode and robust exit on failure."}]