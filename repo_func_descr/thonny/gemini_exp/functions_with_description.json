[{"file": "./dataset/RepoExec/test-apps/thonny/setup.py", "function": "recursive_files", "line_number": 6, "body": "def recursive_files(directory):\n    paths = []\n    for (path, _, filenames) in os.walk(directory):\n        for filename in filenames:\n            paths.append(os.path.join('..', path, filename))\n    return paths", "is_method": false, "function_description": "Recursively collects all file paths within a given directory and its subdirectories. Paths are returned relative to the parent of the current working directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "which", "line_number": 18, "body": "def which(cmd, mode=os.F_OK | os.X_OK, path=None):\n    \"\"\"Given a command, mode, and a PATH string, return the path which\n    conforms to the given mode on the PATH, or None if there is no such\n    file.\n\n    `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n    of os.environ.get(\"PATH\"), or can be overridden with a custom search\n    path.\n    (Copied from Python 3.5 shutil)\n    \"\"\"\n    # Check that a given file can be accessed with the correct mode.\n    # Additionally check that `file` is not a directory, as on Windows\n    # directories pass the os.access check.\n    def _access_check(fn, mode):\n        return os.path.exists(fn) and os.access(fn, mode) and not os.path.isdir(fn)\n\n    # If we're given a path with a directory part, look it up directly rather\n    # than referring to PATH directories. This includes checking relative to the\n    # current directory, e.g. ./script\n    if os.path.dirname(cmd):\n        if _access_check(cmd, mode):\n            return cmd\n        return None\n\n    if path is None:\n        path = os.environ.get(\"PATH\", os.defpath)\n    if not path:\n        return None\n    path = path.split(os.pathsep)\n\n    files = [cmd]\n\n    seen = set()\n    for dir_ in path:\n        normdir = os.path.normcase(dir_)\n        if not normdir in seen:\n            seen.add(normdir)\n            for thefile in files:\n                name = os.path.join(dir_, thefile)\n                if _access_check(name, mode):\n                    return name\n    return None", "is_method": false, "function_description": "This function locates the full path to a command or executable file, searching specified directories (like PATH) and verifying access permissions. It determines if a given program is accessible."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "create_launcher", "line_number": 62, "body": "def create_launcher(source_filename, target_filename, replacements={}):\n    target_dir = os.path.dirname(target_filename)\n    if not os.path.exists(target_dir):\n        os.makedirs(target_dir)\n\n    with open(source_filename) as f:\n        content = f.read()\n\n    with open(target_filename, mode=\"w\") as f:\n        for from_str in replacements:\n            to_str = replacements[from_str]\n            content = content.replace(from_str, to_str)\n        f.write(content)\n\n    # Seems that even desktop files have to be executable\n    # https://help.ubuntu.com/community/UnityLaunchersAndDesktopFiles\n    os.chmod(target_filename, 0o755)", "is_method": false, "function_description": "Generates a customized executable launcher or script file from a source template. It performs string replacements and sets appropriate file permissions for execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "try_to_refresh_desktop_and_menus", "line_number": 81, "body": "def try_to_refresh_desktop_and_menus(menu_dir):\n    \"\"\"In KDE, the .destop files are not taken into account immediately\"\"\"\n    for cmd in [\"kbuildsycoca5\", \"kbuildsycoca4\", \"kbuildsycoca\"]:\n        if which(cmd):\n            subprocess.call([cmd])\n            break\n\n    udd = \"update-desktop-database\"\n    if which(udd):\n        subprocess.call([udd, menu_dir])", "is_method": false, "function_description": "Refreshes the desktop and application menus in KDE environments. It updates system caches and desktop file databases to reflect changes immediately."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "print_task", "line_number": 106, "body": "def print_task(desc):\n    print((desc + \" \").ljust(70, \".\") + \" \", end=\"\")", "is_method": false, "function_description": "Formats and prints a task description string, padding it with dots to a fixed width for clear alignment in terminal output."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "get_desktop_path", "line_number": 110, "body": "def get_desktop_path():\n    try:\n        return subprocess.check_output([\"xdg-user-dir\", \"DESKTOP\"]).strip().decode()\n    except:\n        return os.path.expanduser(\"~/Desktop\")", "is_method": false, "function_description": "Retrieves the absolute path to the user's desktop directory. It provides a reliable way for applications to locate and interact with the user's desktop regardless of the operating system."}, {"file": "./dataset/RepoExec/test-apps/thonny/packaging/linux/install.py", "function": "_access_check", "line_number": 31, "body": "def _access_check(fn, mode):\n        return os.path.exists(fn) and os.access(fn, mode) and not os.path.isdir(fn)", "is_method": false, "function_description": "This function verifies if a given path points to an existing, accessible, non-directory file. It provides a quick check for file interaction permissions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "get_statement_of_position", "line_number": 10, "body": "def get_statement_of_position(node, pos):\n    import jedi.parser_utils\n\n    func = getattr(\n        jedi.parser_utils, \"get_statement_of_position\", _copy_of_get_statement_of_position\n    )\n    return func(node, pos)", "is_method": false, "function_description": "Retrieves the abstract syntax tree (AST) node representing the statement at a specified position within a given code node. This is useful for static code analysis tools."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "_copy_of_get_statement_of_position", "line_number": 20, "body": "def _copy_of_get_statement_of_position(node, pos):\n    # https://github.com/davidhalter/jedi/commit/9f3a2f93c48eda24e2dcc25e54eb7cc10aa73848\n    from parso.python import tree\n\n    for c in node.children:\n        if c.start_pos <= pos <= c.end_pos:\n            if (\n                c.type\n                not in (\n                    \"decorated\",\n                    \"simple_stmt\",\n                    \"suite\",\n                    \"async_stmt\",\n                    \"async_funcdef\",\n                )\n                and not isinstance(c, (tree.Flow, tree.ClassOrFunc))\n            ):\n                return c\n            else:\n                try:\n                    return _copy_of_get_statement_of_position(c, pos)\n                except AttributeError:\n                    pass  # Must be a non-scope\n    return None", "is_method": false, "function_description": "Locates the most specific Python AST node (like an expression or definition) containing a given source code position. It navigates the AST, bypassing general structural elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "parse_source", "line_number": 46, "body": "def parse_source(source):\n    import parso\n\n    return parso.parse(source)", "is_method": false, "function_description": "Parses Python source code from a string into an abstract syntax tree using the `parso` library. This enables structured analysis and manipulation of the code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "get_script_completions", "line_number": 52, "body": "def get_script_completions(source: str, row: int, column: int, filename: str, sys_path=None):\n    import jedi\n\n    if _using_older_jedi(jedi):\n        try:\n            script = jedi.Script(source, row, column, filename, sys_path=sys_path)\n        except Exception as e:\n            logger.info(\"Could not get completions with given sys_path\", exc_info=e)\n            script = jedi.Script(source, row, column, filename)\n\n        completions = script.completions()\n    else:\n        script = jedi.Script(code=source, path=filename, project=_get_new_jedi_project(sys_path))\n        completions = script.complete(line=row, column=column)\n\n    return _tweak_completions(completions)", "is_method": false, "function_description": "Generates intelligent code completion suggestions for a Python script at a given cursor position. It leverages the Jedi library to provide useful autocompletion capabilities for developer tools."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "get_interpreter_completions", "line_number": 70, "body": "def get_interpreter_completions(source: str, namespaces: List[Dict], sys_path=None):\n    import jedi\n\n    if _using_older_jedi(jedi):\n        try:\n            interpreter = jedi.Interpreter(source, namespaces, sys_path=sys_path)\n        except Exception as e:\n            logger.info(\"Could not get completions with given sys_path\", exc_info=e)\n            interpreter = jedi.Interpreter(source, namespaces)\n    else:\n        # NB! Can't send project for Interpreter in 0.18\n        # https://github.com/davidhalter/jedi/pull/1734\n        interpreter = jedi.Interpreter(source, namespaces)\n    if hasattr(interpreter, \"completions\"):\n        # up to jedi 0.17\n        return _tweak_completions(interpreter.completions())\n    else:\n        return _tweak_completions(interpreter.complete())", "is_method": false, "function_description": "This function uses the Jedi library to generate code completions for a given Python source code and its execution environment. It provides a core capability for auto-completion features in IDEs or interactive shells."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "_get_new_jedi_project", "line_number": 90, "body": "def _get_new_jedi_project(sys_path):\n    if not sys_path:\n        return None\n    else:\n        import jedi\n\n        return jedi.Project(path=sys_path[0], added_sys_path=sys_path)", "is_method": false, "function_description": "Initializes a `jedi.Project` object for static code analysis. It configures the project using the provided system path, enabling code intelligence features like autocompletion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "_tweak_completions", "line_number": 99, "body": "def _tweak_completions(completions):\n    # In jedi before 0.16, the name attribute did not contain trailing '=' for argument completions,\n    # since 0.16 it does. Need to ensure similar result for all supported versions.\n    result = []\n    for completion in completions:\n        name = completion.name\n        complete = completion.complete\n        if complete.endswith(\"=\") and not name.endswith(\"=\"):\n            name += \"=\"\n\n        result.append(\n            ThonnyCompletion(\n                name=name,\n                complete=complete,\n                type=completion.type,\n                description=completion.description,\n                parent=completion.parent,\n                full_name=completion.full_name,\n            )\n        )\n\n    return result", "is_method": false, "function_description": "Standardizes completion objects for consistent behavior across different library versions. It ensures argument completion names include a trailing equals sign for uniformity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "get_definitions", "line_number": 123, "body": "def get_definitions(source: str, row: int, column: int, filename: str):\n    import jedi\n\n    if _using_older_jedi(jedi):\n        script = jedi.Script(source, row, column, filename)\n        return script.goto_definitions()\n    else:\n        script = jedi.Script(code=source, path=filename)\n        return script.infer(line=row, column=column)", "is_method": false, "function_description": "Provides a service to locate the definition of a Python symbol within source code at a given position. It powers \"go to definition\" features in code editors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "_using_older_jedi", "line_number": 134, "body": "def _using_older_jedi(jedi):\n    return jedi.__version__[:4] in [\"0.13\", \"0.14\", \"0.15\", \"0.16\", \"0.17\"]", "is_method": false, "function_description": "Determines if the given Jedi library instance is an older version (0.13-0.17), typically for managing compatibility or conditional feature support."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/jedi_utils.py", "function": "__getitem__", "line_number": 147, "body": "def __getitem__(self, key):\n        return self.__dict__[key]", "is_method": true, "class_name": "ThonnyCompletion", "function_description": "Enables dictionary-like access to the object's internal attributes. It allows retrieving attribute values using square bracket notation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "advertise_ready", "line_number": 226, "body": "def advertise_ready(self):\n        self.event_generate(\"WorkbenchReady\")\n        self.ready = True", "is_method": true, "class_name": "Workbench", "function_description": "Notifies other components that the Workbench is ready for operation. It emits a 'WorkbenchReady' event and updates the internal ready state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_make_sanity_checks", "line_number": 230, "body": "def _make_sanity_checks(self):\n        home_dir = os.path.expanduser(\"~\")\n        bad_home_msg = None\n        if home_dir == \"~\":\n            bad_home_msg = \"Can not find your home directory.\"\n        elif not os.path.exists(home_dir):\n            bad_home_msg = \"Reported home directory (%s) does not exist.\" % home_dir\n        if bad_home_msg:\n            messagebox.showwarning(\n                \"Problems with home directory\",\n                bad_home_msg + \"\\nThis may cause problems for Thonny.\",\n                master=self,\n            )", "is_method": true, "class_name": "Workbench", "function_description": "Validates the user's home directory for existence and accessibility issues. Displays a warning if problems are detected, ensuring the workbench can operate correctly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_try_action", "line_number": 244, "body": "def _try_action(self, action: Callable) -> None:\n        try:\n            action()\n        except Exception:\n            self.report_exception()", "is_method": true, "class_name": "Workbench", "function_description": "Executes a provided action within the Workbench context. It catches any exceptions raised during execution and reports them for robust operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_configuration", "line_number": 250, "body": "def _init_configuration(self) -> None:\n        self._configuration_manager = try_load_configuration(thonny.CONFIGURATION_FILE)\n        self._configuration_pages = []  # type: List[Tuple[str, str, Type[tk.Widget]]]\n\n        self.set_default(\"general.single_instance\", thonny.SINGLE_INSTANCE_DEFAULT)\n        self.set_default(\"general.ui_mode\", \"simple\" if running_on_rpi() else \"regular\")\n        self.set_default(\"general.debug_mode\", False)\n        self.set_default(\"general.disable_notification_sound\", False)\n        self.set_default(\"general.scaling\", \"default\")\n        self.set_default(\"general.language\", languages.BASE_LANGUAGE_CODE)\n        self.set_default(\"general.font_scaling_mode\", \"default\")\n        self.set_default(\"general.environment\", [])\n        self.set_default(\"file.avoid_zenity\", False)\n        self.set_default(\"run.working_directory\", os.path.expanduser(\"~\"))\n        self.update_debug_mode()", "is_method": true, "class_name": "Workbench", "function_description": "This Workbench method initializes the application's configuration manager and establishes default settings for various operational aspects, including general behavior, file handling, and execution environment. It ensures the application starts with a defined and consistent set of parameters."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_tweak_environment", "line_number": 266, "body": "def _tweak_environment(self):\n        for entry in self.get_option(\"general.environment\"):\n            if \"=\" in entry:\n                key, val = entry.split(\"=\", maxsplit=1)\n                os.environ[key] = os.path.expandvars(val)\n            else:\n                logger.warning(\"No '=' in environment entry '%s'\", entry)", "is_method": true, "class_name": "Workbench", "function_description": "Configures the process environment by setting environment variables from the Workbench's general options, allowing dynamic customization of its operational context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "update_debug_mode", "line_number": 274, "body": "def update_debug_mode(self):\n        os.environ[\"THONNY_DEBUG\"] = str(self.get_option(\"general.debug_mode\", False))\n        thonny.set_logging_level()", "is_method": true, "class_name": "Workbench", "function_description": "Updates Thonny's debugging environment and logging level according to the application's current debug mode setting. It ensures the system's debug state reflects user preferences."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_language", "line_number": 278, "body": "def _init_language(self) -> None:\n        \"\"\"Initialize language.\"\"\"\n        languages.set_language(self.get_option(\"general.language\"))", "is_method": true, "class_name": "Workbench", "function_description": "Initializes the application's global language setting by retrieving the 'general.language' option."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_window", "line_number": 282, "body": "def _init_window(self) -> None:\n        self.title(\"Thonny\")\n\n        self.set_default(\"layout.zoomed\", False)\n        self.set_default(\"layout.top\", 15)\n        self.set_default(\"layout.left\", 150)\n        if self.in_simple_mode():\n            self.set_default(\"layout.width\", 1050)\n            self.set_default(\"layout.height\", 700)\n        else:\n            self.set_default(\"layout.width\", 800)\n            self.set_default(\"layout.height\", 650)\n        self.set_default(\"layout.w_width\", 200)\n        self.set_default(\"layout.e_width\", 200)\n        self.set_default(\"layout.s_height\", 200)\n\n        # I don't actually need saved options for Full screen/maximize view,\n        # but it's easier to create menu items, if I use configuration manager's variables\n        self.set_default(\"view.full_screen\", False)\n        self.set_default(\"view.maximize_view\", False)\n\n        # In order to avoid confusion set these settings to False\n        # even if they were True when Thonny was last run\n        self.set_option(\"view.full_screen\", False)\n        self.set_option(\"view.maximize_view\", False)\n\n        self.geometry(\n            \"{0}x{1}+{2}+{3}\".format(\n                min(max(self.get_option(\"layout.width\"), 320), self.winfo_screenwidth()),\n                min(max(self.get_option(\"layout.height\"), 240), self.winfo_screenheight()),\n                min(max(self.get_option(\"layout.left\"), 0), self.winfo_screenwidth() - 200),\n                min(max(self.get_option(\"layout.top\"), 0), self.winfo_screenheight() - 200),\n            )\n        )\n\n        if self.get_option(\"layout.zoomed\"):\n            ui_utils.set_zoomed(self, True)\n\n        self.protocol(\"WM_DELETE_WINDOW\", self._on_close)\n        self.bind(\"<Configure>\", self._on_configure, True)", "is_method": true, "class_name": "Workbench", "function_description": "Initializes the application's main window. It sets the title, default dimensions, position, and initial view states, also binding essential window events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_statusbar", "line_number": 323, "body": "def _init_statusbar(self):\n        self._statusbar = ttk.Frame(self)", "is_method": true, "class_name": "Workbench", "function_description": "Initializes the status bar component for the Workbench user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_icon", "line_number": 326, "body": "def _init_icon(self) -> None:\n        # Window icons\n        if running_on_linux() and ui_utils.get_tk_version_info() >= (8, 6):\n            self.iconphoto(True, self.get_image(\"thonny.png\"))\n        else:\n            icon_file = os.path.join(self.get_package_dir(), \"res\", \"thonny.ico\")\n            try:\n                self.iconbitmap(icon_file, default=icon_file)\n            except Exception:\n                try:\n                    # seems to work in mac\n                    self.iconbitmap(icon_file)\n                except Exception:\n                    pass", "is_method": true, "class_name": "Workbench", "function_description": "Configures the Workbench's main application window icon. It ensures the correct visual display across different operating systems and Tkinter versions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_menu", "line_number": 341, "body": "def _init_menu(self) -> None:\n        self.option_add(\"*tearOff\", tk.FALSE)\n        if lookup_style_option(\"Menubar\", \"custom\", False):\n            self._menubar = ui_utils.CustomMenubar(\n                self\n            )  # type: Union[tk.Menu, ui_utils.CustomMenubar]\n            if self.get_ui_mode() != \"simple\":\n                self._menubar.grid(row=0, sticky=\"nsew\")\n        else:\n            opts = get_style_configuration(\"Menubar\")\n            if \"custom\" in opts:\n                del opts[\"custom\"]\n            self._menubar = tk.Menu(self, **opts)\n            if self.get_ui_mode() != \"simple\":\n                self[\"menu\"] = self._menubar\n        self._menus = {}  # type: Dict[str, tk.Menu]\n        self._menu_item_specs = (\n            {}\n        )  # type: Dict[Tuple[str, str], MenuItem] # key is pair (menu_name, command_label)\n\n        # create standard menus in correct order\n        self.get_menu(\"file\", tr(\"File\"))\n        self.get_menu(\"edit\", tr(\"Edit\"))\n        self.get_menu(\"view\", tr(\"View\"))\n        self.get_menu(\"run\", tr(\"Run\"))\n        self.get_menu(\"tools\", tr(\"Tools\"))\n        self.get_menu(\"help\", tr(\"Help\"))", "is_method": true, "class_name": "Workbench", "function_description": "This method initializes the Workbench's main menu bar, creating standard top-level menus like File and Edit. It also prepares the internal data structures for managing all application menus."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_load_plugins", "line_number": 369, "body": "def _load_plugins(self) -> None:\n        # built-in plugins\n        import thonny.plugins  # pylint: disable=redefined-outer-name\n\n        self._load_plugins_from_path(thonny.plugins.__path__, \"thonny.plugins.\")  # type: ignore\n\n        # 3rd party plugins from namespace package\n        try:\n            import thonnycontrib  # @UnresolvedImport\n        except ImportError:\n            # No 3rd party plugins installed\n            pass\n        else:\n            self._load_plugins_from_path(thonnycontrib.__path__, \"thonnycontrib.\")", "is_method": true, "class_name": "Workbench", "function_description": "Loads all available built-in and third-party plugins for the Workbench application. This service enables the Workbench to extend its core functionality through modular additions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_load_plugins_from_path", "line_number": 384, "body": "def _load_plugins_from_path(self, path: List[str], prefix: str) -> None:\n        load_function_name = \"load_plugin\"\n\n        modules = []\n        for _, module_name, _ in sorted(pkgutil.iter_modules(path, prefix), key=lambda x: x[2]):\n            if module_name in OBSOLETE_PLUGINS:\n                logging.debug(\"Skipping plug-in %s\", module_name)\n            else:\n                try:\n                    m = importlib.import_module(module_name)\n                    if hasattr(m, load_function_name):\n                        modules.append(m)\n                except Exception:\n                    logging.exception(\"Failed loading plugin '\" + module_name + \"'\")\n\n        def module_sort_key(m):\n            return getattr(m, \"load_order_key\", m.__name__)\n\n        for m in sorted(modules, key=module_sort_key):\n            getattr(m, load_function_name)()", "is_method": true, "class_name": "Workbench", "function_description": "Loads and initializes plugins for the Workbench by discovering them from specified paths. It imports and executes a designated load function within each eligible plugin."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_fonts", "line_number": 405, "body": "def _init_fonts(self) -> None:\n        # set up editor and shell fonts\n        self.set_default(\"view.io_font_family\", \"Courier\" if running_on_mac_os() else \"Courier New\")\n\n        default_editor_family = \"Courier New\"\n        families = tk_font.families()\n\n        for family in [\"Consolas\", \"Ubuntu Mono\", \"Menlo\", \"DejaVu Sans Mono\"]:\n            if family in families:\n                default_editor_family = family\n                break\n\n        self.set_default(\"view.editor_font_family\", default_editor_family)\n\n        if running_on_mac_os():\n            self.set_default(\"view.editor_font_size\", 14)\n            self.set_default(\"view.io_font_size\", 12)\n        elif self.in_simple_mode():\n            self.set_default(\"view.editor_font_size\", 12)\n            self.set_default(\"view.io_font_size\", 12)\n        else:\n            self.set_default(\"view.editor_font_size\", 13)\n            self.set_default(\"view.io_font_size\", 11)\n\n        default_font = tk_font.nametofont(\"TkDefaultFont\")\n\n        if running_on_linux():\n            heading_font = tk_font.nametofont(\"TkHeadingFont\")\n            heading_font.configure(weight=\"normal\")\n            caption_font = tk_font.nametofont(\"TkCaptionFont\")\n            caption_font.configure(weight=\"normal\", size=default_font.cget(\"size\"))\n\n        small_link_ratio = 0.8 if running_on_windows() else 0.7\n        self._fonts = [\n            tk_font.Font(\n                name=\"SmallLinkFont\",\n                family=default_font.cget(\"family\"),\n                size=int(default_font.cget(\"size\") * small_link_ratio),\n                underline=True,\n            ),\n            tk_font.Font(name=\"IOFont\", family=self.get_option(\"view.io_font_family\")),\n            tk_font.Font(\n                name=\"BoldIOFont\", family=self.get_option(\"view.io_font_family\"), weight=\"bold\"\n            ),\n            tk_font.Font(\n                name=\"UnderlineIOFont\",\n                family=self.get_option(\"view.io_font_family\"),\n                underline=True,\n            ),\n            tk_font.Font(\n                name=\"ItalicIOFont\", family=self.get_option(\"view.io_font_family\"), slant=\"italic\"\n            ),\n            tk_font.Font(\n                name=\"BoldItalicIOFont\",\n                family=self.get_option(\"view.io_font_family\"),\n                weight=\"bold\",\n                slant=\"italic\",\n            ),\n            tk_font.Font(name=\"EditorFont\", family=self.get_option(\"view.editor_font_family\")),\n            tk_font.Font(name=\"SmallEditorFont\", family=self.get_option(\"view.editor_font_family\")),\n            tk_font.Font(\n                name=\"BoldEditorFont\",\n                family=self.get_option(\"view.editor_font_family\"),\n                weight=\"bold\",\n            ),\n            tk_font.Font(\n                name=\"ItalicEditorFont\",\n                family=self.get_option(\"view.editor_font_family\"),\n                slant=\"italic\",\n            ),\n            tk_font.Font(\n                name=\"BoldItalicEditorFont\",\n                family=self.get_option(\"view.editor_font_family\"),\n                weight=\"bold\",\n                slant=\"italic\",\n            ),\n            tk_font.Font(\n                name=\"TreeviewFont\",\n                family=default_font.cget(\"family\"),\n                size=default_font.cget(\"size\"),\n            ),\n            tk_font.Font(\n                name=\"BoldTkDefaultFont\",\n                family=default_font.cget(\"family\"),\n                size=default_font.cget(\"size\"),\n                weight=\"bold\",\n            ),\n            tk_font.Font(\n                name=\"ItalicTkDefaultFont\",\n                family=default_font.cget(\"family\"),\n                size=default_font.cget(\"size\"),\n                slant=\"italic\",\n            ),\n            tk_font.Font(\n                name=\"UnderlineTkDefaultFont\",\n                family=default_font.cget(\"family\"),\n                size=default_font.cget(\"size\"),\n                underline=1,\n            ),\n        ]\n\n        self.update_fonts()", "is_method": true, "class_name": "Workbench", "function_description": "Initializes and configures all default and styled fonts for the Workbench application's user interface. It adapts settings based on the operating system and application mode for consistent display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_start_runner", "line_number": 508, "body": "def _start_runner(self) -> None:\n        try:\n            self.update_idletasks()  # allow UI to complete\n            thonny._runner = self._runner\n            self._runner.start()\n            self._update_toolbar()\n        except Exception:\n            self.report_exception(\"Error when initializing backend\")", "is_method": true, "class_name": "Workbench", "function_description": "Starts the Workbench's internal execution runner, providing the core capability to launch the application's backend process while ensuring UI responsiveness and updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_check_init_server_loop", "line_number": 517, "body": "def _check_init_server_loop(self) -> None:\n        \"\"\"Socket will listen requests from newer Thonny instances,\n        which try to delegate opening files to older instance\"\"\"\n\n        if not self.get_option(\"general.single_instance\") or os.path.exists(\n            thonny.get_ipc_file_path()\n        ):\n            self._ipc_requests = None\n            return\n\n        self._ipc_requests = queue.Queue()  # type: queue.Queue[bytes]\n        server_socket, actual_secret = self._create_server_socket()\n        server_socket.listen(10)\n\n        def server_loop():\n            while True:\n                logging.debug(\"Waiting for next client\")\n                (client_socket, _) = server_socket.accept()\n                try:\n                    data = bytes()\n                    while True:\n                        new_data = client_socket.recv(1024)\n                        if len(new_data) > 0:\n                            data += new_data\n                        else:\n                            break\n                    proposed_secret, args = ast.literal_eval(data.decode(\"UTF-8\"))\n                    if proposed_secret == actual_secret:\n                        self._ipc_requests.put(args)\n                        # respond OK\n                        client_socket.sendall(SERVER_SUCCESS.encode(encoding=\"utf-8\"))\n                        client_socket.shutdown(socket.SHUT_WR)\n                        logging.debug(\"AFTER NEW REQUEST %s\", client_socket)\n                    else:\n                        client_socket.shutdown(socket.SHUT_WR)\n                        raise PermissionError(\"Wrong secret\")\n\n                except Exception as e:\n                    logger.exception(\"Error in ipc server loop\", exc_info=e)\n\n        Thread(target=server_loop, daemon=True).start()", "is_method": true, "class_name": "Workbench", "function_description": "Establishes a background server to receive and queue file opening requests from new Thonny instances, facilitating single-instance application management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_create_server_socket", "line_number": 559, "body": "def _create_server_socket(self):\n        if running_on_windows():\n            server_socket = socket.socket(socket.AF_INET)  # @UndefinedVariable\n            server_socket.bind((\"127.0.0.1\", 0))\n\n            # advertise the port and secret\n            port = server_socket.getsockname()[1]\n            import uuid\n\n            secret = str(uuid.uuid4())\n\n            with open(thonny.get_ipc_file_path(), \"w\") as fp:\n                fp.write(str(port) + \"\\n\")\n                fp.write(secret + \"\\n\")\n\n        else:\n            server_socket = socket.socket(socket.AF_UNIX)  # @UndefinedVariable\n            server_socket.bind(thonny.get_ipc_file_path())\n            secret = \"\"\n\n        os.chmod(thonny.get_ipc_file_path(), 0o600)\n        return server_socket, secret", "is_method": true, "class_name": "Workbench", "function_description": "Initializes a platform-aware server socket for inter-process communication. It exposes connection details and a secret via an IPC file to enable secure client connections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_commands", "line_number": 582, "body": "def _init_commands(self) -> None:\n\n        self.add_command(\n            \"exit\",\n            \"file\",\n            tr(\"Exit\"),\n            self._on_close,\n            default_sequence=select_sequence(\"<Alt-F4>\", \"<Command-q>\", \"<Control-q>\"),\n            extra_sequences=[\"<Alt-F4>\"]\n            if running_on_linux()\n            else [\"<Control-q>\"]\n            if running_on_windows()\n            else [],\n        )\n\n        self.add_command(\"show_options\", \"tools\", tr(\"Options...\"), self.show_options, group=180)\n        self.createcommand(\"::tk::mac::ShowPreferences\", self.show_options)\n        self.createcommand(\"::tk::mac::Quit\", self._mac_quit)\n\n        self.add_command(\n            \"increase_font_size\",\n            \"view\",\n            tr(\"Increase font size\"),\n            lambda: self._change_font_size(1),\n            default_sequence=select_sequence(\"<Control-plus>\", \"<Command-Shift-plus>\"),\n            extra_sequences=[\"<Control-KP_Add>\"],\n            group=60,\n        )\n\n        self.add_command(\n            \"decrease_font_size\",\n            \"view\",\n            tr(\"Decrease font size\"),\n            lambda: self._change_font_size(-1),\n            default_sequence=select_sequence(\"<Control-minus>\", \"<Command-minus>\"),\n            extra_sequences=[\"<Control-KP_Subtract>\"],\n            group=60,\n        )\n\n        self.bind(\"<Control-MouseWheel>\", self._cmd_zoom_with_mouse, True)\n\n        self.add_command(\n            \"focus_editor\",\n            \"view\",\n            tr(\"Focus editor\"),\n            self._cmd_focus_editor,\n            default_sequence=select_sequence(\"<Alt-e>\", \"<Command-Alt-e>\"),\n            group=70,\n        )\n\n        self.add_command(\n            \"focus_shell\",\n            \"view\",\n            tr(\"Focus shell\"),\n            self._cmd_focus_shell,\n            default_sequence=select_sequence(\"<Alt-s>\", \"<Command-Alt-s>\"),\n            group=70,\n        )\n\n        if self.get_ui_mode() == \"expert\":\n\n            self.add_command(\n                \"toggle_maximize_view\",\n                \"view\",\n                tr(\"Maximize view\"),\n                self._cmd_toggle_maximize_view,\n                flag_name=\"view.maximize_view\",\n                default_sequence=None,\n                group=80,\n            )\n            self.bind_class(\"TNotebook\", \"<Double-Button-1>\", self._maximize_view, True)\n            self.bind(\"<Escape>\", self._unmaximize_view, True)\n\n            self.add_command(\n                \"toggle_maximize_view\",\n                \"view\",\n                tr(\"Full screen\"),\n                self._cmd_toggle_full_screen,\n                flag_name=\"view.full_screen\",\n                default_sequence=select_sequence(\"<F11>\", \"<Command-Shift-F>\"),\n                group=80,\n            )\n\n        if self.in_simple_mode():\n            self.add_command(\n                \"font\",\n                \"tools\",\n                tr(\"Change font size\"),\n                caption=tr(\"Zoom\"),\n                handler=self._toggle_font_size,\n                image=\"zoom\",\n                include_in_toolbar=True,\n            )\n\n            self.add_command(\n                \"quit\",\n                \"help\",\n                tr(\"Exit Thonny\"),\n                self._on_close,\n                image=\"quit\",\n                caption=tr(\"Quit\"),\n                include_in_toolbar=True,\n                group=101,\n            )\n\n        if thonny.in_debug_mode():\n            self.bind_all(\"<Control-Shift-Alt-D>\", self._print_state_for_debugging, True)", "is_method": true, "class_name": "Workbench", "function_description": "This method initializes the Workbench's interactive command system. It defines menu actions, keyboard shortcuts, and event bindings for various core application functionalities like exiting, view management, and font size adjustments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_containers", "line_number": 693, "body": "def _init_containers(self) -> None:\n\n        margin = 10\n        # Main frame functions as\n        # - a background behind padding of main_pw, without this OS X leaves white border\n        # - a container to be hidden, when a view is maximized and restored when view is back home\n        main_frame = ttk.Frame(self)  #\n        self._main_frame = main_frame\n        main_frame.grid(row=1, column=0, sticky=tk.NSEW)\n        self.columnconfigure(0, weight=1)\n        self.rowconfigure(1, weight=1)\n        self._maximized_view = None  # type: Optional[tk.Widget]\n\n        self._toolbar = ttk.Frame(main_frame, padding=0)\n        self._toolbar.grid(column=0, row=0, sticky=tk.NSEW, padx=margin, pady=(5, 0))\n\n        self.set_default(\"layout.west_pw_width\", self.scale(150))\n        self.set_default(\"layout.east_pw_width\", self.scale(150))\n\n        self.set_default(\"layout.s_nb_height\", self.scale(150))\n        self.set_default(\"layout.nw_nb_height\", self.scale(150))\n        self.set_default(\"layout.sw_nb_height\", self.scale(150))\n        self.set_default(\"layout.ne_nb_height\", self.scale(150))\n        self.set_default(\"layout.se_nb_height\", self.scale(150))\n\n        self._main_pw = AutomaticPanedWindow(main_frame, orient=tk.HORIZONTAL)\n\n        self._main_pw.grid(column=0, row=1, sticky=tk.NSEW, padx=margin, pady=(margin, 0))\n        main_frame.columnconfigure(0, weight=1)\n        main_frame.rowconfigure(1, weight=1)\n\n        self._west_pw = AutomaticPanedWindow(\n            self._main_pw,\n            1,\n            orient=tk.VERTICAL,\n            preferred_size_in_pw=self.get_option(\"layout.west_pw_width\"),\n        )\n        self._center_pw = AutomaticPanedWindow(self._main_pw, 2, orient=tk.VERTICAL)\n        self._east_pw = AutomaticPanedWindow(\n            self._main_pw,\n            3,\n            orient=tk.VERTICAL,\n            preferred_size_in_pw=self.get_option(\"layout.east_pw_width\"),\n        )\n\n        self._view_notebooks = {\n            \"nw\": AutomaticNotebook(\n                self._west_pw, 1, preferred_size_in_pw=self.get_option(\"layout.nw_nb_height\")\n            ),\n            \"w\": AutomaticNotebook(self._west_pw, 2),\n            \"sw\": AutomaticNotebook(\n                self._west_pw, 3, preferred_size_in_pw=self.get_option(\"layout.sw_nb_height\")\n            ),\n            \"s\": AutomaticNotebook(\n                self._center_pw, 3, preferred_size_in_pw=self.get_option(\"layout.s_nb_height\")\n            ),\n            \"ne\": AutomaticNotebook(\n                self._east_pw, 1, preferred_size_in_pw=self.get_option(\"layout.ne_nb_height\")\n            ),\n            \"e\": AutomaticNotebook(self._east_pw, 2),\n            \"se\": AutomaticNotebook(\n                self._east_pw, 3, preferred_size_in_pw=self.get_option(\"layout.se_nb_height\")\n            ),\n        }\n\n        for nb_name in self._view_notebooks:\n            self.set_default(\"layout.notebook_\" + nb_name + \"_visible_view\", None)\n\n        self._editor_notebook = EditorNotebook(self._center_pw)\n        self._editor_notebook.position_key = 1\n        self._center_pw.insert(\"auto\", self._editor_notebook)\n\n        self._statusbar = ttk.Frame(main_frame)\n        self._statusbar.grid(column=0, row=2, sticky=\"nsew\", padx=margin, pady=(0))\n        self._statusbar.columnconfigure(2, weight=2)\n        self._status_label = ttk.Label(self._statusbar, text=\"\")\n        self._status_label.grid(row=1, column=1, sticky=\"w\")\n\n        self._init_backend_switcher()", "is_method": true, "class_name": "Workbench", "function_description": "Initializes the main GUI layout for the Workbench, creating the foundational frames, paned windows, and notebooks that structure the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_backend_switcher", "line_number": 773, "body": "def _init_backend_switcher(self):\n\n        # Set up the menu\n        self._backend_conf_variable = tk.StringVar(value=\"{}\")\n        self._backend_menu = tk.Menu(self._statusbar, tearoff=False)\n\n        # Set up the button\n        self._backend_button = ttk.Button(self._statusbar, text=\"\", style=\"Toolbutton\")\n\n        self._backend_button.grid(row=1, column=3, sticky=\"e\")\n        self._backend_button.configure(command=self._post_backend_menu)", "is_method": true, "class_name": "Workbench", "function_description": "Initializes the GUI components for a backend switcher, creating a button and its associated menu. This enables users to select or manage different application backends within the workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_post_backend_menu", "line_number": 785, "body": "def _post_backend_menu(self):\n        menu_font = tk_font.nametofont(\"TkMenuFont\")\n\n        def choose_backend():\n            backend_conf = ast.literal_eval(self._backend_conf_variable.get())\n            assert isinstance(backend_conf, dict), \"backend conf is %r\" % backend_conf\n            for name, value in backend_conf.items():\n                self.set_option(name, value)\n            get_runner().restart_backend(False)\n\n        self._backend_menu.delete(0, \"end\")\n        max_description_width = 0\n        button_text_width = menu_font.measure(self._backend_button.cget(\"text\"))\n\n        num_entries = 0\n        for backend in sorted(self.get_backends().values(), key=lambda x: x.sort_key):\n            entries = backend.proxy_class.get_switcher_entries()\n\n            if not entries:\n                continue\n\n            if len(entries) == 1:\n                self._backend_menu.add_radiobutton(\n                    label=backend.description,\n                    command=choose_backend,\n                    variable=self._backend_conf_variable,\n                    value=repr(entries[0][0]),\n                )\n            else:\n                submenu = tk.Menu(self._backend_menu, tearoff=False)\n                for conf, label in entries:\n                    submenu.add_radiobutton(\n                        label=label,\n                        command=choose_backend,\n                        variable=self._backend_conf_variable,\n                        value=repr(conf),\n                    )\n                self._backend_menu.add_cascade(label=backend.description, menu=submenu)\n\n            max_description_width = max(\n                menu_font.measure(backend.description), max_description_width\n            )\n        num_entries += 1\n\n        # self._backend_conf_variable.set(value=self.get_option(\"run.backend_name\"))\n\n        self._backend_menu.add_separator()\n        self._backend_menu.add_command(\n            label=tr(\"Configure interpreter...\"),\n            command=lambda: self.show_options(\"interpreter\"),\n        )\n\n        post_x = self._backend_button.winfo_rootx()\n        post_y = self._backend_button.winfo_rooty()\n\n        if self.winfo_screenwidth() / self.winfo_screenheight() > 2:\n            # Most likely several monitors.\n            # Tk will adjust x properly with single monitor, but when Thonny is maximized\n            # on a monitor, which has another monitor to its right, the menu can be partially\n            # displayed on another monitor (at least in Ubuntu).\n            width_diff = max_description_width - button_text_width\n            post_x -= width_diff + menu_font.measure(\"mmm\")\n\n        if running_on_mac_os():\n            # won't be good location otherwise\n            popup_entry = num_entries + 4\n        else:\n            popup_entry = \"\"\n\n        # print(post_x, post_y)\n        try:\n            self._backend_menu.tk_popup(post_x, post_y, entry=popup_entry)\n        except tk.TclError as e:\n            if not 'unknown option \"-state\"' in str(e):\n                logger.warning(\"Problem with switcher popup\", exc_info=e)", "is_method": true, "class_name": "Workbench", "function_description": "For the Workbench, this method dynamically creates and displays a popup menu. It enables users to select and switch between different application backends or configure the interpreter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_backend_restart", "line_number": 861, "body": "def _on_backend_restart(self, event):\n        proxy = get_runner().get_backend_proxy()\n        if proxy:\n            desc = proxy.get_clean_description()\n            self._backend_conf_variable.set(value=repr(proxy.get_current_switcher_configuration()))\n        else:\n            backend_conf = self._backends.get(self.get_option(\"run.backend_name\"), None)\n            if backend_conf:\n                desc = backend_conf.description\n            else:\n                desc = \"<no backend>\"\n        self._backend_button.configure(text=desc)", "is_method": true, "class_name": "Workbench", "function_description": "Handles backend restart events by updating the Workbench's user interface. It displays the backend's current description on a button and its configuration in a variable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_theming", "line_number": 874, "body": "def _init_theming(self) -> None:\n        self._style = ttk.Style()\n        self._ui_themes = (\n            {}\n        )  # type: Dict[str, Tuple[Optional[str], FlexibleUiThemeSettings, Dict[str, str]]] # value is (parent, settings, images)\n        self._syntax_themes = (\n            {}\n        )  # type: Dict[str, Tuple[Optional[str], FlexibleSyntaxThemeSettings]] # value is (parent, settings)\n        self.set_default(\"view.ui_theme\", ui_utils.get_default_theme())", "is_method": true, "class_name": "Workbench", "function_description": "Initializes the Workbench application's theming system. It sets up structures and default settings for managing both user interface and syntax highlighting themes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_command", "line_number": 884, "body": "def add_command(\n        self,\n        command_id: str,\n        menu_name: str,\n        command_label: str,\n        handler: Optional[Callable[[], None]] = None,\n        tester: Optional[Callable[[], bool]] = None,\n        default_sequence: Optional[str] = None,\n        extra_sequences: Sequence[str] = [],\n        flag_name: Optional[str] = None,\n        skip_sequence_binding: bool = False,\n        accelerator: Optional[str] = None,\n        group: int = 99,\n        position_in_group=\"end\",\n        image: Optional[str] = None,\n        caption: Optional[str] = None,\n        alternative_caption: Optional[str] = None,\n        include_in_menu: bool = True,\n        include_in_toolbar: bool = False,\n        submenu: Optional[tk.Menu] = None,\n        bell_when_denied: bool = True,\n        show_extra_sequences=False,\n    ) -> None:\n        \"\"\"Registers an item to be shown in specified menu.\n\n        Args:\n            menu_name: Name of the menu the command should appear in.\n                Standard menu names are \"file\", \"edit\", \"run\", \"view\", \"help\".\n                If a menu with given name doesn't exist, then new menu is created\n                (with label=name).\n            command_label: Label for this command\n            handler: Function to be called when the command is invoked.\n                Should be callable with one argument (the event or None).\n            tester: Function to be called for determining if command is available or not.\n                Should be callable with one argument (the event or None).\n                Should return True or False.\n                If None then command is assumed to be always available.\n            default_sequence: Default shortcut (Tk style)\n            flag_name: Used for toggle commands. Indicates the name of the boolean option.\n            group: Used for grouping related commands together. Value should be int.\n                Groups with smaller numbers appear before.\n\n        Returns:\n            None\n        \"\"\"\n\n        # Temporary solution for plug-ins made for versions before 3.2\n        if menu_name == \"device\":\n            menu_name = \"tools\"\n            group = 150\n\n        # store command to be published later\n        self._commands.append(\n            dict(\n                command_id=command_id,\n                menu_name=menu_name,\n                command_label=command_label,\n                handler=handler,\n                tester=tester,\n                default_sequence=default_sequence,\n                extra_sequences=extra_sequences,\n                flag_name=flag_name,\n                skip_sequence_binding=skip_sequence_binding,\n                accelerator=accelerator,\n                group=group,\n                position_in_group=position_in_group,\n                image=image,\n                caption=caption,\n                alternative_caption=alternative_caption,\n                include_in_menu=include_in_menu,\n                include_in_toolbar=include_in_toolbar,\n                submenu=submenu,\n                bell_when_denied=bell_when_denied,\n                show_extra_sequences=show_extra_sequences,\n            )\n        )", "is_method": true, "class_name": "Workbench", "function_description": "This method registers a new command within the Workbench, defining its label, behavior, and where it appears in menus or toolbars. It enables extending the application's user interface with custom actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_publish_commands", "line_number": 961, "body": "def _publish_commands(self) -> None:\n        for cmd in self._commands:\n            self._publish_command(**cmd)", "is_method": true, "class_name": "Workbench", "function_description": "Dispatches all collected commands stored within the workbench. It provides a service to process a batch of internal operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_publish_command", "line_number": 965, "body": "def _publish_command(\n        self,\n        command_id: str,\n        menu_name: str,\n        command_label: str,\n        handler: Optional[Callable[[], None]],\n        tester: Optional[Callable[[], bool]] = None,\n        default_sequence: Optional[str] = None,\n        extra_sequences: Sequence[str] = [],\n        flag_name: Optional[str] = None,\n        skip_sequence_binding: bool = False,\n        accelerator: Optional[str] = None,\n        group: int = 99,\n        position_in_group=\"end\",\n        image: Optional[str] = None,\n        caption: Optional[str] = None,\n        alternative_caption: Optional[str] = None,\n        include_in_menu: bool = True,\n        include_in_toolbar: bool = False,\n        submenu: Optional[tk.Menu] = None,\n        bell_when_denied: bool = True,\n        show_extra_sequences: bool = False,\n    ) -> None:\n        def dispatch(event=None):\n            if not tester or tester():\n                denied = False\n                handler()\n            else:\n                denied = True\n                logging.debug(\"Command '\" + command_id + \"' execution denied\")\n                if bell_when_denied:\n                    self.bell()\n\n            self.event_generate(\"UICommandDispatched\", command_id=command_id, denied=denied)\n\n        def dispatch_if_caps_lock_is_on(event):\n            if caps_lock_is_on(event.state) and not shift_is_pressed(event.state):\n                dispatch(event)\n\n        sequence_option_name = \"shortcuts.\" + command_id\n        self.set_default(sequence_option_name, default_sequence)\n        sequence = self.get_option(sequence_option_name)\n\n        if sequence:\n            if not skip_sequence_binding:\n                self.bind_all(sequence, dispatch, True)\n                # work around caps-lock problem\n                # https://github.com/thonny/thonny/issues/1347\n                # Unfortunately the solution doesn't work with sequences involving Shift\n                # (in Linux with the expected solution Shift sequences did not come through\n                # with Caps Lock, and in Windows, the shift handlers started to react\n                # on non-shift keypresses)\n                # Python 3.7 on Mac seems to require lower letters for shift sequences.\n                parts = sequence.strip(\"<>\").split(\"-\")\n                if len(parts[-1]) == 1 and parts[-1].islower() and \"Shift\" not in parts:\n                    lock_sequence = \"<%s-Lock-%s>\" % (\"-\".join(parts[:-1]), parts[-1].upper())\n                    self.bind_all(lock_sequence, dispatch_if_caps_lock_is_on, True)\n\n            # register shortcut even without binding\n            register_latin_shortcut(self._latin_shortcuts, sequence, handler, tester)\n\n        for extra_sequence in extra_sequences:\n            self.bind_all(extra_sequence, dispatch, True)\n            if \"greek_\" not in extra_sequence.lower() or running_on_linux():\n                # Use greek alternatives only on Linux\n                # (they are not required on Mac\n                # and cause double events on Windows)\n                register_latin_shortcut(self._latin_shortcuts, sequence, handler, tester)\n\n        menu = self.get_menu(menu_name)\n\n        if image:\n            _image = self.get_image(image)  # type: Optional[tk.PhotoImage]\n            _disabled_image = self.get_image(image, disabled=True)\n        else:\n            _image = None\n            _disabled_image = None\n\n        if not accelerator and sequence:\n            accelerator = sequence_to_accelerator(sequence)\n            \"\"\"\n            # Does not work on Mac\n            if show_extra_sequences:\n                for extra_seq in extra_sequences:\n                    accelerator += \" or \" + sequence_to_accelerator(extra_seq)\n            \"\"\"\n\n        if include_in_menu:\n\n            def dispatch_from_menu():\n                # I don't like that Tk menu toggles checbutton variable\n                # automatically before calling the handler.\n                # So I revert the toggle before calling the actual handler.\n                # This way the handler doesn't have to worry whether it\n                # needs to toggle the variable or not, and it can choose to\n                # decline the toggle.\n                if flag_name is not None:\n                    var = self.get_variable(flag_name)\n                    var.set(not var.get())\n\n                dispatch(None)\n\n            if _image and lookup_style_option(\"OPTIONS\", \"icons_in_menus\", True):\n                menu_image = _image  # type: Optional[tk.PhotoImage]\n            elif flag_name:\n                # no image or black next to a checkbox\n                menu_image = None\n            else:\n                menu_image = self.get_image(\"16x16-blank\")\n\n            # remember the details that can't be stored in Tkinter objects\n            self._menu_item_specs[(menu_name, command_label)] = MenuItem(\n                group, position_in_group, tester\n            )\n\n            menu.insert(\n                self._find_location_for_menu_item(menu_name, command_label),\n                \"checkbutton\" if flag_name else \"cascade\" if submenu else \"command\",\n                label=command_label,\n                accelerator=accelerator,\n                image=menu_image,\n                compound=tk.LEFT,\n                variable=self.get_variable(flag_name) if flag_name else None,\n                command=dispatch_from_menu if handler else None,\n                menu=submenu,\n            )\n\n        if include_in_toolbar:\n            toolbar_group = self._get_menu_index(menu) * 100 + group\n            assert caption is not None\n            self._add_toolbar_button(\n                command_id,\n                _image,\n                _disabled_image,\n                command_label,\n                caption,\n                caption if alternative_caption is None else alternative_caption,\n                accelerator,\n                handler,\n                tester,\n                toolbar_group,\n            )", "is_method": true, "class_name": "Workbench", "function_description": "Registers a command with the Workbench application, integrating it into menus, toolbars, and keyboard shortcuts. It defines the command's behavior, availability, and UI representation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_view", "line_number": 1108, "body": "def add_view(\n        self,\n        cls: Type[tk.Widget],\n        label: str,\n        default_location: str,\n        visible_by_default: bool = False,\n        default_position_key: Optional[str] = None,\n    ) -> None:\n        \"\"\"Adds item to \"View\" menu for showing/hiding given view.\n\n        Args:\n            view_class: Class or constructor for view. Should be callable with single\n                argument (the master of the view)\n            label: Label of the view tab\n            location: Location descriptor. Can be \"nw\", \"sw\", \"s\", \"se\", \"ne\"\n\n        Returns: None\n        \"\"\"\n        view_id = cls.__name__\n        if default_position_key == None:\n            default_position_key = label\n\n        self.set_default(\"view.\" + view_id + \".visible\", visible_by_default)\n        self.set_default(\"view.\" + view_id + \".location\", default_location)\n        self.set_default(\"view.\" + view_id + \".position_key\", default_position_key)\n\n        if self.in_simple_mode():\n            visibility_flag = tk.BooleanVar(value=view_id in SIMPLE_MODE_VIEWS)\n        else:\n            visibility_flag = cast(tk.BooleanVar, self.get_variable(\"view.\" + view_id + \".visible\"))\n\n        self._view_records[view_id] = {\n            \"class\": cls,\n            \"label\": label,\n            \"location\": self.get_option(\"view.\" + view_id + \".location\"),\n            \"position_key\": self.get_option(\"view.\" + view_id + \".position_key\"),\n            \"visibility_flag\": visibility_flag,\n        }\n\n        # handler\n        def toggle_view_visibility():\n            if visibility_flag.get():\n                self.hide_view(view_id)\n            else:\n                self.show_view(view_id, True)\n\n        self.add_command(\n            \"toggle_\" + view_id,\n            menu_name=\"view\",\n            command_label=label,\n            handler=toggle_view_visibility,\n            flag_name=\"view.\" + view_id + \".visible\",\n            group=10,\n            position_in_group=\"alphabetic\",\n        )", "is_method": true, "class_name": "Workbench", "function_description": "Registers a new user interface view within the Workbench application. It allows users to toggle the view's visibility through the 'View' menu."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_configuration_page", "line_number": 1164, "body": "def add_configuration_page(\n        self, key: str, title: str, page_class: Type[tk.Widget], order: int\n    ) -> None:\n        self._configuration_pages.append((key, title, page_class, order))", "is_method": true, "class_name": "Workbench", "function_description": "This method registers a new configuration page for the Workbench. It stores details like the page's key, title, and display order, allowing the UI to present various application settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_content_inspector", "line_number": 1169, "body": "def add_content_inspector(self, inspector_class: Type) -> None:\n        self.content_inspector_classes.append(inspector_class)", "is_method": true, "class_name": "Workbench", "function_description": "Registers a content inspector class with the Workbench, allowing it to dynamically support various content inspection capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_backend", "line_number": 1172, "body": "def add_backend(\n        self,\n        name: str,\n        proxy_class: Type[BackendProxy],\n        description: str,\n        config_page_constructor,\n        sort_key=None,\n    ) -> None:\n        self._backends[name] = BackendSpec(\n            name,\n            proxy_class,\n            description,\n            config_page_constructor,\n            sort_key if sort_key is not None else description,\n        )\n\n        # assing names to related classes\n        proxy_class.backend_name = name  # type: ignore\n        proxy_class.backend_description = description  # type: ignore\n        if not getattr(config_page_constructor, \"backend_name\", None):\n            config_page_constructor.backend_name = name", "is_method": true, "class_name": "Workbench", "function_description": "Registers a new backend service with the Workbench, associating it with a unique name, proxy class, and configuration details. This makes the backend available for use within the Workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_ui_theme", "line_number": 1194, "body": "def add_ui_theme(\n        self,\n        name: str,\n        parent: Union[str, None],\n        settings: FlexibleUiThemeSettings,\n        images: Dict[str, str] = {},\n    ) -> None:\n        if name in self._ui_themes:\n            warn(tr(\"Overwriting theme '%s'\") % name)\n\n        self._ui_themes[name] = (parent, settings, images)", "is_method": true, "class_name": "Workbench", "function_description": "Registers a user interface theme, including its settings and associated images, within the Workbench. This allows for defining and managing custom application appearances."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "add_syntax_theme", "line_number": 1206, "body": "def add_syntax_theme(\n        self, name: str, parent: Optional[str], settings: FlexibleSyntaxThemeSettings\n    ) -> None:\n        if name in self._syntax_themes:\n            warn(tr(\"Overwriting theme '%s'\") % name)\n\n        self._syntax_themes[name] = (parent, settings)", "is_method": true, "class_name": "Workbench", "function_description": "Registers a new syntax theme or updates an existing one for the workbench. Enables customization of the editor's visual appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_usable_ui_theme_names", "line_number": 1214, "body": "def get_usable_ui_theme_names(self) -> Sequence[str]:\n        return sorted([name for name in self._ui_themes if self._ui_themes[name][0] is not None])", "is_method": true, "class_name": "Workbench", "function_description": "Provides a sorted list of names for all usable UI themes within the Workbench. This enables selection and application of valid themes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_syntax_theme_names", "line_number": 1217, "body": "def get_syntax_theme_names(self) -> Sequence[str]:\n        return sorted(self._syntax_themes.keys())", "is_method": true, "class_name": "Workbench", "function_description": "Provides a sorted list of all available syntax theme names. This is useful for displaying theme options to the user within the workbench interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_ui_mode", "line_number": 1220, "body": "def get_ui_mode(self) -> str:\n        return self._active_ui_mode", "is_method": true, "class_name": "Workbench", "function_description": "This method retrieves the current user interface mode configured for the Workbench. It allows other components to access the active UI state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "in_simple_mode", "line_number": 1223, "body": "def in_simple_mode(self) -> bool:\n        return self.get_ui_mode() == \"simple\"", "is_method": true, "class_name": "Workbench", "function_description": "Checks if the workbench is currently operating in 'simple' user interface mode. This helps other parts of the application adapt their behavior or display based on the UI configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "scale", "line_number": 1226, "body": "def scale(self, value: Union[int, float]) -> int:\n        if isinstance(value, (int, float)):\n            # using int instead of round so that thin lines will stay\n            # one pixel even with scaling_factor 1.67\n            result = int(self._scaling_factor * value)\n            if result == 0 and value > 0:\n                # don't lose thin lines because of scaling\n                return 1\n            else:\n                return result\n        else:\n            raise NotImplementedError(\"Only numeric dimensions supported at the moment\")", "is_method": true, "class_name": "Workbench", "function_description": "Applies the workbench's scaling factor to a numeric dimension, returning an integer. It prevents small positive inputs from scaling down to zero."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_register_ui_theme_as_tk_theme", "line_number": 1239, "body": "def _register_ui_theme_as_tk_theme(self, name: str) -> None:\n        # collect settings from all ancestors\n        total_settings = []  # type: List[FlexibleUiThemeSettings]\n        total_images = {}  # type: Dict[str, str]\n        temp_name = name\n        while True:\n            parent, settings, images = self._ui_themes[temp_name]\n            total_settings.insert(0, settings)\n            for img_name in images:\n                total_images.setdefault(img_name, images[img_name])\n\n            if parent is not None:\n                temp_name = parent\n            else:\n                # reached start of the chain\n                break\n\n        assert temp_name in self._style.theme_names()\n        # only root of the ancestors is relevant for theme_create,\n        # because the method actually doesn't take parent settings into account\n        # (https://mail.python.org/pipermail/tkinter-discuss/2015-August/003752.html)\n        self._style.theme_create(name, temp_name)\n        self._image_mapping_by_theme[name] = total_images\n\n        # load images\n        self.get_image(\"tab-close\", \"img_close\")\n        self.get_image(\"tab-close-active\", \"img_close_active\")\n\n        # apply settings starting from root ancestor\n        for settings in total_settings:\n            if callable(settings):\n                settings = settings()\n\n            if isinstance(settings, dict):\n                self._style.theme_settings(name, settings)\n            else:\n                for subsettings in settings:\n                    self._style.theme_settings(name, subsettings)", "is_method": true, "class_name": "Workbench", "function_description": "Registers a UI theme, along with its inherited settings and associated images, as a new Tkinter theme. This allows the custom UI theme to be rendered by the Tkinter GUI framework."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_apply_ui_theme", "line_number": 1278, "body": "def _apply_ui_theme(self, name: str) -> None:\n        self._current_theme_name = name\n        if name not in self._style.theme_names():\n            self._register_ui_theme_as_tk_theme(name)\n\n        self._style.theme_use(name)\n\n        # https://wiki.tcl.tk/37973#pagetocfe8b22ab\n        for setting in [\"background\", \"foreground\", \"selectBackground\", \"selectForeground\"]:\n            value = self._style.lookup(\"Listbox\", setting)\n            if value:\n                self.option_add(\"*TCombobox*Listbox.\" + setting, value)\n                self.option_add(\"*Listbox.\" + setting, value)\n\n        text_opts = self._style.configure(\"Text\")\n        if text_opts:\n            for key in text_opts:\n                self.option_add(\"*Text.\" + key, text_opts[key])\n\n        if hasattr(self, \"_menus\"):\n            # if menus have been initialized, ie. when theme is being changed\n            for menu in self._menus.values():\n                menu.configure(get_style_configuration(\"Menu\"))\n\n        self.update_fonts()", "is_method": true, "class_name": "Workbench", "function_description": "Applies a specified UI theme across the application's user interface. It configures various widget styles and fonts to ensure a consistent visual appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_apply_syntax_theme", "line_number": 1304, "body": "def _apply_syntax_theme(self, name: str) -> None:\n        def get_settings(name):\n            try:\n                parent, settings = self._syntax_themes[name]\n            except KeyError:\n                self.report_exception(\"Can't find theme '%s'\" % name)\n                return {}\n\n            if callable(settings):\n                settings = settings()\n\n            if parent is None:\n                return settings\n            else:\n                result = get_settings(parent)\n                for key in settings:\n                    if key in result:\n                        result[key].update(settings[key])\n                    else:\n                        result[key] = settings[key]\n                return result\n\n        from thonny import codeview\n\n        codeview.set_syntax_options(get_settings(name))", "is_method": true, "class_name": "Workbench", "function_description": "Applies a specified syntax highlighting theme to the code editor. It retrieves and merges theme settings, supporting inheritance for a consistent visual experience."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "reload_themes", "line_number": 1330, "body": "def reload_themes(self) -> None:\n        preferred_theme = self.get_option(\"view.ui_theme\")\n        available_themes = self.get_usable_ui_theme_names()\n\n        if preferred_theme in available_themes:\n            self._apply_ui_theme(preferred_theme)\n        elif \"Enhanced Clam\" in available_themes:\n            self._apply_ui_theme(\"Enhanced Clam\")\n        elif \"Windows\" in available_themes:\n            self._apply_ui_theme(\"Windows\")\n\n        self._apply_syntax_theme(self.get_option(\"view.syntax_theme\"))", "is_method": true, "class_name": "Workbench", "function_description": "Applies the user's preferred UI and syntax themes to the Workbench. It ensures the application's visual appearance is correctly set, using defaults if preferences are unavailable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "uses_dark_ui_theme", "line_number": 1343, "body": "def uses_dark_ui_theme(self) -> bool:\n\n        name = self._style.theme_use()\n        while True:\n            if \"dark\" in name.lower():\n                return True\n\n            name, _, _ = self._ui_themes[name]\n            if name is None:\n                # reached start of the chain\n                break\n\n        return False", "is_method": true, "class_name": "Workbench", "function_description": "Determines if the current UI theme, or any inherited theme, is a 'dark' theme, allowing components to adapt their appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_program_arguments_frame", "line_number": 1357, "body": "def _init_program_arguments_frame(self) -> None:\n        self.set_default(\"view.show_program_arguments\", False)\n        self.set_default(\"run.program_arguments\", \"\")\n        self.set_default(\"run.past_program_arguments\", [])\n\n        visibility_var = self.get_variable(\"view.show_program_arguments\")\n        content_var = self.get_variable(\"run.program_arguments\")\n\n        frame = ttk.Frame(self._toolbar)\n        col = 1000\n        self._toolbar.columnconfigure(col, weight=1)\n\n        label = ttk.Label(frame, text=tr(\"Program arguments:\"))\n        label.grid(row=0, column=0, sticky=\"nse\", padx=5)\n\n        self.program_arguments_box = ttk.Combobox(\n            frame,\n            width=80,\n            height=15,\n            textvariable=content_var,\n            values=[\"\"] + self.get_option(\"run.past_program_arguments\"),\n        )\n        self.program_arguments_box.grid(row=0, column=1, sticky=\"nsew\", padx=5)\n\n        frame.columnconfigure(1, weight=1)\n\n        def update_visibility():\n            if visibility_var.get():\n                if not frame.winfo_ismapped():\n                    frame.grid(row=0, column=col, sticky=\"nse\")\n            else:\n                if frame.winfo_ismapped():\n                    frame.grid_remove()\n\n        def toggle():\n            visibility_var.set(not visibility_var.get())\n            update_visibility()\n\n        self.add_command(\n            \"viewargs\",\n            \"view\",\n            tr(\"Program arguments\"),\n            toggle,\n            flag_name=\"view.show_program_arguments\",\n            group=11,\n        )\n\n        update_visibility()", "is_method": true, "class_name": "Workbench", "function_description": "Initializes and manages the user interface for inputting and viewing program arguments within the Workbench. It sets default values, provides argument history, and includes a toggle for visibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_regular_mode_link", "line_number": 1406, "body": "def _init_regular_mode_link(self):\n        if self.get_ui_mode() != \"simple\":\n            return\n\n        label = ttk.Label(\n            self._toolbar,\n            text=tr(\"Switch to\\nregular\\nmode\"),\n            justify=\"right\",\n            font=\"SmallLinkFont\",\n            style=\"Url.TLabel\",\n            cursor=\"hand2\",\n        )\n        label.grid(row=0, column=1001, sticky=\"ne\")\n\n        def on_click(event):\n            self.set_option(\"general.ui_mode\", \"regular\")\n            tk.messagebox.showinfo(\n                tr(\"Regular mode\"),\n                tr(\n                    \"Configuration has been updated. \"\n                    + \"Restart Thonny to start working in regular mode.\\n\\n\"\n                    + \"(See 'Tools \u2192 Options \u2192 General' if you change your mind later.)\"\n                ),\n                master=self,\n            )\n\n        label.bind(\"<1>\", on_click, True)", "is_method": true, "class_name": "Workbench", "function_description": "Initializes a UI link that enables users in \"simple\" mode to switch to \"regular\" UI mode. It updates the application's configuration and prompts the user to restart."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "log_program_arguments_string", "line_number": 1443, "body": "def log_program_arguments_string(self, arg_str: str) -> None:\n        arg_str = arg_str.strip()\n        self.set_option(\"run.program_arguments\", arg_str)\n\n        if arg_str == \"\":\n            # empty will be handled differently\n            return\n\n        past_args = self.get_option(\"run.past_program_arguments\")\n\n        if arg_str in past_args:\n            past_args.remove(arg_str)\n\n        past_args.insert(0, arg_str)\n        past_args = past_args[:10]\n\n        self.set_option(\"run.past_program_arguments\", past_args)\n        self.program_arguments_box.configure(values=[\"\"] + past_args)", "is_method": true, "class_name": "Workbench", "function_description": "This method records the current program arguments and maintains a limited, unique history of recently used arguments. It updates a UI component for user convenience."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_show_views", "line_number": 1462, "body": "def _show_views(self) -> None:\n        for view_id in self._view_records:\n            if self._view_records[view_id][\"visibility_flag\"].get():\n                try:\n                    self.show_view(view_id, False)\n                except Exception:\n                    self.report_exception(\"Problem showing \" + view_id)", "is_method": true, "class_name": "Workbench", "function_description": "This internal method of the Workbench class displays all views currently marked as visible. It iterates through registered views, ensuring their presentation and gracefully handling any display errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "update_image_mapping", "line_number": 1470, "body": "def update_image_mapping(self, mapping: Dict[str, str]) -> None:\n        \"\"\"Was used by thonny-pi. Not recommended anymore\"\"\"\n        self._default_image_mapping.update(mapping)", "is_method": true, "class_name": "Workbench", "function_description": "Not Implemented."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_backends", "line_number": 1474, "body": "def get_backends(self) -> Dict[str, BackendSpec]:\n        return self._backends", "is_method": true, "class_name": "Workbench", "function_description": "Provides access to the collection of registered backend specifications. This allows other parts of the system to retrieve information about available backends."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_option", "line_number": 1477, "body": "def get_option(self, name: str, default=None) -> Any:\n        # Need to return Any, otherwise each typed call site needs to cast\n        return self._configuration_manager.get_option(name, default)", "is_method": true, "class_name": "Workbench", "function_description": "Retrieves a configuration option by name from the Workbench's internal configuration manager, returning a default value if not found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "set_option", "line_number": 1481, "body": "def set_option(self, name: str, value: Any) -> None:\n        self._configuration_manager.set_option(name, value)", "is_method": true, "class_name": "Workbench", "function_description": "Configures the Workbench instance by setting a specific named option to a provided value."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_local_cwd", "line_number": 1484, "body": "def get_local_cwd(self) -> str:\n        cwd = self.get_option(\"run.working_directory\")\n        if os.path.exists(cwd):\n            return normpath_with_actual_case(cwd)\n        else:\n            return normpath_with_actual_case(os.path.expanduser(\"~\"))", "is_method": true, "class_name": "Workbench", "function_description": "This method provides the Workbench's designated local current working directory. It retrieves a configured path, falling back to the user's home directory if the specified path does not exist."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "set_local_cwd", "line_number": 1491, "body": "def set_local_cwd(self, value: str) -> None:\n        if self.get_option(\"run.working_directory\") != value:\n            self.set_option(\"run.working_directory\", value)\n            if value:\n                self.event_generate(\"LocalWorkingDirectoryChanged\", cwd=value)", "is_method": true, "class_name": "Workbench", "function_description": "This method updates the local working directory setting for the workbench. It triggers a `LocalWorkingDirectoryChanged` event if the directory is successfully changed to a non-empty value."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "set_default", "line_number": 1497, "body": "def set_default(self, name: str, default_value: Any) -> None:\n        \"\"\"Registers a new option.\n\n        If the name contains a period, then the part left to the (first) period\n        will become the section of the option and rest will become name under that\n        section.\n\n        If the name doesn't contain a period, then it will be added under section\n        \"general\".\n        \"\"\"\n        self._configuration_manager.set_default(name, default_value)", "is_method": true, "class_name": "Workbench", "function_description": "Registers default values for configuration options, automatically organizing them into hierarchical sections based on the option's name. This provides a structured way to manage application settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_variable", "line_number": 1509, "body": "def get_variable(self, name: str) -> tk.Variable:\n        return self._configuration_manager.get_variable(name)", "is_method": true, "class_name": "Workbench", "function_description": "Provides access to a specific Tkinter variable by name, enabling other parts of the application to interact with UI-bound values managed by the Workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_menu", "line_number": 1512, "body": "def get_menu(self, name: str, label: Optional[str] = None) -> tk.Menu:\n        \"\"\"Gives the menu with given name. Creates if not created yet.\n\n        Args:\n            name: meant to be used as not translatable menu name\n            label: translated label, used only when menu with given name doesn't exist yet\n        \"\"\"\n\n        # For compatibility with plug-ins\n        if name in [\"device\", \"tempdevice\"] and label is None:\n            label = tr(\"Device\")\n\n        if name not in self._menus:\n            if running_on_mac_os():\n                conf = {}\n            else:\n                conf = get_style_configuration(\"Menu\")\n\n            menu = tk.Menu(self._menubar, **conf)\n            menu[\"postcommand\"] = lambda: self._update_menu(menu, name)\n            self._menubar.add_cascade(label=label if label else name, menu=menu)\n\n            self._menus[name] = menu\n            if label:\n                self._menus[label] = menu\n\n        return self._menus[name]", "is_method": true, "class_name": "Workbench", "function_description": "Provides or creates a `tkinter` menu object identified by its name for the Workbench's menubar. It ensures consistent access and setup of application menus."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_view", "line_number": 1540, "body": "def get_view(self, view_id: str, create: bool = True) -> tk.Widget:\n        if \"instance\" not in self._view_records[view_id]:\n            if not create:\n                raise RuntimeError(\"View %s not created\" % view_id)\n            class_ = self._view_records[view_id][\"class\"]\n            location = self._view_records[view_id][\"location\"]\n            master = self._view_notebooks[location]\n\n            # create the view\n            view = class_(self)  # View's master is workbench to allow making it maximized\n            view.position_key = self._view_records[view_id][\"position_key\"]\n            self._view_records[view_id][\"instance\"] = view\n\n            # create the view home_widget to be added into notebook\n            view.home_widget = ttk.Frame(master)\n            view.home_widget.columnconfigure(0, weight=1)\n            view.home_widget.rowconfigure(0, weight=1)\n            view.home_widget.maximizable_widget = view  # type: ignore\n            view.home_widget.close = lambda: self.hide_view(view_id)  # type: ignore\n            if hasattr(view, \"position_key\"):\n                view.home_widget.position_key = view.position_key  # type: ignore\n\n            # initially the view will be in it's home_widget\n            view.grid(row=0, column=0, sticky=tk.NSEW, in_=view.home_widget)\n            view.hidden = True\n\n        return self._view_records[view_id][\"instance\"]", "is_method": true, "class_name": "Workbench", "function_description": "Provides access to a specific UI view by its ID. It creates and configures the view if it doesn't already exist and creation is enabled, integrating it into the workbench's layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_editor_notebook", "line_number": 1568, "body": "def get_editor_notebook(self) -> EditorNotebook:\n        assert self._editor_notebook is not None\n        return self._editor_notebook", "is_method": true, "class_name": "Workbench", "function_description": "Provides access to the `EditorNotebook` instance managed by the workbench. This allows other components to interact with the active notebook."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_package_dir", "line_number": 1572, "body": "def get_package_dir(self):\n        \"\"\"Returns thonny package directory\"\"\"\n        return os.path.dirname(sys.modules[\"thonny\"].__file__)", "is_method": true, "class_name": "Workbench", "function_description": "Provides the file system path to the Thonny integrated development environment's main package directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_image", "line_number": 1576, "body": "def get_image(\n        self, filename: str, tk_name: Optional[str] = None, disabled=False\n    ) -> tk.PhotoImage:\n\n        if filename in self._image_mapping_by_theme[self._current_theme_name]:\n            filename = self._image_mapping_by_theme[self._current_theme_name][filename]\n\n        if filename in self._default_image_mapping:\n            filename = self._default_image_mapping[filename]\n\n        # if path is relative then interpret it as living in res folder\n        if not os.path.isabs(filename):\n            filename = os.path.join(self.get_package_dir(), \"res\", filename)\n            if not os.path.exists(filename):\n                if os.path.exists(filename + \".png\"):\n                    filename = filename + \".png\"\n                elif os.path.exists(filename + \".gif\"):\n                    filename = filename + \".gif\"\n\n        if disabled:\n            filename = os.path.join(\n                os.path.dirname(filename), \"_disabled_\" + os.path.basename(filename)\n            )\n            if not os.path.exists(filename):\n                return None\n\n        # are there platform-specific variants?\n        plat_filename = filename[:-4] + \"_\" + platform.system() + \".png\"\n        if os.path.exists(plat_filename):\n            filename = plat_filename\n\n        if self._scaling_factor >= 2.0:\n            scaled_filename = filename[:-4] + \"_2x.png\"\n            if os.path.exists(scaled_filename):\n                filename = scaled_filename\n            else:\n                img = tk.PhotoImage(file=filename)\n                # can't use zoom method, because this doesn't allow name\n                img2 = tk.PhotoImage(tk_name)\n                self.tk.call(\n                    img2,\n                    \"copy\",\n                    img.name,\n                    \"-zoom\",\n                    int(self._scaling_factor),\n                    int(self._scaling_factor),\n                )\n                self._images.add(img2)\n                return img2\n\n        img = tk.PhotoImage(tk_name, file=filename)\n        self._images.add(img)\n        return img", "is_method": true, "class_name": "Workbench", "function_description": "Provides a `tk.PhotoImage` for a given filename, intelligently resolving theme, path, platform, disabled state, and scaling for UI display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "show_view", "line_number": 1630, "body": "def show_view(self, view_id: str, set_focus: bool = True) -> Union[bool, tk.Widget]:\n        \"\"\"View must be already registered.\n\n        Args:\n            view_id: View class name\n            without package name (eg. 'ShellView')\"\"\"\n\n        if view_id == \"MainFileBrowser\":\n            # Was renamed in 3.1.1\n            view_id = \"FilesView\"\n\n        # NB! Don't forget that view.home_widget is added to notebook, not view directly\n        # get or create\n        view = self.get_view(view_id)\n        notebook = view.home_widget.master  # type: ignore\n\n        if hasattr(view, \"before_show\") and view.before_show() == False:  # type: ignore\n            return False\n\n        if view.hidden:  # type: ignore\n            notebook.insert(\n                \"auto\", view.home_widget, text=self._view_records[view_id][\"label\"]  # type: ignore\n            )\n            view.hidden = False  # type: ignore\n            if hasattr(view, \"on_show\"):  # type: ignore\n                view.on_show()\n\n        # switch to the tab\n        notebook.select(view.home_widget)  # type: ignore\n\n        # add focus\n        if set_focus:\n            view.focus_set()\n\n        self.set_option(\"view.\" + view_id + \".visible\", True)\n        self.event_generate(\"ShowView\", view=view, view_id=view_id)\n        return view", "is_method": true, "class_name": "Workbench", "function_description": "Makes a specified, previously registered GUI view visible and active within the Workbench's interface. It handles display state and sets focus to the view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "hide_view", "line_number": 1668, "body": "def hide_view(self, view_id: str) -> Union[bool, None]:\n        # NB! Don't forget that view.home_widget is added to notebook, not view directly\n\n        if \"instance\" in self._view_records[view_id]:\n            # TODO: handle the case, when view is maximized\n            view = self._view_records[view_id][\"instance\"]\n            if view.hidden:\n                return True\n\n            if hasattr(view, \"before_hide\") and view.before_hide() == False:\n                return False\n\n            view.home_widget.master.forget(view.home_widget)\n            self.set_option(\"view.\" + view_id + \".visible\", False)\n\n            self.event_generate(\"HideView\", view=view, view_id=view_id)\n            view.hidden = True\n\n        return True", "is_method": true, "class_name": "Workbench", "function_description": "This method hides a specified user interface view within the Workbench. It removes the view from display, updates its visibility state, and triggers a `HideView` event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "event_generate", "line_number": 1688, "body": "def event_generate(self, sequence: str, event: Optional[Record] = None, **kwargs) -> None:\n        \"\"\"Uses custom event handling when sequence doesn't start with <.\n        In this case arbitrary attributes can be added to the event.\n        Otherwise forwards the call to Tk's event_generate\"\"\"\n        # pylint: disable=arguments-differ\n        if sequence.startswith(\"<\"):\n            assert event is None\n            tk.Tk.event_generate(self, sequence, **kwargs)\n        else:\n            if sequence in self._event_handlers:\n                if event is None:\n                    event = WorkbenchEvent(sequence, **kwargs)\n                else:\n                    event.update(kwargs)\n\n                # make a copy of handlers, so that event handler can remove itself\n                # from the registry during iteration\n                # (or new handlers can be added)\n                for handler in sorted(self._event_handlers[sequence].copy(), key=str):\n                    try:\n                        handler(event)\n                    except Exception:\n                        self.report_exception(\"Problem when handling '\" + sequence + \"'\")\n\n        if not self._closing:\n            self._update_toolbar()", "is_method": true, "class_name": "Workbench", "function_description": "Generates and dispatches events within the Workbench. It handles standard GUI events via Tkinter or custom application-defined events, allowing arbitrary attributes to be passed to registered handlers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "bind", "line_number": 1715, "body": "def bind(self, sequence: str, func: Callable, add: bool = None) -> None:  # type: ignore\n        \"\"\"Uses custom event handling when sequence doesn't start with <.\n        Otherwise forwards the call to Tk's bind\"\"\"\n        # pylint: disable=signature-differs\n\n        if not add:\n            logging.warning(\n                \"Workbench.bind({}, ..., add={}) -- did you really want to replace existing bindings?\".format(\n                    sequence, add\n                )\n            )\n\n        if sequence.startswith(\"<\"):\n            tk.Tk.bind(self, sequence, func, add)\n        else:\n            if sequence not in self._event_handlers or not add:\n                self._event_handlers[sequence] = set()\n\n            self._event_handlers[sequence].add(func)", "is_method": true, "class_name": "Workbench", "function_description": "This method binds a function to a specified event sequence, enabling the `Workbench` to respond to user interactions or custom triggers. It supports both standard Tkinter GUI events and custom, application-defined event types."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "unbind", "line_number": 1735, "body": "def unbind(self, sequence: str, func=None) -> None:\n        # pylint: disable=arguments-differ\n        if sequence.startswith(\"<\"):\n            tk.Tk.unbind(self, sequence, funcid=func)\n        else:\n            try:\n                self._event_handlers[sequence].remove(func)\n            except Exception:\n                logger.exception(\"Can't remove binding for '%s' and '%s'\", sequence, func)", "is_method": true, "class_name": "Workbench", "function_description": "Removes a previously established binding between an event sequence and a callback function. This stops the function from being invoked when the event occurs, supporting both Tkinter and custom events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "in_heap_mode", "line_number": 1745, "body": "def in_heap_mode(self) -> bool:\n        # TODO: add a separate command for enabling the heap mode\n        # untie the mode from HeapView\n\n        return self._configuration_manager.has_option(\"view.HeapView.visible\") and self.get_option(\n            \"view.HeapView.visible\"\n        )", "is_method": true, "class_name": "Workbench", "function_description": "Indicates if the application is currently operating in a specific \"heap mode.\""}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "in_debug_mode", "line_number": 1753, "body": "def in_debug_mode(self) -> bool:\n        return (\n            os.environ.get(\"THONNY_DEBUG\", False)\n            in [\n                \"1\",\n                1,\n                \"True\",\n                True,\n                \"true\",\n            ]\n            or self.get_option(\"general.debug_mode\", False)\n        )", "is_method": true, "class_name": "Workbench", "function_description": "Determines if the Workbench application is currently operating in debug mode, based on environment settings or internal configuration. This informs other components to adjust their behavior for debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_init_scaling", "line_number": 1766, "body": "def _init_scaling(self) -> None:\n        self._default_scaling_factor = self.tk.call(\"tk\", \"scaling\")\n        if self._default_scaling_factor > 10:\n            # it may be infinity in eg. Fedora\n            self._default_scaling_factor = 1.33\n\n        scaling = self.get_option(\"general.scaling\")\n        if scaling in [\"default\", \"auto\"]:  # auto was used in 2.2b3\n            self._scaling_factor = self._default_scaling_factor\n        else:\n            self._scaling_factor = float(scaling)\n\n        MAC_SCALING_MODIFIER = 1.7\n        if running_on_mac_os():\n            self._scaling_factor *= MAC_SCALING_MODIFIER\n\n        self.tk.call(\"tk\", \"scaling\", self._scaling_factor)\n\n        font_scaling_mode = self.get_option(\"general.font_scaling_mode\")\n\n        if (\n            running_on_linux()\n            and font_scaling_mode in [\"default\", \"extra\"]\n            and scaling not in [\"default\", \"auto\"]\n        ):\n            # update system fonts which are given in pixel sizes\n            for name in tk_font.names():\n                f = tk_font.nametofont(name)\n                orig_size = f.cget(\"size\")\n                # According to do documentation, absolute values of negative font sizes\n                # should be interpreted as pixel sizes (not affected by \"tk scaling\")\n                # and positive values are point sizes, which are supposed to scale automatically\n                # http://www.tcl.tk/man/tcl8.6/TkCmd/font.htm#M26\n\n                # Unfortunately it seems that this cannot be relied on\n                # https://groups.google.com/forum/#!msg/comp.lang.tcl/ZpL6tq77M4M/GXImiV2INRQJ\n\n                # My experiments show that manually changing negative font sizes\n                # doesn't have any effect -- fonts keep their default size\n                # (Tested in Raspbian Stretch, Ubuntu 18.04 and Fedora 29)\n                # On the other hand positive sizes scale well (and they don't scale automatically)\n\n                # convert pixel sizes to point_size\n                if orig_size < 0:\n                    orig_size = -orig_size / self._default_scaling_factor\n\n                # scale\n                scaled_size = round(\n                    orig_size * (self._scaling_factor / self._default_scaling_factor)\n                )\n                f.configure(size=scaled_size)\n\n        elif running_on_mac_os() and scaling not in [\"default\", \"auto\"]:\n            # see http://wiki.tcl.tk/44444\n            # update system fonts\n            for name in tk_font.names():\n                f = tk_font.nametofont(name)\n                orig_size = f.cget(\"size\")\n                assert orig_size > 0\n                f.configure(size=int(orig_size * self._scaling_factor / MAC_SCALING_MODIFIER))", "is_method": true, "class_name": "Workbench", "function_description": "Initializes and applies the Tkinter GUI scaling factor for the Workbench. It adjusts global UI element and font sizes based on user settings and operating system specifics."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "update_fonts", "line_number": 1827, "body": "def update_fonts(self) -> None:\n        editor_font_size = self._guard_font_size(self.get_option(\"view.editor_font_size\"))\n        editor_font_family = self.get_option(\"view.editor_font_family\")\n\n        io_font_size = self._guard_font_size(self.get_option(\"view.io_font_size\"))\n        io_font_family = self.get_option(\"view.io_font_family\")\n        for io_name in [\n            \"IOFont\",\n            \"BoldIOFont\",\n            \"UnderlineIOFont\",\n            \"ItalicIOFont\",\n            \"BoldItalicIOFont\",\n        ]:\n            tk_font.nametofont(io_name).configure(family=io_font_family, size=io_font_size)\n\n        try:\n            shell = self.get_view(\"ShellView\", create=False)\n        except Exception:\n            # shell may be not created yet\n            pass\n        else:\n            shell.update_tabs()\n\n        tk_font.nametofont(\"EditorFont\").configure(family=editor_font_family, size=editor_font_size)\n        tk_font.nametofont(\"SmallEditorFont\").configure(\n            family=editor_font_family, size=editor_font_size - 2\n        )\n        tk_font.nametofont(\"BoldEditorFont\").configure(\n            family=editor_font_family, size=editor_font_size\n        )\n        tk_font.nametofont(\"ItalicEditorFont\").configure(\n            family=editor_font_family, size=editor_font_size\n        )\n        tk_font.nametofont(\"BoldItalicEditorFont\").configure(\n            family=editor_font_family, size=editor_font_size\n        )\n\n        if self.get_ui_mode() == \"simple\":\n            default_size_factor = max(0.7, 1 - (editor_font_size - 10) / 25)\n            small_size_factor = max(0.6, 0.8 - (editor_font_size - 10) / 25)\n\n            tk_font.nametofont(\"TkDefaultFont\").configure(\n                size=round(editor_font_size * default_size_factor)\n            )\n            tk_font.nametofont(\"TkHeadingFont\").configure(\n                size=round(editor_font_size * default_size_factor)\n            )\n            tk_font.nametofont(\"SmallLinkFont\").configure(\n                size=round(editor_font_size * small_size_factor)\n            )\n\n        # Update Treeview font and row height\n        if running_on_mac_os():\n            treeview_font_size = int(editor_font_size * 0.7 + 4)\n        else:\n            treeview_font_size = int(editor_font_size * 0.7 + 2)\n\n        treeview_font = tk_font.nametofont(\"TreeviewFont\")\n        treeview_font.configure(size=treeview_font_size)\n        rowheight = round(treeview_font.metrics(\"linespace\") * 1.2)\n\n        style = ttk.Style()\n        style.configure(\"Treeview\", rowheight=rowheight)\n\n        if self._editor_notebook is not None:\n            self._editor_notebook.update_appearance()", "is_method": true, "class_name": "Workbench", "function_description": "Updates all user interface fonts within the Workbench, including editor, I/O, and general elements, based on configured options. It ensures a consistent typographic appearance across the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_get_menu_index", "line_number": 1894, "body": "def _get_menu_index(self, menu: tk.Menu) -> int:\n        for i in range(len(self._menubar.winfo_children())):\n            if menu == self._menubar.winfo_children()[i]:\n                return i\n\n        raise RuntimeError(\"Couldn't find menu\")", "is_method": true, "class_name": "Workbench", "function_description": "This method finds the index of a specific Tkinter menu within the workbench's menubar. It allows locating menus by their position for UI management operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_add_toolbar_button", "line_number": 1901, "body": "def _add_toolbar_button(\n        self,\n        command_id: str,\n        image: Optional[tk.PhotoImage],\n        disabled_image: Optional[tk.PhotoImage],\n        command_label: str,\n        caption: str,\n        alternative_caption: str,\n        accelerator: Optional[str],\n        handler: Callable[[], None],\n        tester: Optional[Callable[[], bool]],\n        toolbar_group: int,\n    ) -> None:\n\n        assert caption is not None and len(caption) > 0, (\n            \"Missing caption for '%s'. Toolbar commands must have caption.\" % command_label\n        )\n        slaves = self._toolbar.grid_slaves(0, toolbar_group)\n        if len(slaves) == 0:\n            group_frame = ttk.Frame(self._toolbar)\n            if self.in_simple_mode():\n                padx = 0  # type: Union[int, Tuple[int, int]]\n            else:\n                padx = (0, 10)\n            group_frame.grid(row=0, column=toolbar_group, padx=padx)\n        else:\n            group_frame = slaves[0]\n\n        if self.in_simple_mode():\n            screen_width = self.winfo_screenwidth()\n            if screen_width >= 1280:\n                button_width = max(7, len(caption), len(alternative_caption))\n            elif screen_width >= 1024:\n                button_width = max(6, len(caption), len(alternative_caption))\n            else:\n                button_width = max(5, len(caption), len(alternative_caption))\n        else:\n            button_width = None\n\n        if disabled_image is not None:\n            image_spec = [image, \"disabled\", disabled_image]\n        else:\n            image_spec = image\n\n        button = ttk.Button(\n            group_frame,\n            image=image_spec,\n            style=\"Toolbutton\",\n            state=tk.NORMAL,\n            text=caption,\n            compound=\"top\" if self.in_simple_mode() else None,\n            pad=(10, 0) if self.in_simple_mode() else None,\n            width=button_width,\n        )\n\n        def toolbar_handler(*args):\n            handler(*args)\n            self._update_toolbar()\n            if self.focus_get() == button:\n                # previously selected widget would be better candidate, but this is\n                # better than button\n                self._editor_notebook.focus_set()\n\n        button.configure(command=toolbar_handler)\n\n        button.pack(side=tk.LEFT)\n        button.tester = tester  # type: ignore\n        tooltip_text = command_label\n        if self.get_ui_mode() != \"simple\":\n            if accelerator and lookup_style_option(\n                \"OPTIONS\", \"shortcuts_in_tooltips\", default=True\n            ):\n                tooltip_text += \" (\" + accelerator + \")\"\n            create_tooltip(button, tooltip_text)\n\n        self._toolbar_buttons[command_id] = button", "is_method": true, "class_name": "Workbench", "function_description": "Adds and configures an interactive button for the Workbench's GUI toolbar. It defines the button's appearance, associated action, and dynamic state within a specified group."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_toolbar_button", "line_number": 1978, "body": "def get_toolbar_button(self, command_id):\n        return self._toolbar_buttons[command_id]", "is_method": true, "class_name": "Workbench", "function_description": "Provides access to a specific toolbar button within the workbench using its unique command identifier."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_update_toolbar", "line_number": 1981, "body": "def _update_toolbar(self, event=None) -> None:\n        if self._destroyed or not hasattr(self, \"_toolbar\"):\n            return\n\n        if self._toolbar.winfo_ismapped():\n            for group_frame in self._toolbar.grid_slaves(0):\n                for button in group_frame.pack_slaves():\n                    if thonny._runner is None or button.tester and not button.tester():\n                        button[\"state\"] = tk.DISABLED\n                    else:\n                        button[\"state\"] = tk.NORMAL", "is_method": true, "class_name": "Workbench", "function_description": "Dynamically updates the enabled/disabled state of toolbar buttons within the workbench. This ensures user interface elements reflect the application's current operational status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_cmd_zoom_with_mouse", "line_number": 1993, "body": "def _cmd_zoom_with_mouse(self, event) -> None:\n        if event.delta > 0:\n            self._change_font_size(1)\n        else:\n            self._change_font_size(-1)", "is_method": true, "class_name": "Workbench", "function_description": "Enables zooming functionality within the Workbench by adjusting the display's font size based on mouse scroll wheel input."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_toggle_font_size", "line_number": 1999, "body": "def _toggle_font_size(self) -> None:\n        current_size = self.get_option(\"view.editor_font_size\")\n\n        if self.winfo_screenwidth() < 1024:\n            # assuming 32x32 icons\n            small_size = 10\n            medium_size = 12\n            large_size = 14\n        elif self.winfo_screenwidth() < 1280:\n            # assuming 32x32 icons\n            small_size = 12\n            medium_size = 14\n            large_size = 18\n        else:\n            small_size = 12\n            medium_size = 16\n            large_size = 20\n\n        widths = {10: 800, 12: 1050, 14: 1200, 16: 1300, 18: 1400, 20: 1650}\n\n        if current_size < small_size or current_size >= large_size:\n            new_size = small_size\n        elif current_size < medium_size:\n            new_size = medium_size\n        else:\n            new_size = large_size\n\n        self._change_font_size(new_size - current_size)\n\n        new_width = min(widths[new_size], self.winfo_screenwidth())\n        geo = re.findall(r\"\\d+\", self.wm_geometry())\n        self.geometry(\"{0}x{1}+{2}+{3}\".format(new_width, geo[1], geo[2], geo[3]))", "is_method": true, "class_name": "Workbench", "function_description": "This method cycles the editor's font size through predefined small, medium, or large settings based on screen width. It also adjusts the workbench window's width for optimal display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_change_font_size", "line_number": 2032, "body": "def _change_font_size(self, delta: int) -> None:\n\n        if delta != 0:\n            editor_font_size = self.get_option(\"view.editor_font_size\")\n            editor_font_size += delta\n            self.set_option(\"view.editor_font_size\", self._guard_font_size(editor_font_size))\n            io_font_size = self.get_option(\"view.io_font_size\")\n            io_font_size += delta\n            self.set_option(\"view.io_font_size\", self._guard_font_size(io_font_size))\n            self.update_fonts()", "is_method": true, "class_name": "Workbench", "function_description": "This Workbench method adjusts the font size for both the editor and I/O output areas. It provides a user interface utility for dynamically changing text display for improved readability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_guard_font_size", "line_number": 2043, "body": "def _guard_font_size(self, size: int) -> int:\n        # https://bitbucket.org/plas/thonny/issues/164/negative-font-size-crashes-thonny\n        MIN_SIZE = 4\n        MAX_SIZE = 200\n        if size < MIN_SIZE:\n            return MIN_SIZE\n        elif size > MAX_SIZE:\n            return MAX_SIZE\n        else:\n            return size", "is_method": true, "class_name": "Workbench", "function_description": "This Workbench method ensures a given font size falls within valid minimum and maximum limits. It prevents out-of-range values by clamping the size to a safe range."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_check_update_window_width", "line_number": 2054, "body": "def _check_update_window_width(self, delta: int) -> None:\n        if not ui_utils.get_zoomed(self):\n            self.update_idletasks()\n            # TODO: shift to left if right edge goes away from screen\n            # TODO: check with screen width\n            new_geometry = \"{0}x{1}+{2}+{3}\".format(\n                self.winfo_width() + delta, self.winfo_height(), self.winfo_x(), self.winfo_y()\n            )\n\n            self.geometry(new_geometry)", "is_method": true, "class_name": "Workbench", "function_description": "Allows the Workbench window's width to be adjusted by a delta amount. This method facilitates dynamic horizontal resizing when the window is not zoomed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_maximize_view", "line_number": 2065, "body": "def _maximize_view(self, event=None) -> None:\n        if self._maximized_view is not None:\n            return\n\n        # find the widget that can be relocated\n        widget = self.focus_get()\n        if isinstance(widget, (EditorNotebook, AutomaticNotebook)):\n            current_tab = widget.get_current_child()\n            if current_tab is None:\n                return\n\n            if not hasattr(current_tab, \"maximizable_widget\"):\n                return\n\n            widget = current_tab.maximizable_widget\n\n        while widget is not None:\n            if hasattr(widget, \"home_widget\"):\n                # if widget is view, then widget.master is workbench\n                widget.grid(row=1, column=0, sticky=tk.NSEW, in_=widget.master)  # type: ignore\n                # hide main_frame\n                self._main_frame.grid_forget()\n                self._maximized_view = widget\n                self.get_variable(\"view.maximize_view\").set(True)\n                break\n            else:\n                widget = widget.master", "is_method": true, "class_name": "Workbench", "function_description": "Maximizes the currently focused UI view or a contained component. It expands the selected element to fill the Workbench's primary display area, hiding the main frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_unmaximize_view", "line_number": 2093, "body": "def _unmaximize_view(self, event=None) -> None:\n        if self._maximized_view is None:\n            return\n\n        # restore main_frame\n        self._main_frame.grid(row=1, column=0, sticky=tk.NSEW, in_=self)\n        # put the maximized view back to its home_widget\n        self._maximized_view.grid(\n            row=0, column=0, sticky=tk.NSEW, in_=self._maximized_view.home_widget  # type: ignore\n        )\n        self._maximized_view = None\n        self.get_variable(\"view.maximize_view\").set(False)", "is_method": true, "class_name": "Workbench", "function_description": "Reverts the Workbench's display by returning the currently maximized view to its original position and restoring the main frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "show_options", "line_number": 2106, "body": "def show_options(self, page_key=None):\n        dlg = ConfigurationDialog(self, self._configuration_pages)\n        if page_key:\n            dlg.select_page(page_key)\n\n        ui_utils.show_dialog(dlg)\n\n        if dlg.backend_restart_required:\n            get_runner().restart_backend(False)", "is_method": true, "class_name": "Workbench", "function_description": "Displays a configuration dialog to the user, optionally opening a specific page, and restarts the backend if required by user changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_cmd_focus_editor", "line_number": 2116, "body": "def _cmd_focus_editor(self) -> None:\n        self.get_editor_notebook().focus_set()", "is_method": true, "class_name": "Workbench", "function_description": "This method sets the input focus to the active editor notebook. This enables direct user interaction, such as typing, within the Workbench's editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_cmd_focus_shell", "line_number": 2119, "body": "def _cmd_focus_shell(self) -> None:\n        self.show_view(\"ShellView\", True)\n        shell = get_shell()\n        # go to the end of any current input\n        shell.text.mark_set(\"insert\", \"end\")\n        shell.text.see(\"insert\")", "is_method": true, "class_name": "Workbench", "function_description": "Activates and brings the interactive shell view to the forefront. It positions the input cursor at the end, ready for immediate user commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_cmd_toggle_full_screen", "line_number": 2126, "body": "def _cmd_toggle_full_screen(self) -> None:\n        \"\"\"\n        TODO: For mac\n        http://wiki.tcl.tk/44444\n\n        Switching a window to fullscreen mode\n        (Normal Difference)\n        To switch a window to fullscreen mode, the window must first be withdrawn.\n              # For Linux/Mac OS X:\n\n              set cfs [wm attributes $w -fullscreen]\n              if { $::tcl_platform(os) eq \"Darwin\" } {\n                if { $cfs == 0 } {\n                  # optional: save the window geometry\n                  set savevar [wm geometry $w]\n                }\n                wm withdraw $w\n              }\n              wm attributes $w -fullscreen [expr {1-$cfs}]\n              if { $::tcl_platform(os) eq \"Darwin\" } {\n                wm deiconify $w\n                if { $cfs == 1 } {\n                  after idle [list wm geometry $w $savevar]\n                }\n              }\n\n        \"\"\"\n        var = self.get_variable(\"view.full_screen\")\n        var.set(not var.get())\n        self.attributes(\"-fullscreen\", var.get())", "is_method": true, "class_name": "Workbench", "function_description": "Toggles the Workbench application's main window between full-screen and normal display modes, providing a user-driven interface for view control."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_cmd_toggle_maximize_view", "line_number": 2157, "body": "def _cmd_toggle_maximize_view(self) -> None:\n        if self._maximized_view is not None:\n            self._unmaximize_view()\n        else:\n            self._maximize_view()", "is_method": true, "class_name": "Workbench", "function_description": "This method toggles the current view in the workbench between a maximized and unmaximized state, providing a UI control for display management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_update_menu", "line_number": 2163, "body": "def _update_menu(self, menu: tk.Menu, menu_name: str) -> None:\n        if menu.index(\"end\") is None:\n            return\n\n        for i in range(menu.index(\"end\") + 1):\n            item_data = menu.entryconfigure(i)\n            if \"label\" in item_data:\n                command_label = menu.entrycget(i, \"label\")\n                if (menu_name, command_label) not in self._menu_item_specs:\n                    continue\n                tester = self._menu_item_specs[(menu_name, command_label)].tester\n\n                enabled = not tester\n                if tester:\n                    try:\n                        enabled = tester()\n                    except Exception as e:\n                        logging.exception(\n                            \"Could not check command tester for '%s'\", item_data, exc_info=e\n                        )\n                        traceback.print_exc()\n                        enabled = False\n\n                if enabled:\n                    menu.entryconfigure(i, state=tk.NORMAL)\n                else:\n                    menu.entryconfigure(i, state=tk.DISABLED)", "is_method": true, "class_name": "Workbench", "function_description": "Manages the interactive state of a Tkinter menu by dynamically enabling or disabling its items. It evaluates a defined 'tester' for each menu item to determine its current availability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_find_location_for_menu_item", "line_number": 2191, "body": "def _find_location_for_menu_item(self, menu_name: str, command_label: str) -> Union[str, int]:\n\n        menu = self.get_menu(menu_name)\n\n        if menu.index(\"end\") == None:  # menu is empty\n            return \"end\"\n\n        specs = self._menu_item_specs[(menu_name, command_label)]\n\n        this_group_exists = False\n        for i in range(0, menu.index(\"end\") + 1):\n            data = menu.entryconfigure(i)\n            if \"label\" in data:\n                # it's a command, not separator\n                sibling_label = menu.entrycget(i, \"label\")\n                sibling_group = self._menu_item_specs[(menu_name, sibling_label)].group\n\n                if sibling_group == specs.group:\n                    this_group_exists = True\n                    if specs.position_in_group == \"alphabetic\" and sibling_label > command_label:\n                        return i\n\n                if sibling_group > specs.group:\n                    assert (\n                        not this_group_exists\n                    )  # otherwise we would have found the ending separator\n                    menu.insert_separator(i)\n                    return i\n            else:\n                # We found a separator\n                if this_group_exists:\n                    # it must be the ending separator for this group\n                    return i\n\n        # no group was bigger, ie. this should go to the end\n        if not this_group_exists:\n            menu.add_separator()\n\n        return \"end\"", "is_method": true, "class_name": "Workbench", "function_description": "This private method of the Workbench class determines the appropriate insertion index for a new menu item. It ensures items are grouped and ordered correctly within the menu structure, adding separators as needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_poll_ipc_requests", "line_number": 2231, "body": "def _poll_ipc_requests(self) -> None:\n        try:\n            if self._ipc_requests.empty():\n                return\n\n            while not self._ipc_requests.empty():\n                args = self._ipc_requests.get()\n                try:\n                    for filename in args:\n                        if os.path.isfile(filename):\n                            self.get_editor_notebook().show_file(filename)\n\n                except Exception as e:\n                    logger.exception(\"Problem processing ipc request\", exc_info=e)\n\n            self.become_active_window()\n        finally:\n            self.after(50, self._poll_ipc_requests)", "is_method": true, "class_name": "Workbench", "function_description": "This method continuously polls for inter-process communication (IPC) requests. It processes these requests by opening specified files in the editor and activating the workbench window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_close", "line_number": 2250, "body": "def _on_close(self) -> None:\n        if self._editor_notebook and not self._editor_notebook.check_allow_closing():\n            return\n\n        self._closing = True\n        try:\n            self._save_layout()\n            self._editor_notebook.remember_open_files()\n            self.event_generate(\"WorkbenchClose\")\n            self._configuration_manager.save()\n            temp_dir = self.get_temp_dir(create_if_doesnt_exist=False)\n            if os.path.exists(temp_dir):\n                try:\n                    shutil.rmtree(temp_dir)\n                except Exception as e:\n                    logger.error(\"Could not remove temp dir\", exc_info=e)\n        except Exception:\n            self.report_exception()\n\n        self.destroy()\n        self._destroyed = True", "is_method": true, "class_name": "Workbench", "function_description": "Orchestrates the graceful shutdown of the Workbench application. It ensures layout and configuration are saved, open files remembered, and temporary resources cleaned up before destroying the instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_all_key_presses", "line_number": 2272, "body": "def _on_all_key_presses(self, event):\n        if running_on_windows():\n            ui_utils.handle_mistreated_latin_shortcuts(self._latin_shortcuts, event)", "is_method": true, "class_name": "Workbench", "function_description": "This method handles all key press events, specifically addressing and correcting mistreated Latin keyboard shortcuts on Windows to ensure consistent UI interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_focus_in", "line_number": 2276, "body": "def _on_focus_in(self, event):\n        if self._lost_focus:\n            self._lost_focus = False\n            self.event_generate(\"WindowFocusIn\")", "is_method": true, "class_name": "Workbench", "function_description": "Handles a window focus-in event, signaling that the Workbench has regained focus. It updates an internal state and generates a 'WindowFocusIn' event for other components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_focus_out", "line_number": 2281, "body": "def _on_focus_out(self, event):\n        if self.focus_get() is None:\n            if not self._lost_focus:\n                self._lost_focus = True\n                self.event_generate(\"WindowFocusOut\")", "is_method": true, "class_name": "Workbench", "function_description": "Notifies when the Workbench application window loses focus. It generates a \"WindowFocusOut\" event for other components to react."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "focus_get", "line_number": 2287, "body": "def focus_get(self) -> Optional[tk.Widget]:\n        try:\n            return tk.Tk.focus_get(self)\n        except Exception:\n            # This may give error in Ubuntu\n            return None", "is_method": true, "class_name": "Workbench", "function_description": "Retrieves the Tkinter widget that currently has input focus for the Workbench instance. This allows identifying the active UI component receiving user input."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "destroy", "line_number": 2294, "body": "def destroy(self) -> None:\n        try:\n            if self._is_server() and os.path.exists(thonny.get_ipc_file_path()):\n                os.remove(thonny.get_ipc_file_path())\n\n            self._closing = True\n\n            # Tk clipboard gets cleared on exit and won't end up in system clipboard\n            # https://bugs.python.org/issue1207592\n            # https://stackoverflow.com/questions/26321333/tkinter-in-python-3-4-on-windows-dont-post-internal-clipboard-data-to-the-windo\n            try:\n                clipboard_data = self.clipboard_get()\n                if len(clipboard_data) < 1000 and all(\n                    map(os.path.exists, clipboard_data.splitlines())\n                ):\n                    # Looks like the clipboard contains file name(s)\n                    # Most likely this means actual file cut/copy operation\n                    # was made outside of Thonny.\n                    # Don't want to replace this with simple string data of file names.\n                    pass\n                else:\n                    copy_to_clipboard(clipboard_data)\n            except Exception:\n                pass\n\n        except Exception:\n            logging.exception(\"Error while destroying workbench\")\n\n        finally:\n            try:\n                super().destroy()\n            finally:\n                runner = get_runner()\n                if runner != None:\n                    runner.destroy_backend()", "is_method": true, "class_name": "Workbench", "function_description": "Responsible for gracefully shutting down the workbench application. It cleans up IPC files, terminates the backend process, and ensures clipboard data persistence."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_configure", "line_number": 2330, "body": "def _on_configure(self, event) -> None:\n        # called when window is moved or resized\n        if (\n            hasattr(self, \"_maximized_view\")  # configure may happen before the attribute is defined\n            and self._maximized_view  # type: ignore\n        ):\n            # grid again, otherwise it acts weird\n            self._maximized_view.grid(\n                row=1, column=0, sticky=tk.NSEW, in_=self._maximized_view.master  # type: ignore\n            )", "is_method": true, "class_name": "Workbench", "function_description": "Ensures a maximized view within the Workbench maintains its correct layout and size when the window is resized or moved."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_on_tk_exception", "line_number": 2341, "body": "def _on_tk_exception(self, exc, val, tb) -> None:\n        # copied from tkinter.Tk.report_callback_exception with modifications\n        # see http://bugs.python.org/issue22384\n        sys.last_type = exc\n        sys.last_value = val\n        sys.last_traceback = tb\n        self.report_exception()", "is_method": true, "class_name": "Workbench", "function_description": "This method handles uncaught exceptions from the Tkinter event loop. It records the exception details and initiates the workbench's general exception reporting process for debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "report_exception", "line_number": 2349, "body": "def report_exception(self, title: str = \"Internal error\") -> None:\n        logging.exception(title)\n        if tk._default_root and not self._closing:  # type: ignore\n            (typ, value, _) = sys.exc_info()\n            assert typ is not None\n            if issubclass(typ, UserError):\n                msg = str(value)\n            else:\n                msg = traceback.format_exc()\n\n            dlg = ui_utils.LongTextDialog(title, msg, parent=self)\n            ui_utils.show_dialog(dlg, self)", "is_method": true, "class_name": "Workbench", "function_description": "Logs an internal error and displays a detailed exception message to the user via a dialog, differentiating user errors from full tracebacks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_open_views", "line_number": 2362, "body": "def _open_views(self) -> None:\n        for nb_name in self._view_notebooks:\n            view_name = self.get_option(\"layout.notebook_\" + nb_name + \"_visible_view\")\n            if view_name != None:\n                if view_name == \"GlobalsView\":\n                    # was renamed in 2.2b5\n                    view_name = \"VariablesView\"\n\n                if (\n                    self.get_ui_mode() != \"simple\" or view_name in SIMPLE_MODE_VIEWS\n                ) and view_name in self._view_records:\n                    self.show_view(view_name)\n\n        # make sure VariablesView is at least loaded\n        # otherwise it may miss globals events\n        # and will show empty table on open\n        self.get_view(\"VariablesView\")\n\n        if (\n            self.get_option(\"assistance.open_assistant_on_errors\")\n            or self.get_option(\"assistance.open_assistant_on_warnings\")\n        ) and (self.get_ui_mode() != \"simple\" or \"AssistantView\" in SIMPLE_MODE_VIEWS):\n            self.get_view(\"AssistantView\")", "is_method": true, "class_name": "Workbench", "function_description": "Initializes and displays the workbench's user interface views based on configuration settings. It ensures critical views like 'VariablesView' are loaded and opens 'AssistantView' conditionally."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_save_layout", "line_number": 2386, "body": "def _save_layout(self) -> None:\n        self.update_idletasks()\n        self.set_option(\"layout.zoomed\", ui_utils.get_zoomed(self))\n\n        for nb_name in self._view_notebooks:\n            widget = self._view_notebooks[nb_name].get_visible_child()\n            if hasattr(widget, \"maximizable_widget\"):\n                view = widget.maximizable_widget\n                view_name = type(view).__name__\n                self.set_option(\"layout.notebook_\" + nb_name + \"_visible_view\", view_name)\n            else:\n                self.set_option(\"layout.notebook_\" + nb_name + \"_visible_view\", None)\n\n        if not ui_utils.get_zoomed(self) or running_on_mac_os():\n            # can't restore zoom on mac without setting actual dimensions\n            gparts = re.findall(r\"\\d+\", self.wm_geometry())\n            self.set_option(\"layout.width\", int(gparts[0]))\n            self.set_option(\"layout.height\", int(gparts[1]))\n            self.set_option(\"layout.left\", int(gparts[2]))\n            self.set_option(\"layout.top\", int(gparts[3]))\n\n        self.set_option(\"layout.west_pw_width\", self._west_pw.preferred_size_in_pw)\n        self.set_option(\"layout.east_pw_width\", self._east_pw.preferred_size_in_pw)\n        for key in [\"nw\", \"sw\", \"s\", \"se\", \"ne\"]:\n            self.set_option(\n                \"layout.%s_nb_height\" % key, self._view_notebooks[key].preferred_size_in_pw\n            )", "is_method": true, "class_name": "Workbench", "function_description": "Saves the current state of the Workbench UI layout, including window dimensions, pane sizes, and visible views within notebooks. This enables restoring the application's visual configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "update_title", "line_number": 2414, "body": "def update_title(self, event=None) -> None:\n        editor = self.get_editor_notebook().get_current_editor()\n        if self._is_portable:\n            title_text = \"Portable Thonny\"\n        else:\n            title_text = \"Thonny\"\n        if editor != None:\n            title_text += \"  -  \" + editor.get_long_description()\n\n        self.title(title_text)", "is_method": true, "class_name": "Workbench", "function_description": "This method updates the main application window's title, combining \"Thonny\" (or \"Portable Thonny\") with the description of the currently active editor for user context. It provides a dynamic and informative window title."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "become_active_window", "line_number": 2425, "body": "def become_active_window(self, force=True) -> None:\n        # Looks like at least on Windows all following is required\n        # for ensuring the window gets focus\n        # (deiconify, ..., iconify, deiconify)\n        self.deiconify()\n\n        if force:\n            self.attributes(\"-topmost\", True)\n            self.after_idle(self.attributes, \"-topmost\", False)\n            self.lift()\n\n            if not running_on_linux():\n                # http://stackoverflow.com/a/13867710/261181\n                self.iconify()\n                self.deiconify()\n\n        editor = self.get_editor_notebook().get_current_editor()\n        if editor is not None:\n            # This method is meant to be called when new file is opened, so it's safe to\n            # send the focus to the editor\n            editor.focus_set()\n        else:\n            self.focus_set()", "is_method": true, "class_name": "Workbench", "function_description": "This method makes the Workbench window visible, brings it to the front, and ensures it gains focus. It also directs focus to the active editor for immediate user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "open_url", "line_number": 2449, "body": "def open_url(self, url):\n        m = re.match(r\"^thonny-editor://(.*?)(#(\\d+)(:(\\d+))?)?$\", url)\n        if m is not None:\n            filename = m.group(1).replace(\"%20\", \" \")\n            lineno = None if m.group(3) is None else int(m.group(3))\n            col_offset = None if m.group(5) is None else int(m.group(5))\n            if lineno is None:\n                self.get_editor_notebook().show_file(filename)\n            else:\n                self.get_editor_notebook().show_file_at_line(filename, lineno, col_offset)\n\n            return\n\n        m = re.match(r\"^thonny-help://(.*?)(#(.+))?$\", url)\n        if m is not None:\n            topic = m.group(1)\n            fragment = m.group(3)\n            self.show_view(\"HelpView\").load_topic(topic, fragment)\n            return\n\n        if url.endswith(\".rst\") and not url.startswith(\"http\"):\n            parts = url.split(\"#\", maxsplit=1)\n            topic = parts[0][:-4]\n            if len(parts) == 2:\n                fragment = parts[1]\n            else:\n                fragment = None\n\n            self.show_view(\"HelpView\").load_topic(topic, fragment)\n            return\n\n        # Fallback\n        import webbrowser\n\n        webbrowser.open(url, False, True)", "is_method": true, "class_name": "Workbench", "function_description": "As a Workbench method, it dispatches URLs to open files in the Thonny editor, display internal help topics, or launch external web pages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "open_help_topic", "line_number": 2485, "body": "def open_help_topic(self, topic, fragment=None):\n        self.show_view(\"HelpView\").load_topic(topic, fragment)", "is_method": true, "class_name": "Workbench", "function_description": "This method opens a specific help topic within the Workbench application. It provides users with integrated access to documentation for various topics and their sub-sections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "bell", "line_number": 2488, "body": "def bell(self, displayof=0):\n        if not self.get_option(\"general.disable_notification_sound\"):\n            super().bell(displayof=displayof)", "is_method": true, "class_name": "Workbench", "function_description": "Plays a notification sound for the Workbench. This function provides an audible alert to the user, respecting their preference to disable notification sounds."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_mac_quit", "line_number": 2492, "body": "def _mac_quit(self, *args):\n        self._on_close()", "is_method": true, "class_name": "Workbench", "function_description": "This method provides a Mac-specific handler to initiate the Workbench's graceful shutdown process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "_is_server", "line_number": 2495, "body": "def _is_server(self):\n        return self._ipc_requests is not None", "is_method": true, "class_name": "Workbench", "function_description": "Determines if the Workbench instance is configured as an IPC server. This check enables conditional execution of server-specific operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_toolbar", "line_number": 2498, "body": "def get_toolbar(self):\n        return self._toolbar", "is_method": true, "class_name": "Workbench", "function_description": "Provides direct access to the `Workbench`'s associated toolbar object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_temp_dir", "line_number": 2501, "body": "def get_temp_dir(self, create_if_doesnt_exist=True):\n        path = os.path.join(THONNY_USER_DIR, \"temp\")\n        if create_if_doesnt_exist:\n            os.makedirs(path, exist_ok=True)\n        return path", "is_method": true, "class_name": "Workbench", "function_description": "Provides a path to a temporary directory specific to the Thonny user. It ensures the directory exists, facilitating temporary file operations for the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "module_sort_key", "line_number": 399, "body": "def module_sort_key(m):\n            return getattr(m, \"load_order_key\", m.__name__)", "is_method": true, "class_name": "Workbench", "function_description": "Generates a sort key for a module or similar object, prioritizing a custom 'load_order_key' attribute and falling back to the object's name. This enables consistent ordering of modules for loading or processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "server_loop", "line_number": 531, "body": "def server_loop():\n            while True:\n                logging.debug(\"Waiting for next client\")\n                (client_socket, _) = server_socket.accept()\n                try:\n                    data = bytes()\n                    while True:\n                        new_data = client_socket.recv(1024)\n                        if len(new_data) > 0:\n                            data += new_data\n                        else:\n                            break\n                    proposed_secret, args = ast.literal_eval(data.decode(\"UTF-8\"))\n                    if proposed_secret == actual_secret:\n                        self._ipc_requests.put(args)\n                        # respond OK\n                        client_socket.sendall(SERVER_SUCCESS.encode(encoding=\"utf-8\"))\n                        client_socket.shutdown(socket.SHUT_WR)\n                        logging.debug(\"AFTER NEW REQUEST %s\", client_socket)\n                    else:\n                        client_socket.shutdown(socket.SHUT_WR)\n                        raise PermissionError(\"Wrong secret\")\n\n                except Exception as e:\n                    logger.exception(\"Error in ipc server loop\", exc_info=e)", "is_method": true, "class_name": "Workbench", "function_description": "Implements an Inter-Process Communication (IPC) server for the Workbench, continuously accepting and authenticating client requests. Valid requests are queued for internal processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "choose_backend", "line_number": 788, "body": "def choose_backend():\n            backend_conf = ast.literal_eval(self._backend_conf_variable.get())\n            assert isinstance(backend_conf, dict), \"backend conf is %r\" % backend_conf\n            for name, value in backend_conf.items():\n                self.set_option(name, value)\n            get_runner().restart_backend(False)", "is_method": true, "class_name": "Workbench", "function_description": "Configures the workbench's backend based on user-defined settings and then restarts the backend to apply these changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "dispatch", "line_number": 988, "body": "def dispatch(event=None):\n            if not tester or tester():\n                denied = False\n                handler()\n            else:\n                denied = True\n                logging.debug(\"Command '\" + command_id + \"' execution denied\")\n                if bell_when_denied:\n                    self.bell()\n\n            self.event_generate(\"UICommandDispatched\", command_id=command_id, denied=denied)", "is_method": true, "class_name": "Workbench", "function_description": "This method attempts to execute a command's handler, optionally checking a pre-condition. It then dispatches a UI event indicating whether the command was successfully executed or denied."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "dispatch_if_caps_lock_is_on", "line_number": 1000, "body": "def dispatch_if_caps_lock_is_on(event):\n            if caps_lock_is_on(event.state) and not shift_is_pressed(event.state):\n                dispatch(event)", "is_method": true, "class_name": "Workbench", "function_description": "Conditionally dispatches an event only if Caps Lock is active and the Shift key is not pressed. This provides precise control over event processing based on keyboard modifier state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "toggle_view_visibility", "line_number": 1148, "body": "def toggle_view_visibility():\n            if visibility_flag.get():\n                self.hide_view(view_id)\n            else:\n                self.show_view(view_id, True)", "is_method": true, "class_name": "Workbench", "function_description": "This method toggles the visibility of a specific view within the Workbench. It hides the view if visible and shows it if hidden, providing UI management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "get_settings", "line_number": 1305, "body": "def get_settings(name):\n            try:\n                parent, settings = self._syntax_themes[name]\n            except KeyError:\n                self.report_exception(\"Can't find theme '%s'\" % name)\n                return {}\n\n            if callable(settings):\n                settings = settings()\n\n            if parent is None:\n                return settings\n            else:\n                result = get_settings(parent)\n                for key in settings:\n                    if key in result:\n                        result[key].update(settings[key])\n                    else:\n                        result[key] = settings[key]\n                return result", "is_method": true, "class_name": "Workbench", "function_description": "Retrieves the full configuration settings for a given syntax theme, incorporating inherited properties from its parent theme if applicable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "update_visibility", "line_number": 1383, "body": "def update_visibility():\n            if visibility_var.get():\n                if not frame.winfo_ismapped():\n                    frame.grid(row=0, column=col, sticky=\"nse\")\n            else:\n                if frame.winfo_ismapped():\n                    frame.grid_remove()", "is_method": true, "class_name": "Workbench", "function_description": "Updates the visibility of a UI frame. It ensures the frame is either shown or hidden on the grid layout based on a stored visibility setting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "toggle", "line_number": 1391, "body": "def toggle():\n            visibility_var.set(not visibility_var.get())\n            update_visibility()", "is_method": true, "class_name": "Workbench", "function_description": "Toggles the visibility of an element or feature within the Workbench, switching its state and applying the change."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "on_click", "line_number": 1420, "body": "def on_click(event):\n            self.set_option(\"general.ui_mode\", \"regular\")\n            tk.messagebox.showinfo(\n                tr(\"Regular mode\"),\n                tr(\n                    \"Configuration has been updated. \"\n                    + \"Restart Thonny to start working in regular mode.\\n\\n\"\n                    + \"(See 'Tools \u2192 Options \u2192 General' if you change your mind later.)\"\n                ),\n                master=self,\n            )", "is_method": true, "class_name": "Workbench", "function_description": "Sets the application's UI mode to 'regular' upon a click event. It then notifies the user to restart Thonny for the changes to take effect."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "toolbar_handler", "line_number": 1956, "body": "def toolbar_handler(*args):\n            handler(*args)\n            self._update_toolbar()\n            if self.focus_get() == button:\n                # previously selected widget would be better candidate, but this is\n                # better than button\n                self._editor_notebook.focus_set()", "is_method": true, "class_name": "Workbench", "function_description": "This method processes toolbar events by executing the associated action, updating the toolbar's state, and adjusting keyboard focus. It ensures a consistent user experience after a toolbar interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workbench.py", "function": "dispatch_from_menu", "line_number": 1054, "body": "def dispatch_from_menu():\n                # I don't like that Tk menu toggles checbutton variable\n                # automatically before calling the handler.\n                # So I revert the toggle before calling the actual handler.\n                # This way the handler doesn't have to worry whether it\n                # needs to toggle the variable or not, and it can choose to\n                # decline the toggle.\n                if flag_name is not None:\n                    var = self.get_variable(flag_name)\n                    var.set(not var.get())\n\n                dispatch(None)", "is_method": true, "class_name": "Workbench", "function_description": "Provides an intermediary dispatch mechanism for Tkinter menu items, specifically checkbox variables. It ensures the handler has full control over the UI variable's state by reverting automatic toggles."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "run_in_terminal", "line_number": 8, "body": "def run_in_terminal(cmd, cwd, env_overrides={}, keep_open=True, title=None):\n    from thonny.running import get_environment_with_overrides\n\n    env = get_environment_with_overrides(env_overrides)\n\n    if not cwd or not os.path.exists(cwd):\n        cwd = os.getcwd()\n\n    if platform.system() == \"Windows\":\n        _run_in_terminal_in_windows(cmd, cwd, env, keep_open, title)\n    elif platform.system() == \"Linux\":\n        _run_in_terminal_in_linux(cmd, cwd, env, keep_open)\n    elif platform.system() == \"Darwin\":\n        _run_in_terminal_in_macos(cmd, cwd, env_overrides, keep_open)\n    else:\n        raise RuntimeError(\"Can't launch terminal in \" + platform.system())", "is_method": false, "function_description": "Provides a cross-platform capability to execute a command within a new terminal window. It allows specifying the working directory, environment variables, and whether the terminal remains open."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "open_system_shell", "line_number": 26, "body": "def open_system_shell(cwd, env_overrides={}):\n    from thonny.running import get_environment_with_overrides\n\n    env = get_environment_with_overrides(env_overrides)\n\n    if platform.system() == \"Darwin\":\n        _run_in_terminal_in_macos([], cwd, env_overrides, True)\n    elif platform.system() == \"Windows\":\n        cmd = \"start cmd\"\n        subprocess.Popen(cmd, cwd=cwd, env=env, shell=True)\n    elif platform.system() == \"Linux\":\n        cmd = _get_linux_terminal_command()\n        subprocess.Popen(cmd, cwd=cwd, env=env, shell=True)\n    else:\n        raise RuntimeError(\"Can't launch terminal in \" + platform.system())", "is_method": false, "function_description": "Opens a new system shell or terminal window specific to the operating system. It launches a command prompt, allowing specification of the current working directory and environment variables."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_add_to_path", "line_number": 43, "body": "def _add_to_path(directory, path):\n    # Always prepending to path may seem better, but this could mess up other things.\n    # If the directory contains only one Python distribution executables, then\n    # it probably won't be in path yet and therefore will be prepended.\n    if (\n        directory in path.split(os.pathsep)\n        or platform.system() == \"Windows\"\n        and directory.lower() in path.lower().split(os.pathsep)\n    ):\n        return path\n    else:\n        return directory + os.pathsep + path", "is_method": false, "function_description": "This helper function adds a specified directory to the beginning of a given path string. It ensures the directory is only added if it's not already present, preventing duplicates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_run_in_terminal_in_windows", "line_number": 57, "body": "def _run_in_terminal_in_windows(cmd, cwd, env, keep_open, title=None):\n    if keep_open:\n        # Yes, the /K argument has weird quoting. Can't explain this, but it works\n        quoted_args = \" \".join(map(lambda s: s if s == \"&\" else '\"' + s + '\"', cmd))\n        cmd_line = \"\"\"start {title} /D \"{cwd}\" /W cmd /K \"{quoted_args}\" \"\"\".format(\n            cwd=cwd, quoted_args=quoted_args, title='\"' + title + '\"' if title else \"\"\n        )\n\n        subprocess.Popen(cmd_line, cwd=cwd, env=env, shell=True)\n    else:\n        subprocess.Popen(cmd, creationflags=subprocess.CREATE_NEW_CONSOLE, cwd=cwd, env=env)", "is_method": false, "function_description": "This function executes a specified command in a new terminal window on Windows. It provides the option to keep the terminal open after the command finishes or close it automatically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_run_in_terminal_in_linux", "line_number": 70, "body": "def _run_in_terminal_in_linux(cmd, cwd, env, keep_open):\n    def _shellquote(s):\n        return subprocess.list2cmdline([s])\n\n    term_cmd = _get_linux_terminal_command()\n\n    if isinstance(cmd, list):\n        cmd = \" \".join(map(_shellquote, cmd))\n\n    if keep_open:\n        # http://stackoverflow.com/a/4466566/261181\n        core_cmd = \"{cmd}; exec bash -i\".format(cmd=cmd)\n        in_term_cmd = \"bash -c {core_cmd}\".format(core_cmd=_shellquote(core_cmd))\n    else:\n        in_term_cmd = cmd\n\n    if term_cmd == \"lxterminal\":\n        # https://www.raspberrypi.org/forums/viewtopic.php?t=221490\n        whole_cmd = \"{term_cmd} --command={in_term_cmd}\".format(\n            term_cmd=term_cmd, in_term_cmd=_shellquote(in_term_cmd)\n        )\n    else:\n        whole_cmd = \"{term_cmd} -e {in_term_cmd}\".format(\n            term_cmd=term_cmd, in_term_cmd=_shellquote(in_term_cmd)\n        )\n\n    if term_cmd == \"terminator\" and \"PYTHONPATH\" in env:\n        # it is written in Python 2 and the PYTHONPATH of Python 3 will confuse it\n        # https://github.com/thonny/thonny/issues/1129\n        del env[\"PYTHONPATH\"]\n\n    subprocess.Popen(whole_cmd, cwd=cwd, env=env, shell=True)", "is_method": false, "function_description": "Executes a given command in a new Linux terminal window. It configures the command's environment and allows the terminal to remain open afterwards."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_run_in_terminal_in_macos", "line_number": 104, "body": "def _run_in_terminal_in_macos(cmd, cwd, env_overrides, keep_open):\n    _shellquote = shlex.quote\n\n    cmds = \"clear; cd \" + _shellquote(cwd)\n    # osascript \"tell application\" won't change Terminal's env\n    # (at least when Terminal is already active)\n    # At the moment I just explicitly set some important variables\n    for key in env_overrides:\n        if env_overrides[key] is None:\n            cmds += \"; unset \" + key\n        else:\n            value = env_overrides[key]\n            if key == \"PATH\":\n                value = _normalize_path(value)\n\n            cmds += \"; export {key}={value}\".format(key=key, value=_shellquote(value))\n\n    if cmd:\n        if isinstance(cmd, list):\n            cmd = \" \".join(map(_shellquote, cmd))\n        cmds += \"; \" + cmd\n\n    if not keep_open:\n        cmds += \"; exit\"\n\n    # try to shorten to avoid too long line https://github.com/thonny/thonny/issues/1529\n\n    common_prefix = os.path.normpath(sys.prefix).rstrip(\"/\")\n    cmds = (\n        \"export THOPR=\" + common_prefix + \" ; \" + cmds.replace(common_prefix + \"/\", \"$THOPR\" + \"/\")\n    )\n    print(cmds)\n\n    # The script will be sent to Terminal with 'do script' command, which takes a string.\n    # We'll prepare an AppleScript string literal for this\n    # (http://stackoverflow.com/questions/10667800/using-quotes-in-a-applescript-string):\n    cmd_as_apple_script_string_literal = (\n        '\"' + cmds.replace(\"\\\\\", \"\\\\\\\\\").replace('\"', '\\\\\"').replace(\"$\", \"\\\\$\") + '\"'\n    )\n\n    # When Terminal is not open, then do script opens two windows.\n    # do script ... in window 1 would solve this, but if Terminal is already\n    # open, this could run the script in existing terminal (in undesirable env on situation)\n    # That's why I need to prepare two variations of the 'do script' command\n    doScriptCmd1 = \"\"\"        do script %s \"\"\" % cmd_as_apple_script_string_literal\n    doScriptCmd2 = \"\"\"        do script %s in window 1 \"\"\" % cmd_as_apple_script_string_literal\n\n    # The whole AppleScript will be executed with osascript by giving script\n    # lines as arguments. The lines containing our script need to be shell-quoted:\n    quotedCmd1 = subprocess.list2cmdline([doScriptCmd1])\n    quotedCmd2 = subprocess.list2cmdline([doScriptCmd2])\n\n    # Now we can finally assemble the osascript command line\n    cmd_line = (\n        \"osascript\"\n        + \"\"\" -e 'if application \"Terminal\" is running then ' \"\"\"\n        + \"\"\" -e '    tell application \"Terminal\"           ' \"\"\"\n        + \"\"\" -e \"\"\"\n        + quotedCmd1\n        + \"\"\" -e '        activate                          ' \"\"\"\n        + \"\"\" -e '    end tell                              ' \"\"\"\n        + \"\"\" -e 'else                                      ' \"\"\"\n        + \"\"\" -e '    tell application \"Terminal\"           ' \"\"\"\n        + \"\"\" -e \"\"\"\n        + quotedCmd2\n        + \"\"\" -e '        activate                          ' \"\"\"\n        + \"\"\" -e '    end tell                              ' \"\"\"\n        + \"\"\" -e 'end if                                    ' \"\"\"\n    )\n\n    subprocess.Popen(cmd_line, cwd=cwd, shell=True)", "is_method": false, "function_description": "Enables running a command in a new or existing macOS Terminal window. It configures the working directory and environment variables, with an option to keep the terminal open."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_get_linux_terminal_command", "line_number": 177, "body": "def _get_linux_terminal_command():\n    import shutil\n\n    xte = shutil.which(\"x-terminal-emulator\")\n    if xte:\n        if os.path.realpath(xte).endswith(\"/lxterminal\") and shutil.which(\"lxterminal\"):\n            # need to know exact program, because it needs special treatment\n            return \"lxterminal\"\n        elif os.path.realpath(xte).endswith(\"/terminator\") and shutil.which(\"terminator\"):\n            # https://github.com/thonny/thonny/issues/1129\n            return \"terminator\"\n        else:\n            return \"x-terminal-emulator\"\n    # Older konsole didn't pass on the environment\n    elif shutil.which(\"konsole\"):\n        if (\n            shutil.which(\"gnome-terminal\")\n            and \"gnome\" in os.environ.get(\"DESKTOP_SESSION\", \"\").lower()\n        ):\n            return \"gnome-terminal\"\n        else:\n            return \"konsole\"\n    elif shutil.which(\"gnome-terminal\"):\n        return \"gnome-terminal\"\n    elif shutil.which(\"xfce4-terminal\"):\n        return \"xfce4-terminal\"\n    elif shutil.which(\"lxterminal\"):\n        return \"lxterminal\"\n    elif shutil.which(\"xterm\"):\n        return \"xterm\"\n    else:\n        raise RuntimeError(\"Don't know how to open terminal emulator\")", "is_method": false, "function_description": "Identifies and returns the command name for a suitable graphical terminal emulator found on a Linux system. This allows other functions to launch a terminal program."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_normalize_path", "line_number": 211, "body": "def _normalize_path(s):\n    parts = s.split(os.pathsep)\n    return os.pathsep.join([os.path.normpath(part) for part in parts])", "is_method": false, "function_description": "Normalizes a string that may contain multiple paths separated by `os.pathsep`. It ensures each individual path component is properly formatted by resolving redundancies."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/terminal.py", "function": "_shellquote", "line_number": 71, "body": "def _shellquote(s):\n        return subprocess.list2cmdline([s])", "is_method": false, "function_description": "Quotes a string, making it safe to use as a single argument within a shell command. This prevents issues with special characters."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_ends_with_incomplete_ansi_code", "line_number": 1164, "body": "def _ends_with_incomplete_ansi_code(data):\n    pos = data.rfind(\"\\033\")\n    if pos == -1:\n        return False\n\n    # note ANSI_CODE_TERMINATOR also includes [\n    params_and_terminator = data[pos + 2 :]\n    return not ANSI_CODE_TERMINATOR.search(params_and_terminator)", "is_method": false, "function_description": "Determines if the provided data string terminates with an unclosed ANSI escape sequence, aiding robust terminal output processing and handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_bundled_python", "line_number": 1174, "body": "def is_bundled_python(executable):\n    return os.path.exists(os.path.join(os.path.dirname(executable), \"thonny_python.ini\"))", "is_method": false, "function_description": "Checks if a given Python executable is part of a Thonny bundled distribution. This helps identify if the environment is a custom, portable Thonny setup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "create_backend_python_process", "line_number": 1178, "body": "def create_backend_python_process(\n    args, stdin=None, stdout=subprocess.PIPE, stderr=subprocess.STDOUT\n):\n    \"\"\"Used for running helper commands (eg. pip) on CPython backend.\n    Assumes current backend is CPython.\"\"\"\n\n    # TODO: if backend == frontend, then delegate to create_frontend_python_process\n\n    python_exe = get_runner().get_local_executable()\n\n    env = get_environment_for_python_subprocess(python_exe)\n    env[\"PYTHONIOENCODING\"] = \"utf-8\"\n    env[\"PYTHONUNBUFFERED\"] = \"1\"\n\n    # TODO: remove frontend python from path and add backend python to it\n\n    return _create_python_process(python_exe, args, stdin, stdout, stderr, env=env)", "is_method": false, "function_description": "Creates and runs a new Python process specifically for the CPython backend environment. This service is used to execute helper commands like `pip`, ensuring the correct Python interpreter and environment variables are utilized."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "create_frontend_python_process", "line_number": 1197, "body": "def create_frontend_python_process(\n    args, stdin=None, stdout=subprocess.PIPE, stderr=subprocess.STDOUT\n):\n    \"\"\"Used for running helper commands (eg. for installing plug-ins on by the plug-ins)\"\"\"\n    if _console_allocated:\n        python_exe = get_interpreter_for_subprocess().replace(\"pythonw.exe\", \"python.exe\")\n    else:\n        python_exe = get_interpreter_for_subprocess().replace(\"python.exe\", \"pythonw.exe\")\n    env = get_environment_for_python_subprocess(python_exe)\n    env[\"PYTHONIOENCODING\"] = \"utf-8\"\n    env[\"PYTHONUNBUFFERED\"] = \"1\"\n    return _create_python_process(python_exe, args, stdin, stdout, stderr)", "is_method": false, "function_description": "Launches a configured Python subprocess for running helper commands, such as plugin installations. It selects the appropriate Python executable and sets specific environment variables."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_create_python_process", "line_number": 1211, "body": "def _create_python_process(\n    python_exe,\n    args,\n    stdin=None,\n    stdout=subprocess.PIPE,\n    stderr=subprocess.STDOUT,\n    shell=False,\n    env=None,\n    universal_newlines=True,\n):\n\n    cmd = [python_exe] + args\n\n    if running_on_windows():\n        creationflags = subprocess.CREATE_NEW_PROCESS_GROUP\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n    else:\n        startupinfo = None\n        creationflags = 0\n\n    proc = subprocess.Popen(\n        cmd,\n        stdin=stdin,\n        stdout=stdout,\n        stderr=stderr,\n        shell=shell,\n        env=env,\n        universal_newlines=universal_newlines,\n        startupinfo=startupinfo,\n        creationflags=creationflags,\n    )\n\n    proc.cmd = cmd\n    return proc", "is_method": false, "function_description": "Creates and starts a new Python interpreter process, enabling the execution of Python scripts or commands as an independent subprocess with configurable I/O."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_environment_for_python_subprocess", "line_number": 1269, "body": "def get_environment_for_python_subprocess(target_executable):\n    overrides = get_environment_overrides_for_python_subprocess(target_executable)\n    return get_environment_with_overrides(overrides)", "is_method": false, "function_description": "Provides a complete environment dictionary for launching a Python subprocess. It incorporates specific overrides based on the target executable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_environment_with_overrides", "line_number": 1274, "body": "def get_environment_with_overrides(overrides):\n    env = os.environ.copy()\n    for key in overrides:\n        if overrides[key] is None and key in env:\n            del env[key]\n        else:\n            assert isinstance(overrides[key], str)\n            if key.upper() == \"PATH\":\n                update_system_path(env, overrides[key])\n            else:\n                env[key] = overrides[key]\n    return env", "is_method": false, "function_description": "Provides a customized environment dictionary. It applies specified overrides to the current process's environment, adding, updating, or removing variables for specific operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_environment_overrides_for_python_subprocess", "line_number": 1288, "body": "def get_environment_overrides_for_python_subprocess(target_executable):\n    \"\"\"Take care of not not confusing different interpreter\n    with variables meant for bundled interpreter\"\"\"\n\n    # At the moment I'm tweaking the environment only if current\n    # exe is bundled for Thonny.\n    # In remaining cases it is user's responsibility to avoid\n    # calling Thonny with environment which may be confusing for\n    # different Pythons called in a subprocess.\n\n    this_executable = sys.executable.replace(\"pythonw.exe\", \"python.exe\")\n    target_executable = target_executable.replace(\"pythonw.exe\", \"python.exe\")\n\n    interpreter_specific_keys = [\n        \"TCL_LIBRARY\",\n        \"TK_LIBRARY\",\n        \"LD_LIBRARY_PATH\",\n        \"DYLD_LIBRARY_PATH\",\n        \"SSL_CERT_DIR\",\n        \"SSL_CERT_FILE\",\n        \"PYTHONHOME\",\n        \"PYTHONPATH\",\n        \"PYTHONNOUSERSITE\",\n        \"PYTHONUSERBASE\",\n    ]\n\n    result = {}\n\n    if os.path.samefile(\n        target_executable, this_executable\n    ) or is_venv_interpreter_of_current_interpreter(target_executable):\n        # bring out some important variables so that they can\n        # be explicitly set in macOS Terminal\n        # (If they are set then it's most likely because current exe is in Thonny bundle)\n        for key in interpreter_specific_keys:\n            if key in os.environ:\n                result[key] = os.environ[key]\n\n        # never pass some variables to different interpreter\n        # (even if it's venv or symlink to current one)\n        if not is_same_path(target_executable, this_executable):\n            for key in [\"PYTHONPATH\", \"PYTHONHOME\", \"PYTHONNOUSERSITE\", \"PYTHONUSERBASE\"]:\n                if key in os.environ:\n                    result[key] = None\n    else:\n        # interpreters are not related\n        # interpreter specific keys most likely would confuse other interpreter\n        for key in interpreter_specific_keys:\n            if key in os.environ:\n                result[key] = None\n\n    # some keys should be never passed\n    for key in [\n        \"PYTHONSTARTUP\",\n        \"PYTHONBREAKPOINT\",\n        \"PYTHONDEBUG\",\n        \"PYTHONNOUSERSITE\",\n        \"PYTHONASYNCIODEBUG\",\n    ]:\n        if key in os.environ:\n            result[key] = None\n\n    # venv may not find (correct) Tk without assistance (eg. in Ubuntu)\n    if is_venv_interpreter_of_current_interpreter(target_executable):\n        try:\n            if \"TCL_LIBRARY\" not in os.environ or \"TK_LIBRARY\" not in os.environ:\n                result[\"TCL_LIBRARY\"] = get_workbench().tk.exprstring(\"$tcl_library\")\n                result[\"TK_LIBRARY\"] = get_workbench().tk.exprstring(\"$tk_library\")\n        except Exception:\n            logging.exception(\"Can't compute Tcl/Tk library location\")\n\n    return result", "is_method": false, "function_description": "Prepares a tailored set of environment variables for a Python subprocess. It ensures that interpreter-specific settings from the current environment do not confuse the target executable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "construct_cd_command", "line_number": 1362, "body": "def construct_cd_command(path) -> str:\n    return construct_cmd_line([\"%cd\", path])", "is_method": false, "function_description": "Constructs a command-line string to change the current directory to the specified path. Useful for programmatically generating shell navigation commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "generate_command_id", "line_number": 1369, "body": "def generate_command_id():\n    global _command_id_counter\n    _command_id_counter += 1\n    return \"cmd_\" + str(_command_id_counter)", "is_method": false, "function_description": "Provides unique, incrementing string IDs for commands. This function helps identify and track individual command executions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_frontend_python", "line_number": 1473, "body": "def get_frontend_python():\n    # TODO: deprecated (name can be misleading)\n    warnings.warn(\"get_frontend_python is deprecated\")\n    return get_interpreter_for_subprocess(sys.executable)", "is_method": false, "function_description": "Provides the path to the current Python interpreter suitable for launching subprocesses. This function is deprecated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_interpreter_for_subprocess", "line_number": 1479, "body": "def get_interpreter_for_subprocess(candidate=None):\n    if candidate is None:\n        candidate = sys.executable\n\n    pythonw = candidate.replace(\"python.exe\", \"pythonw.exe\")\n    if not _console_allocated and os.path.exists(pythonw):\n        return pythonw\n    else:\n        return candidate.replace(\"pythonw.exe\", \"python.exe\")", "is_method": false, "function_description": "Determines the suitable Python interpreter path for a subprocess. It selects between console (`python.exe`) and windowed (`pythonw.exe`) executables based on console allocation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_remove_obsolete_jedi_copies", "line_number": 98, "body": "def _remove_obsolete_jedi_copies(self) -> None:\n        # Thonny 2.1 used to copy jedi in order to make it available\n        # for the backend. Get rid of it now\n        for item in os.listdir(THONNY_USER_DIR):\n            if item.startswith(\"jedi_0.\"):\n                import shutil\n\n                shutil.rmtree(os.path.join(THONNY_USER_DIR, item), True)", "is_method": true, "class_name": "Runner", "function_description": "This method cleans up the user's directory by removing outdated copies of the Jedi library. It addresses a legacy issue from Thonny 2.1 to maintain a clean environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "start", "line_number": 107, "body": "def start(self) -> None:\n        global _console_allocated\n        try:\n            self._check_alloc_console()\n            _console_allocated = True\n        except Exception:\n            logger.exception(\"Problem allocating console\")\n            _console_allocated = False\n\n        self.restart_backend(False, True)\n        # temporary\n        self._remove_obsolete_jedi_copies()", "is_method": true, "class_name": "Runner", "function_description": "Initializes the Runner's operational environment. It attempts console allocation, restarts the backend component, and performs necessary internal cleanup tasks to prepare for operation.\nInitializes the Runner's operational environment. It attempts console allocation, restarts the backend component, and performs necessary internal cleanup tasks to prepare for operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_init_commands", "line_number": 120, "body": "def _init_commands(self) -> None:\n        global RUN_COMMAND_CAPTION, RUN_COMMAND_LABEL\n\n        RUN_COMMAND_LABEL = tr(\"Run current script\")\n        RUN_COMMAND_CAPTION = tr(\"Run\")\n\n        get_workbench().set_default(\"run.run_in_terminal_python_repl\", False)\n        get_workbench().set_default(\"run.run_in_terminal_keep_open\", True)\n\n        try:\n            import thonny.plugins.debugger  # @UnusedImport\n\n            debugger_available = True\n        except ImportError:\n            debugger_available = False\n\n        get_workbench().add_command(\n            \"run_current_script\",\n            \"run\",\n            RUN_COMMAND_LABEL,\n            caption=RUN_COMMAND_CAPTION,\n            handler=self.cmd_run_current_script,\n            default_sequence=\"<F5>\",\n            extra_sequences=[select_sequence(\"<Control-r>\", \"<Command-r>\")],\n            tester=self.cmd_run_current_script_enabled,\n            group=10,\n            image=\"run-current-script\",\n            include_in_toolbar=not (get_workbench().in_simple_mode() and debugger_available),\n            show_extra_sequences=True,\n        )\n\n        get_workbench().add_command(\n            \"run_current_script_in_terminal\",\n            \"run\",\n            tr(\"Run current script in terminal\"),\n            caption=\"RunT\",\n            handler=self._cmd_run_current_script_in_terminal,\n            default_sequence=\"<Control-t>\",\n            extra_sequences=[\"<<CtrlTInText>>\"],\n            tester=self._cmd_run_current_script_in_terminal_enabled,\n            group=35,\n            image=\"terminal\",\n        )\n\n        get_workbench().add_command(\n            \"restart\",\n            \"run\",\n            tr(\"Stop/Restart backend\"),\n            caption=tr(\"Stop\"),\n            handler=self.cmd_stop_restart,\n            default_sequence=\"<Control-F2>\",\n            group=100,\n            image=\"stop\",\n            include_in_toolbar=True,\n        )\n\n        get_workbench().add_command(\n            \"interrupt\",\n            \"run\",\n            tr(\"Interrupt execution\"),\n            handler=self._cmd_interrupt,\n            tester=self._cmd_interrupt_enabled,\n            default_sequence=INTERRUPT_SEQUENCE,\n            skip_sequence_binding=True,  # Sequence will be bound differently\n            group=100,\n            bell_when_denied=False,\n        )\n        get_workbench().bind(INTERRUPT_SEQUENCE, self._cmd_interrupt_with_shortcut, True)\n\n        get_workbench().add_command(\n            \"ctrld\",\n            \"run\",\n            tr(\"Send EOF / Soft reboot\"),\n            self.ctrld,\n            self.ctrld_enabled,\n            group=100,\n            default_sequence=\"<Control-d>\",\n            extra_sequences=[\"<<CtrlDInText>>\"],\n        )\n\n        get_workbench().add_command(\n            \"disconnect\",\n            \"run\",\n            tr(\"Disconnect\"),\n            self.disconnect,\n            self.disconnect_enabled,\n            group=100,\n        )", "is_method": true, "class_name": "Runner", "function_description": "Registers a comprehensive suite of commands for running, stopping, and managing script execution within the application's workbench, configuring default settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_state", "line_number": 209, "body": "def get_state(self) -> str:\n        \"\"\"State is one of \"running\", \"waiting_debugger_command\", \"waiting_toplevel_command\" \"\"\"\n        return self._state", "is_method": true, "class_name": "Runner", "function_description": "Retrieves the current operational state of the Runner instance. This indicates whether it is running, waiting for debugger commands, or waiting for top-level commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_set_state", "line_number": 213, "body": "def _set_state(self, state: str) -> None:\n        if self._state != state:\n            logging.debug(\"Runner state changed: %s ==> %s\" % (self._state, state))\n            self._state = state", "is_method": true, "class_name": "Runner", "function_description": "Updates the Runner's internal state, logging the change if different. It's used to manage the runner's operational phases."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_running", "line_number": 218, "body": "def is_running(self):\n        return self._state == \"running\"", "is_method": true, "class_name": "Runner", "function_description": "This method reports if the Runner object is currently active. It provides a boolean status to determine if the runner is executing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_waiting", "line_number": 221, "body": "def is_waiting(self):\n        return self._state.startswith(\"waiting\")", "is_method": true, "class_name": "Runner", "function_description": "Provides a status check to determine if the Runner is currently in any 'waiting' state, indicating it is paused or awaiting input."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_waiting_toplevel_command", "line_number": 224, "body": "def is_waiting_toplevel_command(self):\n        return self._state == \"waiting_toplevel_command\"", "is_method": true, "class_name": "Runner", "function_description": "Indicates if the Runner instance is currently waiting for a top-level command, providing a status check for external interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_waiting_debugger_command", "line_number": 227, "body": "def is_waiting_debugger_command(self):\n        return self._state == \"waiting_debugger_command\"", "is_method": true, "class_name": "Runner", "function_description": "Indicates if the Runner is currently paused, awaiting a debugger command. This informs other components of its interactive state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_sys_path", "line_number": 230, "body": "def get_sys_path(self) -> List[str]:\n        return self._proxy.get_sys_path()", "is_method": true, "class_name": "Runner", "function_description": "This method retrieves the Python system path from an internal proxy object, likely for configuring or inspecting the execution environment managed by the Runner."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_command", "line_number": 233, "body": "def send_command(self, cmd: CommandToBackend) -> None:\n        if self._proxy is None:\n            return\n\n        if self._publishing_events:\n            # allow all event handlers to complete before sending the commands\n            # issued by first event handlers\n            self._postpone_command(cmd)\n            return\n\n        # First sanity check\n        if (\n            isinstance(cmd, ToplevelCommand)\n            and not self.is_waiting_toplevel_command()\n            and cmd.name not in [\"Reset\", \"Run\", \"Debug\"]\n            or isinstance(cmd, DebuggerCommand)\n            and not self.is_waiting_debugger_command()\n        ):\n            get_workbench().bell()\n            logging.warning(\n                \"RUNNER: Command %s was attempted at state %s\" % (cmd, self.get_state())\n            )\n            return\n\n        # Attach extra info\n        if \"debug\" in cmd.name.lower():\n            cmd[\"breakpoints\"] = get_current_breakpoints()\n\n        if \"id\" not in cmd:\n            cmd[\"id\"] = generate_command_id()\n\n        cmd[\"local_cwd\"] = get_workbench().get_local_cwd()\n\n        # Offer the command\n        logging.debug(\"RUNNER Sending: %s, %s\", cmd.name, cmd)\n        response = self._proxy.send_command(cmd)\n\n        if response == \"discard\":\n            return None\n        elif response == \"postpone\":\n            self._postpone_command(cmd)\n            return\n        else:\n            assert response is None\n            get_workbench().event_generate(\"CommandAccepted\", command=cmd)\n\n        if isinstance(cmd, (ToplevelCommand, DebuggerCommand)):\n            self._set_state(\"running\")\n\n        if cmd.name[0].isupper():\n            # This may be only logical restart, which does not look like restart to the runner\n            get_workbench().event_generate(\"BackendRestart\", full=False)", "is_method": true, "class_name": "Runner", "function_description": "Dispatches various commands from the Runner to the backend, handling state-based validation and enriching commands with context. It ensures appropriate command delivery and status updates to the system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_command_and_wait", "line_number": 286, "body": "def send_command_and_wait(self, cmd: CommandToBackend, dialog_title: str) -> MessageFromBackend:\n        dlg = InlineCommandDialog(get_workbench(), cmd, title=dialog_title + \" ...\")\n        show_dialog(dlg)\n        return dlg.response", "is_method": true, "class_name": "Runner", "function_description": "Sends a command to the backend, displays a progress dialog to the user, and waits synchronously for the backend's response. It facilitates interactive command execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_postpone_command", "line_number": 291, "body": "def _postpone_command(self, cmd: CommandToBackend) -> None:\n        # in case of InlineCommands, discard older same type command\n        if isinstance(cmd, InlineCommand):\n            for older_cmd in self._postponed_commands:\n                if older_cmd.name == cmd.name:\n                    self._postponed_commands.remove(older_cmd)\n\n        if len(self._postponed_commands) > 10:\n            logging.warning(\"Can't pile up too many commands. This command will be just ignored\")\n        else:\n            self._postponed_commands.append(cmd)", "is_method": true, "class_name": "Runner", "function_description": "This method queues commands for later processing, discarding older inline commands of the same type. It also enforces a maximum limit on the number of commands that can be postponed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_send_postponed_commands", "line_number": 303, "body": "def _send_postponed_commands(self) -> None:\n        todo = self._postponed_commands\n        self._postponed_commands = []\n\n        for cmd in todo:\n            logging.debug(\"Sending postponed command: %s\", cmd)\n            self.send_command(cmd)", "is_method": true, "class_name": "Runner", "function_description": "Processes and dispatches all commands that were previously postponed. This ensures deferred operations are finally sent via the runner's command sending mechanism."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_program_input", "line_number": 311, "body": "def send_program_input(self, data: str) -> None:\n        assert self.is_running()\n        self._proxy.send_program_input(data)", "is_method": true, "class_name": "Runner", "function_description": "This method provides a way to send string input directly to the external program currently managed by the Runner instance. It ensures the program is active before delivering the data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "execute_script", "line_number": 315, "body": "def execute_script(\n        self,\n        script_path: str,\n        args: List[str],\n        working_directory: Optional[str] = None,\n        command_name: str = \"Run\",\n    ) -> None:\n\n        if self._proxy.get_cwd() != working_directory:\n            # create compound command\n            # start with %cd\n            cd_cmd_line = construct_cd_command(working_directory) + \"\\n\"\n        else:\n            # create simple command\n            cd_cmd_line = \"\"\n\n        rel_filename = universal_relpath(script_path, working_directory)\n        cmd_parts = [\"%\" + command_name, rel_filename] + args\n        exe_cmd_line = construct_cmd_line(cmd_parts, [EDITOR_CONTENT_TOKEN]) + \"\\n\"\n\n        # submit to shell (shell will execute it)\n        get_shell().submit_magic_command(cd_cmd_line + exe_cmd_line)", "is_method": true, "class_name": "Runner", "function_description": "The Runner class's `execute_script` method provides the capability to run a script at a specified path. It manages the script's execution context, including its working directory and command-line arguments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "execute_editor_content", "line_number": 338, "body": "def execute_editor_content(self, command_name, args):\n        get_shell().submit_magic_command(\n            construct_cmd_line(\n                [\"%\" + command_name, \"-c\", EDITOR_CONTENT_TOKEN] + args, [EDITOR_CONTENT_TOKEN]\n            )\n        )", "is_method": true, "class_name": "Runner", "function_description": "Enables executing shell magic commands with content from the editor. It provides a way to process editor content directly within an interactive session."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "execute_current", "line_number": 345, "body": "def execute_current(self, command_name: str) -> None:\n        \"\"\"\n        This method's job is to create a command for running/debugging\n        current file/script and submit it to shell\n        \"\"\"\n\n        if not self.is_waiting_toplevel_command():\n            self.restart_backend(True, False, 2)\n\n        filename = get_saved_current_script_filename()\n\n        if not filename:\n            # user has cancelled file saving\n            return\n\n        if (\n            is_remote_path(filename)\n            and not self._proxy.can_run_remote_files()\n            or is_local_path(filename)\n            and not self._proxy.can_run_local_files()\n        ):\n            self.execute_editor_content(command_name, self._get_active_arguments())\n        else:\n            if get_workbench().get_option(\"run.auto_cd\") and command_name[0].isupper():\n                working_directory = get_target_dirname_from_editor_filename(filename)\n            else:\n                working_directory = self._proxy.get_cwd()\n\n            if is_local_path(filename):\n                target_path = filename\n            else:\n                target_path = extract_target_path(filename)\n            self.execute_script(\n                target_path, self._get_active_arguments(), working_directory, command_name\n            )", "is_method": true, "class_name": "Runner", "function_description": "The Runner class uses this method to execute or debug the currently active script or file. It prepares the necessary command and submits it to the shell, handling local and remote file paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_get_active_arguments", "line_number": 381, "body": "def _get_active_arguments(self):\n        if get_workbench().get_option(\"view.show_program_arguments\"):\n            args_str = get_workbench().get_option(\"run.program_arguments\")\n            get_workbench().log_program_arguments_string(args_str)\n            return shlex.split(args_str)\n        else:\n            return []", "is_method": true, "class_name": "Runner", "function_description": "Retrieves and parses the active program arguments from workbench settings, if configured to show them. It prepares arguments for program execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "cmd_run_current_script_enabled", "line_number": 389, "body": "def cmd_run_current_script_enabled(self) -> bool:\n        return (\n            get_workbench().get_editor_notebook().get_current_editor() is not None\n            and \"run\" in get_runner().get_supported_features()\n        )", "is_method": true, "class_name": "Runner", "function_description": "Checks if the 'run current script' command should be enabled. It verifies an active editor and if the runner supports script execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_cmd_run_current_script_in_terminal_enabled", "line_number": 395, "body": "def _cmd_run_current_script_in_terminal_enabled(self) -> bool:\n        return (\n            self._proxy\n            and \"run_in_terminal\" in self._proxy.get_supported_features()\n            and self.cmd_run_current_script_enabled()\n        )", "is_method": true, "class_name": "Runner", "function_description": "Determines if running the current script within a terminal is supported and currently enabled, based on proxy capabilities and general script execution status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "cmd_run_current_script", "line_number": 402, "body": "def cmd_run_current_script(self) -> None:\n        if get_workbench().in_simple_mode():\n            get_workbench().hide_view(\"VariablesView\")\n        self.execute_current(\"Run\")", "is_method": true, "class_name": "Runner", "function_description": "Initiates the execution of the script currently active within the development environment, managing UI visibility as needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_cmd_run_current_script_in_terminal", "line_number": 407, "body": "def _cmd_run_current_script_in_terminal(self) -> None:\n        filename = get_saved_current_script_filename()\n        if not filename:\n            return\n\n        self._proxy.run_script_in_terminal(\n            filename,\n            self._get_active_arguments(),\n            get_workbench().get_option(\"run.run_in_terminal_python_repl\"),\n            get_workbench().get_option(\"run.run_in_terminal_keep_open\"),\n        )", "is_method": true, "class_name": "Runner", "function_description": "Provides a command to run the currently active Python script. It executes the script in an external terminal, passing current arguments and user-defined options via a proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_cmd_interrupt", "line_number": 419, "body": "def _cmd_interrupt(self) -> None:\n        if self._proxy is not None:\n            if _console_allocated:\n                self._proxy.interrupt()\n            else:\n                messagebox.showerror(\n                    \"No console\",\n                    \"Can't interrupt as console was not allocated.\\n\\nUse Stop/Restart instead.\",\n                    master=self,\n                )\n        else:\n            logging.warning(\"User tried interrupting without proxy\")", "is_method": true, "class_name": "Runner", "function_description": "Provides a command to interrupt an active process managed by the Runner's proxy. It informs the user if interruption fails due to console allocation issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_cmd_interrupt_with_shortcut", "line_number": 432, "body": "def _cmd_interrupt_with_shortcut(self, event=None):\n        if not self._cmd_interrupt_enabled():\n            return None\n\n        if not running_on_mac_os():  # on Mac Ctrl+C is not used for Copy.\n            # Disable Ctrl+C interrupt in editor and shell, when some text is selected\n            # (assuming user intended to copy instead of interrupting)\n            widget = get_workbench().focus_get()\n            if isinstance(widget, tk.Text):\n                if len(widget.tag_ranges(\"sel\")) > 0:\n                    # this test is reliable, unlike selection_get below\n                    return None\n            elif isinstance(widget, (tk.Listbox, ttk.Entry, tk.Entry, tk.Spinbox)):\n                try:\n                    selection = widget.selection_get()\n                    if isinstance(selection, str) and len(selection) > 0:\n                        # Assuming user meant to copy, not interrupt\n                        # (IDLE seems to follow same logic)\n\n                        # NB! This is not perfect, as in Linux the selection can be in another app\n                        # ie. there may be no selection in Thonny actually.\n                        # In other words, Ctrl+C interrupt may be dropped without reason\n                        # when given inside the widgets listed above.\n                        return None\n                except Exception:\n                    # widget either doesn't have selection_get or it\n                    # gave error (can happen without selection on Ubuntu)\n                    pass\n\n        self._cmd_interrupt()\n        return \"break\"", "is_method": true, "class_name": "Runner", "function_description": "Provides conditional command interruption, typically via a keyboard shortcut. It intelligently avoids interrupting when text is selected in a GUI, preventing accidental copy operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_cmd_interrupt_enabled", "line_number": 464, "body": "def _cmd_interrupt_enabled(self) -> bool:\n        return self._proxy and self._proxy.is_connected()", "is_method": true, "class_name": "Runner", "function_description": "Checks if an external command can be interrupted through an active proxy connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "cmd_stop_restart", "line_number": 467, "body": "def cmd_stop_restart(self) -> None:\n        if get_workbench().in_simple_mode():\n            get_workbench().hide_view(\"VariablesView\")\n\n        self.restart_backend(True)", "is_method": true, "class_name": "Runner", "function_description": "Provides a command to stop and restart the application's backend. It hides the VariablesView when operating in simple mode."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "disconnect", "line_number": 473, "body": "def disconnect(self):\n        proxy = self.get_backend_proxy()\n        assert hasattr(proxy, \"disconnect\")\n        proxy.disconnect()", "is_method": true, "class_name": "Runner", "function_description": "Disconnects the Runner from its associated backend system, releasing resources or terminating the connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "disconnect_enabled", "line_number": 478, "body": "def disconnect_enabled(self):\n        return hasattr(self.get_backend_proxy(), \"disconnect\")", "is_method": true, "class_name": "Runner", "function_description": "This method checks if the Runner's backend proxy provides a 'disconnect' capability. It indicates whether disconnection functionality is supported and can be invoked."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "ctrld", "line_number": 481, "body": "def ctrld(self):\n        proxy = self.get_backend_proxy()\n        if not proxy:\n            return\n\n        if get_shell().has_pending_input():\n            messagebox.showerror(\n                \"Can't perform this action\",\n                \"Ctrl+D only has effect on an empty line / prompt.\\n\"\n                + \"Submit current input (press ENTER) and try again\",\n                master=self,\n            )\n            return\n\n        proxy.send_command(EOFCommand())\n        self._set_state(\"running\")", "is_method": true, "class_name": "Runner", "function_description": "Sends an End-of-File (Ctrl+D) command to the backend, but only when no input is pending. This allows signaling termination to the running process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "ctrld_enabled", "line_number": 498, "body": "def ctrld_enabled(self):\n        proxy = self.get_backend_proxy()\n        return proxy and proxy.is_connected()", "is_method": true, "class_name": "Runner", "function_description": "Verifies if the `ctrld` service is enabled and actively connected. It provides a status indicating if the backend proxy is operational."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_poll_backend_messages", "line_number": 502, "body": "def _poll_backend_messages(self) -> None:\n        \"\"\"I chose polling instead of event_generate in listener thread,\n        because event_generate across threads is not reliable\n        http://www.thecodingforums.com/threads/more-on-tk-event_generate-and-threads.359615/\n        \"\"\"\n        self._polling_after_id = None\n        if self._pull_backend_messages() is False:\n            return\n\n        self._polling_after_id = get_workbench().after(20, self._poll_backend_messages)", "is_method": true, "class_name": "Runner", "function_description": "Establishes and maintains a continuous polling mechanism for retrieving and processing messages from a backend. This ensures the application remains responsive and synchronized with backend updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_pull_backend_messages", "line_number": 513, "body": "def _pull_backend_messages(self):\n        # Don't process too many messages in single batch, allow screen updates\n        # and user actions between batches.\n        # Mostly relevant when backend prints a lot quickly.\n        msg_count = 0\n        max_msg_count = 10\n        while self._proxy is not None and msg_count < max_msg_count:\n            try:\n                msg = self._proxy.fetch_next_message()\n                if not msg:\n                    break\n                logging.debug(\n                    \"RUNNER GOT: %s, %s in state: %s\", msg.event_type, msg, self.get_state()\n                )\n\n                msg_count += 1\n            except BackendTerminatedError as exc:\n                self._report_backend_crash(exc)\n                self.destroy_backend()\n                return False\n\n            if msg.get(\"SystemExit\", False):\n                self.restart_backend(True)\n                return False\n\n            # change state\n            if isinstance(msg, ToplevelResponse):\n                self._set_state(\"waiting_toplevel_command\")\n            elif isinstance(msg, DebuggerResponse):\n                self._set_state(\"waiting_debugger_command\")\n            else:\n                \"other messages don't affect the state\"\n\n            # Publish the event\n            # NB! This may cause another command to be sent before we get to postponed commands.\n            try:\n                self._publishing_events = True\n                class_event_type = type(msg).__name__\n                get_workbench().event_generate(class_event_type, event=msg)  # more general event\n                if msg.event_type != class_event_type:\n                    # more specific event\n                    get_workbench().event_generate(msg.event_type, event=msg)\n            finally:\n                self._publishing_events = False\n\n            # TODO: is it necessary???\n            # https://stackoverflow.com/a/13520271/261181\n            # get_workbench().update()\n\n        self._send_postponed_commands()", "is_method": true, "class_name": "Runner", "function_description": "This method retrieves and processes messages from a backend process in batches. It updates the Runner's internal state, publishes received messages as events, and handles backend termination or restarts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_report_backend_crash", "line_number": 564, "body": "def _report_backend_crash(self, exc: Exception) -> None:\n        returncode = getattr(exc, \"returncode\", \"?\")\n        err = \"Backend terminated or disconnected.\"\n\n        try:\n            faults_file = os.path.join(THONNY_USER_DIR, \"backend_faults.log\")\n            if os.path.exists(faults_file):\n                with open(faults_file, encoding=\"ASCII\") as fp:\n                    err += fp.read()\n        except Exception:\n            logging.exception(\"Failed retrieving backend faults\")\n\n        err = err.strip() + \" Use 'Stop/Restart' to restart.\\n\"\n\n        if returncode != EXPECTED_TERMINATION_CODE:\n            get_workbench().event_generate(\"ProgramOutput\", stream_name=\"stderr\", data=\"\\n\" + err)\n\n        get_workbench().become_active_window(False)", "is_method": true, "class_name": "Runner", "function_description": "Reports a backend crash to the user by displaying an error message and appending diagnostic details from a log file. It then activates the application window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "restart_backend", "line_number": 583, "body": "def restart_backend(self, clean: bool, first: bool = False, wait: float = 0) -> None:\n        \"\"\"Recreate (or replace) backend proxy / backend process.\"\"\"\n\n        if not first:\n            get_shell().restart()\n            get_shell().update_idletasks()\n\n        self.destroy_backend()\n        backend_name = get_workbench().get_option(\"run.backend_name\")\n        if backend_name not in get_workbench().get_backends():\n            raise UserError(\n                \"Can't find backend '{}'. Please select another backend from options\".format(\n                    backend_name\n                )\n            )\n\n        backend_class = get_workbench().get_backends()[backend_name].proxy_class\n        self._set_state(\"running\")\n        self._proxy = None\n        self._proxy = backend_class(clean)\n\n        self._poll_backend_messages()\n\n        if wait:\n            start_time = time.time()\n            while not self.is_waiting_toplevel_command() and time.time() - start_time <= wait:\n                # self._pull_backend_messages()\n                get_workbench().update()\n                sleep(0.01)\n\n        get_workbench().event_generate(\"BackendRestart\", full=True)", "is_method": true, "class_name": "Runner", "function_description": "Provides the service to fully reinitialize the application's core backend process. It destroys the existing backend, then creates and connects a new configured one, with an option to wait for readiness."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "destroy_backend", "line_number": 615, "body": "def destroy_backend(self) -> None:\n        if self._polling_after_id is not None:\n            get_workbench().after_cancel(self._polling_after_id)\n            self._polling_after_id = None\n\n        self._postponed_commands = []\n        if self._proxy:\n            self._proxy.destroy()\n            self._proxy = None\n\n        get_workbench().event_generate(\"BackendTerminated\")", "is_method": true, "class_name": "Runner", "function_description": "Provides a clean shutdown for the Runner's backend by canceling scheduled tasks, clearing commands, and destroying its internal proxy object. It signals the backend's termination."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_local_executable", "line_number": 627, "body": "def get_local_executable(self) -> Optional[str]:\n        if self._proxy is None:\n            return None\n        else:\n            return self._proxy.get_local_executable()", "is_method": true, "class_name": "Runner", "function_description": "Retrieves the file path for a locally available executable. This allows the Runner to locate the program it needs to execute.\nRetrieves the file path for a locally available executable. This allows the Runner to locate the program it needs to execute."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_backend_proxy", "line_number": 633, "body": "def get_backend_proxy(self) -> \"BackendProxy\":\n        return self._proxy", "is_method": true, "class_name": "Runner", "function_description": "Provides access to the `BackendProxy` object that the `Runner` uses to interact with its backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_check_alloc_console", "line_number": 636, "body": "def _check_alloc_console(self) -> None:\n        if sys.executable.endswith(\"pythonw.exe\"):\n            # These don't have console allocated.\n            # Console is required for sending interrupts.\n\n            # AllocConsole would be easier but flashes console window\n\n            import ctypes\n\n            kernel32 = ctypes.WinDLL(\"kernel32\", use_last_error=True)\n\n            exe = sys.executable.replace(\"pythonw.exe\", \"python.exe\")\n\n            cmd = [exe, \"-c\", \"print('Hi!'); input()\"]\n            child = subprocess.Popen(\n                cmd,\n                stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                shell=True,\n            )\n            child.stdout.readline()\n            result = kernel32.AttachConsole(child.pid)\n            if not result:\n                err = ctypes.get_last_error()\n                logging.info(\"Could not allocate console. Error code: \" + str(err))\n            child.stdin.write(b\"\\n\")\n            try:\n                child.stdin.flush()\n            except Exception:\n                # May happen eg. when installation path has \"&\" in it\n                # See https://bitbucket.org/plas/thonny/issues/508/cant-allocate-windows-console-when\n                # Without flush the console window becomes visible, but Thonny can be still used\n                logger.exception(\"Problem with finalizing console allocation\")", "is_method": true, "class_name": "Runner", "function_description": "This method attempts to attach a hidden console to `pythonw.exe` processes. This enables proper handling of interrupt signals, such as keyboard interrupts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "ready_for_remote_file_operations", "line_number": 671, "body": "def ready_for_remote_file_operations(self, show_message=False):\n        if not self._proxy or not self.supports_remote_files():\n            return False\n\n        ready = self._proxy.ready_for_remote_file_operations()\n\n        if not ready and show_message:\n            if not self._proxy.is_connected():\n                msg = \"Device is not connected\"\n            else:\n                msg = (\n                    \"Device is busy -- can't perform this action now.\"\n                    + \"\\nPlease wait or cancel current work and try again!\"\n                )\n            messagebox.showerror(\"Can't complete\", msg, master=get_workbench())\n\n        return ready", "is_method": true, "class_name": "Runner", "function_description": "Checks if the runner's remote device or connection is ready for file operations, optionally displaying an error message if not."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_supported_features", "line_number": 689, "body": "def get_supported_features(self) -> Set[str]:\n        if self._proxy is None:\n            return set()\n        else:\n            return self._proxy.get_supported_features()", "is_method": true, "class_name": "Runner", "function_description": "This method identifies and returns the set of features supported by the Runner's underlying proxy. It provides an empty set if no proxy is configured."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "supports_remote_files", "line_number": 695, "body": "def supports_remote_files(self):\n        if self._proxy is None:\n            return False\n        else:\n            return self._proxy.supports_remote_files()", "is_method": true, "class_name": "Runner", "function_description": "Indicates if the Runner instance's underlying system supports operations with remote files. This capability check helps determine if remote file access is possible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "supports_remote_directories", "line_number": 701, "body": "def supports_remote_directories(self):\n        if self._proxy is None:\n            return False\n        else:\n            return self._proxy.supports_remote_directories()", "is_method": true, "class_name": "Runner", "function_description": "Indicates whether the Runner, via its internal proxy, supports operations involving remote directories. Essential for determining remote file system interaction capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_node_label", "line_number": 707, "body": "def get_node_label(self):\n        if self._proxy is None:\n            return \"Back-end\"\n        else:\n            return self._proxy.get_node_label()", "is_method": true, "class_name": "Runner", "function_description": "Retrieves a descriptive label for the Runner's node. It returns 'Back-end' for direct operation or defers to an active proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "using_venv", "line_number": 713, "body": "def using_venv(self) -> bool:\n        from thonny.plugins.cpython import CPythonProxy\n\n        return isinstance(self._proxy, CPythonProxy) and self._proxy._in_venv", "is_method": true, "class_name": "Runner", "function_description": "Checks if the Python environment managed by this Runner is a virtual environment, indicating if the interpreter is running within a venv."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_backend_name", "line_number": 756, "body": "def get_backend_name(self):\n        return type(self).backend_name", "is_method": true, "class_name": "BackendProxy", "function_description": "Provides the name of the specific backend implementation managed by this `BackendProxy` instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "destroy", "line_number": 766, "body": "def destroy(self):\n        \"\"\"Called when Thonny no longer needs this instance\n        (Thonny gets closed or new backend gets selected)\n        \"\"\"\n        pass", "is_method": true, "class_name": "BackendProxy", "function_description": "Provides a lifecycle hook for the BackendProxy to perform cleanup operations when Thonny no longer requires its instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_supported_features", "line_number": 779, "body": "def get_supported_features(self):\n        return {\"run\"}", "is_method": true, "class_name": "BackendProxy", "function_description": "This BackendProxy method identifies the specific features the backend supports, explicitly listing 'run' as its only current capability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_node_label", "line_number": 782, "body": "def get_node_label(self):\n        \"\"\"Used as files caption if back-end has separate files\"\"\"\n        return \"Back-end\"", "is_method": true, "class_name": "BackendProxy", "function_description": "Provides a fixed label \"Back-end\" for display purposes. This method identifies backend-related files or sections within a user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_full_label", "line_number": 786, "body": "def get_full_label(self):\n        \"\"\"Used in pip GUI title\"\"\"\n        return self.get_node_label()", "is_method": true, "class_name": "BackendProxy", "function_description": "Returns a descriptive label primarily used for the pip GUI window title, by invoking the node's label method."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "supports_remote_files", "line_number": 790, "body": "def supports_remote_files(self):\n        \"\"\"Whether remote file browser should be presented with this back-end\"\"\"\n        return False", "is_method": true, "class_name": "BackendProxy", "function_description": "Reports whether the backend associated with this proxy supports remote file browsing. This implementation explicitly indicates it does not."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "uses_local_filesystem", "line_number": 794, "body": "def uses_local_filesystem(self):\n        \"\"\"Whether it runs code from local files\"\"\"\n        return True", "is_method": true, "class_name": "BackendProxy", "function_description": "This method indicates that the BackendProxy interacts with the local filesystem. It signals whether the backend requires access to local files for its operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "supports_remote_directories", "line_number": 798, "body": "def supports_remote_directories(self):\n        return False", "is_method": true, "class_name": "BackendProxy", "function_description": "This method indicates whether the backend service, accessed via this proxy, supports operations involving remote directories. It explicitly states that this proxy does not support them."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "supports_trash", "line_number": 801, "body": "def supports_trash(self):\n        return True", "is_method": true, "class_name": "BackendProxy", "function_description": "This method indicates that the underlying backend system provides support for 'trash' or 'recycle bin' operations. It serves as a capability flag for clients."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_clean_description", "line_number": 816, "body": "def get_clean_description(self):\n        return self.backend_description", "is_method": true, "class_name": "BackendProxy", "function_description": "Retrieves the clean description of the specific backend represented by this proxy. This provides essential information about the proxied system.\nRetrieves the clean description of the specific backend represented by this proxy. This provides essential information about the proxied system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_current_switcher_configuration", "line_number": 820, "body": "def get_current_switcher_configuration(cls):\n        \"\"\"returns the dict of configuration entries that distinguish current backend conf from other\n        items in the backend switcher\"\"\"\n        return {\"run.backend_name\": cls.backend_name}", "is_method": true, "class_name": "BackendProxy", "function_description": "Provides a dictionary identifying the current backend's unique configuration. It distinguishes the active backend by its name for use in a backend switching system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_switcher_entries", "line_number": 826, "body": "def get_switcher_entries(cls):\n        \"\"\"\n        Each returned entry creates one item in the backend switcher menu.\n        \"\"\"\n        return [(cls.get_current_switcher_configuration(), cls.backend_description)]", "is_method": true, "class_name": "BackendProxy", "function_description": "This class method provides entries for a backend switcher menu. It returns the current switcher configuration and description, enabling dynamic backend selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "has_custom_system_shell", "line_number": 832, "body": "def has_custom_system_shell(self):\n        return False", "is_method": true, "class_name": "BackendProxy", "function_description": "Indicates whether the associated backend uses a custom system shell. This method currently reports that no custom shell is in use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_get_environment", "line_number": 871, "body": "def _get_environment(self):\n        env = get_environment_for_python_subprocess(self._executable)\n        # variables controlling communication with the back-end process\n        env[\"PYTHONIOENCODING\"] = \"utf-8\"\n\n        # because cmd line option -u won't reach child processes\n        # see https://github.com/thonny/thonny/issues/808\n        env[\"PYTHONUNBUFFERED\"] = \"1\"\n\n        # Let back-end know about plug-ins\n        env[\"THONNY_USER_DIR\"] = THONNY_USER_DIR\n        env[\"THONNY_FRONTEND_SYS_PATH\"] = repr(sys.path)\n\n        env[\"THONNY_LANGUAGE\"] = get_workbench().get_option(\"general.language\")\n\n        if thonny.in_debug_mode():\n            env[\"THONNY_DEBUG\"] = \"1\"\n        elif \"THONNY_DEBUG\" in env:\n            del env[\"THONNY_DEBUG\"]\n        return env", "is_method": true, "class_name": "SubprocessProxy", "function_description": "This method constructs and returns a dictionary of environment variables for a Python subprocess. It configures standard Python settings and injects Thonny-specific variables for backend communication and setup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_start_background_process", "line_number": 892, "body": "def _start_background_process(self, clean=None, extra_args=[]):\n        # deque, because in one occasion I need to put messages back\n        self._response_queue = collections.deque()\n\n        if not os.path.exists(self._executable):\n            raise UserError(\n                \"Interpreter (%s) not found. Please recheck corresponding option!\"\n                % self._executable\n            )\n\n        cmd_line = (\n            [\n                self._executable,\n                \"-u\",  # unbuffered IO\n                \"-B\",  # don't write pyo/pyc files\n                # (to avoid problems when using different Python versions without write permissions)\n            ]\n            + self._get_launcher_with_args()\n            + extra_args\n        )\n\n        creationflags = 0\n        if running_on_windows():\n            creationflags = subprocess.CREATE_NEW_PROCESS_GROUP\n\n        debug(\"Starting the backend: %s %s\", cmd_line, get_workbench().get_local_cwd())\n\n        extra_params = {}\n        if sys.version_info >= (3, 6):\n            extra_params[\"encoding\"] = \"utf-8\"\n\n        self._proc = subprocess.Popen(\n            cmd_line,\n            bufsize=0,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            cwd=self._get_launch_cwd(),\n            env=self._get_environment(),\n            universal_newlines=True,\n            creationflags=creationflags,\n            **extra_params\n        )\n\n        # setup asynchronous output listeners\n        self._terminated_readers = 0\n        Thread(target=self._listen_stdout, args=(self._proc.stdout,), daemon=True).start()\n        Thread(target=self._listen_stderr, args=(self._proc.stderr,), daemon=True).start()", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Launches an external executable as a background process, setting up its I/O and environment. It then establishes asynchronous listeners to capture stdout and stderr for ongoing monitoring."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_get_launch_cwd", "line_number": 941, "body": "def _get_launch_cwd(self):\n        return self.get_cwd() if self.uses_local_filesystem() else None", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Determines the appropriate current working directory for launching a subprocess. It returns the local CWD if a local filesystem is used, otherwise None."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_command", "line_number": 947, "body": "def send_command(self, cmd: CommandToBackend) -> Optional[str]:\n        \"\"\"Send the command to backend. Return None, 'discard' or 'postpone'\"\"\"\n        if isinstance(cmd, ToplevelCommand) and cmd.name[0].isupper():\n            self._clear_environment()\n\n        if isinstance(cmd, ToplevelCommand):\n            # required by SshCPythonBackend for creating fresh target process\n            cmd[\"expected_cwd\"] = self._cwd\n\n        method_name = \"_cmd_\" + cmd.name\n\n        if hasattr(self, method_name):\n            getattr(self, method_name)(cmd)\n        else:\n            self._send_msg(cmd)", "is_method": true, "class_name": "SubprocessProxy", "function_description": "This method dispatches commands to a backend process. It performs command-specific pre-processing and delegates handling to internal methods or a generic message sender."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_send_msg", "line_number": 963, "body": "def _send_msg(self, msg):\n        self._proc.stdin.write(serialize_message(msg) + \"\\n\")\n        self._proc.stdin.flush()", "is_method": true, "class_name": "SubprocessProxy", "function_description": "This internal method sends a serialized message to the standard input of the managed subprocess. It ensures the message is immediately written to the subprocess's input stream."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_program_input", "line_number": 970, "body": "def send_program_input(self, data):\n        self._send_msg(InputSubmission(data))", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Sends the provided data as input to the program managed by the subprocess proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "process_is_alive", "line_number": 973, "body": "def process_is_alive(self):\n        return self._proc is not None and self._proc.poll() is None", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Determines if the managed subprocess is currently active and has not yet terminated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_terminated", "line_number": 976, "body": "def is_terminated(self):\n        return not self.process_is_alive()", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Reports whether the managed subprocess has terminated. This method provides a simple status check for its lifecycle."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "is_connected", "line_number": 979, "body": "def is_connected(self):\n        return self.process_is_alive()", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Checks if the managed subprocess is currently alive. This determines if the proxy can still interact with the external process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_sys_path", "line_number": 982, "body": "def get_sys_path(self):\n        return self._sys_path", "is_method": true, "class_name": "SubprocessProxy", "function_description": "This method retrieves the system path configured for the subprocess managed by this proxy, making it available for external use or introspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "destroy", "line_number": 985, "body": "def destroy(self):\n        self._close_backend()", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Terminates and cleans up the underlying subprocess managed by this proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_close_backend", "line_number": 988, "body": "def _close_backend(self):\n        if self._proc is not None and self._proc.poll() is None:\n            self._proc.kill()\n\n        self._proc = None\n        self._response_queue = None", "is_method": true, "class_name": "SubprocessProxy", "function_description": "The `_close_backend` method safely terminates the managed subprocess if active. It cleans up the process object and response queue, ensuring resource release."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_listen_stdout", "line_number": 995, "body": "def _listen_stdout(self, stdout):\n        # debug(\"... started listening to stdout\")\n        # will be called from separate thread\n\n        # allow self._response_queue to be replaced while processing\n        message_queue = self._response_queue\n\n        def publish_as_msg(data):\n            msg = parse_message(data)\n            if \"cwd\" in msg:\n                self.cwd = msg[\"cwd\"]\n            message_queue.append(msg)\n\n            if len(message_queue) > 10:\n                # Probably backend runs an infinite/long print loop.\n                # Throttle message throughput in order to keep GUI thread responsive.\n                while len(message_queue) > 0:\n                    sleep(0.005)\n\n        while True:\n            try:\n                data = stdout.readline()\n            except IOError:\n                sleep(0.1)\n                continue\n\n            # debug(\"... read some stdout data\", repr(data))\n            if data == \"\":\n                break\n            else:\n                try:\n                    publish_as_msg(data)\n                except Exception:\n                    # Can mean the line was from subprocess,\n                    # which can't be captured by stream faking.\n                    # NB! If subprocess printed it without linebreak,\n                    # then the suffix can be thonny message\n\n                    parts = data.rsplit(common.MESSAGE_MARKER, maxsplit=1)\n\n                    # print first part as it is\n                    message_queue.append(\n                        BackendEvent(\"ProgramOutput\", data=parts[0], stream_name=\"stdout\")\n                    )\n\n                    if len(parts) == 2:\n                        second_part = common.MESSAGE_MARKER + parts[1]\n                        try:\n                            publish_as_msg(second_part)\n                        except Exception:\n                            # just print ...\n                            message_queue.append(\n                                BackendEvent(\n                                    \"ProgramOutput\", data=second_part, stream_name=\"stdout\"\n                                )\n                            )\n\n        self._terminated_readers += 1", "is_method": true, "class_name": "SubprocessProxy", "function_description": "This internal method continuously monitors a subprocess's standard output. It parses structured messages and raw output, queuing them for the main application while throttling to ensure responsiveness."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_listen_stderr", "line_number": 1054, "body": "def _listen_stderr(self, stderr):\n        # stderr is used only for debugger debugging\n        while True:\n            data = stderr.readline()\n            if data == \"\":\n                break\n            else:\n                self._response_queue.append(\n                    BackendEvent(\"ProgramOutput\", stream_name=\"stderr\", data=data)\n                )\n\n        self._terminated_readers += 1", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Continuously reads standard error output from a subprocess. It queues each line as a `BackendEvent` for the application to process real-time error messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_store_state_info", "line_number": 1067, "body": "def _store_state_info(self, msg):\n        if \"cwd\" in msg:\n            self._cwd = msg[\"cwd\"]\n            self._publish_cwd(msg[\"cwd\"])\n\n        if msg.get(\"welcome_text\"):\n            self._welcome_text = msg[\"welcome_text\"]\n\n        if \"in_venv\" in msg:\n            self._in_venv = msg[\"in_venv\"]\n\n        if \"sys_path\" in msg:\n            self._sys_path = msg[\"sys_path\"]\n\n        if \"usersitepackages\" in msg:\n            self._usersitepackages = msg[\"usersitepackages\"]\n\n        if \"prefix\" in msg:\n            self._sys_prefix = msg[\"prefix\"]\n\n        if \"exe_dirs\" in msg:\n            self._exe_dirs = msg[\"exe_dirs\"]\n\n        if msg.get(\"executable\"):\n            self._reported_executable = msg[\"executable\"]", "is_method": true, "class_name": "SubprocessProxy", "function_description": "This method updates the internal state of the SubprocessProxy with environment details received from the proxied subprocess, such as CWD, virtual environment status, and system paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_publish_cwd", "line_number": 1093, "body": "def _publish_cwd(self, cwd):\n        if self.uses_local_filesystem():\n            get_workbench().set_local_cwd(cwd)", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Synchronizes the workbench's local current working directory with the subprocess's CWD when the subprocess proxy operates on a local filesystem."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_supported_features", "line_number": 1097, "body": "def get_supported_features(self):\n        return {\"run\"}", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Indicates the specific operations supported by the SubprocessProxy. It currently reports that only the 'run' operation is available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_site_packages", "line_number": 1100, "body": "def get_site_packages(self):\n        # NB! site.sitepackages may not be present in virtualenv\n        for d in self._sys_path:\n            if (\"site-packages\" in d or \"dist-packages\" in d) and path_startswith(\n                d, self._sys_prefix\n            ):\n                return d\n\n        return None", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Retrieves the `site-packages` or `dist-packages` directory for the subprocess's Python environment. This enables locating where installed third-party packages are stored."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_user_site_packages", "line_number": 1110, "body": "def get_user_site_packages(self):\n        return self._usersitepackages", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Provides access to the user-specific Python `site-packages` directories. This information is valuable for managing or configuring Python environments for subprocesses."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_cwd", "line_number": 1113, "body": "def get_cwd(self):\n        return self._cwd", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Retrieves the current working directory used by the subprocess managed by this proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_exe_dirs", "line_number": 1116, "body": "def get_exe_dirs(self):\n        return self._exe_dirs", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Provides the list of directories where executable files are searched. This allows other components to determine the execution environment for subprocesses."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "fetch_next_message", "line_number": 1119, "body": "def fetch_next_message(self):\n        if not self._response_queue or len(self._response_queue) == 0:\n            if self.is_terminated() and self._terminated_readers == 2:\n                raise BackendTerminatedError(self._proc.returncode if self._proc else None)\n            else:\n                return None\n\n        msg = self._response_queue.popleft()\n        self._store_state_info(msg)\n        if msg.event_type == \"ProgramOutput\":\n            # combine available small output messages to one single message,\n            # in order to put less pressure on UI code\n\n            wait_time = 0.01\n            total_wait_time = 0\n            while True:\n                if len(self._response_queue) == 0:\n                    if _ends_with_incomplete_ansi_code(msg[\"data\"]) and total_wait_time < 0.1:\n                        # Allow reader to send the remaining part\n                        sleep(wait_time)\n                        total_wait_time += wait_time\n                        continue\n                    else:\n                        return msg\n                else:\n                    next_msg = self._response_queue.popleft()\n                    if (\n                        next_msg.event_type == \"ProgramOutput\"\n                        and next_msg[\"stream_name\"] == msg[\"stream_name\"]\n                        and (\n                            len(msg[\"data\"]) + len(next_msg[\"data\"]) <= OUTPUT_MERGE_THRESHOLD\n                            and (\"\\n\" not in msg[\"data\"] or not io_animation_required)\n                            or _ends_with_incomplete_ansi_code(msg[\"data\"])\n                        )\n                    ):\n                        msg[\"data\"] += next_msg[\"data\"]\n                    else:\n                        # not to be sent in the same block, put it back\n                        self._response_queue.appendleft(next_msg)\n                        return msg\n\n        else:\n            return msg", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Retrieves the next message from the subprocess's response queue. It efficiently consolidates small, consecutive program output messages into a single larger message for better display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_title", "line_number": 1400, "body": "def get_title(self):\n        return self._title", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Retrieves the title associated with the inline command dialog instance. This allows for clear identification and display of the dialog's purpose."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "get_instructions", "line_number": 1403, "body": "def get_instructions(self) -> Optional[str]:\n        return self._instructions or self._cmd.get(\"description\", \"Working...\")", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Retrieves instructions or a descriptive message for the inline command dialog, providing helpful text to users."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_on_response", "line_number": 1406, "body": "def _on_response(self, response):\n        if response.get(\"command_id\") == getattr(self._cmd, \"id\"):\n            logger.debug(\"Dialog got response: %s\", response)\n            self.response = response\n            self.returncode = response.get(\"returncode\", None)\n            success = (\n                not self.returncode and not response.get(\"error\") and not response.get(\"errors\")\n            )\n            if success:\n                self.set_action_text(\"Done!\")\n            else:\n                self.set_action_text(\"Error\")\n                if response.get(\"error\"):\n                    self.append_text(\"Error %s\\n\" % response[\"error\"], stream_name=\"stderr\")\n                if response.get(\"errors\"):\n                    self.append_text(\"Errors %s\\n\" % response[\"errors\"], stream_name=\"stderr\")\n                if self.returncode:\n                    self.append_text(\n                        \"Process returned with code %s\\n\" % self.returncode, stream_name=\"stderr\"\n                    )\n\n            self.report_done(success)", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Receives and processes a command's response, updating the inline dialog's status and displaying completion or error messages to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_on_progress", "line_number": 1429, "body": "def _on_progress(self, msg):\n        if msg.get(\"command_id\") != getattr(self._cmd, \"id\"):\n            return\n\n        if msg.get(\"value\", None) is not None and msg.get(\"maximum\", None) is not None:\n            self.report_progress(msg[\"value\"], msg[\"maximum\"])\n        if msg.get(\"description\"):\n            self.set_action_text(msg[\"description\"])", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Processes messages from a running command to update the dialog's visual progress bar and status text, ensuring updates correspond to the active command."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "_on_output", "line_number": 1438, "body": "def _on_output(self, msg):\n        stream_name = msg.get(\"stream_name\", \"stdout\")\n        self.append_text(msg[\"data\"], stream_name)\n        self.set_action_text_smart(msg[\"data\"])", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "As a method of `InlineCommandDialog`, this function processes output messages from a command. It appends the message data to the dialog's text display and dynamically updates related action text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "start_work", "line_number": 1443, "body": "def start_work(self):\n        self.send_command_to_backend()", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Initiates the dialog's primary action by sending its command to the backend. It enables the dialog to execute its configured operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "send_command_to_backend", "line_number": 1446, "body": "def send_command_to_backend(self):\n        if not isinstance(self._cmd, CommandToBackend):\n            # it was a lazy definition\n            try:\n                self._cmd = self._cmd()\n            except Exception as e:\n                logger.error(\"Could not produce command for backend\", self._cmd)\n                self.set_action_text(\"Error!\")\n                self.append_text(\"Could not produce command for backend\\n\")\n                self.append_text(\"\".join(traceback.format_exc()) + \"\\n\")\n                self.report_done(False)\n                return\n\n        logger.debug(\"Starting command in dialog: %s\", self._cmd)\n        get_runner().send_command(self._cmd)", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "Sends a prepared command from the dialog to a backend runner for execution. It handles command initialization and reports any errors encountered during this process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "cancel_work", "line_number": 1462, "body": "def cancel_work(self):\n        super(InlineCommandDialog, self).cancel_work()\n        get_runner()._cmd_interrupt()", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "The method handles the cancellation of an active command or process. It extends the parent class's cancellation logic by specifically interrupting the command runner."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "close", "line_number": 1466, "body": "def close(self):\n        get_workbench().unbind(\"InlineResponse\", self._on_response)\n        get_workbench().unbind(\"InlineProgress\", self._on_progress)\n        super(InlineCommandDialog, self).close()\n        get_shell().set_ignore_program_output(False)", "is_method": true, "class_name": "InlineCommandDialog", "function_description": "This method closes the inline command dialog. It unbinds event listeners and restores the shell's program output behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/running.py", "function": "publish_as_msg", "line_number": 1002, "body": "def publish_as_msg(data):\n            msg = parse_message(data)\n            if \"cwd\" in msg:\n                self.cwd = msg[\"cwd\"]\n            message_queue.append(msg)\n\n            if len(message_queue) > 10:\n                # Probably backend runs an infinite/long print loop.\n                # Throttle message throughput in order to keep GUI thread responsive.\n                while len(message_queue) > 0:\n                    sleep(0.005)", "is_method": true, "class_name": "SubprocessProxy", "function_description": "Receives and queues messages from a subprocess, optionally updating its current working directory. It also throttles message throughput to prevent overwhelming the GUI thread."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "format_object_id", "line_number": 14, "body": "def format_object_id(object_id):\n    # this format aligns with how Python shows memory addresses\n    if object_id is None:\n        return None\n    else:\n        return \"0x\" + hex(object_id)[2:]", "is_method": false, "function_description": "Formats a numerical object identifier into a hexadecimal string, mimicking Python's memory address representation. This provides a consistent, readable format for displaying object IDs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "parse_object_id", "line_number": 22, "body": "def parse_object_id(object_id_repr):\n    return int(object_id_repr, base=16)", "is_method": false, "function_description": "Converts a hexadecimal string representation of an object ID into its integer equivalent. This is useful for processing IDs encoded in base-16 format."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "stop_debugging", "line_number": 34, "body": "def stop_debugging(self):\n        self._clear_tree()", "is_method": true, "class_name": "MemoryFrame", "function_description": "Terminates the debugging session by clearing the associated internal data or visual representation within the memory frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "show_selected_object_info", "line_number": 37, "body": "def show_selected_object_info(self):\n        object_id = self.get_object_id()\n        if object_id is not None:\n            get_workbench().event_generate(\"ObjectSelect\", object_id=object_id)", "is_method": true, "class_name": "MemoryFrame", "function_description": "Notifies the application's workbench about the currently selected object, enabling other components to respond to the selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "get_object_id", "line_number": 42, "body": "def get_object_id(self):\n        iid = self.tree.focus()\n        if iid != \"\":\n            # NB! Assuming id is second column!\n            id_str = self.tree.item(iid)[\"values\"][1]\n            if id_str in [\"\", None, \"None\"]:\n                return None\n\n            return parse_object_id(id_str)\n\n        return None", "is_method": true, "class_name": "MemoryFrame", "function_description": "Provides the object ID for the currently focused item in the memory view. It parses the ID from a specific column, returning None if no item is selected or the ID is invalid."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "destroy", "line_number": 76, "body": "def destroy(self):\n        MemoryFrame.destroy(self)\n        get_workbench().unbind(\"ShowView\", self._update_memory_model)\n        get_workbench().unbind(\"HideView\", self._update_memory_model)", "is_method": true, "class_name": "VariablesFrame", "function_description": "Safely destroys the `VariablesFrame` instance, performing necessary cleanup. It unbinds associated event handlers to prevent resource leaks and ensure proper termination."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "_update_memory_model", "line_number": 81, "body": "def _update_memory_model(self, event=None):\n        if get_workbench().in_heap_mode():\n            self.tree.configure(displaycolumns=(\"name\", \"id\"))\n            # self.tree.columnconfigure(1, weight=1, width=400)\n            # self.tree.columnconfigure(2, weight=0)\n        else:\n            self.tree.configure(displaycolumns=(\"name\", \"value\"))", "is_method": true, "class_name": "VariablesFrame", "function_description": "Dynamically adjusts how variables are displayed in the UI. It switches between showing variable names with IDs in heap mode or names with values in other modes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "update_variables", "line_number": 91, "body": "def update_variables(self, all_variables):\n        self._clear_tree()\n\n        if not all_variables:\n            return\n\n        if isinstance(all_variables, list):\n            groups = all_variables\n        else:\n            groups = [(\"\", all_variables)]\n\n        for group_title, variables in groups:\n            if group_title:\n                node_id = self.tree.insert(\"\", \"end\", tags=(\"group_title\",))\n                self.tree.set(node_id, \"name\", group_title)\n\n            for name in sorted(variables.keys()):\n\n                if not name.startswith(\"__\"):\n                    node_id = self.tree.insert(\"\", \"end\", tags=\"item\")\n                    self.tree.set(node_id, \"name\", name)\n                    if isinstance(variables[name], ValueInfo):\n                        description = variables[name].repr\n                        id_str = variables[name].id\n                    else:\n                        description = variables[name]\n                        id_str = None\n\n                    self.tree.set(node_id, \"id\", format_object_id(id_str))\n                    self.tree.set(node_id, \"value\", description)", "is_method": true, "class_name": "VariablesFrame", "function_description": "This method updates the `VariablesFrame`'s tree display with provided variables. It populates the view with variable names, values, and IDs, optionally grouped, while excluding internal variables."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/memory.py", "function": "on_select", "line_number": 122, "body": "def on_select(self, event):\n        self.show_selected_object_info()", "is_method": true, "class_name": "VariablesFrame", "function_description": "This method handles a selection event, triggering the display of detailed information about the currently selected object within the variables frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "get_text_font", "line_number": 1136, "body": "def get_text_font(text):\n    font = text[\"font\"]\n    if isinstance(font, str):\n        return tkfont.nametofont(font)\n    else:\n        return font", "is_method": false, "function_description": "Retrieves a usable font object from a text configuration. It converts font names to Tkinter font objects or returns pre-existing font objects directly for consistent use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "classifyws", "line_number": 1144, "body": "def classifyws(s, tabwidth):\n    raw = effective = 0\n    for ch in s:\n        if ch == \" \":\n            raw = raw + 1\n            effective = effective + 1\n        elif ch == \"\\t\":\n            raw = raw + 1\n            effective = (effective // tabwidth + 1) * tabwidth\n        else:\n            break\n    return raw, effective", "is_method": false, "function_description": "Calculates the raw character count and the effective visual width of leading whitespace in a string. It stops at the first non-whitespace character, handling tab expansion according to `tabwidth`."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "index2line", "line_number": 1158, "body": "def index2line(index):\n    return int(float(index))", "is_method": false, "function_description": "Normalizes a numeric index, potentially given as a string or float, into an integer. It is suitable for converting various numerical representations into precise line numbers.\nNormalizes a numeric index, potentially given as a string or float, into an integer. It is suitable for converting various numerical representations into precise line numbers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "fixwordbreaks", "line_number": 1166, "body": "def fixwordbreaks(root):\n    # Adapted from idlelib.EditorWindow (Python 3.4.2)\n    # Modified to include non-ascii chars\n\n    # Make sure that Tk's double-click and next/previous word\n    # operations use our definition of a word (i.e. an identifier)\n    root.tk.call(\"tcl_wordBreakAfter\", \"a b\", 0)  # make sure word.tcl is loaded\n    root.tk.call(\"set\", \"tcl_wordchars\", r\"\\w\")\n    root.tk.call(\"set\", \"tcl_nonwordchars\", r\"\\W\")", "is_method": false, "function_description": "Customizes Tkinter's internal definition of word boundaries for text operations. This ensures double-click selection and navigation correctly recognize words, including non-ASCII characters."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "rebind_control_a", "line_number": 1177, "body": "def rebind_control_a(root):\n    # Tk 8.6 has <<SelectAll>> event but 8.5 doesn't\n    # http://stackoverflow.com/questions/22907200/remap-default-keybinding-in-tkinter\n    def control_a(event):\n        widget = event.widget\n        if isinstance(widget, tk.Text):\n            widget.tag_remove(\"sel\", \"1.0\", \"end\")\n            widget.tag_add(\"sel\", \"1.0\", \"end\")\n\n    root.bind_class(\"Text\", \"<Control-a>\", control_a)", "is_method": false, "function_description": "Configures Tkinter text widgets to perform 'select all' when Control-A is pressed. This ensures consistent text selection behavior across Tkinter versions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_running_on_mac", "line_number": 1189, "body": "def _running_on_mac():\n    return tk._default_root.call(\"tk\", \"windowingsystem\") == \"aqua\"", "is_method": false, "function_description": "Determines if the current Python environment is executing on a macOS system, typically for platform-specific adaptations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_running_on_x11", "line_number": 1193, "body": "def _running_on_x11():\n    return tk._default_root.call(\"tk\", \"windowingsystem\") == \"x11\"", "is_method": false, "function_description": "Checks if the Tkinter graphical user interface is currently operating on an X11 windowing system. This helps in adapting GUI behavior for specific Linux/Unix environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "get_keyboard_language", "line_number": 1197, "body": "def get_keyboard_language():\n    # https://stackoverflow.com/a/42047820/261181\n    if platform.system() != \"Windows\":\n        raise NotImplementedError(\"Can provide keyboard language only on Windows\")\n\n    import ctypes\n\n    user32 = ctypes.WinDLL(\"user32\", use_last_error=True)\n    curr_window = user32.GetForegroundWindow()\n    thread_id = user32.GetWindowThreadProcessId(curr_window, 0)\n    # Made up of 0xAAABBBB, AAA = HKL (handle object) & BBBB = language ID\n    klid = user32.GetKeyboardLayout(thread_id)\n    # Language ID -> low 10 bits, Sub-language ID -> high 6 bits\n    # Extract language ID from KLID\n    lid = klid & (2 ** 16 - 1)\n\n    return lid", "is_method": false, "function_description": "Retrieves the language identifier of the active keyboard layout for the current foreground window on Windows systems. This provides the numerical language ID in use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_register_tk_proxy_function", "line_number": 33, "body": "def _register_tk_proxy_function(self, operation, function):\n        self._tk_proxies[operation] = function\n        setattr(self, operation, function)\n\n        def original_function(*args):\n            self.tk.call((self._original_widget_name, operation) + args)\n\n        return original_function", "is_method": true, "class_name": "TweakableText", "function_description": "Associates a Python function with a specific Tkinter widget operation, making it available as a method on the `TweakableText` instance. It also provides a callable to invoke the original Tkinter operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_dispatch_tk_operation", "line_number": 42, "body": "def _dispatch_tk_operation(self, operation, *args):\n        f = self._tk_proxies.get(operation)\n        try:\n            if f:\n                return f(*args)\n            else:\n                return self.tk.call((self._original_widget_name, operation) + args)\n\n        except TclError as e:\n            # Some Tk internal actions (eg. paste and cut) can cause this error\n            if (\n                str(e).lower() == '''text doesn't contain any characters tagged with \"sel\"'''\n                and operation in [\"delete\", \"index\", \"get\"]\n                and args in [(\"sel.first\", \"sel.last\"), (\"sel.first\",)]\n            ):\n                pass\n            # Don't worry about hitting ends of undo/redo stacks\n            elif (\n                operation == \"edit\"\n                and args in [(\"undo\",), (\"redo\",)]\n                and str(e).lower() == \"nothing to \" + args[0]\n            ):\n                pass\n            else:\n                exception(\n                    \"[_dispatch_tk_operation] operation: \" + operation + \", args:\" + repr(args)\n                )\n                # traceback.print_exc()\n\n            return \"\"", "is_method": true, "class_name": "TweakableText", "function_description": "This function dispatches and executes Tkinter operations for a `TweakableText` widget. It provides a robust interface by handling common Tkinter errors gracefully."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_read_only", "line_number": 73, "body": "def set_read_only(self, value):\n        self._read_only = value", "is_method": true, "class_name": "TweakableText", "function_description": "Sets the read-only status of the TweakableText object, enabling or disabling its modifiability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "is_read_only", "line_number": 76, "body": "def is_read_only(self):\n        return self._read_only", "is_method": true, "class_name": "TweakableText", "function_description": "Reports whether the `TweakableText` instance is configured as read-only, preventing further modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_content", "line_number": 79, "body": "def set_content(self, chars):\n        self.direct_delete(\"1.0\", tk.END)\n        self.direct_insert(\"1.0\", chars)", "is_method": true, "class_name": "TweakableText", "function_description": "Replaces the entire content of the TweakableText widget with the provided characters, effectively updating the displayed text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_insertwidth", "line_number": 83, "body": "def set_insertwidth(self, new_width):\n        \"\"\"Change cursor width\n\n        NB! Need to be careful with setting text[\"insertwidth\"]!\n        My first straightforward solution caused unexplainable\n        infinite loop of insertions and deletions in the text\n        (Repro: insert a line and a word, select that word and then do Ctrl-Z).\n\n        This solution seems safe but be careful!\n        \"\"\"\n        if self._suppress_events:\n            return\n\n        if self[\"insertwidth\"] != new_width:\n            old_suppress = self._suppress_events\n            try:\n                self._suppress_events = True\n                self.config(insertwidth=new_width)\n            finally:\n                self._suppress_events = old_suppress", "is_method": true, "class_name": "TweakableText", "function_description": "Sets the width of the text insertion cursor within the TweakableText component. This allows dynamic visual customization of the input cursor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "intercept_insert", "line_number": 107, "body": "def intercept_insert(self, index, chars, tags=None, **kw):\n        assert isinstance(chars, str)\n        if chars >= \"\\uf704\" and chars <= \"\\uf70d\":  # Function keys F1..F10 in Mac cause these\n            pass\n        elif self.is_read_only():\n            self.bell()\n        else:\n            self.direct_insert(index, chars, tags, **kw)", "is_method": true, "class_name": "TweakableText", "function_description": "Provides a controlled character insertion mechanism. It filters out specific control characters (like Mac function keys) and prevents modifications when the text is read-only."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "intercept_delete", "line_number": 116, "body": "def intercept_delete(self, index1, index2=None, **kw):\n        if index1 == \"sel.first\" and index2 == \"sel.last\" and not self.has_selection():\n            return\n\n        if self.is_read_only():\n            self.bell()\n        elif self._is_erroneous_delete(index1, index2):\n            pass\n        else:\n            self.direct_delete(index1, index2, **kw)", "is_method": true, "class_name": "TweakableText", "function_description": "Intercepts text deletion requests to validate their legitimacy. It prevents deletion for read-only text, erroneous operations, or when deleting a non-existent selection, otherwise proceeding."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_is_erroneous_delete", "line_number": 127, "body": "def _is_erroneous_delete(self, index1, index2):\n        \"\"\"Paste can cause deletes where index1 is sel.start but text has no selection. This would cause errors\"\"\"\n        return index1.startswith(\"sel.\") and not self.has_selection()", "is_method": true, "class_name": "TweakableText", "function_description": "Determines if a text deletion operation is erroneous because it references a non-existent selection. It ensures data integrity during text modifications within the TweakableText object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "direct_mark", "line_number": 131, "body": "def direct_mark(self, *args):\n        self._original_mark(*args)\n\n        if args[:2] == (\"set\", \"insert\") and not self._suppress_events:\n            self.event_generate(\"<<CursorMove>>\")", "is_method": true, "class_name": "TweakableText", "function_description": "Executes a text mark operation. If the operation sets the insertion point and events are not suppressed, it triggers a cursor movement event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "index_sel_first", "line_number": 137, "body": "def index_sel_first(self):\n        # Tk will give error without this check\n        if self.tag_ranges(\"sel\"):\n            return self.index(\"sel.first\")\n        else:\n            return None", "is_method": true, "class_name": "TweakableText", "function_description": "Retrieves the starting index of the current text selection in the widget. Returns None if no text is selected."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "index_sel_last", "line_number": 144, "body": "def index_sel_last(self):\n        if self.tag_ranges(\"sel\"):\n            return self.index(\"sel.last\")\n        else:\n            return None", "is_method": true, "class_name": "TweakableText", "function_description": "This method retrieves the index of the last character of the current text selection within the `TweakableText` object. It returns None if no selection is active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "has_selection", "line_number": 150, "body": "def has_selection(self):\n        return len(self.tag_ranges(\"sel\")) > 0", "is_method": true, "class_name": "TweakableText", "function_description": "Determines if an active text selection exists within the `TweakableText` object, useful for managing UI states or applying operations to selected text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "get_selection_indices", "line_number": 153, "body": "def get_selection_indices(self):\n        # If a selection is defined in the text widget, return (start,\n        # end) as Tkinter text indices, otherwise return (None, None)\n        if self.has_selection():\n            return self.index(\"sel.first\"), self.index(\"sel.last\")\n        else:\n            return None, None", "is_method": true, "class_name": "TweakableText", "function_description": "Returns the start and end indices of the current text selection within the widget. This provides positional data useful for operations on user-highlighted text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "direct_insert", "line_number": 161, "body": "def direct_insert(self, index, chars, tags=None, **kw):\n        self._original_insert(index, chars, tags, **kw)\n        if not self._suppress_events:\n            self.event_generate(\"<<TextChange>>\")", "is_method": true, "class_name": "TweakableText", "function_description": "Inserts characters directly into the text content at a specified index. It then notifies observers by generating a text change event unless suppressed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "direct_delete", "line_number": 166, "body": "def direct_delete(self, index1, index2=None, **kw):\n        self._original_delete(index1, index2, **kw)\n        if not self._suppress_events:\n            self.event_generate(\"<<TextChange>>\")", "is_method": true, "class_name": "TweakableText", "function_description": "Deletes a specified range of text from the TweakableText object. It then generates a \"<<TextChange>>\" event, notifying any listeners about the modification."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "should_indent_with_tabs", "line_number": 215, "body": "def should_indent_with_tabs(self):\n        return True", "is_method": true, "class_name": "EnhancedText", "function_description": "Indicates that text managed by the EnhancedText class should always be indented using tabs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_mouse_aids", "line_number": 218, "body": "def _bind_mouse_aids(self):\n        if _running_on_mac():\n            self.bind(\"<Button-2>\", self.on_secondary_click)\n            self.bind(\"<Control-Button-1>\", self.on_secondary_click)\n        else:\n            self.bind(\"<Button-3>\", self.on_secondary_click)", "is_method": true, "class_name": "EnhancedText", "function_description": "Configures mouse button bindings for the `EnhancedText` widget. It ensures platform-consistent handling of secondary clicks, such as right-clicks, for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_editing_aids", "line_number": 225, "body": "def _bind_editing_aids(self):\n        def if_not_readonly(fun):\n            def dispatch(event):\n                if not self.is_read_only():\n                    return fun(event)\n                else:\n                    return \"break\"\n\n            return dispatch\n\n        self.bind(\"<Control-BackSpace>\", if_not_readonly(self.delete_word_left), True)\n        self.bind(\"<Control-Delete>\", if_not_readonly(self.delete_word_right), True)\n        self.bind(\"<Control-d>\", self._redirect_ctrld, True)\n        self.bind(\"<Control-t>\", self._redirect_ctrlt, True)\n        self.bind(\"<BackSpace>\", if_not_readonly(self.perform_smart_backspace), True)\n        self.bind(\"<Return>\", if_not_readonly(self.perform_return), True)\n        self.bind(\"<KP_Enter>\", if_not_readonly(self.perform_return), True)\n        self.bind(\"<Tab>\", if_not_readonly(self.perform_tab), True)\n        try:\n            # Is needed on eg. Ubuntu with Estonian keyboard\n            self.bind(\"<ISO_Left_Tab>\", if_not_readonly(self.perform_tab), True)\n        except Exception:\n            pass\n\n        if platform.system() == \"Windows\":\n            self.bind(\"<KeyPress>\", self._insert_untypable_characters_on_windows, True)", "is_method": true, "class_name": "EnhancedText", "function_description": "This method configures custom keyboard shortcuts for the `EnhancedText` widget's editing actions. It ensures these enhanced behaviors, like smart backspace or word deletion, respect the widget's read-only state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_keypad", "line_number": 252, "body": "def _bind_keypad(self):\n        \"\"\"Remap keypad movement events to non-keypad equivalents\"\"\"\n        # https://github.com/thonny/thonny/issues/1106\n        kmap = {\n            \"<KP_Left>\": \"<Left>\",\n            \"<KP_Right>\": \"<Right>\",\n            \"<KP_Up>\": \"<Up>\",\n            \"<KP_Down>\": \"<Down>\",\n            \"<KP_Home>\": \"<Home>\",\n            \"<KP_End>\": \"<End>\",\n            \"<KP_Next>\": \"<Next>\",\n            \"<KP_Prior>\": \"<Prior>\",\n            \"<KP_Enter>\": \"<Return>\",\n        }\n        for from_key in kmap:\n\n            def mfunc(event, key=from_key):\n                self.event_generate(kmap[key], **{\"state\": event.state})\n                return \"break\"\n\n            try:\n                self.bind(from_key, mfunc)\n            except TclError:\n                pass", "is_method": true, "class_name": "EnhancedText", "function_description": "This method ensures consistent text navigation by remapping numeric keypad events to their standard keyboard equivalents for the EnhancedText widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_movement_aids", "line_number": 277, "body": "def _bind_movement_aids(self):\n        self.bind(\"<Home>\", self.perform_smart_home, True)\n        self.bind(\"<Left>\", self.move_to_edge_if_selection(0), True)\n        self.bind(\"<Right>\", self.move_to_edge_if_selection(1), True)\n        self.bind(\"<Next>\", self.perform_page_down, True)\n        self.bind(\"<Prior>\", self.perform_page_up, True)", "is_method": true, "class_name": "EnhancedText", "function_description": "This method binds common keyboard navigation keys (like Home, Left, Right, Page Up/Down) to specific text movement and view control actions within the `EnhancedText` component. It establishes essential UI interaction for text navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_selection_aids", "line_number": 284, "body": "def _bind_selection_aids(self):\n        self.bind(\"<Command-a>\" if _running_on_mac() else \"<Control-a>\", self.select_all, True)", "is_method": true, "class_name": "EnhancedText", "function_description": "This method binds common 'select all' keyboard shortcuts (Ctrl/Cmd+A) to the component's functionality, enabling quick full text selection within the EnhancedText instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_bind_undo_aids", "line_number": 287, "body": "def _bind_undo_aids(self):\n        self.bind(\"<<Undo>>\", self._on_undo, True)\n        self.bind(\"<<Redo>>\", self._on_redo, True)\n        self.bind(\"<<Cut>>\", self._on_cut, True)\n        self.bind(\"<<Copy>>\", self._on_copy, True)\n        self.bind(\"<<Paste>>\", self._on_paste, True)\n        self.bind(\"<FocusIn>\", self._on_get_focus, True)\n        self.bind(\"<FocusOut>\", self._on_lose_focus, True)\n        self.bind(\"<Key>\", self._on_key_press, True)\n        self.bind(\"<1>\", self._on_mouse_click, True)\n        self.bind(\"<2>\", self._on_mouse_click, True)\n        self.bind(\"<3>\", self._on_mouse_click, True)\n\n        if _running_on_x11() or _running_on_mac():\n\n            def custom_redo(event):\n                self.event_generate(\"<<Redo>>\")\n                return \"break\"\n\n            self.bind(\"<Control-y>\", custom_redo, True)", "is_method": true, "class_name": "EnhancedText", "function_description": "Binds common UI events and text editing actions like undo, redo, cut, copy, and paste to internal handler methods for the `EnhancedText` widget. This enables the widget's interactive functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_redirect_ctrld", "line_number": 308, "body": "def _redirect_ctrld(self, event):\n        # I want to disable the deletion effect of Ctrl-D in the text but still\n        # keep the event for other purposes\n        self.event_generate(\"<<CtrlDInText>>\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Disables the default deletion effect of Ctrl-D within the text widget. It generates a custom event for alternative handling, preventing text removal."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_redirect_ctrlt", "line_number": 314, "body": "def _redirect_ctrlt(self, event):\n        # I want to disable the swap effect of Ctrl-T in the text but still\n        # keep the event for other purposes\n        self.event_generate(\"<<CtrlTInText>>\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Intercepts the Ctrl-T key event within the EnhancedText component, preventing its default action. It generates a custom internal event, allowing other parts of the application to respond."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "tag_reset", "line_number": 320, "body": "def tag_reset(self, tag_name):\n        empty_conf = {key: \"\" for key in self.tag_configure(tag_name)}\n        self.tag_configure(empty_conf)", "is_method": true, "class_name": "EnhancedText", "function_description": "Resets all configured attributes for a specified text tag by setting its configuration options to empty values. This effectively clears any custom styling or behavior associated with the tag."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "select_lines", "line_number": 324, "body": "def select_lines(self, first_line, last_line):\n        self.tag_remove(\"sel\", \"1.0\", tk.END)\n        self.tag_add(\"sel\", \"%s.0\" % first_line, \"%s.end\" % last_line)", "is_method": true, "class_name": "EnhancedText", "function_description": "Selects a specific range of lines within the text widget. It clears any previous selection and then highlights the text from the `first_line` to the `last_line`."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "delete_word_left", "line_number": 328, "body": "def delete_word_left(self, event):\n        self.event_generate(\"<Meta-Delete>\")\n        self.edit_separator()\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Deletes the entire word to the left of the cursor in the `EnhancedText` component. This action is recorded in the editor's history."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "delete_word_right", "line_number": 333, "body": "def delete_word_right(self, event):\n        self.event_generate(\"<Meta-d>\")\n        self.edit_separator()\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Deletes the word immediately to the right of the cursor's current position within the text editing component. This provides a quick word-deletion capability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_smart_backspace", "line_number": 338, "body": "def perform_smart_backspace(self, event):\n        self._log_keypress_for_undo(event)\n\n        text = self\n        first, last = self.get_selection_indices()\n        if first and last:\n            text.delete(first, last)\n            text.mark_set(\"insert\", first)\n            return \"break\"\n        # Delete whitespace left, until hitting a real char or closest\n        # preceding virtual tab stop.\n        chars = text.get(\"insert linestart\", \"insert\")\n        if chars == \"\":\n            if text.compare(\"insert\", \">\", \"1.0\"):\n                # easy: delete preceding newline\n                text.delete(\"insert-1c\")\n            else:\n                text.bell()  # at start of buffer\n            return \"break\"\n\n        if (\n            chars.strip() != \"\"\n        ):  # there are non-whitespace chars somewhere to the left of the cursor\n            # easy: delete preceding real char\n            text.delete(\"insert-1c\")\n            self._log_keypress_for_undo(event)\n            return \"break\"\n\n        # Ick.  It may require *inserting* spaces if we back up over a\n        # tab character!  This is written to be clear, not fast.\n        have = len(chars.expandtabs(self.tabwidth))\n        assert have > 0\n        want = ((have - 1) // self.indent_width) * self.indent_width\n        # Debug prompt is multilined....\n        # if self.context_use_ps1:\n        #    last_line_of_prompt = sys.ps1.split('\\n')[-1]\n        # else:\n        last_line_of_prompt = \"\"\n        ncharsdeleted = 0\n        while 1:\n            if chars == last_line_of_prompt:\n                break\n            chars = chars[:-1]\n            ncharsdeleted = ncharsdeleted + 1\n            have = len(chars.expandtabs(self.tabwidth))\n            if have <= want or chars[-1] not in \" \\t\":\n                break\n        text.delete(\"insert-%dc\" % ncharsdeleted, \"insert\")\n        if have < want:\n            text.insert(\"insert\", \" \" * (want - have))\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Implements a smart backspace operation for text editing. It deletes selections, single characters, or intelligently removes whitespace and adjusts indentation based on tab settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_dumb_tab", "line_number": 395, "body": "def perform_dumb_tab(self, event=None):\n        self._log_keypress_for_undo(event)\n        self.insert(\"insert\", \"\\t\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "This method provides the `EnhancedText` widget with the capability to insert a literal tab character at the current cursor position. It also logs this insertion for undo purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_smart_tab", "line_number": 400, "body": "def perform_smart_tab(self, event=None):\n        self._log_keypress_for_undo(event)\n\n        # if intraline selection:\n        #     delete it\n        # elif multiline selection:\n        #     do indent-region\n        # else:\n        #     indent one level\n\n        first, last = self.get_selection_indices()\n        if first and last:\n            if index2line(first) != index2line(last):\n                return self.indent_region(event)\n            self.delete(first, last)\n            self.mark_set(\"insert\", first)\n        prefix = self.get(\"insert linestart\", \"insert\")\n        raw, effective = classifyws(prefix, self.tabwidth)\n        if raw == len(prefix):\n            # only whitespace to the left\n            self._reindent_to(effective + self.indent_width)\n        else:\n            # tab to the next 'stop' within or to right of line's text:\n            if self.should_indent_with_tabs():\n                pad = \"\\t\"\n            else:\n                effective = len(prefix.expandtabs(self.tabwidth))\n                n = self.indent_width\n                pad = \" \" * (n - effective % n)\n            self.insert(\"insert\", pad)\n        self.see(\"insert\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Provides smart tab functionality for the text editor. It intelligently indents multi-line selections, deletes intra-line selections, or inserts appropriate whitespace to align the current line to the next tab stop."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "get_cursor_position", "line_number": 433, "body": "def get_cursor_position(self):\n        return map(int, self.index(\"insert\").split(\".\"))", "is_method": true, "class_name": "EnhancedText", "function_description": "Retrieves the current line and column position of the text insertion cursor. This is essential for tracking user input within the text editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "get_line_count", "line_number": 436, "body": "def get_line_count(self):\n        return list(map(int, self.index(\"end-1c\").split(\".\")))[0]", "is_method": true, "class_name": "EnhancedText", "function_description": "Calculates and returns the total number of lines within the `EnhancedText` object. It provides a direct way to ascertain the text's line count."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_return", "line_number": 439, "body": "def perform_return(self, event):\n        self.insert(\"insert\", \"\\n\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Customizes the 'Enter' key behavior for the EnhancedText component, inserting a newline character and preventing further event processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_page_down", "line_number": 443, "body": "def perform_page_down(self, event):\n        # if last line is visible then go to last line\n        # (by default it doesn't move then)\n        try:\n            last_visible_idx = self.index(\"@0,%d\" % self.winfo_height())\n            row, _ = map(int, last_visible_idx.split(\".\"))\n            line_count = self.get_line_count()\n\n            if row == line_count or row == line_count - 1:  # otherwise tk doesn't show last line\n                self.mark_set(\"insert\", \"end\")\n        except Exception as e:\n            logger.exception(\"Could not perform page down\", exc_info=e)", "is_method": true, "class_name": "EnhancedText", "function_description": "Provides enhanced page-down functionality for a text widget, ensuring the view scrolls to the very end if the current position is already near the bottom."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_page_up", "line_number": 456, "body": "def perform_page_up(self, event):\n        # if first line is visible then go there\n        # (by default it doesn't move then)\n        try:\n            first_visible_idx = self.index(\"@0,0\")\n            row, _ = map(int, first_visible_idx.split(\".\"))\n            if row == 1:\n                self.mark_set(\"insert\", \"1.0\")\n        except Exception as e:\n            logger.exception(\"Could not perform page up\", exc_info=e)", "is_method": true, "class_name": "EnhancedText", "function_description": "This method, part of the `EnhancedText` class, handles the 'page up' action. It ensures the cursor moves to the absolute start of the text if the first line is already visible, enhancing navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "compute_smart_home_destination_index", "line_number": 467, "body": "def compute_smart_home_destination_index(self):\n        \"\"\"Is overridden in shell\"\"\"\n\n        line = self.get(\"insert linestart\", \"insert lineend\")\n        for insertpt in range(len(line)):\n            if line[insertpt] not in (\" \", \"\\t\"):\n                break\n        else:\n            insertpt = len(line)\n\n        lineat = int(self.index(\"insert\").split(\".\")[1])\n        if insertpt == lineat:\n            insertpt = 0\n        return \"insert linestart+\" + str(insertpt) + \"c\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Calculates a text editor index for a \"smart home\" position on the current line. It points to either the first non-whitespace character or the very beginning of the line, aiding cursor navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_smart_home", "line_number": 482, "body": "def perform_smart_home(self, event):\n        if (event.state & 4) != 0 and event.keysym == \"Home\":\n            # state&4==Control. If <Control-Home>, use the Tk binding.\n            return None\n\n        dest = self.compute_smart_home_destination_index()\n\n        if (event.state & 1) == 0:\n            # shift was not pressed\n            self.tag_remove(\"sel\", \"1.0\", \"end\")\n        else:\n            if not self.index_sel_first():\n                # there was no previous selection\n                self.mark_set(\"my_anchor\", \"insert\")\n            else:\n                if self.compare(self.index_sel_first(), \"<\", self.index(\"insert\")):\n                    self.mark_set(\"my_anchor\", \"sel.first\")  # extend back\n                else:\n                    self.mark_set(\"my_anchor\", \"sel.last\")  # extend forward\n            first = self.index(dest)\n            last = self.index(\"my_anchor\")\n            if self.compare(first, \">\", last):\n                first, last = last, first\n            self.tag_remove(\"sel\", \"1.0\", \"end\")\n            self.tag_add(\"sel\", first, last)\n        self.mark_set(\"insert\", dest)\n        self.see(\"insert\")\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "This method manages the \"Home\" key press within an EnhancedText widget. It moves the cursor to a computed \"smart\" beginning of a line or text, optionally extending or creating a selection if Shift is pressed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "move_to_edge_if_selection", "line_number": 511, "body": "def move_to_edge_if_selection(self, edge_index):\n        \"\"\"Cursor move begins at start or end of selection\n\n        When a left/right cursor key is pressed create and return to Tkinter a\n        function which causes a cursor move from the associated edge of the\n        selection.\n        \"\"\"\n\n        def move_at_edge(event):\n            if (\n                self.has_selection() and (event.state & 5) == 0\n            ):  # no shift(==1) or control(==4) pressed\n                try:\n                    self.mark_set(\"insert\", (\"sel.first+1c\", \"sel.last-1c\")[edge_index])\n                except tk.TclError:\n                    pass\n\n        return move_at_edge", "is_method": true, "class_name": "EnhancedText", "function_description": "Configures a Tkinter event handler that, upon a cursor key press, moves the text cursor to the start or end of the current text selection. This enables cursor navigation along selection boundaries without extending the selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "perform_tab", "line_number": 530, "body": "def perform_tab(self, event=None):\n        self._log_keypress_for_undo(event)\n        if event.state & 0x0001:  # shift is pressed (http://stackoverflow.com/q/32426250/261181)\n            return self.dedent_region(event)\n        else:\n            # check whether there are letters before cursor on this line\n            index = self.index(\"insert\")\n            left_text = self.get(index + \" linestart\", index)\n            if left_text.strip() == \"\" or self.has_selection():\n                return self.perform_smart_tab(event)\n            else:\n                return self.perform_midline_tab(event)", "is_method": true, "class_name": "EnhancedText", "function_description": "This method processes the 'Tab' key press in the EnhancedText editor. It intelligently dedents, performs smart indentation, or inserts a literal tab character based on the Shift key and cursor position."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "indent_region", "line_number": 543, "body": "def indent_region(self, event=None):\n        return self._change_indentation(True)", "is_method": true, "class_name": "EnhancedText", "function_description": "Increases the indentation level of the currently selected text region. It provides a quick way to format text by adding an indent."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "dedent_region", "line_number": 546, "body": "def dedent_region(self, event=None):\n        return self._change_indentation(False)", "is_method": true, "class_name": "EnhancedText", "function_description": "Decreases the indentation of the currently selected text region. It provides a core text formatting capability within an EnhancedText component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_change_indentation", "line_number": 549, "body": "def _change_indentation(self, increase=True):\n        head, tail, chars, lines = self._get_region()\n\n        # Text widget plays tricks if selection ends on last line\n        # and content doesn't end with empty line,\n        text_last_line = index2line(self.index(\"end-1c\"))\n        sel_last_line = index2line(tail)\n        if sel_last_line >= text_last_line:\n            while not self.get(head, \"end\").endswith(\"\\n\\n\"):\n                self.insert(\"end\", \"\\n\")\n\n        for pos in range(len(lines)):\n            line = lines[pos]\n            if line:\n                raw, effective = classifyws(line, self.tabwidth)\n                if increase:\n                    effective = effective + self.indent_width\n                else:\n                    effective = max(effective - self.indent_width, 0)\n                lines[pos] = self._make_blanks(effective) + line[raw:]\n        self._set_region(head, tail, chars, lines)\n        return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "This internal method of `EnhancedText` adjusts the indentation of the currently selected text lines. It can either increase or decrease the indentation based on a specified width."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "select_all", "line_number": 572, "body": "def select_all(self, event):\n        self.tag_remove(\"sel\", \"1.0\", tk.END)\n        self.tag_add(\"sel\", \"1.0\", tk.END)", "is_method": true, "class_name": "EnhancedText", "function_description": "This method of the EnhancedText class selects all text content within the widget, typically in response to a user interface event. It provides a simple way to highlight the entire document for operations like copy or cut."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_read_only", "line_number": 576, "body": "def set_read_only(self, value):\n        if value == self.is_read_only():\n            return\n\n        TweakableText.set_read_only(self, value)\n        self._reload_theme_options()\n        if self._should_tag_current_line:\n            self._tag_current_line()", "is_method": true, "class_name": "EnhancedText", "function_description": "Manages the read-only state for EnhancedText objects, ensuring visual elements like theme and line tagging are properly updated upon status changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_reindent_to", "line_number": 585, "body": "def _reindent_to(self, column):\n        # Delete from beginning of line to insert point, then reinsert\n        # column logical (meaning use tabs if appropriate) spaces.\n        if self.compare(\"insert linestart\", \"!=\", \"insert\"):\n            self.delete(\"insert linestart\", \"insert\")\n        if column:\n            self.insert(\"insert\", self._make_blanks(column))", "is_method": true, "class_name": "EnhancedText", "function_description": "This internal method adjusts the current line's indentation. It ensures the line starts with a specific number of leading spaces or tabs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_get_region", "line_number": 593, "body": "def _get_region(self):\n        first, last = self.get_selection_indices()\n        if first and last:\n            head = self.index(first + \" linestart\")\n            tail = self.index(last + \"-1c lineend +1c\")\n        else:\n            head = self.index(\"insert linestart\")\n            tail = self.index(\"insert lineend +1c\")\n        chars = self.get(head, tail)\n        lines = chars.split(\"\\n\")\n        return head, tail, chars, lines", "is_method": true, "class_name": "EnhancedText", "function_description": "Retrieves the text and boundaries of either the selected lines or the current line within the EnhancedText object. It provides the character range, full content, and individual lines of the identified region."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_set_region", "line_number": 605, "body": "def _set_region(self, head, tail, chars, lines):\n        newchars = \"\\n\".join(lines)\n        if newchars == chars:\n            self.bell()\n            return\n        self.tag_remove(\"sel\", \"1.0\", \"end\")\n        self.mark_set(\"insert\", head)\n        self.delete(head, tail)\n        self.insert(head, newchars)\n        self.tag_add(\"sel\", head, \"insert\")", "is_method": true, "class_name": "EnhancedText", "function_description": "This internal method updates a specified text region within the EnhancedText widget. It replaces content and selects the updated region, providing a core text modification capability for the widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_log_keypress_for_undo", "line_number": 616, "body": "def _log_keypress_for_undo(self, e):\n        if e is None:\n            return\n\n        # NB! this may not execute if the event is cancelled in another handler\n        event_kind = self._get_event_kind(e)\n\n        if (\n            event_kind != self._last_event_kind\n            or e.char in (\"\\r\", \"\\n\", \" \", \"\\t\")\n            or e.keysym in [\"Return\", \"KP_Enter\"]\n            or time.time() - self._last_key_time > 2\n        ):\n            self.edit_separator()\n\n        self._last_event_kind = event_kind\n        self._last_key_time = time.time()", "is_method": true, "class_name": "EnhancedText", "function_description": "Manages the internal undo history by inserting separators for logical undo points based on user key presses and timing. It ensures that related edits are grouped for coherent undo functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_get_event_kind", "line_number": 634, "body": "def _get_event_kind(self, event):\n        if event.keysym in (\"BackSpace\", \"Delete\"):\n            return \"delete\"\n        elif event.char:\n            return \"insert\"\n        else:\n            # eg. e.keysym in (\"Left\", \"Up\", \"Right\", \"Down\", \"Home\", \"End\", \"Prior\", \"Next\"):\n            return \"other_key\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Classifies a keyboard event into \"delete\", \"insert\", or \"other_key\" categories. This internal helper method aids in processing user input related to text modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_make_blanks", "line_number": 643, "body": "def _make_blanks(self, n):\n        # Make string that displays as n leading blanks.\n        if self.should_indent_with_tabs():\n            ntabs, nspaces = divmod(n, self.tabwidth)\n            return \"\\t\" * ntabs + \" \" * nspaces\n        else:\n            return \" \" * n", "is_method": true, "class_name": "EnhancedText", "function_description": "This method generates a string representing a specified number of leading blank characters, respecting whether indentation should use tabs or spaces based on class settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_undo", "line_number": 651, "body": "def _on_undo(self, e):\n        self._last_event_kind = \"undo\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Records that an undo operation has occurred on the EnhancedText object, likely serving as an internal event handler to track the last action."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_redo", "line_number": 654, "body": "def _on_redo(self, e):\n        self._last_event_kind = \"redo\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Registers a 'redo' event within the EnhancedText object. It updates an internal state variable, crucial for managing the text component's undo/redo history."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_cut", "line_number": 657, "body": "def _on_cut(self, e):\n        self._last_event_kind = \"cut\"\n        self.edit_separator()", "is_method": true, "class_name": "EnhancedText", "function_description": "Processes a 'cut' event by updating the internal state and then adjusting the text's formatting separator within the EnhancedText object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_paste", "line_number": 665, "body": "def _on_paste(self, e):\n        if self.is_read_only():\n            return\n\n        try:\n            if self.has_selection():\n                self.direct_delete(\"sel.first\", \"sel.last\")\n        except Exception:\n            pass\n\n        self._last_event_kind = \"paste\"\n        self.edit_separator()\n        self.see(\"insert\")\n        self.after_idle(lambda: self.see(\"insert\"))", "is_method": true, "class_name": "EnhancedText", "function_description": "Provides the core functionality for handling user paste operations in an `EnhancedText` widget. It manages clipboard content insertion, selection replacement, and cursor visibility, respecting read-only states."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_get_focus", "line_number": 680, "body": "def _on_get_focus(self, e):\n        self._last_event_kind = \"get_focus\"\n        self.edit_separator()", "is_method": true, "class_name": "EnhancedText", "function_description": "Handles the 'get focus' event for the EnhancedText component, triggering an internal update to its separator."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_lose_focus", "line_number": 684, "body": "def _on_lose_focus(self, e):\n        self._last_event_kind = \"lose_focus\"\n        self.edit_separator()", "is_method": true, "class_name": "EnhancedText", "function_description": "Handles the 'lose focus' event for the EnhancedText control, updating its internal state and initiating a separator edit."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_key_press", "line_number": 688, "body": "def _on_key_press(self, e):\n        return self._log_keypress_for_undo(e)", "is_method": true, "class_name": "EnhancedText", "function_description": "Handles a key press event by logging it internally to support undo functionality for user input."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_on_mouse_click", "line_number": 691, "body": "def _on_mouse_click(self, event):\n        self.edit_separator()", "is_method": true, "class_name": "EnhancedText", "function_description": "Handles a mouse click event on the EnhancedText component. When clicked, it activates the functionality to edit a separator within the text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_tag_current_line", "line_number": 694, "body": "def _tag_current_line(self, event=None):\n        self.tag_remove(\"current_line\", \"1.0\", \"end\")\n\n        # Let's show current line only with readable text\n        # (this fits well with Thonny debugger,\n        # otherwise debugger focus box and current line interact in an ugly way)\n        if self._should_tag_current_line and not self.is_read_only():\n            # we may be on the same line as with prev event but tag needs extension\n            lineno = int(self.index(\"insert\").split(\".\")[0])\n            self.tag_add(\"current_line\", str(lineno) + \".0\", str(lineno + 1) + \".0\")", "is_method": true, "class_name": "EnhancedText", "function_description": "Provides visual highlighting for the current line in the EnhancedText component. It applies a 'current_line' tag to the active line if text is editable and highlighting is enabled."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "on_secondary_click", "line_number": 705, "body": "def on_secondary_click(self, event=None):\n        \"Use this for invoking context menu\"\n        self.focus_set()\n        if event:\n            self.mark_set(\"insert\", \"@%d,%d\" % (event.x, event.y))", "is_method": true, "class_name": "EnhancedText", "function_description": "Handles secondary click events on the text widget. It sets focus and positions the text cursor to prepare for invoking a context menu."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_reload_theme_options", "line_number": 711, "body": "def _reload_theme_options(self, event=None):\n\n        style = ttk.Style()\n\n        states = []\n        if self.is_read_only():\n            states.append(\"readonly\")\n\n        # Following crashes when a combobox is focused\n        # if self.focus_get() == self:\n        #    states.append(\"focus\")\n\n        if \"background\" not in self._initial_configuration:\n            background = style.lookup(self._style, \"background\", states)\n            if background:\n                self.configure(background=background)\n\n        if \"foreground\" not in self._initial_configuration:\n            foreground = style.lookup(self._style, \"foreground\", states)\n            if foreground:\n                self.configure(foreground=foreground)\n                self.configure(insertbackground=foreground)", "is_method": true, "class_name": "EnhancedText", "function_description": "Reloads the background and foreground colors of the EnhancedText widget. It applies current `ttk` style settings, respecting the widget's read-only state and initial configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_insert_untypable_characters_on_windows", "line_number": 734, "body": "def _insert_untypable_characters_on_windows(self, event):\n        if event.state == 131084:  # AltGr or Ctrl+Alt\n            lang_id = get_keyboard_language()\n            char = _windows_altgr_chars_by_lang_id_and_keycode.get(lang_id, {}).get(\n                event.keycode, None\n            )\n            if char is not None:\n                self.insert(\"insert\", char)", "is_method": true, "class_name": "EnhancedText", "function_description": "Inserts specific characters into the text component when AltGr or Ctrl+Alt key combinations are used on Windows. It enhances text input by supporting characters not directly typable via standard key presses."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "destroy", "line_number": 743, "body": "def destroy(self):\n        self.unbind(\"<<ThemeChanged>>\", self._ui_theme_change_binding)\n        super().destroy()", "is_method": true, "class_name": "EnhancedText", "function_description": "Deconstructs the EnhancedText widget, unbinding its UI theme change listener to prevent memory leaks and ensure proper resource release."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "direct_insert", "line_number": 747, "body": "def direct_insert(self, index, chars, tags=None, **kw):\n        super().direct_insert(index, chars, tags, **kw)", "is_method": true, "class_name": "EnhancedText", "function_description": "Provides direct character insertion capability to the `EnhancedText` object by delegating the operation to its parent class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "focus_set", "line_number": 811, "body": "def focus_set(self):\n        self.text.focus_set()", "is_method": true, "class_name": "TextFrame", "function_description": "This method sets the keyboard focus to the `TextFrame`'s internal text widget, enabling it to receive user input directly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_vertical_scrollbar_update", "line_number": 814, "body": "def _vertical_scrollbar_update(self, *args):\n        if not hasattr(self, \"_vbar\"):\n            return\n\n        self._vbar.set(*args)\n        self.text.event_generate(\"<<VerticalScroll>>\")", "is_method": true, "class_name": "TextFrame", "function_description": "Updates the vertical scrollbar's position for the text frame. It then signals a vertical scroll event to ensure synchronization between the scrollbar and text view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_horizontal_scrollbar_update", "line_number": 821, "body": "def _horizontal_scrollbar_update(self, *args):\n        self._hbar.set(*args)", "is_method": true, "class_name": "TextFrame", "function_description": "Updates the internal horizontal scrollbar's state, ensuring it accurately reflects the text frame's current view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_vertical_scroll", "line_number": 824, "body": "def _vertical_scroll(self, *args):\n        self.text.yview(*args)\n        self.text.event_generate(\"<<VerticalScroll>>\")", "is_method": true, "class_name": "TextFrame", "function_description": "Vertically scrolls the text content within the frame's text widget. It also generates a custom event to signal that a vertical scroll has occurred."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_horizontal_scroll", "line_number": 828, "body": "def _horizontal_scroll(self, *args):\n        self.text.xview(*args)", "is_method": true, "class_name": "TextFrame", "function_description": "This method provides horizontal scrolling functionality for the TextFrame's embedded text display. It allows users to navigate horizontally through the text content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "destroy", "line_number": 834, "body": "def destroy(self):\n        self.unbind(\"<<ThemeChanged>>\", self._ui_theme_change_binding)\n        super().destroy()", "is_method": true, "class_name": "TextFrame", "function_description": "This method properly cleans up the TextFrame instance, unbinding event listeners and releasing associated resources. It ensures the frame is gracefully removed from the UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_gutter_visibility", "line_number": 932, "body": "def set_gutter_visibility(self, value):\n        if value and not self._gutter_is_gridded:\n            self._gutter.grid(row=0, column=0, sticky=tk.NSEW)\n            self._gutter_is_gridded = True\n        elif not value and self._gutter_is_gridded:\n            self._gutter.grid_forget()\n            self._gutter_is_gridded = False\n        else:\n            return\n\n        \"\"\"\n        # insert first line number (NB! Without trailing linebreak. See update_gutter)\n        self._gutter.config(state=\"normal\")\n        self._gutter.delete(\"1.0\", \"end\")\n        for content, tags in self.compute_gutter_line(self._first_line_number):\n            self._gutter.insert(\"end\", content, (\"content\",) + tags)\n        self._gutter.config(state=\"disabled\")\n        \"\"\"\n        self.update_gutter(True)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Controls the visibility of the text frame's gutter, typically used for line numbers, by showing or hiding it in the UI and updating its content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "set_line_length_margin", "line_number": 952, "body": "def set_line_length_margin(self, value):\n        self._recommended_line_length = value\n        self.update_margin_line()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Sets the recommended maximum line length for text within the frame. It automatically updates the associated visual margin line."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_gutter_scroll", "line_number": 956, "body": "def _gutter_scroll(self, *args):\n        if not hasattr(self, \"_vbar\"):\n            return\n\n        try:\n            self._vbar.set(*args)\n            self.text.yview(tk.MOVETO, args[0])\n        except TclError:\n            pass", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "This internal method synchronizes the vertical scrollbar's position with the text widget's view. It ensures consistent vertical scrolling for elements within the EnhancedTextFrame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_text_changed", "line_number": 966, "body": "def _text_changed(self, event):\n        self.update_gutter()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "This method automatically updates the text frame's gutter when its text content changes. It ensures visual elements like line numbers remain synchronized with the current text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_cursor_moved", "line_number": 969, "body": "def _cursor_moved(self, event):\n        self._update_gutter_active_line()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Handles cursor movement events by updating the active line highlight in the text frame's gutter display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "update_gutter", "line_number": 972, "body": "def update_gutter(self, clean=False):\n        if clean:\n            self._gutter.config(state=\"normal\")\n            self._gutter.delete(\"1.0\", \"end\")\n            # need to add first item separately, because Text can't report 0 rows\n            for content, tags in self.compute_gutter_line(self._first_line_number):\n                self._gutter.insert(\"end-1c\", content, tags + (\"content\",))\n\n            self._gutter.config(state=\"disabled\")\n\n        text_line_count = int(self.text.index(\"end\").split(\".\")[0])\n        gutter_line_count = int(self._gutter.index(\"end\").split(\".\")[0])\n\n        if text_line_count != gutter_line_count:\n            self._gutter.config(state=\"normal\")\n\n            # NB! Text acts weird with last symbol\n            # (don't really understand whether it automatically keeps a newline there or not)\n            # Following seems to ensure both Text-s have same height\n            if text_line_count > gutter_line_count:\n                delta = text_line_count - gutter_line_count\n                start = gutter_line_count + self._first_line_number - 1\n\n                if not clean and text_line_count > 10 and gutter_line_count < 3:\n                    # probably initial load, do bulk insert\n                    parts = []\n                    for i in range(start, start + delta):\n                        parts.append(\"\\n\")\n                        for content, tags in self.compute_gutter_line(i, plain=True):\n                            parts.append(content)\n\n                    self._gutter.insert(\"end-1c\", \"\".join(parts), (\"content\",) + tags)\n                else:\n                    for i in range(start, start + delta):\n                        self._gutter.insert(\"end-1c\", \"\\n\", (\"content\",))\n                        for content, tags in self.compute_gutter_line(i):\n                            self._gutter.insert(\"end-1c\", content, (\"content\",) + tags)\n            else:\n                self._gutter.delete(line2index(text_line_count) + \"-1c\", \"end-1c\")\n\n            self._gutter.config(state=\"disabled\")\n\n        # synchronize gutter scroll position with text\n        # https://mail.python.org/pipermail/tkinter-discuss/2010-March/002197.html\n        first, _ = self.text.yview()\n        self._gutter.yview_moveto(first)\n        self._update_gutter_active_line()\n\n        if text_line_count > 9998:\n            self._gutter.configure(width=7)\n        elif text_line_count > 998:\n            self._gutter.configure(width=6)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Synchronizes the `EnhancedTextFrame`'s gutter display (e.g., line numbers) with its main text content. It dynamically adjusts gutter lines, scroll position, and width to match the text editor's state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_update_gutter_active_line", "line_number": 1025, "body": "def _update_gutter_active_line(self):\n        self._gutter.tag_remove(\"active\", \"1.0\", \"end\")\n        insert = self.text.index(\"insert\")\n        self._gutter.tag_add(\"active\", insert + \" linestart\", insert + \" lineend\")", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Updates the gutter to highlight the currently active line in the text display. This provides visual feedback for the user's current cursor position."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "compute_gutter_line", "line_number": 1030, "body": "def compute_gutter_line(self, lineno, plain=False):\n        yield str(lineno), ()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Generates a line number string for display in the text frame's gutter area."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "update_margin_line", "line_number": 1033, "body": "def update_margin_line(self):\n        if self._recommended_line_length == 0:\n            self._margin_line.place_forget()\n        else:\n            try:\n                self.text.update_idletasks()\n                # How far left has text been scrolled\n                first_visible_idx = self.text.index(\"@0,0\")\n                first_visible_col = int(first_visible_idx.split(\".\")[1])\n                bbox = self.text.bbox(first_visible_idx)\n                first_visible_col_x = bbox[0]\n\n                margin_line_visible_col = self._recommended_line_length - first_visible_col\n                delta = first_visible_col_x\n            except Exception:\n                # fall back to ignoring scroll position\n                margin_line_visible_col = self._recommended_line_length\n                delta = 0\n\n            if margin_line_visible_col > -1:\n                x = (\n                    get_text_font(self.text).measure((margin_line_visible_col - 1) * \"M\")\n                    + delta\n                    + self.text[\"padx\"]\n                )\n            else:\n                x = -10\n\n            # print(first_visible_col, first_visible_col_x)\n\n            self._margin_line.place(y=-10, x=x)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Dynamically positions a visual margin line within the text frame. It adjusts the line's horizontal placement based on the recommended line length and current horizontal text scroll."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "on_gutter_click", "line_number": 1065, "body": "def on_gutter_click(self, event=None):\n        try:\n            linepos = self._gutter.index(\"@%s,%s\" % (event.x, event.y)).split(\".\")[0]\n            self.text.mark_set(\"insert\", \"%s.0\" % linepos)\n            self._gutter.mark_set(\"gutter_selection_start\", \"%s.0\" % linepos)\n            if (\n                event.type == \"4\"\n            ):  # In Python 3.6 you can use tk.EventType.ButtonPress instead of \"4\"\n                self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n        except tk.TclError:\n            exception(\"on_gutter_click\")", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Responds to a click on the text frame's gutter by moving the text cursor to the corresponding line. It also clears any active text selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "on_gutter_double_click", "line_number": 1077, "body": "def on_gutter_double_click(self, event=None):\n        try:\n            self._gutter.mark_unset(\"gutter_selection_start\")\n            self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n            self._gutter.tag_remove(\"sel\", \"1.0\", \"end\")\n        except tk.TclError:\n            exception(\"on_gutter_click\")", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Handles a double-click event on the text frame's gutter. This method clears all active text and gutter selections, resetting the selection state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "on_gutter_motion", "line_number": 1085, "body": "def on_gutter_motion(self, event=None):\n        try:\n            if \"gutter_selection_start\" not in self._gutter.mark_names():\n                return\n            linepos = int(self._gutter.index(\"@%s,%s\" % (event.x, event.y)).split(\".\")[0])\n            gutter_selection_start = int(self._gutter.index(\"gutter_selection_start\").split(\".\")[0])\n            self.text.select_lines(\n                min(gutter_selection_start, linepos), max(gutter_selection_start - 1, linepos - 1)\n            )\n            self.text.mark_set(\"insert\", \"%s.0\" % linepos)\n            self.text.focus_set()\n        except tk.TclError:\n            exception(\"on_gutter_motion\")", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Handles mouse movement in the text frame's gutter. It dynamically extends or adjusts the line selection in the associated text widget as the user drags the mouse."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_vertical_scrollbar_update", "line_number": 1099, "body": "def _vertical_scrollbar_update(self, *args):\n        if not hasattr(self, \"_vbar\"):\n            return\n\n        super()._vertical_scrollbar_update(*args)\n        self._gutter.yview(tk.MOVETO, args[0])", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Ensures the vertical scrollbar update propagates to the `EnhancedTextFrame` and its associated gutter, keeping elements like line numbers synchronized with text scrolling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_horizontal_scrollbar_update", "line_number": 1106, "body": "def _horizontal_scrollbar_update(self, *args):\n        super()._horizontal_scrollbar_update(*args)\n        self.update_margin_line()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Updates the horizontal scrollbar's state and ensures the text frame's margin line is redrawn. This maintains visual consistency during horizontal scrolling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_vertical_scroll", "line_number": 1110, "body": "def _vertical_scroll(self, *args):\n        super()._vertical_scroll(*args)\n        self._gutter.yview(*args)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Synchronizes vertical scrolling between the text frame and its associated gutter, ensuring visual alignment. This provides a cohesive scrolling experience for text and complementary elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_horizontal_scroll", "line_number": 1114, "body": "def _horizontal_scroll(self, *args):\n        super()._horizontal_scroll(*args)\n        self.update_margin_line()", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Handles horizontal scrolling within the text frame. It ensures the margin line visual representation is updated and synchronized with the new scroll position."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_reload_theme_options", "line_number": 1118, "body": "def _reload_theme_options(self, event=None):\n        super()._reload_theme_options(event)\n        if self._gutter is not None:\n            self._reload_gutter_theme_options(event)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Reloads the visual theme options for the `EnhancedTextFrame`, extending the parent's theme update and specifically applying options to its gutter if present."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "_reload_gutter_theme_options", "line_number": 1123, "body": "def _reload_gutter_theme_options(self, event=None):\n\n        style = ttk.Style()\n        background = style.lookup(\"GUTTER\", \"background\")\n        if background:\n            self._gutter.configure(background=background, selectbackground=background)\n            self._margin_line.configure(background=background)\n\n        foreground = style.lookup(\"GUTTER\", \"foreground\")\n        if foreground:\n            self._gutter.configure(foreground=foreground, selectforeground=foreground)", "is_method": true, "class_name": "EnhancedTextFrame", "function_description": "Updates the `_gutter` and `_margin_line` elements' colors to match the active `ttk.Style`'s \"GUTTER\" theme options. It ensures these text frame components reflect the current application theme."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "control_a", "line_number": 1180, "body": "def control_a(event):\n        widget = event.widget\n        if isinstance(widget, tk.Text):\n            widget.tag_remove(\"sel\", \"1.0\", \"end\")\n            widget.tag_add(\"sel\", \"1.0\", \"end\")", "is_method": false, "function_description": "Provides 'Select All' functionality for a Tkinter Text widget. It enables users to select all text within the widget programmatically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "original_function", "line_number": 37, "body": "def original_function(*args):\n            self.tk.call((self._original_widget_name, operation) + args)", "is_method": true, "class_name": "TweakableText", "function_description": "Provides a low-level interface to execute arbitrary operations directly on the underlying Tkinter widget. It acts as a passthrough for accessing the widget's original functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "if_not_readonly", "line_number": 226, "body": "def if_not_readonly(fun):\n            def dispatch(event):\n                if not self.is_read_only():\n                    return fun(event)\n                else:\n                    return \"break\"\n\n            return dispatch", "is_method": true, "class_name": "EnhancedText", "function_description": "This higher-order function creates a wrapper that conditionally executes another function. It prevents the wrapped function from running if the `EnhancedText` instance is in a read-only state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "move_at_edge", "line_number": 519, "body": "def move_at_edge(event):\n            if (\n                self.has_selection() and (event.state & 5) == 0\n            ):  # no shift(==1) or control(==4) pressed\n                try:\n                    self.mark_set(\"insert\", (\"sel.first+1c\", \"sel.last-1c\")[edge_index])\n                except tk.TclError:\n                    pass", "is_method": true, "class_name": "EnhancedText", "function_description": "Moves the text insertion point to an edge of the current selection. This action occurs only when no modifier keys (Shift or Control) are pressed, preventing unintended selection changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "dispatch", "line_number": 227, "body": "def dispatch(event):\n                if not self.is_read_only():\n                    return fun(event)\n                else:\n                    return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "This method conditionally dispatches an event to its handler (`fun`). It allows the event to be processed only if the `EnhancedText` object is not read-only, otherwise it signals to stop."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "mfunc", "line_number": 268, "body": "def mfunc(event, key=from_key):\n                self.event_generate(kmap[key], **{\"state\": event.state})\n                return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "This method programmatically generates a new GUI event from a specified key, preserving the original event's state. It enables custom key bindings and event remapping within the EnhancedText component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/tktextext.py", "function": "custom_redo", "line_number": 302, "body": "def custom_redo(event):\n                self.event_generate(\"<<Redo>>\")\n                return \"break\"", "is_method": true, "class_name": "EnhancedText", "function_description": "Generates a `<<Redo>>` virtual event to signal a redo operation within the `EnhancedText` component. This allows other parts of the system to handle the redo action."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/languages.py", "function": "get_button_padding", "line_number": 52, "body": "def get_button_padding():\n    code = get_workbench().get_option(\"general.language\")\n    if code in BUTTON_PADDING_SIZES:\n        return BUTTON_PADDING_SIZES[code] * \" \"\n    else:\n        return \"\"", "is_method": false, "function_description": "Dynamically retrieves a string of spaces for button padding, adjusting its length based on the current language setting. This ensures optimal button layout for diverse linguistic contexts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/languages.py", "function": "get_language_code_by_name", "line_number": 60, "body": "def get_language_code_by_name(name):\n    for code in LANGUAGES_DICT:\n        if LANGUAGES_DICT[code] == name:\n            return code\n\n    raise RuntimeError(\"Unknown language name '%s'\" % name)", "is_method": false, "function_description": "This function retrieves the standardized language code corresponding to a given language name. It provides a utility for mapping human-readable language names to their official codes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/languages.py", "function": "tr", "line_number": 68, "body": "def tr(message: str) -> str:\n    return _translation.gettext(message)", "is_method": false, "function_description": "Provides a convenient alias to retrieve the translated version of a given message string for internationalization purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/languages.py", "function": "set_language", "line_number": 72, "body": "def set_language(language_code: str) -> None:\n    global _translation\n    try:\n        path = os.path.join(os.path.dirname(__file__), \"locale\")\n        _translation = gettext.translation(\"thonny\", path, [language_code])\n    except Exception as e:\n        logger.exception(\"Could not set language to '%s\", language_code, exc_info=e)\n        _translation = gettext.NullTranslations()", "is_method": false, "function_description": "Sets the application's display language by loading the corresponding translation catalog. This enables the user interface to be presented in the specified language."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "set_data", "line_number": 33, "body": "def set_data(self, data_rows):\n        # self.data_rows.update(data_rows) # dict version\n        self.data_rows = data_rows\n        self.data_row_count = len(data_rows)\n        self.update_screen_data()", "is_method": true, "class_name": "GridTable", "function_description": "Sets or replaces all data rows displayed by the GridTable. It ensures the table's visual representation is updated to reflect the new data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "update_header_rows", "line_number": 39, "body": "def update_header_rows(self):\n        for row_no in range(self.header_row_count):\n            for col_no in range(self.column_count):\n                w = self.get_header_widget(self.screen_row_count, col_no)\n                w.grid(row=row_no, column=col_no, sticky=\"nsew\", pady=(0, 1), padx=(0, 1))\n                w.configure(text=self.get_header_value(row_no, col_no))\n\n        self.screen_row_count = self.header_row_count", "is_method": true, "class_name": "GridTable", "function_description": "Refreshes and renders the table's header rows. It updates the position and text content of each header cell widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "get_data_widget", "line_number": 48, "body": "def get_data_widget(self, screen_row_no, col_no):\n        if (screen_row_no, col_no) not in self.data_widgets:\n            self.data_widgets[(screen_row_no, col_no)] = self.create_data_widget(col_no)\n\n        return self.data_widgets[(screen_row_no, col_no)]", "is_method": true, "class_name": "GridTable", "function_description": "Provides a data display widget for a specified grid cell. It efficiently creates and reuses widgets, ensuring only one instance per cell is managed by the grid table."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "get_header_widget", "line_number": 54, "body": "def get_header_widget(self, row_no, col_no):\n        if (row_no, col_no) not in self.header_widgets:\n            self.header_widgets[(row_no, col_no)] = self.create_header_widget(col_no)\n\n        return self.header_widgets[(row_no, col_no)]", "is_method": true, "class_name": "GridTable", "function_description": "This method retrieves a header widget for a specified cell within the grid table. It creates and caches the widget on demand, ensuring efficient reuse for subsequent requests."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "create_data_widget", "line_number": 60, "body": "def create_data_widget(self, col_no):\n        if col_no < self.frozen_column_count:\n            background = None\n        else:\n            background = \"white\"\n\n        return tk.Label(self, background=background, anchor=\"e\", padx=7, text=\"\")", "is_method": true, "class_name": "GridTable", "function_description": "Creates a new `tk.Label` widget, configured for displaying data within the grid table. It sets the background color based on whether the column is 'frozen' or not."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "create_header_widget", "line_number": 68, "body": "def create_header_widget(self, col_no):\n        return tk.Label(self, anchor=\"e\", padx=7, text=\"\")", "is_method": true, "class_name": "GridTable", "function_description": "Creates a pre-configured Tkinter label widget intended for use as a column header in the grid table."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "set_first_visible_data_row_no", "line_number": 71, "body": "def set_first_visible_data_row_no(self, n):\n        self.first_visible_data_row_no = max(min(n, self.data_row_count), 0)\n        self.update_screen_data()", "is_method": true, "class_name": "GridTable", "function_description": "Controls which data row is visible at the top of the grid table. It validates the row number and updates the display accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "_clear_screen_row", "line_number": 75, "body": "def _clear_screen_row(self, row_no):\n        for widget in self.grid_slaves(row=row_no):\n            widget.grid_remove()", "is_method": true, "class_name": "GridTable", "function_description": "This method removes all widgets from a specified row in the GridTable's display, effectively clearing that row."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "update_screen_widgets", "line_number": 79, "body": "def update_screen_widgets(self, available_screen_height):\n        max_screen_rows = available_screen_height // self.screen_row_height\n        target_screen_row_count = max(\n            min(\n                max_screen_rows,\n                self.header_row_count\n                + self.data_row_count\n                + self.footer_row_count\n                - self.first_visible_data_row_no,\n            ),\n            self.header_row_count + 1 + self.footer_row_count,\n        )\n        # target_screen_row_count = 30\n\n        # remove cells not required anymore ...\n        while self.screen_row_count > target_screen_row_count:\n            # print(\"removing\")\n            self._clear_screen_row(self.screen_row_count - 1)\n            self.screen_row_count -= 1\n\n        # ... or add cells that can be shown\n        while self.screen_row_count < target_screen_row_count:\n            # print(\"adding\")\n            for col in range(self.column_count):\n                w = self.get_data_widget(self.screen_row_count, col)\n                w.grid(\n                    row=self.screen_row_count, column=col, sticky=\"nsew\", pady=(0, 1), padx=(0, 1)\n                )\n\n            self.screen_row_count += 1\n\n        self.visible_data_row_count = (\n            self.screen_row_count - self.header_row_count - self.footer_row_count\n        )", "is_method": true, "class_name": "GridTable", "function_description": "Dynamically adjusts the number of visible rows in the grid table. It adds or removes screen widgets to match the available display height."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "update_screen_data", "line_number": 114, "body": "def update_screen_data(self):\n        self.update_screen_widgets(self.winfo_height())\n        for screen_row_no in range(self.header_row_count, self.screen_row_count):\n            data_row_no = self.first_visible_data_row_no + screen_row_no - self.header_row_count\n            if data_row_no == self.data_row_count:\n                break\n\n            for col_no in range(self.column_count):\n                w = self.get_data_widget(screen_row_no, col_no)\n                value = self.get_data_value(data_row_no, col_no)\n                if value is None:\n                    w.configure(text=\"\")\n                else:\n                    w.configure(text=str(value))", "is_method": true, "class_name": "GridTable", "function_description": "Refreshes the visible cells of the GridTable, populating them with current data values. This ensures the UI accurately reflects the underlying dataset."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "get_data_value", "line_number": 129, "body": "def get_data_value(self, row_no, col_no):\n        \"\"\"lazy dict version:\n        assert 0 <= row_no < self.data_row_count\n        if row_no in self.data_rows:\n            return self.data_rows[row_no][col_no]\n        else:\n            return \"\"\n        \"\"\"\n        return self.data_rows[row_no][col_no]", "is_method": true, "class_name": "GridTable", "function_description": "Retrieves the data value from a specific cell (row and column) within the grid table. It provides direct access to individual data points."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "get_header_value", "line_number": 139, "body": "def get_header_value(self, row_no, col_no):\n        return self.header_rows[row_no][col_no]", "is_method": true, "class_name": "GridTable", "function_description": "Retrieves the value of a specific header cell in the grid table based on its row and column coordinates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "on_configure", "line_number": 142, "body": "def on_configure(self, event):\n        # query row height\n        _, _, _, height = self.grid_bbox(row=1)\n        if height > 10 and height < 100:\n            \"self.screen_row_height = height + 2\"\n\n        # screen_available_height = self.winfo_height()\n\n        # print(\"HE\", self.winfo_height(), event.height, self.screen_row_height)\n        self.update_screen_widgets(event.height)\n\n        self.update_screen_data()", "is_method": true, "class_name": "GridTable", "function_description": "Responds to grid configuration events, such as resizing, by updating the visible widgets and the data displayed within the grid."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "debug", "line_number": 196, "body": "def debug(self, event=None):\n        print(\"DE\", self.vscrollbar.get())", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "Provides a simple debugging printout of the vertical scrollbar's current position within the table."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "create_infopanel", "line_number": 199, "body": "def create_infopanel(self, data_row_count):\n        self.infopanel = ttk.Frame(self)\n        self.size_label = ttk.Label(self.infopanel, text=str(data_row_count) + \" rows\")\n        self.size_label.grid(row=0, column=0, padx=5)", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "This method creates an information panel for the ScrollableGridTable. It displays the total number of data rows, providing a quick summary to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "_update_vertical_scrollbar", "line_number": 204, "body": "def _update_vertical_scrollbar(self):\n        first = self.grid_table.first_visible_data_row_no / self.grid_table.data_row_count\n        last = first + self.grid_table.visible_data_row_count / self.grid_table.data_row_count\n        # print(first, last, self.grid_table.visible_data_row_count)\n        self.vscrollbar.set(first, last)", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "Updates the vertical scrollbar's position and size to reflect the currently visible data rows within the grid table. This ensures the scrollbar accurately represents the table's scroll state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "_handle_vertical_scroll", "line_number": 210, "body": "def _handle_vertical_scroll(self, *args):\n        # print(\"vscroll\", args, self.vscrollbar.get())\n        if len(args) == 3 and args[0] == \"scroll\":\n            amount = int(args[1])\n            unit = args[2]\n            if unit == \"pages\":\n                amount *= self.grid_table.visible_data_row_count\n\n            self.grid_table.set_first_visible_data_row_no(\n                self.grid_table.first_visible_data_row_no + amount\n            )\n        else:\n            assert args[0] == \"moveto\"\n            pos = max(min(float(args[1]), 1.0), 0.0)\n            top_row = math.floor(\n                (self.grid_table.data_row_count - self.grid_table.visible_data_row_count + 1) * pos\n            )\n            self.grid_table.set_first_visible_data_row_no(top_row)\n\n        self._update_vertical_scrollbar()", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "Manages vertical scrollbar interactions for the grid table. It dynamically adjusts the currently visible data rows based on scroll commands or direct position jumps."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "_on_expose", "line_number": 231, "body": "def _on_expose(self, event):\n        self.update_idletasks()\n        self._configure_interior(event)", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "Handles GUI expose events for the `ScrollableGridTable`. It updates pending tasks and reconfigures the table's interior display to ensure proper rendering when visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/gridtable.py", "function": "_configure_interior", "line_number": 235, "body": "def _configure_interior(self, event):\n        # update the scrollbars to match the size of the inner frame\n        size = (self.interior.winfo_reqwidth(), self.canvas.winfo_height())\n        self.canvas.config(scrollregion=\"0 0 %s %s\" % size)\n        if (\n            self.interior.winfo_reqheight() != self.canvas.winfo_height()\n            and self.canvas.winfo_height() > 10\n        ):\n            # update the interior's height to fit canvas\n            self.canvas.itemconfigure(self.interior_id, height=self.canvas.winfo_height())\n\n        self._update_vertical_scrollbar()", "is_method": true, "class_name": "ScrollableGridTable", "function_description": "Aligns the scrollable area of the grid table's canvas with its interior content. This ensures proper scrolling behavior and vertical scrollbar synchronization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/first_run.py", "function": "add_combo", "line_number": 58, "body": "def add_combo(self, row, label_text, variable, values):\n        pady = 7\n        label = ttk.Label(self.main_frame, text=label_text)\n        label.grid(row=row, column=2, sticky=\"sw\", pady=(pady, 0))\n        assert isinstance(variable, tk.Variable)\n        combobox = ttk.Combobox(\n            self.main_frame,\n            exportselection=False,\n            textvariable=variable,\n            state=\"readonly\",\n            height=15,\n            width=20,\n            values=values,\n        )\n        combobox.grid(row=row, column=3, padx=(10, self.padx), sticky=\"sw\", pady=(pady, 0))", "is_method": true, "class_name": "FirstRunWindow", "function_description": "Provides a service to dynamically add a label and a read-only combobox widget to the window's main frame. This allows the FirstRunWindow to offer users a dropdown selection from predefined values."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/first_run.py", "function": "center", "line_number": 74, "body": "def center(self):\n        width = max(self.winfo_reqwidth(), 640)\n        height = max(self.winfo_reqheight(), 300)\n\n        screen_width = self.winfo_screenwidth()\n        screen_height = self.winfo_screenheight()\n\n        if screen_width > screen_height * 2:\n            # probably dual monitors\n            screen_width //= 2\n\n        left = max(int(screen_width / 2 - width / 2), 0)\n        top = max(int(screen_height / 2 - height / 2), 0)\n\n        # Positions the window in the center of the page.\n        self.geometry(\"+{}+{}\".format(left, top))", "is_method": true, "class_name": "FirstRunWindow", "function_description": "This method positions the `FirstRunWindow` directly in the center of the user's display. It calculates the optimal coordinates to ensure the window appears centrally regardless of screen dimensions or window size."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/first_run.py", "function": "on_ok", "line_number": 91, "body": "def on_ok(self):\n        if self.mode_variable.get() == RPI_MODE_TEXT:\n            self.conf.set_option(\"debugger.preferred_debugger\", \"faster\")\n            self.conf.set_option(\"view.ui_theme\", \"Raspberry Pi\")\n            self.conf.set_option(\"general.ui_mode\", \"simple\")\n\n        self.conf.set_option(\n            \"general.language\", languages.get_language_code_by_name(self.language_variable.get())\n        )\n\n        self.conf.save()\n\n        self.ok = True\n        self.destroy()", "is_method": true, "class_name": "FirstRunWindow", "function_description": "Persists initial application settings, including RPi mode and language, from the first-run wizard. This method saves the configuration and closes the window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "extract_text_range", "line_number": 7, "body": "def extract_text_range(source, text_range):\n    if isinstance(source, bytes):\n        # TODO: may be wrong encoding\n        source = source.decode(\"utf-8\")\n\n    lines = source.splitlines(True)\n    # get relevant lines\n    lines = lines[text_range.lineno - 1 : text_range.end_lineno]\n\n    # trim last and first lines\n    lines[-1] = lines[-1][: text_range.end_col_offset]\n    lines[0] = lines[0][text_range.col_offset :]\n    return \"\".join(lines)", "is_method": false, "function_description": "Extracts a specific text segment from a source string given its start and end line/column offsets. This provides precise isolation for purposes like code analysis or error reporting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "find_expression", "line_number": 22, "body": "def find_expression(start_node, text_range):\n    for node in ast.walk(start_node):\n        if (\n            isinstance(node, ast.expr)\n            and node.lineno == text_range.lineno\n            and node.col_offset == text_range.col_offset\n            and node.end_lineno == text_range.end_lineno\n            and node.end_col_offset == text_range.end_col_offset\n        ):\n            return node\n\n    return None", "is_method": false, "function_description": "Locates and returns the specific Abstract Syntax Tree (AST) expression node that exactly matches a given text range within a Python code structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "parse_source", "line_number": 36, "body": "def parse_source(source: bytes, filename=\"<unknown>\", mode=\"exec\", fallback_to_one_char=False):\n    root = ast.parse(source, filename, mode)\n    mark_text_ranges(root, source, fallback_to_one_char)\n    return root", "is_method": false, "function_description": "Parses Python source code into an Abstract Syntax Tree (AST). It further annotates AST nodes with precise text range information, enabling detailed code analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "get_last_child", "line_number": 42, "body": "def get_last_child(node, skip_incorrect=True):\n    \"\"\"Returns last focusable child expression or child statement\"\"\"\n\n    def ok_node(node):\n        if node is None:\n            return None\n\n        assert isinstance(node, (ast.expr, ast.stmt))\n\n        if skip_incorrect and getattr(node, \"incorrect_range\", False):\n            return None\n\n        return node\n\n    def last_ok(nodes):\n        for i in range(len(nodes) - 1, -1, -1):\n            if ok_node(nodes[i]):\n                node = nodes[i]\n                if isinstance(node, ast.Starred):\n                    if ok_node(node.value):\n                        return node.value\n                    else:\n                        return None\n                else:\n                    return nodes[i]\n\n        return None\n\n    if isinstance(node, ast.Call):\n        # TODO: take care of Python 3.5 updates (Starred etc.)\n        if hasattr(node, \"kwargs\") and ok_node(node.kwargs):\n            return node.kwargs\n        elif hasattr(node, \"starargs\") and ok_node(node.starargs):\n            return node.starargs\n        else:\n            kw_values = list(map(lambda x: x.value, node.keywords))\n            last_ok_kw = last_ok(kw_values)\n            if last_ok_kw:\n                return last_ok_kw\n            elif last_ok(node.args):\n                return last_ok(node.args)\n            else:\n                return ok_node(node.func)\n\n    elif isinstance(node, ast.BoolOp):\n        return last_ok(node.values)\n\n    elif isinstance(node, ast.BinOp):\n        if ok_node(node.right):\n            return node.right\n        else:\n            return ok_node(node.left)\n\n    elif isinstance(node, ast.Compare):\n        return last_ok(node.comparators)\n\n    elif isinstance(node, ast.UnaryOp):\n        return ok_node(node.operand)\n\n    elif isinstance(node, (ast.Tuple, ast.List, ast.Set)):\n        return last_ok(node.elts)\n\n    elif isinstance(node, ast.Dict):\n        # TODO: actually should pairwise check last value, then last key, etc.\n        return last_ok(node.values)\n\n    elif isinstance(\n        node, (ast.Index, ast.Return, ast.Assign, ast.AugAssign, ast.Yield, ast.YieldFrom)\n    ):\n        return ok_node(node.value)\n\n    elif isinstance(node, ast.Delete):\n        return last_ok(node.targets)\n\n    elif isinstance(node, ast.Expr):\n        return ok_node(node.value)\n\n    elif isinstance(node, ast.Assert):\n        if ok_node(node.msg):\n            return node.msg\n        else:\n            return ok_node(node.test)\n\n    elif isinstance(node, ast.Slice):\n        # [:]\n        if ok_node(node.step):\n            return node.step\n        elif ok_node(node.upper):\n            return node.upper\n        else:\n            return ok_node(node.lower)\n\n    elif isinstance(node, ast.ExtSlice):\n        # [:,:]\n        for dim in reversed(node.dims):\n            result = get_last_child(dim, skip_incorrect)\n            assert result is None or isinstance(result, ast.expr)\n            if result is not None:\n                return result\n        return None\n\n    elif isinstance(node, ast.Subscript):\n        result = get_last_child(node.slice, skip_incorrect)\n        if result is not None:\n            return result\n        else:\n            return node.value\n\n    elif isinstance(node, ast.Raise):\n        if ok_node(node.cause):\n            return node.cause\n        elif ok_node(node.exc):\n            return node.exc\n\n    elif isinstance(node, (ast.For, ast.While, ast.If, ast.With)):\n        return True  # There is last child, but I don't know which it will be\n\n    # TODO: pick more cases from here:\n    \"\"\"\n    (isinstance(node, (ast.IfExp, ast.ListComp, ast.SetComp, ast.DictComp, ast.GeneratorExp))\n            # or isinstance(node, ast.FunctionDef, ast.Lambda) and len(node.args.defaults) > 0\n                and (node.dest is not None or len(node.values) > 0))\n\n            #\"TODO: Import ja ImportFrom\"\n            # TODO: what about ClassDef ???\n    \"\"\"\n\n    return None", "is_method": false, "function_description": "Identifies and returns the last \"focusable\" child expression or statement within a given Abstract Syntax Tree (AST) node. It aids in navigating complex parsed code structures, useful for editor features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "mark_text_ranges", "line_number": 172, "body": "def mark_text_ranges(node, source: Union[bytes, str], fallback_to_one_char=False):\n    \"\"\"\n    Node is an AST, source is corresponding source as string.\n    Function adds recursively attributes end_lineno and end_col_offset to each node\n    which has attributes lineno and col_offset.\n    \"\"\"\n    from asttokens.asttokens import ASTTokens\n\n    if isinstance(source, bytes):\n        source = source.decode(\"utf8\")\n\n    ASTTokens(source, tree=node)\n    for child in ast.walk(node):\n        if hasattr(child, \"last_token\"):\n            child.end_lineno, child.end_col_offset = child.last_token.end\n\n            if hasattr(child, \"lineno\"):\n                # Fixes problems with some nodes like binop\n                child.lineno, child.col_offset = child.first_token.start\n\n        # some nodes stay without end info\n        if (\n            hasattr(child, \"lineno\")\n            and (not hasattr(child, \"end_lineno\") or not hasattr(child, \"end_col_offset\"))\n            and fallback_to_one_char\n        ):\n            child.end_lineno = child.lineno\n            child.end_col_offset = child.col_offset + 2", "is_method": false, "function_description": "Marks each node in an Abstract Syntax Tree (AST) with its precise start and end line/column offsets. This enables accurate mapping of AST nodes back to their source code text ranges."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "ok_node", "line_number": 45, "body": "def ok_node(node):\n        if node is None:\n            return None\n\n        assert isinstance(node, (ast.expr, ast.stmt))\n\n        if skip_incorrect and getattr(node, \"incorrect_range\", False):\n            return None\n\n        return node", "is_method": false, "function_description": "Determines if an Abstract Syntax Tree (AST) node is valid and should be processed. It returns the node if valid, optionally filtering out incorrect ones, or None otherwise."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ast_utils.py", "function": "last_ok", "line_number": 56, "body": "def last_ok(nodes):\n        for i in range(len(nodes) - 1, -1, -1):\n            if ok_node(nodes[i]):\n                node = nodes[i]\n                if isinstance(node, ast.Starred):\n                    if ok_node(node.value):\n                        return node.value\n                    else:\n                        return None\n                else:\n                    return nodes[i]\n\n        return None", "is_method": false, "function_description": "Locates the last valid node in a sequence by iterating backward. For `ast.Starred` nodes, it retrieves their validated inner value."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_current_breakpoints", "line_number": 1053, "body": "def get_current_breakpoints():\n    result = {}\n\n    for editor in get_workbench().get_editor_notebook().get_all_editors():\n        filename = editor.get_filename()\n        if filename:\n            linenos = editor.get_code_view().get_breakpoint_line_numbers()\n            if linenos:\n                result[filename] = linenos\n\n    return result", "is_method": false, "function_description": "This function retrieves all active breakpoints set across open editor files. It returns a dictionary mapping filenames to lists of breakpoint line numbers for debugging or session management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_saved_current_script_filename", "line_number": 1066, "body": "def get_saved_current_script_filename(force=True):\n    editor = get_workbench().get_editor_notebook().get_current_editor()\n    if not editor:\n        return None\n\n    filename = editor.get_filename(force)\n    if not filename:\n        return None\n\n    if editor.is_modified():\n        filename = editor.save_file()\n\n    return filename", "is_method": false, "function_description": "This function retrieves the filename of the currently active script in the editor, ensuring the file is saved to disk first if it has been modified. It provides the definitive path for the editor's current, saved content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "is_remote_path", "line_number": 1081, "body": "def is_remote_path(s):\n    return REMOTE_PATH_MARKER in s", "is_method": false, "function_description": "Checks if a given string path contains a predefined marker, indicating it refers to a remote location. This helps distinguish remote paths from local ones."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "is_local_path", "line_number": 1085, "body": "def is_local_path(s):\n    return not is_remote_path(s)", "is_method": false, "function_description": "Determines if a given path string refers to a local resource. It provides a boolean check for distinguishing local file system paths from remote ones."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_target_dirname_from_editor_filename", "line_number": 1089, "body": "def get_target_dirname_from_editor_filename(s):\n    if is_local_path(s):\n        return os.path.dirname(s)\n    else:\n        return universal_dirname(extract_target_path(s))", "is_method": false, "function_description": "Determines the target directory name from an editor-provided filename string. It adapts to both local file paths and universal path formats."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "extract_target_path", "line_number": 1096, "body": "def extract_target_path(s):\n    assert is_remote_path(s)\n    return s[s.find(REMOTE_PATH_MARKER) + len(REMOTE_PATH_MARKER) :]", "is_method": false, "function_description": "Extracts the pure target path component from a remote path string. It strips away the remote system identifier and its marker."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "make_remote_path", "line_number": 1101, "body": "def make_remote_path(target_path):\n    return get_runner().get_node_label() + REMOTE_PATH_MARKER + target_path", "is_method": false, "function_description": "Creates a remote-specific path by prepending a unique node label and a marker to the given target path. This function helps construct fully qualified paths for operations on remote systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_text_widget", "line_number": 69, "body": "def get_text_widget(self):\n        return self._code_view.text", "is_method": true, "class_name": "Editor", "function_description": "Retrieves the text widget from the editor's code view. This provides direct access to the editor's editable text content for further manipulation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_filename", "line_number": 76, "body": "def get_filename(self, try_hard=False):\n        if self._filename is None and try_hard:\n            self.save_file()\n\n        return self._filename", "is_method": true, "class_name": "Editor", "function_description": "Retrieves the filename for the editor's current content. If `try_hard` is true and no filename exists, it triggers a save operation to establish one."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_title", "line_number": 82, "body": "def get_title(self):\n        if self.get_filename() is None:\n            result = \"<untitled>\"\n        elif is_remote_path(self.get_filename()):\n            path = extract_target_path(self.get_filename())\n            name = path.split(\"/\")[-1]\n            result = \"[ \" + name + \" ]\"\n        else:\n            result = os.path.basename(self.get_filename())\n\n        if self.is_modified():\n            result += \" *\"\n\n        return result", "is_method": true, "class_name": "Editor", "function_description": "Generates a descriptive title for the editor's content, formatting it based on filename (local or remote), and indicating if the content is unsaved or modified."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "check_for_external_changes", "line_number": 97, "body": "def check_for_external_changes(self):\n        if self._asking_about_external_change:\n            # otherwise method will be re-entered when focus\n            # changes because of message box\n            return\n\n        if self._filename is None:\n            return\n\n        if is_remote_path(self._filename):\n            return\n\n        try:\n            self._asking_about_external_change = True\n\n            if self._last_known_mtime is None:\n                return\n\n            elif not os.path.exists(self._filename):\n                self.master.select(self)\n\n                if messagebox.askyesno(\n                    tr(\"File is gone\"),\n                    tr(\"Looks like '%s' was deleted or moved outside of the editor.\")\n                    % self._filename\n                    + \"\\n\\n\"\n                    + tr(\"Do you want to also close the editor?\"),\n                    master=self,\n                ):\n                    self.master.close_editor(self)\n                else:\n                    self.get_text_widget().edit_modified(True)\n                    self._last_known_mtime = None\n\n            elif os.path.getmtime(self._filename) != self._last_known_mtime:\n                self.master.select(self)\n\n                if messagebox.askyesno(\n                    tr(\"External modification\"),\n                    tr(\"Looks like '%s' was modified outside the editor.\") % self._filename\n                    + \"\\n\\n\"\n                    + tr(\n                        \"Do you want to discard current editor content and reload the file from disk?\"\n                    ),\n                    master=self,\n                ):\n                    self._load_file(self._filename, keep_undo=True)\n                else:\n                    self._last_known_mtime = os.path.getmtime(self._filename)\n        finally:\n            self._asking_about_external_change = False", "is_method": true, "class_name": "Editor", "function_description": "Monitors the editor's opened file for external modifications or deletion. It prompts the user to reload the file or close the editor to ensure data consistency."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_long_description", "line_number": 149, "body": "def get_long_description(self):\n\n        if self._filename is None:\n            result = \"<untitled>\"\n        else:\n            result = self._filename\n\n        try:\n            index = self._code_view.text.index(\"insert\")\n            if index and \".\" in index:\n                line, col = index.split(\".\")\n                result += \"  @  {} : {}\".format(line, int(col) + 1)\n        except Exception:\n            exception(\"Finding cursor location\")\n\n        return result", "is_method": true, "class_name": "Editor", "function_description": "Generates a descriptive string for the editor, indicating the filename and the current cursor's line and column. This can be used for display or status updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_load_file", "line_number": 166, "body": "def _load_file(self, filename, keep_undo=False):\n        try:\n            if is_remote_path(filename):\n                result = self._load_remote_file(filename)\n            else:\n                result = self._load_local_file(filename, keep_undo)\n                if not result:\n                    return False\n        except BinaryFileException:\n            messagebox.showerror(\n                \"Problem\", \"%s doesn't look like a text file\" % filename, master=self\n            )\n            return False\n        except SyntaxError as e:\n            assert \"encoding\" in str(e).lower()\n            messagebox.showerror(\n                \"Problem loading file\",\n                \"This file seems to have problems with encoding.\\n\\n\"\n                + \"Make sure it is in UTF-8 or contains proper encoding hint.\",\n                master=self,\n            )\n            return False\n\n        self.update_appearance()\n        return True", "is_method": true, "class_name": "Editor", "function_description": "Loads a file into the editor, supporting both local and remote paths. It handles common loading errors such as binary files or encoding issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_load_local_file", "line_number": 192, "body": "def _load_local_file(self, filename, keep_undo=False):\n        with open(filename, \"rb\") as fp:\n            source = fp.read()\n\n        # Make sure Windows filenames have proper format\n        filename = normpath_with_actual_case(filename)\n        self._filename = filename\n        self.update_file_type()\n        self._last_known_mtime = os.path.getmtime(self._filename)\n\n        get_workbench().event_generate(\"Open\", editor=self, filename=filename)\n        if not self._code_view.set_content_as_bytes(source, keep_undo):\n            return False\n        self.get_text_widget().edit_modified(False)\n        self._code_view.focus_set()\n        self.master.remember_recent_file(filename)\n        return True", "is_method": true, "class_name": "Editor", "function_description": "Provides the Editor with the capability to open and load the content of a local file, updating its internal state and view for editing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_load_remote_file", "line_number": 210, "body": "def _load_remote_file(self, filename):\n        self._filename = filename\n        self.update_file_type()\n        self._code_view.set_content(\"\")\n        self._code_view.text.set_read_only(True)\n\n        target_filename = extract_target_path(self._filename)\n\n        self.update_title()\n        response = get_runner().send_command_and_wait(\n            InlineCommand(\n                \"read_file\", path=target_filename, description=tr(\"Loading %s\") % target_filename\n            ),\n            dialog_title=tr(\"Loading\"),\n        )\n\n        if response.get(\"error\"):\n            # TODO: make it softer\n            raise RuntimeError(response[\"error\"])\n\n        content = response[\"content_bytes\"]\n        self._code_view.text.set_read_only(False)\n        if not self._code_view.set_content_as_bytes(content):\n            return False\n        self.get_text_widget().edit_modified(False)\n        self.update_title()\n        return True", "is_method": true, "class_name": "Editor", "function_description": "Provides the core service of loading a remote file's content into the editor. It asynchronously fetches the file via a runner and displays it for editing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "is_modified", "line_number": 238, "body": "def is_modified(self):\n        return bool(self._code_view.text.edit_modified())", "is_method": true, "class_name": "Editor", "function_description": "The Editor method checks if the current code or text content within the editor has been modified since its last state. It enables features like prompting to save changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "save_file_enabled", "line_number": 241, "body": "def save_file_enabled(self):\n        return self.is_modified() or not self.get_filename()", "is_method": true, "class_name": "Editor", "function_description": "Determines if the save functionality should be active for the current editor state. It enables saving if content is modified or the file is new."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "save_file", "line_number": 244, "body": "def save_file(self, ask_filename=False, save_copy=False, node=None):\n        if self._filename is not None and not ask_filename:\n            save_filename = self._filename\n            get_workbench().event_generate(\"Save\", editor=self, filename=save_filename)\n        else:\n            save_filename = self.ask_new_path(node)\n\n            if not save_filename:\n                return None\n\n            if self.notebook.get_editor(save_filename) is not None:\n                messagebox.showerror(\n                    \"File is open\",\n                    \"This file is already open in Thonny.\\n\\n\"\n                    \"If you want to save with this name,\\n\"\n                    \"close the existing editor first!\",\n                    master=get_workbench(),\n                )\n                return None\n\n            get_workbench().event_generate(\n                \"SaveAs\", editor=self, filename=save_filename, save_copy=save_copy\n            )\n\n        content_bytes = self._code_view.get_content_as_bytes()\n\n        if is_remote_path(save_filename):\n            result = self.write_remote_file(save_filename, content_bytes, save_copy)\n        else:\n            result = self.write_local_file(save_filename, content_bytes, save_copy)\n\n        if not result:\n            return None\n\n        if not save_copy:\n            self._filename = save_filename\n            self.update_file_type()\n\n        self.update_title()\n        return save_filename", "is_method": true, "class_name": "Editor", "function_description": "Allows the Editor to save its current content to a file. It handles saving to the existing file or prompting for a new filename, supporting both local and remote file systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "write_local_file", "line_number": 285, "body": "def write_local_file(self, save_filename, content_bytes, save_copy):\n        try:\n            f = open(save_filename, mode=\"wb\")\n            f.write(content_bytes)\n            f.flush()\n            # Force writes on disk, see https://learn.adafruit.com/adafruit-circuit-playground-express/creating-and-editing-code#1-use-an-editor-that-writes-out-the-file-completely-when-you-save-it\n            os.fsync(f)\n            f.close()\n            if not save_copy or save_filename == self._filename:\n                self._last_known_mtime = os.path.getmtime(save_filename)\n            get_workbench().event_generate(\n                \"LocalFileOperation\", path=save_filename, operation=\"save\"\n            )\n        except PermissionError:\n            messagebox.showerror(\n                \"Permission Error\", \"Looks like this file or folder is not writable.\", master=self\n            )\n            return False\n\n        if not save_copy or save_filename == self._filename:\n            self.master.remember_recent_file(save_filename)\n\n        if not save_copy or save_filename == self._filename:\n            self._code_view.text.edit_modified(False)\n\n        return True", "is_method": true, "class_name": "Editor", "function_description": "Writes specified content bytes to a local file, ensuring robust disk synchronization. It updates the editor's internal state, including modification status and recent files, while handling permission errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "update_file_type", "line_number": 312, "body": "def update_file_type(self):\n        if self._filename is None:\n            self._code_view.set_file_type(None)\n        else:\n            ext = self._filename.split(\".\")[-1].lower()\n            if ext in [\"py\", \"pyw\", \"pyi\"]:\n                file_type = \"python\"\n            else:\n                file_type = None\n\n            self._code_view.set_file_type(file_type)\n\n        self.update_appearance()", "is_method": true, "class_name": "Editor", "function_description": "This method updates the associated code view's file type based on the current file's extension. It automatically sets the file type to \"python\" for Python files, enabling correct syntax highlighting and appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "write_remote_file", "line_number": 326, "body": "def write_remote_file(self, save_filename, content_bytes, save_copy):\n        if get_runner().ready_for_remote_file_operations(show_message=True):\n            target_filename = extract_target_path(save_filename)\n\n            get_runner().send_command_and_wait(\n                InlineCommand(\n                    \"write_file\",\n                    path=target_filename,\n                    content_bytes=content_bytes,\n                    editor_id=id(self),\n                    blocking=True,\n                    description=tr(\"Saving to %s\") % target_filename,\n                ),\n                dialog_title=tr(\"Saving\"),\n            )\n\n            if not save_copy:\n                self._code_view.text.edit_modified(False)\n\n            self.update_title()\n\n            # NB! edit_modified is not falsed yet!\n            get_workbench().event_generate(\n                \"RemoteFileOperation\", path=target_filename, operation=\"save\"\n            )\n            get_workbench().event_generate(\"RemoteFilesChanged\")\n            return True\n        else:\n            return False", "is_method": true, "class_name": "Editor", "function_description": "This function provides the capability to save the editor's content to a specified remote file. It manages the remote writing process and updates the editor's internal state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "ask_new_path", "line_number": 356, "body": "def ask_new_path(self, node=None):\n        if node is None:\n            node = choose_node_for_file_operations(self.winfo_toplevel(), \"Where to save to?\")\n        if not node:\n            return None\n\n        if node == \"local\":\n            return self.ask_new_local_path()\n        else:\n            assert node == \"remote\"\n            return self.ask_new_remote_path()", "is_method": true, "class_name": "Editor", "function_description": "Guides the user to specify a new file path, handling the choice between local and remote storage. This method is crucial for operations like saving or moving files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "ask_new_remote_path", "line_number": 368, "body": "def ask_new_remote_path(self):\n        target_path = ask_backend_path(self.winfo_toplevel(), \"save\")\n        if target_path:\n            return make_remote_path(target_path)\n        else:\n            return None", "is_method": true, "class_name": "Editor", "function_description": "This method prompts the user to select a new save location. It then converts the chosen path into a remote path format, enabling the editor to save or publish content to a specified remote destination."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "ask_new_local_path", "line_number": 375, "body": "def ask_new_local_path(self):\n        if self._filename is None:\n            initialdir = get_workbench().get_local_cwd()\n            initialfile = None\n        else:\n            initialdir = os.path.dirname(self._filename)\n            initialfile = os.path.basename(self._filename)\n\n        # http://tkinter.unpythonic.net/wiki/tkFileDialog\n        new_filename = asksaveasfilename(\n            filetypes=_dialog_filetypes,\n            defaultextension=\".py\",\n            initialdir=initialdir,\n            initialfile=initialfile,\n            parent=get_workbench(),\n        )\n\n        # Different tkinter versions may return different values\n        if new_filename in [\"\", (), None]:\n            return None\n\n        # Seems that in some Python versions defaultextension\n        # acts funny\n        if new_filename.lower().endswith(\".py.py\"):\n            new_filename = new_filename[:-3]\n\n        if running_on_windows():\n            # may have /-s instead of \\-s and wrong case\n            new_filename = os.path.join(\n                normpath_with_actual_case(os.path.dirname(new_filename)),\n                os.path.basename(new_filename),\n            )\n\n        if new_filename.endswith(\".py\"):\n            base = os.path.basename(new_filename)\n            mod_name = base[:-3].lower()\n            if running_on_windows():\n                mod_name = mod_name.lower()\n\n            if mod_name in [\n                \"math\",\n                \"turtle\",\n                \"random\",\n                \"statistics\",\n                \"pygame\",\n                \"matplotlib\",\n                \"numpy\",\n            ]:\n\n                # More proper name analysis will be performed by ProgramNamingAnalyzer\n                if not tk.messagebox.askyesno(\n                    \"Potential problem\",\n                    \"If you name your script '%s', \" % base\n                    + \"you won't be able to import the library module named '%s'\" % mod_name\n                    + \".\\n\\n\"\n                    + \"Do you still want to use this name for your script?\",\n                    master=self,\n                ):\n                    return self.ask_new_local_path()\n\n        return new_filename", "is_method": true, "class_name": "Editor", "function_description": "Presents a \"Save As\" dialog to the user, allowing them to choose a new file path for the editor's content. It validates the chosen name, warning about potential conflicts with Python's built-in modules."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "show", "line_number": 437, "body": "def show(self):\n        self.master.select(self)", "is_method": true, "class_name": "Editor", "function_description": "Activates or displays this editor instance within its master container, making it the current focus for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "update_appearance", "line_number": 440, "body": "def update_appearance(self):\n        self._code_view.set_gutter_visibility(\n            get_workbench().get_option(\"view.show_line_numbers\") or get_workbench().in_simple_mode()\n        )\n        self._code_view.set_line_length_margin(\n            get_workbench().get_option(\"view.recommended_line_length\")\n        )\n        self._code_view.text.update_tabs()\n        self._code_view.text.event_generate(\"<<UpdateAppearance>>\")", "is_method": true, "class_name": "Editor", "function_description": "Applies current visual settings to the editor's code view, adjusting elements like line numbers, line length margin, and tab display. It ensures the editor's appearance reflects user preferences or system modes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_listen_debugger_progress", "line_number": 450, "body": "def _listen_debugger_progress(self, event):\n        # Go read-only\n        # TODO: check whether this module is active?\n        self._code_view.text.set_read_only(True)", "is_method": true, "class_name": "Editor", "function_description": "This method sets the editor's code view to read-only when a debugger event indicates progress, preventing user modifications during active debugging sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_listen_for_toplevel_response", "line_number": 455, "body": "def _listen_for_toplevel_response(self, event: ToplevelResponse) -> None:\n        self._code_view.text.set_read_only(False)", "is_method": true, "class_name": "Editor", "function_description": "As an event handler, this method re-enables text input in the editor's code view when a `ToplevelResponse` event is received."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_control_tab", "line_number": 458, "body": "def _control_tab(self, event):\n        if event.state & 1:  # shift was pressed\n            direction = -1\n        else:\n            direction = 1\n        self.master.select_next_prev_editor(direction)\n        return \"break\"", "is_method": true, "class_name": "Editor", "function_description": "Handles keyboard events (e.g., Tab/Shift+Tab) to cycle through open editor instances. It switches focus to the next or previous editor within the parent window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_shift_control_tab", "line_number": 466, "body": "def _shift_control_tab(self, event):\n        self.master.select_next_prev_editor(-1)\n        return \"break\"", "is_method": true, "class_name": "Editor", "function_description": "This method switches focus to the previous editor instance within a multi-editor environment. It provides keyboard-driven navigation capability for efficient workspace management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "select_range", "line_number": 470, "body": "def select_range(self, text_range):\n        self._code_view.select_range(text_range)", "is_method": true, "class_name": "Editor", "function_description": "Allows the editor to select a specific range of text. This enables programmatic highlighting or manipulation within the displayed content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "select_line", "line_number": 473, "body": "def select_line(self, lineno, col_offset=None):\n        self._code_view.select_range(TextRange(lineno, 0, lineno + 1, 0))\n        self.see_line(lineno)\n\n        if col_offset is None:\n            col_offset = 0\n\n        self.get_text_widget().mark_set(\"insert\", \"%d.%d\" % (lineno, col_offset))", "is_method": true, "class_name": "Editor", "function_description": "Selects a specific line within the editor, makes it visible, and positions the text cursor on that line, optionally at a given column."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "see_line", "line_number": 482, "body": "def see_line(self, lineno):\n        # first see an earlier line in order to push target line downwards\n        self._code_view.text.see(\"%d.0\" % max(lineno - 4, 1))\n        self._code_view.text.see(\"%d.0\" % lineno)", "is_method": true, "class_name": "Editor", "function_description": "Makes a specified line number visible within the editor's code display, positioning it clearly in the user's view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "focus_set", "line_number": 487, "body": "def focus_set(self):\n        self._code_view.focus_set()", "is_method": true, "class_name": "Editor", "function_description": "Sets the keyboard input focus on the editor's code viewing area. This allows the user to directly interact with and type into the code display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "is_focused", "line_number": 490, "body": "def is_focused(self):\n        return self.focus_displayof() == self._code_view.text", "is_method": true, "class_name": "Editor", "function_description": "Determines if the editor's primary code view is currently the active, focused display element. This indicates user interaction with the code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_on_text_modified", "line_number": 493, "body": "def _on_text_modified(self, event):\n        self.update_title()", "is_method": true, "class_name": "Editor", "function_description": "An internal handler for the Editor class, it updates the editor's title in response to text modification events, ensuring the title reflects the current document state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "update_title", "line_number": 496, "body": "def update_title(self):\n        try:\n            self.master.update_editor_title(self)\n        except Exception as e:\n            logger.exception(\"Could not update editor title\", exc_info=e)", "is_method": true, "class_name": "Editor", "function_description": "Requests its master to update the editor's display title, ensuring UI consistency."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_on_text_change", "line_number": 502, "body": "def _on_text_change(self, event):\n        self.update_title()", "is_method": true, "class_name": "Editor", "function_description": "Updates the editor's title when the text content changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "destroy", "line_number": 505, "body": "def destroy(self):\n        get_workbench().unbind(\"DebuggerResponse\", self._listen_debugger_progress)\n        get_workbench().unbind(\"ToplevelResponse\", self._listen_for_toplevel_response)\n        ttk.Frame.destroy(self)", "is_method": true, "class_name": "Editor", "function_description": "This method properly shuts down the editor instance, unbinding associated event listeners and destroying its graphical user interface frame to release resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_init_commands", "line_number": 549, "body": "def _init_commands(self):\n        # TODO: do these commands have to be in EditorNotebook ??\n        # Create a module level function install_editor_notebook ??\n        # Maybe add them separately, when notebook has been installed ??\n\n        get_workbench().add_command(\n            \"new_file\",\n            \"file\",\n            tr(\"New\"),\n            self._cmd_new_file,\n            caption=tr(\"New\"),\n            default_sequence=select_sequence(\"<Control-n>\", \"<Command-n>\"),\n            extra_sequences=[\"<Control-Greek_nu>\"],\n            group=10,\n            image=\"new-file\",\n            include_in_toolbar=True,\n        )\n\n        get_workbench().add_command(\n            \"open_file\",\n            \"file\",\n            tr(\"Open...\"),\n            self._cmd_open_file,\n            caption=tr(\"Load\"),\n            default_sequence=select_sequence(\"<Control-o>\", \"<Command-o>\"),\n            extra_sequences=[\"<Control-Greek_omicron>\"],\n            group=10,\n            image=\"open-file\",\n            include_in_toolbar=True,\n        )\n\n        get_workbench().add_command(\n            \"recents\", \"file\", tr(\"Recent files\"), group=10, submenu=self._recent_menu\n        )\n\n        # http://stackoverflow.com/questions/22907200/remap-default-keybinding-in-tkinter\n        get_workbench().bind_class(\"Text\", \"<Control-o>\", self._control_o)\n        get_workbench().bind_class(\"Text\", \"<Control-Greek_omicron>\", self._control_o)\n        rebind_control_a(get_workbench())\n\n        get_workbench().add_command(\n            \"close_file\",\n            \"file\",\n            tr(\"Close\"),\n            self._cmd_close_file,\n            default_sequence=select_sequence(\"<Control-w>\", \"<Command-w>\"),\n            extra_sequences=[\"<Control-Greek_finalsmallsigma>\"],\n            tester=lambda: self.get_current_editor() is not None,\n            group=10,\n        )\n\n        get_workbench().add_command(\n            \"close_files\",\n            \"file\",\n            tr(\"Close all\"),\n            self.close_tabs,\n            tester=lambda: self.get_current_editor() is not None,\n            default_sequence=select_sequence(\"<Control-W>\", \"<Command-Alt-w>\"),\n            group=10,\n        )\n\n        get_workbench().add_command(\n            \"save_file\",\n            \"file\",\n            tr(\"Save\"),\n            self._cmd_save_file,\n            caption=tr(\"Save\"),\n            default_sequence=select_sequence(\"<Control-s>\", \"<Command-s>\"),\n            extra_sequences=[\"<Control-Greek_sigma>\"],\n            tester=self._cmd_save_file_enabled,\n            group=10,\n            image=\"save-file\",\n            include_in_toolbar=True,\n        )\n\n        get_workbench().add_command(\n            \"save_all_files\",\n            \"file\",\n            tr(\"Save All files\"),\n            self._cmd_save_all_files,\n            caption=tr(\"Save All files\"),\n            default_sequence=select_sequence(\"<Control-Alt-s>\", \"<Command-Alt-s>\"),\n            tester=self._cmd_save_all_files_enabled,\n            group=10,\n        )\n\n        get_workbench().add_command(\n            \"save_file_as\",\n            \"file\",\n            tr(\"Save as...\"),\n            self._cmd_save_file_as,\n            default_sequence=select_sequence(\"<Control-Shift-S>\", \"<Command-Shift-s>\"),\n            extra_sequences=[\"<Control-Greek_SIGMA>\"],\n            tester=lambda: self.get_current_editor() is not None,\n            group=10,\n        )\n\n        get_workbench().add_command(\n            \"save_copy\",\n            \"file\",\n            tr(\"Save copy...\"),\n            self._cmd_save_copy,\n            tester=lambda: self.get_current_editor() is not None,\n            group=10,\n        )\n\n        get_workbench().add_command(\n            \"move_rename_file\",\n            \"file\",\n            tr(\"Move / rename...\"),\n            self._cmd_move_rename_file,\n            tester=self._cmd_move_rename_file_enabled,\n            group=10,\n        )\n\n        get_workbench().createcommand(\"::tk::mac::OpenDocument\", self._mac_open_document)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Registers core file management commands (new, open, save, close) and their keyboard shortcuts with the editor's workbench. This sets up essential user interface actions for file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "load_startup_files", "line_number": 666, "body": "def load_startup_files(self):\n        \"\"\"If no filename was sent from command line\n        then load previous files (if setting allows)\"\"\"\n\n        cmd_line_filenames = [\n            os.path.abspath(name) for name in sys.argv[1:] if os.path.exists(name)\n        ]\n\n        if len(cmd_line_filenames) > 0:\n            filenames = cmd_line_filenames\n        elif get_workbench().get_option(\"file.reopen_all_files\"):\n            filenames = get_workbench().get_option(\"file.open_files\")\n        elif get_workbench().get_option(\"file.current_file\"):\n            filenames = [get_workbench().get_option(\"file.current_file\")]\n        else:\n            filenames = []\n\n        if len(filenames) > 0:\n            for filename in filenames:\n                if os.path.exists(filename):\n                    self.show_file(filename)\n\n            cur_file = get_workbench().get_option(\"file.current_file\")\n            # choose correct active file\n            if len(cmd_line_filenames) > 0:\n                self.show_file(cmd_line_filenames[0])\n            elif cur_file and os.path.exists(cur_file):\n                self.show_file(cur_file)\n            else:\n                self._cmd_new_file()\n        else:\n            self._cmd_new_file()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Loads files into the editor notebook upon startup. It prioritizes command-line files, then previously opened files, ensuring the correct initial display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "save_all_named_editors", "line_number": 699, "body": "def save_all_named_editors(self):\n        all_saved = True\n        for editor in self.winfo_children():\n            if editor.get_filename() and editor.is_modified():\n                success = editor.save_file()\n                all_saved = all_saved and success\n\n        return all_saved", "is_method": true, "class_name": "EditorNotebook", "function_description": "This method iterates through and saves all modified editors that have an associated file within the notebook. It provides a convenient way to persist changes across multiple open documents."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "remember_recent_file", "line_number": 708, "body": "def remember_recent_file(self, filename):\n        recents = get_workbench().get_option(\"file.recent_files\")\n        if filename in recents:\n            recents.remove(filename)\n        recents.insert(0, filename)\n        relevant_recents = [name for name in recents if os.path.exists(name)][:15]\n        get_workbench().set_option(\"file.recent_files\", relevant_recents)\n        self._update_recent_menu()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Manages the editor's list of recent files, placing the specified file at the top. It maintains a concise, valid history of accessed files for quick user navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_update_recent_menu", "line_number": 717, "body": "def _update_recent_menu(self):\n        recents = get_workbench().get_option(\"file.recent_files\")\n        relevant_recents = [\n            path for path in recents if os.path.exists(path) and not self.file_is_opened(path)\n        ]\n        self._recent_menu.delete(0, \"end\")\n        for path in relevant_recents:\n\n            def load(path=path):\n                self.show_file(path)\n\n            self._recent_menu.insert_command(\"end\", label=path, command=load)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Updates the editor's 'recent files' menu, ensuring it lists only existing, unopened documents. This provides users a convenient way to quickly access previously opened files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "remember_open_files", "line_number": 730, "body": "def remember_open_files(self):\n        if (\n            self.get_current_editor() is not None\n            and self.get_current_editor().get_filename() is not None\n        ):\n            current_file = self.get_current_editor().get_filename()\n        else:\n            current_file = None\n\n        get_workbench().set_option(\"file.current_file\", current_file)\n\n        open_files = [\n            editor.get_filename() for editor in self.winfo_children() if editor.get_filename()\n        ]\n        get_workbench().set_option(\"file.open_files\", open_files)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Stores the active file and all open file paths from the editor notebook. This allows the application to remember the user's editing session state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_new_file", "line_number": 746, "body": "def _cmd_new_file(self):\n        new_editor = Editor(self)\n        get_workbench().event_generate(\"NewFile\", editor=new_editor)\n        self.add(new_editor, text=new_editor.get_title())\n        self.select(new_editor)\n        new_editor.focus_set()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Creates and integrates a new editor for a blank file into the EditorNotebook. It activates the new editor and signals its creation to the workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_open_file", "line_number": 753, "body": "def _cmd_open_file(self):\n        node = choose_node_for_file_operations(self.winfo_toplevel(), \"Where to open from?\")\n        if not node:\n            return\n\n        if node == \"local\":\n            initialdir = get_workbench().get_local_cwd()\n            if (\n                self.get_current_editor() is not None\n                and self.get_current_editor().get_filename() is not None\n            ):\n                initialdir = os.path.dirname(self.get_current_editor().get_filename())\n            path = askopenfilename(\n                filetypes=_dialog_filetypes, initialdir=initialdir, parent=get_workbench()\n            )\n        else:\n            assert node == \"remote\"\n            target_path = ask_backend_path(self.winfo_toplevel(), \"open\")\n            if not target_path:\n                return\n\n            path = make_remote_path(target_path)\n\n        if path:\n            # self.close_single_untitled_unmodified_editor()\n            self.show_file(path, propose_dialog=False)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Enables the user to open a file, prompting for its location (local or remote). It then displays the selected file within the editor notebook."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_control_o", "line_number": 780, "body": "def _control_o(self, event):\n        # http://stackoverflow.com/questions/22907200/remap-default-keybinding-in-tkinter\n        self._cmd_open_file()\n        return \"break\"", "is_method": true, "class_name": "EditorNotebook", "function_description": "Handles the Ctrl+O keyboard shortcut within the EditorNotebook, triggering the command to open a file."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_close_files", "line_number": 785, "body": "def _close_files(self, except_index=None):\n\n        for tab_index in reversed(range(len(self.winfo_children()))):\n            if except_index is not None and tab_index == except_index:\n                continue\n            else:\n                editor = self.get_child_by_index(tab_index)\n                if self.check_allow_closing(editor):\n                    self.forget(editor)\n                    editor.destroy()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Provides the capability to close multiple editor tabs in the notebook. It systematically closes all tabs, with an option to keep one specified tab open."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_close_file", "line_number": 796, "body": "def _cmd_close_file(self):\n        self.close_tab(self.index(self.select()))", "is_method": true, "class_name": "EditorNotebook", "function_description": "Closes the currently selected or active file tab in the editor notebook. This provides a user command to manage open documents."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "close_tab", "line_number": 799, "body": "def close_tab(self, index):\n        editor = self.get_child_by_index(index)\n\n        if editor:\n            self.close_editor(editor)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Closes the editor tab located at the specified index within the notebook."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "close_editor", "line_number": 805, "body": "def close_editor(self, editor, force=False):\n        if not force and not self.check_allow_closing(editor):\n            return\n        self.forget(editor)\n        editor.destroy()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Closes a specified editor instance, optionally bypassing safety checks. It removes the editor from the notebook's internal management and destroys its associated resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_file", "line_number": 811, "body": "def _cmd_save_file(self):\n        if self.get_current_editor():\n            self.get_current_editor().save_file()\n            self.update_editor_title(self.get_current_editor())", "is_method": true, "class_name": "EditorNotebook", "function_description": "Saves the content of the currently active editor and updates its display title within the notebook."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_file_enabled", "line_number": 816, "body": "def _cmd_save_file_enabled(self):\n        return self.get_current_editor() and self.get_current_editor().save_file_enabled()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Determines if an active editor exists and if saving the current file is enabled within that editor. This indicates whether a 'save' command should be actionable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_all_files", "line_number": 819, "body": "def _cmd_save_all_files(self):\n        for editor in self.get_all_editors():\n            if editor.save_file_enabled() == True:\n                editor.save_file()\n                self.update_editor_title(editor)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Saves all open files managed by the notebook, updating their titles upon successful save."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_all_files_enabled", "line_number": 825, "body": "def _cmd_save_all_files_enabled(self):\n        for editor in self.get_all_editors():\n            if editor.save_file_enabled() == True:\n                return True\n        return False", "is_method": true, "class_name": "EditorNotebook", "function_description": "Checks if any active editor within the notebook has changes that can be saved. This function determines if a \"Save All Files\" action is applicable and should be enabled."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_file_as", "line_number": 831, "body": "def _cmd_save_file_as(self, node=None):\n        if not self.get_current_editor():\n            return\n\n        self.get_current_editor().save_file(ask_filename=True, node=node)\n        self.update_editor_title(self.get_current_editor())\n        get_workbench().update_title()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Enables saving the current editor's content to a new file, prompting the user for the filename. It updates relevant UI elements after saving."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_copy", "line_number": 839, "body": "def _cmd_save_copy(self):\n        if not self.get_current_editor():\n            return\n\n        self.get_current_editor().save_file(ask_filename=True, save_copy=True)\n        self.update_editor_title(self.get_current_editor())", "is_method": true, "class_name": "EditorNotebook", "function_description": "Provides the capability to save the current editor's content as a copy to a new file. It prompts the user for a new filename."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_save_file_as_enabled", "line_number": 846, "body": "def _cmd_save_file_as_enabled(self):\n        return self.get_current_editor() is not None", "is_method": true, "class_name": "EditorNotebook", "function_description": "Checks if the 'Save File As' command should be enabled. It returns true if an active editor exists, indicating a file is open for saving."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_move_rename_file", "line_number": 849, "body": "def _cmd_move_rename_file(self):\n        editor = self.get_current_editor()\n        old_filename = editor.get_filename()\n        assert old_filename is not None\n\n        if is_remote_path(old_filename):\n            node = \"remote\"\n        else:\n            node = \"local\"\n\n        self._cmd_save_file_as(node=node)\n\n        if editor.get_filename() != old_filename:\n            if is_remote_path(old_filename):\n                remote_path = extract_target_path(old_filename)\n                get_runner().send_command_and_wait(\n                    InlineCommand(\n                        \"delete\", paths=[remote_path], description=tr(\"Deleting\" + remote_path)\n                    ),\n                    dialog_title=tr(\"Deleting\"),\n                )\n                get_workbench().event_generate(\n                    \"RemoteFileOperation\", path=remote_path, operation=\"delete\"\n                )\n            else:\n                os.remove(old_filename)\n                get_workbench().event_generate(\n                    \"LocalFileOperation\", path=old_filename, operation=\"delete\"\n                )", "is_method": true, "class_name": "EditorNotebook", "function_description": "Handles renaming or moving the active file in the editor. It saves the file to a new path and deletes the original, supporting both local and remote operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_cmd_move_rename_file_enabled", "line_number": 879, "body": "def _cmd_move_rename_file_enabled(self):\n        return self.get_current_editor() and self.get_current_editor().get_filename() is not None", "is_method": true, "class_name": "EditorNotebook", "function_description": "Determines if the \"move or rename file\" command can be enabled. It checks if an active editor is present and has a file open."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "close_single_untitled_unmodified_editor", "line_number": 882, "body": "def close_single_untitled_unmodified_editor(self):\n        editors = self.winfo_children()\n        if len(editors) == 1 and not editors[0].is_modified() and not editors[0].get_filename():\n            self._cmd_close_file()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Automatically closes the only open editor if it is untitled and contains no modifications, streamlining the workspace."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_mac_open_document", "line_number": 887, "body": "def _mac_open_document(self, *args):\n        for arg in args:\n            if isinstance(arg, str) and os.path.exists(arg):\n                self.show_file(arg)\n        get_workbench().become_active_window()", "is_method": true, "class_name": "EditorNotebook", "function_description": "This internal method handles opening multiple document files specified by macOS, displaying each within the editor notebook. It also ensures the main application window becomes active after opening the files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_current_editor", "line_number": 893, "body": "def get_current_editor(self):\n        return self.get_current_child()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Returns the currently active editor component within the notebook. This provides direct access to the visible editor instance for interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_current_editor_content", "line_number": 896, "body": "def get_current_editor_content(self):\n        editor = self.get_current_editor()\n        if editor is None:\n            return None\n        else:\n            return editor.get_code_view().get_content()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Retrieves the textual content from the currently active editor within the notebook. It returns None if no editor is open."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_all_editors", "line_number": 903, "body": "def get_all_editors(self):\n        # When workspace is closing, self.winfo_children()\n        # may return an unexplainable tkinter.Frame\n        return [child for child in self.winfo_children() if isinstance(child, Editor)]", "is_method": true, "class_name": "EditorNotebook", "function_description": "This method retrieves all active editor instances managed by the `EditorNotebook`. It provides a collection of open editors for management or iteration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "select_next_prev_editor", "line_number": 908, "body": "def select_next_prev_editor(self, direction):\n        cur_index = self.index(self.select())\n        next_index = (cur_index + direction) % len(self.tabs())\n        self.select(self.get_child_by_index(next_index))", "is_method": true, "class_name": "EditorNotebook", "function_description": "Enables navigation between editor tabs within the notebook. It selects the next or previous editor in a circular manner, based on the specified direction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "file_is_opened", "line_number": 913, "body": "def file_is_opened(self, path):\n        for editor in self.get_all_editors():\n            if editor.get_filename() and is_same_path(path, editor.get_filename()):\n                return True\n\n        return False", "is_method": true, "class_name": "EditorNotebook", "function_description": "Identifies if a specified file is currently open in any editor managed by the notebook. This prevents duplicate file instances."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "show_file", "line_number": 920, "body": "def show_file(self, filename, text_range=None, set_focus=True, propose_dialog=True):\n        # self.close_single_untitled_unmodified_editor()\n        try:\n            editor = self.get_editor(filename, True)\n        except PermissionError:\n            logger.exception(\"Loading \" + filename)\n            msg = \"Got permission error when trying to load\\n\" + filename\n            if running_on_mac_os() and propose_dialog:\n                msg += \"\\n\\nTry opening it with File => Open.\"\n\n            messagebox.showerror(\"Permission error\", msg, master=self)\n            return None\n\n        if editor is None:\n            return\n\n        self.select(editor)\n        if set_focus:\n            editor.focus_set()\n\n        if text_range is not None:\n            editor.select_range(text_range)\n\n        return editor", "is_method": true, "class_name": "EditorNotebook", "function_description": "Provides the capability to open and display a specified file within the editor interface. It selects the file's editor, optionally highlights a text range, and handles permission issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "show_remote_file", "line_number": 945, "body": "def show_remote_file(self, target_filename):\n        if not get_runner().ready_for_remote_file_operations(show_message=True):\n            return None\n        else:\n            return self.show_file(make_remote_path(target_filename))", "is_method": true, "class_name": "EditorNotebook", "function_description": "Displays a file located on a remote system within the editor notebook. It first verifies the system's readiness for remote file operations before attempting to show the file."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "show_file_at_line", "line_number": 951, "body": "def show_file_at_line(self, filename, lineno, col_offset=None):\n        editor = self.show_file(filename)\n        editor.select_line(lineno, col_offset)", "is_method": true, "class_name": "EditorNotebook", "function_description": "Displays the specified file in the editor and immediately navigates the view to a specific line and column."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "update_appearance", "line_number": 955, "body": "def update_appearance(self):\n        for editor in self.winfo_children():\n            editor.update_appearance()", "is_method": true, "class_name": "EditorNotebook", "function_description": "Triggers an appearance refresh for all child editor instances, ensuring consistent visual styling across the notebook."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "update_editor_title", "line_number": 959, "body": "def update_editor_title(self, editor, title=None):\n        if title is None:\n            title = editor.get_title()\n        try:\n            self.tab(editor, text=title)\n        except TclError:\n            pass\n\n        try:\n            self.indicate_modification()\n        except Exception:\n            logging.exception(\"Could not update modification indication\")", "is_method": true, "class_name": "EditorNotebook", "function_description": "Updates the display title of an editor's tab within the notebook, using either the editor's current title or a specified one. It also attempts to indicate modification."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "indicate_modification", "line_number": 972, "body": "def indicate_modification(self):\n        if not running_on_mac_os():\n            return\n\n        atts = self.winfo_toplevel().wm_attributes()\n        if \"-modified\" in atts:\n            i = atts.index(\"-modified\")\n            mod = atts[i : i + 2]\n            rest = atts[:i] + atts[i + 2 :]\n        else:\n            mod = ()\n            rest = atts\n\n        for editor in self.get_all_editors():\n            if editor.is_modified():\n                if mod != (\"-modified\", 1):\n                    self.winfo_toplevel().wm_attributes(*(rest + (\"-modified\", 1)))\n                break\n        else:\n            if mod == (\"-modified\", 1):\n                self.winfo_toplevel().wm_attributes(*(rest + (\"-modified\", 0)))", "is_method": true, "class_name": "EditorNotebook", "function_description": "Updates the top-level window's modification indicator on macOS based on the collective modified status of its contained editors. This provides a visual cue to the user about unsaved changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "_open_file", "line_number": 994, "body": "def _open_file(self, filename):\n        editor = Editor(self)\n        if editor._load_file(filename):\n            self.add(editor, text=editor.get_title())\n            return editor\n        else:\n            editor.destroy()\n            return None", "is_method": true, "class_name": "EditorNotebook", "function_description": "Opens a specified file by creating a new editor and integrating it into the notebook's interface. It returns the editor instance upon success, or None if the file cannot be loaded."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "get_editor", "line_number": 1003, "body": "def get_editor(self, filename, open_when_necessary=False):\n        if not is_remote_path(filename) and os.path.isfile(filename):\n            filename = normpath_with_actual_case(os.path.abspath(filename))\n        for child in self.winfo_children():\n            child_filename = child.get_filename(False)\n            if child_filename == filename:\n                return child\n\n        if open_when_necessary:\n            return self._open_file(filename)\n        else:\n            return None", "is_method": true, "class_name": "EditorNotebook", "function_description": "Provides access to an editor for a specific file. It returns an existing editor if open, or can optionally create and return a new one if not found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "check_allow_closing", "line_number": 1016, "body": "def check_allow_closing(self, editor=None):\n        if not editor:\n            modified_editors = [e for e in self.winfo_children() if e.is_modified()]\n        else:\n            if not editor.is_modified():\n                return True\n            else:\n                modified_editors = [editor]\n        if len(modified_editors) == 0:\n            return True\n\n        message = tr(\"Do you want to save files before closing?\")\n        if editor:\n            message = tr(\"Do you want to save file before closing?\")\n\n        confirm = messagebox.askyesnocancel(\n            title=tr(\"Save On Close\"), message=message, default=messagebox.YES, master=self\n        )\n\n        if confirm:\n            for editor_ in modified_editors:\n                if editor_.get_filename(True):\n                    editor_.save_file()\n                else:\n                    return False\n            return True\n\n        elif confirm is None:\n            return False\n        else:\n            return True", "is_method": true, "class_name": "EditorNotebook", "function_description": "Determines if the editor notebook or a specific editor can be closed by prompting the user to save any modified files. It returns true if closing is permitted based on user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "on_focus_window", "line_number": 1048, "body": "def on_focus_window(self, event=None):\n        for editor in self.get_all_editors():\n            editor.check_for_external_changes()", "is_method": true, "class_name": "EditorNotebook", "function_description": "When the application window gains focus, this method ensures all open editors reflect external file changes. It prevents users from working on outdated file versions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/editors.py", "function": "load", "line_number": 725, "body": "def load(path=path):\n                self.show_file(path)", "is_method": true, "class_name": "EditorNotebook", "function_description": "This method opens a specified file and displays its content within the EditorNotebook interface. It provides a convenient way to load files for viewing or editing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "ask_string", "line_number": 133, "body": "def ask_string(\n    title: str,\n    prompt: str,\n    initial_value: str = \"\",\n    options: List[str] = [],\n    entry_width: Optional[int] = None,\n    master=None,\n):\n    dlg = QueryDialog(\n        master, title, prompt, initial_value=initial_value, options=options, entry_width=entry_width\n    )\n    show_dialog(dlg, master)\n    return dlg.get_result()", "is_method": false, "function_description": "Displays a graphical dialog to the user, prompting for a string input. It returns the string entered or selected by the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "scrollbar_style", "line_number": 742, "body": "def scrollbar_style(orientation):\n    # In mac ttk.Scrollbar uses native rendering unless style attribute is set\n    # see http://wiki.tcl.tk/44444#pagetoc50f90d9a\n    # Native rendering doesn't look good in dark themes\n    if running_on_mac_os() and get_workbench().uses_dark_ui_theme():\n        return orientation + \".TScrollbar\"\n    else:\n        return None", "is_method": false, "function_description": "Determines the appropriate `ttk.Scrollbar` style string for a given orientation. It ensures scrollbars render correctly on macOS when a dark UI theme is active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "sequence_to_accelerator", "line_number": 752, "body": "def sequence_to_accelerator(sequence):\n    \"\"\"Translates Tk event sequence to customary shortcut string\n    for showing in the menu\"\"\"\n\n    if not sequence:\n        return \"\"\n\n    if not sequence.startswith(\"<\"):\n        return sequence\n\n    accelerator = (\n        sequence.strip(\"<>\").replace(\"Key-\", \"\").replace(\"KeyPress-\", \"\").replace(\"Control\", \"Ctrl\")\n    )\n\n    # Tweaking individual parts\n    parts = accelerator.split(\"-\")\n    # tkinter shows shift with capital letter, but in shortcuts it's customary to include it explicitly\n    if len(parts[-1]) == 1 and parts[-1].isupper() and not \"Shift\" in parts:\n        parts.insert(-1, \"Shift\")\n\n    # even when shift is not required, it's customary to show shortcut with capital letter\n    if len(parts[-1]) == 1:\n        parts[-1] = parts[-1].upper()\n\n    accelerator = \"+\".join(parts)\n\n    # Post processing\n    accelerator = (\n        accelerator.replace(\"Minus\", \"-\")\n        .replace(\"minus\", \"-\")\n        .replace(\"Plus\", \"+\")\n        .replace(\"plus\", \"+\")\n    )\n\n    return accelerator", "is_method": false, "function_description": "Translates a Tkinter event sequence into a customary, human-readable keyboard shortcut string. This function formats input sequences for clear display in application menus."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_zoomed", "line_number": 789, "body": "def get_zoomed(toplevel):\n    if \"-zoomed\" in toplevel.wm_attributes():  # Linux\n        return bool(toplevel.wm_attributes(\"-zoomed\"))\n    else:  # Win/Mac\n        return toplevel.wm_state() == \"zoomed\"", "is_method": false, "function_description": "Checks if a top-level GUI window is currently in a 'zoomed' or maximized state. It offers a cross-platform method for querying window maximization status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "set_zoomed", "line_number": 796, "body": "def set_zoomed(toplevel, value):\n    if \"-zoomed\" in toplevel.wm_attributes():  # Linux\n        toplevel.wm_attributes(\"-zoomed\", str(int(value)))\n    else:  # Win/Mac\n        if value:\n            toplevel.wm_state(\"zoomed\")\n        else:\n            toplevel.wm_state(\"normal\")", "is_method": false, "function_description": "Controls the zoomed (maximized) or normal state of a graphical user interface window. It abstracts OS-specific window management commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "update_entry_text", "line_number": 947, "body": "def update_entry_text(entry, text):\n    original_state = entry.cget(\"state\")\n    entry.config(state=\"normal\")\n    entry.delete(0, \"end\")\n    entry.insert(0, text)\n    entry.config(state=original_state)", "is_method": false, "function_description": "This function updates the displayed text of a GUI entry widget. It temporarily enables the widget for modification before restoring its original state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_tooltip", "line_number": 1130, "body": "def create_tooltip(widget, text, **kw):\n    options = get_style_configuration(\"Tooltip\").copy()\n    options.setdefault(\"background\", \"#ffffe0\")\n    options.setdefault(\"foreground\", \"#000000\")\n    options.setdefault(\"relief\", \"solid\")\n    options.setdefault(\"borderwidth\", 1)\n    options.setdefault(\"padx\", 1)\n    options.setdefault(\"pady\", 0)\n    options.update(kw)\n\n    toolTip = ToolTip(widget, options)\n\n    def enter(event):\n        toolTip.showtip(text)\n\n    def leave(event):\n        toolTip.hidetip()\n\n    widget.bind(\"<Enter>\", enter)\n    widget.bind(\"<Leave>\", leave)", "is_method": false, "function_description": "Attaches a customizable tooltip to a GUI widget. It displays the given text when the mouse enters the widget and hides it when the mouse leaves."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_widget_offset_from_toplevel", "line_number": 1314, "body": "def get_widget_offset_from_toplevel(widget):\n    x = 0\n    y = 0\n    toplevel = widget.winfo_toplevel()\n    while widget != toplevel:\n        x += widget.winfo_x()\n        y += widget.winfo_y()\n        widget = widget.master\n    return x, y", "is_method": false, "function_description": "Calculates the total pixel offset (X, Y coordinates) of a GUI widget relative to its top-level window. This determines the widget's absolute position within the application window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_string_var", "line_number": 1366, "body": "def create_string_var(value, modification_listener=None) -> EnhancedStringVar:\n    \"\"\"Creates a tk.StringVar with \"modified\" attribute\n    showing whether the variable has been modified after creation\"\"\"\n    return EnhancedStringVar(None, value, None, modification_listener)", "is_method": false, "function_description": "Creates an enhanced string variable that tracks its modification status. This variable can also notify a listener when its value changes, useful for UI element state management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_int_var", "line_number": 1372, "body": "def create_int_var(value, modification_listener=None) -> EnhancedIntVar:\n    \"\"\"See create_string_var\"\"\"\n    return EnhancedIntVar(None, value, None, modification_listener)", "is_method": false, "function_description": "This function creates an `EnhancedIntVar`, an observable integer variable. It initializes the variable with a specified value and can attach a listener for modifications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_double_var", "line_number": 1377, "body": "def create_double_var(value, modification_listener=None) -> EnhancedDoubleVar:\n    \"\"\"See create_string_var\"\"\"\n    return EnhancedDoubleVar(None, value, None, modification_listener)", "is_method": false, "function_description": "Creates an `EnhancedDoubleVar` object, a mutable variable that stores a floating-point value. It can optionally notify a listener when its value changes, commonly used for data binding."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_boolean_var", "line_number": 1382, "body": "def create_boolean_var(value, modification_listener=None) -> EnhancedBooleanVar:\n    \"\"\"See create_string_var\"\"\"\n    return EnhancedBooleanVar(None, value, None, modification_listener)", "is_method": false, "function_description": "This function creates an enhanced boolean variable, initialized with a given value. It can notify a registered listener when its state changes, enabling reactive behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "shift_is_pressed", "line_number": 1387, "body": "def shift_is_pressed(event_state):\n    # http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/event-handlers.html\n    # http://stackoverflow.com/q/32426250/261181\n    return event_state & 0x0001", "is_method": false, "function_description": "Checks if the Shift key was pressed based on the given event state. Typically used in GUI event handling to determine if the Shift modifier was active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "caps_lock_is_on", "line_number": 1393, "body": "def caps_lock_is_on(event_state):\n    # http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/event-handlers.html\n    # http://stackoverflow.com/q/32426250/261181\n    return event_state & 0x0002", "is_method": false, "function_description": "Determines if the Caps Lock key was active when a user input event occurred. It extracts this state from the event's numerical state flags, useful for GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "control_is_pressed", "line_number": 1399, "body": "def control_is_pressed(event_state):\n    # http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/event-handlers.html\n    # http://stackoverflow.com/q/32426250/261181\n    return event_state & 0x0004", "is_method": false, "function_description": "Determines if the Control key was active within a given event state. Useful for identifying keyboard shortcuts or modified actions in GUI applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "sequence_to_event_state_and_keycode", "line_number": 1405, "body": "def sequence_to_event_state_and_keycode(sequence: str) -> Optional[Tuple[int, int]]:\n    # remember handlers for certain shortcuts which require\n    # different treatment on non-latin keyboards\n    if sequence[0] != \"<\":\n        return None\n\n    parts = sequence.strip(\"<\").strip(\">\").split(\"-\")\n    # support only latin letters for now\n    if parts[-1].lower() not in list(\"abcdefghijklmnopqrstuvwxyz\"):\n        return None\n\n    letter = parts.pop(-1)\n    if \"Key\" in parts:\n        parts.remove(\"Key\")\n    if \"key\" in parts:\n        parts.remove(\"key\")\n\n    modifiers = {part.lower() for part in parts}\n\n    if letter.isupper():\n        modifiers.add(\"shift\")\n\n    if modifiers not in [{\"control\"}, {\"control\", \"shift\"}]:\n        # don't support others for now\n        return None\n\n    event_state = 0\n    # http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/event-handlers.html\n    # https://stackoverflow.com/questions/32426250/python-documentation-and-or-lack-thereof-e-g-keyboard-event-state\n    for modifier in modifiers:\n        if modifier == \"shift\":\n            event_state |= 0x0001\n        elif modifier == \"control\":\n            event_state |= 0x0004\n        else:\n            # unsupported modifier\n            return None\n\n    # for latin letters keycode is same as its ascii code\n    return (event_state, ord(letter.upper()))", "is_method": false, "function_description": "Translates a keyboard shortcut string (e.g., \"<Control-a>\") into its corresponding numeric event state and keycode. This function provides a standardized mapping for GUI event handling, supporting specific modifiers and latin letters."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "select_sequence", "line_number": 1447, "body": "def select_sequence(win_version, mac_version, linux_version=None):\n    if running_on_windows():\n        return win_version\n    elif running_on_mac_os():\n        return mac_version\n    elif running_on_linux() and linux_version:\n        return linux_version\n    else:\n        return win_version", "is_method": false, "function_description": "Selects and returns a specific version or sequence based on the detected operating system (Windows, macOS, or Linux). This provides platform-tailored configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "try_remove_linenumbers", "line_number": 1458, "body": "def try_remove_linenumbers(text, master):\n    try:\n        if has_line_numbers(text) and messagebox.askyesno(\n            title=\"Remove linenumbers\",\n            message=\"Do you want to remove linenumbers from pasted text?\",\n            default=messagebox.YES,\n            master=master,\n        ):\n            return remove_line_numbers(text)\n        else:\n            return text\n    except Exception:\n        traceback.print_exc()\n        return text", "is_method": false, "function_description": "Provides an interactive way to remove line numbers from text. It detects line numbers, prompts the user for confirmation, and returns the modified or original text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "has_line_numbers", "line_number": 1474, "body": "def has_line_numbers(text):\n    lines = text.splitlines()\n    return len(lines) > 2 and all([len(split_after_line_number(line)) == 2 for line in lines])", "is_method": false, "function_description": "Ascertains if a text string is formatted with line numbers prefixing each line, aiding in parsing or validating such content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "split_after_line_number", "line_number": 1479, "body": "def split_after_line_number(s):\n    parts = re.split(r\"(^\\s*\\d+\\.?)\", s)\n    if len(parts) == 1:\n        return parts\n    else:\n        assert len(parts) == 3 and parts[0] == \"\"\n        return parts[1:]", "is_method": false, "function_description": "Splits a string into two parts if it starts with a numbered prefix (e.g., '1.', ' 2'). It returns the identified prefix and the remaining text, or the original string if no number is present."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "remove_line_numbers", "line_number": 1488, "body": "def remove_line_numbers(s):\n    cleaned_lines = []\n    for line in s.splitlines():\n        parts = split_after_line_number(line)\n        if len(parts) != 2:\n            return s\n        else:\n            cleaned_lines.append(parts[1])\n\n    return textwrap.dedent((\"\\n\".join(cleaned_lines)) + \"\\n\")", "is_method": false, "function_description": "Removes leading line numbers from a multi-line string. It extracts and dedents the content, returning the original string if parsing fails."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "center_window", "line_number": 1500, "body": "def center_window(win, master=None):\n    # for backward compat\n    return assign_geometry(win, master)", "is_method": false, "function_description": "Serves as a backward-compatible utility to center a given graphical user interface (GUI) window. It delegates the actual positioning logic to an underlying geometry assignment function."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "assign_geometry", "line_number": 1505, "body": "def assign_geometry(win, master=None, min_left=0, min_top=0):\n    if master is None:\n        master = tk._default_root\n\n    size = get_workbench().get_option(get_size_option_name(win))\n    if size:\n        width, height = size\n        saved_size = True\n    else:\n        fallback_width = 600\n        fallback_height = 400\n        # need to wait until size is computed\n        # (unfortunately this causes dialog to jump)\n        if getattr(master, \"initializing\", False):\n            # can't get reliable positions when main window is not in mainloop yet\n            width = fallback_width\n            height = fallback_height\n        else:\n            if not running_on_linux():\n                # better to avoid in Linux because it causes ugly jump\n                win.update_idletasks()\n            # looks like it doesn't take window border into account\n            width = win.winfo_width()\n            height = win.winfo_height()\n\n            if width < 10:\n                # ie. size measurement is not correct\n                width = fallback_width\n                height = fallback_height\n\n        saved_size = False\n\n    left = master.winfo_rootx() + master.winfo_width() // 2 - width // 2\n    top = master.winfo_rooty() + master.winfo_height() // 2 - height // 2\n\n    left = max(left, min_left)\n    top = max(top, min_top)\n\n    if saved_size:\n        win.geometry(\"%dx%d+%d+%d\" % (width, height, left, top))\n    else:\n        win.geometry(\"+%d+%d\" % (left, top))", "is_method": false, "function_description": "This function sets the geometry (size and position) of a Tkinter window. It centers the window relative to a master or default root, respecting saved dimensions and minimum coordinates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "run_with_waiting_dialog", "line_number": 1580, "body": "def run_with_waiting_dialog(master, action, args=(), description=\"Working\"):\n    # http://stackoverflow.com/a/14299004/261181\n    from multiprocessing.pool import ThreadPool\n\n    pool = ThreadPool(processes=1)\n\n    async_result = pool.apply_async(action, args)\n    dlg = WaitingDialog(master, async_result, description=description)\n    show_dialog(dlg, master)\n\n    return async_result.get()", "is_method": false, "function_description": "Executes a function in a separate thread, displaying a non-blocking waiting dialog. This prevents the main GUI from freezing during long-running operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "ask_one_from_choices", "line_number": 1779, "body": "def ask_one_from_choices(\n    master=None,\n    title=\"Choose one\",\n    question: str = \"Choose one:\",\n    choices=[],\n    initial_choice_index=None,\n):\n    dlg = ChoiceDialog(master, title, question, choices, initial_choice_index)\n    show_dialog(dlg, master)\n    return dlg.result", "is_method": false, "function_description": "Presents a graphical dialog to the user, allowing them to select one option from a given list and returns their choice."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_busy_cursor", "line_number": 1791, "body": "def get_busy_cursor():\n    if running_on_windows():\n        return \"wait\"\n    elif running_on_mac_os():\n        return \"spinning\"\n    else:\n        return \"watch\"", "is_method": false, "function_description": "Determines and returns the platform-specific string identifier for a busy cursor, adapting to Windows, macOS, or other operating systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_tk_version_str", "line_number": 1800, "body": "def get_tk_version_str():\n    return tk._default_root.tk.call(\"info\", \"patchlevel\")", "is_method": false, "function_description": "Provides the version string for the underlying Tk library. Useful for compatibility checks or debugging Tkinter applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_tk_version_info", "line_number": 1804, "body": "def get_tk_version_info():\n    result = []\n    for part in get_tk_version_str().split(\".\"):\n        try:\n            result.append(int(part))\n        except Exception:\n            result.append(0)\n    return tuple(result)", "is_method": false, "function_description": "Retrieves the Tkinter/Tk version string and parses it into a comparable tuple of integers. This enables programmatic version checks and comparisons."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_style_configuration", "line_number": 1814, "body": "def get_style_configuration(style_name, default={}):\n    style = ttk.Style()\n    # NB! style.configure seems to reuse the returned dict\n    # Don't change it without copying first\n    result = style.configure(style_name)\n    if result is None:\n        return default\n    else:\n        return result", "is_method": false, "function_description": "Retrieves the current configuration dictionary for a specified Tkinter Ttk style. It returns a provided default if the style has no custom configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "lookup_style_option", "line_number": 1825, "body": "def lookup_style_option(style_name, option_name, default=None):\n    style = ttk.Style()\n    setting = style.lookup(style_name, option_name)\n    if setting in [None, \"\"]:\n        return default\n    elif setting == \"True\":\n        return True\n    elif setting == \"False\":\n        return False\n    else:\n        return setting", "is_method": false, "function_description": "Provides a robust way to retrieve specific options for Tkinter widget styles. It handles boolean string conversion and returns a default when an option is not explicitly set."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "scale", "line_number": 1838, "body": "def scale(value):\n    return get_workbench().scale(value)", "is_method": false, "function_description": "This function scales a given value by delegating the operation to the application's central workbench. It provides a convenient, global access point for the application's core scaling logic."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "open_path_in_system_file_manager", "line_number": 1842, "body": "def open_path_in_system_file_manager(path):\n    if running_on_mac_os():\n        # http://stackoverflow.com/a/3520693/261181\n        # -R doesn't allow showing hidden folders\n        subprocess.Popen([\"open\", path])\n    elif running_on_linux():\n        subprocess.Popen([\"xdg-open\", path])\n    else:\n        assert running_on_windows()\n        subprocess.Popen([\"explorer\", path])", "is_method": false, "function_description": "Provides a cross-platform capability to open a given file or directory path in the operating system's default file manager."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_get_dialog_provider", "line_number": 1854, "body": "def _get_dialog_provider():\n    if platform.system() != \"Linux\" or get_workbench().get_option(\"file.avoid_zenity\"):\n        return filedialog\n\n    import shutil\n\n    if shutil.which(\"zenity\"):\n        return _ZenityDialogProvider\n\n    # fallback\n    return filedialog", "is_method": false, "function_description": "Selects and returns the most appropriate file dialog provider based on the operating system and environment settings, prioritizing Zenity on Linux when available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "asksaveasfilename", "line_number": 1867, "body": "def asksaveasfilename(**options):\n    # https://tcl.tk/man/tcl8.6/TkCmd/getSaveFile.htm\n    _check_dialog_parent(options)\n    return _get_dialog_provider().asksaveasfilename(**options)", "is_method": false, "function_description": "Opens a dialog box for the user to select a filename and location to save a file. This service is essential for applications that need to export or save data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askopenfilename", "line_number": 1873, "body": "def askopenfilename(**options):\n    # https://tcl.tk/man/tcl8.6/TkCmd/getOpenFile.htm\n    _check_dialog_parent(options)\n    return _get_dialog_provider().askopenfilename(**options)", "is_method": false, "function_description": "Presents a standard file selection dialog to the user. It allows the user to browse and select a file, returning its full path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askopenfilenames", "line_number": 1879, "body": "def askopenfilenames(**options):\n    # https://tcl.tk/man/tcl8.6/TkCmd/getOpenFile.htm\n    _check_dialog_parent(options)\n    return _get_dialog_provider().askopenfilenames(**options)", "is_method": false, "function_description": "Presents a file dialog to the user, enabling them to select one or multiple existing files. It provides a standard way for GUI applications to get file paths from the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askdirectory", "line_number": 1885, "body": "def askdirectory(**options):\n    # https://tcl.tk/man/tcl8.6/TkCmd/chooseDirectory.htm\n    _check_dialog_parent(options)\n    return _get_dialog_provider().askdirectory(**options)", "is_method": false, "function_description": "Presents a standard GUI dialog box, enabling the user to select a directory from their file system. This allows applications to obtain a directory path directly from user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_check_dialog_parent", "line_number": 1891, "body": "def _check_dialog_parent(options):\n    if options.get(\"parent\") and options.get(\"master\"):\n        parent = options[\"parent\"].winfo_toplevel()\n        master = options[\"master\"].winfo_toplevel()\n        if parent is not master:\n            logger.warning(\n                \"Dialog with different parent/master toplevels:\\n%s\",\n                \"\".join(traceback.format_stack()),\n            )\n    elif options.get(\"parent\"):\n        parent = options[\"parent\"].winfo_toplevel()\n        master = options[\"parent\"].winfo_toplevel()\n    elif options.get(\"master\"):\n        parent = options[\"master\"].winfo_toplevel()\n        master = options[\"master\"].winfo_toplevel()\n    else:\n        logger.warning(\"Dialog without parent:\\n%s\", \"\".join(traceback.format_stack()))\n        parent = tk._default_root\n        master = tk._default_root\n\n    options[\"parent\"] = parent\n    options[\"master\"] = master\n\n    if running_on_mac_os():\n        # used to require master/parent (https://bugs.python.org/issue34927)\n        # but this is deprecated in Catalina (https://github.com/thonny/thonny/issues/840)\n        # TODO: Consider removing this when upgrading from Tk 8.6.8\n        del options[\"master\"]\n        del options[\"parent\"]", "is_method": false, "function_description": "Prepares and validates dialog parent/master window options, ensuring consistent top-level window assignments. It handles platform-specific requirements, including special adjustments for macOS."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_options_to_zenity_filename", "line_number": 2004, "body": "def _options_to_zenity_filename(options):\n    if options.get(\"initialdir\"):\n        if options.get(\"initialfile\"):\n            return os.path.join(options[\"initialdir\"], options[\"initialfile\"])\n        else:\n            return options[\"initialdir\"] + os.path.sep\n\n    return None", "is_method": false, "function_description": "Generates an initial file or directory path string for Zenity dialogs based on provided options, suitable for pre-selecting a file or directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "register_latin_shortcut", "line_number": 2014, "body": "def register_latin_shortcut(\n    registry, sequence: str, handler: Callable, tester: Optional[Callable]\n) -> None:\n    res = sequence_to_event_state_and_keycode(sequence)\n    if res is not None:\n        if res not in registry:\n            registry[res] = []\n        registry[res].append((handler, tester))", "is_method": false, "function_description": "This function registers a Latin input sequence or keyboard shortcut, associating it with a handler function and an optional tester. It allows mapping user inputs to specific actions within an application's registry."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "handle_mistreated_latin_shortcuts", "line_number": 2024, "body": "def handle_mistreated_latin_shortcuts(registry, event):\n    # tries to handle Ctrl+LatinLetter shortcuts\n    # given from non-Latin keyboards\n    # See: https://bitbucket.org/plas/thonny/issues/422/edit-keyboard-shortcuts-ctrl-c-ctrl-v-etc\n\n    # only consider events with Control held\n    if not event.state & 0x04:\n        return\n\n    if running_on_mac_os():\n        return\n\n    # consider only part of the state,\n    # because at least on Windows, Ctrl-shortcuts' state\n    # has something extra\n    simplified_state = 0x04\n    if shift_is_pressed(event.state):\n        simplified_state |= 0x01\n\n    # print(simplified_state, event.keycode)\n    if (simplified_state, event.keycode) in registry:\n        if event.keycode != ord(event.char) and event.keysym in (None, \"??\"):\n            # keycode and char doesn't match,\n            # this means non-latin keyboard\n            for handler, tester in registry[(simplified_state, event.keycode)]:\n                if tester is None or tester():\n                    handler()", "is_method": false, "function_description": "This function provides a compatibility service for keyboard shortcuts, remapping `Ctrl+LatinLetter` combinations from non-Latin keyboards to ensure they trigger their intended actions. It addresses a specific issue to ensure consistent shortcut behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "show_dialog", "line_number": 2053, "body": "def show_dialog(dlg, master=None, geometry=True, min_left=0, min_top=0):\n    if getattr(dlg, \"closed\", False):\n        return\n\n    if master is None:\n        master = getattr(dlg, \"parent\", None) or getattr(dlg, \"master\", None) or tk._default_root\n\n    master = master.winfo_toplevel()\n\n    get_workbench().event_generate(\"WindowFocusOut\")\n    # following order seems to give most smooth appearance\n    focused_widget = master.focus_get()\n    dlg.transient(master.winfo_toplevel())\n\n    if geometry:\n        # dlg.withdraw() # unfortunately inhibits size calculations in assign_geometry\n        if isinstance(geometry, str):\n            dlg.geometry(geometry)\n        else:\n            assign_geometry(dlg, master, min_left, min_top)\n        # dlg.wm_deiconify()\n\n    dlg.lift()\n    dlg.focus_set()\n\n    try:\n        dlg.grab_set()\n    except TclError as e:\n        print(\"Can't grab:\", e, file=sys.stderr)\n\n    master.winfo_toplevel().wait_window(dlg)\n    dlg.grab_release()\n    master.winfo_toplevel().lift()\n    master.winfo_toplevel().focus_force()\n    master.winfo_toplevel().grab_set()\n    if running_on_mac_os():\n        master.winfo_toplevel().grab_release()\n\n    if focused_widget is not None:\n        try:\n            focused_widget.focus_force()\n        except TclError:\n            pass", "is_method": false, "function_description": "Displays a Tkinter dialog window, making it modal and transient relative to its master. It manages dialog geometry, focus, and waits for user interaction to complete."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "popen_with_ui_thread_callback", "line_number": 2098, "body": "def popen_with_ui_thread_callback(*Popen_args, on_completion, poll_delay=0.1, **Popen_kwargs):\n    if \"encoding\" not in Popen_kwargs:\n        if \"env\" not in Popen_kwargs:\n            Popen_kwargs[\"env\"] = os.environ.copy()\n        Popen_kwargs[\"env\"][\"PYTHONIOENCODING\"] = \"utf-8\"\n        if sys.version_info >= (3, 6):\n            Popen_kwargs[\"encoding\"] = \"utf-8\"\n\n    proc = subprocess.Popen(*Popen_args, **Popen_kwargs)\n\n    # Need to read in thread in order to avoid blocking because\n    # of full pipe buffer (see https://bugs.python.org/issue1256)\n    out_lines = []\n    err_lines = []\n\n    def read_stream(stream, target_list):\n        while True:\n            line = stream.readline()\n            if line:\n                target_list.append(line)\n            else:\n                break\n\n    t_out = threading.Thread(target=read_stream, daemon=True, args=(proc.stdout, out_lines))\n    t_err = threading.Thread(target=read_stream, daemon=True, args=(proc.stderr, err_lines))\n    t_out.start()\n    t_err.start()\n\n    def poll():\n        if proc.poll() is not None:\n            t_out.join(3)\n            t_err.join(3)\n            on_completion(proc, out_lines, err_lines)\n            return\n\n        tk._default_root.after(int(poll_delay * 1000), poll)\n\n    poll()\n    return proc", "is_method": false, "function_description": "Executes an external command as a subprocess, asynchronously capturing its output. It invokes a specified callback upon completion, ensuring the UI thread remains responsive."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_url_label", "line_number": 2223, "body": "def create_url_label(master, url, text=None):\n    import webbrowser\n\n    return create_action_label(master, text or url, lambda _: webbrowser.open(url))", "is_method": false, "function_description": "Creates a clickable label that, when activated, opens the specified URL in the user's default web browser. It provides a simple way to embed interactive web links within a GUI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_action_label", "line_number": 2229, "body": "def create_action_label(master, text, click_handler, **kw):\n    url_font = tkinter.font.nametofont(\"TkDefaultFont\").copy()\n    url_font.configure(underline=1)\n    url_label = ttk.Label(\n        master, text=text, style=\"Url.TLabel\", cursor=\"hand2\", font=url_font, **kw\n    )\n    url_label.bind(\"<Button-1>\", click_handler)\n    return url_label", "is_method": false, "function_description": "Creates a clickable Tkinter label that visually resembles a hyperlink. It executes a specified function when clicked, serving as an interactive text element in a GUI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_size_option_name", "line_number": 2239, "body": "def get_size_option_name(window):\n    return \"layout.\" + type(window).__name__ + \"_size\"", "is_method": false, "function_description": "Creates a standardized configuration key for a window's size option, based on its class name. This is useful for storing and retrieving window dimensions persistently."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_default_theme", "line_number": 2243, "body": "def get_default_theme():\n    if running_on_windows():\n        return \"Windows\"\n    elif running_on_rpi():\n        return \"Raspberry Pi\"\n    else:\n        return \"Enhanced Clam\"", "is_method": false, "function_description": "Determines and provides the appropriate default theme name based on the detected operating system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_default_basic_theme", "line_number": 2252, "body": "def get_default_basic_theme():\n    if running_on_windows():\n        return \"xpnative\"\n    else:\n        return \"clam\"", "is_method": false, "function_description": "This function provides an appropriate default theme name for the user interface, selecting \"xpnative\" for Windows and \"clam\" for other operating systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "ems_to_pixels", "line_number": 2262, "body": "def ems_to_pixels(x):\n    global EM_WIDTH\n    if EM_WIDTH is None:\n        EM_WIDTH = tkinter.font.nametofont(\"TkDefaultFont\").measure(\"m\")\n    return int(EM_WIDTH * x)", "is_method": false, "function_description": "Converts font-relative 'em' units to absolute pixel values based on the default font's 'm' character width. This ensures GUI element sizing is proportional to font metrics for consistent layouts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "set_text_if_different", "line_number": 2272, "body": "def set_text_if_different(widget, text) -> bool:\n    if widget[\"text\"] != text:\n        widget[\"text\"] = text\n        return True\n    else:\n        return False", "is_method": false, "function_description": "Updates a widget's text content only if the new text differs from its current value. It returns True if an update occurred, otherwise False."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "tr_btn", "line_number": 2280, "body": "def tr_btn(s):\n    \"\"\"Translates button caption, adds padding to make sure text fits\"\"\"\n    global _btn_padding\n    if _btn_padding is None:\n        _btn_padding = get_button_padding()\n\n    return _btn_padding + tr(s) + _btn_padding", "is_method": false, "function_description": "Translates a button caption and adds necessary padding to ensure the text fits visually within the button element."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add_messagebox_parent_checker", "line_number": 2289, "body": "def add_messagebox_parent_checker():\n    def wrap_with_parent_checker(original):\n        def wrapper(*args, **options):\n            _check_dialog_parent(options)\n            return original(*args, **options)\n\n        return wrapper\n\n    from tkinter import messagebox\n\n    for name in [\n        \"showinfo\",\n        \"showwarning\",\n        \"showerror\",\n        \"askquestion\",\n        \"askokcancel\",\n        \"askyesno\",\n        \"askyesnocancel\",\n        \"askretrycancel\",\n    ]:\n        fun = getattr(messagebox, name)\n        setattr(messagebox, name, wrap_with_parent_checker(fun))", "is_method": false, "function_description": "Dynamically modifies Tkinter's `messagebox` functions to automatically check for a valid parent window before displaying. This ensures all message dialogs are properly associated with a parent."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_unlock_on_focus_in", "line_number": 44, "body": "def _unlock_on_focus_in(self, event):\n        if not self.winfo_ismapped():\n            focussed_widget = self.focus_get()\n            self.deiconify()\n            if focussed_widget:\n                focussed_widget.focus_set()", "is_method": true, "class_name": "CommonDialog", "function_description": "This internal method makes a hidden `CommonDialog` visible when it gains focus. It restores focus to the previously active widget within the dialog for seamless user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_padding", "line_number": 51, "body": "def get_padding(self):\n        return ems_to_pixels(2)", "is_method": true, "class_name": "CommonDialog", "function_description": "Provides a consistent padding value for the dialog's UI elements. It converts an ems-based measurement to pixels, ensuring uniform spacing within the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_internal_padding", "line_number": 54, "body": "def get_internal_padding(self):\n        return self.get_padding() // 4", "is_method": true, "class_name": "CommonDialog", "function_description": "This method provides a calculated internal padding value, typically used to ensure consistent proportional spacing within a CommonDialog's UI elements, by deriving it from the main padding."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_close", "line_number": 71, "body": "def on_close(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "CommonDialogEx", "function_description": "This method closes and disposes of the dialog window. It is typically invoked when a user initiates a close action on the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_ok", "line_number": 121, "body": "def on_ok(self, event=None):\n        self.result = self.var.get()\n        self.destroy()", "is_method": true, "class_name": "QueryDialog", "function_description": "For a QueryDialog, this method confirms and retrieves the user's input, making it available as the dialog's result before closing the dialog window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_cancel", "line_number": 125, "body": "def on_cancel(self, event=None):\n        self.result = None\n        self.destroy()", "is_method": true, "class_name": "QueryDialog", "function_description": "Handles the user's cancellation of a query dialog. It clears any pending result and closes the dialog window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_result", "line_number": 129, "body": "def get_result(self) -> Optional[str]:\n        return self.result", "is_method": true, "class_name": "QueryDialog", "function_description": "Retrieves the final outcome or result string from the query dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add_cascade", "line_number": 166, "body": "def add_cascade(self, label, menu):\n        label_widget = ttk.Label(\n            self,\n            style=\"CustomMenubarLabel.TLabel\",\n            text=label,\n            padding=[6, 3, 6, 2],\n            font=\"TkDefaultFont\",\n        )\n\n        if len(self._menus) == 0:\n            padx = (6, 0)\n        else:\n            padx = 0\n\n        label_widget.grid(row=0, column=len(self._menus), padx=padx)\n\n        def enter(event):\n            label_widget.state((\"active\",))\n\n            # Don't know how to open this menu when another menu is open\n            # another tk_popup just doesn't work unless old menu is closed by click or Esc\n            # https://stackoverflow.com/questions/38081470/is-there-a-way-to-know-if-tkinter-optionmenu-dropdown-is-active\n            # unpost doesn't work in Win and Mac: https://www.tcl.tk/man/tcl8.5/TkCmd/menu.htm#M62\n            # print(\"ENTER\", menu, self._opened_menu)\n            if self._opened_menu is not None:\n                self._opened_menu.unpost()\n                click(event)\n\n        def leave(event):\n            label_widget.state((\"!active\",))\n\n        def click(event):\n            try:\n                # print(\"Before\")\n                self._opened_menu = menu\n                menu.tk_popup(\n                    label_widget.winfo_rootx(),\n                    label_widget.winfo_rooty() + label_widget.winfo_height(),\n                )\n            finally:\n                # print(\"After\")\n                self._opened_menu = None\n\n        label_widget.bind(\"<Enter>\", enter, True)\n        label_widget.bind(\"<Leave>\", leave, True)\n        label_widget.bind(\"<1>\", click, True)\n        self._menus.append(menu)", "is_method": true, "class_name": "CustomMenubar", "function_description": "This method adds a new top-level menu item with a given label to the custom menubar. Clicking this label displays the associated dropdown menu."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "insert", "line_number": 241, "body": "def insert(self, pos, child, **kw):\n        kw.setdefault(\"minsize\", self._pane_minsize)\n\n        if pos == \"auto\":\n            # According to documentation I should use self.panes()\n            # but this doesn't return expected widgets\n            for sibling in sorted(\n                self.pane_widgets(),\n                key=lambda p: p.position_key if hasattr(p, \"position_key\") else 0,\n            ):\n                if (\n                    not hasattr(sibling, \"position_key\")\n                    or sibling.position_key == None\n                    or sibling.position_key > child.position_key\n                ):\n                    pos = sibling\n                    break\n            else:\n                pos = \"end\"\n\n        if isinstance(pos, tk.Widget):\n            kw[\"before\"] = pos\n\n        self.add(child, **kw)", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Adds a child widget to the paned window, automatically determining its insertion position using a `position_key`. This ensures widgets maintain a predefined order within the layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add", "line_number": 266, "body": "def add(self, child, **kw):\n        kw.setdefault(\"minsize\", self._pane_minsize)\n\n        tk.PanedWindow.add(self, child, **kw)\n        self._update_visibility()\n        self._check_restore_preferred_sizes()", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Adds a child widget to the paned window, automatically applying a default minimum size. It then manages pane visibility and attempts to restore preferred sizes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "remove", "line_number": 273, "body": "def remove(self, child):\n        tk.PanedWindow.remove(self, child)\n        self._update_visibility()\n        self._check_restore_preferred_sizes()", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Removes a specified child widget from the paned window. This method also updates the window's layout and manages the preferred sizes of remaining panes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "forget", "line_number": 278, "body": "def forget(self, child):\n        tk.PanedWindow.forget(self, child)\n        self._update_visibility()\n        self._check_restore_preferred_sizes()", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Removes a specified child widget from the paned window. It then automatically updates the layout visibility and manages preferred sizes of the remaining panes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "destroy", "line_number": 283, "body": "def destroy(self):\n        self.unbind(\"<Configure>\", self._configure_binding)\n        self.unbind(\"<<ThemeChanged>>\", self._update_appearance_binding)\n        tk.PanedWindow.destroy(self)", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "This method unbinds custom event handlers and then destroys the `AutomaticPanedWindow` widget. It ensures proper resource release upon widget removal."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "is_visible", "line_number": 288, "body": "def is_visible(self):\n        if not isinstance(self.master, AutomaticPanedWindow):\n            return self.winfo_ismapped()\n        else:\n            return self in self.master.pane_widgets()", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Determines if the `AutomaticPanedWindow` is currently visible. It checks if the window is mapped or active within its parent `AutomaticPanedWindow`."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "pane_widgets", "line_number": 294, "body": "def pane_widgets(self):\n        result = []\n        for pane in self.panes():\n            # pane is not the widget but some kind of reference object\n            assert not isinstance(pane, tk.Widget)\n            result.append(self.nametowidget(str(pane)))\n        return result", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Retrieves and returns the list of Tkinter widgets currently displayed as panes within the window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_on_window_resize", "line_number": 302, "body": "def _on_window_resize(self, event):\n        if event.width < 10 or event.height < 10:\n            return\n        window = self.winfo_toplevel()\n        window_size = (window.winfo_width(), window.winfo_height())\n        initializing = hasattr(window, \"initializing\") and window.initializing\n\n        if (\n            not initializing\n            and not self._restoring_pane_sizes\n            and (window_size != self._last_window_size or self._full_size_not_final)\n        ):\n            self._check_restore_preferred_sizes()\n            self._last_window_size = window_size", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Responds to window resize events for `AutomaticPanedWindow` to maintain pane layout. It intelligently checks if preferred pane sizes should be restored based on new window dimensions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_on_mouse_dragged", "line_number": 317, "body": "def _on_mouse_dragged(self, event):\n        if event.widget == self and not self._restoring_pane_sizes:\n            self._update_preferred_sizes()", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Manages interactive pane resizing by updating preferred pane sizes in response to mouse drag events on the window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_update_preferred_sizes", "line_number": 321, "body": "def _update_preferred_sizes(self):\n        for pane in self.pane_widgets():\n            if getattr(pane, \"preferred_size_in_pw\", None) is not None:\n                if self.cget(\"orient\") == \"horizontal\":\n                    current_size = pane.winfo_width()\n                else:\n                    current_size = pane.winfo_height()\n\n                if current_size > 20:\n                    pane.preferred_size_in_pw = current_size", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "This method dynamically updates the \"preferred size\" attribute of individual panes within the `AutomaticPanedWindow`, storing their current dimension if it exceeds a minimum threshold. It helps maintain layout preferences for the panes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_check_restore_preferred_sizes", "line_number": 342, "body": "def _check_restore_preferred_sizes(self):\n        window = self.winfo_toplevel()\n        if getattr(window, \"initializing\", False):\n            return\n\n        try:\n            self._restoring_pane_sizes = True\n            self._restore_preferred_sizes()\n        finally:\n            self._restoring_pane_sizes = False", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "This method orchestrates restoring preferred pane sizes for the `AutomaticPanedWindow`. It prevents the operation during window initialization and manages an internal state flag."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_restore_preferred_sizes", "line_number": 353, "body": "def _restore_preferred_sizes(self):\n        total_preferred_size = 0\n        panes_without_preferred_size = []\n\n        panes = self.pane_widgets()\n        for pane in panes:\n            if not hasattr(pane, \"preferred_size_in_pw\"):\n                # child isn't fully constructed yet\n                return\n\n            if pane.preferred_size_in_pw is None:\n                panes_without_preferred_size.append(pane)\n                # self.paneconfig(pane, width=1000, height=1000)\n            else:\n                total_preferred_size += pane.preferred_size_in_pw\n\n                # Without updating pane width/height attribute\n                # the preferred size may lose effect when squeezing\n                # non-preferred panes too small. Also zooming/unzooming\n                # changes the supposedly fixed panes ...\n                #\n                # but\n                # paneconfig width/height effectively puts\n                # unexplainable maxsize to some panes\n                # if self.cget(\"orient\") == \"horizontal\":\n                #    self.paneconfig(pane, width=pane.preferred_size_in_pw)\n                # else:\n                #    self.paneconfig(pane, height=pane.preferred_size_in_pw)\n\n        assert len(panes_without_preferred_size) <= 1\n\n        size = self._get_size()\n        if size is None:\n            return\n\n        leftover_size = self._get_size() - total_preferred_size\n        used_size = 0\n        for i, pane in enumerate(panes[:-1]):\n            used_size += pane.preferred_size_in_pw or leftover_size\n            self._place_sash(i, used_size)\n            used_size += int(str(self.cget(\"sashwidth\")))", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "For the `AutomaticPanedWindow` class, this method restores preferred sizes of its panes. It positions sashes to maintain the window's intended layout, respecting individual pane size preferences."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_get_size", "line_number": 395, "body": "def _get_size(self):\n        if self.cget(\"orient\") == tk.HORIZONTAL:\n            result = self.winfo_width()\n        else:\n            result = self.winfo_height()\n\n        if result < 20:\n            # Not ready yet\n            return None\n        else:\n            return result", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Determines the current width or height of the `AutomaticPanedWindow` based on its orientation. It returns the size, or None if the widget is not yet ready for layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_place_sash", "line_number": 407, "body": "def _place_sash(self, i, distance):\n        if self.cget(\"orient\") == tk.HORIZONTAL:\n            self.sash_place(i, distance, 0)\n        else:\n            self.sash_place(i, 0, distance)", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Manages the placement of a specific sash within the paned window. It positions the sash at a given distance, adapting for horizontal or vertical orientation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_update_visibility", "line_number": 413, "body": "def _update_visibility(self):\n        if not isinstance(self.master, AutomaticPanedWindow):\n            return\n\n        if len(self.panes()) == 0 and self.is_visible():\n            self.master.forget(self)\n\n        if len(self.panes()) > 0 and not self.is_visible():\n            self.master.insert(\"auto\", self)", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Manages the `AutomaticPanedWindow`'s visibility, hiding it within its parent if it contains no panes. Conversely, it shows the window if it has content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_update_appearance", "line_number": 423, "body": "def _update_appearance(self, event=None):\n        self.configure(sashwidth=lookup_style_option(\"Sash\", \"sashthickness\", ems_to_pixels(0.6)))\n        self.configure(background=lookup_style_option(\"TPanedWindow\", \"background\"))", "is_method": true, "class_name": "AutomaticPanedWindow", "function_description": "Refreshes the paned window's visual style by configuring its sash width and background color according to the application's theme settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "create_tab_menu", "line_number": 446, "body": "def create_tab_menu(self):\n        menu = tk.Menu(self.winfo_toplevel(), tearoff=False, **get_style_configuration(\"Menu\"))\n        menu.add_command(label=tr(\"Close\"), command=self._close_tab_from_menu)\n        menu.add_command(label=tr(\"Close others\"), command=self._close_other_tabs)\n        menu.add_command(label=tr(\"Close all\"), command=self.close_tabs)\n        return menu", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Provides a Tkinter context menu for tab management within the notebook. It allows users to close the current, other, or all tabs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_letf_btn_press", "line_number": 453, "body": "def _letf_btn_press(self, event):\n        try:\n            elem = self.identify(event.x, event.y)\n            index = self.index(\"@%d,%d\" % (event.x, event.y))\n\n            if \"closebutton\" in elem:\n                self.state([\"pressed\"])\n                self.pressed_index = index\n        except Exception:\n            # may fail, if clicked outside of tab\n            return", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Detects left mouse button presses on a `ClosableNotebook` tab's close button. This prepares the notebook for a potential tab closure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_left_btn_release", "line_number": 465, "body": "def _left_btn_release(self, event):\n        if not self.instate([\"pressed\"]):\n            return\n\n        try:\n            elem = self.identify(event.x, event.y)\n            index = self.index(\"@%d,%d\" % (event.x, event.y))\n        except Exception:\n            # may fail, when mouse is dragged\n            return\n        else:\n            if \"closebutton\" in elem and self.pressed_index == index:\n                self.close_tab(index)\n\n            self.state([\"!pressed\"])\n        finally:\n            self.pressed_index = None", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Handles the left mouse button release event on the notebook. It closes the corresponding tab if a close button was successfully clicked on it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_right_btn_press", "line_number": 483, "body": "def _right_btn_press(self, event):\n        try:\n            index = self.index(\"@%d,%d\" % (event.x, event.y))\n            self._popup_index = index\n            self.tab_menu.tk_popup(*self.winfo_toplevel().winfo_pointerxy())\n        except Exception:\n            logging.exception(\"Opening tab menu\")", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Upon a right-click, this method determines which notebook tab was clicked. It then opens a context menu specific to that tab at the mouse pointer's location."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close_tab_from_menu", "line_number": 491, "body": "def _close_tab_from_menu(self):\n        self.close_tab(self._popup_index)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Closes the notebook tab indicated by the current menu selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close_other_tabs", "line_number": 494, "body": "def _close_other_tabs(self):\n        self.close_tabs(self._popup_index)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "This method closes all tabs in the ClosableNotebook except the one specified by `_popup_index`. It ensures only a specific tab remains open, simplifying the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "close_tabs", "line_number": 497, "body": "def close_tabs(self, except_index=None):\n        for tab_index in reversed(range(len(self.winfo_children()))):\n            if except_index is not None and tab_index == except_index:\n                continue\n            else:\n                self.close_tab(tab_index)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "This method provides the capability to close all tabs within the notebook. It offers an option to exclude a specific tab from being closed, useful for workspace management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "close_tab", "line_number": 504, "body": "def close_tab(self, index):\n        child = self.get_child_by_index(index)\n        if hasattr(child, \"close\"):\n            child.close()\n        else:\n            self.forget(index)\n            child.destroy()", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Closes a specified tab in the notebook. It attempts a graceful shutdown of the tab's content, otherwise it directly removes and destroys it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_child_by_index", "line_number": 512, "body": "def get_child_by_index(self, index):\n        tab_id = self.tabs()[index]\n        if tab_id:\n            return self.nametowidget(tab_id)\n        else:\n            return None", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Provides access to the content widget of a specific tab within the notebook, identified by its numerical index."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_current_child", "line_number": 519, "body": "def get_current_child(self):\n        child_id = self.select()\n        if child_id:\n            return self.nametowidget(child_id)\n        else:\n            return None", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Returns the currently selected child widget object within the `ClosableNotebook`. It provides direct access to the active tab's content or properties."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "focus_set", "line_number": 526, "body": "def focus_set(self):\n        editor = self.get_current_child()\n        if editor:\n            editor.focus_set()\n        else:\n            super().focus_set()", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Manages input focus for the ClosableNotebook, directing it to the active child editor or the notebook itself."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_check_update_style", "line_number": 533, "body": "def _check_update_style(self):\n        style = ttk.Style()\n        if \"closebutton\" in style.element_names():\n            # It's done already\n            return\n\n        # respect if required images have been defined already\n        if \"img_close\" not in self.image_names():\n            img_dir = os.path.join(os.path.dirname(__file__), \"res\")\n            ClosableNotebook._close_img = tk.PhotoImage(\n                \"img_tab_close\", file=os.path.join(img_dir, \"tab_close.gif\")\n            )\n            ClosableNotebook._close_active_img = tk.PhotoImage(\n                \"img_tab_close_active\", file=os.path.join(img_dir, \"tab_close_active.gif\")\n            )\n\n        style.element_create(\n            \"closebutton\",\n            \"image\",\n            \"img_tab_close\",\n            (\"active\", \"pressed\", \"!disabled\", \"img_tab_close_active\"),\n            (\"active\", \"!disabled\", \"img_tab_close_active\"),\n            border=8,\n            sticky=\"\",\n        )\n\n        style.layout(\n            \"ButtonNotebook.TNotebook.Tab\",\n            [\n                (\n                    \"Notebook.tab\",\n                    {\n                        \"sticky\": \"nswe\",\n                        \"children\": [\n                            (\n                                \"Notebook.padding\",\n                                {\n                                    \"side\": \"top\",\n                                    \"sticky\": \"nswe\",\n                                    \"children\": [\n                                        (\n                                            \"Notebook.focus\",\n                                            {\n                                                \"side\": \"top\",\n                                                \"sticky\": \"nswe\",\n                                                \"children\": [\n                                                    (\n                                                        \"Notebook.label\",\n                                                        {\"side\": \"left\", \"sticky\": \"\"},\n                                                    ),\n                                                    (\n                                                        \"Notebook.closebutton\",\n                                                        {\"side\": \"left\", \"sticky\": \"\"},\n                                                    ),\n                                                ],\n                                            },\n                                        )\n                                    ],\n                                },\n                            )\n                        ],\n                    },\n                )\n            ],\n        )", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Ensures `ClosableNotebook` tabs are styled with a close button. It loads necessary button images and defines the `ttk.Style` layout for the close button within each tab."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_check_remove_padding", "line_number": 599, "body": "def _check_remove_padding(self, kw):\n        # Windows themes produce 1-pixel padding to the bottom of the pane\n        # Don't know how to get rid of it using themes\n        if \"padding\" not in kw and ttk.Style().theme_use().lower() in (\n            \"windows\",\n            \"xpnative\",\n            \"vista\",\n        ):\n            kw[\"padding\"] = (0, 0, 0, -1)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "This method compensates for an unwanted 1-pixel bottom padding issue. It adjusts widget padding to ensure consistent visual rendering on Windows themes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add", "line_number": 609, "body": "def add(self, child, **kw):\n        self._check_remove_padding(kw)\n        super().add(child, **kw)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Adds a child widget to the `ClosableNotebook`. It extends the base class functionality by optionally adjusting internal padding before the addition."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "insert", "line_number": 613, "body": "def insert(self, pos, child, **kw):\n        self._check_remove_padding(kw)\n        super().insert(pos, child, **kw)", "is_method": true, "class_name": "ClosableNotebook", "function_description": "Inserts a child widget into the notebook at a specified position, ensuring proper internal padding adjustments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add", "line_number": 636, "body": "def add(self, child, **kw):\n        super().add(child, **kw)\n        self._update_visibility()", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Adds a child widget to the notebook (tabbed interface) and then automatically updates the notebook's visibility based on this addition."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "insert", "line_number": 640, "body": "def insert(self, pos, child, **kw):\n        if pos == \"auto\":\n            for sibling in map(self.nametowidget, self.tabs()):\n                if (\n                    not hasattr(sibling, \"position_key\")\n                    or sibling.position_key == None\n                    or sibling.position_key > child.position_key\n                ):\n                    pos = sibling\n                    break\n            else:\n                pos = \"end\"\n\n        super().insert(pos, child, **kw)\n        self._update_visibility()", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "This method inserts a new tab into the notebook. It supports \"auto\" positioning, which places the tab based on its `position_key` relative to existing tabs, maintaining a sorted order."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "hide", "line_number": 656, "body": "def hide(self, tab_id):\n        super().hide(tab_id)\n        self._update_visibility()", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Hides a specified tab within the AutomaticNotebook's interface. After hiding, it updates the overall display to reflect the change in visibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "forget", "line_number": 660, "body": "def forget(self, tab_id):\n        if tab_id in self.tabs() or tab_id in self.winfo_children():\n            super().forget(tab_id)\n        self._update_visibility()", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "This method removes a specified tab from the AutomaticNotebook UI. It then updates the notebook's visibility to reflect the change."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "is_visible", "line_number": 665, "body": "def is_visible(self):\n        return self in self.master.pane_widgets()", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Checks if this notebook instance is currently a visible or active pane widget within its master container."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_visible_child", "line_number": 668, "body": "def get_visible_child(self):\n        for child in self.winfo_children():\n            if str(child) == str(self.select()):\n                return child\n\n        return None", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Identifies and returns the currently selected or visible child widget within the `AutomaticNotebook`. This enables direct access to the content of the active tab."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_update_visibility", "line_number": 675, "body": "def _update_visibility(self):\n        if not isinstance(self.master, AutomaticPanedWindow):\n            return\n        if len(self.tabs()) == 0 and self.is_visible():\n            self.master.remove(self)\n\n        if len(self.tabs()) > 0 and not self.is_visible():\n            self.master.insert(\"auto\", self)", "is_method": true, "class_name": "AutomaticNotebook", "function_description": "Automatically manages the notebook's visibility within its parent. It hides the notebook when empty and shows it when tabs are present."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_clear_tree", "line_number": 728, "body": "def _clear_tree(self):\n        for child_id in self.tree.get_children():\n            self.tree.delete(child_id)", "is_method": true, "class_name": "TreeFrame", "function_description": "Removes all entries and their associated data from the graphical tree view managed by this frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "clear", "line_number": 732, "body": "def clear(self):\n        self._clear_tree()", "is_method": true, "class_name": "TreeFrame", "function_description": "Clears all items or nodes from the TreeFrame's tree structure, effectively resetting its content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "direct_insert", "line_number": 814, "body": "def direct_insert(self, index, chars, tags=None, **kw):\n        # try removing line numbers\n        # TODO: shouldn't it take place only on paste?\n        # TODO: does it occur when opening a file with line numbers in it?\n        # if self._propose_remove_line_numbers and isinstance(chars, str):\n        #    chars = try_remove_linenumbers(chars, self)\n\n        concrete_index = self.index(index)\n        line_before = self.get(concrete_index + \" linestart\", concrete_index + \" lineend\")\n        self._last_event_changed_line_count = \"\\n\" in chars\n        result = tktextext.EnhancedText.direct_insert(self, index, chars, tags=tags, **kw)\n        line_after = self.get(concrete_index + \" linestart\", concrete_index + \" lineend\")\n        trivial_for_coloring, trivial_for_parens = self._is_trivial_edit(\n            chars, line_before, line_after\n        )\n        get_workbench().event_generate(\n            \"TextInsert\",\n            index=concrete_index,\n            text=chars,\n            tags=tags,\n            text_widget=self,\n            trivial_for_coloring=trivial_for_coloring,\n            trivial_for_parens=trivial_for_parens,\n        )\n        return result", "is_method": true, "class_name": "EnhancedTextWithLogging", "function_description": "Inserts characters into the text widget and generates a 'TextInsert' event. This event provides detailed information about the insertion, including its triviality for features like syntax coloring."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "direct_delete", "line_number": 840, "body": "def direct_delete(self, index1, index2=None, **kw):\n        try:\n            # index1 may be eg \"sel.first\" and it doesn't make sense *after* deletion\n            concrete_index1 = self.index(index1)\n            if index2 is not None:\n                concrete_index2 = self.index(index2)\n            else:\n                concrete_index2 = None\n\n            chars = self.get(index1, index2)\n            self._last_event_changed_line_count = \"\\n\" in chars\n            line_before = self.get(\n                concrete_index1 + \" linestart\",\n                (concrete_index1 if concrete_index2 is None else concrete_index2) + \" lineend\",\n            )\n            return tktextext.EnhancedText.direct_delete(self, index1, index2=index2, **kw)\n        finally:\n            line_after = self.get(\n                concrete_index1 + \" linestart\",\n                (concrete_index1 if concrete_index2 is None else concrete_index2) + \" lineend\",\n            )\n            trivial_for_coloring, trivial_for_parens = self._is_trivial_edit(\n                chars, line_before, line_after\n            )\n            get_workbench().event_generate(\n                \"TextDelete\",\n                index1=concrete_index1,\n                index2=concrete_index2,\n                text_widget=self,\n                trivial_for_coloring=trivial_for_coloring,\n                trivial_for_parens=trivial_for_parens,\n            )", "is_method": true, "class_name": "EnhancedTextWithLogging", "function_description": "Deletes a specified range of text from the widget. It then generates a `TextDelete` event, providing context like the deleted content and its impact on line counts or formatting for event subscribers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_is_trivial_edit", "line_number": 873, "body": "def _is_trivial_edit(self, chars, line_before, line_after):\n        # line is taken after edit for insertion and before edit for deletion\n        if not chars.strip():\n            # linebreaks, including with automatic indent\n            # check it doesn't break a triple-quote\n            trivial_for_coloring = line_before.count(\"'''\") == line_after.count(\n                \"'''\"\n            ) and line_before.count('\"\"\"') == line_after.count('\"\"\"')\n            trivial_for_parens = trivial_for_coloring\n        elif len(chars) > 1:\n            # paste, cut, load or something like this\n            trivial_for_coloring = False\n            trivial_for_parens = False\n        elif chars == \"#\":\n            trivial_for_coloring = \"''''\" not in line_before and '\"\"\"' not in line_before\n            trivial_for_parens = trivial_for_coloring and not re.search(PARENS_REGEX, line_before)\n        elif chars in \"()[]{}\":\n            trivial_for_coloring = line_before.count(\"'''\") == line_after.count(\n                \"'''\"\n            ) and line_before.count('\"\"\"') == line_after.count('\"\"\"')\n            trivial_for_parens = False\n        elif chars == \"'\":\n            trivial_for_coloring = \"'''\" not in line_before and \"'''\" not in line_after\n            trivial_for_parens = False  # can put parens into open string\n        elif chars == '\"':\n            trivial_for_coloring = '\"\"\"' not in line_before and '\"\"\"' not in line_after\n            trivial_for_parens = False  # can put parens into open string\n        elif chars == \"\\\\\":\n            # can shorten closing quote\n            trivial_for_coloring = '\"\"\"' not in line_before and '\"\"\"' not in line_after\n            trivial_for_parens = False\n        else:\n            trivial_for_coloring = line_before.count(\"'''\") == line_after.count(\n                \"'''\"\n            ) and line_before.count('\"\"\"') == line_after.count('\"\"\"')\n            trivial_for_parens = trivial_for_coloring\n\n        return trivial_for_coloring, trivial_for_parens", "is_method": true, "class_name": "EnhancedTextWithLogging", "function_description": "Determines if a text edit is trivial concerning syntax coloring and parenthesis matching. This helps optimize text editor performance by avoiding unnecessary re-parsing for minor changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "set", "line_number": 917, "body": "def set(self, first, last):\n        try:\n            ttk.Scrollbar.set(self, first, last)\n        except Exception:\n            traceback.print_exc()", "is_method": true, "class_name": "SafeScrollbar", "function_description": "Sets the scrollbar's viewable range by calling the superclass method. It safely handles potential errors to ensure application stability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "set", "line_number": 932, "body": "def set(self, first, last):\n        if float(first) <= 0.0 and float(last) >= 1.0:\n            self.grid_remove()\n        elif float(first) > 0.001 or float(last) < 0.009:\n            # with >0 and <1 it occasionally made scrollbar wobble back and forth\n            self.grid()\n        ttk.Scrollbar.set(self, first, last)", "is_method": true, "class_name": "AutoScrollbar", "function_description": "This method updates the scrollbar's visible range and automatically controls its visibility. It hides the scrollbar when all content is visible and shows it otherwise."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "pack", "line_number": 940, "body": "def pack(self, **kw):\n        raise tk.TclError(\"cannot use pack with this widget\")", "is_method": true, "class_name": "AutoScrollbar", "function_description": "Prevents the use of the `pack` geometry manager with `AutoScrollbar` instances by raising an error, indicating that this method is not supported for layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "place", "line_number": 943, "body": "def place(self, **kw):\n        raise tk.TclError(\"cannot use place with this widget\")", "is_method": true, "class_name": "AutoScrollbar", "function_description": "Not Implemented\nThis method explicitly prevents the use of the `place` geometry manager with this AutoScrollbar widget by raising an error."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_expose", "line_number": 977, "body": "def _expose(self, event):\n        self.update_idletasks()\n        self.update_scrollbars()", "is_method": true, "class_name": "VerticallyScrollableFrame", "function_description": "Updates the frame's display and synchronizes its scrollbars. This ensures the vertically scrollable frame correctly renders its content and reflects its scrollable area."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_configure_interior", "line_number": 981, "body": "def _configure_interior(self, event):\n        self.update_scrollbars()", "is_method": true, "class_name": "VerticallyScrollableFrame", "function_description": "Updates the scrollbars to reflect the current state and content of the vertically scrollable frame's interior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "update_scrollbars", "line_number": 984, "body": "def update_scrollbars(self):\n        # update the scrollbars to match the size of the inner frame\n        size = (self.canvas.winfo_width(), self.interior.winfo_reqheight())\n        self.canvas.config(scrollregion=\"0 0 %s %s\" % size)\n        if (\n            self.interior.winfo_reqwidth() != self.canvas.winfo_width()\n            and self.canvas.winfo_width() > 10\n        ):\n            # update the interior's width to fit canvas\n            # print(\"CAWI\", self.canvas.winfo_width())\n            self.canvas.itemconfigure(self.interior_id, width=self.canvas.winfo_width())", "is_method": true, "class_name": "VerticallyScrollableFrame", "function_description": "Updates the canvas's scrollable region to match the inner frame's height. It also dynamically adjusts the interior's width to fit the canvas, ensuring correct horizontal layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_expose", "line_number": 1027, "body": "def _expose(self, event):\n        self.update_idletasks()\n        self._configure_interior(event)", "is_method": true, "class_name": "ScrollableFrame", "function_description": "Updates the ScrollableFrame and configures its interior content, typically in response to an expose event to ensure proper display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_configure_interior", "line_number": 1031, "body": "def _configure_interior(self, event):\n        # update the scrollbars to match the size of the inner frame\n        size = (self.canvas.winfo_reqwidth(), self.interior.winfo_reqheight())\n        self.canvas.config(scrollregion=\"0 0 %s %s\" % size)", "is_method": true, "class_name": "ScrollableFrame", "function_description": "Adjusts the canvas's scrollable area to match the interior frame's size. This ensures scrollbars accurately reflect content for proper navigation within the `ScrollableFrame`."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_reload_theme_options", "line_number": 1046, "body": "def _reload_theme_options(self, event=None):\n        style = ttk.Style()\n\n        states = []\n        if self[\"state\"] == \"disabled\":\n            states.append(\"disabled\")\n\n        # Following crashes when a combobox is focused\n        # if self.focus_get() == self:\n        #    states.append(\"focus\")\n        opts = {}\n        for key in [\n            \"background\",\n            \"foreground\",\n            \"highlightthickness\",\n            \"highlightcolor\",\n            \"highlightbackground\",\n        ]:\n            value = style.lookup(self.get_style_name(), key, states)\n            if value:\n                opts[key] = value\n\n        self.configure(opts)", "is_method": true, "class_name": "ThemedListbox", "function_description": "This method updates the `ThemedListbox` instance's visual properties, such as background and foreground colors, to align with the current `ttk.Style` theme. It ensures consistent UI appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_style_name", "line_number": 1070, "body": "def get_style_name(self):\n        return \"Listbox\"", "is_method": true, "class_name": "ThemedListbox", "function_description": "Provides the designated style name for the ThemedListbox component, crucial for applying themes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "destroy", "line_number": 1073, "body": "def destroy(self):\n        self.unbind(\"<<ThemeChanged>>\", self._ui_theme_change_binding)\n        super().destroy()", "is_method": true, "class_name": "ThemedListbox", "function_description": "Disposes of the themed listbox widget, removing its theme change event listener and freeing associated resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "showtip", "line_number": 1088, "body": "def showtip(self, text):\n        \"Display text in tooltip window\"\n        self.text = text\n        if self.tipwindow or not self.text:\n            return\n        x, y, _, cy = self.widget.bbox(\"insert\")\n        x = x + self.widget.winfo_rootx() + 27\n        y = y + cy + self.widget.winfo_rooty() + self.widget.winfo_height() + 2\n        self.tipwindow = tw = tk.Toplevel(self.widget)\n        if running_on_mac_os():\n            try:\n                # Must be the first thing to do after creating window\n                # https://wiki.tcl-lang.org/page/MacWindowStyle\n                tw.tk.call(\n                    \"::tk::unsupported::MacWindowStyle\", \"style\", tw._w, \"help\", \"noActivates\"\n                )\n                if get_tk_version_info() >= (8, 6, 10) and running_on_mac_os():\n                    tw.wm_overrideredirect(1)\n            except tk.TclError:\n                pass\n        else:\n            tw.wm_overrideredirect(1)\n\n        tw.wm_geometry(\"+%d+%d\" % (x, y))\n\n        if running_on_mac_os():\n            # TODO: maybe it's because of Tk 8.5, not because of Mac\n            tw.wm_transient(self.widget)\n\n        label = tk.Label(tw, text=self.text, **self.options)\n        label.pack()", "is_method": true, "class_name": "ToolTip", "function_description": "Displays a temporary tooltip window containing the specified text near the associated widget. It manages the tooltip's creation and positioning on screen."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "hidetip", "line_number": 1121, "body": "def hidetip(self, event=None):\n        tw = self.tipwindow\n        self.tipwindow = None\n        if tw:\n            tw.destroy()", "is_method": true, "class_name": "ToolTip", "function_description": "Closes and removes the active tooltip display for the ToolTip instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "enter", "line_number": 1142, "body": "def enter(event):\n        toolTip.showtip(text)", "is_method": false, "function_description": "Displays a tooltip when an associated event is triggered, providing contextual information to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "leave", "line_number": 1145, "body": "def leave(event):\n        toolTip.hidetip()", "is_method": false, "function_description": "Hides an active tooltip. This function serves as an event handler to dismiss a tooltip, typically when the mouse pointer leaves an associated element."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "clear", "line_number": 1200, "body": "def clear(self):\n        for tag in self._click_bindings:\n            self.text.tag_unbind(tag, \"<1>\", self._click_bindings[tag])\n            self.text.tag_remove(tag, \"1.0\", \"end\")\n\n        self.text.direct_delete(\"1.0\", \"end\")\n        self._current_chars = \"\"\n        self._click_bindings.clear()", "is_method": true, "class_name": "NoteBox", "function_description": "Clears all text content, removes all associated click bindings, and resets the internal state of the NoteBox instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "set_content", "line_number": 1209, "body": "def set_content(self, *items):\n        self.clear()\n\n        for item in items:\n            if isinstance(item, str):\n                self.text.direct_insert(\"1.0\", item)\n                self._current_chars = item\n            else:\n                assert isinstance(item, (list, tuple))\n                chars, *props = item\n                if len(props) > 0 and callable(props[-1]):\n                    tags = tuple(props[:-1])\n                    click_handler = props[-1]\n                else:\n                    tags = tuple(props)\n                    click_handler = None\n\n                self.append_text(chars, tags, click_handler)\n\n            self.text.see(\"1.0\")", "is_method": true, "class_name": "NoteBox", "function_description": "Sets the entire content of the NoteBox, clearing any existing display. It supports adding plain text or structured text with formatting tags and optional interactive click handlers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "append_text", "line_number": 1230, "body": "def append_text(self, chars, tags=(), click_handler=None):\n        tags = tuple(tags)\n\n        if click_handler is not None:\n            click_tag = \"click_%d\" % len(self._click_bindings)\n            tags = tags + (click_tag,)\n            binding = self.text.tag_bind(click_tag, \"<1>\", click_handler, True)\n            self._click_bindings[click_tag] = binding\n\n        self.text.direct_insert(\"end\", chars, tags)\n        self._current_chars += chars", "is_method": true, "class_name": "NoteBox", "function_description": "Adds text to the NoteBox's display area, optionally applying tags for styling or behavior. It allows making the newly added text clickable by binding a provided handler to its click event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "place", "line_number": 1242, "body": "def place(self, target, focus=None):\n\n        # Compute the area that will be described by this Note\n        focus_x = target.winfo_rootx()\n        focus_y = target.winfo_rooty()\n        focus_height = target.winfo_height()\n\n        if isinstance(focus, TextRange):\n            assert isinstance(target, tk.Text)\n            topleft = target.bbox(\"%d.%d\" % (focus.lineno, focus.col_offset))\n            if focus.end_col_offset == 0:\n                botright = target.bbox(\n                    \"%d.%d lineend\" % (focus.end_lineno - 1, focus.end_lineno - 1)\n                )\n            else:\n                botright = target.bbox(\"%d.%d\" % (focus.end_lineno, focus.end_col_offset))\n\n            if topleft and botright:\n                focus_x += topleft[0]\n                focus_y += topleft[1]\n                focus_height = botright[1] - topleft[1] + botright[3]\n\n        elif isinstance(focus, (list, tuple)):\n            focus_x += focus[0]\n            focus_y += focus[1]\n            focus_height = focus[3]\n\n        elif focus is None:\n            pass\n\n        else:\n            raise TypeError(\"Unsupported focus\")\n\n        # Compute dimensions of the note\n        font = self.text[\"font\"]\n        if isinstance(font, str):\n            font = tk.font.nametofont(font)\n\n        lines = self._current_chars.splitlines()\n        max_line_width = 0\n        for line in lines:\n            max_line_width = max(max_line_width, font.measure(line))\n\n        width = min(max_line_width, self._max_default_width) + self.padx * 2 + 2\n        self.wm_geometry(\"%dx%d+%d+%d\" % (width, 100, focus_x, focus_y + focus_height))\n\n        self.update_idletasks()\n        line_count = int(float(self.text.index(\"end\")))\n        line_height = font.metrics()[\"linespace\"]\n\n        self.wm_geometry(\n            \"%dx%d+%d+%d\" % (width, line_count * line_height, focus_x, focus_y + focus_height)\n        )\n\n        # TODO: detect the situation when note doesn't fit under\n        # the focus box and should be placed above\n\n        self.deiconify()", "is_method": true, "class_name": "NoteBox", "function_description": "Positions and sizes the NoteBox window. It dynamically calculates its placement and dimensions relative to a target widget or a specific text range within it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "show_note", "line_number": 1301, "body": "def show_note(self, *content_items: Union[str, List], target=None, focus=None) -> None:\n\n        self.set_content(*content_items)\n        self.place(target, focus)", "is_method": true, "class_name": "NoteBox", "function_description": "Displays a note by setting its content and positioning it at a specified target or focus point."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close_maybe", "line_number": 1306, "body": "def _close_maybe(self, event):\n        if event.widget not in [self, self.text]:\n            self.close(event)", "is_method": true, "class_name": "NoteBox", "function_description": "Conditionally closes the NoteBox widget when an interaction occurs outside its boundaries. This ensures the temporary box automatically dismisses itself if the user clicks elsewhere."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "close", "line_number": 1310, "body": "def close(self, event=None):\n        self.withdraw()", "is_method": true, "class_name": "NoteBox", "function_description": "Hides the NoteBox window, making it disappear from the screen without destroying the object, allowing for later re-display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_on_write", "line_number": 1338, "body": "def _on_write(self, *args):\n        self.modified = True\n        if self.modification_listener:\n            try:\n                self.modification_listener()\n            except Exception:\n                # Otherwise whole process will be brought down\n                # because for some reason Tk tries to call non-existing method\n                # on variable\n                get_workbench().report_exception()", "is_method": true, "class_name": "EnhancedVar", "function_description": "Manages modifications to an EnhancedVar, setting a 'modified' flag. It then safely invokes a registered callback listener to react to the change."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_poll", "line_number": 1567, "body": "def _poll(self):\n        if self._async_result.ready():\n            self._close()\n        elif self.timeout and time.time() - self.start_time > self.timeout:\n            raise TimeoutError()\n        else:\n            self.after(500, self._poll)\n            self.desc_label[\"text\"] = self.desc_label[\"text\"] + \".\"", "is_method": true, "class_name": "WaitingDialog", "function_description": "This internal method of WaitingDialog periodically checks an asynchronous operation's status. It closes the dialog on completion, raises an error on timeout, or updates the UI while waiting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close", "line_number": 1576, "body": "def _close(self):\n        self.destroy()", "is_method": true, "class_name": "WaitingDialog", "function_description": "This method closes the `WaitingDialog` instance. It dismisses the dialog from the user interface when its purpose is fulfilled."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_start", "line_number": 1634, "body": "def _start(self):\n        def work():\n            self._copy_progess = 0\n\n            with open(self._source, \"rb\") as fsrc:\n                with open(self._destination, \"wb\") as fdst:\n                    while True:\n                        buf = fsrc.read(16 * 1024)\n                        if not buf:\n                            break\n\n                        fdst.write(buf)\n                        fdst.flush()\n                        if self._fsync:\n                            os.fsync(fdst)\n                        self._bytes_copied += len(buf)\n\n            self._done = True\n\n        threading.Thread(target=work, daemon=True).start()", "is_method": true, "class_name": "FileCopyDialog", "function_description": "Initiates the file copying process for the dialog by reading from source and writing to destination. It performs the copy operation in a background thread to prevent blocking the UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_update_progress", "line_number": 1655, "body": "def _update_progress(self):\n        if self._done:\n            if not self._closed:\n                self._close()\n            return\n\n        self._bar.step(self._bytes_copied - self._old_bytes_copied)\n        self._old_bytes_copied = self._bytes_copied\n\n        self.after(100, self._update_progress)", "is_method": true, "class_name": "FileCopyDialog", "function_description": "Continuously updates the file copy progress bar within the dialog. It also handles the dialog's closure once the file copy operation is complete."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close", "line_number": 1666, "body": "def _close(self):\n        self.destroy()\n        self._closed = True", "is_method": true, "class_name": "FileCopyDialog", "function_description": "This method closes the file copy dialog window. It updates the dialog's internal state to indicate that it is no longer active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_cancel", "line_number": 1670, "body": "def _cancel(self, event=None):\n        self._cancelled = True\n        self._close()", "is_method": true, "class_name": "FileCopyDialog", "function_description": "Marks the file copy operation as cancelled and closes the dialog window, indicating the user's intent to stop the process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_ok", "line_number": 1714, "body": "def _ok(self):\n        self.result = self.var.get()\n        if not self.result:\n            self.result = None\n\n        self.destroy()", "is_method": true, "class_name": "ChoiceDialog", "function_description": "Finalizes the user's selection within the `ChoiceDialog` by capturing the chosen value. It then stores this result and closes the dialog window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_cancel", "line_number": 1721, "body": "def _cancel(self):\n        self.result = None\n        self.destroy()", "is_method": true, "class_name": "ChoiceDialog", "function_description": "Provides the service to cancel the `ChoiceDialog` operation. It sets the dialog's result to `None` and closes the dialog window, indicating no selection was made."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_copy", "line_number": 1771, "body": "def _copy(self, event=None):\n        self.clipboard_clear()\n        self.clipboard_append(self._text.text.get(\"1.0\", \"end\"))", "is_method": true, "class_name": "LongTextDialog", "function_description": "This method copies the entire content of the dialog's long text display to the system clipboard. It enables users to easily extract the displayed text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_close", "line_number": 1775, "body": "def _close(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "LongTextDialog", "function_description": "This method closes and destroys the `LongTextDialog` window, typically used when the user dismisses the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askopenfilename", "line_number": 1930, "body": "def askopenfilename(cls, **options):\n        args = cls._convert_common_options(\"Open file\", **options)\n        return cls._call(args)", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "Provides a graphical \"open file\" dialog using Zenity, enabling users to select a file from their system and returning its path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askopenfilenames", "line_number": 1935, "body": "def askopenfilenames(cls, **options):\n        args = cls._convert_common_options(\"Open files\", **options)\n        return cls._call(args + [\"--multiple\"]).split(\"|\")", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "This method displays a graphical dialog allowing users to select multiple files from their system. It returns a list containing the paths of the chosen files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "asksaveasfilename", "line_number": 1940, "body": "def asksaveasfilename(cls, **options):\n        args = cls._convert_common_options(\"Save as\", **options)\n        args.append(\"--save\")\n        if options.get(\"confirmoverwrite\", True):\n            args.append(\"--confirm-overwrite\")\n\n        filename = cls._call(args)\n        if not filename:\n            return None\n\n        if \"defaultextension\" in options and \".\" not in os.path.basename(filename):\n            filename += options[\"defaultextension\"]\n\n        return filename", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "Provides a graphical 'Save As' dialog for the user to select a file path. It includes options for confirming overwrites and adding default extensions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "askdirectory", "line_number": 1956, "body": "def askdirectory(cls, **options):\n        args = cls._convert_common_options(\"Select directory\", **options)\n        args.append(\"--directory\")\n        return cls._call(args)", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "Displays a Zenity graphical dialog for the user to select a directory. It provides a user-friendly way to obtain a directory path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_convert_common_options", "line_number": 1962, "body": "def _convert_common_options(cls, default_title, **options):\n        args = [\"--file-selection\", \"--title=%s\" % options.get(\"title\", default_title)]\n\n        filename = _options_to_zenity_filename(options)\n        if filename:\n            args.append(\"--filename=%s\" % filename)\n\n        parent = options.get(\"parent\", options.get(\"master\", None))\n        if parent is not None:\n            args.append(\"--modal\")\n            args.append(\"--attach=%s\" % hex(parent.winfo_id()))\n\n        for desc, pattern in options.get(\"filetypes\", ()):\n            # zenity requires star before extension\n            pattern = pattern.replace(\" .\", \" *.\")\n            if pattern.startswith(\".\"):\n                pattern = \"*\" + pattern\n\n            if pattern == \"*.*\":\n                # \".*\" was provided to make the pattern safe for Tk dialog\n                # not required with Zenity\n                pattern = \"*\"\n\n            args.append(\"--file-filter=%s | %s\" % (desc, pattern))\n\n        return args", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "Prepares a list of command-line arguments for a Zenity file selection dialog, converting standard dialog options into Zenity-specific formats."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "_call", "line_number": 1990, "body": "def _call(cls, args):\n        args = [\"zenity\", \"--name=Thonny\", \"--class=Thonny\"] + args\n        result = subprocess.run(\n            args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True\n        )\n        if result.returncode == 0:\n            return result.stdout.strip()\n        else:\n            # TODO: log problems\n            print(result.stderr, file=sys.stderr)\n            # could check stderr, but it may contain irrelevant warnings\n            return None", "is_method": true, "class_name": "_ZenityDialogProvider", "function_description": "Executes a Zenity command with Thonny-specific parameters to display a graphical dialog. It returns the command's standard output on successful execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "read_stream", "line_number": 2113, "body": "def read_stream(stream, target_list):\n        while True:\n            line = stream.readline()\n            if line:\n                target_list.append(line)\n            else:\n                break", "is_method": false, "function_description": "Reads all lines from an input stream. It appends each line to a provided list until the stream is exhausted."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "poll", "line_number": 2126, "body": "def poll():\n        if proc.poll() is not None:\n            t_out.join(3)\n            t_err.join(3)\n            on_completion(proc, out_lines, err_lines)\n            return\n\n        tk._default_root.after(int(poll_delay * 1000), poll)", "is_method": false, "function_description": "This function continuously polls an external process for its completion status. Upon process termination, it finalizes related threads and triggers a specified completion callback."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_post", "line_number": 2146, "body": "def on_post(self, *args):\n        self.update_item_availability()", "is_method": true, "class_name": "MenuEx", "function_description": "This method serves as a POST request handler for the MenuEx class. It updates the availability status of menu items, allowing external triggers to refresh menu state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "update_item_availability", "line_number": 2149, "body": "def update_item_availability(self):\n        for i in range(self.index(\"end\") + 1):\n            item_data = self.entryconfigure(i)\n            if \"label\" in item_data:\n                tester = self._testers.get(item_data[\"label\"])\n                if tester and not tester():\n                    self.entryconfigure(i, state=tk.DISABLED)\n                else:\n                    self.entryconfigure(i, state=tk.NORMAL)", "is_method": true, "class_name": "MenuEx", "function_description": "This method dynamically updates the enabled or disabled state of menu items. It queries associated \"tester\" functions for each item to determine its current availability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add", "line_number": 2159, "body": "def add(self, itemType, cnf={}, **kw):\n        cnf = cnf or kw\n        tester = cnf.get(\"tester\")\n        if \"tester\" in cnf:\n            del cnf[\"tester\"]\n\n        super().add(itemType, cnf)\n\n        itemdata = self.entryconfigure(self.index(\"end\"))\n        labeldata = itemdata.get(\"label\")\n        if labeldata:\n            self._testers[labeldata] = tester", "is_method": true, "class_name": "MenuEx", "function_description": "Adds an item to the menu, passing standard configuration to the parent class. It also extracts and stores a 'tester' function, associating it with the new item's label for custom behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add_basic_items", "line_number": 2180, "body": "def add_basic_items(self):\n        self.add_command(label=tr(\"Cut\"), command=self.on_cut, tester=self.can_cut)\n        self.add_command(label=tr(\"Copy\"), command=self.on_copy, tester=self.can_copy)\n        self.add_command(label=tr(\"Paste\"), command=self.on_paste, tester=self.can_paste)", "is_method": true, "class_name": "TextMenu", "function_description": "Configures the TextMenu by adding standard 'Cut', 'Copy', and 'Paste' commands. It sets up their associated actions and availability tests."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "add_extra_items", "line_number": 2185, "body": "def add_extra_items(self):\n        self.add_separator()\n        self.add_command(label=tr(\"Select All\"), command=self.on_select_all)", "is_method": true, "class_name": "TextMenu", "function_description": "Configures the menu by appending a visual separator and a \"Select All\" command, enhancing standard text editing capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_cut", "line_number": 2189, "body": "def on_cut(self):\n        self.text.event_generate(\"<<Cut>>\")", "is_method": true, "class_name": "TextMenu", "function_description": "Triggers the 'cut' operation on the linked text widget. This method is typically used to implement a 'Cut' menu item."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_copy", "line_number": 2192, "body": "def on_copy(self):\n        self.text.event_generate(\"<<Copy>>\")", "is_method": true, "class_name": "TextMenu", "function_description": "Triggers the standard copy event on the associated text widget. This allows a menu item to initiate copying selected text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_paste", "line_number": 2195, "body": "def on_paste(self):\n        self.text.event_generate(\"<<Paste>>\")", "is_method": true, "class_name": "TextMenu", "function_description": "Triggers the standard paste event on the associated text widget. This allows a menu item to programmatically initiate a paste operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "on_select_all", "line_number": 2198, "body": "def on_select_all(self):\n        self.text.event_generate(\"<<SelectAll>>\")", "is_method": true, "class_name": "TextMenu", "function_description": "Triggers the \"select all\" action for the associated text component, enabling selection of all displayed text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "can_cut", "line_number": 2201, "body": "def can_cut(self):\n        return self.get_selected_text() and not self.selection_is_read_only()", "is_method": true, "class_name": "TextMenu", "function_description": "Determines if the currently selected text within the menu can be cut. It verifies that text is selected and is not read-only, typically used to enable or disable a \"cut\" action."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "can_copy", "line_number": 2204, "body": "def can_copy(self):\n        return self.get_selected_text()", "is_method": true, "class_name": "TextMenu", "function_description": "The function checks if text is currently selected within the TextMenu. It determines if a copy operation is possible, often used to enable/disable UI elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "can_paste", "line_number": 2207, "body": "def can_paste(self):\n        return not self.selection_is_read_only()", "is_method": true, "class_name": "TextMenu", "function_description": "Checks if content can be pasted into the text menu's current selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "get_selected_text", "line_number": 2210, "body": "def get_selected_text(self):\n        try:\n            return self.text.get(\"sel.first\", \"sel.last\")\n        except TclError:\n            return \"\"", "is_method": true, "class_name": "TextMenu", "function_description": "This method retrieves the text currently selected by the user from the associated text display component. It returns an empty string if no text is selected or an error occurs during retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "selection_is_read_only", "line_number": 2216, "body": "def selection_is_read_only(self):\n        if hasattr(self.text, \"is_read_only\"):\n            return self.text.is_read_only()\n\n        return False", "is_method": true, "class_name": "TextMenu", "function_description": "Determines if the text selection managed by the menu is read-only. This allows the TextMenu to enable or disable editing options accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "wrap_with_parent_checker", "line_number": 2290, "body": "def wrap_with_parent_checker(original):\n        def wrapper(*args, **options):\n            _check_dialog_parent(options)\n            return original(*args, **options)\n\n        return wrapper", "is_method": false, "function_description": "It provides a decorator-like utility to add a pre-execution check for a dialog's parent before running the original function. This ensures required parent conditions are met."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "leave", "line_number": 194, "body": "def leave(event):\n            label_widget.state((\"!active\",))", "is_method": true, "class_name": "CustomMenubar", "function_description": "This method deactivates a label widget, typically removing its 'active' visual state when a pointer leaves its area."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "click", "line_number": 197, "body": "def click(event):\n            try:\n                # print(\"Before\")\n                self._opened_menu = menu\n                menu.tk_popup(\n                    label_widget.winfo_rootx(),\n                    label_widget.winfo_rooty() + label_widget.winfo_height(),\n                )\n            finally:\n                # print(\"After\")\n                self._opened_menu = None", "is_method": true, "class_name": "CustomMenubar", "function_description": "Displays a pop-up menu on a click event, positioning it relative to a label widget. It also manages an internal state for the currently opened menu."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "work", "line_number": 1635, "body": "def work():\n            self._copy_progess = 0\n\n            with open(self._source, \"rb\") as fsrc:\n                with open(self._destination, \"wb\") as fdst:\n                    while True:\n                        buf = fsrc.read(16 * 1024)\n                        if not buf:\n                            break\n\n                        fdst.write(buf)\n                        fdst.flush()\n                        if self._fsync:\n                            os.fsync(fdst)\n                        self._bytes_copied += len(buf)\n\n            self._done = True", "is_method": true, "class_name": "FileCopyDialog", "function_description": "Executes the file copying process from source to destination within the dialog, updating progress and ensuring data integrity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/ui_utils.py", "function": "wrapper", "line_number": 2291, "body": "def wrapper(*args, **options):\n            _check_dialog_parent(options)\n            return original(*args, **options)", "is_method": false, "function_description": "This wrapper function validates dialog parent options before executing the original function. It ensures a required UI context is valid prior to proceeding."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_compute_thonny_user_dir", "line_number": 11, "body": "def _compute_thonny_user_dir():\n    if os.environ.get(\"THONNY_USER_DIR\", \"\"):\n        return os.path.expanduser(os.environ[\"THONNY_USER_DIR\"])\n    elif is_portable():\n        if platform.system() == \"Windows\":\n            root_dir = os.path.dirname(sys.executable)\n        elif platform.system() == \"Darwin\":\n            root_dir = os.path.join(\n                os.path.dirname(sys.executable), \"..\", \"..\", \"..\", \"..\", \"..\", \"..\"\n            )\n        else:\n            root_dir = os.path.join(os.path.dirname(sys.executable), \"..\")\n        return os.path.normpath(os.path.abspath(os.path.join(root_dir, \"user_data\")))\n    elif (\n        hasattr(sys, \"base_prefix\")\n        and sys.base_prefix != sys.prefix\n        or hasattr(sys, \"real_prefix\")\n        and getattr(sys, \"real_prefix\") != sys.prefix\n    ):\n        # we're in a virtualenv or venv\n        return os.path.join(sys.prefix, \".thonny\")\n    elif platform.system() == \"Windows\":\n        from thonny import misc_utils\n\n        return os.path.join(misc_utils.get_roaming_appdata_dir(), \"Thonny\")\n    elif platform.system() == \"Darwin\":\n        return os.path.expanduser(\"~/Library/Thonny\")\n    else:\n        # https://specifications.freedesktop.org/basedir-spec/latest/ar01s02.html\n        data_home = os.environ.get(\n            \"XDG_CONFIG_HOME\", os.path.expanduser(os.path.join(\"~\", \".config\"))\n        )\n        return os.path.join(data_home, \"Thonny\")", "is_method": false, "function_description": "Determines the appropriate user data directory for the Thonny application. It accounts for environment variables, portable installations, and operating system conventions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_read_configured_debug_mode", "line_number": 46, "body": "def _read_configured_debug_mode():\n    if not os.path.exists(CONFIGURATION_FILE):\n        return False\n\n    try:\n        with open(CONFIGURATION_FILE, encoding=\"utf-8\") as fp:\n            for line in fp:\n                if \"debug_mode\" in line and \"True\" in line:\n                    return True\n        return False\n    except Exception:\n        import traceback\n\n        traceback.print_exc()\n        return False", "is_method": false, "function_description": "Determines if debug mode is enabled by checking for a specific flag within a global configuration file."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "is_portable", "line_number": 63, "body": "def is_portable():\n    # it can be explicitly declared as portable or shared ...\n    portable_marker_path = os.path.join(os.path.dirname(sys.executable), \"portable_thonny.ini\")\n    shared_marker_path = os.path.join(os.path.dirname(sys.executable), \"shared_thonny.ini\")\n\n    if os.path.exists(portable_marker_path) and not os.path.exists(shared_marker_path):\n        return True\n    elif not os.path.exists(portable_marker_path) and os.path.exists(shared_marker_path):\n        return False\n\n    # ... or it becomes implicitly portable if it's on a removable drive\n    abs_location = os.path.abspath(__file__)\n    if platform.system() == \"Windows\":\n        drive = os.path.splitdrive(abs_location)[0]\n        if drive.endswith(\":\"):\n            from ctypes import windll\n\n            return windll.kernel32.GetDriveTypeW(drive) == 2  # @UndefinedVariable\n        else:\n            return False\n    elif platform.system() == \"Darwin\":\n        # not exact heuristics\n        return abs_location.startswith(\"/Volumes/\")\n    else:\n        # not exact heuristics\n        return abs_location.startswith(\"/media/\") or abs_location.startswith(\"/mnt/\")", "is_method": false, "function_description": "Ascertains if the application is running in a portable mode. It checks for explicit configuration markers or infers portability from its location on a removable drive."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "get_version", "line_number": 91, "body": "def get_version():\n    try:\n        package_dir = os.path.dirname(sys.modules[\"thonny\"].__file__)\n        with open(os.path.join(package_dir, \"VERSION\"), encoding=\"ASCII\") as fp:\n            return fp.read().strip()\n    except Exception:\n        return \"0.0.0\"", "is_method": false, "function_description": "Retrieves the version string of the installed 'thonny' package. Defaults to '0.0.0' if the version cannot be found or read."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "get_ipc_file_path", "line_number": 108, "body": "def get_ipc_file_path():\n    global _IPC_FILE\n    if _IPC_FILE:\n        return _IPC_FILE\n\n    from thonny import misc_utils\n\n    if platform.system() == \"Windows\":\n        base_dir = misc_utils.get_local_appdata_dir()\n    else:\n        base_dir = os.environ.get(\"XDG_RUNTIME_DIR\")\n        if not base_dir or not os.path.exists(base_dir):\n            base_dir = os.environ.get(\"TMPDIR\")\n\n    if not base_dir or not os.path.exists(base_dir):\n        base_dir = THONNY_USER_DIR\n\n    for name in (\"LOGNAME\", \"USER\", \"LNAME\", \"USERNAME\"):\n        if name in os.environ:\n            username = os.environ.get(name)\n            break\n    else:\n        username = os.path.basename(os.path.expanduser(\"~\"))\n\n    ipc_dir = os.path.join(base_dir, \"thonny-%s\" % username)\n    os.makedirs(ipc_dir, exist_ok=True)\n\n    if not platform.system() == \"Windows\":\n        os.chmod(ipc_dir, 0o700)\n\n    _IPC_FILE = os.path.join(ipc_dir, \"ipc.sock\")\n    return _IPC_FILE", "is_method": false, "function_description": "This function determines and returns a stable, OS-specific file path for inter-process communication (IPC). It creates and secures the necessary directory for Thonny processes to establish connections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_check_welcome", "line_number": 142, "body": "def _check_welcome():\n    from thonny import misc_utils\n\n    if not os.path.exists(CONFIGURATION_FILE) and not misc_utils.running_on_rpi():\n        from thonny.config import ConfigurationManager\n        from thonny.first_run import FirstRunWindow\n\n        mgr = ConfigurationManager(CONFIGURATION_FILE)\n\n        win = FirstRunWindow(mgr)\n        win.mainloop()\n        return win.ok\n    else:\n        return True", "is_method": false, "function_description": "Handles the application's first-time startup. If no configuration exists and not on RPi, it displays a welcome window for initial setup, returning its success."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "launch", "line_number": 158, "body": "def launch():\n    import runpy\n    import socket\n\n    if sys.executable.endswith(\"thonny.exe\"):\n        # otherwise some library may try to run its subprocess with thonny.exe\n        # NB! Must be pythonw.exe not python.exe, otherwise Runner thinks console\n        # is already allocated.\n        sys.executable = sys.executable[: -len(\"thonny.exe\")] + \"pythonw.exe\"\n\n    set_dpi_aware()\n\n    try:\n        runpy.run_module(\"thonny.customize\", run_name=\"__main__\")\n    except ImportError:\n        pass\n\n    prepare_thonny_user_dir()\n    _configure_frontend_logging()\n\n    if not _check_welcome():\n        return 0\n\n    if _should_delegate():\n        try:\n            _delegate_to_existing_instance(sys.argv[1:])\n            print(\"Delegated to an existing Thonny instance. Exiting now.\")\n            return 0\n        except (ConnectionRefusedError, socket.timeout):\n            pass\n\n    # Did not or could not delegate\n\n    try:\n        from thonny import workbench\n\n        bench = workbench.Workbench()\n        try:\n            bench.mainloop()\n        except SystemExit:\n            bench.destroy()\n        return 0\n\n    except SystemExit as e:\n        from tkinter import messagebox, _default_root\n\n        messagebox.showerror(\"System exit\", str(e), master=_default_root)\n        return -1\n\n    except Exception:\n        from logging import exception\n\n        exception(\"Internal launch or mainloop error\")\n        from thonny import ui_utils\n\n        dlg = ui_utils.LongTextDialog(\"Internal error\", traceback.format_exc())\n        ui_utils.show_dialog(dlg, get_workbench())\n        return -1\n    finally:\n        runner = get_runner()\n        if runner is not None:\n            runner.destroy_backend()\n\n    return 0", "is_method": false, "function_description": "Launches the Thonny IDE application, performing initial setup and handling delegation to an existing instance. It then starts the main graphical user interface for the development environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "prepare_thonny_user_dir", "line_number": 224, "body": "def prepare_thonny_user_dir():\n    if not os.path.exists(THONNY_USER_DIR):\n        os.makedirs(THONNY_USER_DIR, mode=0o700, exist_ok=True)\n\n        # user_dir_template is a post-installation means for providing\n        # alternative default user environment in multi-user setups\n        template_dir = os.path.join(os.path.dirname(__file__), \"user_dir_template\")\n\n        if os.path.isdir(template_dir):\n            import shutil\n\n            def copy_contents(src_dir, dest_dir):\n                # I want the copy to have current user permissions\n                for name in os.listdir(src_dir):\n                    src_item = os.path.join(src_dir, name)\n                    dest_item = os.path.join(dest_dir, name)\n                    if os.path.isdir(src_item):\n                        os.makedirs(dest_item, mode=0o700)\n                        copy_contents(src_item, dest_item)\n                    else:\n                        shutil.copyfile(src_item, dest_item)\n                        os.chmod(dest_item, 0o600)\n\n            copy_contents(template_dir, THONNY_USER_DIR)", "is_method": false, "function_description": "Establishes the Thonny user directory, creating it if absent, and populating it with default files from a template. This prepares the user's persistent workspace."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_should_delegate", "line_number": 250, "body": "def _should_delegate():\n    if not os.path.exists(get_ipc_file_path()):\n        # no previous instance\n        return False\n\n    from thonny.config import try_load_configuration\n\n    configuration_manager = try_load_configuration(CONFIGURATION_FILE)\n    configuration_manager.set_default(\"general.single_instance\", SINGLE_INSTANCE_DEFAULT)\n    return configuration_manager.get_option(\"general.single_instance\")", "is_method": false, "function_description": "Determines if execution should be delegated to another application instance. It bases this decision on the existence of an inter-process communication file and a 'single instance' configuration setting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_delegate_to_existing_instance", "line_number": 262, "body": "def _delegate_to_existing_instance(args):\n    import socket\n\n    from thonny import workbench\n\n    transformed_args = []\n    for arg in args:\n        if not arg.startswith(\"-\"):\n            arg = os.path.abspath(arg)\n\n        transformed_args.append(arg)\n\n    try:\n        sock, secret = _create_client_socket()\n    except (ConnectionRefusedError, socket.timeout):\n        # Maybe the lock is abandoned\n        os.remove(get_ipc_file_path())\n        raise\n\n    data = repr((secret, transformed_args)).encode(encoding=\"utf_8\")\n\n    sock.settimeout(2.0)\n    sock.sendall(data)\n    sock.shutdown(socket.SHUT_WR)\n    response = bytes([])\n    while len(response) < len(workbench.SERVER_SUCCESS):\n        new_data = sock.recv(2)\n        if len(new_data) == 0:\n            break\n        else:\n            response += new_data\n\n    if response.decode(\"UTF-8\") != workbench.SERVER_SUCCESS:\n        raise RuntimeError(\"Unsuccessful delegation\")", "is_method": false, "function_description": "Delegates command-line arguments to an already running application instance using inter-process communication (IPC) via a socket. This enables single-instance behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_create_client_socket", "line_number": 298, "body": "def _create_client_socket():\n    import socket\n\n    timeout = 2.0\n\n    if platform.system() == \"Windows\":\n        with open(get_ipc_file_path(), \"r\") as fp:\n            port = int(fp.readline().strip())\n            secret = fp.readline().strip()\n\n        # \"localhost\" can be much slower than \"127.0.0.1\"\n        client_socket = socket.create_connection((\"127.0.0.1\", port), timeout=timeout)\n    else:\n        client_socket = socket.socket(socket.AF_UNIX)  # @UndefinedVariable\n        client_socket.settimeout(timeout)\n        client_socket.connect(get_ipc_file_path())\n        secret = \"\"\n\n    return client_socket, secret", "is_method": false, "function_description": "Creates an OS-specific client socket for inter-process communication, connecting via TCP/IP on Windows or a Unix domain socket otherwise. It also retrieves a connection secret."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_configure_frontend_logging", "line_number": 319, "body": "def _configure_frontend_logging() -> None:\n    _configure_logging(\"frontend.log\")", "is_method": false, "function_description": "This function configures the logging system specifically for the frontend component of an application. It ensures all frontend-related log messages are directed to a dedicated file named \"frontend.log\"."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "configure_backend_logging", "line_number": 323, "body": "def configure_backend_logging() -> None:\n    _configure_logging(\"backend.log\", logging.WARNING)", "is_method": false, "function_description": "Configures the logging system specifically for the backend. It sets up log output to a file named \"backend.log\" with a minimum logging level of WARNING."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_configure_logging", "line_number": 327, "body": "def _configure_logging(filename, console_level=None):\n    logFormatter = logging.Formatter(\"%(levelname)-7s %(name)s: %(message)s\")\n\n    # NB! Don't mess with the root logger, because (CPython) backend runs user code\n    thonny_root_logger = logging.getLogger(\"thonny\")\n    thonny_root_logger.setLevel(_choose_logging_level())\n    thonny_root_logger.propagate = False  # otherwise it will be also reported by IDE-s root logger\n\n    log_file = os.path.join(THONNY_USER_DIR, filename)\n    file_handler = logging.FileHandler(log_file, encoding=\"UTF-8\", mode=\"w\")\n    file_handler.setFormatter(logFormatter)\n    thonny_root_logger.addHandler(file_handler)\n\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setFormatter(logFormatter)\n    if console_level is None:\n        console_level = _choose_logging_level()\n    console_handler.setLevel(console_level)\n    thonny_root_logger.addHandler(console_handler)\n\n    thonny_root_logger.info(\"Thonny version: %s\", get_version())\n\n    import faulthandler\n\n    fault_out = open(os.path.join(THONNY_USER_DIR, \"frontend_faults.log\"), mode=\"w\")\n    faulthandler.enable(fault_out)", "is_method": false, "function_description": "Configures the application's logging system, directing output to both a file and the console. It also enables a fault handler to log fatal errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "set_dpi_aware", "line_number": 355, "body": "def set_dpi_aware():\n    # https://stackoverflow.com/questions/36134072/setprocessdpiaware-seems-not-to-work-under-windows-10\n    # https://bugs.python.org/issue33656\n    # https://msdn.microsoft.com/en-us/library/windows/desktop/dn280512(v=vs.85).aspx\n    # https://github.com/python/cpython/blob/master/Lib/idlelib/pyshell.py\n    if sys.platform == \"win32\":\n        try:\n            import ctypes\n\n            PROCESS_SYSTEM_DPI_AWARE = 1\n            ctypes.OleDLL(\"shcore\").SetProcessDpiAwareness(PROCESS_SYSTEM_DPI_AWARE)\n        except (ImportError, AttributeError, OSError):\n            pass", "is_method": false, "function_description": "Configures the current process on Windows to be DPI (Dots Per Inch) aware, preventing UI scaling issues on high-resolution displays."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "get_workbench", "line_number": 381, "body": "def get_workbench() -> \"Workbench\":\n    return cast(\"Workbench\", _workbench)", "is_method": false, "function_description": "Provides access to the global, singleton Workbench instance. This allows other parts of the system to retrieve and interact with the central workbench object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "set_logging_level", "line_number": 388, "body": "def set_logging_level(level=None):\n    if level is None:\n        level = _choose_logging_level()\n\n    logging.getLogger(\"thonny\").setLevel(level)", "is_method": false, "function_description": "Sets the logging level for the \"thonny\" application, controlling the verbosity of its log messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "_choose_logging_level", "line_number": 395, "body": "def _choose_logging_level():\n    if in_debug_mode():\n        return logging.DEBUG\n    else:\n        return logging.INFO", "is_method": false, "function_description": "Determines the appropriate logging level (DEBUG or INFO) based on the application's debug status. This allows dynamic control over log verbosity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "in_debug_mode", "line_number": 402, "body": "def in_debug_mode() -> bool:\n    # Value may be something other than string when it is set in Python code\n    return (\n        os.environ.get(\"THONNY_DEBUG\", False)\n        in [\n            \"1\",\n            1,\n            \"True\",\n            True,\n            \"true\",\n        ]\n        or _CONFIGURED_DEBUG\n    )", "is_method": false, "function_description": "Provides a boolean flag indicating if the application is running in debug mode. It checks environment variables and internal configuration to determine the current state for conditional behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "get_runner", "line_number": 417, "body": "def get_runner() -> \"Runner\":\n    return cast(\"Runner\", _runner)", "is_method": false, "function_description": "Retrieves the singleton `Runner` object, which orchestrates the application's execution flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "get_shell", "line_number": 421, "body": "def get_shell() -> \"ShellView\":\n    return cast(\"ShellView\", get_workbench().get_view(\"ShellView\"))", "is_method": false, "function_description": "Retrieves the application's main shell view object. This function centralizes access to the `ShellView` for other UI components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/__init__.py", "function": "copy_contents", "line_number": 235, "body": "def copy_contents(src_dir, dest_dir):\n                # I want the copy to have current user permissions\n                for name in os.listdir(src_dir):\n                    src_item = os.path.join(src_dir, name)\n                    dest_item = os.path.join(dest_dir, name)\n                    if os.path.isdir(src_item):\n                        os.makedirs(dest_item, mode=0o700)\n                        copy_contents(src_item, dest_item)\n                    else:\n                        shutil.copyfile(src_item, dest_item)\n                        os.chmod(dest_item, 0o600)", "is_method": false, "function_description": "Copies all files and subdirectories from a source to a destination, ensuring copied items have strict owner-only read and write permissions for enhanced security."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "delete_dir_try_hard", "line_number": 18, "body": "def delete_dir_try_hard(path: str, hardness: int = 5) -> None:\n    # Deleting the folder on Windows is not so easy task\n    # http://bugs.python.org/issue15496\n    import shutil\n\n    for i in range(hardness):\n        if os.path.exists(path):\n            time.sleep(i * 0.5)\n            shutil.rmtree(path, True)\n        else:\n            break\n\n    if os.path.exists(path):\n        # try once more but now without ignoring errors\n        shutil.rmtree(path, False)", "is_method": false, "function_description": "Forcefully deletes a directory, retrying multiple times with delays to overcome common deletion issues, especially on Windows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "running_on_windows", "line_number": 35, "body": "def running_on_windows() -> bool:\n    return platform.system() == \"Windows\"", "is_method": false, "function_description": "Determines if the current operating system is Windows, useful for OS-specific logic and environment checks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "running_on_mac_os", "line_number": 39, "body": "def running_on_mac_os() -> bool:\n    return platform.system() == \"Darwin\"", "is_method": false, "function_description": "This function checks if the current operating system is macOS. It provides a simple way to implement platform-specific logic or configurations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "running_on_linux", "line_number": 43, "body": "def running_on_linux() -> bool:\n    return platform.system() == \"Linux\"", "is_method": false, "function_description": "Determines if the current operating system is Linux. This function enables applications to execute OS-specific code paths or configurations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "running_on_rpi", "line_number": 47, "body": "def running_on_rpi() -> bool:\n    return running_on_linux() and (\n        platform.uname().machine.lower().startswith(\"arm\")\n        or os.environ.get(\"DESKTOP_SESSION\") == \"LXDE-pi\"\n    )", "is_method": false, "function_description": "Determines if the current execution environment is a Raspberry Pi device, allowing for platform-specific code adjustments or optimizations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "list_volumes", "line_number": 54, "body": "def list_volumes(skip_letters=set()) -> Sequence[str]:\n    \"Adapted from https://github.com/ntoll/uflash/blob/master/uflash.py\"\n    if sys.platform == \"win32\":\n        import ctypes\n\n        #\n        # In certain circumstances, volumes are allocated to USB\n        # storage devices which cause a Windows popup to raise if their\n        # volume contains no media. Wrapping the check in SetErrorMode\n        # with SEM_FAILCRITICALERRORS (1) prevents this popup.\n        #\n        old_mode = ctypes.windll.kernel32.SetErrorMode(1)  # @UndefinedVariable\n        try:\n            volumes = []\n            for disk in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                if disk in skip_letters:\n                    continue\n                path = \"{}:\\\\\".format(disk)\n                if os.path.exists(path):\n                    volumes.append(path)\n\n            return volumes\n        finally:\n            ctypes.windll.kernel32.SetErrorMode(old_mode)  # @UndefinedVariable\n    else:\n        # 'posix' means we're on Linux or OSX (Mac).\n        # Call the unix \"mount\" command to list the mounted volumes.\n        mount_output = subprocess.check_output(\"mount\").splitlines()\n        return [x.split()[2].decode(\"utf-8\") for x in mount_output]", "is_method": false, "function_description": "This function lists all accessible storage volumes or drive letters on the current operating system, adapting its method for Windows or POSIX systems. It provides a way to discover available storage devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_win_volume_name", "line_number": 85, "body": "def get_win_volume_name(path: str) -> str:\n    \"\"\"\n    Each disk or external device connected to windows has an attribute\n    called \"volume name\". This function returns the volume name for\n    the given disk/device.\n    Code from http://stackoverflow.com/a/12056414\n    \"\"\"\n    if sys.platform == \"win32\":\n        import ctypes\n\n        vol_name_buf = ctypes.create_unicode_buffer(1024)\n        ctypes.windll.kernel32.GetVolumeInformationW(  # @UndefinedVariable\n            ctypes.c_wchar_p(path),\n            vol_name_buf,\n            ctypes.sizeof(vol_name_buf),\n            None,\n            None,\n            None,\n            None,\n            0,\n        )\n        assert isinstance(vol_name_buf.value, str)\n        return vol_name_buf.value\n    else:\n        raise RuntimeError(\"Only meant for Windows\")", "is_method": false, "function_description": "This function retrieves the volume name for a specified disk or device on Windows systems. It provides a human-readable identifier for storage media."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "find_volumes_by_name", "line_number": 112, "body": "def find_volumes_by_name(volume_name: str, skip_letters={\"A\"}) -> Sequence[str]:\n    volumes = list_volumes(skip_letters=skip_letters)\n    if os.name == \"nt\":\n        return [\n            volume\n            for volume in volumes\n            if get_win_volume_name(volume).upper() == volume_name.upper()\n        ]\n    else:\n        return [volume for volume in volumes if volume.endswith(volume_name)]", "is_method": false, "function_description": "This function identifies and returns storage volumes that match a specified name. It provides a cross-platform method to locate volumes, adapting its search logic based on the operating system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "find_volume_by_name", "line_number": 124, "body": "def find_volume_by_name(\n    volume_name: str,\n    not_found_msg: Optional[str] = None,\n    found_several_msg: Optional[str] = None,\n    parent=None,\n) -> Optional[str]:\n    from thonny.languages import tr\n\n    # Can't translate in the header as _ may not be available at import time\n    if not_found_msg is None:\n        not_found_msg = tr(\"Could not find disk '%s'. Do you want to locate it yourself?\")\n\n    if found_several_msg is None:\n        found_several_msg = tr(\"Found several '%s' disks. Do you want to choose one yourself?\")\n\n    volumes = find_volumes_by_name(volume_name)\n    if len(volumes) == 1:\n        return volumes[0]\n    else:\n        if len(volumes) == 0:\n            msg = not_found_msg % volume_name\n        else:\n            msg = found_several_msg % volume_name\n\n        import tkinter as tk\n        from tkinter.messagebox import askyesno\n\n        from thonny.ui_utils import askdirectory\n\n        if askyesno(tr(\"Can't find suitable disk\"), msg, master=parent):\n            path = askdirectory(parent=parent)\n            if path:\n                return path\n\n    return None", "is_method": false, "function_description": "Provides a user-guided way to find a disk volume by its name. It prompts the user for manual location or selection if the volume is not found or multiple matches are found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "shorten_repr", "line_number": 161, "body": "def shorten_repr(original_repr: str, max_len: int = 1000) -> str:\n    if len(original_repr) > max_len:\n        return original_repr[: max_len - 1] + \"\u2026\"\n    else:\n        return original_repr", "is_method": false, "function_description": "Shortens a string representation to a maximum length, appending an ellipsis if truncated. This function is useful for displaying long textual content concisely."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "_win_get_used_memory", "line_number": 168, "body": "def _win_get_used_memory():\n    # http://code.activestate.com/recipes/578513-get-memory-usage-of-windows-processes-using-getpro/\n    import ctypes\n    from ctypes import wintypes\n\n    GetCurrentProcess = ctypes.windll.kernel32.GetCurrentProcess\n    GetCurrentProcess.argtypes = []\n    GetCurrentProcess.restype = wintypes.HANDLE\n\n    SIZE_T = ctypes.c_size_t\n\n    class PROCESS_MEMORY_COUNTERS_EX(ctypes.Structure):\n        _fields_ = [\n            (\"cb\", wintypes.DWORD),\n            (\"PageFaultCount\", wintypes.DWORD),\n            (\"PeakWorkingSetSize\", SIZE_T),\n            (\"WorkingSetSize\", SIZE_T),\n            (\"QuotaPeakPagedPoolUsage\", SIZE_T),\n            (\"QuotaPagedPoolUsage\", SIZE_T),\n            (\"QuotaPeakNonPagedPoolUsage\", SIZE_T),\n            (\"QuotaNonPagedPoolUsage\", SIZE_T),\n            (\"PagefileUsage\", SIZE_T),\n            (\"PeakPagefileUsage\", SIZE_T),\n            (\"PrivateUsage\", SIZE_T),\n        ]\n\n    GetProcessMemoryInfo = ctypes.windll.psapi.GetProcessMemoryInfo\n    GetProcessMemoryInfo.argtypes = [\n        wintypes.HANDLE,\n        ctypes.POINTER(PROCESS_MEMORY_COUNTERS_EX),\n        wintypes.DWORD,\n    ]\n    GetProcessMemoryInfo.restype = wintypes.BOOL\n\n    def get_current_process():\n        \"\"\"Return handle to current process.\"\"\"\n        return GetCurrentProcess()\n\n    def get_memory_info(process=None):\n        \"\"\"Return Win32 process memory counters structure as a dict.\"\"\"\n        if process is None:\n            process = get_current_process()\n        counters = PROCESS_MEMORY_COUNTERS_EX()\n        ret = GetProcessMemoryInfo(process, ctypes.byref(counters), ctypes.sizeof(counters))\n        if not ret:\n            raise ctypes.WinError()\n        info = dict((name, getattr(counters, name)) for name, _ in counters._fields_)\n        return info\n\n    return get_memory_info()[\"PrivateUsage\"]", "is_method": false, "function_description": "Retrieves the private memory usage for the current process on Windows. It provides a specific metric for monitoring an application's memory footprint."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "construct_cmd_line", "line_number": 225, "body": "def construct_cmd_line(parts, safe_tokens=[]) -> str:\n    def quote(s):\n        if s in safe_tokens:\n            return s\n        else:\n            return shlex.quote(s)\n\n    return \" \".join(map(quote, parts))", "is_method": false, "function_description": "Constructs a shell command string from a list of parts, ensuring proper quoting for safe execution. It selectively avoids quoting for specified safe tokens, preventing common shell injection issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "user_friendly_python_command_line", "line_number": 235, "body": "def user_friendly_python_command_line(cmd):\n    if \"-m\" in cmd:\n        cmd = cmd[cmd.index(\"-m\") + 1 :]\n\n    lines = [\"\"]\n    for item in cmd:\n        if lines[-1] and len(lines[-1] + \" \" + item) > 60:\n            lines.append(\"\")\n        lines[-1] = (lines[-1] + \" \" + item).strip()\n\n    return \"\\n\".join(lines)\n\n    return subprocess.list2cmdline(cmd)", "is_method": false, "function_description": "Creates a readable, multi-line string representation of a command-line instruction. It removes the Python '-m' flag for brevity and wraps lines to ensure better display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "parse_cmd_line", "line_number": 250, "body": "def parse_cmd_line(s):\n    return shlex.split(s, posix=True)", "is_method": false, "function_description": "Parses a command-line string into a list of arguments, respecting POSIX shell quoting and tokenization rules. This is useful for processing user-provided shell commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "levenshtein_distance", "line_number": 254, "body": "def levenshtein_distance(s1, s2):\n    # https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#Python\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)  # pylint: disable=arguments-out-of-order\n\n    # len(s1) >= len(s2)\n    if len(s2) == 0:\n        return len(s1)\n\n    previous_row = range(len(s2) + 1)\n    for i, c1 in enumerate(s1):\n        current_row = [i + 1]\n        for j, c2 in enumerate(s2):\n            insertions = (\n                previous_row[j + 1] + 1\n            )  # j+1 instead of j since previous_row and current_row are one character longer\n            deletions = current_row[j] + 1  # than s2\n            substitutions = previous_row[j] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n\n    return previous_row[-1]", "is_method": false, "function_description": "Calculates the Levenshtein distance, representing the minimum number of single-character edits required to transform one string into another. Useful for measuring string similarity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "levenshtein_damerau_distance", "line_number": 278, "body": "def levenshtein_damerau_distance(s1, s2, maxDistance):\n    # https://gist.github.com/giststhebearbear/4145811\n    #  get smallest string so our rows are minimized\n    s1, s2 = (s1, s2) if len(s1) <= len(s2) else (s2, s1)\n    #  set lengths\n    l1, l2 = len(s1), len(s2)\n\n    #  We are simulatng an NM matrix where n is the longer string\n    #  and m is the shorter string. By doing this we can minimize\n    #  memory usage to O(M).\n    #  Since we are simulating the matrix we only maintain two rows\n    #  at a time the current row and the previous rows.\n    #  A move from the current cell looking at the cell before it indicates\n    #  consideration of an insert operation.\n    #  A move from the current cell looking at the cell above it indicates\n    #  consideration of a deletion\n    #  Both operations are cost 1\n    #  A move from the current cell to the cell up and to the left indicates\n    #  an edit operation of 0 cost for a matching character and a 1 cost for\n    #  a non matching characters\n    #  no row has been previously computed yet, set empty row\n    #  Since this is also a Damerou-Levenshtein calculation transposition\n    #  costs will be taken into account. These look back 2 characters to\n    #  determine optimal cost based on a possible transposition\n    #  example: aei -> aie with levensthein has a cost of 2\n    #  match a, change e->i change i->e => aie\n    #  Damarau-Levenshtein has a cost of 1\n    #  match a, transpose ei to ie => aie\n    transpositionRow = []\n    prevRow = []\n\n    #  build first leven matrix row\n    #  The first row represents transformation from an empty string\n    #  to the shorter string making it static [0-n]\n    #  since this row is static we can set it as\n    #  curRow and start computation at the second row or index 1\n    curRow = list(range(0, l1 + 1))\n\n    # use second length to loop through all the rows being built\n    # we start at row one\n    for rowNum in range(1, l2 + 1):\n        #  set transposition, previous, and current\n        #  because the rowNum always increments by one\n        #  we can use rowNum to set the value representing\n        #  the first column which is indicitive of transforming TO\n        #  the empty string from our longer string\n        #  transposition row maintains an extra row so that it is possible\n        #  for us to apply Damarou's formula\n        transpositionRow, prevRow, curRow = prevRow, curRow, [rowNum] + [0] * l1\n\n        #  consider if we have passed the max distance if all paths through\n        #  the transposition row are larger than the max we can stop calculating\n        #  distance and return the last element in that row and return the max\n        if transpositionRow:\n            if not any(cellValue < maxDistance for cellValue in transpositionRow):\n                return maxDistance\n\n        for colNum in range(1, l1 + 1):\n            insertionCost = curRow[colNum - 1] + 1\n            deletionCost = prevRow[colNum] + 1\n            changeCost = prevRow[colNum - 1] + (0 if s1[colNum - 1] == s2[rowNum - 1] else 1)\n            #  set the cell value - min distance to reach this\n            #  position\n            curRow[colNum] = min(insertionCost, deletionCost, changeCost)\n\n            #  test for a possible transposition optimization\n            #  check to see if we have at least 2 characters\n            if 1 < rowNum <= colNum:\n                #  test for possible transposition\n                if s1[colNum - 1] == s2[colNum - 2] and s2[colNum - 1] == s1[colNum - 2]:\n                    curRow[colNum] = min(curRow[colNum], transpositionRow[colNum - 2] + 1)\n\n    #  the last cell of the matrix is ALWAYS the shortest distance between the two strings\n    return curRow[-1]", "is_method": false, "function_description": "This function calculates the Damerau-Levenshtein distance between two strings, which quantifies the minimum number of edits required to transform one string into the other. It efficiently determines string similarity, useful for fuzzy matching or spell checking."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_file_creation_date", "line_number": 354, "body": "def get_file_creation_date(path_to_file):\n    \"\"\"\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn't possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    \"\"\"\n    if platform.system() == \"Windows\":\n        return os.path.getctime(path_to_file)\n    else:\n        stat = os.stat(path_to_file)\n        try:\n            return stat.st_birthtime\n        except AttributeError:\n            # We're probably on Linux. No easy way to get creation dates here,\n            # so we'll settle for when its content was last modified.\n            return stat.st_mtime", "is_method": false, "function_description": "Retrieves the creation date of a file, falling back to its last modification date if the true creation date is unavailable on the operating system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "start_time", "line_number": 375, "body": "def start_time(text=\"\"):\n    global _timer_time\n    print(\"RESET\", text)\n    _timer_time = time.time()", "is_method": false, "function_description": "This function resets a global timer to the current time, marking a starting point for subsequent time measurements. It also prints a \"RESET\" message."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "lap_time", "line_number": 381, "body": "def lap_time(text=\"\"):\n    global _timer_time\n    new_time = time.time()\n    print(\"LAP\", text, round(new_time - _timer_time, 4))\n    _timer_time = time.time()", "is_method": false, "function_description": "This function measures and prints the time elapsed since the last call, effectively serving as a lap timer for code execution. It is useful for profiling the duration of specific code segments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "copy_to_clipboard", "line_number": 402, "body": "def copy_to_clipboard(data):\n    if running_on_windows():\n        _copy_to_windows_clipboard(data)\n    elif running_on_mac_os():\n        command = [\"pbcopy\"]\n    else:\n        command = [\"xsel\", \"-b\", \"-i\"]\n\n    env = dict(os.environ).copy()\n    encoding = \"utf-8\"\n    env[\"PYTHONIOENCODING\"] = encoding\n\n    if sys.version_info >= (3, 6):\n        extra = {\"encoding\": encoding}\n    else:\n        extra = {}\n\n    proc = subprocess.Popen(\n        command,\n        stdin=subprocess.PIPE,\n        shell=False,\n        env=env,\n        universal_newlines=True,\n        close_fds=True,\n        **extra\n    )\n    proc.communicate(input=data, timeout=0.1)", "is_method": false, "function_description": "This function provides a cross-platform way to copy given data to the operating system's clipboard. It simplifies interaction with system clipboard utilities across Windows, macOS, and Linux."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "_copy_to_windows_clipboard", "line_number": 431, "body": "def _copy_to_windows_clipboard(data):\n    # https://bugs.python.org/file37366/test_clipboard_win.py\n    import ctypes\n\n    wcscpy = ctypes.cdll.msvcrt.wcscpy\n    OpenClipboard = ctypes.windll.user32.OpenClipboard\n    EmptyClipboard = ctypes.windll.user32.EmptyClipboard\n    SetClipboardData = ctypes.windll.user32.SetClipboardData\n    CloseClipboard = ctypes.windll.user32.CloseClipboard\n    CF_UNICODETEXT = 13\n    GlobalAlloc = ctypes.windll.kernel32.GlobalAlloc\n    GlobalLock = ctypes.windll.kernel32.GlobalLock\n    GlobalUnlock = ctypes.windll.kernel32.GlobalUnlock\n    GMEM_DDESHARE = 0x2000\n\n    OpenClipboard(None)\n    EmptyClipboard()\n    hCd = GlobalAlloc(GMEM_DDESHARE, 2 * (len(data) + 1))\n    pchData = GlobalLock(hCd)\n    wcscpy(ctypes.c_wchar_p(pchData), data)\n    GlobalUnlock(hCd)\n    SetClipboardData(CF_UNICODETEXT, hCd)\n    # ctypes.windll.user32.SetClipboardText(CF_UNICODETEXT, hCd)\n    CloseClipboard()", "is_method": false, "function_description": "Copies the provided text data to the Windows clipboard. This enables other applications to paste the text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "sizeof_fmt", "line_number": 457, "body": "def sizeof_fmt(num, suffix=\"B\"):\n    \"\"\"Readable file size\n    :param num: Bytes value\n    :type num: int\n    :param suffix: Unit suffix (optionnal) default = B\n    :type suffix: str\n    :rtype: str\n    \"\"\"\n    # https://gist.github.com/cbwar/d2dfbc19b140bd599daccbe0fe925597\n    for unit in [\"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\"]:\n        if abs(num) < 1024.0:\n            if unit == \"\":\n                return \"%d %s%s\" % (num, unit, suffix)\n            return \"%.1f %s%s\" % (num, unit, suffix)\n        num /= 1024.0\n    return \"%.1f%s%s\" % (num, \"Yi\", suffix)", "is_method": false, "function_description": "This function converts a given number of bytes into a concise, human-readable string format, appending appropriate units like KB, MB, or GB. It simplifies the display of file sizes or other large byte values."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "_get_known_folder", "line_number": 475, "body": "def _get_known_folder(ID):\n    # http://stackoverflow.com/a/3859336/261181\n    # http://www.installmate.com/support/im9/using/symbols/functions/csidls.htm\n    import ctypes.wintypes\n\n    SHGFP_TYPE_CURRENT = 0\n    buf = ctypes.create_unicode_buffer(ctypes.wintypes.MAX_PATH)\n    ctypes.windll.shell32.SHGetFolderPathW(0, ID, 0, SHGFP_TYPE_CURRENT, buf)\n    assert buf.value\n    return buf.value", "is_method": false, "function_description": "Retrieves the file system path for a specified standard Windows system folder using its ID. Useful for programmatically locating special directories on Windows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_roaming_appdata_dir", "line_number": 487, "body": "def get_roaming_appdata_dir():\n    return _get_known_folder(26)", "is_method": false, "function_description": "Retrieves the path to the current user's Roaming AppData directory. This provides a standard location for applications to store user-specific data that roams with the user's profile."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_local_appdata_dir", "line_number": 491, "body": "def get_local_appdata_dir():\n    return _get_known_folder(28)", "is_method": false, "function_description": "Provides the path to the current user's local application data directory. This standard location is useful for applications to store user-specific configuration, cache, or temporary files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_current_process", "line_number": 202, "body": "def get_current_process():\n        \"\"\"Return handle to current process.\"\"\"\n        return GetCurrentProcess()", "is_method": false, "function_description": "Provides a system handle to the currently executing process. This handle enables other functions to interact with or retrieve information about the process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "get_memory_info", "line_number": 206, "body": "def get_memory_info(process=None):\n        \"\"\"Return Win32 process memory counters structure as a dict.\"\"\"\n        if process is None:\n            process = get_current_process()\n        counters = PROCESS_MEMORY_COUNTERS_EX()\n        ret = GetProcessMemoryInfo(process, ctypes.byref(counters), ctypes.sizeof(counters))\n        if not ret:\n            raise ctypes.WinError()\n        info = dict((name, getattr(counters, name)) for name, _ in counters._fields_)\n        return info", "is_method": false, "function_description": "Retrieves detailed Win32 memory usage counters for a specified process, returning the information as a dictionary. This provides insights into a process's memory footprint on Windows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "quote", "line_number": 226, "body": "def quote(s):\n        if s in safe_tokens:\n            return s\n        else:\n            return shlex.quote(s)", "is_method": false, "function_description": "Quotes a string to make it safe for use as a shell command argument, skipping the quoting if the string is identified as a pre-approved safe token."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "time_spent", "line_number": 394, "body": "def time_spent(self):\n        return time.time() - self.start_time", "is_method": true, "class_name": "TimeHelper", "function_description": "This method calculates and returns the time elapsed since the `TimeHelper` instance was started. It provides a simple way to measure the duration of an operation or event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "time_left", "line_number": 398, "body": "def time_left(self):\n        return max(self.time_allowed - self.time_spent, 0)", "is_method": true, "class_name": "TimeHelper", "function_description": "Provides the amount of time remaining until a specified limit is reached. It calculates the difference between total allowed time and time already spent, ensuring the result is never negative."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/misc_utils.py", "function": "_listen_thread", "line_number": 509, "body": "def _listen_thread(self, stream, target_queue: queue.Queue):\n        while True:\n            data = stream.readline()\n            if data == \"\":\n                break\n            target_queue.put(data)", "is_method": true, "class_name": "PopenWithOutputQueues", "function_description": "This method serves as a dedicated thread for `PopenWithOutputQueues` to continuously read output from a process stream and push it into a queue for asynchronous consumption."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_syntax_options", "line_number": 367, "body": "def set_syntax_options(syntax_options):\n    global _syntax_options\n    _syntax_options = syntax_options\n    get_workbench().event_generate(\"SyntaxThemeChanged\")", "is_method": false, "function_description": "Configures the application's global syntax highlighting options. It then signals a 'SyntaxThemeChanged' event, prompting UI elements to update their display accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_syntax_options_for_tag", "line_number": 373, "body": "def get_syntax_options_for_tag(tag, **base_options):\n    global _syntax_options\n    if tag in _syntax_options:\n        base_options.update(_syntax_options[tag])\n    return base_options", "is_method": false, "function_description": "This function retrieves and applies tag-specific syntax options. It augments provided base options with custom settings defined for a given tag, returning the complete configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "tweak_newlines", "line_number": 380, "body": "def tweak_newlines(content):\n    cr_count = len(OLD_MAC_LINEBREAK.findall(content))\n    lf_count = len(UNIX_LINEBREAK.findall(content))\n    crlf_count = len(WINDOWS_LINEBREAK.findall(content))\n\n    if cr_count > 0 and lf_count == 0 and crlf_count == 0:\n        original_newlines = \"\\r\"\n    elif crlf_count > 0 and lf_count == 0 and cr_count == 0:\n        original_newlines = \"\\r\\n\"\n    elif lf_count > 0 and crlf_count == 0 and cr_count == 0:\n        original_newlines = \"\\n\"\n    else:\n        original_newlines = os.linesep\n\n    content = OLD_MAC_LINEBREAK.sub(\"\\n\", content)\n    content = WINDOWS_LINEBREAK.sub(\"\\n\", content)\n\n    return content, original_newlines", "is_method": false, "function_description": "This function normalizes all line endings within a given string to the Unix format (`\\n`). It also identifies and returns the predominant original newline character found in the input content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "perform_python_return", "line_number": 400, "body": "def perform_python_return(text: EnhancedText, event):\n    # copied from idlelib.EditorWindow (Python 3.4.2)\n    # slightly modified\n    # pylint: disable=lost-exception\n\n    assert text is event.widget\n    assert isinstance(text, EnhancedText)\n\n    try:\n        # delete selection\n        first, last = text.get_selection_indices()\n        if first and last:\n            text.delete(first, last)\n            text.mark_set(\"insert\", first)\n\n        # Strip whitespace after insert point\n        # (ie. don't carry whitespace from the right of the cursor over to the new line)\n        while text.get(\"insert\") in [\" \", \"\\t\"]:\n            text.delete(\"insert\")\n\n        left_part = text.get(\"insert linestart\", \"insert\")\n        # locate first non-white character\n        i = 0\n        n = len(left_part)\n        while i < n and left_part[i] in \" \\t\":\n            i = i + 1\n\n        # is it only whitespace?\n        if i == n:\n            # start the new line with the same whitespace\n            text.insert(\"insert\", \"\\n\" + left_part)\n            return \"break\"\n\n        # Turned out the left part contains visible chars\n        # Remember the indent\n        indent = left_part[:i]\n\n        # Strip whitespace before insert point\n        # (ie. after inserting the linebreak this line doesn't have trailing whitespace)\n        while text.get(\"insert-1c\", \"insert\") in [\" \", \"\\t\"]:\n            text.delete(\"insert-1c\", \"insert\")\n\n        # start new line\n        text.insert(\"insert\", \"\\n\")\n\n        # adjust indentation for continuations and block\n        # open/close first need to find the last stmt\n        lno = tktextext.index2line(text.index(\"insert\"))\n        y = roughparse.RoughParser(text.indent_width, text.tabwidth)\n\n        for context in roughparse.NUM_CONTEXT_LINES:\n            startat = max(lno - context, 1)\n            startatindex = repr(startat) + \".0\"\n            rawtext = text.get(startatindex, \"insert\")\n            y.set_str(rawtext)\n            bod = y.find_good_parse_start(\n                False, roughparse._build_char_in_string_func(startatindex)\n            )\n            if bod is not None or startat == 1:\n                break\n        y.set_lo(bod or 0)\n\n        c = y.get_continuation_type()\n        if c != roughparse.C_NONE:\n            # The current stmt hasn't ended yet.\n            if c == roughparse.C_STRING_FIRST_LINE:\n                # after the first line of a string; do not indent at all\n                pass\n            elif c == roughparse.C_STRING_NEXT_LINES:\n                # inside a string which started before this line;\n                # just mimic the current indent\n                text.insert(\"insert\", indent)\n            elif c == roughparse.C_BRACKET:\n                # line up with the first (if any) element of the\n                # last open bracket structure; else indent one\n                # level beyond the indent of the line with the\n                # last open bracket\n                text._reindent_to(y.compute_bracket_indent())\n            elif c == roughparse.C_BACKSLASH:\n                # if more than one line in this stmt already, just\n                # mimic the current indent; else if initial line\n                # has a start on an assignment stmt, indent to\n                # beyond leftmost =; else to beyond first chunk of\n                # non-whitespace on initial line\n                if y.get_num_lines_in_stmt() > 1:\n                    text.insert(\"insert\", indent)\n                else:\n                    text._reindent_to(y.compute_backslash_indent())\n            else:\n                assert 0, \"bogus continuation type %r\" % (c,)\n            return \"break\"\n\n        # This line starts a brand new stmt; indent relative to\n        # indentation of initial line of closest preceding\n        # interesting stmt.\n        indent = y.get_base_indent_string()\n        text.insert(\"insert\", indent)\n        if y.is_block_opener():\n            text.perform_smart_tab(event)\n        elif indent and y.is_block_closer():\n            text.perform_smart_backspace(event)\n        return \"break\"\n    finally:\n        text.see(\"insert\")\n        text.event_generate(\"<<NewLine>>\")\n        return \"break\"", "is_method": false, "function_description": "Manages the Return key press in a Python code editor, automatically inserting a newline and adjusting indentation to maintain correct Python syntax."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "perform_simple_return", "line_number": 508, "body": "def perform_simple_return(text: EnhancedText, event):\n    assert text is event.widget\n    assert isinstance(text, EnhancedText)\n\n    text._log_keypress_for_undo(event)\n\n    try:\n        # delete selection\n        first, last = text.get_selection_indices()\n        if first and last:\n            text.delete(first, last)\n            text.mark_set(\"insert\", first)\n\n        # Strip whitespace after insert point\n        # (ie. don't carry whitespace from the right of the cursor over to the new line)\n        while text.get(\"insert\") in [\" \", \"\\t\"]:\n            text.delete(\"insert\")\n\n        left_part = text.get(\"insert linestart\", \"insert\")\n        # locate first non-white character\n        i = 0\n        n = len(left_part)\n        while i < n and left_part[i] in \" \\t\":\n            i = i + 1\n\n        # start the new line with the same whitespace\n        text.insert(\"insert\", \"\\n\" + left_part[:i])\n        return \"break\"\n\n    finally:\n        text.see(\"insert\")\n        text.event_generate(\"<<NewLine>>\")\n        return \"break\"", "is_method": false, "function_description": "Provides smart handling for the 'Return' key in an EnhancedText widget. It inserts a new line with automatic indentation, deletes any selection, and logs the change for undo/redo functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_proposed_encodings", "line_number": 547, "body": "def get_proposed_encodings():\n    # https://w3techs.com/technologies/overview/character_encoding\n    result = [\n        \"UTF-8\",\n        \"ISO-8859-1\",\n        \"Windows-1251\",\n        \"Windows-1252\",\n        \"GB2312\",\n        \"Shift JIS\",\n        \"GBK\",\n        \"EUC-KR\",\n        \"ISO-8859-9\",\n        \"Windows-1254\",\n        \"EUC-JP\",\n        \"Big5\",\n        \"ISO-8859-2  \",\n        \"Windows-1250\",\n        \"Windows-874\",\n        \"Windows-1256\",\n        \"ISO-8859-15\",\n        \"US-ASCII\",\n        \"Windows-1255\",\n        \"TIS-620\",\n        \"ISO-8859-7\",\n        \"Windows-1253\",\n        \"UTF-16\",\n        \"KOI8-R\",\n        \"GB18030\",\n        \"Windows-1257\",\n        \"KS C 5601\",\n        \"UTF-7\",\n        \"ISO-8859-8\",\n        \"Windows-31J\",\n        \"ISO-8859-5\",\n        \"ISO-8859-6\",\n        \"ISO-8859-4\",\n        \"ANSI_X3.110-1983\",\n        \"ISO-8859-3\",\n        \"KOI8-U\",\n        \"Big5 HKSCS\",\n        \"ISO-2022-JP\",\n        \"Windows-1258\",\n        \"ISO-8859-13\",\n        \"ISO-8859-14\",\n        \"Windows-949\",\n        \"ISO-8859-10\",\n        \"ISO-8859-11\",\n        \"ISO-8859-16\",\n    ]\n\n    sys_enc = sys.getdefaultencoding()\n    for item in result[:]:\n        if item.lower() == sys_enc.lower():\n            result.remove(item)\n            sys_enc = item\n\n    result.insert(0, sys_enc)\n    return result", "is_method": false, "function_description": "Provides a prioritized list of common character encodings, with the system's default encoding listed first. Useful for attempting to decode text or files with unknown encodings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_syntax_options", "line_number": 40, "body": "def set_syntax_options(self, syntax_options):\n        # clear old options\n        for tag_name in self._syntax_options:\n            self.tag_reset(tag_name)\n\n        background = syntax_options.get(\"TEXT\", {}).get(\"background\")\n\n        # apply new options\n        for tag_name in syntax_options:\n            opts = syntax_options[tag_name]\n\n            if tag_name == \"string3\":\n                # Needs explicit background to override uniline tags\n                opts[\"background\"] = background\n\n            if tag_name == \"TEXT\":\n                self.configure(**opts)\n            else:\n                self.tag_configure(tag_name, **opts)\n\n        self._syntax_options = syntax_options\n\n        if \"current_line\" in syntax_options:\n            self.tag_lower(\"current_line\")\n\n        self.tag_raise(\"sel\")\n        self.tag_lower(\"stdout\")", "is_method": true, "class_name": "SyntaxText", "function_description": "This method updates the visual appearance of the `SyntaxText` widget by applying new syntax highlighting options, clearing previous settings and adjusting tag layering. It allows dynamic customization of text display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_reload_theme_options", "line_number": 68, "body": "def _reload_theme_options(self, event=None):\n        super()._reload_theme_options(event)\n        self._reload_syntax_options(event)", "is_method": true, "class_name": "SyntaxText", "function_description": "Reloads both general theme options and specific syntax-related display options for the text, ensuring visual consistency. This maintains the up-to-date appearance of highlighted syntax."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_reload_syntax_options", "line_number": 72, "body": "def _reload_syntax_options(self, event=None):\n        global _syntax_options\n        self.set_syntax_options(_syntax_options)", "is_method": true, "class_name": "SyntaxText", "function_description": "Reapplies the global syntax display options to the `SyntaxText` instance. This ensures the text editor's rendering reflects the latest configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "destroy", "line_number": 76, "body": "def destroy(self):\n        super().destroy()\n        get_workbench().unbind(\"SyntaxThemeChanged\", self._reload_syntax_options)", "is_method": true, "class_name": "SyntaxText", "function_description": "This method cleans up the `SyntaxText` object, unbinding its event listeners upon destruction. It ensures proper resource release and prevents memory leaks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "perform_return", "line_number": 80, "body": "def perform_return(self, event):\n        if self.file_type == \"python\":\n            return perform_python_return(self, event)\n        else:\n            return perform_simple_return(self, event)", "is_method": true, "class_name": "SyntaxText", "function_description": "This method handles a \"return\" event, such as pressing Enter, by applying file-type-specific logic. It dispatches to Python-specific return handling or a generic approach based on the text file type."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "perform_smart_backspace", "line_number": 86, "body": "def perform_smart_backspace(self, event):\n        if self.file_type == \"python\":\n            return EnhancedText.perform_smart_backspace(self, event)\n        else:\n            self._log_keypress_for_undo(event)\n            # let the default action work\n            return", "is_method": true, "class_name": "SyntaxText", "function_description": "This method provides context-aware backspace functionality. It applies enhanced backspace logic for Python files, while for other file types, it logs the keypress for undo and allows the default backspace action."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "should_indent_with_tabs", "line_number": 94, "body": "def should_indent_with_tabs(self):\n        return get_workbench().get_option(\"edit.indent_with_tabs\")", "is_method": true, "class_name": "SyntaxText", "function_description": "This method queries the workbench configuration to determine if text content should be indented using tabs. It provides the current indentation preference."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_file_type", "line_number": 97, "body": "def set_file_type(self, file_type):\n        self.file_type = file_type", "is_method": true, "class_name": "SyntaxText", "function_description": "Sets the file type for the `SyntaxText` object. This allows the object to manage or process text according to the specified file format's rules."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "is_python_text", "line_number": 100, "body": "def is_python_text(self):\n        return self.file_type == \"python\"", "is_method": true, "class_name": "SyntaxText", "function_description": "Indicates whether the text content managed by this object is identified as Python code, useful for language-specific processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "update_tabs", "line_number": 103, "body": "def update_tabs(self):\n        tab_chars = 4\n        tab_pixels = tk.font.nametofont(self[\"font\"]).measure(\"n\" * tab_chars)\n        tabs = [tab_pixels]\n        self.configure(tabs=tabs, tabstyle=\"wordprocessor\")", "is_method": true, "class_name": "SyntaxText", "function_description": "This method dynamically calculates and sets the pixel width for tab characters within the `SyntaxText` widget. It ensures consistent visual alignment of tabbed content, adapting to the current font settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "on_secondary_click", "line_number": 125, "body": "def on_secondary_click(self, event=None):\n        super().on_secondary_click(event)\n        self.mark_set(\"insert\", \"@%d,%d\" % (event.x, event.y))\n\n        menu = get_workbench().get_menu(\"edit\")\n        try:\n            from thonny.plugins.debugger import get_current_debugger\n\n            debugger = get_current_debugger()\n            if debugger is not None:\n                menu = debugger.get_editor_context_menu()\n        except ImportError:\n            pass\n\n        menu.tk_popup(event.x_root, event.y_root)", "is_method": true, "class_name": "CodeViewText", "function_description": "Handles secondary (right-click) events in the code view, setting the cursor and displaying a context menu. This menu may be customized based on whether a debugger is active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_content", "line_number": 173, "body": "def get_content(self):\n        return self.text.get(\"1.0\", \"end-1c\")", "is_method": true, "class_name": "CodeView", "function_description": "This method retrieves the entire text content currently displayed within the CodeView instance. It provides the full content for external use or processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "detect_encoding", "line_number": 176, "body": "def detect_encoding(self, data):\n        enc = self.detect_encoding_without_check(data)\n        try:\n            codecs.lookup(enc)\n            return enc\n        except LookupError:\n            messagebox.showerror(\n                \"Error\", \"Unknown encoding '%s'. Using utf-8 instead\" % enc, master=self\n            )\n            return \"utf-8\"", "is_method": true, "class_name": "CodeView", "function_description": "Provides a service to detect the character encoding of input data. It validates the detected encoding, defaulting to 'utf-8' and notifying the user if the original detection is unknown."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "detect_encoding_without_check", "line_number": 187, "body": "def detect_encoding_without_check(self, data):\n        if self.text.is_python_text():\n            import tokenize\n\n            encoding, _ = tokenize.detect_encoding(io.BytesIO(data).readline)\n            return encoding\n        else:\n            ENCODING_MARKER = re.compile(\n                br\"(charset|coding)[\\t ]*[=: ][\\t ]*[\\\"\\']?([a-z][0-9a-z-_ ]*[0-9a-z])[\\\"\\'\\n\\r\\t ]?\",\n                re.IGNORECASE,\n            )\n\n            for line in data[:1024].splitlines():\n                match = ENCODING_MARKER.search(line)\n                if match and len(match.group(2)) > 2:\n                    return match.group(2).decode(\"ascii\", errors=\"replace\")\n\n            return \"UTF-8\"", "is_method": true, "class_name": "CodeView", "function_description": "Determines the character encoding of provided text data. It uses Python-specific detection for code and a general marker search for other text, defaulting to UTF-8."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_file_type", "line_number": 206, "body": "def set_file_type(self, file_type):\n        self.text.set_file_type(file_type)", "is_method": true, "class_name": "CodeView", "function_description": "Configures the display of code within the CodeView by setting its file type. This enables appropriate rendering, such as syntax highlighting, for the viewed content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_content_as_bytes", "line_number": 209, "body": "def get_content_as_bytes(self):\n        content = self.get_content()\n\n        # convert all linebreaks to original format\n        content = OLD_MAC_LINEBREAK.sub(self._original_newlines, content)\n        content = WINDOWS_LINEBREAK.sub(self._original_newlines, content)\n        content = UNIX_LINEBREAK.sub(self._original_newlines, content)\n\n        return content.encode(self.detect_encoding(content.encode(\"ascii\", errors=\"replace\")))", "is_method": true, "class_name": "CodeView", "function_description": "This method retrieves the code content, restores its original line endings, and encodes it into bytes using a detected encoding. It provides the raw, byte-level representation of the code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_content_as_bytes", "line_number": 219, "body": "def set_content_as_bytes(self, data, keep_undo=False):\n\n        encoding = self.detect_encoding(data)\n        while True:\n            try:\n                chars = data.decode(encoding)\n                if self.looks_like_text(chars):\n                    self.set_content(chars, keep_undo)\n                    return True\n            except UnicodeDecodeError:\n                pass\n\n            encoding = ask_string(\n                \"Bad encoding\",\n                \"Could not read as %s text.\\nYou could try another encoding\" % encoding,\n                initial_value=encoding,\n                options=get_proposed_encodings(),\n                master=self.winfo_toplevel(),\n            )\n            if not encoding:\n                return False", "is_method": true, "class_name": "CodeView", "function_description": "This method decodes byte data into the CodeView's content, automatically detecting encoding and interactively prompting the user to resolve `UnicodeDecodeError` issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "looks_like_text", "line_number": 241, "body": "def looks_like_text(self, chars):\n        if not chars:\n            return True\n\n        non_text_char_count = 0\n        for ch in chars:\n            if ch in NON_TEXT_CHARS:\n                non_text_char_count += 1\n\n        return non_text_char_count / len(chars) < 0.01", "is_method": true, "class_name": "CodeView", "function_description": "This method determines if a given sequence of characters appears to be human-readable text. It assesses this by checking if the proportion of non-textual control characters is below a threshold."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "set_content", "line_number": 252, "body": "def set_content(self, content, keep_undo=False):\n        content, self._original_newlines = tweak_newlines(content)\n\n        self.text.direct_delete(\"1.0\", tk.END)\n        self.text.direct_insert(\"1.0\", content)\n\n        if not keep_undo:\n            self.text.edit_reset()", "is_method": true, "class_name": "CodeView", "function_description": "Updates the CodeView's display by replacing all its content with new text. It normalizes newlines and can reset the undo history for the view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_toggle_breakpoint", "line_number": 261, "body": "def _toggle_breakpoint(self, event):\n        index = \"@%d,%d\" % (event.x, event.y)\n        start_index = index + \" linestart\"\n        end_index = index + \" lineend\"\n\n        if self.text.tag_nextrange(\"breakpoint_line\", start_index, end_index):\n            self.text.tag_remove(\"breakpoint_line\", start_index, end_index)\n        else:\n            line_content = self.text.get(start_index, end_index).strip()\n            if line_content and line_content[0] != \"#\":\n                self.text.tag_add(\"breakpoint_line\", start_index, end_index)\n\n        self.update_gutter(clean=True)", "is_method": true, "class_name": "CodeView", "function_description": "Toggles a debugger breakpoint on the clicked line in the code view. It adds or removes a breakpoint tag, ignoring comment or empty lines, and updates the gutter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_clean_selection", "line_number": 275, "body": "def _clean_selection(self):\n        self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n        self._gutter.tag_remove(\"sel\", \"1.0\", \"end\")", "is_method": true, "class_name": "CodeView", "function_description": "Clears any active text selection within the CodeView's main text area and its associated gutter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_text_changed", "line_number": 279, "body": "def _text_changed(self, event):\n        self.update_gutter(\n            clean=self.text._last_event_changed_line_count\n            and self.text.tag_ranges(\"breakpoint_line\")\n        )", "is_method": true, "class_name": "CodeView", "function_description": "This method updates the CodeView's gutter in response to text changes. It ensures visual elements like line numbers and breakpoint indicators remain synchronized."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "compute_gutter_line", "line_number": 285, "body": "def compute_gutter_line(self, lineno, plain=False):\n        if plain:\n            yield str(lineno) + \" \", ()\n        else:\n            visual_line_number = self._first_line_number + lineno - 1\n            linestart = str(visual_line_number) + \".0\"\n\n            yield str(lineno), ()\n\n            if self.text.tag_nextrange(\"breakpoint_line\", linestart, linestart + \" lineend\"):\n                yield BREAKPOINT_SYMBOL, (\"breakpoint\",)\n            else:\n                yield \" \", ()", "is_method": true, "class_name": "CodeView", "function_description": "Generates the display content for a single line in a code editor's gutter. It includes the line number and indicates if a breakpoint is present for that line."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "select_range", "line_number": 299, "body": "def select_range(self, text_range):\n        self.text.tag_remove(\"sel\", \"1.0\", tk.END)\n\n        if text_range:\n            if isinstance(text_range, int):\n                # it's line number\n                start = str(text_range - self._first_line_number + 1) + \".0\"\n                end = str(text_range - self._first_line_number + 1) + \".end\"\n            elif isinstance(text_range, TextRange):\n                start = \"%s.%s\" % (\n                    text_range.lineno - self._first_line_number + 1,\n                    text_range.col_offset,\n                )\n                end = \"%s.%s\" % (\n                    text_range.end_lineno - self._first_line_number + 1,\n                    text_range.end_col_offset,\n                )\n            else:\n                assert isinstance(text_range, tuple)\n                start, end = text_range\n\n            self.text.tag_add(\"sel\", start, end)\n            if isinstance(text_range, int):\n                self.text.mark_set(\"insert\", end)\n            self.text.see(\"%s -1 lines\" % start)", "is_method": true, "class_name": "CodeView", "function_description": "Selects a specified range of code within the view, clearing any prior selections. It then scrolls the display to ensure the newly selected range is visible to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_breakpoint_line_numbers", "line_number": 325, "body": "def get_breakpoint_line_numbers(self):\n        result = set()\n        for num_line in self._gutter.get(\"1.0\", \"end\").splitlines():\n            if BREAKPOINT_SYMBOL in num_line:\n                result.add(int(num_line.replace(BREAKPOINT_SYMBOL, \"\")))\n        return result", "is_method": true, "class_name": "CodeView", "function_description": "Retrieves the line numbers of all currently set breakpoints displayed within the code view. This provides a list of active breakpoint locations for debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "get_selected_range", "line_number": 332, "body": "def get_selected_range(self):\n        if self.text.has_selection():\n            lineno, col_offset = map(int, self.text.index(tk.SEL_FIRST).split(\".\"))\n            end_lineno, end_col_offset = map(int, self.text.index(tk.SEL_LAST).split(\".\"))\n        else:\n            lineno, col_offset = map(int, self.text.index(tk.INSERT).split(\".\"))\n            end_lineno, end_col_offset = lineno, col_offset\n\n        return TextRange(lineno, col_offset, end_lineno, end_col_offset)", "is_method": true, "class_name": "CodeView", "function_description": "Provides the specific text range currently selected by the user in the code view. If no selection exists, it returns the range of the current cursor position."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "destroy", "line_number": 342, "body": "def destroy(self):\n        super().destroy()\n        get_workbench().unbind(\"SyntaxThemeChanged\", self._reload_theme_options)", "is_method": true, "class_name": "CodeView", "function_description": "Cleans up the CodeView instance by calling the parent's destroy method and unbinding its syntax theme change listener."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/codeview.py", "function": "_reload_gutter_theme_options", "line_number": 346, "body": "def _reload_gutter_theme_options(self, event=None):\n        # super()._reload_gutter_theme_options(event)\n        if \"GUTTER\" in _syntax_options:\n            opts = _syntax_options[\"GUTTER\"].copy()\n            if \"background\" in opts and \"selectbackground\" not in opts:\n                opts[\"selectbackground\"] = opts[\"background\"]\n                opts[\"inactiveselectbackground\"] = opts[\"background\"]\n            if \"foreground\" in opts and \"selectforeground\" not in opts:\n                opts[\"selectforeground\"] = opts[\"foreground\"]\n\n            self._gutter.configure(opts)\n\n            if \"background\" in opts:\n                background = opts[\"background\"]\n                self._margin_line.configure(background=background)\n                self._gutter.tag_configure(\"sel\", background=background)\n\n        if \"breakpoint\" in _syntax_options:\n            self._gutter.tag_configure(\"breakpoint\", _syntax_options[\"breakpoint\"])", "is_method": true, "class_name": "CodeView", "function_description": "Reloads and applies visual theme options to the code editor's gutter, configuring its appearance, including background, selection, and breakpoint indicators. This ensures consistent styling for the code view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "ask_backend_path", "line_number": 1301, "body": "def ask_backend_path(master, dialog_kind):\n    proxy = get_runner().get_backend_proxy()\n    if not proxy:\n        return None\n\n    assert proxy.supports_remote_files()\n\n    dlg = BackendFileDialog(master, dialog_kind, proxy.get_cwd())\n    show_dialog(dlg, master)\n    return dlg.result", "is_method": false, "function_description": "Provides a user interface for selecting a file or directory path from a remote backend. It enables interaction with a remote file system through a dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "choose_node_for_file_operations", "line_number": 1313, "body": "def choose_node_for_file_operations(master, prompt):\n    if get_runner().supports_remote_files():\n        dlg = NodeChoiceDialog(master, prompt)\n        show_dialog(dlg, master)\n        if dlg.result == \"remote\" and not get_runner().ready_for_remote_file_operations(\n            show_message=True\n        ):\n            return None\n        return dlg.result\n    else:\n        return \"local\"", "is_method": false, "function_description": "Facilitates choosing between local or remote nodes for file operations. It interacts with the user and verifies remote node readiness."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_local_files_root_text", "line_number": 1326, "body": "def get_local_files_root_text():\n    global _LOCAL_FILES_ROOT_TEXT\n\n    if not _LOCAL_FILES_ROOT_TEXT:\n        # translation can't be done in module load time\n        _LOCAL_FILES_ROOT_TEXT = tr(\"This computer\")\n\n    return _LOCAL_FILES_ROOT_TEXT", "is_method": false, "function_description": "This function provides a localized and consistent display name for the local computer or file system root. It translates \"This computer\" on its first call and caches the result for subsequent use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_with_default_app", "line_number": 1336, "body": "def open_with_default_app(path):\n    if running_on_windows():\n        os.startfile(path)\n    elif running_on_mac_os():\n        subprocess.run([\"open\", path])\n    else:\n        subprocess.run([\"xdg-open\", path])", "is_method": false, "function_description": "Opens a specified file or directory path using the operating system's default application. It provides a cross-platform way to launch documents or folders directly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_file_handler_conf_key", "line_number": 1345, "body": "def get_file_handler_conf_key(extension):\n    return \"file_default_handlers.%s\" % extension", "is_method": false, "function_description": "Creates a standardized configuration key for default file handlers using a provided file extension. This enables consistent access to file handler settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "show_hidden_files", "line_number": 1349, "body": "def show_hidden_files():\n    return get_workbench().get_option(HIDDEN_FILES_OPTION)", "is_method": false, "function_description": "Provides the application's configuration setting indicating whether hidden files should be visible to the user. This function is a utility to check the current display preference."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "init_header", "line_number": 101, "body": "def init_header(self, row, column):\n        header_frame = ttk.Frame(self, style=\"ViewToolbar.TFrame\")\n        header_frame.grid(row=row, column=column, sticky=\"nsew\")\n        header_frame.columnconfigure(0, weight=1)\n\n        self.path_bar = tktextext.TweakableText(\n            header_frame,\n            borderwidth=0,\n            relief=\"flat\",\n            height=1,\n            font=\"TkDefaultFont\",\n            wrap=\"word\",\n            padx=6,\n            pady=5,\n            insertwidth=0,\n            highlightthickness=0,\n            background=lookup_style_option(\"ViewToolbar.TFrame\", \"background\"),\n        )\n\n        self.path_bar.grid(row=0, column=0, sticky=\"nsew\")\n        self.path_bar.set_read_only(True)\n        self.path_bar.bind(\"<Configure>\", self.resize_path_bar, True)\n        self.path_bar.tag_configure(\n            \"dir\", foreground=lookup_style_option(\"Url.TLabel\", \"foreground\")\n        )\n        self.path_bar.tag_configure(\"underline\", underline=True)\n\n        def get_dir_range(event):\n            mouse_index = self.path_bar.index(\"@%d,%d\" % (event.x, event.y))\n            return self.path_bar.tag_prevrange(\"dir\", mouse_index + \"+1c\")\n\n        def dir_tag_motion(event):\n            self.path_bar.tag_remove(\"underline\", \"1.0\", \"end\")\n            dir_range = get_dir_range(event)\n            if dir_range:\n                range_start, range_end = dir_range\n                self.path_bar.tag_add(\"underline\", range_start, range_end)\n\n        def dir_tag_enter(event):\n            self.path_bar.config(cursor=\"hand2\")\n\n        def dir_tag_leave(event):\n            self.path_bar.config(cursor=\"\")\n            self.path_bar.tag_remove(\"underline\", \"1.0\", \"end\")\n\n        def dir_tag_click(event):\n            mouse_index = self.path_bar.index(\"@%d,%d\" % (event.x, event.y))\n            lineno = int(float(mouse_index))\n            if lineno == 1:\n                self.request_focus_into(\"\")\n            else:\n                assert lineno == 2\n                dir_range = get_dir_range(event)\n                if dir_range:\n                    _, end_index = dir_range\n                    path = self.path_bar.get(\"2.0\", end_index)\n                    if path.endswith(\":\"):\n                        path += \"\\\\\"\n                    self.request_focus_into(path)\n\n        self.path_bar.tag_bind(\"dir\", \"<1>\", dir_tag_click)\n        self.path_bar.tag_bind(\"dir\", \"<Enter>\", dir_tag_enter)\n        self.path_bar.tag_bind(\"dir\", \"<Leave>\", dir_tag_leave)\n        self.path_bar.tag_bind(\"dir\", \"<Motion>\", dir_tag_motion)\n\n        # self.menu_button = ttk.Button(header_frame, text=\"\u2261 \", style=\"ViewToolbar.Toolbutton\")\n        self.menu_button = ttk.Button(\n            header_frame, text=\" \u2261 \", style=\"ViewToolbar.Toolbutton\", command=self.post_button_menu\n        )\n        # self.menu_button.grid(row=0, column=1, sticky=\"ne\")\n        self.menu_button.place(anchor=\"ne\", rely=0, relx=1)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method sets up the file browser's interactive header bar. It displays the current path, enabling navigation by clicking path segments and providing a menu button for actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "clear", "line_number": 173, "body": "def clear(self):\n        self.clear_error()\n        self.invalidate_cache()\n        self.path_bar.direct_delete(\"1.0\", \"end\")\n        self.tree.set_children(\"\")\n        self.current_focus = None", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Resets the file browser's current display and internal state. It clears paths, file listings, cached data, and any error messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_focus_into", "line_number": 180, "body": "def request_focus_into(self, path):\n        return self.focus_into(path)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides an interface to request the file browser to change its active directory view. It allows navigation into a specified file system path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "focus_into", "line_number": 183, "body": "def focus_into(self, path):\n        self.clear_error()\n        self.invalidate_cache()\n\n        # clear\n        self.tree.set_children(ROOT_NODE_ID)\n\n        self.tree.set(ROOT_NODE_ID, \"path\", path)\n\n        self.building_breadcrumbs = True\n        self.path_bar.direct_delete(\"1.0\", \"end\")\n\n        self.path_bar.direct_insert(\"1.0\", self.get_root_text(), (\"dir\",))\n\n        if path and path != \"/\":\n            self.path_bar.direct_insert(\"end\", \"\\n\")\n\n            def create_spacer():\n                return ttk.Frame(self.path_bar, height=1, width=4, style=\"ViewToolbar.TFrame\")\n\n            parts = self.split_path(path)\n            for i, part in enumerate(parts):\n                if i > 0:\n                    if parts[i - 1] != \"\":\n                        self.path_bar.window_create(\"end\", window=create_spacer())\n                    self.path_bar.direct_insert(\"end\", self.get_dir_separator())\n                    self.path_bar.window_create(\"end\", window=create_spacer())\n\n                self.path_bar.direct_insert(\"end\", part, tags=(\"dir\",))\n\n        self.building_breadcrumbs = False\n        self.resize_path_bar()\n        self.render_children_from_cache()\n        self.scroll_to_top()\n        self.current_focus = path", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Sets the file browser's current view to a specified path. It updates the file tree, re-renders the path bar, and displays the directory's contents, providing a navigational capability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "scroll_to_top", "line_number": 219, "body": "def scroll_to_top(self):\n        children = self.tree.get_children()\n        if children:\n            self.tree.see(children[0])", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Scrolls the file browser's display to the very beginning, showing the first entry in its tree view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "split_path", "line_number": 224, "body": "def split_path(self, path):\n        return path.split(self.get_dir_separator())", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method breaks a file path into a list of its constituent parts, utilizing the file browser's specific directory separator for platform-agnostic parsing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_root_text", "line_number": 227, "body": "def get_root_text(self):\n        return get_local_files_root_text()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides the human-readable text representing the root directory for local files. This method helps the file browser display the base location from which files are accessed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_open_node", "line_number": 230, "body": "def on_open_node(self, event):\n        node_id = self.get_selected_node()\n        path = self.tree.set(node_id, \"path\")\n        if path:  # and path not in self._cached_child_data:\n            self.render_children_from_cache(node_id)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Manages the event of opening a file browser node. It retrieves the selected node's path and renders its children efficiently from a cache."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "resize_path_bar", "line_number": 238, "body": "def resize_path_bar(self, event=None):\n        if self.building_breadcrumbs:\n            return\n        height = self.tk.call((self.path_bar, \"count\", \"-update\", \"-displaylines\", \"1.0\", \"end\"))\n        self.path_bar.configure(height=height)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Resizes the file browser's path bar to dynamically fit its content. This ensures the path display is always correctly sized for visibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "_cleaned_selection", "line_number": 244, "body": "def _cleaned_selection(self):\n        # In some cases (eg. Python 3.6.9 and Tk 8.6.8 in Ubuntu when selecting a range with shift),\n        # nodes may contain collapsed children.\n        # In most cases this does no harm, because the command would apply to children as well,\n        # but dummy dir marker nodes may cause confusion\n        nodes = self.tree.selection()\n        return [node for node in nodes if self.tree.item(node, \"text\") != _dummy_node_text]", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Filters selected items from the file browser's tree view, returning only valid nodes by excluding internal placeholder entries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_node", "line_number": 252, "body": "def get_selected_node(self):\n        \"\"\"Returns single node (or nothing)\"\"\"\n        nodes = self._cleaned_selection()\n        if len(nodes) == 1:\n            return nodes[0]\n        elif len(nodes) > 1:\n            return self.tree.focus() or None\n        else:\n            return None", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Returns the single selected node from the file browser. If multiple nodes are selected, it provides the currently focused node; otherwise, it returns none."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_nodes", "line_number": 262, "body": "def get_selected_nodes(self, notify_if_empty=False):\n        \"\"\"Can return several nodes\"\"\"\n        result = self._cleaned_selection()\n        if not result and notify_if_empty:\n            self.notify_missing_selection()\n        return result", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Fetches all currently selected items (nodes) from the file browser, optionally notifying the user if the selection is empty."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selection_info", "line_number": 269, "body": "def get_selection_info(self, notify_if_empty=False):\n        nodes = self.get_selected_nodes(notify_if_empty)\n        if not nodes:\n            return None\n        elif len(nodes) == 1:\n            description = \"'\" + self.tree.set(nodes[0], \"name\") + \"'\"\n        else:\n            description = tr(\"%d items\") % len(nodes)\n\n        paths = [self.tree.set(node, \"path\") for node in nodes]\n        kinds = [self.tree.set(node, \"kind\") for node in nodes]\n\n        return {\"description\": description, \"nodes\": nodes, \"paths\": paths, \"kinds\": kinds}", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Retrieves comprehensive information about the currently selected items in the file browser. It returns a dictionary containing a display description, the selected nodes, their full paths, and their types."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_path", "line_number": 283, "body": "def get_selected_path(self):\n        return self.get_selected_value(\"path\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides the file path for the item currently selected within the file browser. Useful for operations on the selected file or directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_kind", "line_number": 286, "body": "def get_selected_kind(self):\n        return self.get_selected_value(\"kind\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Retrieves the 'kind' or category of the currently selected item within the file browser. This provides information about the selected file type."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_name", "line_number": 289, "body": "def get_selected_name(self):\n        return self.get_selected_value(\"name\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Retrieves the name of the currently selected item within the file browser. Useful for identifying the chosen file or directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_extension_from_name", "line_number": 292, "body": "def get_extension_from_name(self, name):\n        if name is None:\n            return None\n        if \".\" in name:\n            return \".\" + name.split(\".\")[-1].lower()\n        else:\n            return name.lower()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Extracts the file extension from a given name string. It returns the lowercase extension with a leading dot if found, or the lowercased name itself if no dot is present."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_selected_value", "line_number": 300, "body": "def get_selected_value(self, key):\n        node_id = self.get_selected_node()\n\n        if node_id:\n            return self.tree.set(node_id, key)\n        else:\n            return None", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides the value of a specified key from the currently selected node within the file browser's tree structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_active_directory", "line_number": 308, "body": "def get_active_directory(self):\n        path = self.tree.set(ROOT_NODE_ID, \"path\")\n        return path", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Returns the path of the current active directory managed by the file browser. This provides the current working location."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "show_fs_info", "line_number": 315, "body": "def show_fs_info(self):\n        path = self.get_selected_path()\n        if path is None:\n            path = self.current_focus\n        self.request_fs_info(path)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method requests and displays file system information for the currently selected or focused path. It enables the file browser to update with details about a specific directory or file."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "present_fs_info", "line_number": 324, "body": "def present_fs_info(self, info):\n        total_str = \"?\" if info[\"total\"] is None else sizeof_fmt(info[\"total\"])\n        used_str = \"?\" if info[\"used\"] is None else sizeof_fmt(info[\"used\"])\n        free_str = \"?\" if info[\"free\"] is None else sizeof_fmt(info[\"free\"])\n        text = tr(\"Storage space on this drive or filesystem\") + \":\\n\\n\" \"    %s: %s\\n\" % (\n            tr(\"total space\"),\n            total_str,\n        ) + \"    %s: %s\\n\" % (tr(\"used space\"), used_str) + \"    %s: %s\\n\" % (\n            tr(\"free space\"),\n            free_str,\n        )\n\n        if info.get(\"comment\"):\n            text += \"\\n\" + info[\"comment\"]\n\n        messagebox.showinfo(tr(\"Storage info\"), text, master=self)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method formats and presents file system storage details. It displays total, used, and free space in a user-friendly pop-up message box."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "cache_dirs_child_data", "line_number": 341, "body": "def cache_dirs_child_data(self, data):\n        from copy import deepcopy\n\n        data = deepcopy(data)\n\n        for parent_path in data:\n            children_data = data[parent_path]\n            if isinstance(children_data, dict):\n                for child_name in children_data:\n                    child_data = children_data[child_name]\n                    assert isinstance(child_data, dict)\n                    if \"label\" not in child_data:\n                        child_data[\"label\"] = child_name\n\n                    if \"isdir\" not in child_data:\n                        child_data[\"isdir\"] = child_data.get(\"size\", 0) is None\n            else:\n                assert children_data is None\n\n        self._cached_child_data.update(data)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method standardizes and caches metadata for child directories and files, ensuring consistent `label` and `isdir` attributes. It prepares file system data for internal use within the file browser."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "file_exists_in_cache", "line_number": 362, "body": "def file_exists_in_cache(self, path):\n        for parent_path in self._cached_child_data:\n            # hard to split because it may not be in this system format\n            name = path[len(parent_path) :]\n            if name[0:1] in [\"/\", \"\\\\\"]:\n                name = name[1:]\n\n            if name in self._cached_child_data[parent_path]:\n                return True\n\n        return False", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method determines if a file path exists in the `BaseFileBrowser`'s cached file system data. It helps avoid redundant file system operations by leveraging cached information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "select_path_if_visible", "line_number": 374, "body": "def select_path_if_visible(self, path, node_id=\"\"):\n        for child_id in self.tree.get_children(node_id):\n            if self.tree.set(child_id, \"path\") == path:\n                self.tree.selection_set(child_id)\n                return\n\n            if self.tree.item(child_id, \"open\"):\n                self.select_path_if_visible(path, child_id)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Finds and selects a given file system path within the currently visible or expanded nodes of the file browser's tree. It highlights the path in the GUI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_open_paths", "line_number": 383, "body": "def get_open_paths(self, node_id=ROOT_NODE_ID):\n        if self.tree.set(node_id, \"kind\") == \"file\":\n            return set()\n\n        elif node_id == ROOT_NODE_ID or self.tree.item(node_id, \"open\"):\n            result = {self.tree.set(node_id, \"path\")}\n            for child_id in self.tree.get_children(node_id):\n                result.update(self.get_open_paths(child_id))\n            return result\n\n        else:\n            return set()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method recursively collects the file paths of all currently \"open\" (expanded) directory nodes within the file browser's tree. It provides a snapshot of the visible directory structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "invalidate_cache", "line_number": 396, "body": "def invalidate_cache(self, paths=None):\n        if paths is None:\n            self._cached_child_data.clear()\n        else:\n            for path in paths:\n                if path in self._cached_child_data:\n                    del self._cached_child_data[path]", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Invalidates the internal cache of file browsing data. It clears the entire cache or removes specific path entries, ensuring data consistency with the underlying file system.\nInvalidates the internal cache of file browsing data. It clears the entire cache or removes specific path entries, ensuring data consistency with the underlying file system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "render_children_from_cache", "line_number": 404, "body": "def render_children_from_cache(self, node_id=\"\"):\n        \"\"\"This node is supposed to be a directory and\n        its contents needs to be shown and/or refreshed\"\"\"\n        path = self.tree.set(node_id, \"path\")\n\n        if path not in self._cached_child_data:\n            self.request_dirs_child_data(node_id, self.get_open_paths() | {path})\n            # leave it as is for now, it will be updated later\n            return\n\n        children_data = self._cached_child_data[path]\n\n        if children_data in [\"file\", \"missing\"]:\n            # path used to be a dir but is now a file or does not exist\n\n            # if browser is focused into this path\n            if node_id == \"\":\n                self.show_error(\"Directory \" + path + \" does not exist anymore\", node_id)\n            elif children_data == \"missing\":\n                self.tree.delete(node_id)\n            else:\n                assert children_data == \"file\"\n                self.tree.set_children(node_id)  # clear the list of children\n                self.tree.item(node_id, open=False)\n\n        elif children_data is None:\n            raise RuntimeError(\"None data for %s\" % path)\n        else:\n            fs_children_names = children_data.keys()\n            tree_children_ids = self.tree.get_children(node_id)\n\n            # recollect children\n            children = {}\n\n            # first the ones, which are present already in tree\n            for child_id in tree_children_ids:\n                name = self.tree.set(child_id, \"name\")\n                if name in fs_children_names:\n                    children[name] = child_id\n                    self.update_node_data(child_id, name, children_data[name])\n\n            # add missing children\n            for name in fs_children_names:\n                if name not in children:\n                    child_id = self.tree.insert(node_id, \"end\")\n                    children[name] = child_id\n                    self.tree.set(children[name], \"path\", self.join(path, name))\n                    self.update_node_data(child_id, name, children_data[name])\n\n            def file_order(name):\n                # items in a folder should be ordered so that\n                # folders come first and names are ordered case insensitively\n                return (\n                    not children_data[name][\"isdir\"],  # prefer directories\n                    not \":\" in name,  # prefer drives\n                    name.upper(),\n                    name,\n                )\n\n            # update tree\n            ids_sorted_by_name = list(\n                map(lambda key: children[key], sorted(children.keys(), key=file_order))\n            )\n            self.tree.set_children(node_id, *ids_sorted_by_name)\n\n            # recursively update open children\n            for child_id in ids_sorted_by_name:\n                if self.tree.item(child_id, \"open\"):\n                    self.render_children_from_cache(child_id)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Updates and displays a directory node's contents in the file browser's tree, leveraging cached data. It handles additions, removals, sorting, and recursively refreshes open subdirectories."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "show_error", "line_number": 474, "body": "def show_error(self, msg, node_id=\"\"):\n        if not node_id:\n            # clear tree\n            self.tree.set_children(\"\")\n\n        err_id = self.tree.insert(node_id, \"end\")\n        self.tree.item(err_id, text=msg)\n        self.tree.set_children(node_id, err_id)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Displays an error message in the file browser's tree view. It clears the existing display for a given node (or the entire tree) and shows the message as its sole entry."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "update_node_data", "line_number": 486, "body": "def update_node_data(self, node_id, name, data):\n        assert node_id != \"\"\n\n        path = self.tree.set(node_id, \"path\")\n\n        if data.get(\"modified\"):\n            try:\n                # modification time is Unix epoch\n                time_str = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(int(data[\"modified\"])))\n            except Exception:\n                time_str = \"\"\n        else:\n            time_str = \"\"\n\n        self.tree.set(node_id, \"modified\", time_str)\n\n        if data[\"isdir\"]:\n            self.tree.set(node_id, \"kind\", \"dir\")\n            self.tree.set(node_id, \"size\", \"\")\n\n            # Ensure that expand button is visible\n            # unless we know it doesn't have children\n            children_ids = self.tree.get_children(node_id)\n            if (\n                self.show_expand_buttons\n                and len(children_ids) == 0\n                and (path not in self._cached_child_data or self._cached_child_data[path])\n            ):\n                self.tree.insert(node_id, \"end\", text=_dummy_node_text)\n\n            if path.endswith(\":\") or path.endswith(\":\\\\\"):\n                img = self.hard_drive_icon\n            else:\n                img = self.folder_icon\n        else:\n            self.tree.set(node_id, \"kind\", \"file\")\n            self.tree.set(node_id, \"size\", data[\"size\"])\n\n            # Make sure it doesn't have children\n            self.tree.set_children(node_id)\n\n            if (\n                path.lower().endswith(\".py\")\n                or path.lower().endswith(\".pyw\")\n                or path.lower().endswith(\".pyi\")\n            ):\n                img = self.python_file_icon\n            elif self.should_open_name_in_thonny(name):\n                img = self.text_file_icon\n            else:\n                img = self.generic_file_icon\n\n        self.tree.set(node_id, \"name\", name)\n        self.tree.item(node_id, text=\" \" + data[\"label\"], image=img)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Updates the visual representation and metadata for a specific file or directory node in the browser's tree view. It sets properties like icon, size, and expandability based on the node's type and data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "join", "line_number": 541, "body": "def join(self, parent, child):\n        if parent == \"\":\n            if self.get_dir_separator() == \"/\":\n                return \"/\" + child\n            else:\n                return child\n\n        if parent.endswith(self.get_dir_separator()):\n            return parent + child\n        else:\n            return parent + self.get_dir_separator() + child", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method constructs a complete file system path by joining a parent directory path and a child name. It correctly inserts the appropriate directory separator."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_dir_separator", "line_number": 553, "body": "def get_dir_separator(self):\n        return os.path.sep", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides the operating system's native directory separator character. Useful for constructing platform-independent file paths within the file browser context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_double_click", "line_number": 556, "body": "def on_double_click(self, event):\n        # TODO: don't act when the click happens below last item\n        path = self.get_selected_path()\n        kind = self.get_selected_kind()\n        name = self.get_selected_name()\n        if kind == \"file\":\n            if self.should_open_name_in_thonny(name):\n                self.open_file(path)\n            else:\n                self.open_path_with_system_app(path)\n        elif kind == \"dir\":\n            self.request_focus_into(path)\n\n        return \"break\"", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Handles double-click events on items in the file browser. It opens selected files using the appropriate application or navigates into selected directories."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_secondary_click", "line_number": 577, "body": "def on_secondary_click(self, event):\n        node_id = self.tree.identify_row(event.y)\n\n        if node_id:\n            if node_id not in self.tree.selection():\n                # replace current selection\n                self.tree.selection_set(node_id)\n            self.tree.focus(node_id)\n        else:\n            self.tree.selection_set()\n            self.path_bar.focus_set()\n\n        self.tree.update()\n\n        self.refresh_menu(context=\"item\")\n        self.menu.tk_popup(event.x_root, event.y_root)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Handles secondary clicks in the file browser's tree view, selecting the clicked item or clearing the selection. It then displays a context menu for relevant actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "post_button_menu", "line_number": 594, "body": "def post_button_menu(self):\n        self.refresh_menu(context=\"button\")\n        self.menu.tk_popup(\n            self.menu_button.winfo_rootx(),\n            self.menu_button.winfo_rooty() + self.menu_button.winfo_height(),\n        )", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method refreshes and displays a popup menu. It positions the menu just below a specific button within the file browser interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "refresh_menu", "line_number": 601, "body": "def refresh_menu(self, context):\n        self.menu.delete(0, \"end\")\n        self.add_first_menu_items(context)\n        self.menu.add_separator()\n        self.add_middle_menu_items(context)\n        self.menu.add_separator()\n        self.add_last_menu_items(context)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Refreshes the file browser's menu by clearing existing items and repopulating it with first, middle, and last sections, separated accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "is_active_browser", "line_number": 609, "body": "def is_active_browser(self):\n        return False", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Indicates that this base file browser instance is never considered active by default, serving as a placeholder method for subclasses to override."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "add_first_menu_items", "line_number": 612, "body": "def add_first_menu_items(self, context):\n        if context == \"item\":\n            selected_path = self.get_selected_path()\n            selected_kind = self.get_selected_kind()\n        else:\n            selected_path = self.get_active_directory()\n            selected_kind = \"dir\"\n\n        if context == \"button\":\n            self.menu.add_command(label=tr(\"Refresh\"), command=self.cmd_refresh_tree)\n            self.menu.add_command(\n                label=tr(\"Open in system file manager\"),\n                command=lambda: self.open_path_with_system_app(selected_path),\n            )\n\n            hidden_files_label = (\n                tr(\"Hide hidden files\") if show_hidden_files() else tr(\"Show hidden files\")\n            )\n            self.menu.add_command(label=hidden_files_label, command=self.toggle_hidden_files)\n        else:\n            if selected_kind == \"dir\":\n                self.menu.add_command(\n                    label=tr(\"Focus into\"), command=lambda: self.request_focus_into(selected_path)\n                )\n            else:\n                self.menu.add_command(\n                    label=tr(\"Open in Thonny\"), command=lambda: self.open_file(selected_path)\n                )\n\n            if self.is_active_browser():\n                self.menu.add_command(\n                    label=tr(\"Open in system default app\"),\n                    command=lambda: self.open_path_with_system_app(selected_path),\n                )\n\n                if selected_kind == \"file\":\n                    ext = self.get_extension_from_name(self.get_selected_name())\n                    self.menu.add_command(\n                        label=tr(\"Configure %s files\") % ext + \"...\",\n                        command=lambda: self.open_extension_dialog(ext),\n                    )", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method dynamically populates the file browser's context menu with essential actions. It offers options relevant to selected files, directories, or general browser operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "toggle_hidden_files", "line_number": 654, "body": "def toggle_hidden_files(self):\n        get_workbench().set_option(\n            HIDDEN_FILES_OPTION, not get_workbench().get_option(HIDDEN_FILES_OPTION)\n        )\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Toggles the visibility of hidden files within the file browser. It updates the display to reflect this change."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "cmd_refresh_tree", "line_number": 660, "body": "def cmd_refresh_tree(self):\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides a command to refresh the file system tree view. It updates the browser's display to reflect current file system changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_extension_dialog", "line_number": 663, "body": "def open_extension_dialog(self, extension: str) -> None:\n        system_choice = tr(\"Open in system default app\")\n        thonny_choice = tr(\"Open in Thonny's text editor\")\n\n        current_index = (\n            1 if get_workbench().get_option(get_file_handler_conf_key(extension)) == \"thonny\" else 0\n        )\n\n        choice = ask_one_from_choices(\n            title=tr(\"Configure %s files\") % extension,\n            question=tr(\n                \"What to do with a %s file when you double-click it in Thonny's file browser?\"\n            )\n            % extension,\n            choices=[system_choice, thonny_choice],\n            initial_choice_index=current_index,\n            master=self.winfo_toplevel(),\n        )\n\n        if not choice:\n            return\n\n        get_workbench().set_option(\n            get_file_handler_conf_key(extension),\n            \"system\" if choice == system_choice else \"thonny\",\n        )\n        # update icons\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Opens a dialog allowing users to configure how files of a specific extension are opened within Thonny's file browser. It lets users choose between the system's default application or Thonny's text editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "add_middle_menu_items", "line_number": 692, "body": "def add_middle_menu_items(self, context):\n        if self.supports_trash():\n            if running_on_windows():\n                trash_label = tr(\"Move to Recycle Bin\")\n            else:\n                trash_label = tr(\"Move to Trash\")\n            self.menu.add_command(label=trash_label, command=self.move_to_trash)\n        else:\n            self.menu.add_command(label=tr(\"Delete\"), command=self.delete)\n\n        if self.supports_directories():\n            self.menu.add_command(label=tr(\"New directory\") + \"...\", command=self.mkdir)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Configures the file browser's context menu by adding options for moving items to trash/deleting and creating new directories. It dynamically adapts based on system capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "add_last_menu_items", "line_number": 705, "body": "def add_last_menu_items(self, context):\n        self.menu.add_command(label=tr(\"Properties\"), command=self.show_properties)\n        if context == \"button\":\n            self.menu.add_command(label=tr(\"Storage space\"), command=self.show_fs_info)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Adds 'Properties' and conditionally 'Storage space' menu items to the file browser's context menu. This enhances user interaction by providing access to file and file system information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "show_properties", "line_number": 710, "body": "def show_properties(self):\n        node_id = self.get_selected_node()\n        if node_id is None:\n            self.notify_missing_selection()\n            return\n\n        values = self.tree.set(node_id)\n\n        text = tr(\"Path\") + \":\\n    \" + values[\"path\"] + \"\\n\\n\"\n        if values[\"kind\"] == \"dir\":\n            title = tr(\"Directory properties\")\n        else:\n            title = tr(\"File properties\")\n            size_fmt_str = sizeof_fmt(int(values[\"size\"]))\n            bytes_str = str(values[\"size\"]) + \" \" + tr(\"bytes\")\n\n            text += (\n                tr(\"Size\")\n                + \":\\n    \"\n                + (\n                    bytes_str\n                    if size_fmt_str.endswith(\" B\")\n                    else size_fmt_str + \"  (\" + bytes_str + \")\"\n                )\n                + \"\\n\\n\"\n            )\n\n        if values[\"modified\"].strip():\n            text += tr(\"Modified\") + \":\\n    \" + values[\"modified\"] + \"\\n\\n\"\n\n        messagebox.showinfo(title, text.strip(), master=self)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Displays a pop-up window showing detailed properties (path, size, modification date) of the currently selected file or directory in the file browser."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "refresh_tree", "line_number": 742, "body": "def refresh_tree(self, paths_to_invalidate=None):\n        self.invalidate_cache(paths_to_invalidate)\n        if self.winfo_ismapped():\n            self.render_children_from_cache(\"\")\n\n        if self.path_to_highlight:\n            self.select_path_if_visible(self.path_to_highlight)\n            self.path_to_highlight = None", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Updates the file tree display by invalidating its cache and re-rendering visible paths. It also ensures a previously marked path is selected if visible after the refresh."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "create_new_file", "line_number": 751, "body": "def create_new_file(self):\n        selected_node_id = self.get_selected_node()\n\n        if selected_node_id:\n            selected_path = self.tree.set(selected_node_id, \"path\")\n            selected_kind = self.tree.set(selected_node_id, \"kind\")\n\n            if selected_kind == \"dir\":\n                parent_path = selected_path\n            else:\n                parent_id = self.tree.parent(selected_node_id)\n                parent_path = self.tree.set(parent_id, \"path\")\n        else:\n            parent_path = self.current_focus\n\n        name = ask_string(\n            \"File name\", \"Provide filename\", initial_value=\"\", master=self.winfo_toplevel()\n        )\n\n        if not name:\n            return None\n\n        path = self.join(parent_path, name)\n\n        if name in self._cached_child_data[parent_path]:\n            # TODO: ignore case in windows\n            messagebox.showerror(\"Error\", \"The file '\" + path + \"' already exists\", master=self)\n            return self.create_new_file()\n        else:\n            self.open_file(path)\n\n        return path", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This `BaseFileBrowser` method allows users to create a new file. It prompts for a filename, determines the appropriate directory based on the current selection, and creates the file, handling name conflicts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "delete", "line_number": 784, "body": "def delete(self):\n        selection = self.get_selection_info(True)\n        if not selection:\n            return\n\n        confirmation = \"Are you sure want to delete %s?\" % selection[\"description\"]\n        confirmation += \"\\n\\nNB! Recycle bin won't be used (no way to undelete)!\"\n        if \"dir\" in selection[\"kinds\"]:\n            confirmation += \"\\n\" + \"Directories will be deleted with content.\"\n\n        if not messagebox.askyesno(\"Are you sure?\", confirmation, master=self):\n            return\n\n        self.perform_delete(selection[\"paths\"], tr(\"Deleting %s\") % selection[\"description\"])\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method enables users to delete selected files or directories after a confirmation prompt. It warns that deletion is permanent and includes all contents for directories."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "move_to_trash", "line_number": 800, "body": "def move_to_trash(self):\n        assert self.supports_trash()\n\n        selection = self.get_selection_info(True)\n        if not selection:\n            return\n\n        trash = \"Recycle Bin\" if running_on_windows() else \"Trash\"\n        if not messagebox.askokcancel(\n            \"Moving to %s\" % trash,\n            \"I'll try to move %s to %s,\\n\" % (selection[\"description\"], trash)\n            + \"but my method is not always reliable \u2014\\n\"\n            + \"in some cases the files will be deleted\\n\"\n            + \"without the possibility to restore.\",\n            icon=\"info\",\n            master=self,\n        ):\n            return\n\n        self.perform_move_to_trash(\n            selection[\"paths\"], tr(\"Moving %s to %s\") % (selection[\"description\"], trash)\n        )\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Provides the capability to move selected files or folders to the system's trash/recycle bin. It includes a user confirmation with a warning about potential permanent deletion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "supports_trash", "line_number": 824, "body": "def supports_trash(self):\n        return False", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method indicates whether the file browser supports moving files to a trash bin instead of immediate permanent deletion. It signals that this specific browser does not offer trash functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "mkdir", "line_number": 827, "body": "def mkdir(self):\n        parent = self.get_selected_path()\n        if parent is None:\n            parent = self.current_focus\n        else:\n            if self.get_selected_kind() == \"file\":\n                # dirname does the right thing even if parent is Linux path and running on Windows\n                parent = os.path.dirname(parent)\n\n        name = ask_string(\n            tr(\"New directory\"),\n            tr(\"Enter name for new directory under\\n%s\") % parent,\n            master=self.winfo_toplevel(),\n        )\n        if not name or not name.strip():\n            return\n\n        self.perform_mkdir(parent, name.strip())\n        self.refresh_tree()", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Allows users to interactively create a new directory within the file browser. It determines the appropriate parent path and prompts the user for the new directory's name."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "supports_directories", "line_number": 853, "body": "def supports_directories(self):\n        return True", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method indicates that the file browser supports the concept of directories. It declares a core capability for managing hierarchical file structures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "notify_missing_selection", "line_number": 859, "body": "def notify_missing_selection(self):\n        messagebox.showerror(\n            tr(\"Nothing selected\"), tr(\"Select an item and try again!\"), master=self\n        )", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Displays an error message to the user, instructing them to select an item before attempting an action again."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "should_open_name_in_thonny", "line_number": 864, "body": "def should_open_name_in_thonny(self, name):\n        ext = self.get_extension_from_name(name)\n        return get_workbench().get_option(get_file_handler_conf_key(ext), \"system\") == \"thonny\"", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "A method of the BaseFileBrowser class that determines if a given file, based on its extension, is configured to be opened by Thonny. It checks the Thonny workbench's file handling options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "destroy", "line_number": 875, "body": "def destroy(self):\n        super().destroy()\n        get_workbench().unbind(\"WindowFocusIn\", self.on_window_focus_in)\n        get_workbench().unbind(\"LocalFileOperation\", self.on_local_file_operation)", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Cleans up the file browser instance by unbinding event handlers for window focus and local file operations. It ensures proper resource release upon component destruction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_dirs_child_data", "line_number": 880, "body": "def request_dirs_child_data(self, node_id, paths):\n        self.cache_dirs_child_data(get_dirs_children_info(paths, show_hidden_files()))\n        self.render_children_from_cache(node_id)", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Retrieves and caches child directory data for the given paths. It then uses this data to render the directory contents for a file browser display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "split_path", "line_number": 884, "body": "def split_path(self, path):\n        parts = super().split_path(path)\n        if running_on_windows() and path.startswith(\"\\\\\\\\\"):\n            # Don't split a network name!\n            sep = self.get_dir_separator()\n            for i in reversed(range(len(parts))):\n                prefix = sep.join(parts[: i + 1])\n                if os.path.ismount(prefix):\n                    return [prefix] + parts[i + 1 :]\n\n            # Could not find the prefix corresponding to mount\n            return [path]\n        else:\n            return parts", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Splits a file path into its components. It specifically handles Windows network paths, ensuring the mount point is correctly identified and preserved as the root."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_file", "line_number": 899, "body": "def open_file(self, path):\n        get_workbench().get_editor_notebook().show_file(path)", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Opens the specified file within the application's integrated editor. This provides users with the capability to view file content directly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_path_with_system_app", "line_number": 902, "body": "def open_path_with_system_app(self, path):\n        try:\n            open_with_default_app(path)\n        except Exception as e:\n            logger.error(\"Could not open %r in system app\", path, exc_info=e)\n            messagebox.showerror(\n                \"Error\",\n                \"Could not open '%s' in system app\\nError: %s\" % (path, e),\n                parent=self.winfo_toplevel(),\n            )", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Opens the specified file or directory path using the operating system's default application. It provides a convenient way for users to interact with local files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_window_focus_in", "line_number": 913, "body": "def on_window_focus_in(self, event=None):\n        self.refresh_tree()", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "This method updates the displayed file tree view when the application window gains focus, ensuring the content is always current."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_local_file_operation", "line_number": 916, "body": "def on_local_file_operation(self, event):\n        if event[\"operation\"] in [\"save\", \"delete\"]:\n            self.refresh_tree()\n            self.select_path_if_visible(event[\"path\"])", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Responds to local file 'save' or 'delete' operations. It updates the file browser's view and attempts to re-select the affected path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_fs_info", "line_number": 921, "body": "def request_fs_info(self, path):\n        if path == \"\":\n            self.notify_missing_selection()\n        else:\n            if not os.path.isdir(path):\n                path = os.path.dirname(path)\n\n            import shutil\n\n            self.present_fs_info(shutil.disk_usage(path)._asdict())", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Retrieves and presents disk usage information for a specified directory. It adapts the path if a file is selected and notifies if no selection is made."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "perform_move_to_trash", "line_number": 936, "body": "def perform_move_to_trash(self, paths, description):\n        # TODO: do it with subprocess dialog\n        import send2trash\n\n        for path in paths:\n            send2trash.send2trash(path)", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Moves specified files or directories to the system's trash or recycle bin, providing a recoverable deletion mechanism for file management operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "perform_mkdir", "line_number": 943, "body": "def perform_mkdir(self, parent_dir, name):\n        os.mkdir(os.path.join(parent_dir, name), mode=0o700)", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Creates a new directory with specified permissions within a given parent directory on the local file system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "supports_trash", "line_number": 946, "body": "def supports_trash(self):\n        try:\n            import send2trash  # @UnusedImport\n\n            return True\n        except ImportError:\n            return False", "is_method": true, "class_name": "BaseLocalFileBrowser", "function_description": "Checks if the file browser can safely move files to the system trash. It indicates whether the `send2trash` library is available for this operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "destroy", "line_number": 964, "body": "def destroy(self):\n        super().destroy()\n        get_workbench().unbind(\"get_dirs_children_info_response\", self.update_dir_data)\n        get_workbench().unbind(\"get_fs_info_response\", self.present_fs_info)\n        get_workbench().unbind(\"RemoteFileOperation\", self.on_remote_file_operation)", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "This method performs necessary cleanup for the remote file browser. It unbinds all associated event listeners from the workbench to release resources upon destruction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_root_text", "line_number": 970, "body": "def get_root_text(self):\n        runner = get_runner()\n        if runner:\n            return runner.get_node_label()\n\n        return \"Back-end\"", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Provides the display text for the remote file browser's root, defaulting to 'Back-end' if no specific runner label is available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_dirs_child_data", "line_number": 977, "body": "def request_dirs_child_data(self, node_id, paths):\n        if get_runner():\n            get_runner().send_command(\n                InlineCommand(\n                    \"get_dirs_children_info\",\n                    node_id=node_id,\n                    paths=paths,\n                    include_hidden=show_hidden_files(),\n                )\n            )", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Initiates a request to a remote runner to fetch child data (files and directories) for specified paths. It can optionally include hidden items."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_fs_info", "line_number": 988, "body": "def request_fs_info(self, path):\n        if get_runner():\n            get_runner().send_command(InlineCommand(\"get_fs_info\", path=path))", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Initiates a request to a remote execution environment to retrieve file system information for a specified path. This method dispatches a command to get details from a remote file system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_dir_separator", "line_number": 992, "body": "def get_dir_separator(self):\n        return self.dir_separator", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Retrieves the character used as a directory separator for the remote file system. This enables other functions to correctly construct or parse remote file paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "update_dir_data", "line_number": 995, "body": "def update_dir_data(self, msg):\n        if msg.get(\"error\"):\n            self.show_error(msg[\"error\"])\n        else:\n            self.dir_separator = msg[\"dir_separator\"]\n            self.cache_dirs_child_data(msg[\"data\"])\n            self.render_children_from_cache(msg[\"node_id\"])\n\n        if self.path_to_highlight:\n            self.select_path_if_visible(self.path_to_highlight)\n            self.path_to_highlight = None", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Updates the remote file browser's state and display using incoming directory data. It caches child directories, renders contents, and handles errors or specific path highlighting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_file", "line_number": 1007, "body": "def open_file(self, path):\n        get_workbench().get_editor_notebook().show_remote_file(path)", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Displays a specified remote file within the application's editor/notebook. It enables users to view remote content directly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "supports_directories", "line_number": 1018, "body": "def supports_directories(self):\n        runner = get_runner()\n        if not runner:\n            return False\n        proxy = runner.get_backend_proxy()\n        if not proxy:\n            return False\n        return proxy.supports_remote_directories()", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Determines if the remote file system, accessed via this browser, supports directory operations. This capability informs other functions about the backend's features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_remote_file_operation", "line_number": 1027, "body": "def on_remote_file_operation(self, event):\n        path = event[\"path\"]\n        exists_in_cache = self.file_exists_in_cache(path)\n        if (\n            event[\"operation\"] == \"save\"\n            and exists_in_cache\n            or event[\"operation\"] == \"delete\"\n            and not exists_in_cache\n        ):\n            # No need to refresh\n            return\n\n        if \"/\" in path:\n            parent = path[: path.rfind(\"/\")]\n            if not parent:\n                parent = \"/\"\n        else:\n            parent = \"\"\n\n        self.refresh_tree([parent])\n        self.path_to_highlight = path", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "This method updates the file browser's display in response to remote file save or delete operations. It refreshes the relevant directory tree and highlights the affected file, optimizing by avoiding unnecessary refreshes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "perform_delete", "line_number": 1049, "body": "def perform_delete(self, paths, description):\n        get_runner().send_command_and_wait(\n            InlineCommand(\"delete\", paths=paths, description=description),\n            dialog_title=tr(\"Deleting\"),\n        )", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "**\nDeletes specified files or directories on the remote system. It sends the delete command and waits for its completion, displaying a progress dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "perform_mkdir", "line_number": 1055, "body": "def perform_mkdir(self, parent_dir, name):\n        path = (parent_dir + self.get_dir_separator() + name).replace(\"//\", \"/\")\n        get_runner().send_command_and_wait(\n            InlineCommand(\"mkdir\", path=path),\n            dialog_title=tr(\"Creating directory\"),\n        )", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "This method creates a new directory on the remote file system. It constructs the full path and sends a command to execute the directory creation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "supports_trash", "line_number": 1062, "body": "def supports_trash(self):\n        return get_runner().get_backend_proxy().supports_trash()", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Checks if the remote file system accessed by the browser supports moving files to a trash or recycle bin. This capability allows for recoverable deletion, enhancing data safety during file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_focus_into", "line_number": 1065, "body": "def request_focus_into(self, path):\n        if not get_runner().ready_for_remote_file_operations(show_message=True):\n            return False\n\n        # super().request_focus_into(path)\n\n        if not get_runner().supports_remote_directories():\n            assert path == \"\"\n            self.focus_into(path)\n        elif self.current_focus == path:\n            # refreshes\n            self.focus_into(path)\n        else:\n            self.request_new_focus(path)\n\n        return True", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Facilitates changing or refreshing the displayed directory focus within the remote file browser, ensuring the system is ready for such operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "request_new_focus", "line_number": 1082, "body": "def request_new_focus(self, path):\n        # Overridden in active browser\n        self.focus_into(path)", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Directs the remote file browser to change its current operational focus to a specified path. This capability enables navigation within the browser's view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "cmd_refresh_tree", "line_number": 1086, "body": "def cmd_refresh_tree(self):\n        if not get_runner().ready_for_remote_file_operations(show_message=True):\n            return\n\n        super().cmd_refresh_tree()", "is_method": true, "class_name": "BaseRemoteFileBrowser", "function_description": "Refreshes the remote file browser's tree view, after confirming that remote file operations are active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "open_file", "line_number": 1102, "body": "def open_file(self, path):\n        self.dialog.double_click_file(path)", "is_method": true, "class_name": "DialogRemoteFileBrowser", "function_description": "Simulates a user double-clicking on a specified file path within the remote file browser's dialog to open it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "should_open_name_in_thonny", "line_number": 1105, "body": "def should_open_name_in_thonny(self, name):\n        # In dialog, all file types are to be opened in Thonny\n        return True", "is_method": true, "class_name": "DialogRemoteFileBrowser", "function_description": "For the remote file browser, this method dictates that all selected items should be opened directly within the Thonny IDE."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_ok", "line_number": 1165, "body": "def on_ok(self, event=None):\n        tree = self.browser.tree\n        name = self.name_var.get()\n\n        if not name:\n            messagebox.showerror(tr(\"Error\"), tr(\"You need to select a file!\"), master=self)\n            return\n\n        for node_id in tree.get_children(\"\"):\n            if name and name == tree.set(node_id, \"name\"):\n                break\n        else:\n            node_id = None\n\n        if node_id is not None:\n            node_kind = tree.set(node_id, \"kind\")\n            if node_kind != \"file\":\n                messagebox.showerror(tr(\"Error\"), tr(\"You need to select a file!\"), master=self)\n                return\n            elif self.kind == \"save\":\n                if not messagebox.askyesno(\n                    tr(\"Overwrite?\"), tr(\"Do you want to overwrite '%s' ?\") % name, master=self\n                ):\n                    return\n\n        parent_path = tree.set(\"\", \"path\")\n        if parent_path == \"\" or parent_path.endswith(\"/\"):\n            self.result = parent_path + name\n        else:\n            self.result = parent_path + \"/\" + name\n\n        self.destroy()", "is_method": true, "class_name": "BackendFileDialog", "function_description": "Validates the user's file selection in a dialog, ensuring a file is chosen and handling overwrite prompts for \"save\" operations. It constructs and stores the full path of the selected file before closing the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_cancel", "line_number": 1198, "body": "def on_cancel(self, event=None):\n        self.result = None\n        self.destroy()", "is_method": true, "class_name": "BackendFileDialog", "function_description": "Handles the cancellation of the file dialog operation. It clears any selection and closes the dialog window, indicating no file was chosen."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_tree_select", "line_number": 1202, "body": "def on_tree_select(self, event=None):\n        if self.updating_selection:\n            return\n\n        if self.browser.get_selected_kind() == \"file\":\n            name = self.browser.get_selected_name()\n            if name:\n                self.name_var.set(name)", "is_method": true, "class_name": "BackendFileDialog", "function_description": "Updates the file name input field when a user selects a file in the browser's tree view. It ignores directory selections and internal update events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_name_edit", "line_number": 1211, "body": "def on_name_edit(self, event=None):\n        self.updating_selection = True\n        tree = self.browser.tree\n        if self.tree_select_handler_id:\n            tree.unbind(\"<<TreeviewSelect>>\", self.tree_select_handler_id)\n            self.tree_select_handler_id = None\n\n        name = self.name_var.get()\n        for node_id in tree.get_children(\"\"):\n            if name == tree.set(node_id, \"name\"):\n                tree.selection_add(node_id)\n            else:\n                tree.selection_remove(node_id)\n\n        self.updating_selection = False\n        self.tree_select_handler_id = tree.bind(\"<<TreeviewSelect>>\", self.on_tree_select, True)", "is_method": true, "class_name": "BackendFileDialog", "function_description": "Updates the file browser's treeview selection to match a user-entered name. It selects the item with the matching name and deselects all others, while temporarily disabling selection events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "double_click_file", "line_number": 1228, "body": "def double_click_file(self, path):\n        assert path.endswith(self.name_var.get())\n        self.on_ok()", "is_method": true, "class_name": "BackendFileDialog", "function_description": "Handles a double-click action on a file within the file dialog. It validates the chosen path and confirms the file selection, like pressing \"OK\"."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_local", "line_number": 1274, "body": "def on_local(self, event=None):\n        self.result = \"local\"\n        self.destroy()", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "Handles the user's selection of the 'local' option in the dialog. It records this choice and then closes the dialog window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_remote", "line_number": 1278, "body": "def on_remote(self, event=None):\n        self.result = \"remote\"\n        self.destroy()", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "Handles the 'remote' selection within the NodeChoiceDialog. It records this choice and then dismisses the dialog window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_return", "line_number": 1282, "body": "def on_return(self, event=None):\n        if self.focus_get() == self.local_button:\n            self.on_local(event)\n        elif self.focus_get() == self.remote_button:\n            self.on_remote(event)", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "This method processes the 'Enter' key press event in the dialog. It triggers the action of the currently focused button (local or remote)."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_down", "line_number": 1288, "body": "def on_down(self, event=None):\n        if self.focus_get() == self.local_button:\n            self.remote_button.focus_set()", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "This method manages UI focus within the `NodeChoiceDialog`. It shifts the user's focus from the local button to the remote button upon a 'down' event, enabling keyboard navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_up", "line_number": 1292, "body": "def on_up(self, event=None):\n        if self.focus_get() == self.remote_button:\n            self.local_button.focus_set()", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "Handles an 'up' event in the NodeChoiceDialog. If the remote button is focused, it shifts input focus to the local button, enabling keyboard navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "on_cancel", "line_number": 1296, "body": "def on_cancel(self, event=None):\n        self.result = None\n        self.destroy()", "is_method": true, "class_name": "NodeChoiceDialog", "function_description": "Handles the user's decision to cancel the NodeChoiceDialog. It sets the dialog's result to None, indicating no selection, and closes the window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "get_dir_range", "line_number": 128, "body": "def get_dir_range(event):\n            mouse_index = self.path_bar.index(\"@%d,%d\" % (event.x, event.y))\n            return self.path_bar.tag_prevrange(\"dir\", mouse_index + \"+1c\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Identifies and returns the text range of the directory segment immediately preceding a mouse click within the file browser's path bar. This enables interactive navigation or selection of path components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "dir_tag_motion", "line_number": 132, "body": "def dir_tag_motion(event):\n            self.path_bar.tag_remove(\"underline\", \"1.0\", \"end\")\n            dir_range = get_dir_range(event)\n            if dir_range:\n                range_start, range_end = dir_range\n                self.path_bar.tag_add(\"underline\", range_start, range_end)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Highlights the specific directory name within the file browser's path bar by underlining it. This provides visual feedback during user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "dir_tag_enter", "line_number": 139, "body": "def dir_tag_enter(event):\n            self.path_bar.config(cursor=\"hand2\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method changes the mouse cursor to a hand icon when it hovers over the file browser's path bar. It provides visual feedback for interactive elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "dir_tag_leave", "line_number": 142, "body": "def dir_tag_leave(event):\n            self.path_bar.config(cursor=\"\")\n            self.path_bar.tag_remove(\"underline\", \"1.0\", \"end\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method resets the visual state of the path bar when the mouse leaves it. It reverts the cursor to default and removes any underline styling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "dir_tag_click", "line_number": 146, "body": "def dir_tag_click(event):\n            mouse_index = self.path_bar.index(\"@%d,%d\" % (event.x, event.y))\n            lineno = int(float(mouse_index))\n            if lineno == 1:\n                self.request_focus_into(\"\")\n            else:\n                assert lineno == 2\n                dir_range = get_dir_range(event)\n                if dir_range:\n                    _, end_index = dir_range\n                    path = self.path_bar.get(\"2.0\", end_index)\n                    if path.endswith(\":\"):\n                        path += \"\\\\\"\n                    self.request_focus_into(path)", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method allows users to navigate the file system by clicking on elements within the file browser's path display. It enables quick directory changes based on the clicked path component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "create_spacer", "line_number": 200, "body": "def create_spacer():\n                return ttk.Frame(self.path_bar, height=1, width=4, style=\"ViewToolbar.TFrame\")", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "Creates a small, styled frame widget that serves as a visual spacer. It helps separate elements within the file browser's path bar."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/base_file_browser.py", "function": "file_order", "line_number": 453, "body": "def file_order(name):\n                # items in a folder should be ordered so that\n                # folders come first and names are ordered case insensitively\n                return (\n                    not children_data[name][\"isdir\"],  # prefer directories\n                    not \":\" in name,  # prefer drives\n                    name.upper(),\n                    name,\n                )", "is_method": true, "class_name": "BaseFileBrowser", "function_description": "This method provides a sorting key for file and folder names within the BaseFileBrowser. It prioritizes directories, then non-drive items, followed by case-insensitive alphabetical order."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "_build_char_in_string_func", "line_number": 954, "body": "def _build_char_in_string_func(startindex):\n    # copied from idlelib.EditorWindow (Python 3.4.2)\n\n    # Our editwin provides a _is_char_in_string function that works\n    # with a Tk text index, but PyParse only knows about offsets into\n    # a string. This builds a function for PyParse that accepts an\n    # offset.\n\n    def inner(offset, _startindex=startindex, _icis=_is_char_in_string):\n        return _icis(_startindex + \"+%dc\" % offset)\n\n    return inner", "is_method": false, "function_description": "This function creates and returns a utility function. It adapts a character-in-string checker from using Tk text indices to accept string offsets, specifically for PyParse."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "__getitem__", "line_number": 149, "body": "def __getitem__(self, item):\n        return self._get(item)", "is_method": true, "class_name": "StringTranslatePseudoMapping", "function_description": "Enables dictionary-like item access for the string translation pseudo-mapping. It provides a way to retrieve mapped values based on input keys."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "__len__", "line_number": 152, "body": "def __len__(self):\n        return len(self._non_defaults)", "is_method": true, "class_name": "StringTranslatePseudoMapping", "function_description": "Enables the `len()` function for `StringTranslatePseudoMapping` objects. It returns the number of custom or non-default string translation mappings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "__iter__", "line_number": 155, "body": "def __iter__(self):\n        return iter(self._non_defaults)", "is_method": true, "class_name": "StringTranslatePseudoMapping", "function_description": "Enables direct iteration over the custom, non-default string translation mappings defined by this `StringTranslatePseudoMapping` object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get", "line_number": 158, "body": "def get(self, key, default=None):\n        return self._get(key)", "is_method": true, "class_name": "StringTranslatePseudoMapping", "function_description": "Retrieves the mapped value associated with a given key from the pseudo-mapping."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "set_str", "line_number": 167, "body": "def set_str(self, s):\n        assert len(s) == 0 or s[-1] == \"\\n\"\n        self.str = s\n        self.study_level = 0", "is_method": true, "class_name": "RoughParser", "function_description": "Initializes or updates the RoughParser's internal string data for subsequent parsing. It also resets the parser's internal study level."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "find_good_parse_start", "line_number": 183, "body": "def find_good_parse_start(self, is_char_in_string=None, _synchre=_synchre):\n        # pylint: disable=redefined-builtin\n\n        str, pos = self.str, None  # @ReservedAssignment\n\n        if not is_char_in_string:\n            # no clue -- make the caller pass everything\n            return None\n\n        # Peek back from the end for a good place to start,\n        # but don't try too often; pos will be left None, or\n        # bumped to a legitimate synch point.\n        limit = len(str)\n        for _ in range(5):\n            i = str.rfind(\":\\n\", 0, limit)\n            if i < 0:\n                break\n            i = str.rfind(\"\\n\", 0, i) + 1  # start of colon line\n            m = _synchre(str, i, limit)\n            if m and not is_char_in_string(m.start()):\n                pos = m.start()\n                break\n            limit = i\n        if pos is None:\n            # Nothing looks like a block-opener, or stuff does\n            # but is_char_in_string keeps returning true; most likely\n            # we're in or near a giant string, the colorizer hasn't\n            # caught up enough to be helpful, or there simply *aren't*\n            # any interesting stmts.  In any of these cases we're\n            # going to have to parse the whole thing to be sure, so\n            # give it one last try from the start, but stop wasting\n            # time here regardless of the outcome.\n            m = _synchre(str)\n            if m and not is_char_in_string(m.start()):\n                pos = m.start()\n            return pos\n\n        # Peeking back worked; look forward until _synchre no longer\n        # matches.\n        i = pos + 1\n        while 1:\n            m = _synchre(str, i)\n            if m:\n                s, i = m.span()\n                if not is_char_in_string(s):\n                    pos = s\n            else:\n                break\n        return pos", "is_method": true, "class_name": "RoughParser", "function_description": "Finds an optimal starting index within a string for parsing by locating a structural synchronization point. It ensures this point is not inside a string literal, aiding efficient parsing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "set_lo", "line_number": 236, "body": "def set_lo(self, lo):\n        assert lo == 0 or self.str[lo - 1] == \"\\n\"\n        if lo > 0:\n            self.str = self.str[lo:]", "is_method": true, "class_name": "RoughParser", "function_description": "Advances the parser's internal string by discarding its initial portion up to a specified line-aligned index. This adjusts the parsing window for subsequent operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "_study1", "line_number": 255, "body": "def _study1(self):\n        # pylint: disable=redefined-builtin\n\n        if self.study_level >= 1:\n            return\n        self.study_level = 1\n\n        # Map all uninteresting characters to \"x\", all open brackets\n        # to \"(\", all close brackets to \")\", then collapse runs of\n        # uninteresting characters.  This can cut the number of chars\n        # by a factor of 10-40, and so greatly speed the following loop.\n        str = (\n            self.str.translate(self._tran)  # @ReservedAssignment\n            .replace(\"xxxxxxxx\", \"x\")\n            .replace(\"xxxx\", \"x\")\n            .replace(\"xx\", \"x\")\n            .replace(\"xx\", \"x\")\n            .replace(\"\\nx\", \"\\n\")\n        )\n        # note that replacing x\\n with \\n would be incorrect, because\n        # x may be preceded by a backslash\n\n        # March over the squashed version of the program, accumulating\n        # the line numbers of non-continued stmts, and determining\n        # whether & why the last stmt is a continuation.\n        continuation = C_NONE\n        level = lno = 0  # level is nesting level; lno is line number\n        self.goodlines = goodlines = [0]\n        push_good = goodlines.append\n        i, n = 0, len(str)\n        while i < n:\n            ch = str[i]\n            i = i + 1\n\n            # cases are checked in decreasing order of frequency\n            if ch == \"x\":\n                continue\n\n            if ch == \"\\n\":\n                lno = lno + 1\n                if level == 0:\n                    push_good(lno)\n                    # else we're in an unclosed bracket structure\n                continue\n\n            if ch == \"(\":\n                level = level + 1\n                continue\n\n            if ch == \")\":\n                if level:\n                    level = level - 1\n                    # else the program is invalid, but we can't complain\n                continue\n\n            if ch == '\"' or ch == \"'\":\n                # consume the string\n                quote = ch\n                if str[i - 1 : i + 2] == quote * 3:\n                    quote = quote * 3\n                firstlno = lno\n                w = len(quote) - 1\n                i = i + w\n                while i < n:\n                    ch = str[i]\n                    i = i + 1\n\n                    if ch == \"x\":\n                        continue\n\n                    if str[i - 1 : i + w] == quote:\n                        i = i + w\n                        break\n\n                    if ch == \"\\n\":\n                        lno = lno + 1\n                        if w == 0:\n                            # unterminated single-quoted string\n                            # It doesn't matter if we're in brackets,\n                            # this should lead to\n                            # SyntaxError: EOL while scanning string literal\n                            level = 0\n                            push_good(lno)\n                            break\n                        continue\n\n                    if ch == \"\\\\\":\n                        assert i < n\n                        if str[i] == \"\\n\":\n                            lno = lno + 1\n                        i = i + 1\n                        continue\n\n                    # else comment char or paren inside string\n\n                else:\n                    # didn't break out of the loop, so we're still\n                    # inside a string\n                    if (lno - 1) == firstlno:\n                        # before the previous \\n in str, we were in the first\n                        # line of the string\n                        continuation = C_STRING_FIRST_LINE\n                    else:\n                        continuation = C_STRING_NEXT_LINES\n                continue  # with outer loop\n\n            if ch == \"#\":\n                # consume the comment\n                i = str.find(\"\\n\", i)\n                assert i >= 0\n                continue\n\n            assert ch == \"\\\\\"\n            assert i < n\n            if str[i] == \"\\n\":\n                lno = lno + 1\n                if i + 1 == n:\n                    continuation = C_BACKSLASH\n            i = i + 1\n\n        # The last stmt may be continued for all 3 reasons.\n        # String continuation takes precedence over bracket\n        # continuation, which beats backslash continuation.\n        if (\n            continuation != C_STRING_FIRST_LINE\n            and continuation != C_STRING_NEXT_LINES\n            and level > 0\n        ):\n            continuation = C_BRACKET\n        self.continuation = continuation\n\n        # Push the final line number as a sentinel value, regardless of\n        # whether it's continued.\n        assert (continuation == C_NONE) == (goodlines[-1] == lno)\n        if goodlines[-1] != lno:\n            push_good(lno)", "is_method": true, "class_name": "RoughParser", "function_description": "Preprocesses the input string to identify logical line boundaries and determine statement continuation status. It marks where new statements begin, considering string literals, comments, and bracket nesting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "_study2", "line_number": 413, "body": "def _study2(self):\n        # pylint: disable=redefined-builtin\n\n        if self.study_level >= 2:\n            return\n        self._study1()\n        self.study_level = 2\n\n        # Set p and q to slice indices of last interesting stmt.\n        str, goodlines = self.str, self.goodlines  # @ReservedAssignment\n        i = len(goodlines) - 1\n        p = len(str)  # index of newest line\n        while i:\n            assert p\n            # p is the index of the stmt at line number goodlines[i].\n            # Move p back to the stmt at line number goodlines[i-1].\n            q = p\n            for _ in range(goodlines[i - 1], goodlines[i]):  # @UnusedVariable\n                # tricky: sets p to 0 if no preceding newline\n                p = str.rfind(\"\\n\", 0, p - 1) + 1\n            # The stmt str[p:q] isn't a continuation, but may be blank\n            # or a non-indenting comment line.\n            if _junkre(str, p):\n                i = i - 1\n            else:\n                break\n        if i == 0:\n            # nothing but junk!\n            assert p == 0\n            q = p\n        self.stmt_start, self.stmt_end = p, q\n\n        # Analyze this stmt, to find the last open bracket (if any)\n        # and last interesting character (if any).\n        lastch = \"\"\n        stack = []  # stack of open bracket indices\n        push_stack = stack.append\n        bracketing = [(p, 0)]\n        while p < q:\n            # suck up all except ()[]{}'\"#\\\\\n            m = _chew_ordinaryre(str, p, q)\n            if m:\n                # we skipped at least one boring char\n                newp = m.end()\n                # back up over totally boring whitespace\n                i = newp - 1  # index of last boring char\n                while i >= p and str[i] in \" \\t\\n\":\n                    i = i - 1\n                if i >= p:\n                    lastch = str[i]\n                p = newp\n                if p >= q:\n                    break\n\n            ch = str[p]\n\n            if ch in \"([{\":\n                push_stack(p)\n                bracketing.append((p, len(stack)))\n                lastch = ch\n                p = p + 1\n                continue\n\n            if ch in \")]}\":\n                if stack:\n                    del stack[-1]\n                lastch = ch\n                p = p + 1\n                bracketing.append((p, len(stack)))\n                continue\n\n            if ch == '\"' or ch == \"'\":\n                # consume string\n                # Note that study1 did this with a Python loop, but\n                # we use a regexp here; the reason is speed in both\n                # cases; the string may be huge, but study1 pre-squashed\n                # strings to a couple of characters per line.  study1\n                # also needed to keep track of newlines, and we don't\n                # have to.\n                bracketing.append((p, len(stack) + 1))\n                lastch = ch\n                p = _match_stringre(str, p, q).end()\n                bracketing.append((p, len(stack)))\n                continue\n\n            if ch == \"#\":\n                # consume comment and trailing newline\n                bracketing.append((p, len(stack) + 1))\n                p = str.find(\"\\n\", p, q) + 1\n                assert p > 0\n                bracketing.append((p, len(stack)))\n                continue\n\n            assert ch == \"\\\\\"\n            p = p + 1  # beyond backslash\n            assert p < q\n            if str[p] != \"\\n\":\n                # the program is invalid, but can't complain\n                lastch = ch + str[p]\n            p = p + 1  # beyond escaped char\n\n        # end while p < q:\n\n        self.lastch = lastch\n        if stack:\n            self.lastopenbracketpos = stack[-1]\n        self.stmt_bracketing = tuple(bracketing)", "is_method": true, "class_name": "RoughParser", "function_description": "Analyzes the last significant statement in the code to determine its precise boundaries and track bracket nesting. This enables features like auto-indentation or syntax-aware editing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "compute_bracket_indent", "line_number": 524, "body": "def compute_bracket_indent(self):\n        # pylint: disable=redefined-builtin\n        self._study2()\n        assert self.continuation == C_BRACKET\n        j = self.lastopenbracketpos\n        str = self.str  # @ReservedAssignment\n        n = len(str)\n        origi = i = str.rfind(\"\\n\", 0, j) + 1\n        j = j + 1  # one beyond open bracket\n        # find first list item; set i to start of its line\n        while j < n:\n            m = _itemre(str, j)\n            if m:\n                j = m.end() - 1  # index of first interesting char\n                extra = 0\n                break\n            else:\n                # this line is junk; advance to next line\n                i = j = str.find(\"\\n\", j) + 1\n        else:\n            # nothing interesting follows the bracket;\n            # reproduce the bracket line's indentation + a level\n            j = i = origi\n            while str[j] in \" \\t\":\n                j = j + 1\n            extra = self.indent_width\n        return len(str[i:j].expandtabs(self.tabwidth)) + extra", "is_method": true, "class_name": "RoughParser", "function_description": "This method computes the correct indentation level for lines that continue after an open bracket, considering subsequent list items or applying a default indent. It helps determine proper alignment for structured code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_num_lines_in_stmt", "line_number": 556, "body": "def get_num_lines_in_stmt(self):\n        self._study1()\n        goodlines = self.goodlines\n        return goodlines[-1] - goodlines[-2]", "is_method": true, "class_name": "RoughParser", "function_description": "Calculates the number of lines for a statement within the parsed content. It serves to determine statement length."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "compute_backslash_indent", "line_number": 565, "body": "def compute_backslash_indent(self):\n        # pylint: disable=redefined-builtin\n        self._study2()\n        assert self.continuation == C_BACKSLASH\n        str = self.str  # @ReservedAssignment\n        i = self.stmt_start\n        while str[i] in \" \\t\":\n            i = i + 1\n        startpos = i\n\n        # See whether the initial line starts an assignment stmt; i.e.,\n        # look for an = operator\n        endpos = str.find(\"\\n\", startpos) + 1\n        found = level = 0\n        while i < endpos:\n            ch = str[i]\n            if ch in \"([{\":\n                level = level + 1\n                i = i + 1\n            elif ch in \")]}\":\n                if level:\n                    level = level - 1\n                i = i + 1\n            elif ch == '\"' or ch == \"'\":\n                i = _match_stringre(str, i, endpos).end()\n            elif ch == \"#\":\n                break\n            elif (\n                level == 0\n                and ch == \"=\"\n                and (i == 0 or str[i - 1] not in \"=<>!\")\n                and str[i + 1] != \"=\"\n            ):\n                found = 1\n                break\n            else:\n                i = i + 1\n\n        if found:\n            # found a legit =, but it may be the last interesting\n            # thing on the line\n            i = i + 1  # move beyond the =\n            found = re.match(r\"\\s*\\\\\", str[i:endpos]) is None\n\n        if not found:\n            # oh well ... settle for moving beyond the first chunk\n            # of non-whitespace chars\n            i = startpos\n            while str[i] not in \" \\t\\n\":\n                i = i + 1\n\n        return len(str[self.stmt_start : i].expandtabs(self.tabwidth)) + 1", "is_method": true, "class_name": "RoughParser", "function_description": "Calculates a specific indentation level for a Python code line continued with a backslash. It attempts to align the indentation based on the presence of an assignment operator."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_base_indent_string", "line_number": 621, "body": "def get_base_indent_string(self):\n        self._study2()\n        i, n = self.stmt_start, self.stmt_end\n        j = i\n        str_ = self.str\n        while j < n and str_[j] in \" \\t\":\n            j = j + 1\n        return str_[i:j]", "is_method": true, "class_name": "RoughParser", "function_description": "Retrieves the leading whitespace (indentation) string from the current statement being parsed. This is essential for parsers that interpret code structure based on indentation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "is_block_opener", "line_number": 632, "body": "def is_block_opener(self):\n        self._study2()\n        return self.lastch == \":\"", "is_method": true, "class_name": "RoughParser", "function_description": "A RoughParser method that checks if the last character observed is a colon. This identifies the start of a new logical or code block during parsing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "is_block_closer", "line_number": 638, "body": "def is_block_closer(self):\n        self._study2()\n        return _closere(self.str, self.stmt_start) is not None", "is_method": true, "class_name": "RoughParser", "function_description": "Checks if the current position within the parsed input signifies the termination of a code or structural block. This helps the parser identify logical units."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_last_open_bracket_pos", "line_number": 645, "body": "def get_last_open_bracket_pos(self):\n        self._study2()\n        return self.lastopenbracketpos", "is_method": true, "class_name": "RoughParser", "function_description": "Retrieves the position of the last open bracket identified by the RoughParser during its analysis. This is useful for syntax parsing or code analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_last_stmt_bracketing", "line_number": 654, "body": "def get_last_stmt_bracketing(self):\n        self._study2()\n        return self.stmt_bracketing", "is_method": true, "class_name": "RoughParser", "function_description": "Retrieves the statement bracketing, first ensuring it is updated by an internal parsing process. It provides the parsed structural boundaries of statements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "set_index", "line_number": 721, "body": "def set_index(self, index):\n        \"\"\"Set the index to which the functions relate.\n\n        The index must be in the same statement.\n        \"\"\"\n        indexinrawtext = len(self.rawtext) - len(self.text.get(index, self.stopatindex))\n        if indexinrawtext < 0:\n            raise ValueError(\"Index %s precedes the analyzed statement\" % index)\n        self.indexinrawtext = indexinrawtext\n        # find the rightmost bracket to which index belongs\n        self.indexbracket = 0\n        while (\n            self.indexbracket < len(self.bracketing) - 1\n            and self.bracketing[self.indexbracket + 1][0] < self.indexinrawtext\n        ):\n            self.indexbracket += 1\n        if (\n            self.indexbracket < len(self.bracketing) - 1\n            and self.bracketing[self.indexbracket + 1][0] == self.indexinrawtext\n            and not self.isopener[self.indexbracket + 1]\n        ):\n            self.indexbracket += 1", "is_method": true, "class_name": "HyperParser", "function_description": "Initializes the parser's current position to a given index, converting it to a raw text offset. It then identifies the deepest structural bracket that contains this position."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "is_in_string", "line_number": 744, "body": "def is_in_string(self):\n        \"\"\"Is the index given to the HyperParser in a string?\"\"\"\n        # The bracket to which we belong should be an opener.\n        # If it's an opener, it has to have a character.\n        return self.isopener[self.indexbracket] and self.rawtext[\n            self.bracketing[self.indexbracket][0]\n        ] in ('\"', \"'\")", "is_method": true, "class_name": "HyperParser", "function_description": "Determines if the current parsing position managed by the HyperParser instance is located within a string literal."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "is_in_code", "line_number": 752, "body": "def is_in_code(self):\n        \"\"\"Is the index given to the HyperParser in normal code?\"\"\"\n        return not self.isopener[self.indexbracket] or self.rawtext[\n            self.bracketing[self.indexbracket][0]\n        ] not in (\"#\", '\"', \"'\")", "is_method": true, "class_name": "HyperParser", "function_description": "Checks if the parser's current position is within executable code, excluding comments and string literals. Useful for syntax highlighting or code analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_surrounding_brackets", "line_number": 758, "body": "def get_surrounding_brackets(self, openers=\"([{\", mustclose=False):\n        \"\"\"Return bracket indexes or None.\n\n        If the index given to the HyperParser is surrounded by a\n        bracket defined in openers (or at least has one before it),\n        return the indices of the opening bracket and the closing\n        bracket (or the end of line, whichever comes first).\n\n        If it is not surrounded by brackets, or the end of line comes\n        before the closing bracket and mustclose is True, returns None.\n        \"\"\"\n\n        bracketinglevel = self.bracketing[self.indexbracket][1]\n        before = self.indexbracket\n        while (\n            not self.isopener[before]\n            or self.rawtext[self.bracketing[before][0]] not in openers\n            or self.bracketing[before][1] > bracketinglevel\n        ):\n            before -= 1\n            if before < 0:\n                return None\n            bracketinglevel = min(bracketinglevel, self.bracketing[before][1])\n        after = self.indexbracket + 1\n        while after < len(self.bracketing) and self.bracketing[after][1] >= bracketinglevel:\n            after += 1\n\n        beforeindex = self.text.index(\n            \"%s-%dc\" % (self.stopatindex, len(self.rawtext) - self.bracketing[before][0])\n        )\n        if after >= len(self.bracketing) or self.bracketing[after][0] > len(self.rawtext):\n            if mustclose:\n                return None\n            afterindex = self.stopatindex\n        else:\n            # We are after a real char, so it is a ')' and we give the\n            # index before it.\n            afterindex = self.text.index(\n                \"%s-%dc\" % (self.stopatindex, len(self.rawtext) - (self.bracketing[after][0] - 1))\n            )\n\n        return beforeindex, afterindex", "is_method": true, "class_name": "HyperParser", "function_description": "Locates the innermost enclosing pair of specified brackets around the parser's current position within the text. It returns the indices of the opening and closing brackets, or None if no such pair exists."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "_eat_identifier", "line_number": 806, "body": "def _eat_identifier(cls, s, limit, pos):\n        \"\"\"Given a string and pos, return the number of chars in the\n        identifier which ends at pos, or 0 if there is no such one.\n\n        This ignores non-identifier eywords are not identifiers.\n        \"\"\"\n        is_ascii_id_char = _IS_ASCII_ID_CHAR\n\n        # Start at the end (pos) and work backwards.\n        i = pos\n\n        # Go backwards as long as the characters are valid ASCII\n        # identifier characters. This is an optimization, since it\n        # is faster in the common case where most of the characters\n        # are ASCII.\n        while i > limit and (ord(s[i - 1]) < 128 and is_ascii_id_char[ord(s[i - 1])]):\n            i -= 1\n\n        # If the above loop ended due to reaching a non-ASCII\n        # character, continue going backwards using the most generic\n        # test for whether a string contains only valid identifier\n        # characters.\n        if i > limit and ord(s[i - 1]) >= 128:\n            while i - 4 >= limit and (\"a\" + s[i - 4 : pos]).isidentifier():\n                i -= 4\n            if i - 2 >= limit and (\"a\" + s[i - 2 : pos]).isidentifier():\n                i -= 2\n            if i - 1 >= limit and (\"a\" + s[i - 1 : pos]).isidentifier():\n                i -= 1\n\n            # The identifier candidate starts here. If it isn't a valid\n            # identifier, don't eat anything. At this point that is only\n            # possible if the first character isn't a valid first\n            # character for an identifier.\n            if not s[i:pos].isidentifier():\n                return 0\n        elif i < pos:\n            # All characters in str[i:pos] are valid ASCII identifier\n            # characters, so it is enough to check that the first is\n            # valid as the first character of an identifier.\n            if not _IS_ASCII_ID_FIRST_CHAR[ord(s[i])]:\n                return 0\n\n        # All keywords are valid identifiers, but should not be\n        # considered identifiers here, except for True, False and None.\n        if i < pos and (iskeyword(s[i:pos]) and s[i:pos] not in cls._ID_KEYWORDS):\n            return 0\n\n        return pos - i", "is_method": true, "class_name": "HyperParser", "function_description": "This method determines the length of a valid Python identifier string segment ending at a specific position. It specifically excludes most standard Python keywords from being recognized as identifiers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "get_expression", "line_number": 859, "body": "def get_expression(self):\n        \"\"\"Return a string with the Python expression which ends at the\n        given index, which is empty if there is no real one.\n        \"\"\"\n        if not self.is_in_code():\n            raise ValueError(\"get_expression should only be called\" \"if index is inside a code.\")\n\n        rawtext = self.rawtext\n        bracketing = self.bracketing\n\n        brck_index = self.indexbracket\n        brck_limit = bracketing[brck_index][0]\n        pos = self.indexinrawtext\n\n        last_identifier_pos = pos\n        postdot_phase = True\n\n        while 1:\n            # Eat whitespaces, comments, and if postdot_phase is False - a dot\n            while 1:\n                if pos > brck_limit and rawtext[pos - 1] in self._whitespace_chars:\n                    # Eat a whitespace\n                    pos -= 1\n                elif not postdot_phase and pos > brck_limit and rawtext[pos - 1] == \".\":\n                    # Eat a dot\n                    pos -= 1\n                    postdot_phase = True\n                # The next line will fail if we are *inside* a comment,\n                # but we shouldn't be.\n                elif (\n                    pos == brck_limit\n                    and brck_index > 0\n                    and rawtext[bracketing[brck_index - 1][0]] == \"#\"\n                ):\n                    # Eat a comment\n                    brck_index -= 2\n                    brck_limit = bracketing[brck_index][0]\n                    pos = bracketing[brck_index + 1][0]\n                else:\n                    # If we didn't eat anything, quit.\n                    break\n\n            if not postdot_phase:\n                # We didn't find a dot, so the expression end at the\n                # last identifier pos.\n                break\n\n            ret = self._eat_identifier(rawtext, brck_limit, pos)\n            if ret:\n                # There is an identifier to eat\n                pos = pos - ret\n                last_identifier_pos = pos\n                # Now, to continue the search, we must find a dot.\n                postdot_phase = False\n                # (the loop continues now)\n\n            elif pos == brck_limit:\n                # We are at a bracketing limit. If it is a closing\n                # bracket, eat the bracket, otherwise, stop the search.\n                level = bracketing[brck_index][1]\n                while brck_index > 0 and bracketing[brck_index - 1][1] > level:\n                    brck_index -= 1\n                if bracketing[brck_index][0] == brck_limit:\n                    # We were not at the end of a closing bracket\n                    break\n                pos = bracketing[brck_index][0]\n                brck_index -= 1\n                brck_limit = bracketing[brck_index][0]\n                last_identifier_pos = pos\n                if rawtext[pos] in \"([\":\n                    # [] and () may be used after an identifier, so we\n                    # continue. postdot_phase is True, so we don't allow a dot.\n                    pass\n                else:\n                    # We can't continue after other types of brackets\n                    if rawtext[pos] in \"'\\\"\":\n                        # Scan a string prefix\n                        while pos > 0 and rawtext[pos - 1] in \"rRbBuU\":\n                            pos -= 1\n                        last_identifier_pos = pos\n                    break\n\n            else:\n                # We've found an operator or something.\n                break\n\n        return rawtext[last_identifier_pos : self.indexinrawtext]", "is_method": true, "class_name": "HyperParser", "function_description": "Identifies and extracts the complete Python expression string that ends at the parser's current position. Useful for code analysis or context-aware operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "inner", "line_number": 962, "body": "def inner(offset, _startindex=startindex, _icis=_is_char_in_string):\n        return _icis(_startindex + \"+%dc\" % offset)", "is_method": false, "function_description": "Checks for character presence by constructing a positional query string based on a start index and an offset, then executing the query via a pre-supplied function."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "_get", "line_number": 144, "body": "def _get(key, _get=non_defaults.get, _default=default_value):\n            return _get(key, _default)", "is_method": true, "class_name": "StringTranslatePseudoMapping", "function_description": "Retrieves a value associated with a key from an internal mapping. If the key is not found, it returns a specified default value."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/roughparse.py", "function": "index2line", "line_number": 686, "body": "def index2line(index):\n            return int(float(index))", "is_method": true, "class_name": "HyperParser", "function_description": "Converts a potentially fractional index into an integer line number by truncating its decimal component. This maps general positions to discrete lines."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "init_instructions_frame", "line_number": 54, "body": "def init_instructions_frame(self):\n        instructions = self.get_instructions()\n        self.instructions_frame = ttk.Frame(self, style=\"Tip.TFrame\")\n        self.instructions_frame.grid(row=0, column=0, sticky=\"nsew\")\n        self.instructions_frame.rowconfigure(0, weight=1)\n        self.instructions_frame.columnconfigure(0, weight=1)\n\n        pad = self.get_padding()\n        self.instructions_label = ttk.Label(self, style=\"Tip.TLabel\", text=instructions)\n        self.instructions_label.grid(row=0, column=0, sticky=\"w\", padx=pad, pady=pad)", "is_method": true, "class_name": "WorkDialog", "function_description": "Sets up and displays a dedicated UI frame and label within the dialog to present instructions to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "init_main_frame", "line_number": 68, "body": "def init_main_frame(self):\n        self.main_frame = ttk.Frame(self)\n        self.main_frame.grid(row=1, column=0, sticky=\"nsew\")", "is_method": true, "class_name": "WorkDialog", "function_description": "Sets up the WorkDialog's main graphical frame. This frame provides the primary container for arranging other UI elements within the dialog's layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "init_action_frame", "line_number": 72, "body": "def init_action_frame(self):\n        padding = self.get_padding()\n        intpad = self.get_internal_padding()\n\n        self.action_frame = ttk.Frame(self)\n        self.action_frame.grid(row=2, column=0, sticky=\"nsew\")\n\n        self._progress_bar = ttk.Progressbar(\n            self.action_frame, length=ems_to_pixels(4), mode=\"indeterminate\"\n        )\n\n        self._current_action_label = create_action_label(\n            self.action_frame,\n            text=\"\",\n            width=round(self.get_action_text_max_length() * 1.1),\n            click_handler=self.toggle_log_frame,\n        )\n        self._current_action_label.grid(\n            row=1, column=2, sticky=\"we\", pady=padding, padx=(0, intpad)\n        )\n\n        self._ok_button = ttk.Button(\n            self.action_frame,\n            text=self.get_ok_text(),\n            command=self.on_ok,\n            state=\"disabled\",\n            default=\"active\",\n        )\n        if not self._autostart:\n            self._ok_button.grid(column=4, row=1, pady=padding, padx=(0, intpad))\n\n        self._cancel_button = ttk.Button(\n            self.action_frame,\n            text=self.get_cancel_text(),\n            command=self.on_cancel,\n        )\n        self._cancel_button.grid(column=5, row=1, padx=(0, padding), pady=padding)\n\n        self.action_frame.columnconfigure(2, weight=1)", "is_method": true, "class_name": "WorkDialog", "function_description": "Initializes and lays out the action control frame for the WorkDialog. This frame contains a progress bar, current action label, and \"OK\" and \"Cancel\" buttons, enabling user interaction and progress display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_action_text_max_length", "line_number": 112, "body": "def get_action_text_max_length(self):\n        return 35", "is_method": true, "class_name": "WorkDialog", "function_description": "Provides the maximum allowed character length for text describing an action within the WorkDialog, ensuring consistency for UI elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "init_log_frame", "line_number": 115, "body": "def init_log_frame(self):\n        self.log_frame = ttk.Frame(self)\n        self.log_frame.columnconfigure(1, weight=1)\n        self.log_frame.rowconfigure(1, weight=1)\n        fixed_font = tk.font.nametofont(\"TkFixedFont\")\n        font = fixed_font.copy()\n        font.configure(size=round(fixed_font.cget(\"size\") * 0.8))\n        self.log_text = tktextext.TextFrame(\n            self.log_frame,\n            horizontal_scrollbar=False,\n            wrap=\"word\",\n            borderwidth=1,\n            height=5,\n            width=20,\n            font=font,\n            read_only=True,\n        )\n\n        padding = self.get_padding()\n        self.log_text.grid(row=1, column=1, sticky=\"nsew\", padx=padding, pady=(0, padding))", "is_method": true, "class_name": "WorkDialog", "function_description": "This method prepares and lays out a dedicated, read-only text area for displaying application logs or messages within the dialog interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "update_ui", "line_number": 136, "body": "def update_ui(self):\n        if self._state == \"closed\":\n            return\n\n        while not self._work_events_queue.empty():\n            self.handle_work_event(*self._work_events_queue.get())\n            if self._state == \"closed\":\n                return\n\n        if self._state == \"idle\":\n            if self.is_ready_for_work():\n                self._ok_button.configure(state=\"normal\")\n            else:\n                self._ok_button.configure(state=\"disabled\")\n        else:\n            self._ok_button.configure(state=\"disabled\")\n\n        if self._state == \"done\":\n            set_text_if_different(self._cancel_button, tr(\"Close\"))\n        else:\n            set_text_if_different(self._cancel_button, tr(\"Cancel\"))", "is_method": true, "class_name": "WorkDialog", "function_description": "Keeps the WorkDialog's user interface synchronized with its internal state and ongoing work. It processes work events and dynamically updates button states and text for user feedback."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_title", "line_number": 161, "body": "def get_title(self):\n        return \"Work dialog\"", "is_method": true, "class_name": "WorkDialog", "function_description": "Provides the default title string for the WorkDialog UI element."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "_keep_updating_ui", "line_number": 164, "body": "def _keep_updating_ui(self):\n        if self._state != \"closed\":\n            self.update_ui()\n            self._update_scheduler = self.after(200, self._keep_updating_ui)\n        else:\n            self._update_scheduler = None", "is_method": true, "class_name": "WorkDialog", "function_description": "This method continuously updates the dialog's user interface at regular intervals. It ensures the UI remains current until the dialog's state is set to \"closed.\""}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "close", "line_number": 171, "body": "def close(self):\n        self._state = \"closed\"\n        if self._update_scheduler is not None:\n            try:\n                self.after_cancel(self._update_scheduler)\n            except tk.TclError:\n                pass\n\n        self.destroy()", "is_method": true, "class_name": "WorkDialog", "function_description": "Closes the WorkDialog instance, cancelling any scheduled updates. This method also destroys the dialog window, releasing its associated resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "cancel_work", "line_number": 181, "body": "def cancel_work(self):\n        # worker should periodically check this value\n        self._state = \"cancelling\"\n        self.set_action_text(tr(\"Cancelling\"))", "is_method": true, "class_name": "WorkDialog", "function_description": "Signals the initiation of a work cancellation within the dialog. It updates the internal state and the displayed action text to reflect the cancellation process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "toggle_log_frame", "line_number": 186, "body": "def toggle_log_frame(self, event=None):\n        if self.log_frame.winfo_ismapped():\n            self.log_frame.grid_forget()\n            self.rowconfigure(2, weight=1)\n            self.rowconfigure(4, weight=0)\n        else:\n            self.log_frame.grid(row=4, column=0, sticky=\"nsew\")\n            self.rowconfigure(2, weight=0)\n            self.rowconfigure(4, weight=1)", "is_method": true, "class_name": "WorkDialog", "function_description": "This method toggles the visibility of the application's log frame within the UI. It dynamically adjusts the grid layout to show or hide the log output area."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_ok_text", "line_number": 196, "body": "def get_ok_text(self):\n        return tr(\"OK\")", "is_method": true, "class_name": "WorkDialog", "function_description": "Provides the localized \"OK\" text for user interface elements within the dialog, supporting internationalization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_cancel_text", "line_number": 199, "body": "def get_cancel_text(self):\n        return tr(\"Cancel\")", "is_method": true, "class_name": "WorkDialog", "function_description": "Provides the localized text string \"Cancel\" for display in the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "on_ok", "line_number": 202, "body": "def on_ok(self, event=None):\n        assert self._state == \"idle\"\n        if self.start_work() is not False:\n            self._state = \"working\"\n            self.success = False\n            self.grid_progress_widgets()\n            self._progress_bar[\"mode\"] = \"indeterminate\"\n            self._progress_bar.start()\n            if not self._current_action_label[\"text\"]:\n                self._current_action_label[\"text\"] = tr(\"Starting\") + \"...\"", "is_method": true, "class_name": "WorkDialog", "function_description": "Initiates the work process associated with the dialog upon user confirmation. It updates the dialog's state to \"working\" and activates an indeterminate progress bar in the UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "grid_progress_widgets", "line_number": 213, "body": "def grid_progress_widgets(self):\n        padding = self.get_padding()\n        intpad = self.get_internal_padding()\n        self._progress_bar.grid(row=1, column=1, sticky=\"w\", padx=(padding, intpad), pady=padding)", "is_method": true, "class_name": "WorkDialog", "function_description": "This internal method positions the dialog's progress bar using a grid layout. It ensures correct visual placement and padding within the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "on_cancel", "line_number": 218, "body": "def on_cancel(self, event=None):\n        if self._state in (\"idle\", \"done\"):\n            self.close()\n        elif self._state == \"cancelling\" and self.confirm_leaving_while_cancelling():\n            self.close()\n        elif self.confirm_cancel():\n            self.cancel_work()", "is_method": true, "class_name": "WorkDialog", "function_description": "Handles user requests to cancel an operation or close the dialog. It either closes the dialog directly or initiates work cancellation, adapting behavior based on the dialog's current state and required user confirmation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "confirm_leaving_while_cancelling", "line_number": 226, "body": "def confirm_leaving_while_cancelling(self):\n        return messagebox.askyesno(\n            \"Close dialog?\",\n            \"Cancelling is in progress.\\nDo you still want to close the dialog?\",\n            parent=self,\n        )", "is_method": true, "class_name": "WorkDialog", "function_description": "Prompts the user to confirm closing the dialog when a cancellation operation is ongoing. This prevents accidental termination of the process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "confirm_cancel", "line_number": 233, "body": "def confirm_cancel(self):\n        return messagebox.askyesno(\n            \"Cancel work?\",\n            \"Are you sure you want to cancel?\",\n            parent=self,\n        )", "is_method": true, "class_name": "WorkDialog", "function_description": "This method displays a confirmation dialog asking the user if they are sure they want to cancel. It returns the user's \"Yes\" or \"No\" response, enabling user-validated cancellation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "append_text", "line_number": 240, "body": "def append_text(self, text: str, stream_name=\"stdout\") -> None:\n        \"\"\"Appends text to the details box. May be called from another thread.\"\"\"\n        self._work_events_queue.put((\"append\", (text, stream_name)))\n        setattr(self, stream_name, getattr(self, stream_name) + text)", "is_method": true, "class_name": "WorkDialog", "function_description": "Appends text to the dialog's details box, allowing thread-safe updates from various sources. It ensures visible log or status information is displayed correctly across threads."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "replace_last_line", "line_number": 245, "body": "def replace_last_line(self, text: str, stream_name=\"stdout\") -> None:\n        \"\"\"Replaces last line in the details box. May be called from another thread.\"\"\"\n        self._work_events_queue.put((\"replace\", (text, stream_name)))\n        setattr(self, stream_name, getattr(self, stream_name) + text)", "is_method": true, "class_name": "WorkDialog", "function_description": "Updates the last line of text displayed in the `WorkDialog`'s details box. It ensures thread-safe updates for dynamic UI output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "report_progress", "line_number": 250, "body": "def report_progress(self, value: float, maximum: float) -> None:\n        \"\"\"Updates progress bar. May be called from another thread.\"\"\"\n        self._work_events_queue.put((\"progress\", (value, maximum)))", "is_method": true, "class_name": "WorkDialog", "function_description": "Updates the WorkDialog's progress bar. It offers a thread-safe way to report current work status from background operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "set_action_text", "line_number": 254, "body": "def set_action_text(self, text: str) -> None:\n        \"\"\"Updates text above the progress bar. May be called from another thread.\"\"\"\n        self._work_events_queue.put((\"action\", (text,)))", "is_method": true, "class_name": "WorkDialog", "function_description": "Updates the action text displayed in the WorkDialog. It uses an internal queue to ensure thread-safe updates from any thread."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "set_action_text_smart", "line_number": 258, "body": "def set_action_text_smart(self, text: str) -> None:\n        \"\"\"Updates text above the progress bar. May be called from another thread.\"\"\"\n        text = text.strip()\n        if not text:\n            return\n        if len(text) > self.get_action_text_max_length():\n            text = text[: self.get_action_text_max_length() - 3] + \"...\"\n        self.set_action_text(text)", "is_method": true, "class_name": "WorkDialog", "function_description": "This method updates the text displayed above a progress bar, ensuring it is properly formatted. It automatically trims whitespace, handles empty input, and truncates overly long text for display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "report_done", "line_number": 267, "body": "def report_done(self, success):\n        \"\"\"May be called from another thread.\"\"\"\n        self._work_events_queue.put((\"done\", (success,)))", "is_method": true, "class_name": "WorkDialog", "function_description": "Signals that the work managed by the WorkDialog has completed, along with its success status. This event is put into an internal queue for asynchronous processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "handle_work_event", "line_number": 271, "body": "def handle_work_event(self, type, args):\n        if type in (\"append\", \"replace\"):\n            text, stream_name = args\n            if type == \"replace\":\n                self.log_text.text.direct_delete(\"end-1c linestart\", \"end-1c\")\n            self.log_text.text.direct_insert(\"end\", text, (stream_name,))\n            self.log_text.text.see(\"end\")\n        elif type == \"action\":\n            set_text_if_different(self._current_action_label, args[0])\n        elif type == \"progress\":\n            value, maximum = args\n            if value is None or maximum is None:\n                if self._progress_bar[\"mode\"] != \"indeterminate\":\n                    self._progress_bar[\"mode\"] = \"indeterminate\"\n                    self._progress_bar.start()\n            else:\n                if self._progress_bar[\"mode\"] != \"determinate\":\n                    self._progress_bar[\"mode\"] = \"determinate\"\n                    self._progress_bar.stop()\n                self._progress_bar.configure(value=value, maximum=maximum)\n        elif type == \"done\":\n            self.on_done(args[0])", "is_method": true, "class_name": "WorkDialog", "function_description": "This method processes various work-related events to update the dialog's user interface. It handles displaying log messages, current actions, and task progress, providing real-time feedback."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "on_done", "line_number": 294, "body": "def on_done(self, success):\n        \"\"\"NB! Don't call from non-ui thread!\"\"\"\n        self.success = success\n        if self.success:\n            self._state = \"done\"\n            self._cancel_button.focus_set()\n            self._cancel_button[\"default\"] = \"active\"\n            self._ok_button[\"default\"] = \"normal\"\n        elif self._autostart:\n            # Can't try again if failed with autostart\n            self._state = \"done\"\n            self._cancel_button.focus_set()\n            self._cancel_button[\"default\"] = \"active\"\n            self._ok_button[\"default\"] = \"normal\"\n        else:\n            # allows trying again when failed\n            self._state = \"idle\"\n            self._ok_button.focus_set()\n            self._ok_button[\"default\"] = \"active\"\n            self._cancel_button[\"default\"] = \"normal\"\n\n        self._progress_bar.stop()\n        # need to put to determinate mode, otherwise it looks half done\n        self._progress_bar[\"mode\"] = \"determinate\"\n        if self.success and self._autostart and not self.log_frame.winfo_ismapped():\n            self.close()\n\n        if not self.success and not self.log_frame.winfo_ismapped():\n            self.toggle_log_frame()", "is_method": true, "class_name": "WorkDialog", "function_description": "This method handles the completion of an operation, updating the dialog's UI elements like buttons and progress bar. It sets the dialog's state and determines subsequent actions based on task success."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "is_ready_for_work", "line_number": 341, "body": "def is_ready_for_work(self):\n        return True", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Indicates that the subprocess dialog is always ready to perform its work, signifying its constant availability for tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_title", "line_number": 344, "body": "def get_title(self):\n        return self._title", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Provides the title string of the `SubprocessDialog` instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_instructions", "line_number": 347, "body": "def get_instructions(self) -> Optional[str]:\n        return self._long_description", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Retrieves the detailed instructions or description associated with the dialog. This provides contextual information for display to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "start_work", "line_number": 350, "body": "def start_work(self):\n        if hasattr(self._proc, \"cmd\"):\n            try:\n                self.append_text(subprocess.list2cmdline(self._proc.cmd) + \"\\n\")\n            except:\n                logger.warning(\"Could not extract cmd (%s)\", self._proc.cmd)\n        self._start_listening_current_proc()", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Initiates the subprocess managed by the dialog by displaying its command and starting to listen for its output. This enables monitoring and interaction with the running process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "_start_listening_current_proc", "line_number": 358, "body": "def _start_listening_current_proc(self):\n        def listen_stream(stream_name):\n            stream = getattr(self._proc, stream_name)\n            while True:\n                data = stream.readline()\n                self.append_text(data, stream_name)\n                self._check_set_action_text_from_output_line(data)\n                setattr(self, stream_name, getattr(self, stream_name) + data)\n                if data == \"\":\n                    logger.debug(\"Finished reading %s\", stream_name)\n                    break\n\n            if stream_name == \"stdout\":\n                self._finish_process()\n\n            logger.debug(\"Returning from reading %s\", stream_name)\n\n        self._stdout_thread = threading.Thread(target=listen_stream, args=[\"stdout\"], daemon=True)\n        self._stdout_thread.start()\n        if self._proc.stderr is not None:\n            self._stderr_thread = threading.Thread(\n                target=listen_stream, args=[\"stderr\"], daemon=True\n            )\n            self._stderr_thread.start()", "is_method": true, "class_name": "SubprocessDialog", "function_description": "This method asynchronously monitors and captures real-time output from a running subprocess. It processes stdout and stderr for interactive display and internal state updates within the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "_finish_process", "line_number": 383, "body": "def _finish_process(self):\n        self.returncode = self._proc.wait()\n        logger.debug(\"Process ended with returncode %s\", self.returncode)\n        if self.returncode:\n            self.set_action_text(\"Error\")\n            self.append_text(\"Error: process returned with code %s\\n\" % self.returncode)\n        else:\n            self.set_action_text(\"Done!\")\n            self.append_text(\"Done!\")\n\n        self.report_done(self.returncode == 0)", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Finalizes subprocess execution, waiting for its completion. It updates the dialog's display with success or error messages and reports the final outcome.\nFinalizes subprocess execution, waiting for its completion. It updates the dialog's display with success or error messages and reports the final outcome."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "get_action_text_max_length", "line_number": 395, "body": "def get_action_text_max_length(self):\n        return 35", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Provides the fixed maximum character length allowed for action text within the dialog. This value likely configures UI display or input validation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "_check_set_action_text_from_output_line", "line_number": 398, "body": "def _check_set_action_text_from_output_line(self, line):\n        if len(line) > self.get_action_text_max_length():\n            line = line[: self.get_action_text_max_length() - 3].strip() + \"...\"\n        if line:\n            self.set_action_text(line.strip())", "is_method": true, "class_name": "SubprocessDialog", "function_description": "This method updates the dialog's displayed 'action text' based on a single output line. It ensures the text fits by truncating long lines before setting it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "cancel_work", "line_number": 404, "body": "def cancel_work(self):\n        super().cancel_work()\n        # try gently first\n        try:\n            try:\n                if running_on_windows():\n                    os.kill(self._proc.pid, signal.CTRL_BREAK_EVENT)  # pylint: disable=no-member\n                else:\n                    os.kill(self._proc.pid, signal.SIGINT)\n\n                self._proc.wait(2)\n            except subprocess.TimeoutExpired:\n                if self._proc.poll() is None:\n                    # now let's be more concrete\n                    self._proc.kill()\n        except OSError as e:\n            messagebox.showerror(\"Error\", \"Could not kill subprocess: \" + str(e), master=self)\n            logger.error(\"Could not kill subprocess\", exc_info=e)", "is_method": true, "class_name": "SubprocessDialog", "function_description": "This method terminates the managed subprocess. It first attempts a graceful shutdown, escalating to a forceful kill if the process does not respond, thereby cancelling its ongoing work."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/workdlg.py", "function": "listen_stream", "line_number": 359, "body": "def listen_stream(stream_name):\n            stream = getattr(self._proc, stream_name)\n            while True:\n                data = stream.readline()\n                self.append_text(data, stream_name)\n                self._check_set_action_text_from_output_line(data)\n                setattr(self, stream_name, getattr(self, stream_name) + data)\n                if data == \"\":\n                    logger.debug(\"Finished reading %s\", stream_name)\n                    break\n\n            if stream_name == \"stdout\":\n                self._finish_process()\n\n            logger.debug(\"Returning from reading %s\", stream_name)", "is_method": true, "class_name": "SubprocessDialog", "function_description": "Continuously reads and processes output from a specified subprocess stream (stdout or stderr). It updates the dialog display, stores the output, and performs actions based on stream content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "range_contains_smaller", "line_number": 122, "body": "def range_contains_smaller(one: TextRange, other: TextRange) -> bool:\n    this_start = (one.lineno, one.col_offset)\n    this_end = (one.end_lineno, one.end_col_offset)\n    other_start = (other.lineno, other.col_offset)\n    other_end = (other.end_lineno, other.end_col_offset)\n\n    return (\n        this_start < other_start\n        and this_end > other_end\n        or this_start == other_start\n        and this_end > other_end\n        or this_start < other_start\n        and this_end == other_end\n    )", "is_method": false, "function_description": "Determines if a given text range completely encloses another text range that is strictly smaller. Useful for identifying hierarchical relationships between code elements like nested AST nodes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "range_contains_smaller_or_equal", "line_number": 138, "body": "def range_contains_smaller_or_equal(one: TextRange, other: TextRange) -> bool:\n    return range_contains_smaller(one, other) or one == other", "is_method": false, "function_description": "Checks if the first text range is entirely contained within or is identical to the second text range. This provides a utility for comparing text segment boundaries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "serialize_message", "line_number": 217, "body": "def serialize_message(msg: Record) -> str:\n    # I want to transfer only ASCII chars because encodings are not reliable\n    # (eg. can't find a way to specify PYTHONIOENCODING for cx_freeze'd program)\n    return MESSAGE_MARKER + ascii(msg)", "is_method": false, "function_description": "Converts a `Record` object into an ASCII-safe string representation by applying `ascii()` and adding a marker, suitable for reliable data transfer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "parse_message", "line_number": 223, "body": "def parse_message(msg_string: str) -> Record:\n    # DataFrames may have nan\n    # pylint: disable=unused-variable\n    nan = float(\"nan\")  # @UnusedVariable\n    assert msg_string[0] == MESSAGE_MARKER\n    return eval(msg_string[1:])", "is_method": false, "function_description": "Decodes a marked message string by evaluating its content as Python code to reconstruct a Record object. This function serves to deserialize messages from a specific format."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "normpath_with_actual_case", "line_number": 231, "body": "def normpath_with_actual_case(name: str) -> str:\n    \"\"\"In Windows return the path with the case it is stored in the filesystem\"\"\"\n    if not os.path.exists(name):\n        return os.path.normpath(name)\n\n    assert os.path.isabs(name) or os.path.ismount(name), \"Not abs nor mount: \" + name\n    assert os.path.exists(name), \"Not exists: \" + name\n\n    if os.name == \"nt\":\n        # https://stackoverflow.com/questions/2113822/python-getting-filename-case-as-stored-in-windows/2114975\n        name = os.path.normpath(name)\n\n        from ctypes import create_unicode_buffer, windll\n\n        buf = create_unicode_buffer(512)\n        # GetLongPathNameW alone doesn't fix filename part\n        windll.kernel32.GetShortPathNameW(name, buf, 512)  # @UndefinedVariable\n        windll.kernel32.GetLongPathNameW(buf.value, buf, 512)  # @UndefinedVariable\n        result = buf.value\n\n        if result.casefold() != name.casefold():\n            # Sometimes GetShortPathNameW + GetLongPathNameW doesn't work\n            # see eg. https://github.com/thonny/thonny/issues/925\n            windll.kernel32.GetLongPathNameW(name, buf, 512)  # @UndefinedVariable\n            result = buf.value\n\n            if result.casefold() != name.casefold():\n                result = name\n\n        if result[1] == \":\":\n            # ensure drive letter is capital\n            return result[0].upper() + result[1:]\n        else:\n            return result\n    else:\n        # easy on Linux\n        # too difficult on mac\n        # https://stackoverflow.com/questions/14515073/in-python-on-osx-with-hfs-how-can-i-get-the-correct-case-of-an-existing-filenam\n        # Hopefully only correct case comes into Thonny (eg. via open dialog)\n        return os.path.normpath(name)", "is_method": false, "function_description": "Normalizes a file path and returns its actual case as stored on the filesystem. This is particularly useful for Windows where the casing might differ from the input."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "is_same_path", "line_number": 273, "body": "def is_same_path(name1: str, name2: str) -> bool:\n    return os.path.normpath(os.path.normcase(name1)) == os.path.normpath(os.path.normcase(name2))", "is_method": false, "function_description": "Checks if two file paths refer to the same location on the file system, ignoring case and platform-specific path formatting differences."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "path_startswith", "line_number": 277, "body": "def path_startswith(child_name: str, dir_name: str) -> bool:\n    normchild = os.path.normpath(os.path.normcase(child_name))\n    normdir = os.path.normpath(os.path.normcase(dir_name))\n    return normdir == normchild or normchild.startswith(normdir.rstrip(os.path.sep) + os.path.sep)", "is_method": false, "function_description": "Determines if a given path is a subpath of, or identical to, a specified directory path. It uses platform-aware normalization for robust comparison."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "read_source", "line_number": 283, "body": "def read_source(filename):\n    import tokenize\n\n    with tokenize.open(filename) as fp:\n        return fp.read()", "is_method": false, "function_description": "Reads the entire content of a specified file, handling character encoding robustly. It is primarily used for safely accessing source code for parsing or analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_exe_dirs", "line_number": 290, "body": "def get_exe_dirs():\n    result = []\n    if site.ENABLE_USER_SITE:\n        if platform.system() == \"Windows\":\n            if site.getusersitepackages():\n                result.append(site.getusersitepackages().replace(\"site-packages\", \"Scripts\"))\n        else:\n            if site.getuserbase():\n                result.append(site.getuserbase() + \"/bin\")\n\n    main_scripts = os.path.join(sys.prefix, \"Scripts\")\n    if os.path.isdir(main_scripts) and main_scripts not in result:\n        result.append(main_scripts)\n\n    if os.path.dirname(sys.executable) not in result:\n        result.append(os.path.dirname(sys.executable))\n\n    # These entries are used by Anaconda\n    for part in [\n        \"Library/mingw-w64/bin\",\n        \"Library/usr/bin\",\n        \"Library/bin\",\n        \"Scripts\",\n        \"bin\",\n        \"condabin\",\n    ]:\n        dirpath = os.path.join(sys.prefix, part.replace(\"/\", os.sep))\n        if os.path.isdir(dirpath) and dirpath not in result:\n            result.append(dirpath)\n\n    if platform.system() != \"Windows\" and \"/usr/local/bin\" not in result:\n        # May be missing on macOS, when started as bundle\n        # (yes, more may be missing, but this one is most useful)\n        result.append(\"/usr/local/bin\")\n\n    return result", "is_method": false, "function_description": "Constructs a comprehensive list of directories where executable files and Python scripts are typically located, including standard installation and user-specific paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_site_dir", "line_number": 328, "body": "def get_site_dir(symbolic_name, executable=None):\n    if not executable or executable == sys.executable:\n        result = getattr(site, symbolic_name, \"\")\n    else:\n        result = (\n            subprocess.check_output(\n                [executable, \"-m\", \"site\", \"--\" + symbolic_name.lower().replace(\"_\", \"-\")],\n                universal_newlines=True,\n            )\n            .decode()\n            .strip()\n        )\n\n    return result if result else None", "is_method": false, "function_description": "Retrieves a specific directory path (e.g., user base, user site) from the Python `site` module. It can query either the current interpreter or a specified Python executable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_base_executable", "line_number": 344, "body": "def get_base_executable():\n    if sys.exec_prefix == sys.base_exec_prefix:\n        return sys.executable\n\n    if platform.system() == \"Windows\":\n        result = sys.base_exec_prefix + \"\\\\\" + os.path.basename(sys.executable)\n        result = normpath_with_actual_case(result)\n    else:\n        result = sys.executable.replace(sys.exec_prefix, sys.base_exec_prefix)\n\n    if not os.path.isfile(result):\n        raise RuntimeError(\"Can't locate base executable\")\n\n    return result", "is_method": false, "function_description": "Provides the file path to the base Python interpreter executable. Useful for operations that need to interact with the original Python installation outside a virtual environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_augmented_system_path", "line_number": 360, "body": "def get_augmented_system_path(extra_dirs):\n    path_items = os.environ.get(\"PATH\", \"\").split(os.pathsep)\n\n    for d in reversed(extra_dirs):\n        if d not in path_items:\n            path_items.insert(0, d)\n\n    return os.pathsep.join(path_items)", "is_method": false, "function_description": "Augments the system's PATH environment variable by prepending specified directories, ensuring they are searched first for executables. It avoids adding duplicate entries to the path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "update_system_path", "line_number": 370, "body": "def update_system_path(env, value):\n    # in Windows, env keys are not case sensitive\n    # this is important if env is a dict (not os.environ)\n    if platform.system() == \"Windows\":\n        found = False\n        for key in env:\n            if key.upper() == \"PATH\":\n                found = True\n                env[key] = value\n\n        if not found:\n            env[\"PATH\"] = value\n    else:\n        env[\"PATH\"] = value", "is_method": false, "function_description": "Updates the 'PATH' environment variable within a given environment mapping. It correctly handles Windows' case-insensitivity for the 'PATH' key, ensuring the variable is reliably set."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "is_hidden_or_system_file", "line_number": 392, "body": "def is_hidden_or_system_file(path: str) -> bool:\n    if os.path.basename(path).startswith(\".\"):\n        return True\n    elif platform.system() == \"Windows\":\n        from ctypes import windll\n\n        FILE_ATTRIBUTE_HIDDEN = 0x2\n        FILE_ATTRIBUTE_SYSTEM = 0x4\n        return bool(\n            windll.kernel32.GetFileAttributesW(path)  # @UndefinedVariable\n            & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)\n        )\n    else:\n        return False", "is_method": false, "function_description": "Checks if a given file path refers to a hidden or system file. It handles both Unix-like dot files and Windows-specific file attributes for this determination."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_dirs_children_info", "line_number": 408, "body": "def get_dirs_children_info(\n    paths: List[str], include_hidden: bool = False\n) -> Dict[str, Optional[Dict[str, Dict]]]:\n    return {path: get_single_dir_child_data(path, include_hidden) for path in paths}", "is_method": false, "function_description": "Retrieves information about the immediate children (files and subdirectories) for a list of specified paths. Useful for building file system exploration or listing tools."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_single_dir_child_data", "line_number": 414, "body": "def get_single_dir_child_data(path: str, include_hidden: bool = False) -> Optional[Dict[str, Dict]]:\n    if path == \"\":\n        if platform.system() == \"Windows\":\n            return {**get_windows_volumes_info(), **get_windows_network_locations()}\n        else:\n            return get_single_dir_child_data(\"/\", include_hidden)\n\n    elif os.path.isdir(path) or os.path.ismount(path):\n        result = {}\n\n        try:\n            for child in os.listdir(path):\n                full_child_path = os.path.join(path, child)\n                if not os.path.exists(full_child_path):\n                    # must be broken link\n                    continue\n                full_child_path = normpath_with_actual_case(full_child_path)\n                hidden = is_hidden_or_system_file(full_child_path)\n                if not hidden or include_hidden:\n                    name = os.path.basename(full_child_path)\n                    st = os.stat(full_child_path, dir_fd=None, follow_symlinks=True)\n                    result[name] = {\n                        \"size\": None if os.path.isdir(full_child_path) else st.st_size,\n                        \"modified\": st.st_mtime,\n                        \"hidden\": hidden,\n                    }\n        except PermissionError:\n            result[\"<not accessible>\"] = {\n                \"kind\": \"error\",\n                \"size\": -1,\n                \"modified\": None,\n                \"hidden\": None,\n            }\n\n        return result\n    else:\n        return None", "is_method": false, "function_description": "Retrieves metadata (size, modification time, hidden status) for the direct children of a given directory. It can optionally include hidden items and handles system root paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_windows_volumes_info", "line_number": 453, "body": "def get_windows_volumes_info():\n    # http://stackoverflow.com/a/2288225/261181\n    # http://msdn.microsoft.com/en-us/library/windows/desktop/aa364939%28v=vs.85%29.aspx\n    import string\n    from ctypes import windll\n\n    all_drive_types = [\n        \"DRIVE_UNKNOWN\",\n        \"DRIVE_NO_ROOT_DIR\",\n        \"DRIVE_REMOVABLE\",\n        \"DRIVE_FIXED\",\n        \"DRIVE_REMOTE\",\n        \"DRIVE_CDROM\",\n        \"DRIVE_RAMDISK\",\n    ]\n\n    required_drive_types = [\"DRIVE_REMOVABLE\", \"DRIVE_FIXED\", \"DRIVE_REMOTE\", \"DRIVE_RAMDISK\"]\n\n    result = {}\n\n    bitmask = windll.kernel32.GetLogicalDrives()  # @UndefinedVariable\n    for letter in string.ascii_uppercase:\n        if not bitmask & 1:\n            pass\n        else:\n            drive_type = all_drive_types[\n                windll.kernel32.GetDriveTypeW(\"%s:\\\\\" % letter)\n            ]  # @UndefinedVariable\n\n            # NB! Drive A can be present in bitmask but actually missing.\n            # In this case querying information about it would freeze the UI\n            # for several seconds.\n            # One solution is to uninstall the device in device manager,\n            # but OS may restore the drive later.\n            # Therefore it is safest to skip A drive (user can access it via Open dialog)\n\n            if drive_type in required_drive_types and (\n                letter != \"A\" or drive_type != \"DRIVE_REMOVABLE\"\n            ):\n                drive = letter + \":\"\n                path = drive + \"\\\\\"\n\n                try:\n                    st = os.stat(path)\n                    volume_name = get_windows_volume_name(path)\n                    if not volume_name:\n                        volume_name = \"Disk\"\n\n                    label = volume_name + \" (\" + drive + \")\"\n                    result[path] = {\n                        \"label\": label,\n                        \"size\": None,\n                        \"modified\": max(st.st_mtime, st.st_ctime),\n                    }\n                except OSError as e:\n                    logger.warning(\"Could not get information for %s\", path, exc_info=e)\n\n        bitmask >>= 1\n\n    return result", "is_method": false, "function_description": "Retrieves details for all accessible Windows disk volumes, including their labels and last modification times. Useful for enumerating available storage drives and their basic properties."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_windows_volume_name", "line_number": 515, "body": "def get_windows_volume_name(path):\n    # https://stackoverflow.com/a/12056414/261181\n    import ctypes\n\n    kernel32 = ctypes.windll.kernel32\n    volume_name_buffer = ctypes.create_unicode_buffer(1024)\n    file_system_name_buffer = ctypes.create_unicode_buffer(1024)\n    serial_number = None\n    max_component_length = None\n    file_system_flags = None\n\n    result = kernel32.GetVolumeInformationW(\n        ctypes.c_wchar_p(path),\n        volume_name_buffer,\n        ctypes.sizeof(volume_name_buffer),\n        serial_number,\n        max_component_length,\n        file_system_flags,\n        file_system_name_buffer,\n        ctypes.sizeof(file_system_name_buffer),\n    )\n\n    if result:\n        return volume_name_buffer.value\n    else:\n        return None", "is_method": false, "function_description": "Obtains the user-defined name of the Windows volume (drive) that a given file path resides on. Useful for identifying disk labels."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_windows_network_locations", "line_number": 543, "body": "def get_windows_network_locations():\n    import ctypes.wintypes\n\n    CSIDL_NETHOOD = 0x13\n    SHGFP_TYPE_CURRENT = 0\n    buf = ctypes.create_unicode_buffer(ctypes.wintypes.MAX_PATH)\n    ctypes.windll.shell32.SHGetFolderPathW(0, CSIDL_NETHOOD, 0, SHGFP_TYPE_CURRENT, buf)\n    shortcuts_dir = buf.value\n\n    result = {}\n    for entry in os.scandir(shortcuts_dir):\n        # full_path = normpath_with_actual_case(entry.path)\n        lnk_path = os.path.join(entry.path, \"target.lnk\")\n        if os.path.exists(lnk_path):\n            try:\n                target = get_windows_lnk_target(lnk_path)\n                result[target] = {\n                    \"label\": entry.name + \" (\" + target + \")\",\n                    \"size\": None,\n                    \"modified\": None,\n                }\n            except Exception:\n                logger.error(\"Can't get target from %s\", lnk_path, exc_info=True)\n\n    return result", "is_method": false, "function_description": "This function identifies and lists network locations configured on a Windows system. It parses shortcuts to network targets, providing a dictionary of accessible network paths and their labels."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_windows_lnk_target", "line_number": 570, "body": "def get_windows_lnk_target(lnk_file_path):\n    import thonny\n\n    script_path = os.path.join(os.path.dirname(thonny.__file__), \"res\", \"PrintLnkTarget.vbs\")\n    cmd = [\"cscript\", \"/NoLogo\", script_path, lnk_file_path]\n    result = subprocess.check_output(cmd, universal_newlines=True, timeout=3)\n\n    return result.strip()", "is_method": false, "function_description": "Retrieves the target path embedded within a Windows shortcut (.lnk) file. This enables Python applications to programmatically resolve the destination of Windows links."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "execute_system_command", "line_number": 580, "body": "def execute_system_command(cmd, cwd=None, disconnect_stdin=False):\n    logger.debug(\"execute_system_command, cmd=%r, cwd=%s\", cmd, cwd)\n    env = dict(os.environ).copy()\n    encoding = \"utf-8\"\n    env[\"PYTHONIOENCODING\"] = encoding\n    # Make sure this python interpreter and its scripts are available\n    # in PATH\n    update_system_path(env, get_augmented_system_path(get_exe_dirs()))\n    popen_kw = dict(\n        env=env,\n        universal_newlines=True,\n        bufsize=0,\n    )\n\n    if cwd and os.path.isdir(cwd):\n        popen_kw[\"cwd\"] = cwd\n\n    if disconnect_stdin:\n        popen_kw[\"stdin\"] = subprocess.DEVNULL\n\n    if sys.version_info >= (3, 6):\n        popen_kw[\"errors\"] = \"replace\"\n        popen_kw[\"encoding\"] = encoding\n\n    if isinstance(cmd.cmd_line, str) and cmd.cmd_line.startswith(\"!\"):\n        cmd_line = cmd.cmd_line[1:]\n        popen_kw[\"shell\"] = True\n    else:\n        assert isinstance(cmd.cmd_line, list)\n        cmd_line = cmd.cmd_line\n    logger.debug(\"Popen(%r, ...)\", cmd_line)\n    proc = subprocess.Popen(cmd_line, **popen_kw)\n    proc.communicate()\n    return proc.wait()", "is_method": false, "function_description": "Executes an external system command with specified working directory and input/output settings. It handles environment setup and returns the command's exit status, providing a robust way to run shell or executable commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "universal_dirname", "line_number": 616, "body": "def universal_dirname(path: str) -> str:\n    if \"/\" in path:\n        sep = \"/\"\n    elif \"\\\\\" in path:\n        sep = \"\\\\\"\n    else:\n        # micro:bit\n        return \"\"\n\n    path = path.rstrip(sep)\n    result = path[: path.rindex(sep)]\n    if not result:\n        return sep\n    else:\n        return result", "is_method": false, "function_description": "Provides a cross-platform way to extract the parent directory from a file path string. It handles both Unix-like forward slashes and Windows-like backslashes as separators."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "universal_relpath", "line_number": 633, "body": "def universal_relpath(path: str, context: str) -> str:\n    \"\"\"Tries to give relative path\"\"\"\n    if \"/\" in path:\n        import pathlib\n\n        p = pathlib.PurePosixPath(path)\n        try:\n            return str(p.relative_to(context))\n        except ValueError:\n            return path\n    else:\n        return os.path.relpath(path, context)", "is_method": false, "function_description": "Calculates a relative path for a given path with respect to a context, supporting both POSIX and native OS path formats. It returns the original path if a relative path cannot be formed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get_python_version_string", "line_number": 647, "body": "def get_python_version_string(version_info: Optional[Tuple] = None, maxsize=None):\n    result = \".\".join(map(str, sys.version_info[:3]))\n    if sys.version_info[3] != \"final\":\n        result += \"-\" + sys.version_info[3]\n\n    if maxsize is not None:\n        result += \" (\" + (\"64\" if sys.maxsize > 2 ** 32 else \"32\") + \" bit)\"\n\n    return result", "is_method": false, "function_description": "This function generates a formatted string representing the current Python interpreter's version. It includes major, minor, and micro versions, release level, and optionally the system's bitness for comprehensive identification."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "try_load_modules_with_frontend_sys_path", "line_number": 658, "body": "def try_load_modules_with_frontend_sys_path(module_names):\n    try:\n        frontend_sys_path = ast.literal_eval(os.environ[\"THONNY_FRONTEND_SYS_PATH\"])\n        assert isinstance(frontend_sys_path, list)\n    except Exception as e:\n        logger.warning(\"Could not get THONNY_FRONTEND_SYS_PATH\", exc_info=e)\n        return\n\n    from importlib import import_module\n\n    old_sys_path = sys.path.copy()\n    sys.path = sys.path + frontend_sys_path\n    try:\n        for name in module_names:\n            try:\n                import_module(name)\n            except ImportError:\n                pass\n    finally:\n        sys.path = old_sys_path", "is_method": false, "function_description": "This function attempts to load specified Python modules. It temporarily extends `sys.path` with a frontend-defined path, enabling imports from non-standard locations relevant to the frontend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "update", "line_number": 61, "body": "def update(self, e, **kw):\n        self.__dict__.update(e, **kw)", "is_method": true, "class_name": "Record", "function_description": "This method updates the Record instance's attributes by merging key-value pairs from a given mapping or object. It efficiently incorporates new or changed properties into the record's internal state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "setdefault", "line_number": 64, "body": "def setdefault(self, **kw):\n        \"updates those fields that are not yet present (similar to dict.setdefault)\"\n        for key in kw:\n            if not hasattr(self, key):\n                setattr(self, key, kw[key])", "is_method": true, "class_name": "Record", "function_description": "Initializes attributes on the `Record` instance only if they are not yet present. This prevents overwriting existing fields."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "get", "line_number": 70, "body": "def get(self, key, default=None):\n        return self.__dict__.get(key, default)", "is_method": true, "class_name": "Record", "function_description": "Retrieves an attribute's value from the record by key. Returns a default value if the key is not found, providing safe data access."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__getitem__", "line_number": 73, "body": "def __getitem__(self, key):\n        return self.__dict__[key]", "is_method": true, "class_name": "Record", "function_description": "Enables dictionary-style access to the Record object's attributes, allowing retrieval of values using a key. This provides a convenient way to access data stored within the record."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__delitem__", "line_number": 76, "body": "def __delitem__(self, key):\n        self.__dict__.__delitem__(key)", "is_method": true, "class_name": "Record", "function_description": "Allows deleting an attribute from a Record instance by its key. This provides the capability to dynamically remove object properties using dictionary-like item deletion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__setitem__", "line_number": 79, "body": "def __setitem__(self, key, value):\n        self.__dict__[key] = value", "is_method": true, "class_name": "Record", "function_description": "This method allows setting values on a Record instance using dictionary-like key assignment. It enables dynamic storage and updates of data fields for Record objects."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__contains__", "line_number": 82, "body": "def __contains__(self, key):\n        return key in self.__dict__", "is_method": true, "class_name": "Record", "function_description": "Enables the `in` operator for `Record` objects, allowing users to efficiently check if a given key (attribute) is present within the record's data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__repr__", "line_number": 85, "body": "def __repr__(self):\n        keys = self.__dict__.keys()\n        items = (\"{}={}\".format(k, repr(self.__dict__[k])) for k in keys)\n        return \"{}({})\".format(self.__class__.__name__, \", \".join(items))", "is_method": true, "class_name": "Record", "function_description": "Generates an unambiguous string representation of the Record object's internal state, showing its class name and attributes. This is crucial for debugging, logging, and developer inspection of instances."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__str__", "line_number": 90, "body": "def __str__(self):\n        keys = sorted(self.__dict__.keys())\n        items = (\"{}={}\".format(k, repr(self.__dict__[k])) for k in keys)\n        return \"{}({})\".format(self.__class__.__name__, \", \".join(items))", "is_method": true, "class_name": "Record", "function_description": "Provides a human-readable string representation of a Record object. It lists all the object's attributes and their values in a sorted format, useful for debugging or logging.\nProvides a human-readable string representation of a Record object. It lists all the object's attributes and their values in a sorted format, useful for debugging or logging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__eq__", "line_number": 95, "body": "def __eq__(self, other):\n        # pylint: disable=unidiomatic-typecheck\n\n        if type(self) != type(other):\n            return False\n\n        if len(self.__dict__) != len(other.__dict__):\n            return False\n\n        for key in self.__dict__:\n            if not hasattr(other, key):\n                return False\n            self_value = getattr(self, key)\n            other_value = getattr(other, key)\n\n            if type(self_value) != type(other_value) or self_value != other_value:\n                return False\n\n        return True", "is_method": true, "class_name": "Record", "function_description": "Defines equality for `Record` objects by comparing their types and ensuring all attribute values and types are identical. This allows for reliable comparison of record instances."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__ne__", "line_number": 115, "body": "def __ne__(self, other):\n        return not self.__eq__(other)", "is_method": true, "class_name": "Record", "function_description": "Defines the 'not equal to' comparison for Record objects by negating the result of the equality comparison."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/common.py", "function": "__hash__", "line_number": 118, "body": "def __hash__(self):\n        return hash(repr(self))", "is_method": true, "class_name": "Record", "function_description": "This method makes `Record` objects hashable, allowing them to be used as dictionary keys or elements in sets. It provides a unique hash value for object identification."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_longest_common_path_prefix", "line_number": 628, "body": "def _longest_common_path_prefix(str_paths, path_class):\n    assert str_paths\n\n    if len(str_paths) == 1:\n        return str_paths[0]\n\n    list_of_parts = []\n    for str_path in str_paths:\n        list_of_parts.append(path_class(str_path).parts)\n\n    first = list_of_parts[0]\n    rest = list_of_parts[1:]\n\n    i = 0\n    while i < len(first):\n        item_i = first[i]\n        if not all([len(x) > i and x[i] == item_i for x in rest]):\n            break\n        else:\n            i += 1\n\n    if i == 0:\n        return \"\"\n\n    result = path_class(first[0])\n    for j in range(1, i):\n        result = result.joinpath(first[j])\n\n    return str(result)", "is_method": false, "function_description": "This function determines the longest common path prefix shared by a list of given file or directory paths. It identifies the deepest common parent directory for a collection of paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "ensure_posix_directory", "line_number": 659, "body": "def ensure_posix_directory(\n    path: str, stat_mode_fun: Callable[[str], Optional[int]], mkdir_fun: Callable[[str], None]\n) -> None:\n    assert path.startswith(\"/\")\n    if path == \"/\":\n        return\n\n    for step in list(reversed(list(map(str, pathlib.PurePosixPath(path).parents)))) + [path]:\n\n        if step != \"/\":\n            mode = stat_mode_fun(step)\n            if mode is None:\n                mkdir_fun(step)\n            elif not stat.S_ISDIR(mode):\n                raise AssertionError(\"'%s' is file, not a directory\" % step)", "is_method": false, "function_description": "Ensures a specified POSIX directory path exists by creating any missing parent directories. It verifies that existing path segments are directories, raising an error if a file is encountered."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "interrupt_local_process", "line_number": 676, "body": "def interrupt_local_process() -> None:\n    \"\"\"Meant to be executed from a background thread\"\"\"\n    import signal\n\n    if hasattr(signal, \"raise_signal\"):\n        # Python 3.8 and later\n        signal.raise_signal(signal.SIGINT)\n    elif sys.platform == \"win32\":\n        # https://stackoverflow.com/a/51122690/261181\n        import ctypes\n\n        ucrtbase = ctypes.CDLL(\"ucrtbase\")\n        c_raise = ucrtbase[\"raise\"]\n        c_raise(signal.SIGINT)\n    else:\n        # Does not give KeyboardInterrupt in Windows\n        os.kill(os.getpid(), signal.SIGINT)", "is_method": false, "function_description": "This function programmatically sends an interrupt signal to the current Python process. It enables a background thread to trigger a `KeyboardInterrupt` for graceful termination."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "get_ssh_password_file_path", "line_number": 695, "body": "def get_ssh_password_file_path():\n    from thonny import THONNY_USER_DIR\n\n    return os.path.join(THONNY_USER_DIR, \"ssh_password\")", "is_method": false, "function_description": "Provides the default file path for the SSH password file located within the Thonny user directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "delete_stored_ssh_password", "line_number": 701, "body": "def delete_stored_ssh_password():\n    if os.path.exists(get_ssh_password_file_path()):\n        # invalidate stored password\n        os.remove(get_ssh_password_file_path())", "is_method": false, "function_description": "Deletes the locally stored SSH password file, invalidating any cached credentials."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_init_command_reader", "line_number": 52, "body": "def _init_command_reader(self):\n        # Don't use threading for creating a management thread, because I don't want them\n        # to be affected by threading.settrace\n        _thread.start_new_thread(self._read_incoming_messages, ())", "is_method": true, "class_name": "BaseBackend", "function_description": "Starts a new background thread to continuously read incoming messages for the backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "mainloop", "line_number": 57, "body": "def mainloop(self):\n        try:\n            while self._should_keep_going():\n                try:\n                    try:\n                        msg = self._fetch_next_incoming_message(timeout=0.01)\n                    except queue.Empty:\n                        self._perform_idle_tasks()\n                    else:\n                        if isinstance(msg, InputSubmission):\n                            self._handle_user_input(msg)\n                        elif isinstance(msg, EOFCommand):\n                            self._handle_eof_command(msg)\n                        else:\n                            self._current_command = msg\n                            self._handle_normal_command(msg)\n                except KeyboardInterrupt:\n                    self._send_output(\"KeyboardInterrupt\", \"stderr\")  # CPython idle REPL does this\n                    self.send_message(ToplevelResponse())\n        except ConnectionClosedException:\n            sys.exit(0)", "is_method": true, "class_name": "BaseBackend", "function_description": "This method serves as the backend's core execution loop. It continuously processes incoming messages (user input, commands), dispatches them to handlers, and manages the backend's ongoing operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_current_command_is_interrupted", "line_number": 79, "body": "def _current_command_is_interrupted(self):\n        return getattr(self._current_command, \"interrupted\", False)", "is_method": true, "class_name": "BaseBackend", "function_description": "Determines if the currently executing command within the backend has been marked as interrupted."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_fetch_next_incoming_message", "line_number": 82, "body": "def _fetch_next_incoming_message(self, timeout=None):\n        return self._incoming_message_queue.get(timeout=timeout)", "is_method": true, "class_name": "BaseBackend", "function_description": "Retrieves the next incoming message from the internal queue. This core utility provides a blocking or timed-out way for the backend to consume messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_report_progress", "line_number": 85, "body": "def _report_progress(\n        self, cmd, description: Optional[str], value: float, maximum: float\n    ) -> None:\n        # Don't notify too often (unless it's the final notification)\n        if value != maximum and time.time() - self._last_progress_reporting_time < 0.2:\n            return\n\n        self.send_message(\n            BackendEvent(\n                event_type=\"InlineProgress\",\n                command_id=cmd[\"id\"],\n                value=value,\n                maximum=maximum,\n                description=description,\n            )\n        )\n        self._last_progress_reporting_time = time.time()", "is_method": true, "class_name": "BaseBackend", "function_description": "Reports rate-limited progress updates for an ongoing command. This internal method sends backend events to inform a connected client about the operation's advancement."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_report_current_action", "line_number": 103, "body": "def _report_current_action(self, cmd, description: str) -> None:\n        self.send_message(\n            BackendEvent(\n                event_type=\"InlineProgress\",\n                command_id=cmd[\"id\"],\n                description=description,\n            )\n        )", "is_method": true, "class_name": "BaseBackend", "function_description": "Reports the backend's current action or progress to clients by sending an \"InlineProgress\" event. This provides real-time status updates for ongoing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_read_incoming_messages", "line_number": 112, "body": "def _read_incoming_messages(self):\n        # works in a separate thread\n        while self._should_keep_going():\n            if not self._read_one_incoming_message():\n                break", "is_method": true, "class_name": "BaseBackend", "function_description": "This method enables the BaseBackend to continuously receive and process incoming messages. It operates asynchronously in a dedicated background thread."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_read_one_incoming_message", "line_number": 118, "body": "def _read_one_incoming_message(self):\n        line = self._read_incoming_msg_line()\n        if line == \"\":\n            return False\n        msg = parse_message(line)\n        if isinstance(msg, ImmediateCommand):\n            # This will be handled right away\n            self._handle_immediate_command(msg)\n        else:\n            self._incoming_message_queue.put(msg)\n        return True", "is_method": true, "class_name": "BaseBackend", "function_description": "Reads and processes a single incoming message for the backend. It immediately handles commands or queues other messages for later processing, ensuring continuous communication flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_prepare_command_response", "line_number": 130, "body": "def _prepare_command_response(\n        self, response: Union[MessageFromBackend, Dict, None], command: CommandToBackend\n    ) -> MessageFromBackend:\n        if response is None:\n            response = {}\n\n        if \"id\" in command and \"command_id\" not in response:\n            response[\"command_id\"] = command[\"id\"]\n\n        if isinstance(response, MessageFromBackend):\n            if \"command_name\" not in response:\n                response[\"command_name\"] = command[\"name\"]\n            return response\n        else:\n            if isinstance(response, dict):\n                args = response\n            else:\n                args = {}\n\n            if isinstance(command, ToplevelCommand):\n                return ToplevelResponse(command_name=command.name, **args)\n            else:\n                assert isinstance(command, InlineCommand)\n                return InlineResponse(command_name=command.name, **args)", "is_method": true, "class_name": "BaseBackend", "function_description": "This internal method of BaseBackend standardizes and formats a backend's raw response, ensuring it conforms to the `MessageFromBackend` type and includes command details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "send_message", "line_number": 155, "body": "def send_message(self, msg: MessageFromBackend) -> None:\n        sys.stdout.write(serialize_message(msg) + \"\\n\")\n        sys.stdout.flush()", "is_method": true, "class_name": "BaseBackend", "function_description": "This method sends a serialized message from the backend to standard output. It provides a way for the backend to communicate information to external consumers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_send_output", "line_number": 159, "body": "def _send_output(self, data, stream_name):\n        if not data:\n            return\n\n        data = self._transform_output(data, stream_name)\n        msg = BackendEvent(event_type=\"ProgramOutput\", stream_name=stream_name, data=data)\n        self.send_message(msg)", "is_method": true, "class_name": "BaseBackend", "function_description": "This method transmits transformed program output to a designated stream. It encapsulates the data into a structured backend event for consistent delivery to the connected system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_read_incoming_msg_line", "line_number": 170, "body": "def _read_incoming_msg_line(self) -> str:\n        return sys.stdin.readline()", "is_method": true, "class_name": "BaseBackend", "function_description": "Provides a core capability for the backend to read a single line of text from the standard input stream, typically for processing incoming messages or commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_report_internal_exception", "line_number": 177, "body": "def _report_internal_exception(self, exception=None):\n        logger.exception(\"PROBLEM WITH THONNY'S BACK-END\", exc_info=exception)", "is_method": true, "class_name": "BaseBackend", "function_description": "This method logs internal exceptions originating from the Thonny backend. It provides a standardized way to report critical problems for diagnostic and debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_report_internal_error", "line_number": 180, "body": "def _report_internal_error(self, message):\n        print(\"PROBLEM WITH THONNY'S BACK-END:\\n\" + message + \"\\n\", file=sys.stderr)", "is_method": true, "class_name": "BaseBackend", "function_description": "Provides a standardized way for the backend to report internal errors. It prints a descriptive error message to the standard error output, notifying users or developers of critical issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_should_keep_going", "line_number": 184, "body": "def _should_keep_going(self) -> bool:\n        \"\"\"Returns False when there is no point in processing more commands\n        (eg. connection to the target process is lost or target process has exited)\"\"\"", "is_method": true, "class_name": "BaseBackend", "function_description": "This method determines if the backend should continue processing commands. It returns False if the connection to the target process is lost or the process has exited."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_handle_immediate_command", "line_number": 201, "body": "def _handle_immediate_command(self, cmd: ImmediateCommand) -> None:\n        \"\"\"Command handler will be executed in command reading thread, right after receiving the command\"\"\"", "is_method": true, "class_name": "BaseBackend", "function_description": "Handles immediate commands received by the backend system. It processes these time-sensitive commands in a dedicated command reading thread immediately upon reception."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_get_dirs_children_info", "line_number": 211, "body": "def _cmd_get_dirs_children_info(self, cmd):\n        \"\"\"Provides information about immediate children of paths opened in a file browser\"\"\"\n        data = {\n            path: self._get_filtered_dir_children_info(path, cmd[\"include_hidden\"])\n            for path in cmd[\"paths\"]\n        }\n        return {\"node_id\": cmd[\"node_id\"], \"dir_separator\": self._get_sep(), \"data\": data}", "is_method": true, "class_name": "MainBackend", "function_description": "Provides a backend service for a file browser, furnishing information about the immediate children of specified directory paths. It includes or excludes hidden files as requested."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_prepare_upload", "line_number": 219, "body": "def _cmd_prepare_upload(self, cmd):\n        \"\"\"Returns info about items to be overwritten or merged by cmd.paths\"\"\"\n        return {\"existing_items\": self._get_paths_info(cmd.target_paths, recurse=False)}", "is_method": true, "class_name": "MainBackend", "function_description": "Prepares an upload operation by providing information on existing items that might be overwritten or merged."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_prepare_download", "line_number": 223, "body": "def _cmd_prepare_download(self, cmd):\n        assert \"id\" in cmd\n        \"\"\"Returns info about all items under and including cmd.paths\"\"\"\n        return {\"all_items\": self._get_paths_info(cmd.source_paths, recurse=True)}", "is_method": true, "class_name": "MainBackend", "function_description": "Prepares a download operation by recursively gathering information about all specified source paths. It provides a structured list of items for the actual download process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_paths_info", "line_number": 228, "body": "def _get_paths_info(self, paths: List[str], recurse: bool) -> Dict[str, Dict]:\n        result = {}\n\n        for path in paths:\n            info = self._get_path_info(path)\n            if info is not None:\n                info[\"anchor\"] = path\n                result[path] = info\n\n            if recurse and info is not None and info[\"kind\"] == \"dir\":\n                desc_infos = self._get_dir_descendants_info(path)\n                for key in desc_infos:\n                    desc_infos[key][\"anchor\"] = path\n                result.update(desc_infos)\n\n        return result", "is_method": true, "class_name": "MainBackend", "function_description": "The function collects metadata for a given list of paths. It can optionally and recursively retrieve information for all descendants within specified directories."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_dir_descendants_info", "line_number": 245, "body": "def _get_dir_descendants_info(self, path: str, include_hidden: bool = False) -> Dict[str, Dict]:\n        \"\"\"Assumes path is dir. Dict is keyed by full path\"\"\"\n        result = {}\n        children_info = self._get_filtered_dir_children_info(path, include_hidden)\n        for child_name, child_info in children_info.items():\n            full_child_path = path + self._get_sep() + child_name\n            result[full_child_path] = child_info\n            if child_info[\"kind\"] == \"dir\":\n                result.update(self._get_dir_descendants_info(full_child_path))\n\n        return result", "is_method": true, "class_name": "MainBackend", "function_description": "Provides a comprehensive, recursive listing of all files and subdirectories within a given path, including their detailed information. Useful for exploring hierarchical directory structures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_filtered_dir_children_info", "line_number": 257, "body": "def _get_filtered_dir_children_info(\n        self, path: str, include_hidden: bool = False\n    ) -> Optional[Dict[str, Dict]]:\n        children = self._get_dir_children_info(path, include_hidden)\n        if children is None:\n            return None\n\n        return {name: children[name] for name in children if name not in IGNORED_FILES_AND_DIRS}", "is_method": true, "class_name": "MainBackend", "function_description": "Retrieves information about a directory's direct children, excluding items specified in a global ignored list. This provides a filtered view of the directory's contents for backend operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_path_info", "line_number": 267, "body": "def _get_path_info(self, path: str) -> Optional[Dict]:\n        \"\"\"Returns information about this path or None if it doesn't exist\"\"\"", "is_method": true, "class_name": "MainBackend", "function_description": "This MainBackend method retrieves specific information about a given path. It provides a dictionary of details if the path exists, or None otherwise, serving as a path inquiry utility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_dir_children_info", "line_number": 271, "body": "def _get_dir_children_info(self, path: str) -> Optional[Dict[str, Dict]]:\n        \"\"\"For existing dirs returns Dict[child_short_name, Dict of its information].\n        Returns None if path doesn't exist or is not a dir.\n        \"\"\"", "is_method": true, "class_name": "MainBackend", "function_description": "This method retrieves detailed information for all immediate children (files and subdirectories) within a specified directory path. It returns a dictionary mapping child names to their information, or `None` if the path is invalid.\nThis method retrieves detailed information for all immediate children (files and subdirectories) within a specified directory path. It returns a dictionary mapping child names to their information, or `None` if the path is invalid."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_sep", "line_number": 277, "body": "def _get_sep(self) -> str:\n        \"\"\"Returns symbol for combining parent directory path and child name\"\"\"", "is_method": true, "class_name": "MainBackend", "function_description": "Provides the specific separator symbol used by the backend for combining parent directory paths with child names."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_download", "line_number": 285, "body": "def _cmd_download(self, cmd):\n        errors = self._transfer_files_and_dirs(\n            cmd.items, self._ensure_local_directory, self._download_file, cmd, pathlib.Path\n        )\n        return {\"errors\": errors}", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "This method processes a download command, orchestrating the transfer of specified files and directories from a remote source to the local system, reporting any errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_upload", "line_number": 291, "body": "def _cmd_upload(self, cmd):\n        errors = self._transfer_files_and_dirs(\n            cmd.items,\n            self._ensure_remote_directory,\n            self._upload_file,\n            cmd,\n            pathlib.PurePosixPath,\n        )\n        return {\"errors\": errors}", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Manages the recursive upload of specified files and directories to a remote destination, reporting any transfer errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_read_file", "line_number": 301, "body": "def _cmd_read_file(self, cmd):\n        def callback(completed, total):\n            self._report_progress(cmd, cmd[\"path\"], completed, total)\n\n        try:\n            with io.BytesIO() as fp:\n                self._read_file(cmd[\"path\"], fp, callback)\n                fp.seek(0)\n                content_bytes = fp.read()\n\n            error = None\n        except Exception as e:\n            self._report_internal_exception()\n            error = str(e)\n            content_bytes = None\n\n        return {\"content_bytes\": content_bytes, \"path\": cmd[\"path\"], \"error\": error}", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Reads the content of a specified file, reporting progress and handling errors. It provides the file's raw byte content for download operations within the mixin."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_cmd_write_file", "line_number": 319, "body": "def _cmd_write_file(self, cmd):\n        def callback(completed, total):\n            self._report_progress(cmd, cmd[\"path\"], completed, total)\n\n        try:\n            with io.BytesIO() as fp:\n                fp.write(cmd[\"content_bytes\"])\n                fp.seek(0)\n                self._write_file(fp, cmd[\"path\"], len(cmd[\"content_bytes\"]), callback)\n\n            error = None\n        except Exception as e:\n            self._report_internal_exception()\n            error = str(e)\n\n        return InlineResponse(\n            command_name=\"write_file\", path=cmd[\"path\"], editor_id=cmd.get(\"editor_id\"), error=error\n        )", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Handles a 'write_file' command by saving provided binary content to a specified path. It includes progress reporting and returns an operation status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_supports_directories", "line_number": 338, "body": "def _supports_directories(self) -> bool:\n        return True", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Indicates that this mixin, and thus any class using it, supports operations that involve directories."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_transfer_files_and_dirs", "line_number": 341, "body": "def _transfer_files_and_dirs(\n        self,\n        items: Iterable[Dict],\n        ensure_dir_fun: Callable[[str], None],\n        transfer_file_fun: Callable,\n        cmd,\n        target_path_class,\n    ) -> List[str]:\n\n        total_cost = 0\n        for item in items:\n            if item[\"kind\"] == \"file\":\n                total_cost += item[\"size\"] + self._get_file_fixed_cost()\n            else:\n                total_cost += self._get_dir_transfer_cost()\n\n        completed_cost = 0\n        errors = []\n\n        ensured_dirs = set()\n\n        def ensure_dir(path):\n            if path in ensured_dirs:\n                return\n            ensure_dir_fun(path)\n            ensured_dirs.add(path)\n\n        for item in sorted(items, key=lambda x: x[\"source_path\"]):\n            self._report_progress(cmd, \"Starting\", completed_cost, total_cost)\n\n            def copy_bytes_notifier(completed_bytes, total_bytes):\n                completed = completed_cost + completed_bytes\n                desc = str(round(completed / total_cost * 100)) + \"%\"\n\n                self._report_progress(cmd, desc, completed, total_cost)\n\n            try:\n                if item[\"kind\"] == \"dir\":\n                    ensure_dir(item[\"target_path\"])\n                    completed_cost += self._get_dir_transfer_cost()\n                else:\n                    if self._supports_directories():\n                        ensure_dir(self._get_parent_directory(item[\"target_path\"]))\n                    print(\"%s (%d bytes)\" % (item[\"source_path\"], item[\"size\"]))\n                    transfer_file_fun(item[\"source_path\"], item[\"target_path\"], copy_bytes_notifier)\n                    completed_cost += self._get_file_fixed_cost() + item[\"size\"]\n            except OSError as e:\n                errors.append(\n                    \"Could not copy %s to %s: %s\"\n                    % (item[\"source_path\"], item[\"target_path\"], str(e))\n                )\n\n        return errors", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Manages the bulk transfer of files and directories, providing progress updates and error collection. It leverages configurable functions for directory creation and file transfer, offering a robust data movement capability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_download_file", "line_number": 395, "body": "def _download_file(self, source_path, target_path, callback):\n        with open(target_path, \"bw\") as target_fp:\n            self._read_file(source_path, target_fp, callback)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "An internal helper method to download data from a specified source to a local file path, utilizing a callback for progress or status updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_upload_file", "line_number": 399, "body": "def _upload_file(self, source_path, target_path, callback):\n        with open(source_path, \"br\") as source_fp:\n            self._write_file(\n                source_fp,\n                target_path,\n                os.path.getsize(source_path),\n                callback,\n            )", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "This helper method of `UploadDownloadMixin` prepares a local file for upload by opening it in binary mode. It then passes the file's contents and metadata to an internal writing mechanism for transfer to a target path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_dir_transfer_cost", "line_number": 408, "body": "def _get_dir_transfer_cost(self):\n        # Validating and maybe creating a directory is taken to be equal to copying this number of bytes\n        return 1000", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Defines a fixed byte cost for directory validation and creation, used in calculating overall transfer expenses."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_file_fixed_cost", "line_number": 412, "body": "def _get_file_fixed_cost(self):\n        # Creating or overwriting a file is taken to be equal to copying this number of bytes\n        return 100", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Provides a fixed byte-equivalent value representing the overhead cost for creating or overwriting a file. This constant is likely used in calculations related to file transfer operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_parent_directory", "line_number": 416, "body": "def _get_parent_directory(self, path: str):\n        return universal_dirname(path)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Returns the parent directory path for any given file or directory path. This is a utility for navigating file structures, useful in upload/download operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_ensure_local_directory", "line_number": 419, "body": "def _ensure_local_directory(self, path: str) -> None:\n        os.makedirs(path, NEW_DIR_MODE, exist_ok=True)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Ensures a specified local directory path exists, creating it and any parent directories if needed, to prepare the local filesystem for file operations.\nEnsures a specified local directory path exists, creating it and any parent directories if needed, to prepare the local filesystem for file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_ensure_remote_directory", "line_number": 422, "body": "def _ensure_remote_directory(self, path: str) -> None:\n        # assuming remote system is Posix\n        ensure_posix_directory(path, self._get_stat_mode_for_upload, self._mkdir_for_upload)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Provides the capability to ensure a specified directory path exists on the remote system. This prepares the target location for file upload operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_stat_mode_for_upload", "line_number": 427, "body": "def _get_stat_mode_for_upload(self, path: str) -> Optional[int]:\n        \"returns None if path doesn't exist\"", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Provides the file system mode for a path, returning None if nonexistent. Useful for pre-upload validation checks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "poll", "line_number": 472, "body": "def poll(self):\n        if self._channel.exit_status_ready():\n            self.returncode = self._channel.recv_exit_status()\n            return self.returncode\n        else:\n            return None", "is_method": true, "class_name": "RemoteProcess", "function_description": "Checks if the remote process has exited and retrieves its return code if available. This allows for non-blocking monitoring of remote operation completion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "wait", "line_number": 479, "body": "def wait(self):\n        self.returncode = self._channel.recv_exit_status()\n        return self.returncode", "is_method": true, "class_name": "RemoteProcess", "function_description": "This method waits for the remote process to complete its execution. It retrieves and returns the process's exit status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "kill", "line_number": 483, "body": "def kill(self):\n        _, stdout, _ = self._client.exec_command(\"kill -9 %s\" % self.pid)\n        # wait until completion\n        stdout.channel.recv_exit_status()", "is_method": true, "class_name": "RemoteProcess", "function_description": "Forcefully terminates the remote process managed by this object. This provides a way to stop unresponsive remote operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_connect", "line_number": 516, "body": "def _connect(self):\n        from paramiko.ssh_exception import AuthenticationException\n        import socket\n\n        from paramiko import SSHException\n\n        try:\n            self._client.connect(\n                hostname=self._host,\n                username=self._user,\n                password=self._password,\n                passphrase=self._password,\n            )\n        except (SSHException, OSError) as e:\n            print(\n                \"\\nCan't connect to '%s' with user '%s': %s\" % (self._host, self._user, str(e)),\n                file=sys.stderr,\n            )\n            print(\"Re-check your host, authentication method, password or keys.\", file=sys.stderr)\n            delete_stored_ssh_password()\n\n            sys.exit(1)", "is_method": true, "class_name": "SshMixin", "function_description": "Establishes an SSH connection to a remote host using stored credentials. It manages connection and authentication errors, providing robust connection setup for SSH-based operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_create_remote_process", "line_number": 539, "body": "def _create_remote_process(self, cmd_items: List[str], cwd: str, env: Dict) -> RemoteProcess:\n        # Before running the main thing:\n        # * print process id (so that we can kill it later)\n        #   http://redes-privadas-virtuales.blogspot.com/2013/03/getting-hold-of-remote-pid-through.html\n        # * change to desired directory\n        #\n        # About -onlcr: https://stackoverflow.com/q/35887380/261181\n        cmd_line_str = (\n            \"echo $$ ; stty -echo ; stty -onlcr ; \"\n            + (\" cd %s  2> /dev/null ;\" % shlex.quote(cwd) if cwd else \"\")\n            + (\" exec \" + \" \".join(map(shlex.quote, cmd_items)))\n        )\n        stdin, stdout, _ = self._client.exec_command(\n            cmd_line_str, bufsize=0, get_pty=True, environment=env\n        )\n\n        # stderr gets directed to stdout because of pty\n        pid = stdout.readline().strip()\n        channel = stdout.channel\n\n        return RemoteProcess(self._client, channel, stdin, stdout, pid)", "is_method": true, "class_name": "SshMixin", "function_description": "Creates and starts a process on a remote server using SSH. It configures the command's working directory and environment, capturing its process ID for control."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_handle_immediate_command", "line_number": 561, "body": "def _handle_immediate_command(self, cmd: ImmediateCommand) -> None:\n        if cmd.name == \"kill\":\n            self._kill()\n        elif cmd.name == \"interrupt\":\n            self._interrupt()\n        else:\n            raise RuntimeError(\"Unknown immediateCommand %s\" % cmd.name)", "is_method": true, "class_name": "SshMixin", "function_description": "Dispatches immediate SSH commands like 'kill' or 'interrupt' to their respective internal handlers. It provides a mechanism for urgent control actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_kill", "line_number": 569, "body": "def _kill(self):\n        if self._proc is None or self._proc.poll() is not None:\n            return\n\n        self._proc.kill()", "is_method": true, "class_name": "SshMixin", "function_description": "Safely terminates the associated background process if it is currently running, preventing lingering resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_sftp", "line_number": 578, "body": "def _get_sftp(self, fresh: bool):\n\n        if fresh and self._sftp is not None:\n            self._sftp.close()\n            self._sftp = None\n\n        if self._sftp is None:\n            import paramiko\n\n            # TODO: does it get closed properly after process gets killed?\n            self._sftp = paramiko.SFTPClient.from_transport(self._client.get_transport())\n\n        return self._sftp", "is_method": true, "class_name": "SshMixin", "function_description": "Obtains an SFTP client instance for secure file transfers, creating a new connection or refreshing an existing one as needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_read_file", "line_number": 592, "body": "def _read_file(\n        self, source_path: str, target_fp: BinaryIO, callback: Callable[[int, int], None]\n    ) -> None:\n        self._perform_sftp_operation_with_retry(\n            lambda sftp: sftp.getfo(source_path, target_fp, callback)\n        )", "is_method": true, "class_name": "SshMixin", "function_description": "Facilitates downloading a file from a remote SSH server to a local file stream using SFTP. It supports retry attempts and progress reporting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_write_file", "line_number": 599, "body": "def _write_file(\n        self,\n        source_fp: BinaryIO,\n        target_path: str,\n        file_size: int,\n        callback: Callable[[int, int], None],\n    ) -> None:\n        self._perform_sftp_operation_with_retry(\n            lambda sftp: sftp.putfo(source_fp, target_path, callback)\n        )", "is_method": true, "class_name": "SshMixin", "function_description": "Uploads a file from a local binary stream to a remote target path via SFTP. It includes retry logic and a progress callback for reliable transfer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_perform_sftp_operation_with_retry", "line_number": 610, "body": "def _perform_sftp_operation_with_retry(self, operation) -> Any:\n        try:\n            return operation(self._get_sftp(fresh=False))\n        except OSError:\n            # It looks like SFTPClient gets stale after a while.\n            # Try again with fresh SFTPClient\n            return operation(self._get_sftp(fresh=True))", "is_method": true, "class_name": "SshMixin", "function_description": "This method performs an SFTP operation, automatically retrying it with a fresh connection if an OSError occurs. It ensures reliable execution of SFTP tasks by handling potential connection issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_get_stat_mode_for_upload", "line_number": 618, "body": "def _get_stat_mode_for_upload(self, path: str) -> Optional[int]:\n        try:\n            return self._perform_sftp_operation_with_retry(lambda sftp: sftp.stat(path).st_mode)\n        except OSError as e:\n            return None", "is_method": true, "class_name": "SshMixin", "function_description": "Retrieves the stat mode (permissions and file type) of a remote file via SFTP. It returns None if the file does not exist or is inaccessible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "_mkdir_for_upload", "line_number": 624, "body": "def _mkdir_for_upload(self, path: str) -> None:\n        self._perform_sftp_operation_with_retry(lambda sftp: sftp.mkdir(path, NEW_DIR_MODE))", "is_method": true, "class_name": "SshMixin", "function_description": "This method creates a new directory on the remote server via SFTP. It ensures the necessary directory structure exists before a file upload."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "callback", "line_number": 302, "body": "def callback(completed, total):\n            self._report_progress(cmd, cmd[\"path\"], completed, total)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Provides a standard callback interface for reporting progress during an operation. It relays completion status to an internal progress tracking mechanism."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "callback", "line_number": 320, "body": "def callback(completed, total):\n            self._report_progress(cmd, cmd[\"path\"], completed, total)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "This callback method reports the ongoing progress of an operation, like an upload or download. It provides updates on completed units relative to the total, enabling real-time feedback."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "ensure_dir", "line_number": 362, "body": "def ensure_dir(path):\n            if path in ensured_dirs:\n                return\n            ensure_dir_fun(path)\n            ensured_dirs.add(path)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "Ensures a specified directory path exists, optimizing performance by preventing redundant creation attempts for paths already processed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/backend.py", "function": "copy_bytes_notifier", "line_number": 371, "body": "def copy_bytes_notifier(completed_bytes, total_bytes):\n                completed = completed_cost + completed_bytes\n                desc = str(round(completed / total_cost * 100)) + \"%\"\n\n                self._report_progress(cmd, desc, completed, total_cost)", "is_method": true, "class_name": "UploadDownloadMixin", "function_description": "This method updates and reports the overall progress of an upload or download operation. It calculates the current completion percentage based on newly transferred bytes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "select_page", "line_number": 64, "body": "def select_page(self, key):\n        for i, tab in enumerate(self._notebook.tabs()):\n            if self._page_records[i][0] == key:\n                self._notebook.select(tab)", "is_method": true, "class_name": "ConfigurationDialog", "function_description": "This method allows programmatic selection of a specific page or tab within the configuration dialog. It activates the page identified by the provided key."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "_ok", "line_number": 69, "body": "def _ok(self, event=None):\n        for _, title, page in self._page_records:\n            try:\n                if page.apply() is False:\n                    return\n            except Exception:\n                get_workbench().report_exception(\"Error when applying options in \" + title)\n\n        self.destroy()", "is_method": true, "class_name": "ConfigurationDialog", "function_description": "This method applies all configuration settings from the dialog's pages. It handles application errors and closes the dialog once changes are successfully applied."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "_cancel", "line_number": 79, "body": "def _cancel(self, event=None):\n        for _, title, page in self._page_records:\n            try:\n                page.cancel()\n            except Exception:\n                get_workbench().report_exception(\"Error when cancelling options in \" + title)\n\n        self.destroy()", "is_method": true, "class_name": "ConfigurationDialog", "function_description": "Cancels the configuration dialog by instructing all contained pages to discard their changes, then closes the dialog window itself."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "destroy", "line_number": 88, "body": "def destroy(self):\n        ConfigurationDialog.last_shown_tab_index = self._notebook.index(self._notebook.select())\n        super().destroy()", "is_method": true, "class_name": "ConfigurationDialog", "function_description": "Closes the configuration dialog. Before destroying the dialog, it stores the index of the last selected tab for future recall."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "add_checkbox", "line_number": 104, "body": "def add_checkbox(\n        self, flag_name, description, row=None, column=0, padx=0, pady=0, columnspan=1, tooltip=None\n    ):\n        variable = get_workbench().get_variable(flag_name)\n        checkbox = ttk.Checkbutton(self, text=description, variable=variable)\n        checkbox.grid(\n            row=row, column=column, sticky=tk.W, padx=padx, pady=pady, columnspan=columnspan\n        )\n\n        if tooltip is not None:\n            ui_utils.create_tooltip(checkbox, tooltip)", "is_method": true, "class_name": "ConfigurationPage", "function_description": "Adds a configurable checkbox to the UI for user settings. It links to an application variable, positions it on the grid, and supports tooltips."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "add_combobox", "line_number": 116, "body": "def add_combobox(\n        self, variable, values, row=None, column=0, padx=0, pady=0, columnspan=1, width=None\n    ):\n        if isinstance(variable, str):\n            variable = get_workbench().get_variable(variable)\n        combobox = ttk.Combobox(\n            self,\n            exportselection=False,\n            textvariable=variable,\n            state=\"readonly\",\n            height=15,\n            width=width,\n            values=values,\n        )\n        combobox.grid(\n            row=row, column=column, sticky=tk.W, pady=pady, padx=padx, columnspan=columnspan\n        )\n        return variable", "is_method": true, "class_name": "ConfigurationPage", "function_description": "Adds a dropdown combobox to the configuration page. It enables users to select from predefined values, linking the choice to a specified variable for dynamic updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config_ui.py", "function": "add_entry", "line_number": 135, "body": "def add_entry(self, option_name, row=None, column=0, pady=0, padx=0, columnspan=1, **kw):\n        variable = get_workbench().get_variable(option_name)\n        entry = ttk.Entry(self, textvariable=variable, **kw)\n        entry.grid(row=row, column=column, sticky=tk.W, pady=pady, columnspan=columnspan, padx=padx)", "is_method": true, "class_name": "ConfigurationPage", "function_description": "Adds a user-editable input field for a specific configuration option to the page. It displays and allows modification of the option's associated value."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/token_utils.py", "function": "matches_any", "line_number": 5, "body": "def matches_any(name, alternates):\n    \"Return a named group pattern matching list of alternates.\"\n    return \"(?P<%s>\" % name + \"|\".join(alternates) + \")\"", "is_method": false, "function_description": "Generates a regular expression pattern for a named group that matches any of the provided alternate strings. This utility aids in dynamic regex construction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "name_similarity", "line_number": 874, "body": "def name_similarity(a, b):\n    # TODO: tweak the result values\n    a = a.replace(\"_\", \"\")\n    b = b.replace(\"_\", \"\")\n\n    minlen = min(len(a), len(b))\n\n    if a.replace(\"0\", \"O\").replace(\"1\", \"l\") == b.replace(\"0\", \"O\").replace(\"1\", \"l\"):\n        if minlen >= 4:\n            return 7\n        else:\n            return 6\n\n    a = a.lower()\n    b = b.lower()\n\n    if a == b:\n        if minlen >= 4:\n            return 7\n        else:\n            return 6\n\n    if minlen <= 2:\n        return 0\n\n    # if names differ at final isolated digits,\n    # then they are probably different vars, even if their\n    # distance is small (eg. location_1 and location_2)\n    if a[-1].isdigit() and not a[-2].isdigit() and b[-1].isdigit() and not b[-2].isdigit():\n        return 0\n\n    # same thing with _ + single char suffixes\n    # (eg. location_a and location_b)\n    if a[-2] == \"_\" and b[-2] == \"_\":\n        return 0\n\n    distance = levenshtein_damerau_distance(a, b, 5)\n\n    if minlen <= 5:\n        return max(8 - distance * 2, 0)\n    elif minlen <= 10:\n        return max(9 - distance * 2, 0)\n    else:\n        return max(10 - distance * 2, 0)", "is_method": false, "function_description": "Provides a similarity score between two input strings, intended for variable or identifier names. It applies normalization and edit distance to assess semantic closeness, accounting for common naming patterns."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_get_imported_user_files", "line_number": 920, "body": "def _get_imported_user_files(main_file, source=None):\n    assert os.path.isabs(main_file)\n\n    if source is None:\n        source = read_source(main_file)\n\n    try:\n        root = ast.parse(source, main_file)\n    except SyntaxError:\n        return set()\n\n    main_dir = os.path.dirname(main_file)\n    module_names = set()\n    # TODO: at the moment only considers non-package modules\n    for node in ast.walk(root):\n        if isinstance(node, ast.Import):\n            for item in node.names:\n                module_names.add(item.name)\n        elif isinstance(node, ast.ImportFrom):\n            module_names.add(node.module)\n\n    imported_files = set()\n\n    for file in {name + ext for ext in [\".py\", \".pyw\"] for name in module_names}:\n        possible_path = os.path.join(main_dir, file)\n        if os.path.exists(possible_path):\n            imported_files.add(possible_path)\n\n    return imported_files", "is_method": false, "function_description": "This function parses a Python file's source code to discover direct imports. It returns the absolute paths of these locally imported Python files found within the same directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "add_program_analyzer", "line_number": 952, "body": "def add_program_analyzer(cls):\n    _program_analyzer_classes.append(cls)", "is_method": false, "function_description": "Adds a program analyzer class to a global registry, enabling dynamic discovery and use by other system components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "add_error_helper", "line_number": 956, "body": "def add_error_helper(error_type_name, helper_class):\n    _error_helper_classes.setdefault(error_type_name, [])\n    _error_helper_classes[error_type_name].append(helper_class)", "is_method": false, "function_description": "Registers a helper class with a specified error type name. This enables associating multiple helper classes with the same error for specialized handling or information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "format_file_url", "line_number": 961, "body": "def format_file_url(filename, lineno, col_offset):\n    s = \"thonny-editor://\" + rst_utils.escape(filename).replace(\" \", \"%20\")\n    if lineno is not None:\n        s += \"#\" + str(lineno)\n        if col_offset is not None:\n            s += \":\" + str(col_offset)\n\n    return s", "is_method": false, "function_description": "Generates a Thonny editor URL that points to a specific file location. This allows direct navigation to a file, line, and column for integration purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "init", "line_number": 975, "body": "def init():\n    get_workbench().set_default(\"assistance.open_assistant_on_errors\", True)\n    get_workbench().set_default(\"assistance.open_assistant_on_warnings\", False)\n    get_workbench().set_default(\"assistance.disabled_checks\", [])\n    get_workbench().add_view(AssistantView, tr(\"Assistant\"), \"se\", visible_by_default=False)", "is_method": false, "function_description": "Configures and initializes the application's 'Assistant' feature. It sets default behaviors for error/warning assistance and registers the Assistant's user interface view within the workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "handle_toplevel_response", "line_number": 96, "body": "def handle_toplevel_response(self, msg: ToplevelResponse) -> None:\n        # Can be called by event system or by Workbench\n        # (if Assistant wasn't created yet but an error came)\n        if not msg.get(\"user_exception\") and msg.get(\"command_name\") in [\n            \"execute_system_command\",\n            \"execute_source\",\n        ]:\n            # Shell commands may be used to investigate the problem, don't clear assistance\n            return\n\n        self._clear()\n\n        from thonny.plugins.cpython import CPythonProxy\n\n        if not isinstance(get_runner().get_backend_proxy(), CPythonProxy):\n            # TODO: add some support for MicroPython as well\n            return\n\n        # prepare for snapshot\n        key = msg.get(\"filename\", \"<pyshell>\")\n        self._current_snapshot = {\n            \"timestamp\": datetime.datetime.now().isoformat()[:19],\n            \"main_file_path\": key,\n        }\n        self._snapshots_per_main_file.setdefault(key, [])\n        self._snapshots_per_main_file[key].append(self._current_snapshot)\n\n        if msg.get(\"user_exception\"):\n            if not msg[\"user_exception\"].get(\"message\", None):\n                msg[\"user_exception\"][\"message\"] = \"<no message>\"\n\n            self._exception_info = msg[\"user_exception\"]\n            self._explain_exception(msg[\"user_exception\"])\n            if get_workbench().get_option(\"assistance.open_assistant_on_errors\"):\n                get_workbench().show_view(\"AssistantView\", set_focus=False)\n        else:\n            self._exception_info = None\n\n        if msg.get(\"filename\") and os.path.exists(msg[\"filename\"]):\n            self.main_file_path = msg[\"filename\"]\n            source = read_source(msg[\"filename\"])\n            self._start_program_analyses(\n                msg[\"filename\"], source, _get_imported_user_files(msg[\"filename\"], source)\n            )\n        else:\n            self.main_file_path = None\n            self._present_conclusion()", "is_method": true, "class_name": "AssistantView", "function_description": "Processes top-level program responses to manage the AssistantView's state. It explains user exceptions, captures execution snapshots, and initiates program analysis for CPython code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_explain_exception", "line_number": 144, "body": "def _explain_exception(self, error_info):\n        rst = (\n            self._get_rst_prelude()\n            + rst_utils.create_title(\n                error_info[\"type_name\"] + \": \" + rst_utils.escape(error_info[\"message\"])\n            )\n            + \"\\n\"\n        )\n\n        if (\n            error_info.get(\"lineno\") is not None\n            and error_info.get(\"filename\")\n            and os.path.exists(error_info[\"filename\"])\n        ):\n            rst += \"`%s, line %d <%s>`__\\n\\n\" % (\n                os.path.basename(error_info[\"filename\"]),\n                error_info[\"lineno\"],\n                self._format_file_url(error_info),\n            )\n\n        helpers = []\n\n        for helper_class in (\n            _error_helper_classes.get(error_info[\"type_name\"], []) + _error_helper_classes[\"*\"]\n        ):\n            try:\n                helpers.append(helper_class(error_info))\n            except HelperNotSupportedError:\n                pass\n            except Exception as e:\n                logger.exception(\"Could not create helper %s\", helper_class, exc_info=e)\n\n        best_intro = helpers[0]\n        for helper in helpers:\n            if helper.intro_confidence > best_intro.intro_confidence:\n                best_intro = helper\n\n        # intro\n        if best_intro.intro_text:\n            rst += (\n                \".. note::\\n\"\n                + \"    \"\n                + best_intro.intro_text.strip().replace(\"\\n\", \"\\n\\n    \")\n                + \"\\n\\n\"\n            )\n\n        suggestions = [\n            suggestion\n            for helper in helpers\n            for suggestion in helper.suggestions\n            if suggestion is not None\n        ]\n        suggestions = sorted(suggestions, key=lambda s: s.relevance, reverse=True)\n\n        if suggestions[0].relevance > 1 or best_intro.intro_confidence > 1:\n            relevance_threshold = 2\n        else:\n            # use relevance 1 only when there is nothing better\n            relevance_threshold = 1\n\n        suggestions = [s for s in suggestions if s.relevance >= relevance_threshold]\n\n        for i, suggestion in enumerate(suggestions):\n            rst += self._format_suggestion(\n                suggestion,\n                i == len(suggestions) - 1,\n                # TODO: is it good if first is preopened?\n                # It looks cleaner if it is not.\n                False,  # i==0\n            )\n\n        self._current_snapshot[\"exception_suggestions\"] = [\n            dict(sug._asdict()) for sug in suggestions\n        ]\n\n        self.text.append_rst(rst)\n        self._append_text(\"\\n\")\n\n        self._current_snapshot[\"exception_type_name\"] = error_info[\"type_name\"]\n        self._current_snapshot[\"exception_message\"] = error_info[\"message\"]\n        self._current_snapshot[\"exception_file_path\"] = error_info[\"filename\"]\n        self._current_snapshot[\"exception_lineno\"] = error_info[\"lineno\"]\n        self._current_snapshot[\"exception_rst\"] = rst", "is_method": true, "class_name": "AssistantView", "function_description": "Provides a formatted reStructuredText explanation of an exception, including error details, file location, and context-aware troubleshooting suggestions for the user. It assists in error understanding and resolution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_format_suggestion", "line_number": 228, "body": "def _format_suggestion(self, suggestion, last, initially_open):\n        return (\n            # assuming that title is already in rst format\n            \".. topic:: \"\n            + suggestion.title\n            + \"\\n\"\n            + \"    :class: toggle%s%s\\n\"\n            % (\", open\" if initially_open else \"\", \", tight\" if not last else \"\")\n            + \"    \\n\"\n            + textwrap.indent(suggestion.body, \"    \")\n            + \"\\n\\n\"\n        )", "is_method": true, "class_name": "AssistantView", "function_description": "Formats a suggestion object into a reStructuredText (RST) topic block. It applies CSS classes to control the block's display and collapse behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_append_text", "line_number": 241, "body": "def _append_text(self, chars, tags=()):\n        self.text.direct_insert(\"end\", chars, tags=tags)", "is_method": true, "class_name": "AssistantView", "function_description": "Appends characters with optional formatting tags to the Assistant's text display. This utility method is essential for presenting information or responses within the view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_clear", "line_number": 244, "body": "def _clear(self):\n        self._accepted_warning_sets.clear()\n        for wp in self._analyzer_instances:\n            wp.cancel_analysis()\n        self._analyzer_instances = []\n        self.text.clear()", "is_method": true, "class_name": "AssistantView", "function_description": "This method resets the `AssistantView` by clearing accepted warnings, canceling active analyses, and clearing its text display. It prepares the view for a fresh state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_start_program_analyses", "line_number": 251, "body": "def _start_program_analyses(self, main_file_path, main_file_source, imported_file_paths):\n\n        for cls in _program_analyzer_classes:\n            analyzer = cls(self._accept_warnings)\n            if analyzer.is_enabled():\n                self._analyzer_instances.append(analyzer)\n\n        if not self._analyzer_instances:\n            return\n\n        self._append_text(\"\\nAnalyzing your code ...\", (\"em\",))\n\n        # save snapshot of current source\n        self._current_snapshot[\"main_file_path\"] = main_file_path\n        self._current_snapshot[\"main_file_source\"] = main_file_source\n        self._current_snapshot[\"imported_files\"] = {\n            name: read_source(name) for name in imported_file_paths\n        }\n\n        # start the analysis\n        for analyzer in self._analyzer_instances:\n            analyzer.start_analysis(main_file_path, imported_file_paths)", "is_method": true, "class_name": "AssistantView", "function_description": "Initiates various enabled program analyzers on the provided main and imported source files. It captures a snapshot of the code and then triggers each analyzer to begin its analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_accept_warnings", "line_number": 274, "body": "def _accept_warnings(self, analyzer, warnings):\n        if analyzer.cancelled:\n            return\n\n        self._accepted_warning_sets.append(warnings)\n        if len(self._accepted_warning_sets) == len(self._analyzer_instances):\n            self._present_warnings()\n            self._present_conclusion()", "is_method": true, "class_name": "AssistantView", "function_description": "Collects warnings from multiple analyzer instances. Once all warnings are gathered, it orchestrates their presentation and displays the final conclusion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_present_conclusion", "line_number": 283, "body": "def _present_conclusion(self):\n\n        if not self.text.get(\"1.0\", \"end\").strip():\n            if self.main_file_path is not None and os.path.exists(self.main_file_path):\n                self._append_text(\"\\n\")\n                self.text.append_rst(\n                    \"The code in `%s <%s>`__ looks good.\\n\\n\"\n                    % (\n                        os.path.basename(self.main_file_path),\n                        self._format_file_url({\"filename\": self.main_file_path}),\n                    )\n                )\n                self.text.append_rst(\n                    \"If it is not working as it should, \"\n                    + \"then consider using some general \"\n                    + \"`debugging techniques <debugging.rst>`__.\\n\\n\",\n                    (\"em\",),\n                )\n\n        if self.text.get(\"1.0\", \"end\").strip():\n            self._append_feedback_link()\n\n        if self._exception_info:\n            self._append_text(\n                \"General advice on dealing with errors.\\n\", (\"a\", \"python_errors_link\")\n            )", "is_method": true, "class_name": "AssistantView", "function_description": "This method finalizes the `AssistantView`'s display by adding a concluding message. It provides positive code feedback, general error advice if exceptions exist, and a feedback link as appropriate."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_present_warnings", "line_number": 310, "body": "def _present_warnings(self):\n        warnings = [w for ws in self._accepted_warning_sets for w in ws]\n        self.text.direct_delete(\"end-2l linestart\", \"end-1c lineend\")\n\n        if not warnings:\n            return\n\n        if self._exception_info is None:\n            intro = \"May be ignored if you are happy with your program.\"\n        else:\n            intro = \"May help you find the cause of the error.\"\n\n        rst = (\n            self._get_rst_prelude()\n            + rst_utils.create_title(\"Warnings\")\n            + \":remark:`%s`\\n\\n\" % intro\n        )\n\n        by_file = {}\n        for warning in warnings:\n            if warning[\"filename\"] not in by_file:\n                by_file[warning[\"filename\"]] = []\n            if warning not in by_file[warning[\"filename\"]]:\n                # Pylint may give double warnings (eg. when module imports itself)\n                by_file[warning[\"filename\"]].append(warning)\n\n        for filename in by_file:\n            rst += \"`%s <%s>`__\\n\\n\" % (\n                os.path.basename(filename),\n                self._format_file_url(dict(filename=filename)),\n            )\n            file_warnings = sorted(\n                by_file[filename], key=lambda x: (x.get(\"lineno\", 0), -x.get(\"relevance\", 1))\n            )\n\n            for i, warning in enumerate(file_warnings):\n                rst += self._format_warning(warning, i == len(file_warnings) - 1) + \"\\n\"\n\n            rst += \"\\n\"\n\n        self.text.append_rst(rst)\n\n        # save snapshot\n        self._current_snapshot[\"warnings_rst\"] = rst\n        self._current_snapshot[\"warnings\"] = warnings\n\n        if get_workbench().get_option(\"assistance.open_assistant_on_warnings\"):\n            get_workbench().show_view(\"AssistantView\")", "is_method": true, "class_name": "AssistantView", "function_description": "Collects and formats all accepted warnings, presenting them to the user within the `AssistantView`, organized by file for clarity. This provides a structured display of potential issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_format_warning", "line_number": 359, "body": "def _format_warning(self, warning, last):\n        title = rst_utils.escape(warning[\"msg\"].splitlines()[0])\n        if warning.get(\"lineno\") is not None:\n            url = self._format_file_url(warning)\n            if warning.get(\"lineno\"):\n                title = \"`Line %d <%s>`__ : %s\" % (warning[\"lineno\"], url, title)\n\n        if warning.get(\"explanation_rst\"):\n            explanation_rst = warning[\"explanation_rst\"]\n        elif warning.get(\"explanation\"):\n            explanation_rst = rst_utils.escape(warning[\"explanation\"])\n        else:\n            explanation_rst = \"\"\n\n        if warning.get(\"more_info_url\"):\n            explanation_rst += \"\\n\\n`More info online <%s>`__\" % warning[\"more_info_url\"]\n\n        explanation_rst = explanation_rst.strip()\n        topic_class = \"toggle\" if explanation_rst else \"empty\"\n        if not explanation_rst:\n            explanation_rst = \"n/a\"\n\n        return (\n            \".. topic:: %s\\n\" % title\n            + \"    :class: \"\n            + topic_class\n            + (\"\" if last else \", tight\")\n            + \"\\n\"\n            + \"    \\n\"\n            + textwrap.indent(explanation_rst, \"    \")\n            + \"\\n\\n\"\n        )", "is_method": true, "class_name": "AssistantView", "function_description": "Formats a structured warning dictionary into a reStructuredText topic block. It includes the message, file links, and detailed explanation for display in an RST-rendered view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_append_feedback_link", "line_number": 392, "body": "def _append_feedback_link(self):\n        self._append_text(\"Was it helpful or confusing?\\n\", (\"a\", \"feedback_link\"))", "is_method": true, "class_name": "AssistantView", "function_description": "Provides the AssistantView with the capability to append a user feedback prompt. This allows users to indicate if the interaction was helpful or confusing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_format_file_url", "line_number": 395, "body": "def _format_file_url(self, atts):\n        return format_file_url(atts[\"filename\"], atts.get(\"lineno\"), atts.get(\"col_offset\"))", "is_method": true, "class_name": "AssistantView", "function_description": "This method formats a file URL by extracting filename, line number, and column offset from an input dictionary. It serves as a utility for the AssistantView to generate precise file location links."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_ask_feedback", "line_number": 398, "body": "def _ask_feedback(self, event=None):\n\n        all_snapshots = self._snapshots_per_main_file[self._current_snapshot[\"main_file_path\"]]\n\n        # TODO: select only snapshots which are not sent yet\n        snapshots = all_snapshots\n\n        ui_utils.show_dialog(FeedbackDialog(get_workbench(), self.main_file_path, snapshots))", "is_method": true, "class_name": "AssistantView", "function_description": "Displays a feedback dialog to the user. It presents relevant file snapshots from the current main file for feedback submission."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_get_rst_prelude", "line_number": 407, "body": "def _get_rst_prelude(self):\n        return \".. default-role:: code\\n\\n\" + \".. role:: light\\n\\n\" + \".. role:: remark\\n\\n\"", "is_method": true, "class_name": "AssistantView", "function_description": "Provides a standard reStructuredText (RST) prelude string. It defines common RST roles ('code', 'light', 'remark') for consistent content rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "configure_tags", "line_number": 412, "body": "def configure_tags(self):\n        super().configure_tags()\n\n        main_font = tk.font.nametofont(\"TkDefaultFont\")\n\n        italic_font = main_font.copy()\n        italic_font.configure(slant=\"italic\", size=main_font.cget(\"size\"))\n\n        h1_font = main_font.copy()\n        h1_font.configure(weight=\"bold\", size=main_font.cget(\"size\"))\n\n        self.tag_configure(\"h1\", font=h1_font, spacing3=0, spacing1=10)\n        self.tag_configure(\"topic_title\", font=\"TkDefaultFont\")\n\n        self.tag_configure(\"topic_body\", font=italic_font, spacing1=10, lmargin1=25, lmargin2=25)\n\n        self.tag_raise(\"sel\")", "is_method": true, "class_name": "AssistantRstText", "function_description": "The AssistantRstText class uses this method to establish visual styling tags for text content. It defines fonts, spacing, and margins for elements like headings, topic titles, and body text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "is_enabled", "line_number": 507, "body": "def is_enabled(self):\n        return True", "is_method": true, "class_name": "ProgramAnalyzer", "function_description": "Reports that the ProgramAnalyzer is always active. This method provides a constant 'true' status, indicating its features are continuously enabled."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "cancel_analysis", "line_number": 522, "body": "def cancel_analysis(self):\n        self.cancelled = True\n        if self._proc is not None:\n            self._proc.kill()", "is_method": true, "class_name": "SubprocessProgramAnalyzer", "function_description": "Provides the capability to halt an ongoing program analysis. It marks the analysis as cancelled and terminates the underlying subprocess if active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "get_intro", "line_number": 531, "body": "def get_intro(self):\n        return \"This error happened in library code. This may mean a bug in \"", "is_method": true, "class_name": "LibraryErrorHelper", "function_description": "Provides a standard introductory phrase for error messages originating from library code. This helps clarify the source of an error to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_happened_in_shell", "line_number": 671, "body": "def _happened_in_shell(self):\n        return self.main_file_path is None or self.main_file_path.lower() == \"<pyshell>\"", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Determines if the event associated with the feedback dialog occurred within an interactive Python shell environment, rather than from a script file."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_populate_tree", "line_number": 674, "body": "def _populate_tree(self):\n        groups = {}\n\n        for snap in self.snapshots:\n            if snap.get(\"exception_message\") and snap.get(\"exception_suggestions\"):\n                group = snap[\"exception_type_name\"]\n                groups.setdefault(group, set())\n                for sug in snap[\"exception_suggestions\"]:\n                    groups[group].add((sug[\"symbol\"], sug[\"title\"]))\n\n            # warnings group\n            if snap.get(\"warnings\"):\n                group = \"Warnings\"\n                groups.setdefault(group, set())\n                for w in snap[\"warnings\"]:\n                    groups[group].add((w[\"symbol\"], w[\"msg\"]))\n\n        for group in sorted(groups.keys(), key=lambda x: x.replace(\"Warnings\", \"z\")):\n            group_id = self.tree.insert(\"\", \"end\", open=True, tags=(\"group\",))\n            self.tree.set(group_id, \"title\", group)\n\n            for symbol, title in sorted(groups[group], key=lambda m: m[1]):\n                item_id = self.tree.insert(\"\", \"end\")\n                self.tree.set(item_id, \"helpful\", self._empty_box)\n                self.tree.set(item_id, \"confusing\", self._empty_box)\n                self.tree.set(item_id, \"title\", title)\n                self.tree.set(item_id, \"symbol\", symbol)\n                self.tree.set(item_id, \"group\", group)\n\n        self.tree.see(\"\")", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Populates the FeedbackDialog's GUI tree view by organizing system snapshots into structured feedback groups. It visually presents categorized exceptions and warnings for user review."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_on_tree_click", "line_number": 705, "body": "def _on_tree_click(self, event):\n        item_id = self.tree.identify(\"item\", event.x, event.y)\n        column = self.tree.identify_column(event.x)\n\n        if not item_id or not column:\n            return\n\n        value_index = int(column[1:]) - 1\n        values = list(self.tree.item(item_id, \"values\"))\n\n        if values[value_index] == self._empty_box:\n            values[value_index] = self._checked_box\n        elif values[value_index] == self._checked_box:\n            values[value_index] = self._empty_box\n        else:\n            return\n\n        # update values\n        self.tree.item(item_id, values=tuple(values))", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Handles user clicks on the tree widget, enabling toggling of a specific cell's state between empty and checked boxes. This provides interactive selection capability within the feedback dialog.\nHandles user clicks on the tree widget, enabling toggling of a specific cell's state between empty and checked boxes. This provides interactive selection capability within the feedback dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_preview_submission_data", "line_number": 725, "body": "def _preview_submission_data(self, event=None):\n        import tempfile\n\n        temp_path = os.path.join(\n            tempfile.mkdtemp(dir=get_workbench().get_temp_dir()),\n            \"ThonnyAssistantFeedback_\"\n            + datetime.datetime.now().isoformat().replace(\":\", \".\")[:19]\n            + \".txt\",\n        )\n        data = self._collect_submission_data()\n        with open(temp_path, \"w\", encoding=\"ascii\") as fp:\n            fp.write(data)\n\n        if running_on_mac_os():\n            subprocess.Popen([\"open\", \"-e\", temp_path])\n        else:\n            import webbrowser\n\n            webbrowser.open(temp_path)", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Allows users to preview the data collected for feedback. It writes this information to a temporary file and opens it for review."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_collect_submission_data", "line_number": 745, "body": "def _collect_submission_data(self):\n        import json\n\n        tree_data = []\n\n        for iid in self.tree.get_children():\n            values = self.tree.item(iid, \"values\")\n            tree_data.append(\n                {\n                    \"helpful\": values[0] == self._checked_box,\n                    \"confusing\": values[1] == self._checked_box,\n                    \"message\": values[2],\n                    \"group\": values[3],\n                    \"symbol\": values[4],\n                }\n            )\n\n        submission = {\n            \"feedback_format_version\": 1,\n            \"thonny_version\": thonny.get_version(),\n            \"python_version\": \".\".join(map(str, sys.version_info[:3])),\n            \"message_feedback\": tree_data,\n            \"comments\": self.comments_text_frame.text.get(\"1.0\", \"end\"),\n        }\n\n        try:\n            import mypy.version\n\n            submission[\"mypy_version\"] = str(mypy.version.__version__)\n        except ImportError:\n            logging.exception(\"Could not get MyPy version\")\n\n        try:\n            import pylint\n\n            submission[\"pylint_version\"] = str(pylint.__version__)\n        except ImportError:\n            logging.exception(\"Could not get Pylint version\")\n\n        if self.include_snapshots_var.get():\n            submission[\"snapshots\"] = self.snapshots\n\n        if self.include_thonny_id_var.get():\n            submission[\"thonny_timestamp\"] = get_workbench().get_option(\n                \"general.configuration_creation_timestamp\"\n            )\n\n        return json.dumps(submission, indent=2)", "is_method": true, "class_name": "FeedbackDialog", "function_description": "This method gathers comprehensive user feedback, comments, and system version information from the dialog. It compiles this data into a structured JSON string for submission."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_submit_data", "line_number": 794, "body": "def _submit_data(self):\n        import gzip\n        import urllib.request\n\n        json_data = self._collect_submission_data()\n        compressed_data = gzip.compress(json_data.encode(\"ascii\"))\n\n        def do_work():\n            try:\n                handle = urllib.request.urlopen(\n                    \"https://thonny.org/store_assistant_feedback.php\",\n                    data=compressed_data,\n                    timeout=10,\n                )\n                return handle.read()\n            except Exception as e:\n                return str(e)\n\n        result = ui_utils.run_with_waiting_dialog(self, do_work, description=\"Uploading\")\n        if result == b\"OK\":\n            if self.snapshots:\n                last_timestamp = self.snapshots[-1][\"timestamp\"]\n                _last_feedback_timestamps[self.main_file_path] = last_timestamp\n            messagebox.showinfo(\n                \"Done!\",\n                \"Thank you for the feedback!\\n\\nLet us know again when Assistant\\nhelps or confuses you!\",\n                master=self.master,\n            )\n            self._close()\n        else:\n            messagebox.showerror(\n                \"Problem\",\n                \"Something went wrong:\\n%s\\n\\nIf you don't mind, then try again later!\"\n                % result[:1000],\n                master=self,\n            )", "is_method": true, "class_name": "FeedbackDialog", "function_description": "This internal method submits user feedback data, collected from the dialog, to a remote server. It compresses the data and manages the asynchronous upload with UI feedback."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_select_unsent_snapshots", "line_number": 831, "body": "def _select_unsent_snapshots(self, all_snapshots):\n        if self.main_file_path not in _last_feedback_timestamps:\n            return all_snapshots\n        else:\n            return [\n                s\n                for s in all_snapshots\n                if s[\"timestamp\"] > _last_feedback_timestamps[self.main_file_path]\n            ]", "is_method": true, "class_name": "FeedbackDialog", "function_description": "This method filters a list of snapshots to identify those created since the last feedback was sent for a specific file. It ensures only new data is considered for feedback submission."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_close", "line_number": 841, "body": "def _close(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Closes and disposes of the feedback dialog window, typically in response to a user action or programmatic request."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "_get_since_str", "line_number": 844, "body": "def _get_since_str(self):\n        if not self.snapshots:\n            assert self.main_file_path in _last_feedback_timestamps\n            since = datetime.datetime.strptime(\n                _last_feedback_timestamps[self.main_file_path], \"%Y-%m-%dT%H:%M:%S\"\n            )\n        else:\n            since = datetime.datetime.strptime(self.snapshots[0][\"timestamp\"], \"%Y-%m-%dT%H:%M:%S\")\n\n        if since.date() == datetime.date.today() or (\n            datetime.datetime.now() - since\n        ) <= datetime.timedelta(hours=5):\n            since_str = since.strftime(\"%X\")\n        else:\n            # date and time without yer\n            since_str = since.strftime(\"%c\").replace(str(datetime.date.today().year), \"\")\n\n        # remove seconds\n        if since_str.count(\":\") == 2:\n            i = since_str.rfind(\":\")\n            if (\n                i > 0\n                and len(since_str[i + 1 : i + 3]) == 2\n                and since_str[i + 1 : i + 3].isnumeric()\n            ):\n                since_str = since_str[:i] + since_str[i + 3 :]\n\n        return since_str.strip()", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Determines and formats a key timestamp (feedback or snapshot start time) into a concise string. It adjusts the display based on recency and removes seconds for a cleaner presentation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/assistance.py", "function": "do_work", "line_number": 801, "body": "def do_work():\n            try:\n                handle = urllib.request.urlopen(\n                    \"https://thonny.org/store_assistant_feedback.php\",\n                    data=compressed_data,\n                    timeout=10,\n                )\n                return handle.read()\n            except Exception as e:\n                return str(e)", "is_method": true, "class_name": "FeedbackDialog", "function_description": "Sends compressed feedback data to a remote server via HTTP. It returns the server's response or an error string from the network operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "try_load_configuration", "line_number": 21, "body": "def try_load_configuration(filename):\n    if filename in _manager_cache:\n        return _manager_cache[filename]\n\n    try:\n        # use cache so Workbench doesn't create duplicate manager\n        # when FirstRunWindow already created one\n        mgr = ConfigurationManager(filename)\n        _manager_cache[filename] = mgr\n        return mgr\n    except configparser.Error:\n        from tkinter import messagebox\n\n        if os.path.exists(filename) and messagebox.askyesno(\n            \"Problem\",\n            \"Thonny's configuration file can't be read. It may be corrupt.\\n\\n\"\n            + \"Do you want to discard the file and open Thonny with default settings?\",\n            master=tk._default_root,\n        ):\n            os.replace(filename, filename + \"_corrupt\")\n            # For some reasons Thonny styles are not loaded properly once messagebox has been shown before main window (At least Windows Py 3.5)\n            raise SystemExit(\"Configuration file has been discarded. Please restart Thonny!\")\n        else:\n            raise", "is_method": false, "function_description": "Loads or retrieves a configuration manager for a given file, utilizing a cache. It handles corrupt configuration files by offering to discard them and requesting a restart."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "_init_default_overrides", "line_number": 94, "body": "def _init_default_overrides(self):\n        overrides_path = os.path.join(os.path.dirname(__file__), \"defaults.ini\")\n        if not os.path.isfile(overrides_path):\n            return\n\n        defparser = configparser.ConfigParser()\n        defparser.read(overrides_path, \"utf-8\")\n        for section in defparser.sections():\n            for key in defparser[section]:\n                # leave parsing until base default value is known\n                self._defaults_overrides_str[section + \".\" + key] = defparser[section][key]", "is_method": true, "class_name": "ConfigurationManager", "function_description": "This method loads configuration overrides from a 'defaults.ini' file. It stores these values as raw strings to be applied over existing default settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "get_option", "line_number": 106, "body": "def get_option(self, name, secondary_default=None):\n        section, option = self._parse_name(name)\n        name = section + \".\" + option\n\n        # variable may have more recent value\n        if name in self._variables:\n            return self._variables[name].get()\n\n        try:\n            val = self._ini.get(section, option)\n\n            # if option's data type is str (inferred from the default value)\n            # then don't try to parse anything (unless it's None)\n            if val == \"None\":\n                return None\n            elif isinstance(self._defaults.get(name), str):\n                return val\n            else:\n                return self._parse_value(val)\n        except Exception:\n            if name in self._defaults:\n                return self._defaults[name]\n            else:\n                return secondary_default", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Retrieves the value of a specific configuration option by name. It prioritizes runtime variables, INI file settings, and predefined defaults for robust application configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "has_option", "line_number": 131, "body": "def has_option(self, name):\n        return name in self._defaults", "is_method": true, "class_name": "ConfigurationManager", "function_description": "This method checks if a specified configuration option is defined within the `ConfigurationManager`'s settings. It allows other components to verify the availability of options before accessing them."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "set_option", "line_number": 134, "body": "def set_option(self, name, value):\n        section, option = self._parse_name(name)\n        name = section + \".\" + option\n        if not self._ini.has_section(section):\n            self._ini.add_section(section)\n\n        if isinstance(value, str):\n            self._ini.set(section, option, value)\n        else:\n            self._ini.set(section, option, repr(value))\n\n        # update variable\n        if name in self._variables:\n            self._variables[name].set(value)", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Sets a specific configuration option's value, updating both the persistent storage and any corresponding in-memory variables. This manages application settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "set_default", "line_number": 149, "body": "def set_default(self, name, primary_default_value):\n        # normalize name\n        section, option = self._parse_name(name)\n        name = section + \".\" + option\n        self._defaults[name] = primary_default_value\n\n        if name in self._defaults_overrides_str:\n            if isinstance(primary_default_value, str):\n                value = self._defaults_overrides_str[name]\n            else:\n                value = self._parse_value(self._defaults_overrides_str[name])\n        else:\n            value = primary_default_value\n\n        self._defaults[name] = value", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Sets a default value for a configuration parameter. It applies a pre-existing override value if one is configured for that parameter, otherwise uses the primary default."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "get_variable", "line_number": 165, "body": "def get_variable(self, name: str) -> tk.Variable:\n        section, option = self._parse_name(name)\n        name = section + \".\" + option\n\n        if name in self._variables:\n            return self._variables[name]\n        else:\n            value = self.get_option(name)\n            if isinstance(value, bool):\n                var = tk.BooleanVar(value=value)  # type: tk.Variable\n            elif isinstance(value, int):\n                var = tk.IntVar(value=value)\n            elif isinstance(value, str):\n                var = tk.StringVar(value=value)\n            elif isinstance(value, float):\n                var = tk.StringVar(value=value)\n            else:\n                raise KeyError(\n                    \"Can't create Tk Variable for \" + name + \". Type is \" + str(type(value))\n                )\n            self._variables[name] = var\n            return var", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Provides or creates a Tkinter `tk.Variable` for a specified configuration option. This enables direct binding of configuration settings to Tkinter UI elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "save", "line_number": 188, "body": "def save(self):\n        # save all tk variables\n        for name in self._variables:\n            self.set_option(name, self._variables[name].get())\n\n        # store\n        if not os.path.exists(self._filename):\n            os.makedirs(os.path.dirname(self._filename), mode=0o700, exist_ok=True)\n\n        # Normal saving occasionally creates corrupted file:\n        # https://bitbucket.org/plas/thonny/issues/167/configuration-file-occasionally-gets\n        # Now I'm saving the configuration to a temp file\n        # and if the save is successful, I replace configuration file with it\n        temp_filename = self._filename + \".temp\"\n        with open(temp_filename, \"w\", encoding=\"UTF-8\") as fp:\n            self._ini.write(fp)\n\n        try:\n            ConfigurationManager(temp_filename)\n            # temp file was created successfully\n            os.chmod(temp_filename, 0o600)\n            os.replace(temp_filename, self._filename)\n            os.chmod(self._filename, 0o600)\n        except Exception:\n            exception(\"Could not save configuration file. Reverting to previous file.\")", "is_method": true, "class_name": "ConfigurationManager", "function_description": "This method saves the application's current configuration variables to a file. It employs a robust temporary file mechanism to ensure data integrity and prevent corruption during the save process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "_parse_name", "line_number": 214, "body": "def _parse_name(self, name):\n        if \".\" in name:\n            return name.split(\".\", 1)\n        else:\n            return \"general\", name", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Parses a configuration key name to extract its category and specific identifier, defaulting to 'general' if no category is specified. This aids in organizing and accessing configuration settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/config.py", "function": "_parse_value", "line_number": 220, "body": "def _parse_value(self, value):\n        try:\n            return ast.literal_eval(value)\n        except Exception:\n            return value", "is_method": true, "class_name": "ConfigurationManager", "function_description": "Safely attempts to convert a string configuration value into its corresponding Python literal type. If conversion fails, it returns the original string, ensuring robust type parsing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "init_plotter", "line_number": 136, "body": "def init_plotter(self):\n        self.plotter = None\n        get_workbench().set_default(\"view.show_plotter\", False)\n        get_workbench().set_default(\"view.shell_sash_position\", 400)\n\n        self.plotter_visibility_var = get_workbench().get_variable(\"view.show_plotter\")\n\n        def can_toggle():\n            return self.winfo_ismapped()\n\n        get_workbench().add_command(\n            \"toggle_plotter\",\n            \"view\",\n            tr(\"Plotter\"),\n            self.toggle_plotter,\n            can_toggle,\n            flag_name=\"view.show_plotter\",\n            group=11,\n        )\n\n        self.update_plotter_visibility(True)", "is_method": true, "class_name": "ShellView", "function_description": "Initializes the plotter component within the ShellView by setting default visibility options. It registers a 'toggle_plotter' command, enabling users to show or hide the plotter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "set_ignore_program_output", "line_number": 158, "body": "def set_ignore_program_output(self, value):\n        self.text._ignore_program_output = value", "is_method": true, "class_name": "ShellView", "function_description": "Allows configuring the ShellView's behavior to either ignore or display program output, controlling what is shown in the view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "toggle_plotter", "line_number": 161, "body": "def toggle_plotter(self):\n        self.plotter_visibility_var.set(not self.plotter_visibility_var.get())\n        self.update_plotter_visibility()", "is_method": true, "class_name": "ShellView", "function_description": "Toggles the visibility state of the plotter component within the ShellView, updating its display accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_plotter_visibility", "line_number": 165, "body": "def update_plotter_visibility(self, initializing_shell_view=False):\n        if self.plotter_visibility_var.get():\n            self.show_plotter(initializing_shell_view)\n        else:\n            self.hide_plotter()", "is_method": true, "class_name": "ShellView", "function_description": "Manages the visibility of the plotter component within the shell view. It shows or hides the plotter based on a stored visibility setting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "show_plotter", "line_number": 171, "body": "def show_plotter(self, initializing_shell_view=False):\n        if not initializing_shell_view:\n            get_workbench().show_view(\"ShellView\", True)\n\n        if self.plotter is None:\n            self.plotter = PlotterCanvas(self, self.text)\n\n        if not self.plotter.winfo_ismapped():\n            self.add(self.plotter, minsize=100)\n\n        self.sash_place(0, get_workbench().get_option(\"view.shell_sash_position\"), 0)\n\n        running.io_animation_required = True\n        self.update_plotter()", "is_method": true, "class_name": "ShellView", "function_description": "The function initializes and displays a plotting canvas within the `ShellView`. It ensures the plotter is visible and ready for data updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "hide_plotter", "line_number": 186, "body": "def hide_plotter(self):\n        if self.plotter is None or not self.plotter.winfo_ismapped():\n            return\n        else:\n            self.remove(self.plotter)\n            running.io_animation_required = False", "is_method": true, "class_name": "ShellView", "function_description": "Removes and hides the graphical plotter component from the ShellView, if visible. This also disables any ongoing I/O animation associated with the plotter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "set_notice", "line_number": 193, "body": "def set_notice(self, text):\n        if text is None:\n            self.notice.grid_forget()\n        else:\n            self.notice[\"text\"] = text\n            if not self.notice.winfo_ismapped():\n                self.notice.grid(row=0, column=1, columnspan=2, sticky=\"nsew\", pady=(0, 1))\n                # height of the text was reduced so adjust the scrolling\n                # self.update()\n                self.text.see(\"end\")", "is_method": true, "class_name": "ShellView", "function_description": "Manages the display of a temporary notice message within the shell view. It shows a new message or clears any existing notification."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "print_error", "line_number": 204, "body": "def print_error(self, txt):\n        self.text._insert_text_directly(txt, (\"io\", \"stderr\"))\n        self.text.see(\"end\")", "is_method": true, "class_name": "ShellView", "function_description": "Displays an error message within the `ShellView`'s output area. It formats the text as standard error and automatically scrolls to make it visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "insert_command_link", "line_number": 208, "body": "def insert_command_link(self, txt, handler):\n        self.text._insert_command_link(txt, handler)", "is_method": true, "class_name": "ShellView", "function_description": "Enables inserting clickable text into the shell view. The inserted text functions as a command link that executes a given handler when activated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "focus_set", "line_number": 211, "body": "def focus_set(self):\n        self.text.focus_set()", "is_method": true, "class_name": "ShellView", "function_description": "This method sets the input focus to the ShellView's primary text area. This ensures user input is directed to the shell's interactive command line."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "submit_python_code", "line_number": 214, "body": "def submit_python_code(self, cmd_line):\n        self.text.submit_command(cmd_line, ())", "is_method": true, "class_name": "ShellView", "function_description": "Submits the given Python code string for execution within the shell's environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "submit_magic_command", "line_number": 217, "body": "def submit_magic_command(self, cmd_line):\n        if isinstance(cmd_line, list):\n            cmd_line = construct_cmd_line(cmd_line)\n\n        if not cmd_line.endswith(\"\\n\"):\n            cmd_line += \"\\n\"\n\n        self.text.submit_command(cmd_line, (\"magic\",))", "is_method": true, "class_name": "ShellView", "function_description": "The `ShellView` method submits a special \"magic command\" for execution within the shell interface. It prepares the command line and delegates it for processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "restart", "line_number": 226, "body": "def restart(self):\n        self.text.restart()", "is_method": true, "class_name": "ShellView", "function_description": "Resets the ShellView's internal text component, preparing it for a new session or clearing its current content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "clear_shell", "line_number": 229, "body": "def clear_shell(self):\n        self.text._clear_shell()", "is_method": true, "class_name": "ShellView", "function_description": "Clears all displayed content from the shell view, providing a clean slate for new output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "has_pending_input", "line_number": 232, "body": "def has_pending_input(self):\n        return self.text.has_pending_input()", "is_method": true, "class_name": "ShellView", "function_description": "This method reports whether the shell view has any user input that has been entered but not yet processed or consumed. It allows other components to determine if input is ready to be read."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "report_exception", "line_number": 235, "body": "def report_exception(self, prelude=None, conclusion=None):\n        if prelude is not None:\n            self.text.direct_insert(\"end\", prelude + \"\\n\", (\"stderr\",))\n\n        self.text.direct_insert(\"end\", traceback.format_exc() + \"\\n\", (\"stderr\",))\n\n        if conclusion is not None:\n            self.text.direct_insert(\"end\", conclusion + \"\\n\", (\"stderr\",))", "is_method": true, "class_name": "ShellView", "function_description": "Displays a formatted Python exception traceback to the shell's standard error output. It can include optional introductory and concluding messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "set_scrollbar", "line_number": 244, "body": "def set_scrollbar(self, *args):\n        self.vert_scrollbar.set(*args)\n        self.update_plotter()", "is_method": true, "class_name": "ShellView", "function_description": "Sets the vertical scrollbar's state and updates the view's plotter to reflect the change."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "text_deleted", "line_number": 248, "body": "def text_deleted(self, event):\n        if event.text_widget == self.text:\n            self.update_plotter()", "is_method": true, "class_name": "ShellView", "function_description": "Handles text deletion events, triggering a plotter update if the deletion occurred within the view's primary text input widget. This ensures the visual representation remains synchronized with the text content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "text_inserted", "line_number": 252, "body": "def text_inserted(self, event):\n        if (\n            event.text_widget == self.text\n            and \"\\n\" in event.text\n            # only when scrollbar doesn't move, because otherwise\n            # the update gets triggered by scrollbar anyway\n            and self.vert_scrollbar.get() == (0.0, 1.0)\n        ):\n            self.update_plotter()", "is_method": true, "class_name": "ShellView", "function_description": "This method updates the plotter component when new text containing a newline is inserted into the shell's text area, provided the view is at the bottom. It ensures the visual output is synchronized with the latest shell activity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_plotter", "line_number": 262, "body": "def update_plotter(self):\n        if self.plotter is not None and self.plotter.winfo_ismapped():\n            self.plotter.update_plot()", "is_method": true, "class_name": "ShellView", "function_description": "Refreshes the associated plotter's display by calling its update method, but only if the plotter exists and is currently visible on screen."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_tabs", "line_number": 266, "body": "def update_tabs(self):\n        self.text.update_tabs()", "is_method": true, "class_name": "ShellView", "function_description": "Refreshes the display and handling of tab characters within the shell view's text component, ensuring correct rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "resize_plotter", "line_number": 269, "body": "def resize_plotter(self):\n        if len(self.panes()) > 1 and self.text.winfo_width() > 5:\n            get_workbench().set_option(\"view.shell_sash_position\", self.sash_coord(0)[0])", "is_method": true, "class_name": "ShellView", "function_description": "Records the current position of the shell view's sash divider. This enables the application to persist and restore the user's preferred shell layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "add_extra_items", "line_number": 279, "body": "def add_extra_items(self):\n        self.add_separator()\n        self.add_command(label=tr(\"Clear\"), command=self.text._clear_shell)\n\n        def toggle_from_menu():\n            # I don't like that Tk menu toggles checbutton variable\n            # automatically before calling the handler.\n            # So I revert the toggle before calling the actual handler.\n            # This way the handler doesn't have to worry whether it\n            # needs to toggle the variable or not, and it can choose to\n            # decline the toggle.\n            self.view.plotter_visibility_var.set(not self.view.plotter_visibility_var.get())\n            self.view.toggle_plotter()\n\n        self.add_checkbutton(\n            label=tr(\"Show Plotter\"),\n            command=toggle_from_menu,\n            variable=self.view.plotter_visibility_var,\n        )", "is_method": true, "class_name": "ShellMenu", "function_description": "Extends the shell menu by adding a separator, a \"Clear\" command to clear the shell, and a checkbutton to toggle the visibility of a plotter. It enhances the user interface with common utilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "selection_is_read_only", "line_number": 299, "body": "def selection_is_read_only(self):\n        return not self.text.selection_is_writable()", "is_method": true, "class_name": "ShellMenu", "function_description": "Determines if the currently selected text is read-only. This indicates whether the selection can be modified."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "is_python_text", "line_number": 399, "body": "def is_python_text(self):\n        return True", "is_method": true, "class_name": "BaseShellText", "function_description": "Declares that the text managed by this `BaseShellText` instance is inherently Python code. This method signals to other components that the content is always Python."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "submit_command", "line_number": 402, "body": "def submit_command(self, cmd_line, tags):\n        # assert get_runner().is_waiting_toplevel_command()\n        self.delete(\"input_start\", \"end\")\n        self.insert(\"input_start\", cmd_line, tags)\n        self.see(\"end\")\n        self.mark_set(\"insert\", \"end\")\n        self._try_submit_input()", "is_method": true, "class_name": "BaseShellText", "function_description": "Submits a command line to the shell's text interface for execution. It handles displaying the command and initiating its processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_handle_input_request", "line_number": 410, "body": "def _handle_input_request(self, msg):\n        self._ensure_visible()\n        self.focus_set()\n        self.mark_set(\"insert\", \"end\")\n        self.tag_remove(\"sel\", \"1.0\", tk.END)\n        self._try_submit_input()  # try to use leftovers from previous request\n        self.see(\"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Prepares the shell text widget to receive user input. It ensures visibility, sets focus, clears selections, and positions the cursor for new interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_handle_program_output", "line_number": 418, "body": "def _handle_program_output(self, msg):\n        if self._ignore_program_output:\n            # This output will be handled elsewhere\n            return\n        # Discard but not too often, as toplevel response will discard anyway\n        if int(float(self.index(\"end\"))) > get_workbench().get_option(\"shell.max_lines\") + 100:\n            self._discard_old_content()\n\n        self._ensure_visible()\n        self._append_to_io_queue(msg.data, msg.stream_name)\n\n        if not self._applied_io_events:\n            # this is first line of io, add padding below command line\n            self.tag_add(\"before_io\", \"output_insert -1 line linestart\")\n\n        self._update_visible_io(None)", "is_method": true, "class_name": "BaseShellText", "function_description": "This method processes and displays incoming program output in the shell text buffer. It manages content size by discarding old lines and ensures new output is visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_handle_toplevel_response", "line_number": 435, "body": "def _handle_toplevel_response(self, msg: ToplevelResponse) -> None:\n        if msg.get(\"error\"):\n            self._insert_text_directly(msg[\"error\"] + \"\\n\", (\"toplevel\", \"stderr\"))\n            self._ensure_visible()\n\n        if \"user_exception\" in msg:\n            self._show_user_exception(msg[\"user_exception\"])\n            self._ensure_visible()\n\n        welcome_text = msg.get(\"welcome_text\")\n        if welcome_text and welcome_text:\n            preceding = self.get(\"output_insert -1 c\", \"output_insert\")\n            if preceding.strip() and not preceding.endswith(\"\\n\"):\n                self._insert_text_directly(\"\\n\")\n            self._insert_text_directly(welcome_text, (\"welcome\",))\n            self.see(\"end\")\n\n        self.mark_set(\"output_end\", self.index(\"end-1c\"))\n        self._discard_old_content()\n        self._update_visible_io(None)\n        self._reset_ansi_attributes()\n        self._io_cursor_offset = 0\n        self._insert_prompt()\n        self._try_submit_input()  # Trying to submit leftover code (eg. second magic command)\n        self.see(\"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Processes and displays various messages (errors, exceptions, welcome text) from a top-level shell response. It updates the shell's text display and prepares it for subsequent user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_handle_fancy_debugger_progress", "line_number": 466, "body": "def _handle_fancy_debugger_progress(self, msg):\n        if msg.in_present or msg.io_symbol_count is None:\n            self._update_visible_io(None)\n        else:\n            self._update_visible_io(msg.io_symbol_count)", "is_method": true, "class_name": "BaseShellText", "function_description": "Provides real-time visual updates for debugger I/O progress within the shell environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_get_squeeze_threshold", "line_number": 472, "body": "def _get_squeeze_threshold(self):\n        return get_workbench().get_option(\"shell.squeeze_threshold\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Retrieves the 'shell.squeeze_threshold' configuration setting. This value likely determines how text output is compressed or truncated within the shell."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_append_to_io_queue", "line_number": 475, "body": "def _append_to_io_queue(self, data, stream_name):\n        # Make sure ANSI CSI codes and object links are stored as separate events\n        # TODO: try to complete previously submitted incomplete code\n        parts = re.split(OUTPUT_SPLIT_REGEX, data)\n        for part in parts:\n            if part:  # split may produce empty string in the beginning or start\n                # split the data so that very long lines separated\n                for block in re.split(\"(.{%d,})\" % (self._get_squeeze_threshold() + 1), part):\n                    if block:\n                        self._queued_io_events.append((block, stream_name))", "is_method": true, "class_name": "BaseShellText", "function_description": "Segments and queues raw shell output data into manageable event blocks. It processes special codes and long lines for structured display or further handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_update_visible_io", "line_number": 486, "body": "def _update_visible_io(self, target_num_visible_chars):\n        current_num_visible_chars = sum(map(lambda x: len(x[0]), self._applied_io_events))\n\n        if (\n            target_num_visible_chars is not None\n            and target_num_visible_chars < current_num_visible_chars\n        ):\n            # hard to undo complex renderings (squeezed texts and ANSI codes)\n            # easier to clean everything and start again\n            self._queued_io_events = self._applied_io_events + self._queued_io_events\n            self._applied_io_events = []\n            self.direct_delete(\"command_io_start\", \"output_end\")\n            current_num_visible_chars = 0\n            self._reset_ansi_attributes()\n\n        while self._queued_io_events and current_num_visible_chars != target_num_visible_chars:\n            data, stream_name = self._queued_io_events.pop(0)\n\n            if target_num_visible_chars is not None:\n                leftover_count = current_num_visible_chars + len(data) - target_num_visible_chars\n\n                if leftover_count > 0:\n                    # add suffix to the queue\n                    self._queued_io_events.insert(0, (data[-leftover_count:], stream_name))\n                    data = data[:-leftover_count]\n\n            self._apply_io_event(data, stream_name)\n            current_num_visible_chars += len(data)\n\n        self.mark_set(\"output_end\", self.index(\"end-1c\"))\n        self.see(\"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "This method dynamically adjusts the amount of shell input/output text currently visible. It manages a queue of I/O events, applying or truncating them to match a target character limit for display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_apply_io_event", "line_number": 518, "body": "def _apply_io_event(self, data, stream_name):\n        if not data:\n            return\n\n        original_data = data\n\n        if self.tty_mode and re.match(TERMINAL_CONTROL_REGEX, data):\n            if data == \"\\a\":\n                get_workbench().bell()\n            elif data == \"\\b\":\n                self._change_io_cursor_offset(-1)\n            elif data == \"\\r\":\n                self._change_io_cursor_offset(\"line\")\n            elif data.endswith(\"D\") or data.endswith(\"C\"):\n                self._change_io_cursor_offset_csi(data)\n            elif stream_name == \"stdout\":\n                # According to https://github.com/tartley/colorama/blob/master/demos/demo04.py\n                # codes sent to stderr shouldn't affect later output in stdout\n                # It makes sense, but Ubuntu terminal does not confirm it.\n                # For now I'm just trimming stderr color codes\n                self._update_ansi_attributes(data)\n            else:\n                logger.warning(\"Don't know what to do with %r\" % data)\n\n        elif re.match(OBJECT_INFO_START_REGEX, data):\n            id_str = data[data.index(\"=\") + 1 : data.index(\"]\")]\n            self.active_extra_tags.append(\"value\")\n            self.active_extra_tags.append(id_str)\n            if get_workbench().get_option(\"shell.auto_inspect_values\"):\n                get_workbench().event_generate(\"ObjectSelect\", object_id=int(id_str))\n\n            if get_workbench().in_heap_mode():\n                self._insert_text_directly(\n                    memory.format_object_id(int(id_str)), tuple(self.active_extra_tags)\n                )\n\n        elif re.match(OBJECT_INFO_END_REGEX, data):\n            self.active_extra_tags.pop()\n            self.active_extra_tags.pop()\n\n        elif \"value\" in self.active_extra_tags and get_workbench().in_heap_mode():\n            # id was already printed and value should be suppressed\n            pass\n        else:\n            if \"value\" in self.active_extra_tags:\n                tags = set(self.active_extra_tags)\n            else:\n                tags = set(self.active_extra_tags) | {\"io\", stream_name}\n\n            if stream_name == \"stdout\" and self.tty_mode:\n                tags |= self._get_ansi_tags()\n\n            non_url_length = len(data)\n            for url_match in SIMPLE_URL_SPLIT_REGEX.finditer(data):\n                non_url_length -= url_match.end() - url_match.start()\n\n            if (\n                non_url_length > self._get_squeeze_threshold()\n                and \"\\n\" not in data\n                and not (data.startswith(OBJECT_LINK_START))\n            ):\n                self._io_cursor_offset = 0  # ignore the effect of preceding \\r and \\b\n                actual_text = data\n                button_text = actual_text[:70] + \" \u2026\"\n                btn = tk.Label(\n                    self,\n                    text=button_text,\n                    # width=len(button_text),\n                    cursor=\"arrow\",\n                    borderwidth=2,\n                    relief=\"raised\",\n                    font=\"IOFont\",\n                )\n                btn.bind(\"<1>\", lambda e: self._show_squeezed_text(btn), True)\n                btn.contained_text = actual_text\n                btn.tags = tags\n                self._squeeze_buttons.add(btn)\n                create_tooltip(btn, \"%d characters squeezed. \" % len(data) + \"Click for details.\")\n\n                # TODO: refactor\n                # (currently copied from insert_text_directly)\n                self.mark_gravity(\"input_start\", tk.RIGHT)\n                self.mark_gravity(\"output_insert\", tk.RIGHT)\n\n                self.window_create(\"output_insert\", window=btn)\n                for tag_name in tags:\n                    self.tag_add(tag_name, \"output_insert -1 chars\")\n                data = \"\"\n\n            elif self._io_cursor_offset < 0:\n                overwrite_len = min(len(data), -self._io_cursor_offset)\n\n                if 0 <= data.find(\"\\n\") < overwrite_len:\n                    overwrite_len = data.find(\"\\n\")\n\n                overwrite_data = data[:overwrite_len]\n                self.direct_insert(\n                    \"output_insert -%d chars\" % -self._io_cursor_offset, overwrite_data, tuple(tags)\n                )\n                del_start = self.index(\"output_insert -%d chars\" % -self._io_cursor_offset)\n                del_end = self.index(\n                    \"output_insert -%d chars\" % (-self._io_cursor_offset - overwrite_len)\n                )\n                self.direct_delete(del_start, del_end)\n\n                # compute leftover data to be printed normally\n                data = data[overwrite_len:]\n\n                if \"\\n\" in data:\n                    # cursor offset doesn't apply on new line\n                    self._io_cursor_offset = 0\n                else:\n                    # offset becomes closer to 0\n                    self._io_cursor_offset += overwrite_len\n\n            elif self._io_cursor_offset > 0:\n                # insert spaces before actual data\n                # NB! Print without formatting tags\n                self._insert_text_directly(\" \" * self._io_cursor_offset, (\"io\", stream_name))\n                self._io_cursor_offset = 0\n\n            if data:\n                # if any data is still left, then this should be output normally\n                self._insert_text_directly(data, tuple(tags))\n\n        self._applied_io_events.append((original_data, stream_name))", "is_method": true, "class_name": "BaseShellText", "function_description": "Renders shell I/O events, including terminal control codes, structured object data, and text, into the `BaseShellText` display. It applies formatting and optimizes the presentation of large outputs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_show_squeezed_text", "line_number": 645, "body": "def _show_squeezed_text(self, button):\n        dlg = SqueezedTextDialog(self, button)\n        show_dialog(dlg)", "is_method": true, "class_name": "BaseShellText", "function_description": "Displays a dedicated dialog window to show the complete version of text that is otherwise truncated or summarized in the shell display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_change_io_cursor_offset_csi", "line_number": 649, "body": "def _change_io_cursor_offset_csi(self, marker):\n        ints = re.findall(INT_REGEX, marker)\n        if len(ints) != 1:\n            logging.warning(\"bad CSI cursor positioning: %s\", marker)\n            # do nothing\n            return\n\n        try:\n            delta = int(ints[0])\n        except ValueError:\n            logging.warning(\"bad CSI cursor positioning: %s\", marker)\n            return\n\n        if marker.endswith(\"D\"):\n            delta = -delta\n\n        self._change_io_cursor_offset(delta)", "is_method": true, "class_name": "BaseShellText", "function_description": "Interprets a Control Sequence Introducer (CSI) marker to calculate a cursor offset. This method updates the shell's I/O cursor position based on the parsed movement command."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_change_io_cursor_offset", "line_number": 667, "body": "def _change_io_cursor_offset(self, delta):\n        line = self.get(\"output_insert linestart\", \"output_insert\")\n        if delta == \"line\":\n            self._io_cursor_offset = -len(line)\n        else:\n            self._io_cursor_offset += delta\n            if self._io_cursor_offset < -len(line):\n                # cap\n                self._io_cursor_offset = -len(line)", "is_method": true, "class_name": "BaseShellText", "function_description": "Manages the internal I/O cursor offset within the shell's text output area. It adjusts the cursor position by a given delta or resets it to the beginning of the current line."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_reset_ansi_attributes", "line_number": 677, "body": "def _reset_ansi_attributes(self):\n        self._ansi_foreground = None\n        self._ansi_background = None\n        self._ansi_inverse = False\n        self._ansi_intensity = None\n        self._ansi_italic = False\n        self._ansi_underline = False\n        self._ansi_conceal = False\n        self._ansi_strikethrough = False", "is_method": true, "class_name": "BaseShellText", "function_description": "This method resets all ANSI text formatting attributes to their default (off) state. It ensures subsequent text rendering starts without inherited styles."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_update_ansi_attributes", "line_number": 687, "body": "def _update_ansi_attributes(self, marker):\n        if not marker.endswith(\"m\"):\n            # ignore\n            return\n\n        codes = re.findall(INT_REGEX, marker)\n        if not codes:\n            self._reset_ansi_attributes()\n\n        while codes:\n            code = codes.pop(0)\n\n            if code == \"0\":\n                self._reset_ansi_attributes()\n            elif code in [\"1\", \"2\"]:\n                self._ansi_intensity = code\n            elif code == \"3\":\n                self._ansi_italic = True\n            elif code == \"4\":\n                self._ansi_underline = True\n            elif code == \"7\":\n                self._ansi_inverse = True\n            elif code == \"8\":\n                self._ansi_conceal = True\n            elif code == \"9\":\n                self._ansi_strikethrough = True\n            elif code == \"22\":\n                self._ansi_intensity = None\n            elif code == \"23\":\n                self._ansi_italic = False\n            elif code == \"24\":\n                self._ansi_underline = False\n            elif code == \"27\":\n                self._ansi_inverse = False\n            elif code == \"28\":\n                self._ansi_conceal = False\n            elif code == \"29\":\n                self._ansi_strikethrough = False\n            if code in [\n                \"30\",\n                \"31\",\n                \"32\",\n                \"33\",\n                \"34\",\n                \"35\",\n                \"36\",\n                \"37\",\n                \"90\",\n                \"91\",\n                \"92\",\n                \"93\",\n                \"94\",\n                \"95\",\n                \"96\",\n                \"97\",\n            ]:\n                self._ansi_foreground = code\n            elif code == \"39\":\n                self._ansi_foreground = None\n            elif code in [\n                \"40\",\n                \"41\",\n                \"42\",\n                \"43\",\n                \"44\",\n                \"45\",\n                \"46\",\n                \"47\",\n                \"100\",\n                \"101\",\n                \"102\",\n                \"103\",\n                \"104\",\n                \"105\",\n                \"106\",\n                \"107\",\n            ]:\n                self._ansi_background = code\n            elif code == \"49\":\n                self._ansi_background = None\n            elif code in [\"38\", \"48\"]:\n                # multipart code, ignore for now,\n                # but make sure all arguments are ignored\n                if not codes:\n                    # nothing follows, ie. invalid code\n                    break\n                mode = codes.pop(0)\n                if mode == \"5\":\n                    # 256-color code, just ignore for now\n                    if not codes:\n                        break\n                    codes = codes[1:]\n                elif mode == \"2\":\n                    # 24-bit code, ignore\n                    if len(codes) < 3:\n                        # invalid code\n                        break\n                    codes = codes[3:]\n            else:\n                # ignore other codes\n                pass", "is_method": true, "class_name": "BaseShellText", "function_description": "Interprets ANSI escape codes to update the text formatting attributes (e.g., color, style) of the `BaseShellText` object. This enables the class to track and apply current text styling for terminal output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_get_ansi_tags", "line_number": 789, "body": "def _get_ansi_tags(self):\n        result = set()\n\n        if self._ansi_foreground:\n            fg = ANSI_COLOR_NAMES[self._ansi_foreground[-1]]\n            if self._ansi_intensity == \"1\" or self._ansi_foreground[0] == \"9\":\n                fg = \"bright_\" + fg\n            elif self._ansi_intensity == \"2\":\n                fg = \"dim_\" + fg\n        else:\n            fg = \"fore\"\n            if self._ansi_intensity == \"1\":\n                fg = \"bright_\" + fg\n            elif self._ansi_intensity == \"2\":\n                fg = \"dim_\" + fg\n\n        if self._ansi_background:\n            bg = ANSI_COLOR_NAMES[self._ansi_background[-1]]\n            if self._ansi_background.startswith(\"10\"):\n                bg = \"bright_\" + bg\n        else:\n            bg = \"back\"\n\n        if self._ansi_inverse:\n            result.add(fg + \"_bg\")\n            result.add(bg + \"_fg\")\n        else:\n            if fg != \"fore\":\n                result.add(fg + \"_fg\")\n            if bg != \"back\":\n                result.add(bg + \"_bg\")\n\n        if self._ansi_intensity == \"1\" and self._ansi_italic:\n            result.add(\"intense_italic_io\")\n        elif self._ansi_intensity == \"1\":\n            result.add(\"intense_io\")\n        elif self._ansi_italic:\n            result.add(\"italic_io\")\n\n        if self._ansi_underline:\n            result.add(\"underline\")\n\n        if self._ansi_strikethrough:\n            result.add(\"strikethrough\")\n\n        return result", "is_method": true, "class_name": "BaseShellText", "function_description": "Generates a set of descriptive tags from the object's ANSI text styling attributes, such as color, intensity, and text decorations. This summarizes the applied text formatting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_insert_prompt", "line_number": 836, "body": "def _insert_prompt(self):\n        # if previous output didn't put a newline, then do it now\n        if not self.index(\"output_insert\").endswith(\".0\"):\n            self._insert_text_directly(\"\\n\", (\"io\",))\n\n        prompt_tags = (\"toplevel\", \"prompt\")\n\n        # if previous line has value or io then add little space\n        prev_line = self.index(\"output_insert - 1 lines\")\n        prev_line_tags = self.tag_names(prev_line)\n        if \"io\" in prev_line_tags or \"value\" in prev_line_tags:\n            prompt_tags += (\"after_io_or_value\",)\n\n        self._insert_text_directly(\">>> \", prompt_tags)\n        self.edit_reset()", "is_method": true, "class_name": "BaseShellText", "function_description": "Inserts a new input prompt (\">>> \") into the shell's text area. It ensures the prompt starts on a new line and applies contextual styling based on previous output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_ensure_visible", "line_number": 852, "body": "def _ensure_visible(self):\n        if self.winfo_ismapped():\n            return\n\n        focused_view = get_workbench().focus_get()\n        get_workbench().show_view(\"ShellView\")\n        if focused_view is not None:\n            focused_view.focus()", "is_method": true, "class_name": "BaseShellText", "function_description": "Ensures the associated 'ShellView' is displayed, making it visible if hidden. It then attempts to restore focus to the previously active GUI element."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_tabs", "line_number": 861, "body": "def update_tabs(self):\n        tab_chars = 8\n        tab_pixels = tk.font.nametofont(\"IOFont\").measure(\"n\" * tab_chars)\n\n        offset = self.io_indent\n        tabs = [offset]\n        for _ in range(20):\n            offset += tab_pixels\n            tabs.append(offset)\n\n        self.tag_configure(\"io\", tabs=tabs, tabstyle=\"wordprocessor\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Configures dynamic tab stops for the \"io\" text tag within the `BaseShellText` widget. This ensures consistent indentation and alignment of displayed content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "restart", "line_number": 873, "body": "def restart(self):\n        self._insert_text_directly(\n            # \"\\n============================== RESTART ==============================\\n\",\n            \"\\n\" + \"\u2500\" * 200 + \"\\n\",\n            # \"\\n\" + \"\u2550\"*200 + \"\\n\",\n            (\"magic\", \"restart_line\"),\n        )\n        self.see(\"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Inserts a distinctive visual separator into the shell's text output to mark a restart point. It then scrolls the view to the end."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "intercept_insert", "line_number": 882, "body": "def intercept_insert(self, index, txt, tags=()):\n        # pylint: disable=arguments-differ\n        if self._editing_allowed() and self._in_current_input_range(index):\n            # self._print_marks(\"before insert\")\n            # I want all marks to stay in place\n            self.mark_gravity(\"input_start\", tk.LEFT)\n            self.mark_gravity(\"output_insert\", tk.LEFT)\n\n            if get_runner().is_waiting_toplevel_command():\n                tags = tags + (\"toplevel\", \"command\")\n            else:\n                tags = tags + (\"io\", \"stdin\")\n\n            EnhancedTextWithLogging.intercept_insert(self, index, txt, tags)\n\n            if not get_runner().is_waiting_toplevel_command():\n                if not self._applied_io_events:\n                    # tag preceding command line differently\n                    self.tag_add(\"before_io\", \"input_start -1 lines linestart\")\n\n                self._try_submit_input()\n\n            self.see(\"insert\")\n        else:\n            get_workbench().bell()", "is_method": true, "class_name": "BaseShellText", "function_description": "Manages text insertion into the shell's interactive input area. It enforces editing rules, applies context-specific tags, and can trigger automatic input submission for enhanced shell behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "intercept_delete", "line_number": 908, "body": "def intercept_delete(self, index1, index2=None, **kw):\n        if index1 == \"sel.first\" and index2 == \"sel.last\" and not self.has_selection():\n            return\n\n        if (\n            self._editing_allowed()\n            and self._in_current_input_range(index1)\n            and (index2 is None or self._in_current_input_range(index2))\n        ):\n            self.direct_delete(index1, index2, **kw)\n        else:\n            get_workbench().bell()", "is_method": true, "class_name": "BaseShellText", "function_description": "Intercepts delete operations in the shell, validating if the specified range is editable. It performs the deletion if allowed, or blocks it and alerts the user otherwise."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "selection_is_writable", "line_number": 921, "body": "def selection_is_writable(self):\n        try:\n            if not self.has_selection():\n                return self._in_current_input_range(self.index(\"insert\"))\n            else:\n                return self._in_current_input_range(\n                    self.index(\"sel.first\")\n                ) and self._in_current_input_range(self.index(\"sel.last\"))\n        except TclError:\n            return True", "is_method": true, "class_name": "BaseShellText", "function_description": "This method checks if the current text selection or cursor position falls within the editable input range. It determines if the user is allowed to modify the focused text area."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "perform_return", "line_number": 932, "body": "def perform_return(self, event):\n        if get_runner().is_running():\n            # if we are fixing the middle of the input string and pressing ENTER\n            # then we expect the whole line to be submitted not linebreak to be inserted\n            # (at least that's how IDLE works)\n            self.mark_set(\"insert\", \"end\")  # move cursor to the end\n\n            # Do the return without auto indent\n            EnhancedTextWithLogging.perform_return(self, event)\n\n            self._try_submit_input()\n\n        elif get_runner().is_waiting_toplevel_command():\n            # Same with editin middle of command, but only if it's a single line command\n            whole_input = self.get(\"input_start\", \"end-1c\")  # asking the whole input\n            if \"\\n\" not in whole_input and self._code_is_ready_for_submission(whole_input):\n                self.mark_set(\"insert\", \"end\")  # move cursor to the end\n                # Do the return without auto indent\n                EnhancedTextWithLogging.perform_return(self, event)\n            else:\n                # Don't want auto indent when code is ready for submission\n                source = self.get(\"input_start\", \"insert\")\n                tail = self.get(\"insert\", \"end\")\n\n                if self._code_is_ready_for_submission(source + \"\\n\", tail):\n                    # No auto-indent\n                    EnhancedTextWithLogging.perform_return(self, event)\n                else:\n                    # Allow auto-indent\n                    perform_python_return(self, event)\n\n            self._try_submit_input()\n\n        return \"break\"", "is_method": true, "class_name": "BaseShellText", "function_description": "Manages the 'Enter' key press in a shell's text area. It either submits the current code for execution or inserts a new line, adapting indentation based on the runner's state and code readiness."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "on_secondary_click", "line_number": 967, "body": "def on_secondary_click(self, event=None):\n        super().on_secondary_click(event)\n        if self.view:\n            self.view.menu.tk_popup(event.x_root, event.y_root)", "is_method": true, "class_name": "BaseShellText", "function_description": "Displays a context menu for the text widget upon a secondary (e.g., right) mouse click. This provides users with context-sensitive options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_in_current_input_range", "line_number": 972, "body": "def _in_current_input_range(self, index):\n        try:\n            return self.compare(index, \">=\", \"input_start\")\n        except Exception:\n            return False", "is_method": true, "class_name": "BaseShellText", "function_description": "Checks if a specified text index is at or beyond the starting position of the current shell input. This helps determine if an index belongs to the active input area."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_insert_command_link", "line_number": 978, "body": "def _insert_command_link(self, txt, handler):\n        self._link_handler_count += 1\n        command_tag = \"link_handler_%s\" % self._link_handler_count\n\n        self.direct_insert(\"output_insert\", txt, (\"io_hyperlink\", command_tag))\n        self.tag_bind(command_tag, \"<1>\", handler)", "is_method": true, "class_name": "BaseShellText", "function_description": "Inserts text into the shell's output, styling it as a hyperlink. It makes the inserted text clickable, executing a provided handler function on click."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_insert_text_directly", "line_number": 985, "body": "def _insert_text_directly(self, txt, tags=()):\n        def _insert(txt, tags):\n            if txt != \"\":\n                self.direct_insert(\"output_insert\", txt, tags)\n\n        def _insert_and_highlight_urls(txt, tags):\n            parts = SIMPLE_URL_SPLIT_REGEX.split(txt)\n            for i, part in enumerate(parts):\n                if i % 2 == 0:\n                    _insert(part, tags)\n                else:\n                    if part.startswith(\"data:image/\"):\n                        token = \";base64,\"\n                        data = part[part.index(token) + len(token) :]\n                        try:\n                            img = tk.PhotoImage(data=data)\n                            self._images.add(img)  # to avoit it being gc-d\"\"\"\n                            self.image_create(\"output_insert\", image=img)\n                            for tag in tags:\n                                self.tag_add(tag, \"output_insert -1 chars\")\n                        except TclError:\n                            _insert(part, tags + (\"io_hyperlink\",))\n                    else:\n                        _insert(part, tags + (\"io_hyperlink\",))\n\n        # I want the insertion to go before marks\n        # self._print_marks(\"before output\")\n        self.mark_gravity(\"input_start\", tk.RIGHT)\n        self.mark_gravity(\"output_insert\", tk.RIGHT)\n        tags = tuple(tags)\n\n        # Make stacktrace clickable\n        if \"stderr\" in tags or \"error\" in tags or (\"File\" in txt and \"line\" in txt):\n            # show lines pointing to source lines as hyperlinks\n            for line in txt.splitlines(True):\n                parts = re.split(r\"(File .* line \\d+.*)$\", line, maxsplit=1)\n                if len(parts) == 3 and \"<pyshell\" not in line:\n                    _insert(parts[0], tags)\n                    _insert(parts[1], tags + (\"io_hyperlink\",))\n                    _insert(parts[2], tags)\n                else:\n                    parts = re.split(r\"(\\'[^\\']+\\.pyw?\\')\", line, flags=re.IGNORECASE)\n                    if len(parts) == 3 and os.path.exists(os.path.expanduser(parts[1][1:-1])):\n                        match = re.search(r\"\\S\", line)\n                        _insert(line[: match.start()], tags)\n                        _insert(line[match.start() :], tags + (\"io_hyperlink\",))\n                    else:\n                        _insert_and_highlight_urls(line, tags)\n        else:\n            _insert_and_highlight_urls(txt, tags)", "is_method": true, "class_name": "BaseShellText", "function_description": "Inserts and formats text into a shell's display area. It automatically highlights URLs, renders embedded images, and makes stack trace elements interactive hyperlinks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "has_pending_input", "line_number": 1039, "body": "def has_pending_input(self):\n        pending = self.get(\"input_start\", \"end-1c\")\n        return bool(pending)", "is_method": true, "class_name": "BaseShellText", "function_description": "Checks if the shell's text area contains any unsubmitted user input. This helps determine if there's active data awaiting processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_try_submit_input", "line_number": 1043, "body": "def _try_submit_input(self):\n        # see if there is already enough inputted text to submit\n        input_text = self.get(\"input_start\", \"insert\")\n        tail = self.get(\"insert\", \"end\")\n\n        # user may have pasted more text than necessary for this request\n        submittable_text = self._extract_submittable_input(input_text, tail)\n\n        if submittable_text is not None:\n            if get_runner().is_waiting_toplevel_command():\n                # clean up the tail\n                if len(tail) > 0:\n                    assert tail.strip() == \"\"\n                    self.delete(\"insert\", \"end-1c\")\n\n            # leftover text will be kept in widget, waiting for next request.\n            start_index = self.index(\"input_start\")\n            end_index = self.index(\"input_start+{0}c\".format(len(submittable_text)))\n\n            # apply correct tags (if it's leftover then it doesn't have them yet)\n            if get_runner().is_running():\n                self.tag_add(\"io\", start_index, end_index)\n                self.tag_add(\"stdin\", start_index, end_index)\n            else:\n                self.tag_add(\"toplevel\", start_index, end_index)\n                self.tag_add(\"command\", start_index, end_index)\n\n            # update start mark for next input range\n            self.mark_set(\"input_start\", end_index)\n\n            # Move output_insert mark after the requested_text\n            # Leftover input, if any, will stay after output_insert,\n            # so that any output that will come in before\n            # next input request will go before leftover text\n            self.mark_set(\"output_insert\", end_index)\n\n            # remove tags from leftover text\n            for tag in (\"io\", \"stdin\", \"toplevel\", \"command\"):\n                # don't remove magic, because otherwise I can't know it's auto\n                self.tag_remove(tag, end_index, \"end\")\n\n            self._submit_input(submittable_text)", "is_method": true, "class_name": "BaseShellText", "function_description": "This method processes the shell's text input, identifying and submitting complete user commands. It also updates the text widget's display and internal state for subsequent input/output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_editing_allowed", "line_number": 1086, "body": "def _editing_allowed(self):\n        return get_runner() is not None", "is_method": true, "class_name": "BaseShellText", "function_description": "Indicates whether text editing is currently allowed within the shell context. It checks for the presence of an active shell runner."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_extract_submittable_input", "line_number": 1089, "body": "def _extract_submittable_input(self, input_text, tail):\n\n        if get_runner().is_waiting_toplevel_command():\n            if input_text.endswith(\"\\n\"):\n                if input_text.strip().startswith(\"%\") or input_text.strip().startswith(\"!\"):\n                    # if several magic command are submitted, then take only first\n                    return input_text[: input_text.index(\"\\n\") + 1]\n                elif self._code_is_ready_for_submission(input_text, tail):\n                    return input_text\n                else:\n                    return None\n            else:\n                return None\n\n        elif get_runner().is_running():\n            i = 0\n            while True:\n                if i >= len(input_text):\n                    return None\n                elif input_text[i] == \"\\n\":\n                    return input_text[: i + 1]\n                else:\n                    i += 1\n\n        return None", "is_method": true, "class_name": "BaseShellText", "function_description": "Extracts a complete, executable command or input block from the current text buffer. It determines submittability based on the shell's execution state, handling single or multi-line code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_code_is_ready_for_submission", "line_number": 1115, "body": "def _code_is_ready_for_submission(self, source, tail=\"\"):\n        # Ready to submit if ends with empty line\n        # or is complete single-line code\n\n        if tail.strip() != \"\":\n            return False\n\n        # First check if it has unclosed parens, unclosed string or ending with : or \\\n        parser = roughparse.RoughParser(self.indent_width, self.tabwidth)\n        parser.set_str(source.rstrip() + \"\\n\")\n        if parser.get_continuation_type() != roughparse.C_NONE or parser.is_block_opener():\n            return False\n\n        # Multiline compound statements need to end with empty line to be considered\n        # complete.\n        lines = source.splitlines()\n        # strip starting empty and comment lines\n        while len(lines) > 0 and (lines[0].strip().startswith(\"#\") or lines[0].strip() == \"\"):\n            lines.pop(0)\n\n        compound_keywords = [\"if\", \"while\", \"for\", \"with\", \"try\", \"def\", \"class\", \"async\", \"await\"]\n        if len(lines) > 0:\n            first_word = lines[0].strip().split()[0]\n            if first_word in compound_keywords and not source.replace(\" \", \"\").replace(\n                \"\\t\", \"\"\n            ).endswith(\"\\n\\n\"):\n                # last line is not empty\n                return False\n\n        return True", "is_method": true, "class_name": "BaseShellText", "function_description": "This method of `BaseShellText` determines if a Python code snippet is syntactically complete and ready for submission. It checks for proper termination and balanced syntax, useful for interactive shell environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_submit_input", "line_number": 1146, "body": "def _submit_input(self, text_to_be_submitted):\n        logging.debug(\n            \"SHELL: submitting %r in state %s\", text_to_be_submitted, get_runner().get_state()\n        )\n        if get_runner().is_waiting_toplevel_command():\n            # register in history and count\n            if text_to_be_submitted in self._command_history:\n                self._command_history.remove(text_to_be_submitted)\n            self._command_history.append(text_to_be_submitted)\n\n            # meaning command selection is not in process\n            self._command_history_current_index = None\n\n            self.update_tty_mode()\n\n            cmd_line = text_to_be_submitted.strip()\n            try:\n                if cmd_line.startswith(\"%\"):\n                    parts = cmd_line.split(\" \", maxsplit=1)\n                    if len(parts) == 2:\n                        args_str = parts[1].strip()\n                    else:\n                        args_str = \"\"\n                    argv = parse_cmd_line(cmd_line[1:])\n                    command_name = argv[0]\n                    cmd_args = argv[1:]\n\n                    if len(cmd_args) >= 2 and cmd_args[0] == \"-c\":\n                        # move source argument to source attribute\n                        source = cmd_args[1]\n                        cmd_args = [cmd_args[0]] + cmd_args[2:]\n                        if source == EDITOR_CONTENT_TOKEN:\n                            source = (\n                                get_workbench().get_editor_notebook().get_current_editor_content()\n                            )\n                    else:\n                        source = None\n\n                    get_workbench().event_generate(\"MagicCommand\", cmd_line=text_to_be_submitted)\n                    get_runner().send_command(\n                        ToplevelCommand(\n                            command_name,\n                            args=cmd_args,\n                            args_str=args_str,\n                            cmd_line=cmd_line,\n                            tty_mode=self.tty_mode,\n                            source=source,\n                        )\n                    )\n                elif cmd_line.startswith(\"!\"):\n                    argv = parse_cmd_line(cmd_line[1:])\n                    get_workbench().event_generate(\"SystemCommand\", cmd_line=text_to_be_submitted)\n                    get_runner().send_command(\n                        ToplevelCommand(\n                            \"execute_system_command\",\n                            argv=argv,\n                            cmd_line=cmd_line,\n                            tty_mode=self.tty_mode,\n                        )\n                    )\n                else:\n                    get_runner().send_command(\n                        ToplevelCommand(\n                            \"execute_source\", source=text_to_be_submitted, tty_mode=self.tty_mode\n                        )\n                    )\n\n                # remember the place where the output of this command started\n                self.mark_set(\"command_io_start\", \"output_insert\")\n                self.mark_gravity(\"command_io_start\", \"left\")\n                # discard old io events\n                self._applied_io_events = []\n                self._queued_io_events = []\n            except Exception:\n                get_workbench().report_exception()\n                self._insert_prompt()\n\n            get_workbench().event_generate(\"ShellCommand\", command_text=text_to_be_submitted)\n        else:\n            assert get_runner().is_running()\n            get_runner().send_program_input(text_to_be_submitted)\n            get_workbench().event_generate(\"ShellInput\", input_text=text_to_be_submitted)\n            self._applied_io_events.append((text_to_be_submitted, \"stdin\"))", "is_method": true, "class_name": "BaseShellText", "function_description": "This method processes user text input from the shell, dispatching it as shell commands (magic/system), Python code, or interactive program input based on the shell's current state. It enables users to interact with the shell environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_arrow_up", "line_number": 1230, "body": "def _arrow_up(self, event):\n        if not get_runner().is_waiting_toplevel_command():\n            return None\n\n        if not self._in_current_input_range(\"insert\"):\n            return None\n\n        insert_line = index2line(self.index(\"insert\"))\n        input_start_line = index2line(self.index(\"input_start\"))\n        if insert_line != input_start_line:\n            # we're in the middle of a multiline command\n            return None\n\n        if len(self._command_history) == 0 or self._command_history_current_index == 0:\n            # can't take previous command\n            return \"break\"\n\n        if self._command_history_current_index is None:\n            self._command_history_current_index = len(self._command_history) - 1\n        else:\n            self._command_history_current_index -= 1\n\n        cmd = self._command_history[self._command_history_current_index]\n        if cmd[-1] == \"\\n\":\n            cmd = cmd[:-1]  # remove the submission linebreak\n        self._propose_command(cmd)\n        return \"break\"", "is_method": true, "class_name": "BaseShellText", "function_description": "Retrieves and displays the previously entered command from the shell's history. This method enables users to cycle through past commands using the up arrow key."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_arrow_down", "line_number": 1258, "body": "def _arrow_down(self, event):\n        if not get_runner().is_waiting_toplevel_command():\n            return None\n\n        if not self._in_current_input_range(\"insert\"):\n            return None\n\n        insert_line = index2line(self.index(\"insert\"))\n        last_line = index2line(self.index(\"end-1c\"))\n        if insert_line != last_line:\n            # we're in the middle of a multiline command\n            return None\n\n        if (\n            len(self._command_history) == 0\n            or self._command_history_current_index is None\n            or self._command_history_current_index >= len(self._command_history) - 1\n        ):\n            # can't take next command\n            self._command_history_current_index = len(self._command_history)\n            self._propose_command(\"\")\n            return \"break\"\n\n        if self._command_history_current_index is None:\n            self._command_history_current_index = len(self._command_history) - 1\n        else:\n            self._command_history_current_index += 1\n\n        self._propose_command(\n            self._command_history[self._command_history_current_index].strip(\"\\n\")\n        )\n        return \"break\"", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles the down arrow key press to navigate forward through the command history. It retrieves and displays the next historical command in the shell's input area for potential re-execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_propose_command", "line_number": 1291, "body": "def _propose_command(self, cmd_line):\n        self.delete(\"input_start\", \"end\")\n        self.intercept_insert(\"input_start\", cmd_line)\n        self.see(\"insert\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Replaces the current shell input with a specified command line. This allows the shell to propose or restore a command for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_clear_shell", "line_number": 1315, "body": "def _clear_shell(self):\n        end_index = self.index(\"output_end\")\n        self._clear_content(end_index)", "is_method": true, "class_name": "BaseShellText", "function_description": "Clears the shell's output content by identifying the 'output_end' marker. This prepares the shell's display area for new output or interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_backend_restart", "line_number": 1319, "body": "def _on_backend_restart(self, event=None):\n        # make sure dead values are not clickable anymore\n        self.tag_remove(\"value\", \"0.1\", \"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Clears interactive elements from the shell's text display after a backend restart. This ensures that 'dead' or invalid values are no longer clickable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "compute_smart_home_destination_index", "line_number": 1323, "body": "def compute_smart_home_destination_index(self):\n        \"\"\"Is used by EnhancedText\"\"\"\n\n        if self._in_current_input_range(\"insert\"):\n            # on input line, go to just after prompt\n            return \"input_start\"\n        else:\n            return super().compute_smart_home_destination_index()", "is_method": true, "class_name": "BaseShellText", "function_description": "This method determines the intelligent \"home\" position for text navigation within a shell environment. It adjusts the destination to the input line start if currently editing, otherwise defers to the parent."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_value_click", "line_number": 1332, "body": "def _value_click(self, event):\n        pos = \"@%d,%d\" % (event.x, event.y)\n        tags = self.tag_names(pos)\n        for tag in tags:\n            if tag.isnumeric() or tag[0] == \"-\" and tag[1:].isnumeric():\n                get_workbench().show_view(\"ObjectInspector\", set_focus=False)\n                get_workbench().update_idletasks()\n                get_workbench().event_generate(\"ObjectSelect\", object_id=int(tag))", "is_method": true, "class_name": "BaseShellText", "function_description": "Provides interactive object inspection within the shell text display. When a numeric tag representing an object ID is clicked, it opens the Object Inspector view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_handle_hyperlink", "line_number": 1352, "body": "def _handle_hyperlink(self, event):\n        import webbrowser\n\n        try:\n            line = self.get(\"insert linestart\", \"insert lineend\")\n            # Python stacktrace\n            matches = list(re.finditer(r'File \"(?P<file>[^\"]+)\", line (?P<line>\\d+)', line))\n            if not matches:\n                # Friendly traceback\n                matches = list(\n                    re.finditer(\n                        r\"\\b(?P<line>\\d+)\\b.+'(?P<file>[^\\']+\\.pyw?)'\", line, flags=re.IGNORECASE\n                    )\n                )\n\n            if len(matches) == 1:\n                filename = os.path.expanduser(matches[0].group(\"file\"))\n                lineno = int(matches[0].group(\"line\"))\n                if os.path.exists(filename) and os.path.isfile(filename):\n                    # TODO: better use events instead direct referencing\n                    get_workbench().get_editor_notebook().show_file(\n                        filename, lineno, set_focus=False\n                    )\n            else:\n                r = self.tag_prevrange(\"io_hyperlink\", \"@%d,%d\" % (event.x, event.y))\n                if r and len(r) == 2:\n                    url = self.get(r[0], r[1])\n                    if SIMPLE_URL_SPLIT_REGEX.match(url):\n                        webbrowser.open(url)\n\n        except Exception as e:\n            logger.exception(\"Could not handle hyperlink click\", exc_info=e)", "is_method": true, "class_name": "BaseShellText", "function_description": "This method makes shell output interactive by handling clicks. It opens source files from tracebacks in the editor or launches detected URLs in a web browser."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_show_user_exception", "line_number": 1385, "body": "def _show_user_exception(self, user_exception):\n        for line, frame_id, *_ in user_exception[\"items\"]:\n\n            tags = (\"io\", \"stderr\")\n            if frame_id is not None:\n                frame_tag = \"frame_%d\" % frame_id\n\n                def handle_frame_click(event, frame_id=frame_id):\n                    get_runner().send_command(InlineCommand(\"get_frame_info\", frame_id=frame_id))\n                    return \"break\"\n\n                # TODO: put first line with frame tag and rest without\n                tags += (frame_tag,)\n                self.tag_bind(frame_tag, \"<ButtonRelease-1>\", handle_frame_click, True)\n\n            self._insert_text_directly(line, tags)", "is_method": true, "class_name": "BaseShellText", "function_description": "Displays user exceptions (tracebacks) in the shell's text area, enabling interactive retrieval of detailed information for individual traceback frames."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_discard_old_content", "line_number": 1402, "body": "def _discard_old_content(self):\n        max_lines = max(get_workbench().get_option(\"shell.max_lines\"), 0)\n        proposed_cut = self.index(\"end -%d lines linestart\" % max_lines)\n        if proposed_cut == \"1.0\":\n            return\n\n        # would this keep current block intact?\n        next_prompt = self.tag_nextrange(\"prompt\", proposed_cut, \"end\")\n        if not next_prompt:\n            pass  # TODO: disable stepping back\n\n        self._clear_content(proposed_cut)", "is_method": true, "class_name": "BaseShellText", "function_description": "Discards old content from the shell's text buffer to maintain a maximum line limit. It prevents excessive memory usage and aims to keep the current command block intact."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_clear_content", "line_number": 1415, "body": "def _clear_content(self, cut_idx):\n        proposed_cut_float = float(cut_idx)\n        for btn in list(self._squeeze_buttons):\n            try:\n                idx = self.index(btn)\n                if idx is None or idx == \"\" or float(idx) < proposed_cut_float:\n                    self._squeeze_buttons.remove(btn)\n                    # looks like the widgets are not fully GC-d.\n                    # At least avoid leaking big chunks of texts\n                    btn.contained_text = None\n                    btn.destroy()\n            except Exception as e:\n                logger.warning(\"Problem with a squeeze button, removing it\", exc_info=e)\n                if btn in self._squeeze_buttons:\n                    self._squeeze_buttons.remove(btn)\n\n        self.direct_delete(\"0.1\", cut_idx)", "is_method": true, "class_name": "BaseShellText", "function_description": "Clears text content and disposes of associated interactive \"squeeze buttons\" from the beginning of the display up to a specified index. This manages and prunes the shell's output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_mouse_move", "line_number": 1433, "body": "def _on_mouse_move(self, event=None):\n        tags = self.tag_names(\"@%d,%d\" % (event.x, event.y))\n        if \"value\" in tags or \"io_hyperlink\" in tags:\n            if self.cget(\"cursor\") != \"hand2\":\n                self.config(cursor=\"hand2\")\n        else:\n            if self.cget(\"cursor\"):\n                self.config(cursor=\"\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Adjusts the mouse cursor within the text widget to indicate interactive elements. It changes to a hand pointer when hovering over \"value\" or \"io_hyperlink\" regions, suggesting clickability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_invalidate_current_data", "line_number": 1442, "body": "def _invalidate_current_data(self):\n        \"\"\"\n        Grayes out input & output displayed so far\n        \"\"\"\n        end_index = self.index(\"output_end\")\n\n        self.tag_add(\"inactive\", \"1.0\", end_index)\n        self.tag_remove(\"value\", \"1.0\", end_index)\n\n        while len(self.active_extra_tags) > 0:\n            self.tag_remove(self.active_extra_tags.pop(), \"1.0\", \"end\")", "is_method": true, "class_name": "BaseShellText", "function_description": "This method visually deactivates all previously displayed input and output within the shell text area. It applies an 'inactive' visual style and clears all active formatting tags."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "get_lines_above_viewport_bottom", "line_number": 1454, "body": "def get_lines_above_viewport_bottom(self, tag_name, n):\n        end_index = self.index(\"@%d,%d lineend\" % (self.winfo_height(), self.winfo_height()))\n        start_index = self.index(end_index + \" -50 lines\")\n\n        result = \"\"\n        while True:\n            r = self.tag_nextrange(tag_name, start_index, end_index)\n            if not r:\n                break\n            result += self.get(r[0], r[1])\n            start_index = r[1]\n\n        return result", "is_method": true, "class_name": "BaseShellText", "function_description": "Retrieves all text segments marked with a specified tag that are located within the last 50 lines of the text area's visible viewport. This enables capturing recently displayed or relevant content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_tty_mode", "line_number": 1468, "body": "def update_tty_mode(self):\n        self.tty_mode = get_workbench().get_option(\"shell.tty_mode\")", "is_method": true, "class_name": "BaseShellText", "function_description": "Updates the shell's TTY mode setting by fetching the current `shell.tty_mode` option from the workbench configuration. This synchronizes the shell's behavior with application settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "set_syntax_options", "line_number": 1471, "body": "def set_syntax_options(self, syntax_options):\n        super().set_syntax_options(syntax_options)\n        self.update_margin_color()", "is_method": true, "class_name": "BaseShellText", "function_description": "Configures the display settings for text syntax within the BaseShellText. It also ensures the margin color is updated to maintain visual consistency."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_margin_color", "line_number": 1475, "body": "def update_margin_color(self):\n        if ui_utils.get_tk_version_info() >= (8, 6, 6):\n            self.tag_configure(\"io\", lmargincolor=get_syntax_options_for_tag(\"TEXT\")[\"background\"])", "is_method": true, "class_name": "BaseShellText", "function_description": "Updates the left margin color for 'io' (input/output) text regions within the `BaseShellText` widget, improving visual differentiation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_hide_trailing_output", "line_number": 1479, "body": "def _hide_trailing_output(self, msg):\n        pos = self.search(msg.text, index=\"end\", backwards=True)\n        if pos:\n            end_pos = self.index(\"%s + %d chars\" % (pos, len(msg.text)))\n            if end_pos == self.index(\"output_end\"):\n                self.direct_delete(pos, end_pos)", "is_method": true, "class_name": "BaseShellText", "function_description": "Removes a specific message's text if it appears as the trailing output in the shell's text buffer. This prevents redundant display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_wrap_changed", "line_number": 1579, "body": "def _on_wrap_changed(self):\n        if self._wrap_var.get():\n            self.text_frame.text.configure(wrap=\"word\")\n        else:\n            self.text_frame.text.configure(wrap=\"none\")", "is_method": true, "class_name": "SqueezedTextDialog", "function_description": "This method toggles text wrapping within the dialog's text display. It allows users to enable or disable word wrapping based on a user preference."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_expand", "line_number": 1585, "body": "def _on_expand(self):\n        index = self.shell_text.index(self.button)\n        self.shell_text.direct_delete(index, index + \" +1 chars\")\n        self.shell_text.direct_insert(index, self.content, tuple(self.button.tags))\n        self.destroy()\n\n        # looks like the widgets are not fully GC-d.\n        # At least avoid leaking big chunks of texts\n        self.button.contained_text = None\n        self.button.destroy()", "is_method": true, "class_name": "SqueezedTextDialog", "function_description": "Expands previously squeezed text by replacing a placeholder with its full content in a text display. It then cleans up the dialog and its components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_copy", "line_number": 1596, "body": "def _on_copy(self):\n        self.clipboard_clear()\n        self.clipboard_append(self.content)", "is_method": true, "class_name": "SqueezedTextDialog", "function_description": "Copies the dialog's text content to the system clipboard."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_on_close", "line_number": 1600, "body": "def _on_close(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "SqueezedTextDialog", "function_description": "Closes and destroys the dialog window, typically triggered by a close event, removing it from display and memory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "create_close_button", "line_number": 1669, "body": "def create_close_button(self):\n        self.close_img = get_workbench().get_image(\"tab-close\")\n        self.close_active_img = get_workbench().get_image(\"tab-close-active\")\n\n        self.close_rect = self.create_rectangle(\n            self.winfo_width() - self.close_img.width() - self.linespace,\n            self.linespace / 2,\n            self.winfo_width(),\n            self.linespace / 2 + self.close_img.height(),\n            fill=self.background,\n            width=0,\n            tags=(\"close\",),\n        )\n\n        self.close_button = self.create_image(\n            self.winfo_width() - self.linespace / 2,\n            self.linespace / 2,\n            anchor=\"ne\",\n            image=self.close_img,\n            activeimage=self.close_active_img,\n            tags=(\"close\",),\n        )\n\n        self.tag_bind(\"close\", \"<1>\", self.on_close)", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Creates and positions a clickable close button on the canvas. This UI element enables users to initiate a close action."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_close_button", "line_number": 1694, "body": "def update_close_button(self):\n        self.coords(\n            self.close_rect,\n            self.winfo_width() - self.close_img.width() - self.linespace / 1.5,\n            self.linespace / 2,\n            self.winfo_width() - self.linespace / 2,\n            self.linespace / 2 + self.close_img.height(),\n        )\n        self.coords(self.close_button, self.winfo_width() - self.linespace / 2, self.linespace / 2)", "is_method": true, "class_name": "PlotterCanvas", "function_description": "This method dynamically updates the position of the close button and its bounding rectangle on the canvas. It ensures the button remains correctly placed within the canvas's current dimensions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "on_close", "line_number": 1704, "body": "def on_close(self, event):\n        self.master.toggle_plotter()", "is_method": true, "class_name": "PlotterCanvas", "function_description": "This method serves as an event handler for the plotter canvas's close event. It notifies the master object to toggle or manage the plotter's display state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "reset_range", "line_number": 1707, "body": "def reset_range(self, event=None):\n        self.fresh_range = True", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Signals that the plotter's display range should be re-evaluated. This allows the plot to automatically adjust its axis limits."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "get_num_steps", "line_number": 1710, "body": "def get_num_steps(self):\n        return 30", "is_method": true, "class_name": "PlotterCanvas", "function_description": "This method provides a fixed value of 30. It likely serves as a default configuration for the number of steps used in plotting or rendering operations by the PlotterCanvas."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_plot", "line_number": 1713, "body": "def update_plot(self, force_clean=False):\n        data_lines = []\n        bottom_index = self.text.index(\n            \"@%d,%d\" % (self.text.winfo_width(), self.text.winfo_height())\n        )\n        bottom_lineno = int(float(bottom_index))\n\n        for i in range(bottom_lineno - self.get_num_steps(), bottom_lineno + 1):\n            line_start_index = \"%d.0\" % i\n            if i < 1 or \"stdout\" not in self.text.tag_names(line_start_index):\n                data_lines.append(([], []))\n            else:\n                content = self.text.get(line_start_index, line_start_index + \" lineend\")\n                data_lines.append(self.extract_pattern_and_numbers(content))\n\n        # data_lines need to be transposed\n        segments_by_color = []\n        for i in range(100):\n            segments = list(self.extract_series_segments(data_lines, i))\n            if segments:\n                segments_by_color.append(segments)\n            else:\n                break\n\n        self.delete(\"segment\")\n\n        self.update_range(segments_by_color, force_clean)\n        segment_count = self.draw_segments(segments_by_color)\n        self.update_legend(data_lines, force_clean)\n\n        self.delete(\"info\")\n        if segment_count == 0:\n            info_text = (\n                tr(\"Plotter visualizes series of\\n\" + \"numbers printed to the Shell.\")\n                + \"\\n\\n\"\n                + tr(\"See Help for details.\")\n            )\n\n            self.create_text_with_background(\n                self.winfo_width() / 2,\n                self.winfo_height() / 2,\n                text=info_text,\n                anchor=\"center\",\n                justify=\"center\",\n                tags=(\"info\",),\n            )\n            # self.delete(\"guide\", \"tick\", \"legend\")\n            # self.range_start = 0\n            # self.range_end = 0\n            self.tag_raise(\"info\")\n\n        self.fresh_range = False", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Updates the canvas by extracting numerical data series from the text output and rendering them as a plot. It also manages the plot's legend and info messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_legend", "line_number": 1766, "body": "def update_legend(self, data_lines, force_clean=False):\n        legend = None\n        i = len(data_lines) - 2  # one before last\n        while i >= 0:\n            legend = data_lines[i][0]\n            if legend and legend == data_lines[i + 1][0]:\n                # found last legend, which covers at least 2 consecutive points\n                break\n            i -= 1\n\n        if self.last_legend == legend and not force_clean:\n            # just make sure it remains topmost\n            self.tag_raise(\"legend\")\n            return\n\n        self.delete(\"legend\")\n\n        if legend is None:\n            return\n\n        # add horizontal padding\n        # legend[0] = \" \" + legend[0]\n        # legend[-1] = legend[-1] + \" \"\n\n        marker = \"\u25cf\"  # \"\u25cf\" \"\u2022\"\n        marker_width = self.font.measure(marker)\n        full_text_width = self.font.measure(marker.join(legend))\n\n        y = self.winfo_height() - self.linespace // 2\n        x = self.winfo_width() - full_text_width - self.linespace\n\n        self.create_rectangle(\n            x - self.linespace // 4,\n            y - self.linespace,\n            x + full_text_width + self.linespace // 4,\n            y,\n            fill=self.background,\n            width=0,\n            tags=(\"legend\",),\n        )\n\n        for i, part in enumerate(legend):\n            if i > 0:\n                self.create_text(\n                    x,\n                    y,\n                    text=marker,\n                    anchor=\"sw\",\n                    fill=self.colors[(i - 1) % len(self.colors)],\n                    tags=(\"legend\",),\n                )\n                x += marker_width\n\n            self.create_text(x, y, text=part, anchor=\"sw\", tags=(\"legend\",), fill=self.foreground)\n            x += self.font.measure(part)\n\n        self.last_legend = legend", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Manages and renders a dynamic legend on the plotter canvas. It identifies the legend content from data and displays it with appropriate markers and colors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "draw_segments", "line_number": 1824, "body": "def draw_segments(self, segments_by_color):\n        count = 0\n        for color, segments in enumerate(segments_by_color):\n            for pos, nums in segments:\n                self.draw_segment(color, pos, nums)\n                count += 1\n\n        # raise certain elements above segments\n        self.tag_raise(\"tick\")\n        self.tag_raise(\"close\")\n        return count", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Draws all specified segments on the canvas, organized by color. It then raises specific overlay elements (\"tick\", \"close\") to ensure they are visible above the drawn segments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "draw_segment", "line_number": 1836, "body": "def draw_segment(self, color, pos, nums):\n\n        x = self.x_padding_left + pos * self.x_scale\n\n        args = []\n        for num in nums:\n            y = self.y_padding + (self.range_end - num) * self.y_scale\n            args.extend([x, y])\n            x += self.x_scale\n\n        self.create_line(\n            *args,\n            width=2,\n            fill=self.colors[color % len(self.colors)],\n            tags=(\"segment\",),\n            # arrow may be confusing\n            # and doesn't play nice with distinguising between\n            # scrollback view and fresh_range view\n            # arrow=\"last\",\n            # arrowshape=(3,5,3)\n        )", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Draws a continuous line segment on the canvas from a sequence of numerical data points. It scales and positions these points to visualize data within the plotter's range."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_range", "line_number": 1859, "body": "def update_range(self, segments_by_color, clean):\n        if not segments_by_color:\n            return\n\n        range_start = 2 ** 15\n        range_end = -(2 ** 15)\n\n        # if new block is using 3/4 of the width,\n        # then don't consider old block's values anymore\n        interest_position = 0\n        for start_pos, nums in reversed(segments_by_color[0]):\n            if start_pos < self.get_num_steps() / 10:\n                interest_position = start_pos\n                break\n\n        assert isinstance(interest_position, int)\n        for segments in segments_by_color:\n            for start_pos, nums in segments:\n                if start_pos >= interest_position:\n                    range_start = min(range_start, *nums)\n                    range_end = max(range_end, *nums)\n\n        if interest_position == 0 and not self.fresh_range:\n            # meaning we still care about old line's values\n            range_start = min(range_start, self.range_start)\n            range_end = max(range_end, self.range_end)\n\n        if range_end == range_start:\n            range_end += 1\n\n        if (\n            not clean\n            and not self.fresh_range\n            and self.x_scale is not None\n            and range_end == self.range_end\n            and range_start == self.range_start\n        ):\n            # don't recompute as nothing was changed\n            return\n\n        value_range = range_end - range_start\n        range_block_size = value_range // 4\n        # prefer round blocks\n        for size in self.range_block_sizes:\n            if size * 4 >= value_range:\n                range_block_size = size\n                break\n\n        # extend to range block boundary\n        if range_end % range_block_size != 0:\n            range_end -= range_end % -range_block_size\n\n        if range_start % range_block_size != 0:\n            range_start -= range_start % range_block_size\n\n        # not sure about these assertions when using floats\n        # assert range_start % range_block_size == 0\n        # assert range_end % range_block_size == 0, \"range_end: %s, bs: %s\" % (range_end, range_block_size)\n\n        # remember\n        self.range_start = range_start\n        self.range_end = range_end\n        self.value_range = range_end - range_start\n        self.range_block_size = range_block_size\n\n        available_height = self.winfo_height() - 2 * self.y_padding\n        available_width = self.winfo_width() - self.x_padding_left - self.x_padding_right\n        num_steps = self.get_num_steps()\n\n        self.x_scale = available_width / (num_steps - 1)\n        self.y_scale = available_height / self.value_range\n\n        self.update_guides_and_ticks()", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Calculates and updates the display range and scaling factors for the canvas based on data segments. It optimizes for dynamic data, ensuring clean, aligned plot boundaries and efficient scaling for visualization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "update_guides_and_ticks", "line_number": 1933, "body": "def update_guides_and_ticks(self):\n        self.delete(\"guide\", \"tick\")\n        value = self.range_start\n        while value <= self.range_end:\n            y = self.y_padding + (self.range_end - value) * self.y_scale\n\n            # guide\n            self.create_line(\n                0, y, self.winfo_width(), y, tags=(\"guide\",), dash=(2, 2), fill=\"#aaaaaa\"\n            )\n\n            # tick\n            if value == int(value):\n                value = int(value)\n\n            caption = \" \" + str(value) + \" \"\n            self.create_text_with_background(\n                self.linespace // 2, y, caption, anchor=\"w\", tags=(\"tick\",)\n            )\n            value += self.range_block_size", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Updates and redraws horizontal guide lines and numerical tick labels on the plotter canvas. This ensures the visual representation of the plot's value range is current and accurate."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "extract_pattern_and_numbers", "line_number": 1954, "body": "def extract_pattern_and_numbers(self, line):\n        parts = NUMBER_SPLIT_REGEX.split(line)\n        if len(parts) < 2:\n            return ([], [])\n\n        assert len(parts) % 2 == 1\n\n        pattern = []\n        numbers = []\n        for i in range(0, len(parts), 2):\n            pattern.append(parts[i])\n\n        for i in range(1, len(parts), 2):\n            numbers.append(float(parts[i]))\n\n        return (pattern, numbers)", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Parses an input string to separate interleaved text patterns from numeric values. It provides structured data extraction, converting numeric parts to floats for subsequent use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "extract_series_segments", "line_number": 1971, "body": "def extract_series_segments(self, data_lines, series_nr):\n        \"\"\"Yields numbers which form connected multilines on graph\n        Each segment is pair of starting position and numbers\"\"\"\n        segment = (0, [])\n        prev_pattern = None\n        for i, (pattern, nums) in enumerate(data_lines):\n            if len(nums) <= series_nr or pattern != prev_pattern:\n                # break the segment\n                if len(segment[1]) > 1:\n                    yield segment\n                segment = (i, [])\n\n            if len(nums) > series_nr:\n                segment[1].append(nums[series_nr])\n\n            prev_pattern = pattern\n\n        if len(segment[1]) > 1:\n            yield segment", "is_method": true, "class_name": "PlotterCanvas", "function_description": "This method extracts continuous segments of a specified data series from input data lines. It yields these segments, typically for plotting, by identifying unbroken sequences of data points sharing the same pattern."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "create_text_with_background", "line_number": 1991, "body": "def create_text_with_background(\n        self, x, y, text, anchor=\"w\", justify=\"left\", background=None, tags=()\n    ):\n        if background is None:\n            background = self.background\n\n        width = 0\n        lines = text.splitlines()\n        for line in lines:\n            width = max(width, self.font.measure(line))\n\n        height = len(lines) * self.linespace\n\n        rect_x = x\n        rect_y = y\n        if anchor == \"center\":\n            rect_x = x - width / 2\n            rect_y = y - height / 2\n        elif anchor == \"w\":\n            rect_y = y - height / 2\n        else:\n            \"TODO:\"\n\n        self.create_rectangle(\n            rect_x, rect_y, rect_x + width, rect_y + height, fill=background, width=0, tags=tags\n        )\n        self.create_text(\n            x, y, anchor=anchor, text=text, tags=tags, fill=self.foreground, justify=justify\n        )", "is_method": true, "class_name": "PlotterCanvas", "function_description": "The method draws text onto the canvas with a customizable background rectangle. It automatically calculates text dimensions and supports various anchoring options for precise placement."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "reload_theme_options", "line_number": 2021, "body": "def reload_theme_options(self, event):\n        self.background = get_syntax_options_for_tag(\"TEXT\")[\"background\"]\n        self.foreground = get_syntax_options_for_tag(\"TEXT\")[\"foreground\"]\n        self.configure(background=self.background)\n        self.itemconfig(self.close_rect, fill=self.background)\n        self.update_plot(True)", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Reloads and applies the current visual theme's background and foreground colors to the PlotterCanvas. It updates the canvas elements and redraws the plot to reflect these new settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "on_resize", "line_number": 2028, "body": "def on_resize(self, event):\n        if self.winfo_width() > 10:\n            get_workbench().set_option(\"view.plotter_width\", self.winfo_width())\n        self.update_plot(True)\n        self.update_close_button()\n        self.master.resize_plotter()", "is_method": true, "class_name": "PlotterCanvas", "function_description": "Chain of Thought:\nThe `on_resize` method is an event handler for a `PlotterCanvas`. Its primary responsibility is to react when the canvas changes size. It updates a workbench setting with the new width, redraws the plot to fit the new dimensions, updates a close button, and informs its parent (`master`) about the resize. The core service is to ensure the plot and UI elements correctly adapt to the new canvas size.\nHandles the canvas resize event, updating the displayed plot and associated UI elements to fit the new dimensions. It also persists the new width and notifies its parent."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "can_toggle", "line_number": 143, "body": "def can_toggle():\n            return self.winfo_ismapped()", "is_method": true, "class_name": "ShellView", "function_description": "Determines if the `ShellView`'s associated window is currently visible, indicating it's in a state where a toggle operation (e.g., hiding it) is possible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "toggle_from_menu", "line_number": 283, "body": "def toggle_from_menu():\n            # I don't like that Tk menu toggles checbutton variable\n            # automatically before calling the handler.\n            # So I revert the toggle before calling the actual handler.\n            # This way the handler doesn't have to worry whether it\n            # needs to toggle the variable or not, and it can choose to\n            # decline the toggle.\n            self.view.plotter_visibility_var.set(not self.view.plotter_visibility_var.get())\n            self.view.toggle_plotter()", "is_method": true, "class_name": "ShellMenu", "function_description": "Provides a robust way to toggle the plotter's visibility, typically invoked by a menu item. It ensures the view's plotter state is controlled directly by its handler, overriding automatic menu behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_insert", "line_number": 986, "body": "def _insert(txt, tags):\n            if txt != \"\":\n                self.direct_insert(\"output_insert\", txt, tags)", "is_method": true, "class_name": "BaseShellText", "function_description": "Inserts non-empty text into the shell's output, applying specified tags. This method provides a controlled way to add content to the shell display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "_insert_and_highlight_urls", "line_number": 990, "body": "def _insert_and_highlight_urls(txt, tags):\n            parts = SIMPLE_URL_SPLIT_REGEX.split(txt)\n            for i, part in enumerate(parts):\n                if i % 2 == 0:\n                    _insert(part, tags)\n                else:\n                    if part.startswith(\"data:image/\"):\n                        token = \";base64,\"\n                        data = part[part.index(token) + len(token) :]\n                        try:\n                            img = tk.PhotoImage(data=data)\n                            self._images.add(img)  # to avoit it being gc-d\"\"\"\n                            self.image_create(\"output_insert\", image=img)\n                            for tag in tags:\n                                self.tag_add(tag, \"output_insert -1 chars\")\n                        except TclError:\n                            _insert(part, tags + (\"io_hyperlink\",))\n                    else:\n                        _insert(part, tags + (\"io_hyperlink\",))", "is_method": true, "class_name": "BaseShellText", "function_description": "Parses input text to insert plain content and format recognized URLs as hyperlinks. It also embeds images directly when encountering data image URIs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/shell.py", "function": "handle_frame_click", "line_number": 1392, "body": "def handle_frame_click(event, frame_id=frame_id):\n                    get_runner().send_command(InlineCommand(\"get_frame_info\", frame_id=frame_id))\n                    return \"break\"", "is_method": true, "class_name": "BaseShellText", "function_description": "Handles user clicks on a shell's text frame. It sends a command to retrieve detailed information about that specific frame for display or further action."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "escape", "line_number": 476, "body": "def escape(s):\n    return (\n        s.replace(\"\\\\\", \"\\\\\\\\\")\n        .replace(\"*\", \"\\\\*\")\n        .replace(\"`\", \"\\\\`\")\n        .replace(\"_\", \"\\\\_\")\n        .replace(\"..\", \"\\\\..\")\n    )", "is_method": false, "function_description": "Escapes specific special characters within a string by prepending a backslash. This prevents their interpretation as formatting in contexts like markup languages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "create_title", "line_number": 486, "body": "def create_title(text, line_symbol=\"=\"):\n    text = text.replace(\"\\r\\n\", \"\\n\").replace(\"\\n\", \" \").strip()\n    return text + \"\\n\" + line_symbol * len(text) + \"\\n\"", "is_method": false, "function_description": "Formats a text string into a console-friendly title by underlining it with a specified character. This provides a simple way to create visually distinct headings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "configure_tags", "line_number": 28, "body": "def configure_tags(self):\n        main_font = tk.font.nametofont(\"TkDefaultFont\")\n\n        bold_font = main_font.copy()\n        bold_font.configure(weight=\"bold\", size=main_font.cget(\"size\"))\n\n        italic_font = main_font.copy()\n        italic_font.configure(slant=\"italic\", size=main_font.cget(\"size\"))\n\n        h1_font = main_font.copy()\n        h1_font.configure(size=main_font.cget(\"size\") * 2, weight=\"bold\")\n\n        h2_font = main_font.copy()\n        h2_font.configure(size=round(main_font.cget(\"size\") * 1.5), weight=\"bold\")\n\n        h3_font = main_font.copy()\n        h3_font.configure(size=main_font.cget(\"size\"), weight=\"bold\")\n\n        small_font = main_font.copy()\n        small_font.configure(size=round(main_font.cget(\"size\") * 0.8))\n        small_italic_font = italic_font.copy()\n        small_italic_font.configure(size=round(main_font.cget(\"size\") * 0.8))\n\n        # Underline on font looks better than underline on tag\n        underline_font = main_font.copy()\n        underline_font.configure(underline=True)\n\n        self.tag_configure(\"h1\", font=h1_font, spacing3=5)\n        self.tag_configure(\"h2\", font=h2_font, spacing3=5)\n        self.tag_configure(\"h3\", font=h3_font, spacing3=5)\n        self.tag_configure(\"p\", spacing1=0, spacing3=10, spacing2=0)\n        self.tag_configure(\"line_block\", spacing1=0, spacing3=10, spacing2=0)\n        self.tag_configure(\"em\", font=italic_font)\n        self.tag_configure(\"strong\", font=bold_font)\n\n        # TODO: hyperlink syntax options may require different background as well\n        hyperlink_opts = get_syntax_options_for_tag(\"hyperlink\")\n        hyperlink_opts[\"underline\"] = False\n        hyperlink_opts[\"font\"] = underline_font\n        self.tag_configure(\"a\", **hyperlink_opts)\n\n        self.tag_configure(\"small\", font=small_font)\n        self.tag_configure(\"light\", foreground=\"gray\")\n        self.tag_configure(\"remark\", font=small_italic_font)\n        self.tag_bind(\"a\", \"<Enter>\", self._hyperlink_enter)\n        self.tag_bind(\"a\", \"<Leave>\", self._hyperlink_leave)\n\n        self.tag_configure(\"topic_title\", lmargin2=16, font=bold_font)\n        self.tag_configure(\"topic_body\", lmargin1=16, lmargin2=16)\n        self.tag_configure(\n            \"code\",\n            font=\"TkFixedFont\",\n            # wrap=\"none\", # TODO: needs automatic hor-scrollbar and better padding mgmt\n            # background=\"#eeeeee\"\n        )\n        # if ui_utils.get_tk_version_info() >= (8,6,6):\n        #    self.tag_configure(\"code\", lmargincolor=self[\"background\"])\n\n        for i in range(1, 6):\n            self.tag_configure(\"list%d\" % i, lmargin1=i * 10, lmargin2=i * 10 + 10)\n\n        toti_code_font = bold_font.copy()\n        toti_code_font.configure(\n            family=tk.font.nametofont(\"TkFixedFont\").cget(\"family\"), size=bold_font.cget(\"size\")\n        )\n        self.tag_configure(\"topic_title_code\", font=toti_code_font)\n        self.tag_raise(\"topic_title_code\", \"code\")\n        self.tag_raise(\"topic_title_code\", \"topic_title\")\n        self.tag_raise(\"a\", \"topic_title\")\n\n        # TODO: topic_title + em\n        self.tag_raise(\"em\", \"topic_title\")\n        self.tag_raise(\"a\", \"em\")\n        self.tag_raise(\"a\", \"topic_body\")\n        self.tag_raise(\"a\", \"topic_title\")\n\n        if ui_utils.get_tk_version_info() >= (8, 6, 6):\n            self.tag_configure(\"sel\", lmargincolor=self[\"background\"])\n        self.tag_raise(\"sel\")", "is_method": true, "class_name": "RstText", "function_description": "Initializes and configures the various text tags (e.g., headings, emphasis, links) within the RstText widget, defining their visual appearance and behavior for formatted text display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "clear", "line_number": 108, "body": "def clear(self):\n        self.direct_delete(\"1.0\", \"end\")", "is_method": true, "class_name": "RstText", "function_description": "Removes all text content from the RST text element. This effectively clears the display for new input or rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "load_rst", "line_number": 111, "body": "def load_rst(self, rst_source, global_tags=()):\n        self.clear()\n        self.append_rst(rst_source, global_tags)", "is_method": true, "class_name": "RstText", "function_description": "Clears existing content and loads new reStructuredText (`rst_source`) into the object. This method initializes or refreshes the object's RST content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "append_rst", "line_number": 115, "body": "def append_rst(self, rst_source, global_tags=()):\n        try:\n            import docutils.core\n\n            doc = docutils.core.publish_doctree(rst_source)\n            doc.walkabout(self.create_visitor(doc, global_tags))\n        except Exception:\n            self.direct_insert(\"end\", \"RST SOURCE:\\n\" + rst_source + \"\\n\\n\")\n            self.direct_insert(\"end\", traceback.format_exc())", "is_method": true, "class_name": "RstText", "function_description": "This method processes and appends reStructuredText (RST) source content to the `RstText` object using Docutils. It includes error handling, appending raw source and traceback upon failure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "create_visitor", "line_number": 129, "body": "def create_visitor(self, doc, global_tags=()):\n        # Pass unique tag count from previous visitor\n        # to keep uniqueness\n\n        if self._visitor is None:\n            unique_tag_count = 0\n        else:\n            unique_tag_count = self._visitor.unique_tag_count\n\n        import docutils.nodes\n\n        class TkTextRenderingVisitor(docutils.nodes.GenericNodeVisitor):\n            def __init__(self, document, text, global_tags=(), unique_tag_count=0):\n                super().__init__(document)\n\n                self._context_tags = list(global_tags)\n                self.text = text\n                self.section_level = 0\n                self.in_topic = False\n                self.in_paragraph = False\n                self.in_title = False\n\n                self.active_lists = []\n\n                self.unique_tag_count = unique_tag_count\n\n            def visit_document(self, node):\n                pass\n\n            def visit_Text(self, node):\n                self._append_text(self._node_to_text(node))\n\n            def visit_section(self, node):\n                self.section_level += 1\n\n            def depart_section(self, node):\n                self.section_level -= 1\n\n            def _get_title_tag(self):\n                if self.in_topic:\n                    return \"topic_title\"\n                else:\n                    return \"h%d\" % (self.section_level + 1)\n\n            def visit_title(self, node):\n                self.in_title = True\n                self._add_tag(self._get_title_tag())\n\n            def depart_title(self, node):\n                self.in_title = False\n                self._append_text(\"\\n\")\n                self._pop_tag(self._get_title_tag())\n\n            def visit_paragraph(self, node):\n                self.in_paragraph = True\n                if not self.active_lists:\n                    self._add_tag(\"p\")\n\n            def depart_paragraph(self, node):\n                self.in_paragraph = False\n                self._append_text(\"\\n\")\n                if not self.active_lists:\n                    self._pop_tag(\"p\")\n\n            def visit_line_block(self, node):\n                self._add_tag(\"line_block\")\n\n            def depart_line_block(self, node):\n                self._pop_tag(\"line_block\")\n\n            def visit_line(self, node):\n                pass\n\n            def depart_line(self, node):\n                self._append_text(\"\\n\")\n\n            def visit_topic(self, node):\n                self.in_topic = True\n\n                if \"toggle\" in node.attributes[\"classes\"]:\n                    return self._visit_toggle_topic(node)\n                elif \"empty\" in node.attributes[\"classes\"]:\n                    return self._visit_empty_topic(node)\n                else:\n                    return self.default_visit(node)\n\n            def _visit_toggle_topic(self, node):\n                tag = self._create_unique_tag()\n                title_id_tag = tag + \"_title\"\n                body_id_tag = tag + \"_body\"\n\n                def get_toggler_image_name(kind):\n                    if get_workbench().uses_dark_ui_theme():\n                        return kind + \"_light\"\n                    else:\n                        return kind\n\n                if \"open\" in node.attributes[\"classes\"]:\n                    initial_image = get_toggler_image_name(\"boxminus\")\n                    initial_elide = False\n                else:\n                    initial_image = get_toggler_image_name(\"boxplus\")\n                    initial_elide = True\n\n                label = tk.Label(\n                    self.text,\n                    image=get_workbench().get_image(initial_image),\n                    borderwidth=0,\n                    background=self.text[\"background\"],\n                    cursor=\"arrow\",\n                )\n\n                def toggle_body(event=None):\n                    elide = self.text.tag_cget(body_id_tag, \"elide\")\n                    if elide == \"1\":\n                        elide = True\n                    elif elide == \"0\":\n                        elide = False\n                    else:\n                        elide = bool(elide)\n\n                    elide = not elide\n\n                    self.text.tag_configure(body_id_tag, elide=elide)\n                    if self.text.has_selection():\n                        self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n\n                    if elide:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxplus\"))\n                        )\n                    else:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxminus\"))\n                        )\n\n                assert isinstance(node.children[0], docutils.nodes.title)\n\n                # self.text.tag_bind(title_id_tag, \"<1>\", toggle_body, True)\n                self._add_tag(title_id_tag)\n                self._append_window(label)\n                label.bind(\"<1>\", toggle_body, True)\n                node.children[0].walkabout(self)\n                self._pop_tag(title_id_tag)\n\n                self.text.tag_configure(body_id_tag, elide=initial_elide)\n                self._add_tag(body_id_tag)\n                self._add_tag(\"topic_body\")\n                for child in list(node.children)[1:]:\n                    child.walkabout(self)\n                self._pop_tag(\"topic_body\")\n                self._pop_tag(body_id_tag)\n\n                if \"tight\" not in node.attributes[\"classes\"]:\n                    self._append_text(\"\\n\")\n\n                raise docutils.nodes.SkipNode()\n\n            def _visit_empty_topic(self, node):\n                img = get_workbench().get_image(\n                    \"boxdot_light\" if get_workbench().uses_dark_ui_theme() else \"boxdot\"\n                )\n                label = tk.Label(\n                    self.text,\n                    image=img,\n                    borderwidth=0,\n                    background=self.text[\"background\"],\n                    cursor=\"arrow\",\n                )\n                self._append_window(label)\n                assert isinstance(node.children[0], docutils.nodes.title)\n                node.children[0].walkabout(self)\n\n                if \"tight\" not in node.attributes[\"classes\"]:\n                    self._append_text(\"\\n\")\n\n                raise docutils.nodes.SkipNode()\n\n            def depart_topic(self, node):\n                # only for non-toggle topics\n                self.in_topic = False\n                self._append_text(\"\\n\")\n\n            def visit_image(self, node):\n                self._append_image(node.attributes[\"uri\"])\n                if not self.in_paragraph and not self.in_title:\n                    self._append_text(\"\\n\")\n\n            def visit_reference(self, node):\n                tag = self._create_unique_tag()\n                node.unique_tag = tag\n                self._add_tag(\"a\")\n                self._add_tag(tag)\n\n                def handle_click(event):\n                    get_workbench().open_url(node.attributes[\"refuri\"])\n\n                self.text.tag_bind(tag, \"<ButtonRelease-1>\", handle_click)\n\n            def depart_reference(self, node):\n                self._pop_tag(\"a\")\n                self._pop_tag(node.unique_tag)\n\n            def visit_literal(self, node):\n                self._add_tag(\"code\")\n\n            def depart_literal(self, node):\n                self._pop_tag(\"code\")\n\n            def visit_inline(self, node):\n                for cls in node.attributes[\"classes\"]:\n                    self._add_tag(cls)\n\n            def depart_inline(self, node):\n                for cls in node.attributes[\"classes\"]:\n                    self._pop_tag(cls)\n\n            def visit_literal_block(self, node):\n                self._add_tag(\"code\")\n\n            def depart_literal_block(self, node):\n                self._pop_tag(\"code\")\n                self._append_text(\"\\n\\n\")\n\n            def visit_bullet_list(self, node):\n                self.active_lists.append(node.attributes[\"bullet\"])\n\n            def depart_bullet_list(self, node):\n                self._append_text(\"\\n\")\n                self.active_lists.pop()\n\n            def visit_enumerated_list(self, node):\n                self.active_lists.append(node.attributes[\"enumtype\"])\n\n            def depart_enumerated_list(self, node):\n                self._append_text(\"\\n\")\n                self.active_lists.pop()\n\n            def visit_list_item(self, node):\n                if self.active_lists[-1] == \"*\":\n                    self._append_text(\"\u2022 \")\n                elif self.active_lists[-1] == \"arabic\":\n                    for i, sib in enumerate(node.parent.children):\n                        if sib is node:\n                            self._append_text(\"%d. \" % (i + 1))\n                            break\n\n            def visit_note(self, node):\n                self._add_tag(\"em\")\n\n            def depart_note(self, node):\n                self._pop_tag(\"em\")\n\n            def visit_target(self, node):\n                pass\n\n            def visit_substitution_definition(self, node):\n                raise docutils.nodes.SkipNode()\n\n            def visit_system_message(self, node):\n                logger.warning(\"docutils message: '%s'. Context: %s\" % (node.astext(), node.parent))\n                raise docutils.nodes.SkipNode\n\n            def visit_emphasis(self, node):\n                self._add_tag(\"em\")\n\n            def depart_emphasis(self, node):\n                self._pop_tag(\"em\")\n\n            def visit_strong(self, node):\n                self._add_tag(\"strong\")\n\n            def depart_strong(self, node):\n                self._pop_tag(\"strong\")\n\n            def visit_block_quote(self, node):\n                self._add_tag(\"code\")\n\n            def depart_block_quote(self, node):\n                self._pop_tag(\"code\")\n\n            def default_visit(self, node):\n                self._append_text(self._node_to_text(node))\n                print(\"skipping children\", type(node), node)\n                raise docutils.nodes.SkipChildren()\n\n            def default_departure(self, node):\n                # Pass all other nodes through.\n                pass\n\n            def _create_unique_tag(self):\n                self.unique_tag_count += 1\n                return \"_UT_%s\" % self.unique_tag_count\n\n            def _node_to_text(self, node):\n                if node.parent.attributes.get(\"xml:space\") == \"preserve\":\n                    return node.astext()\n                else:\n                    return node.astext().replace(\"\\r\", \"\").replace(\"\\n\", \" \")\n\n            def _add_tag(self, tag):\n                self._context_tags.append(tag)\n\n            def _pop_tag(self, tag):\n                self._context_tags.remove(tag)\n\n            def _append_text(self, chars, extra_tags=()):\n                # print(\"APPP\", chars, tags)\n                self.text.direct_insert(\"end\", chars, self._get_effective_tags(extra_tags))\n\n            def _append_image(self, name, extra_tags=()):\n                index = self.text.index(\"end-1c\")\n                self.text.image_create(index, image=get_workbench().get_image(name))\n                for tag in self._get_effective_tags(extra_tags):\n                    self.text.tag_add(tag, index)\n\n            def _append_window(self, window, extra_tags=()):\n                index = self.text.index(\"end-1c\")\n                self.text.window_create(index, window=window)\n                for tag in self._get_effective_tags(extra_tags):\n                    self.text.tag_add(tag, index)\n\n            def _get_effective_tags(self, extra_tags):\n                tags = set(extra_tags) | set(self._context_tags)\n\n                if self.active_lists:\n                    tags.add(\"list%d\" % min(len(self.active_lists), 5))\n\n                # combine tags\n                if \"code\" in tags and \"topic_title\" in tags:\n                    tags.remove(\"code\")\n                    tags.remove(\"topic_title\")\n                    tags.add(\"topic_title_code\")\n\n                return tuple(sorted(tags))\n\n        self._visitor = TkTextRenderingVisitor(doc, self, global_tags, unique_tag_count)\n\n        return self._visitor", "is_method": true, "class_name": "RstText", "function_description": "Provides a visitor object for the `RstText` class that renders `docutils` reStructuredText documents into a Tkinter text widget, applying formatting and handling interactive elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_hyperlink_enter", "line_number": 469, "body": "def _hyperlink_enter(self, event):\n        self.config(cursor=\"hand2\")", "is_method": true, "class_name": "RstText", "function_description": "This method provides visual feedback by changing the mouse cursor to a hand icon. It indicates that the cursor has entered an interactive element, typically a hyperlink, within an RstText widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_hyperlink_leave", "line_number": 472, "body": "def _hyperlink_leave(self, event):\n        self.config(cursor=\"\")", "is_method": true, "class_name": "RstText", "function_description": "This method resets the cursor to its default appearance when the mouse leaves a hyperlink. It ensures proper visual feedback for user interaction within the text display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_Text", "line_number": 158, "body": "def visit_Text(self, node):\n                self._append_text(self._node_to_text(node))", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Incorporates the textual content from a 'Text' node into the ongoing Tkinter text rendering output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_section", "line_number": 161, "body": "def visit_section(self, node):\n                self.section_level += 1", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This method tracks the current depth of document sections within the visitor. It increments the section level counter, indicating entry into a new, deeper section."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_section", "line_number": 164, "body": "def depart_section(self, node):\n                self.section_level -= 1", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Decrements the internal section level counter. This method helps maintain the correct hierarchical context when exiting a document section during text rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_get_title_tag", "line_number": 167, "body": "def _get_title_tag(self):\n                if self.in_topic:\n                    return \"topic_title\"\n                else:\n                    return \"h%d\" % (self.section_level + 1)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Determines the appropriate rendering tag for a title or heading, based on whether it's a topic title or a specific section level."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_title", "line_number": 173, "body": "def visit_title(self, node):\n                self.in_title = True\n                self._add_tag(self._get_title_tag())", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Prepares the Tkinter text rendering for a title node, setting an internal state and applying the specific formatting tag for titles."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_title", "line_number": 177, "body": "def depart_title(self, node):\n                self.in_title = False\n                self._append_text(\"\\n\")\n                self._pop_tag(self._get_title_tag())", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This method finalizes the rendering of a title block by the visitor. It ensures proper formatting separation in the text output by adding a newline and removing the title's display tag."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_paragraph", "line_number": 182, "body": "def visit_paragraph(self, node):\n                self.in_paragraph = True\n                if not self.active_lists:\n                    self._add_tag(\"p\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Manages the rendering of paragraph nodes by setting an internal state. It applies specific formatting, adding a paragraph tag unless the paragraph is within an active list."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_paragraph", "line_number": 187, "body": "def depart_paragraph(self, node):\n                self.in_paragraph = False\n                self._append_text(\"\\n\")\n                if not self.active_lists:\n                    self._pop_tag(\"p\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This method concludes the processing of a paragraph node, adding a newline for formatting. It manages paragraph tags unless nested within a list structure, ensuring correct text layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_line_block", "line_number": 193, "body": "def visit_line_block(self, node):\n                self._add_tag(\"line_block\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "As part of a Tkinter rendering process, this method applies a 'line_block' tag to text nodes, enabling specific formatting for text blocks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_line_block", "line_number": 196, "body": "def depart_line_block(self, node):\n                self._pop_tag(\"line_block\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This method concludes the rendering context for a \"line block\" by removing its associated formatting tag, ensuring proper style application within a Tkinter text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_line", "line_number": 202, "body": "def depart_line(self, node):\n                self._append_text(\"\\n\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This method appends a newline character to the text being rendered. It ensures proper line breaks are inserted into the final output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_topic", "line_number": 205, "body": "def visit_topic(self, node):\n                self.in_topic = True\n\n                if \"toggle\" in node.attributes[\"classes\"]:\n                    return self._visit_toggle_topic(node)\n                elif \"empty\" in node.attributes[\"classes\"]:\n                    return self._visit_empty_topic(node)\n                else:\n                    return self.default_visit(node)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This method processes a 'topic' node, dispatching to specific rendering functions based on its class attributes (e.g., 'toggle', 'empty') or using a default approach. It manages the rendering of various topic types."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_visit_toggle_topic", "line_number": 215, "body": "def _visit_toggle_topic(self, node):\n                tag = self._create_unique_tag()\n                title_id_tag = tag + \"_title\"\n                body_id_tag = tag + \"_body\"\n\n                def get_toggler_image_name(kind):\n                    if get_workbench().uses_dark_ui_theme():\n                        return kind + \"_light\"\n                    else:\n                        return kind\n\n                if \"open\" in node.attributes[\"classes\"]:\n                    initial_image = get_toggler_image_name(\"boxminus\")\n                    initial_elide = False\n                else:\n                    initial_image = get_toggler_image_name(\"boxplus\")\n                    initial_elide = True\n\n                label = tk.Label(\n                    self.text,\n                    image=get_workbench().get_image(initial_image),\n                    borderwidth=0,\n                    background=self.text[\"background\"],\n                    cursor=\"arrow\",\n                )\n\n                def toggle_body(event=None):\n                    elide = self.text.tag_cget(body_id_tag, \"elide\")\n                    if elide == \"1\":\n                        elide = True\n                    elif elide == \"0\":\n                        elide = False\n                    else:\n                        elide = bool(elide)\n\n                    elide = not elide\n\n                    self.text.tag_configure(body_id_tag, elide=elide)\n                    if self.text.has_selection():\n                        self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n\n                    if elide:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxplus\"))\n                        )\n                    else:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxminus\"))\n                        )\n\n                assert isinstance(node.children[0], docutils.nodes.title)\n\n                # self.text.tag_bind(title_id_tag, \"<1>\", toggle_body, True)\n                self._add_tag(title_id_tag)\n                self._append_window(label)\n                label.bind(\"<1>\", toggle_body, True)\n                node.children[0].walkabout(self)\n                self._pop_tag(title_id_tag)\n\n                self.text.tag_configure(body_id_tag, elide=initial_elide)\n                self._add_tag(body_id_tag)\n                self._add_tag(\"topic_body\")\n                for child in list(node.children)[1:]:\n                    child.walkabout(self)\n                self._pop_tag(\"topic_body\")\n                self._pop_tag(body_id_tag)\n\n                if \"tight\" not in node.attributes[\"classes\"]:\n                    self._append_text(\"\\n\")\n\n                raise docutils.nodes.SkipNode()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Renders an interactive, collapsible topic section in a Tkinter text widget. It enables users to toggle the visibility of the topic's content using a clickable image, enhancing readability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_visit_empty_topic", "line_number": 287, "body": "def _visit_empty_topic(self, node):\n                img = get_workbench().get_image(\n                    \"boxdot_light\" if get_workbench().uses_dark_ui_theme() else \"boxdot\"\n                )\n                label = tk.Label(\n                    self.text,\n                    image=img,\n                    borderwidth=0,\n                    background=self.text[\"background\"],\n                    cursor=\"arrow\",\n                )\n                self._append_window(label)\n                assert isinstance(node.children[0], docutils.nodes.title)\n                node.children[0].walkabout(self)\n\n                if \"tight\" not in node.attributes[\"classes\"]:\n                    self._append_text(\"\\n\")\n\n                raise docutils.nodes.SkipNode()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles the rendering of `docutils` 'empty topic' nodes in a Tkinter text widget. It displays a visual icon, processes the node's title, and manages the associated layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_topic", "line_number": 307, "body": "def depart_topic(self, node):\n                # only for non-toggle topics\n                self.in_topic = False\n                self._append_text(\"\\n\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Signals the end of processing a topic node by resetting an internal flag and appending a newline character for proper text rendering in Tkinter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_image", "line_number": 312, "body": "def visit_image(self, node):\n                self._append_image(node.attributes[\"uri\"])\n                if not self.in_paragraph and not self.in_title:\n                    self._append_text(\"\\n\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Renders image nodes within a Tkinter text widget. It appends the image and manages layout by adding newlines for standalone images."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_reference", "line_number": 317, "body": "def visit_reference(self, node):\n                tag = self._create_unique_tag()\n                node.unique_tag = tag\n                self._add_tag(\"a\")\n                self._add_tag(tag)\n\n                def handle_click(event):\n                    get_workbench().open_url(node.attributes[\"refuri\"])\n\n                self.text.tag_bind(tag, \"<ButtonRelease-1>\", handle_click)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This method renders a document's reference node as an interactive hyperlink in a Tkinter text widget. It enables clicking the link to open its associated URL."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_reference", "line_number": 328, "body": "def depart_reference(self, node):\n                self._pop_tag(\"a\")\n                self._pop_tag(node.unique_tag)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Finalizes the rendering of a reference element by closing its associated formatting tags within a Tkinter text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_literal", "line_number": 332, "body": "def visit_literal(self, node):\n                self._add_tag(\"code\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Applies 'code' formatting to literal text nodes, enabling their distinct visual representation within a Tkinter text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_literal", "line_number": 335, "body": "def depart_literal(self, node):\n                self._pop_tag(\"code\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Ends the 'code' text styling scope for a literal block, ensuring subsequent text is rendered without code formatting in a Tkinter text widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_inline", "line_number": 338, "body": "def visit_inline(self, node):\n                for cls in node.attributes[\"classes\"]:\n                    self._add_tag(cls)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Applies Tkinter text tags to an inline document node based on its assigned classes. It formats styled text during rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_inline", "line_number": 342, "body": "def depart_inline(self, node):\n                for cls in node.attributes[\"classes\"]:\n                    self._pop_tag(cls)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Closes text tags for inline elements, removing associated formatting when the visitor leaves the node. This ensures correct styling scope in Tkinter text rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_literal_block", "line_number": 346, "body": "def visit_literal_block(self, node):\n                self._add_tag(\"code\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Prepares a literal block for Tkinter rendering by applying a \"code\" tag, enabling specific styling for code sections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_literal_block", "line_number": 349, "body": "def depart_literal_block(self, node):\n                self._pop_tag(\"code\")\n                self._append_text(\"\\n\\n\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Completes the rendering of a literal code block in a Tkinter text widget. It removes the associated 'code' style tag and adds paragraph spacing for readability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_bullet_list", "line_number": 353, "body": "def visit_bullet_list(self, node):\n                self.active_lists.append(node.attributes[\"bullet\"])", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Records the bullet style when encountering a bullet list node. This helps the renderer maintain context for proper display of list items."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_bullet_list", "line_number": 356, "body": "def depart_bullet_list(self, node):\n                self._append_text(\"\\n\")\n                self.active_lists.pop()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Within the TkTextRenderingVisitor, this method concludes the rendering of a bullet list. It adds a newline after the list and updates the visitor's active list context for proper formatting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_enumerated_list", "line_number": 360, "body": "def visit_enumerated_list(self, node):\n                self.active_lists.append(node.attributes[\"enumtype\"])", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Tracks the type of an active enumerated list during a Tkinter text rendering traversal. This helps maintain the correct rendering context for lists."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_enumerated_list", "line_number": 363, "body": "def depart_enumerated_list(self, node):\n                self._append_text(\"\\n\")\n                self.active_lists.pop()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This method finalizes the rendering of an enumerated list, adding a newline for formatting and updating the visitor's state to reflect exiting the list."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_list_item", "line_number": 367, "body": "def visit_list_item(self, node):\n                if self.active_lists[-1] == \"*\":\n                    self._append_text(\"\u2022 \")\n                elif self.active_lists[-1] == \"arabic\":\n                    for i, sib in enumerate(node.parent.children):\n                        if sib is node:\n                            self._append_text(\"%d. \" % (i + 1))\n                            break", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This method of `TkTextRenderingVisitor` adds the appropriate bullet or numbered prefix to a list item during text rendering. It ensures correct formatting when displaying ordered and unordered lists."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_note", "line_number": 376, "body": "def visit_note(self, node):\n                self._add_tag(\"em\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Applies emphasis formatting when rendering a 'note' node within a Tkinter text widget. This method defines the visual style for note elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_note", "line_number": 379, "body": "def depart_note(self, node):\n                self._pop_tag(\"em\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Closes the emphasis formatting context when departing from a 'note' node, ensuring proper text styling during Tkinter rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_substitution_definition", "line_number": 385, "body": "def visit_substitution_definition(self, node):\n                raise docutils.nodes.SkipNode()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This visitor method explicitly skips processing `substitution_definition` nodes. It ensures these nodes are ignored during Tkinter text rendering, as they are not relevant for visual output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_system_message", "line_number": 388, "body": "def visit_system_message(self, node):\n                logger.warning(\"docutils message: '%s'. Context: %s\" % (node.astext(), node.parent))\n                raise docutils.nodes.SkipNode", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Processes `docutils` system messages, logging warnings about them. It ensures these specific nodes are not rendered by the visitor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_emphasis", "line_number": 392, "body": "def visit_emphasis(self, node):\n                self._add_tag(\"em\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Instructs the Tkinter text renderer to apply an emphasis tag. It ensures emphasized content is visually formatted as expected."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_emphasis", "line_number": 395, "body": "def depart_emphasis(self, node):\n                self._pop_tag(\"em\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Removes the emphasis formatting tag from the rendering state when the text rendering visitor leaves an emphasis text node."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_strong", "line_number": 398, "body": "def visit_strong(self, node):\n                self._add_tag(\"strong\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "A method of TkTextRenderingVisitor, it applies the \"strong\" formatting tag to text during the rendering process, typically for rendering bold text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "depart_strong", "line_number": 401, "body": "def depart_strong(self, node):\n                self._pop_tag(\"strong\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Completes the rendering of a 'strong' text section for Tkinter display. It ensures the bold text formatting is correctly finalized."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "visit_block_quote", "line_number": 404, "body": "def visit_block_quote(self, node):\n                self._add_tag(\"code\")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This method, part of a Tkinter text rendering visitor, styles block quote elements. It renders block quotes with a \"code\" tag, visually presenting them as code within the text output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "default_visit", "line_number": 410, "body": "def default_visit(self, node):\n                self._append_text(self._node_to_text(node))\n                print(\"skipping children\", type(node), node)\n                raise docutils.nodes.SkipChildren()", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Provides a default text rendering strategy for `docutils` nodes. It extracts and appends the node's text, then explicitly skips visiting its children."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_create_unique_tag", "line_number": 419, "body": "def _create_unique_tag(self):\n                self.unique_tag_count += 1\n                return \"_UT_%s\" % self.unique_tag_count", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Generates a unique tag string to identify elements or apply formatting within Tkinter text widgets without conflict."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_node_to_text", "line_number": 423, "body": "def _node_to_text(self, node):\n                if node.parent.attributes.get(\"xml:space\") == \"preserve\":\n                    return node.astext()\n                else:\n                    return node.astext().replace(\"\\r\", \"\").replace(\"\\n\", \" \")", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "This method normalizes the text content of a given node for rendering. It either preserves original whitespace or converts line breaks and carriage returns into spaces, based on a parent attribute."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_add_tag", "line_number": 429, "body": "def _add_tag(self, tag):\n                self._context_tags.append(tag)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Adds a formatting tag to the current list of active tags for text rendering within the Tkinter context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_pop_tag", "line_number": 432, "body": "def _pop_tag(self, tag):\n                self._context_tags.remove(tag)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Removes a specified tag from the rendering visitor's active context, essential for managing the scope of text formatting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_append_text", "line_number": 435, "body": "def _append_text(self, chars, extra_tags=()):\n                # print(\"APPP\", chars, tags)\n                self.text.direct_insert(\"end\", chars, self._get_effective_tags(extra_tags))", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Appends text with associated styling tags to the end of the Tkinter Text widget managed by the visitor. This facilitates building the display content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_append_image", "line_number": 439, "body": "def _append_image(self, name, extra_tags=()):\n                index = self.text.index(\"end-1c\")\n                self.text.image_create(index, image=get_workbench().get_image(name))\n                for tag in self._get_effective_tags(extra_tags):\n                    self.text.tag_add(tag, index)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Appends a specified image to a Tkinter Text widget. It applies relevant tags for formatting and interaction purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_append_window", "line_number": 445, "body": "def _append_window(self, window, extra_tags=()):\n                index = self.text.index(\"end-1c\")\n                self.text.window_create(index, window=window)\n                for tag in self._get_effective_tags(extra_tags):\n                    self.text.tag_add(tag, index)", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Embeds a Tkinter widget into the Text widget at the current end position. It applies associated formatting tags to the inserted object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "_get_effective_tags", "line_number": 451, "body": "def _get_effective_tags(self, extra_tags):\n                tags = set(extra_tags) | set(self._context_tags)\n\n                if self.active_lists:\n                    tags.add(\"list%d\" % min(len(self.active_lists), 5))\n\n                # combine tags\n                if \"code\" in tags and \"topic_title\" in tags:\n                    tags.remove(\"code\")\n                    tags.remove(\"topic_title\")\n                    tags.add(\"topic_title_code\")\n\n                return tuple(sorted(tags))", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Computes the definitive set of tags for rendering text, merging input tags with context and applying specific rules for list and combined code/title styling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "get_toggler_image_name", "line_number": 220, "body": "def get_toggler_image_name(kind):\n                    if get_workbench().uses_dark_ui_theme():\n                        return kind + \"_light\"\n                    else:\n                        return kind", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Provides the appropriate image name for a UI toggler, adapting it for light or dark user interface themes. This ensures visual consistency."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "toggle_body", "line_number": 241, "body": "def toggle_body(event=None):\n                    elide = self.text.tag_cget(body_id_tag, \"elide\")\n                    if elide == \"1\":\n                        elide = True\n                    elif elide == \"0\":\n                        elide = False\n                    else:\n                        elide = bool(elide)\n\n                    elide = not elide\n\n                    self.text.tag_configure(body_id_tag, elide=elide)\n                    if self.text.has_selection():\n                        self.text.tag_remove(\"sel\", \"1.0\", \"end\")\n\n                    if elide:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxplus\"))\n                        )\n                    else:\n                        label.configure(\n                            image=get_workbench().get_image(get_toggler_image_name(\"boxminus\"))\n                        )", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Toggles the elided (hidden/expanded) state of a specific text body within a Tkinter Text widget. It updates an associated UI indicator to reflect the new visibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/rst_utils.py", "function": "handle_click", "line_number": 323, "body": "def handle_click(event):\n                    get_workbench().open_url(node.attributes[\"refuri\"])", "is_method": true, "class_name": "TkTextRenderingVisitor", "function_description": "Handles a click event on a rendered text element, opening its associated URL via the workbench. This provides interactive link functionality within the Tkinter text display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/export.py", "function": "add_export_page", "line_number": 51, "body": "def add_export_page(title, page_class):\n    page_specs.append((title, page_class))", "is_method": false, "function_description": "Registers a new page for export, storing its title and associated page class. This allows the system to later list and generate exportable content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/export.py", "function": "on_cancel", "line_number": 41, "body": "def on_cancel(self):\n        print(\"Cancel\")\n        self.destroy()", "is_method": true, "class_name": "ExportDialog", "function_description": "This method handles the user's \"cancel\" action in an export dialog. It closes the dialog window, effectively terminating the export process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_update_highlighting", "line_number": 179, "body": "def _update_highlighting(event, text_changed, need_update, delay=None):\n    text = event.widget\n    if not hasattr(text, \"paren_matcher\"):\n        if isinstance(text, CodeViewText):\n            text.paren_matcher = ParenMatcher(text)\n        elif isinstance(text, ShellText):\n            text.paren_matcher = ShellParenMatcher(text)\n        else:\n            return\n\n    if text_changed:\n        text.paren_matcher.invalidate_token_cache()\n\n    if need_update:\n        text.paren_matcher.schedule_update(delay)", "is_method": false, "function_description": "Provides a service to manage and trigger syntax highlighting updates for text editor widgets. It initializes the parenthesis matcher, invalidates its cache, and schedules updates as text content changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "update_highlighting_full", "line_number": 196, "body": "def update_highlighting_full(event):\n    _update_highlighting(event, True, True)", "is_method": false, "function_description": "This function triggers a complete update of all highlighting based on an event. It provides a simple way to refresh the entire visual highlight state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "clear_highlighting", "line_number": 200, "body": "def clear_highlighting(text):\n    text.tag_remove(\"surrounding_parens\", \"0.1\", \"end\")\n    text.tag_remove(\"unclosed_expression\", \"0.1\", \"end\")", "is_method": false, "function_description": "Clears specific syntax highlighting and error indicators from a text display. This resets the visual appearance by removing tags for elements like parentheses and unclosed expressions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "update_highlighting_move", "line_number": 208, "body": "def update_highlighting_move(event):\n    global _last_move_time\n    # needs delay because selecting with mouse causes many events\n    # and I don't know how to distinguish selection from other moves\n    t = time.time()\n    if t - _last_move_time > 0.1:\n        delay = None\n    else:\n        delay = 300\n    _last_move_time = t\n    _update_highlighting(event, False, True, delay=delay)", "is_method": false, "function_description": "Updates visual highlighting in response to a user 'move' event, such as mouse movement. It intelligently throttles updates to prevent excessive redraws and improve application performance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "update_highlighting_edit_cw", "line_number": 221, "body": "def update_highlighting_edit_cw(event):\n    if isinstance(event.text_widget, CodeViewText):\n        event.widget = event.text_widget\n        trivial = event.get(\"trivial_for_parens\", False)\n        _update_highlighting(event, True, not trivial)\n        if trivial:\n            event.text_widget.tag_remove(\"surrounding_parens\", \"0.1\", \"end\")", "is_method": false, "function_description": "This function updates text highlighting within a `CodeViewText` widget in response to an edit event. It specifically manages the highlighting of surrounding parentheses based on the nature of the edit."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "load_plugin", "line_number": 230, "body": "def load_plugin() -> None:\n    wb = get_workbench()\n\n    wb.set_default(\"view.paren_highlighting\", True)\n    wb.bind(\"TextInsert\", update_highlighting_edit_cw, True)\n    wb.bind(\"TextDelete\", update_highlighting_edit_cw, True)\n    wb.bind_class(\"CodeViewText\", \"<<VerticalScroll>>\", update_highlighting_move, True)\n    wb.bind_class(\"CodeViewText\", \"<<CursorMove>>\", update_highlighting_move, True)\n    wb.bind_class(\"ShellText\", \"<<TextChange>>\", update_highlighting_full, True)\n    wb.bind_class(\"ShellText\", \"<<CursorMove>>\", update_highlighting_full, True)\n    wb.bind(\"<<UpdateAppearance>>\", update_highlighting_full, True)", "is_method": false, "function_description": "Configures the workbench to enable parenthesis highlighting. It binds various text and cursor events to update functions, ensuring dynamic highlighting as the user interacts with code and shell views."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "schedule_update", "line_number": 33, "body": "def schedule_update(self, delay=None):\n        if self._update_scheduling_id is not None:\n            self.text.after_cancel(self._update_scheduling_id)\n\n        if delay is not None:\n            self._update_scheduling_id = self.text.after(delay, self.perform_update)\n        else:\n            self._update_scheduling_id = self.text.after_idle(self.perform_update)", "is_method": true, "class_name": "ParenMatcher", "function_description": "Schedules the `perform_update` method of the ParenMatcher instance to run after a specified delay or when idle, canceling any previously scheduled update."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "perform_update", "line_number": 42, "body": "def perform_update(self):\n        try:\n            self.update_highlighting()\n        finally:\n            self._update_scheduled = False", "is_method": true, "class_name": "ParenMatcher", "function_description": "Triggers the visual highlighting update for parenthesis matching. It ensures the update process is completed and the system is ready for future changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "invalidate_token_cache", "line_number": 48, "body": "def invalidate_token_cache(self):\n        self._tokens_cache = {}", "is_method": true, "class_name": "ParenMatcher", "function_description": "Clears the internal token cache of the ParenMatcher instance. This ensures subsequent operations use fresh token data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "update_highlighting", "line_number": 51, "body": "def update_highlighting(self):\n        clear_highlighting(self.text)\n\n        if get_workbench().get_option(\"view.paren_highlighting\") and self.text.is_python_text():\n            self._update_highlighting_for_active_range()", "is_method": true, "class_name": "ParenMatcher", "function_description": "Manages and updates the visual highlighting of parentheses in Python code. It clears existing highlights and applies new ones, respecting user preferences for paren highlighting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_update_highlighting_for_active_range", "line_number": 57, "body": "def _update_highlighting_for_active_range(self):\n        start_index = \"1.0\"\n        end_index = self.text.index(\"end\")\n\n        # Try to reduce search range for better performance.\n        index = self._find_block_start(\"@0,0 linestart\", True)\n        if index:\n            start_index = index\n\n        lower_right = \"@%d,%d\" % (self.text.winfo_width(), self.text.winfo_height())\n        index = self._find_block_start(lower_right + \" lineend\", False)\n        if index:\n            end_index = index\n\n        self._highlight(start_index, end_index)", "is_method": true, "class_name": "ParenMatcher", "function_description": "Updates parenthesis highlighting within the widget's visible text area to optimize performance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_find_block_start", "line_number": 73, "body": "def _find_block_start(self, start_position, backwards):\n        while True:\n            index = self.text.search(\n                BLOCK_START_REGEX_STR,\n                start_position,\n                regexp=True,\n                backwards=backwards,\n                stopindex=\"1.0\" if backwards else \"end\",\n            )\n            if not index:\n                break\n\n            tags = self.text.tag_names(index)\n            if \"string3\" in tags or \"open_string3\" in tags:\n                # not a block start\n                if backwards:\n                    start_position = index\n                else:\n                    start_position = index + \" +1c\"\n            else:\n                break\n\n        return index", "is_method": true, "class_name": "ParenMatcher", "function_description": "A utility for `ParenMatcher`, this method identifies the true start of a code block (e.g., `def`, `class`) within text. It intelligently skips matches found inside string literals to accurately parse code structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_highlight", "line_number": 97, "body": "def _highlight(self, start_index, end_index):\n        stack = []\n\n        cursor_row, cursor_col = map(int, self.text.index(\"insert\").split(\".\"))\n\n        for t in self._get_paren_tokens(start_index, end_index):\n            if t.string in \"([{\":\n                stack.append(t)\n            elif not stack:\n                # stack is empty, ie. found a closer without opener\n                close_index = \"%d.%d\" % (t.start[0], t.end[1])\n                self.text.tag_add(\"unclosed_expression\", start_index, close_index)\n                break\n            elif stack[-1].string != _OPENERS[t.string]:\n                # incorrect closure\n                opener = stack[-1]\n                open_index = \"%d.%d\" % opener.start\n                self.text.tag_add(\"unclosed_expression\", open_index, end_index)\n                break\n            else:\n                # found a pair\n                opener = stack[-1]\n                closer = t\n\n                # if cursor is right after opener or closer then highlight both\n                if (\n                    cursor_row == opener.start[0]\n                    and cursor_col == opener.end[1]\n                    or cursor_row == closer.start[0]\n                    and cursor_col == closer.end[1]\n                ):\n                    self.text.tag_add(\"surrounding_parens\", \"%d.%d\" % closer.start)\n                    self.text.tag_add(\"surrounding_parens\", \"%d.%d\" % opener.start)\n\n                stack.pop()\n\n        if stack:\n            # something was left without closure\n            opener = stack[-1]\n            open_index = \"%d.%d\" % opener.start\n            self.text.tag_add(\"unclosed_expression\", open_index, end_index)", "is_method": true, "class_name": "ParenMatcher", "function_description": "The `ParenMatcher`'s `_highlight` method identifies and highlights matching or mismatched parenthetical expressions within a specified range. It also highlights the surrounding pair if the cursor is adjacent, aiding syntax visualization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_get_paren_tokens", "line_number": 139, "body": "def _get_paren_tokens(self, start_index, end_index):\n        import tokenize\n\n        if (start_index, end_index) in self._tokens_cache:\n            return self._tokens_cache[(start_index, end_index)]\n\n        start_row, start_col = map(int, start_index.split(\".\"))\n        source = self.text.get(start_index, end_index)\n        # prepend source with empty lines and spaces to make\n        # token rows and columns match with widget indices\n        source = (\"\\n\" * (start_row - 1)) + (\" \" * start_col) + source\n\n        result = []\n        try:\n            tokens = tokenize.tokenize(io.BytesIO(source.encode(\"utf-8\")).readline)\n            for token in tokens:\n                # if token.string != \"\" and token.string in \"()[]{}\":\n                if token.exact_type in TOKTYPES:\n                    result.append(token)\n        except Exception:\n            # happens eg when parens are unbalanced or there is indentation error or ...\n            pass\n\n        if start_index == \"1.0\" and end_index == \"end\":\n            self._tokens_cache[(start_index, end_index)] = result\n\n        return result", "is_method": true, "class_name": "ParenMatcher", "function_description": "This method tokenizes a specified text range, returning a filtered list of all parenthesis, bracket, and brace tokens. It supports efficient retrieval by caching full document results."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/paren_matcher.py", "function": "_update_highlighting_for_active_range", "line_number": 169, "body": "def _update_highlighting_for_active_range(self):\n\n        # TODO: check that cursor is in this range\n        index_parts = self.text.tag_prevrange(\"command\", \"end\")\n\n        if index_parts:\n            start_index, end_index = index_parts\n            self._highlight(start_index, end_index)", "is_method": true, "class_name": "ShellParenMatcher", "function_description": "Identifies the most recent command text range and applies visual highlighting to it. This helps indicate the currently active command context in the shell."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_get_phrase_for_object", "line_number": 680, "body": "def _get_phrase_for_object(type_name, with_article=True):\n    friendly_names = {\n        \"str\": \"a string\",\n        \"int\": \"an integer\",\n        \"float\": \"a float\",\n        \"list\": \"a list\",\n        \"tuple\": \"a tuple\",\n        \"dict\": \"a dictionary\",\n        \"set\": \"a set\",\n        \"bool\": \"a boolean\",\n    }\n    result = friendly_names.get(type_name, \"an object of type '%s'\" % type_name)\n\n    if with_article:\n        return result\n    else:\n        _, rest = result.split(\" \", maxsplit=1)\n        return rest", "is_method": false, "function_description": "Converts a Python type name string into a human-readable phrase, optionally including an indefinite article. This utility provides user-friendly descriptions for various data types."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_get_sample_for_type", "line_number": 700, "body": "def _get_sample_for_type(type_name):\n    if type_name == \"int\":\n        return \"42\"\n    elif type_name == \"float\":\n        return \"3.14\"\n    elif type_name == \"str\":\n        return \"'abc'\"\n    elif type_name == \"bytes\":\n        return \"b'abc'\"\n    elif type_name == \"list\":\n        return \"[1, 2, 3]\"\n    elif type_name == \"tuple\":\n        return \"(1, 2, 3)\"\n    elif type_name == \"set\":\n        return \"{1, 2, 3}\"\n    elif type_name == \"dict\":\n        return \"{1 : 'one', 2 : 'two'}\"\n    else:\n        return \"...\"", "is_method": false, "function_description": "Provides a string representation of a sample value for common Python data types. Useful for generating example code or placeholders."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "load_plugin", "line_number": 721, "body": "def load_plugin():\n    for name in globals():\n        if name.endswith(\"ErrorHelper\") and not name.startswith(\"_\"):\n            type_name = name[: -len(\"Helper\")]\n            add_error_helper(type_name, globals()[name])", "is_method": false, "function_description": "Dynamically discovers and registers error helper components. It integrates any globally defined object ending with \"ErrorHelper\" into the system's error handling mechanism."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_missing_or_misplaced_colon", "line_number": 74, "body": "def _sug_missing_or_misplaced_colon(self):\n        import tokenize\n\n        i = 0\n        title = \"Did you forget the colon?\"\n        relevance = 0\n        body = \"\"\n        while i < len(self.tokens) and self.tokens[i].type != token.ENDMARKER:\n            t = self.tokens[i]\n            if t.string in [\n                \"if\",\n                \"elif\",\n                \"else\",\n                \"while\",\n                \"for\",\n                \"with\",\n                \"try\",\n                \"except\",\n                \"finally\",\n                \"class\",\n                \"def\",\n            ]:\n                keyword_pos = i\n                while (\n                    self.tokens[i].type\n                    not in [\n                        token.NEWLINE,\n                        token.ENDMARKER,\n                        token.COLON,  # colon may be OP\n                        token.RBRACE,\n                    ]\n                    and self.tokens[i].string != \":\"\n                ):\n\n                    old_i = i\n                    if self.tokens[i].string in \"([{\":\n                        i = self._skip_braced_part(i)\n                        assert i > old_i\n                        if i == len(self.tokens):\n                            return None\n                    else:\n                        i += 1\n\n                if self.tokens[i].string != \":\":\n                    relevance = 9\n                    body = \"`%s` header must end with a colon.\" % t.string\n                    break\n\n                # Colon was present, but maybe it should have been right\n                # after the keyword.\n                if (\n                    t.string in [\"else\", \"try\", \"finally\"]\n                    and self.tokens[keyword_pos + 1].string != \":\"\n                ):\n                    title = \"Incorrect use of `%s`\" % t.string\n                    body = \"Nothing is allowed between `%s` and colon.\" % t.string\n                    relevance = 9\n                    if (\n                        self.tokens[keyword_pos + 1].type not in (token.NEWLINE, tokenize.COMMENT)\n                        and t.string == \"else\"\n                    ):\n                        body = \"If you want to specify a condition, then use `elif` or nested `if`.\"\n                    break\n\n            i += 1\n\n        return Suggestion(\"missing-or-misplaced-colon\", title, body, relevance)", "is_method": true, "class_name": "SyntaxErrorHelper", "function_description": "Detects and suggests corrections for syntax errors caused by missing or misplaced colons after Python keywords like `if`, `while`, or `class`. It provides tailored feedback for common structural issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_unbalanced_parens", "line_number": 142, "body": "def _sug_unbalanced_parens(self):\n        problem = self._find_first_braces_problem()\n        if not problem:\n            return None\n\n        return Suggestion(\"missing-or-misplaced-colon\", \"Unbalanced brackets\", problem[1], 8)", "is_method": true, "class_name": "SyntaxErrorHelper", "function_description": "Identifies the first instance of unbalanced brackets within code. It provides a structured suggestion to help resolve this specific syntax error."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_skip_braced_part", "line_number": 161, "body": "def _skip_braced_part(self, token_index):\n        assert self.tokens[token_index].string in [\"(\", \"[\", \"{\"]\n        level = 1\n        token_index += 1\n        while token_index < len(self.tokens):\n\n            if self.tokens[token_index].string in [\"(\", \"[\", \"{\"]:\n                level += 1\n            elif self.tokens[token_index].string in [\")\", \"]\", \"}\"]:\n                level -= 1\n\n            token_index += 1\n\n            if level <= 0:\n                return token_index\n\n        assert token_index == len(self.tokens)\n        return token_index", "is_method": true, "class_name": "SyntaxErrorHelper", "function_description": "This method, part of `SyntaxErrorHelper`, locates the token immediately following a balanced, braced section of code. It effectively skips over nested parentheses, brackets, or curly braces."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_find_first_braces_problem", "line_number": 180, "body": "def _find_first_braces_problem(self):\n        # closers = {'(':')', '{':'}', '[':']'}\n        openers = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        brace_stack = []\n        for t in self.tokens:\n            if t.string in [\"(\", \"[\", \"{\"]:\n                brace_stack.append(t)\n            elif t.string in [\")\", \"]\", \"}\"]:\n                if not brace_stack:\n                    return (\n                        t,\n                        \"Found '`%s`' at `line %d <%s>`_ without preceding matching '`%s`'\"\n                        % (\n                            t.string,\n                            t.start[0],\n                            assistance.format_file_url(\n                                self.error_info[\"filename\"], t.start[0], t.start[1]\n                            ),\n                            openers[t.string],\n                        ),\n                    )\n                elif brace_stack[-1].string != openers[t.string]:\n                    return (\n                        t,\n                        \"Found '`%s`' at `line %d <%s>`__ when last unmatched opener was '`%s`' at `line %d <%s>`__\"\n                        % (\n                            t.string,\n                            t.start[0],\n                            assistance.format_file_url(\n                                self.error_info[\"filename\"], t.start[0], t.start[1]\n                            ),\n                            brace_stack[-1].string,\n                            brace_stack[-1].start[0],\n                            assistance.format_file_url(\n                                self.error_info[\"filename\"],\n                                brace_stack[-1].start[0],\n                                brace_stack[-1].start[1],\n                            ),\n                        ),\n                    )\n                else:\n                    brace_stack.pop()\n\n        if brace_stack:\n            return (\n                brace_stack[-1],\n                \"'`%s`' at `line %d <%s>`_ is not closed by the end of the program\"\n                % (\n                    brace_stack[-1].string,\n                    brace_stack[-1].start[0],\n                    assistance.format_file_url(\n                        self.error_info[\"filename\"],\n                        brace_stack[-1].start[0],\n                        brace_stack[-1].start[1],\n                    ),\n                ),\n            )\n\n        return None", "is_method": true, "class_name": "SyntaxErrorHelper", "function_description": "Identifies the first syntax error related to mismatched, unexpected, or unclosed braces within a token stream. It provides specific diagnostic information to help pinpoint the exact problem."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_missing_quotes", "line_number": 259, "body": "def _sug_missing_quotes(self):\n        if self._is_attribute_value() or self._is_call_function() or self._is_subscript_value():\n            relevance = 0\n        else:\n            relevance = 5\n\n        return Suggestion(\n            \"missing-quotes\",\n            \"Did you actually mean string (text)?\",\n            'If you didn\\'t mean a variable but literal text \"%s\", then surround it with quotes.'\n            % self.name,\n            relevance,\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Provides a contextual suggestion for NameErrors, proposing that an unquoted variable might have been intended as a string literal. It assesses the relevance of this suggestion based on the code's structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_bad_spelling", "line_number": 273, "body": "def _sug_bad_spelling(self):\n\n        # Yes, it would be more proper to consult builtins from the backend,\n        # but it's easier this way...\n        all_names = {name for name in dir(builtins) if not name.startswith(\"_\")}\n        all_names |= {\"pass\", \"break\", \"continue\", \"return\", \"yield\"}\n\n        if self.last_frame.globals is not None:\n            all_names |= set(self.last_frame.globals.keys())\n        if self.last_frame.locals is not None:\n            all_names |= set(self.last_frame.locals.keys())\n\n        similar_names = {self.name}\n        if all_names:\n            relevance = 0\n            for name in all_names:\n                sim = name_similarity(name, self.name)\n                if sim > 4:\n                    similar_names.add(name)\n                relevance = max(sim, relevance)\n        else:\n            relevance = 3\n\n        if len(similar_names) > 1:\n            body = \"I found similar names. Are all of them spelled correctly?\\n\\n\"\n            for name in sorted(similar_names, key=lambda x: x.lower()):\n                # TODO: add location info\n                body += \"* `%s`\\n\\n\" % name\n        else:\n            body = (\n                \"Compare the name with corresponding definition / assignment / documentation.\"\n                + \" Don't forget that case of the letters matters!\"\n            )\n\n        return Suggestion(\"bad-spelling-name\", \"Did you misspell it (somewhere)?\", body, relevance)", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Provides a suggestion for a `NameError` by identifying similarly spelled names from built-ins, globals, and locals. It helps diagnose and correct misspelled variable or function names."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_missing_import", "line_number": 309, "body": "def _sug_missing_import(self):\n        likely_importable_functions = {\n            \"math\": {\"ceil\", \"floor\", \"sqrt\", \"sin\", \"cos\", \"degrees\"},\n            \"random\": {\"randint\"},\n            \"turtle\": {\n                \"left\",\n                \"right\",\n                \"forward\",\n                \"fd\",\n                \"goto\",\n                \"setpos\",\n                \"Turtle\",\n                \"penup\",\n                \"up\",\n                \"pendown\",\n                \"down\",\n                \"color\",\n                \"pencolor\",\n                \"fillcolor\",\n                \"begin_fill\",\n                \"end_fill\",\n                \"pensize\",\n                \"width\",\n            },\n            \"re\": {\"search\", \"match\", \"findall\"},\n            \"datetime\": {\"date\", \"time\", \"datetime\", \"today\"},\n            \"statistics\": {\n                \"mean\",\n                \"median\",\n                \"median_low\",\n                \"median_high\",\n                \"mode\",\n                \"pstdev\",\n                \"pvariance\",\n                \"stdev\",\n                \"variance\",\n            },\n            \"os\": {\"listdir\"},\n            \"time\": {\"time\", \"sleep\"},\n        }\n\n        body = None\n\n        if self._is_call_function():\n            relevance = 5\n            for mod in likely_importable_functions:\n                if self.name in likely_importable_functions[mod]:\n                    relevance += 3\n                    body = (\n                        \"If you meant `%s` from module `%s`, then add\\n\\n`from %s import %s`\\n\\nto the beginning of your script.\"\n                        % (self.name, mod, mod, self.name)\n                    )\n                    break\n\n        elif self._is_attribute_value():\n            relevance = 5\n            body = (\n                \"If you meant module `%s`, then add `import %s` to the beginning of your script\"\n                % (self.name, self.name)\n            )\n\n            if self.name in likely_importable_functions:\n                relevance += 3\n\n        elif self._is_subscript_value() and self.name != \"argv\":\n            relevance = 0\n        elif self.name == \"pi\":\n            body = \"If you meant the constant \u03c0, then add `from math import pi` to the beginning of your script.\"\n            relevance = 8\n        elif self.name == \"argv\":\n            body = \"If you meant the list with program arguments, then add `from sys import argv` to the beginning of your script.\"\n            relevance = 8\n        else:\n            relevance = 3\n\n        if body is None:\n            body = \"Some functions/variables need to be imported before they can be used.\"\n\n        return Suggestion(\"missing-import\", \"Did you forget to import it?\", body, relevance)", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Provides intelligent suggestions for missing import statements based on common Python functions or modules. It helps users resolve NameErrors by guiding them to add necessary imports."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_local_from_global", "line_number": 389, "body": "def _sug_local_from_global(self):\n        import ast\n\n        relevance = 0\n        body = None\n\n        if self.last_frame.code_name == \"<module>\" and self.last_frame_module_ast is not None:\n            function_names = set()\n            for node in ast.walk(self.last_frame_module_ast):\n                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                    if self.name in map(lambda x: x.arg, node.args.args):\n                        function_names.add(node.name)\n                    # TODO: varargs, kw, ...\n                    declared_global = False\n                    for localnode in ast.walk(node):\n                        # print(node.name, localnode)\n                        if (\n                            isinstance(localnode, ast.Name)\n                            and localnode.id == self.name\n                            and isinstance(localnode.ctx, ast.Store)\n                        ):\n                            function_names.add(node.name)\n                        elif isinstance(localnode, ast.Global) and self.name in localnode.names:\n                            declared_global = True\n\n                    if node.name in function_names and declared_global:\n                        function_names.remove(node.name)\n\n            if function_names:\n                relevance = 9\n                body = (\n                    (\n                        \"Name `%s` defined in `%s` is not accessible in the global/module level.\"\n                        % (self.name, \" and \".join(function_names))\n                    )\n                    + \"\\n\\nIf you need that data at the global level, then consider changing the function so that it `return`-s the value.\"\n                )\n\n        return Suggestion(\n            \"local-from-global\",\n            \"Are you trying to access a local variable outside of the function?\",\n            body,\n            relevance,\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Analyzes `NameError` to detect if it's caused by attempting to access a local variable from the global scope. It then provides a suggestion to resolve this common scope-related issue."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_not_defined_yet", "line_number": 434, "body": "def _sug_not_defined_yet(self):\n        return Suggestion(\n            \"not-defined-yet\",\n            \"Has Python executed the definition?\",\n            (\n                \"Don't forget that name becomes defined when corresponding definition ('=', 'def' or 'import') gets executed.\"\n                + \" If the definition comes later in code or is inside an if-statement, Python may not have executed it (yet).\"\n                + \"\\n\\n\"\n                + \"Make sure Python arrives to the definition before it arrives to this line. When in doubt, \"\n                + \"`use the debugger <debuggers.rst>`_.\"\n            ),\n            2,\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Provides a specific suggestion within NameErrorHelper to help users understand why a name might be undefined due to execution flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_is_call_function", "line_number": 454, "body": "def _is_call_function(self):\n        return self.name + \"(\" in (\n            self.error_info[\"line\"].replace(\" \", \"\").replace(\"\\n\", \"\").replace(\"\\r\", \"\")\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Identifies if the undefined name causing a NameError was used as a function call on the erroneous line."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_is_subscript_value", "line_number": 459, "body": "def _is_subscript_value(self):\n        return self.name + \"[\" in (\n            self.error_info[\"line\"].replace(\" \", \"\").replace(\"\\n\", \"\").replace(\"\\r\", \"\")\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "Identifies if the `NameError` resulted from attempting to subscript an undefined variable. This helps the `NameErrorHelper` classify specific error patterns for diagnostic purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_is_attribute_value", "line_number": 464, "body": "def _is_attribute_value(self):\n        return self.name + \".\" in (\n            self.error_info[\"line\"].replace(\" \", \"\").replace(\"\\n\", \"\").replace(\"\\r\", \"\")\n        )", "is_method": true, "class_name": "NameErrorHelper", "function_description": "This helper method determines if the name associated with a `NameError` is being used as an object accessing an attribute within the problematic line of code. It aids in contextualizing `NameError` analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_wrong_attribute_instead_of_len", "line_number": 498, "body": "def _sug_wrong_attribute_instead_of_len(self):\n\n        if self.type_name == \"str\":\n            goal = \"length\"\n        elif self.type_name == \"bytes\":\n            goal = \"number of bytes\"\n        elif self.type_name == \"list\":\n            goal = \"number of elements\"\n        elif self.type_name == \"tuple\":\n            goal = \"number of elements\"\n        elif self.type_name == \"set\":\n            goal = \"number of elements\"\n        elif self.type_name == \"dict\":\n            goal = \"number of entries\"\n        else:\n            return None\n\n        return Suggestion(\n            \"wrong-attribute-instead-of-len\",\n            \"Did you mean to ask the %s?\" % goal,\n            \"This can be done with function `len`, eg:\\n\\n`len(%s)`\"\n            % _get_sample_for_type(self.type_name),\n            (9 if self.att_name.lower() in (\"len\", \"length\", \"size\") else 0),\n        )", "is_method": true, "class_name": "AttributeErrorHelper", "function_description": "Provides a helpful suggestion for `AttributeError` when users incorrectly seek the length of an object via an attribute, guiding them to use the `len()` function instead."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_bad_spelling", "line_number": 523, "body": "def _sug_bad_spelling(self):\n        # TODO: compare with attributes of known types\n        return Suggestion(\n            \"bad-spelling-attribute\",\n            \"Did you misspell the name?\",\n            \"Don't forget that case of the letters matters too!\",\n            3,\n        )", "is_method": true, "class_name": "AttributeErrorHelper", "function_description": "Provides a predefined suggestion for `AttributeError`s, highlighting potential attribute name misspellings or incorrect casing to aid debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_sug_bad_type", "line_number": 532, "body": "def _sug_bad_type(self):\n        if self._is_call_function():\n            action = \"call this function on\"\n        else:\n            action = \"ask this attribute from\"\n\n        return Suggestion(\n            \"wrong-type-attribute\",\n            \"Did you expect another type?\",\n            \"If you didn't mean %s %s, \" % (action, _get_phrase_for_object(self.type_name))\n            + \"then step through your program to see \"\n            + \"why this type appears here.\",\n            3,\n        )", "is_method": true, "class_name": "AttributeErrorHelper", "function_description": "Generates a debugging suggestion for `AttributeError` when an operation is attempted on an object of an unexpected type. It guides users to investigate type mismatches."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_is_call_function", "line_number": 547, "body": "def _is_call_function(self):\n        return \".\" + self.att_name + \"(\" in (\n            self.error_info[\"line\"].replace(\" \", \"\").replace(\"\\n\", \"\").replace(\"\\r\", \"\")\n        )", "is_method": true, "class_name": "AttributeErrorHelper", "function_description": "Checks if the attribute name identified in an `AttributeError` was part of a function call. It helps the `AttributeErrorHelper` class diagnose the error's context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "get_kill_process_instructions", "line_number": 578, "body": "def get_kill_process_instructions(self):\n        s = (\n            \"Let's say you need port 5000. If you don't know which process is using it,\"\n            + \" then enter following system command into Thonny's Shell:\\n\\n\"\n        )\n\n        if running_on_windows():\n            s += (\n                \"``!netstat -ano | findstr :5000``\\n\\n\"\n                + \"You should see the process ID in the last column.\\n\\n\"\n            )\n        else:\n            s += (\n                \"``!lsof -i:5000``\\n\\n\" + \"You should see the process ID under the heading PID.\\n\\n\"\n            )\n\n        s += (\n            \"Let's pretend the ID is 12345.\"\n            \" You can try hard-killing the process with following command:\\n\\n\"\n        )\n\n        if running_on_windows():\n            s += \"``!tskill 12345``\\n\"\n        else:\n            s += (\n                \"``!kill -9 12345``\\n\\n\"\n                + \"Both steps can be combined into single command:\\n\\n\"\n                + \"``!kill -9 $(lsof -t -i:5000)``\\n\\n\"\n            )\n\n        return s", "is_method": true, "class_name": "OSErrorHelper", "function_description": "Provides platform-specific instructions to identify and terminate processes occupying network ports. This helps users resolve \"address already in use\" errors by guiding manual troubleshooting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/stdlib_error_helpers.py", "function": "_bad_string_concatenation", "line_number": 649, "body": "def _bad_string_concatenation(self, other_type_name, string_first):\n        self.intro_text = \"Your program is trying to put together \" + (\n            \"a string and %s.\" if string_first else \"%s and a string.\"\n        ) % _get_phrase_for_object(other_type_name)\n\n        self.suggestions.append(\n            Suggestion(\n                \"convert-other-operand-to-string\",\n                \"Did you mean to treat both sides as text and produce a string?\",\n                \"In this case you should apply function `str` to the %s \"\n                % _get_phrase_for_object(other_type_name, False)\n                + \"in order to convert it to string first, eg:\\n\\n\"\n                + (\"`'abc' + str(%s)`\" if string_first else \"`str(%s) + 'abc'`\")\n                % _get_sample_for_type(other_type_name),\n                8,\n            )\n        )\n\n        if other_type_name in (\"float\", \"int\"):\n            self.suggestions.append(\n                Suggestion(\n                    \"convert-other-operand-to-number\",\n                    \"Did you mean to treat both sides as numbers and produce a sum?\",\n                    \"In this case you should first convert the string to a number \"\n                    + \"using either function `float` or `int`, eg:\\n\\n\"\n                    + (\"`float('3.14') + 22`\" if string_first else \"`22 + float('3.14')`\"),\n                    7,\n                )\n            )", "is_method": true, "class_name": "TypeErrorHelper", "function_description": "Internal helper within `TypeErrorHelper` that crafts user-friendly explanations and fix suggestions for `TypeError` instances caused by invalid string concatenation with other data types."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "default_light", "line_number": 5, "body": "def default_light() -> SyntaxThemeSettings:\n    default_fg = \"black\"\n    default_bg = \"#fdfdfd\"\n    light_fg = \"DarkGray\"\n    string_fg = \"DarkGreen\"\n    open_string_bg = \"#c3f9d3\"\n    gutter_foreground = \"#999999\"\n    gutter_background = \"#e0e0e0\"\n\n    return {\n        \"TEXT\": {\n            \"foreground\": default_fg,\n            \"insertbackground\": default_fg,\n            \"background\": default_bg,\n        },\n        \"GUTTER\": {\"foreground\": gutter_foreground, \"background\": gutter_background},\n        \"breakpoint\": {\"foreground\": \"crimson\"},\n        \"current_line\": {\"background\": \"#f5f5f5\"},\n        \"definition\": {\"foreground\": \"DarkBlue\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg, \"background\": None, \"font\": \"EditorFont\"},\n        \"open_string\": {\"foreground\": string_fg, \"background\": open_string_bg},\n        \"open_string3\": {\n            \"foreground\": string_fg,\n            \"background\": open_string_bg,\n            \"font\": \"EditorFont\",\n        },\n        \"tab\": {\"background\": \"#f5ecd7\"},\n        \"keyword\": {\"foreground\": \"#7f0055\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#7f0055\"},\n        \"number\": {\"foreground\": \"#B04600\"},\n        \"comment\": {\"foreground\": light_fg},\n        \"welcome\": {\"foreground\": light_fg},\n        \"magic\": {\"foreground\": light_fg},\n        \"prompt\": {\"foreground\": \"purple\", \"font\": \"BoldEditorFont\"},\n        \"stdin\": {\"foreground\": \"Blue\"},\n        \"stdout\": {\"foreground\": \"Black\"},\n        \"stderr\": {\"foreground\": \"#CC0000\"},  # same as ANSI red\n        \"value\": {\"foreground\": \"DarkBlue\"},\n        \"hyperlink\": {\"foreground\": \"#3A66DD\", \"underline\": True},\n        # paren matcher\n        \"surrounding_parens\": {\"foreground\": \"Blue\", \"font\": \"BoldEditorFont\"},\n        \"unclosed_expression\": {\"background\": \"LightGray\"},\n        # find/replace\n        \"found\": {\"foreground\": \"blue\", \"underline\": True},\n        \"current_found\": {\"foreground\": \"white\", \"background\": \"red\"},\n        \"matched_name\": {\"background\": \"#e6ecfe\"},\n        \"local_name\": {\"font\": \"ItalicEditorFont\"},\n        # debugger\n        \"active_focus\": {\"background\": \"#F8FC9A\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"suspended_focus\": {\"background\": \"\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"completed_focus\": {\"background\": \"#BBEDB2\", \"borderwidth\": 1, \"relief\": \"flat\"},\n        \"exception_focus\": {\"background\": \"#FFBFD6\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"expression_box\": {\"background\": \"#DCEDF2\", \"foreground\": default_fg},\n        \"black_fg\": {\"foreground\": \"#2E3436\"},\n        \"black_bg\": {\"background\": \"#2E3436\"},\n        \"bright_black_fg\": {\"foreground\": \"#555753\"},\n        \"bright_black_bg\": {\"background\": \"#555753\"},\n        \"dim_black_fg\": {\"foreground\": \"#1E2224\"},\n        \"dim_black_bg\": {\"background\": \"#1E2224\"},\n        \"red_fg\": {\"foreground\": \"#CC0000\"},\n        \"red_bg\": {\"background\": \"#CC0000\"},\n        \"bright_red_fg\": {\"foreground\": \"#EF2929\"},\n        \"bright_red_bg\": {\"background\": \"#EF2929\"},\n        \"dim_red_fg\": {\"foreground\": \"#880000\"},\n        \"dim_red_bg\": {\"background\": \"#880000\"},\n        \"green_fg\": {\"foreground\": \"#4E9A06\"},\n        \"green_bg\": {\"background\": \"#4E9A06\"},\n        \"bright_green_fg\": {\"foreground\": \"#8AE234\"},\n        \"bright_green_bg\": {\"background\": \"#8AE234\"},\n        \"dim_green_fg\": {\"foreground\": \"#346704\"},\n        \"dim_green_bg\": {\"background\": \"#346704\"},\n        \"yellow_fg\": {\"foreground\": \"#C4A000\"},\n        \"yellow_bg\": {\"background\": \"#C4A000\"},\n        \"bright_yellow_fg\": {\"foreground\": \"#FCE94F\"},\n        \"bright_yellow_bg\": {\"background\": \"#FCE94F\"},\n        \"dim_yellow_fg\": {\"foreground\": \"#836B00\"},\n        \"dim_yellow_bg\": {\"background\": \"#836B00\"},\n        \"blue_fg\": {\"foreground\": \"#3465A4\"},\n        \"blue_bg\": {\"background\": \"#3465A4\"},\n        \"bright_blue_fg\": {\"foreground\": \"#729FCF\"},\n        \"bright_blue_bg\": {\"background\": \"#729FCF\"},\n        \"dim_blue_fg\": {\"foreground\": \"#22436D\"},\n        \"dim_blue_bg\": {\"background\": \"#22436D\"},\n        \"magenta_fg\": {\"foreground\": \"#75507B\"},\n        \"magenta_bg\": {\"background\": \"#75507B\"},\n        \"bright_magenta_fg\": {\"foreground\": \"#AD7FA8\"},\n        \"bright_magenta_bg\": {\"background\": \"#AD7FA8\"},\n        \"dim_magenta_fg\": {\"foreground\": \"#4E3552\"},\n        \"dim_magenta_bg\": {\"background\": \"#4E3552\"},\n        \"cyan_fg\": {\"foreground\": \"#06989A\"},\n        \"cyan_bg\": {\"background\": \"#06989A\"},\n        \"bright_cyan_fg\": {\"foreground\": \"#34E2E2\"},\n        \"bright_cyan_bg\": {\"background\": \"#34E2E2\"},\n        \"dim_cyan_fg\": {\"foreground\": \"#046567\"},\n        \"dim_cyan_bg\": {\"background\": \"#046567\"},\n        \"white_fg\": {\"foreground\": \"#D3D7CF\"},\n        \"white_bg\": {\"background\": \"#D3D7CF\"},\n        \"bright_white_fg\": {\"foreground\": \"#EEEEEC\"},\n        \"bright_white_bg\": {\"background\": \"#EEEEEC\"},\n        \"dim_white_fg\": {\"foreground\": \"#8D8F8A\"},\n        \"dim_white_bg\": {\"background\": \"#8D8F8A\"},\n        \"fore_fg\": {\"foreground\": default_fg},\n        \"fore_bg\": {\"background\": default_fg},\n        \"bright_fore_fg\": {\"foreground\": \"#000000\"},\n        \"bright_fore_bg\": {\"background\": \"#000000\"},\n        \"dim_fore_fg\": {\"foreground\": \"#222222\"},\n        \"dim_fore_bg\": {\"background\": \"#222222\"},\n        \"back_fg\": {\"foreground\": default_bg},\n        \"back_bg\": {\"background\": default_bg},\n        \"bright_back_fg\": {\"foreground\": \"#ffffff\"},\n        \"bright_back_bg\": {\"background\": \"#ffffff\"},\n        \"dim_back_fg\": {\"foreground\": \"#e0e0e0\"},\n        \"dim_back_bg\": {\"background\": \"#e0e0e0\"},\n        \"intense_io\": {\"font\": \"BoldIOFont\"},\n        \"italic_io\": {\"font\": \"ItalicIOFont\"},\n        \"intense_italic_io\": {\"font\": \"BoldItalicIOFont\"},\n        \"underline\": {\"underline\": True},\n        \"strikethrough\": {\"overstrike\": True},\n    }", "is_method": false, "function_description": "Provides a complete set of default visual settings for a light syntax theme. It defines colors, fonts, and styles for editor elements, debugger states, and console outputs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "default_dark", "line_number": 127, "body": "def default_dark() -> SyntaxThemeSettings:\n    default_fg = \"#B3B3B3\"\n    default_bg = \"#2d2d2d\"\n    string_fg = \"#8DC76F\"\n    open_string_bg = \"#224533\"\n    gutter_foreground = \"#606060\"\n    gutter_background = \"#323232\"\n\n    # s.configure(\"Local.Code\", foreground=\"#BCCAE8\")\n    # s.configure(\"MatchedName.Code\", background=\"#193022\")\n\n    return {\n        \"TEXT\": {\n            \"foreground\": default_fg,\n            \"insertbackground\": default_fg,\n            \"background\": default_bg,\n        },\n        \"GUTTER\": {\"foreground\": gutter_foreground, \"background\": gutter_background},\n        \"breakpoint\": {\"foreground\": \"pink\"},\n        \"current_line\": {\"background\": \"#363636\"},\n        \"sel\": {\"foreground\": \"#eeeeee\", \"background\": \"#6E6E6E\"},\n        \"definition\": {\"foreground\": default_fg},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg, \"background\": None, \"font\": \"EditorFont\"},\n        \"open_string\": {\"foreground\": string_fg, \"background\": open_string_bg},\n        \"open_string3\": {\n            \"foreground\": string_fg,\n            \"background\": open_string_bg,\n            \"font\": \"EditorFont\",\n        },\n        \"tab\": {\"background\": \"#424034\"},\n        \"builtin\": {\"foreground\": \"#A9B1C9\"},\n        \"keyword\": {\"foreground\": \"#A9B1C9\", \"font\": \"BoldEditorFont\"},\n        \"number\": {\"foreground\": \"#FFCABF\"},\n        \"comment\": {\"foreground\": \"#D4D44E\"},\n        \"welcome\": {\"foreground\": \"pink\"},\n        \"magic\": {\"foreground\": \"pink\"},\n        # shell\n        \"prompt\": {\"foreground\": \"#5BEBBB\", \"font\": \"BoldEditorFont\"},\n        \"stdin\": {\"foreground\": \"LightBlue\"},\n        \"stdout\": {\"foreground\": \"LightGray\"},\n        \"stderr\": {\"foreground\": \"#EB5B83\"},\n        \"value\": {\"foreground\": \"#EBEB5B\"},\n        \"hyperlink\": {\"foreground\": \"#619DC7\", \"underline\": True},\n        # paren matcher\n        \"surrounding_parens\": {\"foreground\": \"#F0995B\", \"font\": \"BoldEditorFont\"},\n        \"unclosed_expression\": {\"background\": \"#000000\"},\n        # find/replace\n        \"found\": {\"underline\": True},\n        \"current_found\": {\"foreground\": \"white\", \"background\": \"red\"},\n        \"matched_name\": {\"background\": \"#474747\"},\n        \"local_name\": {\"font\": \"ItalicEditorFont\"},\n        # debugger\n        \"active_focus\": {\"background\": \"#807238\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"suspended_focus\": {\"background\": \"\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"completed_focus\": {\"background\": \"#807238\", \"borderwidth\": 1, \"relief\": \"flat\"},\n        \"exception_focus\": {\"background\": \"#FFBFD6\", \"borderwidth\": 1, \"relief\": \"solid\"},\n        \"expression_box\": {\"background\": \"#506E67\", \"foreground\": default_fg},\n        \"black_fg\": {\"foreground\": \"#2E3436\"},\n        \"black_bg\": {\"background\": \"#2E3436\"},\n        \"bright_black_fg\": {\"foreground\": \"#555753\"},\n        \"bright_black_bg\": {\"background\": \"#555753\"},\n        \"dim_black_fg\": {\"foreground\": \"#1E2224\"},\n        \"dim_black_bg\": {\"background\": \"#1E2224\"},\n        \"red_fg\": {\"foreground\": \"#CC0000\"},\n        \"red_bg\": {\"background\": \"#CC0000\"},\n        \"bright_red_fg\": {\"foreground\": \"#EF2929\"},\n        \"bright_red_bg\": {\"background\": \"#EF2929\"},\n        \"dim_red_fg\": {\"foreground\": \"#880000\"},\n        \"dim_red_bg\": {\"background\": \"#880000\"},\n        \"green_fg\": {\"foreground\": \"#4E9A06\"},\n        \"green_bg\": {\"background\": \"#4E9A06\"},\n        \"bright_green_fg\": {\"foreground\": \"#8AE234\"},\n        \"bright_green_bg\": {\"background\": \"#8AE234\"},\n        \"dim_green_fg\": {\"foreground\": \"#346704\"},\n        \"dim_green_bg\": {\"background\": \"#346704\"},\n        \"yellow_fg\": {\"foreground\": \"#C4A000\"},\n        \"yellow_bg\": {\"background\": \"#C4A000\"},\n        \"bright_yellow_fg\": {\"foreground\": \"#FCE94F\"},\n        \"bright_yellow_bg\": {\"background\": \"#FCE94F\"},\n        \"dim_yellow_fg\": {\"foreground\": \"#836B00\"},\n        \"dim_yellow_bg\": {\"background\": \"#836B00\"},\n        \"blue_fg\": {\"foreground\": \"#3465A4\"},\n        \"blue_bg\": {\"background\": \"#3465A4\"},\n        \"bright_blue_fg\": {\"foreground\": \"#729FCF\"},\n        \"bright_blue_bg\": {\"background\": \"#729FCF\"},\n        \"dim_blue_fg\": {\"foreground\": \"#22436D\"},\n        \"dim_blue_bg\": {\"background\": \"#22436D\"},\n        \"magenta_fg\": {\"foreground\": \"#75507B\"},\n        \"magenta_bg\": {\"background\": \"#75507B\"},\n        \"bright_magenta_fg\": {\"foreground\": \"#AD7FA8\"},\n        \"bright_magenta_bg\": {\"background\": \"#AD7FA8\"},\n        \"dim_magenta_fg\": {\"foreground\": \"#4E3552\"},\n        \"dim_magenta_bg\": {\"background\": \"#4E3552\"},\n        \"cyan_fg\": {\"foreground\": \"#06989A\"},\n        \"cyan_bg\": {\"background\": \"#06989A\"},\n        \"bright_cyan_fg\": {\"foreground\": \"#34E2E2\"},\n        \"bright_cyan_bg\": {\"background\": \"#34E2E2\"},\n        \"dim_cyan_fg\": {\"foreground\": \"#046567\"},\n        \"dim_cyan_bg\": {\"background\": \"#046567\"},\n        \"white_fg\": {\"foreground\": \"#D3D7CF\"},\n        \"white_bg\": {\"background\": \"#D3D7CF\"},\n        \"bright_white_fg\": {\"foreground\": \"#EEEEEC\"},\n        \"bright_white_bg\": {\"background\": \"#EEEEEC\"},\n        \"dim_white_fg\": {\"foreground\": \"#8D8F8A\"},\n        \"dim_white_bg\": {\"background\": \"#8D8F8A\"},\n        \"fore_fg\": {\"foreground\": default_fg},\n        \"fore_bg\": {\"background\": default_fg},\n        \"bright_fore_fg\": {\"foreground\": \"#ffffff\"},\n        \"bright_fore_bg\": {\"background\": \"#ffffff\"},\n        \"dim_fore_fg\": {\"foreground\": \"#e0e0e0\"},\n        \"dim_fore_bg\": {\"background\": \"#e0e0e0\"},\n        \"back_fg\": {\"foreground\": default_bg},\n        \"back_bg\": {\"background\": default_bg},\n        \"bright_back_fg\": {\"foreground\": \"#000000\"},\n        \"bright_back_bg\": {\"background\": \"#000000\"},\n        \"dim_back_fg\": {\"foreground\": \"#222222\"},\n        \"dim_back_bg\": {\"background\": \"#222222\"},\n        \"intense_io\": {\"font\": \"BoldIOFont\"},\n        \"italic_io\": {\"font\": \"ItalicIOFont\"},\n        \"intense_italic_io\": {\"font\": \"BoldItalicIOFont\"},\n        \"underline\": {\"underline\": True},\n        \"strikethrough\": {\"overstrike\": True},\n    }", "is_method": false, "function_description": "Provides a default dark syntax theme. It defines comprehensive color and styling settings for various code editor elements, debugger components, and shell output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "default_dark_green", "line_number": 253, "body": "def default_dark_green() -> SyntaxThemeSettings:\n    open_string_bg = \"#453B22\"\n    gutter_background = \"#33402F\"\n\n    return {\n        \"TEXT\": {\"background\": \"#273627\"},\n        \"GUTTER\": {\"background\": gutter_background},\n        \"current_line\": {\"background\": \"#2E402E\"},\n        \"sel\": {\"background\": \"#6E6E6E\"},\n        \"unclosed_expression\": {\"background\": \"#0F1F15\"},\n        \"open_string\": {\"background\": open_string_bg},\n        \"open_string3\": {\"background\": open_string_bg},\n        \"keyword\": {\"foreground\": \"#88CFB6\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#88CFB6\"},\n        # debugger\n        \"active_focus\": {\"background\": \"#807238\"},\n        \"completed_focus\": {\"background\": \"#807238\"},\n        \"exception_focus\": {\"background\": \"#FFBFD6\"},\n        \"expression_box\": {\"background\": \"#506E67\"},\n    }", "is_method": false, "function_description": "Provides a complete, predefined dark green color scheme for an editor's syntax highlighting and UI elements. It defines default visual settings for a programming environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "default_dark_blue", "line_number": 275, "body": "def default_dark_blue() -> SyntaxThemeSettings:\n    open_string_bg = \"#224533\"\n    gutter_background = \"#2F3640\"\n    return {\n        \"TEXT\": {\"background\": \"#272936\"},\n        \"GUTTER\": {\"background\": gutter_background},\n        \"current_line\": {\"background\": \"#2D3040\"},\n        \"sel\": {\"background\": \"#6E6E6E\"},\n        \"unclosed_expression\": {\"background\": \"#100B21\"},\n        \"open_string\": {\"background\": open_string_bg},\n        \"open_string3\": {\"background\": open_string_bg},\n        \"keyword\": {\"foreground\": \"#8899CF\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#8899CF\"},\n        # debugger\n        \"active_focus\": {\"background\": \"#807238\"},\n        \"completed_focus\": {\"background\": \"#807238\"},\n        \"exception_focus\": {\"background\": \"#FFBFD6\"},\n        \"expression_box\": {\"background\": \"#506E67\"},\n    }", "is_method": false, "function_description": "This function provides a predefined \"dark blue\" color scheme. It returns a dictionary of settings for various UI elements within a syntax highlighting editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "idle_classic", "line_number": 296, "body": "def idle_classic() -> SyntaxThemeSettings:\n    string_fg = \"#00aa00\"\n    return {\n        \"TEXT\": {\"foreground\": \"black\", \"insertbackground\": \"black\", \"background\": \"white\"},\n        \"GUTTER\": {\"foreground\": \"gray\", \"background\": \"#efefef\"},\n        \"sel\": {\"foreground\": \"black\", \"background\": \"gray\"},\n        \"number\": {\"foreground\": \"black\"},\n        \"definition\": {\"foreground\": \"#0000ff\", \"font\": \"EditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string_fg},\n        \"open_string3\": {\"foreground\": string_fg},\n        \"keyword\": {\"foreground\": \"#ff7700\", \"font\": \"EditorFont\"},\n        \"builtin\": {\"foreground\": \"#900090\"},\n        \"comment\": {\"foreground\": \"#dd0000\"},\n        \"prompt\": {\"foreground\": \"#770000\"},\n        \"stdin\": {\"foreground\": \"black\"},\n        \"stdout\": {\"foreground\": \"Blue\"},\n        \"value\": {\"foreground\": \"Blue\"},\n        \"stderr\": {\"foreground\": \"Red\"},\n        \"found\": {\"foreground\": \"\", \"underline\": True},\n        \"current_found\": {\"foreground\": \"white\", \"background\": \"black\"},\n    }", "is_method": false, "function_description": "Provides the full color and font definitions for the classic IDLE syntax highlighting theme, enabling consistent visual styling for code elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "idle_dark", "line_number": 321, "body": "def idle_dark() -> SyntaxThemeSettings:\n    normal_fg = \"white\"\n    string_fg = \"#02ff02\"\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#002240\"},\n        \"sel\": {\"foreground\": \"#FFFFFF\", \"background\": \"#7e7e7e\"},\n        \"number\": {\"foreground\": normal_fg},\n        \"definition\": {\"foreground\": \"#5e5eff\", \"font\": \"EditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string_fg},\n        \"open_string3\": {\"foreground\": string_fg},\n        \"keyword\": {\"foreground\": \"#ff8000\", \"font\": \"EditorFont\"},\n        \"builtin\": {\"foreground\": \"#ff00ff\"},\n        \"comment\": {\"foreground\": \"#dd0000\"},\n        \"welcome\": {\"foreground\": \"#dd0000\"},\n        \"prompt\": {\"foreground\": \"#ff4d4d\"},\n        \"stdin\": {\"foreground\": normal_fg},\n        \"stdout\": {\"foreground\": \"#c2d1fa\"},\n        \"value\": {\"foreground\": \"#c2d1fa\"},\n        \"stderr\": {\"foreground\": \"#ffb3b3\"},\n        \"found\": {\"foreground\": \"\", \"underline\": True},\n        \"current_found\": {\"foreground\": \"#002240\", \"background\": \"#fbfbfb\"},\n    }", "is_method": false, "function_description": "Provides a comprehensive definition for a dark syntax highlighting theme, specifying color and font settings for various text elements in an editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "desert_sunset", "line_number": 348, "body": "def desert_sunset() -> SyntaxThemeSettings:\n    normal_fg = \"#f0e68c\"\n    string_fg = \"#ffa0a0\"\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#333333\"},\n        \"GUTTER\": {\"foreground\": \"gray\", \"background\": \"#404040\"},\n        \"sel\": {\"foreground\": \"#000000\", \"background\": \"gray\"},\n        \"number\": {\"foreground\": normal_fg},\n        \"definition\": {\"foreground\": \"#98fb98\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string_fg},\n        \"open_string3\": {\"foreground\": string_fg},\n        \"keyword\": {\"foreground\": \"#cc6600\"},\n        \"builtin\": {\"foreground\": \"#519e51\"},\n        \"comment\": {\"foreground\": \"#87ceeb\"},\n        \"welcome\": {\"foreground\": \"#87ceeb\"},\n        \"prompt\": {\"foreground\": \"#87ceeb\"},\n        \"stdin\": {\"foreground\": normal_fg},\n        \"stdout\": {\"foreground\": \"#eeeeee\"},\n        \"value\": {\"foreground\": \"#eeeeee\"},\n        \"stderr\": {\"foreground\": \"#ff595b\"},\n        \"found\": {\"foreground\": \"\", \"underline\": True},\n        \"current_found\": {\"foreground\": \"#ffffff\", \"background\": \"#333333\"},\n    }", "is_method": false, "function_description": "Returns a dictionary defining the 'Desert Sunset' syntax theme. It provides specific color settings for various code elements and UI components, enabling a pre-configured visual style."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "zenburn", "line_number": 376, "body": "def zenburn() -> SyntaxThemeSettings:\n    # https://github.com/mig/gedit-themes/blob/master/zenburn.xml\n    # https://github.com/trusktr/gedit-color-schemes/blob/master/gtksourceview-3.0/styles/zenburn.xml\n    normal_fg = \"#dcdccc\"\n    string_fg = \"#cc9393\"\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#3f3f3f\"},\n        \"GUTTER\": {\"foreground\": \"#7f8f8f\", \"background\": \"#464646\"},\n        \"current_line\": {\"background\": \"#4A4A4A\"},\n        \"sel\": {\"foreground\": \"white\", \"background\": \"#506070\"},\n        \"number\": {\"foreground\": \"#8cd0d3\"},\n        \"definition\": {\"foreground\": \"#f4a020\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string_fg},\n        \"open_string3\": {\"foreground\": string_fg},\n        \"keyword\": {\"foreground\": \"#f0dfaf\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#efef8f\"},\n        \"comment\": {\"foreground\": \"#7f9f7f\"},\n        \"welcome\": {\"foreground\": \"#7f9f7f\"},\n        \"prompt\": {\"foreground\": \"#87ceeb\"},\n        \"stdin\": {\"foreground\": normal_fg},\n        \"stdout\": {\"foreground\": \"#eeeeee\"},\n        \"value\": {\"foreground\": \"#eeeeee\"},\n        \"stderr\": {\"foreground\": \"#ff3e40\"},\n        # paren matcher\n        \"surrounding_parens\": {\"foreground\": \"white\", \"font\": \"BoldEditorFont\"},\n    }", "is_method": false, "function_description": "Provides the complete visual configuration for the Zenburn editor theme. It defines color and font settings for various syntax elements and UI components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_syntax_themes.py", "function": "load_plugin", "line_number": 407, "body": "def load_plugin() -> None:\n    get_workbench().add_syntax_theme(\"Default Light\", None, default_light)\n    get_workbench().add_syntax_theme(\"Default Dark\", None, default_dark)\n    get_workbench().add_syntax_theme(\"Default Dark Green\", \"Default Dark\", default_dark_green)\n    get_workbench().add_syntax_theme(\"Default Dark Blue\", \"Default Dark\", default_dark_blue)\n    get_workbench().add_syntax_theme(\"Desert Sunset\", \"Default Dark\", desert_sunset)\n    get_workbench().add_syntax_theme(\"Zenburn\", \"Default Dark\", zenburn)\n    get_workbench().add_syntax_theme(\"IDLE Classic\", \"Default Light\", idle_classic)\n\n    # Comments in IDLE Dark really hurt the eyes\n    # get_workbench().add_syntax_theme(\"IDLE Dark\", \"Default Dark\", idle_dark)\n\n    get_workbench().set_default(\"view.syntax_theme\", \"Default Light\")", "is_method": false, "function_description": "This function loads and registers various syntax themes for the application's workbench, setting 'Default Light' as the initial default theme."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/goto_definition.py", "function": "goto_definition", "line_number": 11, "body": "def goto_definition(event):\n    if not control_is_pressed(event.state):\n        return\n\n    assert isinstance(event.widget, tk.Text)\n    text = event.widget\n\n    source = text.get(\"1.0\", \"end\")\n    index = text.index(\"insert\")\n    index_parts = index.split(\".\")\n    line, column = int(index_parts[0]), int(index_parts[1])\n    try:\n        editor = text.master.home_widget\n        path = editor.get_filename()\n    except Exception as e:\n        logger.warning(\"Could not get path\", exc_info=e)\n        path = None\n\n    defs = jedi_utils.get_definitions(source, line, column, path)\n    if len(defs) > 0:\n        # TODO: handle multiple results like PyCharm\n        module_path = str(defs[0].module_path)\n        if not os.path.isfile(module_path):\n            logger.warning(\"%s is not a file\", module_path)\n            return\n\n        module_name = defs[0].module_name\n        line = defs[0].line\n        if module_path and line is not None:\n            get_workbench().get_editor_notebook().show_file(module_path, line)\n        elif module_name == \"\" and line is not None:  # current editor\n            get_workbench().get_editor_notebook().get_current_editor().select_range(line)", "is_method": false, "function_description": "Enables \"go to definition\" functionality within a text editor. It navigates to the source code definition of a symbol under the cursor, typically triggered by a user event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/goto_definition.py", "function": "load_plugin", "line_number": 45, "body": "def load_plugin() -> None:\n    wb = get_workbench()\n    wb.bind_class(\"CodeViewText\", \"<1>\", goto_definition, True)", "is_method": false, "function_description": "Loads an IDE plugin to enable \"go to definition\" functionality. It binds a mouse click event in code views to navigate to symbol definitions, enhancing code exploration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "update_editor_cells", "line_number": 11, "body": "def update_editor_cells(event):\n    text = event.widget\n\n    if not getattr(text, \"cell_tags_configured\", False):\n        text.tag_configure(\"CURRENT_CELL\", borderwidth=1, relief=\"groove\", background=\"LightYellow\")\n        text.tag_configure(\"CELL_HEADER\", font=\"BoldEditorFont\", foreground=\"#665843\")\n\n        text.tag_lower(\"CELL_HEADER\")\n        text.tag_lower(\"CURRENT_CELL\")\n        text.cell_tags_configured = True\n\n    text.tag_remove(\"CURRENT_CELL\", \"0.1\", \"end\")\n    text.tag_remove(\"CELL_HEADER\", \"0.1\", \"end\")\n    source = text.get(\"1.0\", \"end\")\n    cells = []\n    prev_marker = 0\n    for match in cell_regex.finditer(source):\n        if match.start() == 0:\n            this_marker = match.start()\n        else:\n            this_marker = match.start() + 1\n\n        cell_start_index = text.index(\"1.0+%dc\" % prev_marker)\n        header_end_index = text.index(\"1.0+%dc\" % match.end())\n        cell_end_index = text.index(\"1.0+%dc\" % this_marker)\n        text.tag_add(\"CELL_HEADER\", cell_end_index, header_end_index)\n        cells.append((cell_start_index, cell_end_index))\n\n        prev_marker = this_marker\n\n    if prev_marker != 0:\n        cells.append((text.index(\"1.0+%dc\" % prev_marker), \"end\"))\n\n    # if get_workbench().focus_get() == text:\n    # It's nice to have cell highlighted even when focus\n    # is elsewhere ? This would act as kind of bookmark.\n\n    for start_index, end_index in cells:\n        if text.compare(start_index, \"<=\", \"insert\") and text.compare(end_index, \">\", \"insert\"):\n            text.tag_add(\"CURRENT_CELL\", start_index, end_index)\n            break", "is_method": false, "function_description": "Updates the visual representation of cells in a text editor. It identifies and styles cell headers, then highlights the active cell where the cursor is currently located."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "_submit_code", "line_number": 54, "body": "def _submit_code(code):\n    lines = code.splitlines()\n\n    # remove starting comments\n    while len(lines) > 0 and lines[0].strip().startswith(\"#\"):\n        lines = lines[1:]\n\n    # remove starting empty lines\n    while len(lines) > 0 and lines[0].strip() == \"\":\n        lines = lines[1:]\n\n    # remove trailing empty lines\n    while len(lines) > 0 and lines[-1].strip() == \"\":\n        lines = lines[:-1]\n\n    if len(lines) > 0:\n        code = \"\\n\".join(lines) + \"\\n\"\n        # if code is function definition/last line start with whitespace\n        # end function definition with a second endline\n        if re.match(r\"^[ \\t].*\", lines[-1]) is not None:\n            code += \"\\n\"\n        shell = get_workbench().show_view(\"ShellView\", False)\n        shell.submit_python_code(code)", "is_method": false, "function_description": "Cleans Python code by removing leading/trailing comments and empty lines, then submits the prepared code to an interactive shell for execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "_patch_perform_return", "line_number": 79, "body": "def _patch_perform_return():\n    original_perform_return = CodeViewText.perform_return\n\n    def _patched_perform_return(self, event):\n        text = event.widget\n        ranges = text.tag_ranges(\"CURRENT_CELL\")\n\n        if len(ranges) == 2 and (\n            ui_utils.shift_is_pressed(event.state) or ui_utils.control_is_pressed(event.state)\n        ):\n\n            if run_enabled():\n                code = text.get(ranges[0], ranges[1]).strip()\n                _submit_code(code)\n\n                if ui_utils.shift_is_pressed(event.state):\n                    # advance to next cell\n                    text.mark_set(\"insert\", ranges[1])\n\n            return \"break\"\n        else:\n            return original_perform_return(self, event)\n\n    CodeViewText.perform_return = _patched_perform_return", "is_method": false, "function_description": "Patches the `CodeViewText.perform_return` method to enable executing code in the current cell via Shift or Ctrl + Enter. It optionally advances the cursor to the next cell after execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "_patch_intercept_mark", "line_number": 105, "body": "def _patch_intercept_mark():\n    \"\"\"Need to make cursor wider when in first column. Otherwise\n    the border of the cell box makes it hard to notice the cursor.\n\n    NB! Need to be careful with setting text[\"insertwidth\"]!\n    My first straightforward solution caused unexplainable\n    infinite loop of insertions and deletions in the text\n    (insert a line and a word, select that word and then do Ctrl-Z).\n\n    Looks like this solution is safe, but I don't dare to include\n    it in the main code.\n\n    UPDATE: not safe. Select and delete a block of lines. Write a new\n    line and do Ctrl-Z\"\"\"\n\n    original_intercept_mark = CodeViewText.intercept_mark\n\n    def _patched_intercept_mark(self, *args):\n        if args[:2] == (\"set\", \"insert\") and args[2].endswith(\".0\"):\n            self.set_insertwidth(3)\n        else:\n            self.set_insertwidth(2)\n\n        original_intercept_mark(self, *args)\n\n    CodeViewText.intercept_mark = _patched_intercept_mark", "is_method": false, "function_description": "This function patches a code view's cursor handling to dynamically widen the cursor when at the beginning of a line. This aims to improve cursor visibility against cell borders."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "run_selection", "line_number": 137, "body": "def run_selection(event=None):\n    widget = get_workbench().focus_get()\n    if isinstance(widget, CodeViewText):\n        text = widget\n\n        if text.has_selection():\n            code = text.get(\"sel.first\", \"sel.last\")\n        else:\n            code = text.get(\"insert linestart\", \"insert lineend\")\n\n        # move cursor to next row\n        row, col = map(int, text.index(\"insert\").split(\".\"))\n        text.mark_set(\"insert\", \"{}.{}\".format(row + 1, col))\n\n        _submit_code(code)", "is_method": false, "function_description": "Submits either the selected code or the current line from a `CodeViewText` widget for execution. It then advances the text cursor to the next line, supporting interactive code execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "run_enabled", "line_number": 154, "body": "def run_enabled():\n    widget = get_workbench().focus_get()\n    return isinstance(widget, CodeViewText) and get_runner().is_waiting_toplevel_command()", "is_method": false, "function_description": "Determines if a 'run' action should be enabled, checking if a code view is focused and the code runner is ready for a new command. This enables context-aware execution controls."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "_load_plugin", "line_number": 159, "body": "def _load_plugin():\n    wb = get_workbench()\n    wb.bind_class(\"CodeViewText\", \"<<CursorMove>>\", update_editor_cells, True)\n    wb.bind_class(\"CodeViewText\", \"<<TextChange>>\", update_editor_cells, True)\n    wb.bind_class(\"CodeViewText\", \"<FocusIn>\", update_editor_cells, True)\n    wb.bind_class(\"CodeViewText\", \"<FocusOut>\", update_editor_cells, True)\n\n    _patch_perform_return()\n    # TODO: try changing insertwidth in keyup/mouseup events\n    # _patch_intercept_mark() # Still causes freezes\n\n    wb.add_command(\n        \"run_cell\",\n        \"run\",\n        (\"Run cell\"),\n        handler=dummy,  # actual handler is in the patch\n        default_sequence=\"<Control-Return>\",\n        tester=run_enabled,\n        group=11,\n    )\n\n    wb.add_command(\n        \"run_cell_and_advance\",\n        \"run\",\n        (\"Run cell and advance\"),\n        handler=dummy,  # actual handler is in the patch\n        default_sequence=\"<Shift-Return>\",\n        tester=run_enabled,\n        group=11,\n    )\n\n    wb.add_command(\n        \"run_selection\",\n        \"run\",\n        (\"Run selection or current line\"),\n        handler=run_selection,\n        default_sequence=\"<F9>\",\n        tester=run_enabled,\n        group=11,\n    )", "is_method": false, "function_description": "Loads an editor plugin, configuring UI event handlers and adding commands for interactive code execution. It enables running code cells and selections within the workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "_patched_perform_return", "line_number": 82, "body": "def _patched_perform_return(self, event):\n        text = event.widget\n        ranges = text.tag_ranges(\"CURRENT_CELL\")\n\n        if len(ranges) == 2 and (\n            ui_utils.shift_is_pressed(event.state) or ui_utils.control_is_pressed(event.state)\n        ):\n\n            if run_enabled():\n                code = text.get(ranges[0], ranges[1]).strip()\n                _submit_code(code)\n\n                if ui_utils.shift_is_pressed(event.state):\n                    # advance to next cell\n                    text.mark_set(\"insert\", ranges[1])\n\n            return \"break\"\n        else:\n            return original_perform_return(self, event)", "is_method": false, "function_description": "Provides custom handling for the Return key in a text widget. When Shift or Control is pressed, it executes code from the current cell and optionally advances the cursor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cells.py", "function": "_patched_intercept_mark", "line_number": 122, "body": "def _patched_intercept_mark(self, *args):\n        if args[:2] == (\"set\", \"insert\") and args[2].endswith(\".0\"):\n            self.set_insertwidth(3)\n        else:\n            self.set_insertwidth(2)\n\n        original_intercept_mark(self, *args)", "is_method": false, "function_description": "This function customizes the insert cursor's visual width in a text component. It sets a wider cursor for specific \"set insert\" operations before executing the original mark interception logic."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/terminal_config_page.py", "function": "load_plugin", "line_number": 39, "body": "def load_plugin():\n    get_workbench().add_configuration_page(\n        \"terminal\", tr(\"Terminal\"), TerminalConfigurationPage, 60\n    )", "is_method": false, "function_description": "Integrates a 'Terminal' configuration page into the application's workbench, allowing users to configure terminal-related settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "load_plugin", "line_number": 714, "body": "def load_plugin() -> None:\n    get_workbench().add_view(ObjectInspector, tr(\"Object inspector\"), \"se\")", "is_method": false, "function_description": "Integrates an Object Inspector view into the application's workbench. This enables users to inspect runtime objects for debugging and analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_create_toolbar", "line_number": 43, "body": "def _create_toolbar(self):\n        toolbar = ttk.Frame(self, style=\"ViewToolbar.TFrame\")\n\n        self.title_label = ttk.Label(\n            toolbar,\n            style=\"ViewToolbar.TLabel\",\n            text=\"\"\n            # borderwidth=1,\n            # background=ui_utils.get_main_background()\n        )\n        self.title_label.grid(row=0, column=3, sticky=\"nsew\", pady=5, padx=5)\n        toolbar.columnconfigure(3, weight=1)\n\n        self.tabs = []\n\n        def create_tab(col, caption, page):\n            if page == self.active_page:\n                style = \"Active.ViewTab.TLabel\"\n            else:\n                style = \"Inactive.ViewTab.TLabel\"\n            tab = ttk.Label(toolbar, text=caption, style=style)\n            tab.grid(row=0, column=col, pady=5, padx=5, sticky=\"nsew\")\n            self.tabs.append(tab)\n            page.tab = tab\n\n            def on_click(event):\n                if self.active_page == page:\n                    return\n                else:\n                    if self.active_page is not None:\n                        self.active_page.grid_forget()\n                        self.active_page.tab.configure(style=\"Inactive.ViewTab.TLabel\")\n\n                    self.active_page = page\n                    page.grid(row=1, column=0, sticky=\"nsew\", padx=0)\n                    tab.configure(style=\"Active.ViewTab.TLabel\")\n                    if (\n                        self.active_page == self.attributes_page\n                        and (self.object_info is None or not self.object_info.get(\"attributes\"))\n                        and self.object_id is not None\n                    ):\n                        self.request_object_info()\n\n            tab.bind(\"<1>\", on_click)\n\n        # create_tab(1, \"Overview\", self.general_page)\n        create_tab(5, tr(\"Data\"), self.content_page)\n        create_tab(6, tr(\"Attributes\"), self.attributes_page)\n\n        def create_navigation_link(col, image_filename, action, tooltip, padx=0):\n            button = ttk.Button(\n                toolbar,\n                # command=handler,\n                image=get_workbench().get_image(image_filename),\n                style=\"ViewToolbar.Toolbutton\",  # TODO: does this cause problems in some Macs?\n                state=tk.NORMAL,\n            )\n            ui_utils.create_tooltip(button, tooltip)\n\n            button.grid(row=0, column=col, sticky=tk.NE, padx=padx, pady=4)\n            button.bind(\"<Button-1>\", action)\n            return button\n\n        def configure(event):\n            if event.width > 20:\n                self.title_label.configure(wraplength=event.width - 10)\n\n        self.title_label.bind(\"<Configure>\", configure, True)\n\n        self.back_button = create_navigation_link(\n            1, \"nav-backward\", self.navigate_back, tr(\"Previous object\"), (5, 0)\n        )\n        self.forward_button = create_navigation_link(\n            2, \"nav-forward\", self.navigate_forward, tr(\"Next object\")\n        )\n        self.back_links = []\n        self.forward_links = []\n\n        return toolbar", "is_method": true, "class_name": "ObjectInspector", "function_description": "Creates the `ObjectInspector`'s interactive toolbar. It provides navigation buttons and tabs for switching between different views of the inspected object, enhancing user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_create_content_page", "line_number": 123, "body": "def _create_content_page(self):\n        self.content_page = ttk.Frame(self, style=\"ViewBody.TFrame\")\n        # type-specific inspectors\n        self.current_content_inspector = None\n        self.content_inspectors = []\n        # load custom inspectors\n        for insp_class in get_workbench().content_inspector_classes:\n            self.content_inspectors.append(insp_class(self.content_page))\n\n        # read standard inspectors\n        self.content_inspectors.extend(\n            [\n                FileHandleInspector(self.content_page),\n                FunctionInspector(self.content_page),\n                StringInspector(self.content_page),\n                ElementsInspector(self.content_page),\n                DictInspector(self.content_page),\n                ImageInspector(self.content_page),\n                IntInspector(self.content_page),\n                FloatInspector(self.content_page),\n                ReprInspector(self.content_page),  # fallback content inspector\n            ]\n        )\n\n        self.content_page.columnconfigure(0, weight=1)\n        self.content_page.rowconfigure(0, weight=1)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Sets up the content display area for the object inspector. It initializes and loads various type-specific content inspectors, both custom and standard, to prepare for showing object details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_create_attributes_page", "line_number": 150, "body": "def _create_attributes_page(self):\n        self.attributes_page = AttributesFrame(self)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Creates the dedicated UI page within the ObjectInspector responsible for displaying an object's attributes. This page provides a visual representation of the object's properties."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "navigate_back", "line_number": 153, "body": "def navigate_back(self, event):\n        if len(self.back_links) == 0:\n            return\n\n        self.forward_links.append(self.object_id)\n        self._show_object_by_id(self.back_links.pop(), True)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Allows returning to a previously inspected object within the ObjectInspector, while also enabling navigation forward again."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "navigate_forward", "line_number": 160, "body": "def navigate_forward(self, event):\n        if len(self.forward_links) == 0:\n            return\n\n        self.back_links.append(self.object_id)\n        self._show_object_by_id(self.forward_links.pop(), True)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Navigates the object inspector to the next object in its forward history. It updates the back history, enabling reverse navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "show_object", "line_number": 167, "body": "def show_object(self, event):\n        self._show_object_by_id(event.object_id)", "is_method": true, "class_name": "ObjectInspector", "function_description": "This ObjectInspector method displays a specific object. It extracts the object's identifier from the incoming event to initiate its presentation or inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_show_object_by_id", "line_number": 170, "body": "def _show_object_by_id(self, object_id, via_navigation=False):\n        assert object_id is not None\n\n        if self.winfo_ismapped() and self.object_id != object_id:\n            if not via_navigation and self.object_id is not None:\n                if self.object_id in self.back_links:\n                    self.back_links.remove(self.object_id)\n                self.back_links.append(self.object_id)\n                del self.forward_links[:]\n\n            context_id = self.object_id\n            self.object_id = object_id\n            self.set_object_info(None)\n            self._set_title(\"object @ \" + thonny.memory.format_object_id(object_id))\n            self.request_object_info(context_id=context_id)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Updates the `ObjectInspector` to display details for a specified object ID. It manages navigation history, enabling seamless movement between inspected objects."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_on_backend_restart", "line_number": 186, "body": "def _on_backend_restart(self, event=None):\n        self.set_object_info(None)\n        self.object_id = None", "is_method": true, "class_name": "ObjectInspector", "function_description": "Resets the object inspector's state when the backend restarts, clearing any currently displayed object information and ID. This ensures the inspector reflects the new backend state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_set_title", "line_number": 190, "body": "def _set_title(self, text):\n        self.title_label.configure(text=text)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Sets the displayed title for the object being inspected. This updates a UI element with the provided text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_handle_object_info_event", "line_number": 193, "body": "def _handle_object_info_event(self, msg):\n        if self.winfo_ismapped():\n            if msg.get(\"error\") and not msg.get(\"info\"):\n                self.set_object_info({\"error\": msg[\"error\"]})\n                return\n\n            if msg.info[\"id\"] == self.object_id:\n                if hasattr(msg, \"not_found\") and msg.not_found:\n                    self.object_id = None\n                    self.set_object_info(None)\n                else:\n                    self.set_object_info(msg.info)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Reacts to and processes incoming object information messages to update the `ObjectInspector`'s display. It handles error conditions, object not found, and valid data, ensuring UI consistency."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_handle_progress_event", "line_number": 206, "body": "def _handle_progress_event(self, event):\n        if self.object_id is not None:\n            # refresh\n            self.request_object_info()", "is_method": true, "class_name": "ObjectInspector", "function_description": "Responds to a progress event by refreshing the currently inspected object's details, ensuring its information remains up-to-date."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "request_object_info", "line_number": 211, "body": "def request_object_info(self, context_id=None):\n        # current width and height of the frame are required for\n        # some content providers\n        if self.active_page is not None:\n            frame_width = self.active_page.winfo_width()\n            frame_height = self.active_page.winfo_height()\n\n            # in some cases measures are inaccurate\n            if frame_width < 5 or frame_height < 5:\n                frame_width = None\n                frame_height = None\n        else:\n            frame_width = None\n            frame_height = None\n\n        get_runner().send_command(\n            InlineCommand(\n                \"get_object_info\",\n                object_id=self.object_id,\n                context_id=context_id,\n                back_links=self.back_links,\n                forward_links=self.forward_links,\n                include_attributes=self.active_page == self.attributes_page,\n                all_attributes=False,\n                frame_width=frame_width,\n                frame_height=frame_height,\n            )\n        )", "is_method": true, "class_name": "ObjectInspector", "function_description": "Requests comprehensive information about a specified object from a backend service. It prepares relevant context, including UI dimensions and navigation links, to facilitate detailed object information retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 240, "body": "def set_object_info(self, object_info):\n        self.object_info = object_info\n        if object_info is None or \"error\" in object_info:\n            if object_info is None:\n                self._set_title(\"\")\n            else:\n                self._set_title(object_info[\"error\"])\n            if self.current_content_inspector is not None:\n                self.current_content_inspector.grid_remove()\n                self.current_content_inspector = None\n            self.attributes_page.clear()\n        else:\n            self._set_title(\n                object_info[\"full_type_name\"]\n                + \" @ \"\n                + thonny.memory.format_object_id(object_info[\"id\"])\n            )\n            self.attributes_page.update_variables(object_info[\"attributes\"])\n            self.attributes_page.context_id = object_info[\"id\"]\n            self.update_type_specific_info(object_info)\n\n            # update layout\n            # self._expose(None)\n            # if not self.grid_frame.winfo_ismapped():\n            #    self.grid_frame.grid()\n\n        \"\"\"\n        if self.back_links == []:\n            self.back_label.config(foreground=\"lightgray\", cursor=\"arrow\")\n        else:\n            self.back_label.config(foreground=\"blue\", cursor=\"hand2\")\n\n        if self.forward_links == []:\n            self.forward_label.config(foreground=\"lightgray\", cursor=\"arrow\")\n        else:\n            self.forward_label.config(foreground=\"blue\", cursor=\"hand2\")\n        \"\"\"", "is_method": true, "class_name": "ObjectInspector", "function_description": "This method updates the ObjectInspector's display to show comprehensive information about a given Python object, including its type, ID, and attributes. It gracefully handles cases where object information is missing or erroneous."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "update_type_specific_info", "line_number": 278, "body": "def update_type_specific_info(self, object_info):\n        content_inspector = None\n        for insp in self.content_inspectors:\n            if insp.applies_to(object_info):\n                content_inspector = insp\n                break\n\n        if content_inspector != self.current_content_inspector:\n            if self.current_content_inspector is not None:\n                self.current_content_inspector.grid_remove()  # TODO: or forget?\n                self.current_content_inspector = None\n\n            if content_inspector is not None:\n                content_inspector.grid(row=0, column=0, sticky=tk.NSEW, padx=(0, 0))\n\n            self.current_content_inspector = content_inspector\n\n        if self.current_content_inspector is not None:\n            self.current_content_inspector.set_object_info(object_info)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Selects and displays the correct type-specific UI panel for the given object. It then updates this panel with the object's detailed information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 309, "body": "def applies_to(self, object_info):\n        return False", "is_method": true, "class_name": "ContentInspector", "function_description": "Determines if this content inspector applies to a given object. It always returns false, indicating it is never applicable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 322, "body": "def applies_to(self, object_info):\n        return \"file_content\" in object_info or \"file_error\" in object_info", "is_method": true, "class_name": "FileHandleInspector", "function_description": "Determines if the provided object information relates to file content or errors. It identifies whether the FileHandleInspector's logic should be applied to the given object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 325, "body": "def set_object_info(self, object_info):\n\n        if \"file_content\" not in object_info:\n            logging.exception(\"File error: \" + object_info[\"file_error\"])\n            return\n\n        assert \"file_content\" in object_info\n        content = object_info[\"file_content\"]\n        line_count_sep = len(content.split(\"\\n\"))\n        # line_count_term = len(content.splitlines())\n        # char_count = len(content)\n        self.text.configure(height=min(line_count_sep, 10))\n        self.text.set_content(content)\n\n        assert \"file_tell\" in object_info\n        # f.tell() gives num of bytes read (minus some magic with linebreaks)\n\n        file_bytes = content.encode(encoding=object_info[\"file_encoding\"])\n        bytes_read = file_bytes[0 : object_info[\"file_tell\"]]\n        read_content = bytes_read.decode(encoding=object_info[\"file_encoding\"])\n        read_char_count = len(read_content)\n        # read_line_count_term = (len(content.splitlines())\n        #                        - len(content[read_char_count:].splitlines()))\n\n        pos_index = \"1.0+\" + str(read_char_count) + \"c\"\n        self.text.tag_add(\"read\", \"1.0\", pos_index)\n        self.text.see(pos_index)\n\n        # TODO: show this info somewhere\n        \"\"\"\n        label.configure(text=\"Read %d/%d %s, %d/%d %s\"\n                        % (read_char_count,\n                           char_count,\n                           \"symbol\" if char_count == 1 else \"symbols\",\n                           read_line_count_term,\n                           line_count_term,\n                           \"line\" if line_count_term == 1 else \"lines\"))\n        \"\"\"", "is_method": true, "class_name": "FileHandleInspector", "function_description": "The `FileHandleInspector` method updates a text display with provided file content. It visually highlights the portion of the content that has been read and adjusts the display's visible height."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 371, "body": "def applies_to(self, object_info):\n        return \"source\" in object_info", "is_method": true, "class_name": "FunctionInspector", "function_description": "For a `FunctionInspector`, this method determines if the given object information includes source code. It helps identify objects suitable for source-code-based analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "get_tab_text", "line_number": 374, "body": "def get_tab_text(self):\n        return \"Code\"", "is_method": true, "class_name": "FunctionInspector", "function_description": "Provides the constant text \"Code\" to label a user interface tab, likely for displaying function source code within the inspector."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 377, "body": "def set_object_info(self, object_info):\n        line_count = len(object_info[\"source\"].split(\"\\n\"))\n        self.text.configure(height=min(line_count, 15))\n        self.text.set_content(object_info[\"source\"])", "is_method": true, "class_name": "FunctionInspector", "function_description": "Displays an object's source code within the inspector's UI text component. It dynamically adjusts the display height to fit the content, up to 15 lines."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 390, "body": "def applies_to(self, object_info):\n        return object_info[\"type\"] == repr(str)", "is_method": true, "class_name": "StringInspector", "function_description": "Determines if the `StringInspector` is applicable to a given object by checking if the object's type is a string. This serves to filter objects that the inspector can process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 393, "body": "def set_object_info(self, object_info):\n        # TODO: don't show too big string\n        try:\n            content = ast.literal_eval(object_info[\"repr\"])\n        except SyntaxError:\n            try:\n                # can be shortened\n                content = ast.literal_eval(object_info[\"repr\"] + object_info[\"repr\"][0:1])\n            except SyntaxError:\n                content = \"<can't show string content>\"\n\n        line_count_sep = len(content.split(\"\\n\"))\n        # line_count_term = len(content.splitlines())\n        self.text.configure(height=min(line_count_sep, 10))\n        self.text.set_content(content)\n        \"\"\" TODO:\n        label.configure(text=\"%d %s, %d %s\"\n                        % (len(content),\n                           \"symbol\" if len(content) == 1 else \"symbols\",\n                           line_count_term,\n                           \"line\" if line_count_term == 1 else \"lines\"))\n        \"\"\"", "is_method": true, "class_name": "StringInspector", "function_description": "This method displays an object's string representation by safely parsing its content. It configures a text display with the content, adjusting its height for readability within a UI component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 424, "body": "def applies_to(self, object_info):\n        return object_info[\"type\"] == repr(int)", "is_method": true, "class_name": "IntInspector", "function_description": "Determines if the provided object information describes an integer type. It serves as a predicate for the `IntInspector`'s applicability to an object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 427, "body": "def set_object_info(self, object_info):\n        content = ast.literal_eval(object_info[\"repr\"])\n        self.text.set_content(\n            object_info[\"repr\"]\n            + \"\\n\\n\"\n            + \"bin: \"\n            + bin(content)\n            + \"\\n\"\n            + \"oct: \"\n            + oct(content)\n            + \"\\n\"\n            + \"hex: \"\n            + hex(content)\n            + \"\\n\"\n        )", "is_method": true, "class_name": "IntInspector", "function_description": "For an `IntInspector` object, this method displays a given integer's decimal, binary, octal, and hexadecimal forms for detailed inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 456, "body": "def applies_to(self, object_info):\n        return object_info[\"type\"] == repr(float)", "is_method": true, "class_name": "FloatInspector", "function_description": "Checks if the provided object information corresponds to a float type. This method is used by `FloatInspector` to determine its applicability to an object.\nDetermines if the provided object information represents a float type. This method is used by the `FloatInspector` to check its applicability to a given object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 459, "body": "def set_object_info(self, object_info):\n        content = object_info[\"repr\"] + \"\\n\\n\\n\"\n\n        if \"as_integer_ratio\" in object_info:\n            ratio = object_info[\"as_integer_ratio\"]\n            from decimal import Decimal\n\n            ratio_dec_str = str(Decimal(ratio[0]) / Decimal(ratio[1]))\n\n            if ratio_dec_str != object_info[\"repr\"]:\n                explanation = tr(\n                    \"The representation above is an approximate value of this float. \"\n                    \"The exact stored value is %s which is about %s\"\n                )\n\n                content += explanation % (\n                    \"\\n\\n  %d / %d\\n\\n\" % ratio,\n                    \"\\n\\n  %s\\n\\n\" % ratio_dec_str,\n                )\n\n        self.text.set_content(content)", "is_method": true, "class_name": "FloatInspector", "function_description": "Displays comprehensive information for a float object, providing its exact fractional and precise decimal values when the standard representation is an approximation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 489, "body": "def applies_to(self, object_info):\n        return True", "is_method": true, "class_name": "ReprInspector", "function_description": "Indicates whether the ReprInspector should be applied to an object. This method always returns True, signifying universal applicability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 492, "body": "def set_object_info(self, object_info):\n        # TODO: don't show too big string\n        content = object_info[\"repr\"]\n        self.text.set_content(content)\n        \"\"\"\n        line_count_sep = len(content.split(\"\\n\"))\n        line_count_term = len(content.splitlines())\n        self.text.configure(height=min(line_count_sep, 10))\n        label.configure(text=\"%d %s, %d %s\"\n                        % (len(content),\n                           \"symbol\" if len(content) == 1 else \"symbols\",\n                           line_count_term,\n                           \"line\" if line_count_term == 1 else \"lines\"))\n        \"\"\"", "is_method": true, "class_name": "ReprInspector", "function_description": "This method updates the `ReprInspector`'s internal text display with the string representation (`repr`) of an object. It serves to visually present an object's `repr` content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "_update_columns", "line_number": 537, "body": "def _update_columns(self):\n        if get_workbench().in_heap_mode():\n            if self.elements_have_indices:\n                self.tree.configure(displaycolumns=(\"index\", \"id\"))\n            else:\n                self.tree.configure(displaycolumns=(\"id\",))\n        else:\n            if self.elements_have_indices:\n                self.tree.configure(displaycolumns=(\"index\", \"value\"))\n            else:\n                self.tree.configure(displaycolumns=(\"value\"))", "is_method": true, "class_name": "ElementsInspector", "function_description": "Dynamically updates the displayed columns in the inspector's tree view. It configures the columns based on the workbench's operating mode and whether inspected elements have indices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 549, "body": "def applies_to(self, object_info):\n        return \"elements\" in object_info", "is_method": true, "class_name": "ElementsInspector", "function_description": "Determines if the `ElementsInspector`'s logic is applicable to a given object's information. It checks for the presence of the string \"elements\" within the provided `object_info`."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "on_double_click", "line_number": 555, "body": "def on_double_click(self, event):\n        self.show_selected_object_info()", "is_method": true, "class_name": "ElementsInspector", "function_description": "Handles a double-click event to display detailed information about the currently selected user interface element."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 558, "body": "def set_object_info(self, object_info):\n        assert \"elements\" in object_info\n\n        self.elements_have_indices = object_info[\"type\"] in (repr(tuple), repr(list))\n        self._update_columns()\n        self.context_id = object_info[\"id\"]\n\n        self._clear_tree()\n        index = 0\n        # TODO: don't show too big number of elements\n        for element in object_info[\"elements\"]:\n            node_id = self.tree.insert(\"\", \"end\")\n            if self.elements_have_indices:\n                self.tree.set(node_id, \"index\", index)\n            else:\n                self.tree.set(node_id, \"index\", \"\")\n\n            self.tree.set(node_id, \"id\", thonny.memory.format_object_id(element.id))\n            self.tree.set(\n                node_id, \"value\", shorten_repr(element.repr, thonny.memory.MAX_REPR_LENGTH_IN_GRID)\n            )\n            index += 1\n\n        count = len(object_info[\"elements\"])\n        self.len_label.configure(text=\" len: %d\" % count)", "is_method": true, "class_name": "ElementsInspector", "function_description": "Initializes the `ElementsInspector`'s UI tree view to display elements from a given object. It populates the view with each element's index, ID, and value, and updates the total count."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "update_memory_model", "line_number": 609, "body": "def update_memory_model(self, event=None):\n        if get_workbench().in_heap_mode():\n            self.tree.configure(displaycolumns=(\"key_id\", \"id\"))\n        else:\n            self.tree.configure(displaycolumns=(\"key\", \"value\"))", "is_method": true, "class_name": "DictInspector", "function_description": "This DictInspector method dynamically configures its tree view's display columns. It switches between showing memory identifiers or dictionary key-value pairs based on the current workbench mode."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 615, "body": "def applies_to(self, object_info):\n        return \"entries\" in object_info", "is_method": true, "class_name": "DictInspector", "function_description": "This method determines if the `DictInspector` is applicable to the given `object_info`. It returns true if an \"entries\" key is present, indicating it's a relevant structure for inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "on_double_click", "line_number": 621, "body": "def on_double_click(self, event):\n        # NB! this selects value\n        self.show_selected_object_info()", "is_method": true, "class_name": "DictInspector", "function_description": "Handles a double-click event within the DictInspector, triggering the display of detailed information for the selected value or object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 625, "body": "def set_object_info(self, object_info):\n        assert \"entries\" in object_info\n        self.context_id = object_info[\"id\"]\n\n        self._clear_tree()\n        # TODO: don't show too big number of elements\n        for key, value in object_info[\"entries\"]:\n            node_id = self.tree.insert(\"\", \"end\")\n            self.tree.set(node_id, \"key_id\", thonny.memory.format_object_id(key.id))\n            self.tree.set(\n                node_id, \"key\", shorten_repr(key.repr, thonny.memory.MAX_REPR_LENGTH_IN_GRID)\n            )\n            self.tree.set(node_id, \"id\", thonny.memory.format_object_id(value.id))\n            self.tree.set(\n                node_id, \"value\", shorten_repr(value.repr, thonny.memory.MAX_REPR_LENGTH_IN_GRID)\n            )\n\n        count = len(object_info[\"entries\"])\n        self.len_label.configure(text=\" len: %d\" % count)\n        self.update_memory_model()", "is_method": true, "class_name": "DictInspector", "function_description": "Updates the DictInspector's UI display. It populates a tree view with key-value entries from a provided dictionary-like object's information, showing object IDs and truncated representations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "set_object_info", "line_number": 656, "body": "def set_object_info(self, object_info):\n        if isinstance(object_info[\"image_data\"], bytes):\n            import base64\n\n            data = base64.b64encode(object_info[\"image_data\"])\n        elif isinstance(object_info[\"image_data\"], str):\n            data = object_info[\"image_data\"]\n        else:\n            self.label.configure(\n                image=None, text=\"Unsupported image data (%s)\" % type(object_info[\"image_data\"])\n            )\n            return\n\n        try:\n            self.image = tk.PhotoImage(data=data)\n            self.label.configure(image=self.image)\n        except Exception as e:\n            self.label.configure(image=None, text=\"Unsupported image data (%s)\" % e)", "is_method": true, "class_name": "ImageInspector", "function_description": "Displays an image within the UI by processing raw image data from various formats. It converts the data for display and updates the associated label, handling errors for unsupported formats."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "applies_to", "line_number": 675, "body": "def applies_to(self, object_info):\n        return \"image_data\" in object_info", "is_method": true, "class_name": "ImageInspector", "function_description": "This `ImageInspector` method determines if a given object is applicable for image inspection by checking for the presence of image data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "on_double_click", "line_number": 687, "body": "def on_double_click(self, event):\n        self.show_selected_object_info()", "is_method": true, "class_name": "AttributesFrame", "function_description": "Responds to double-click interactions by displaying comprehensive details of the selected item within the attributes frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "show_selected_object_info", "line_number": 690, "body": "def show_selected_object_info(self):\n        object_id = self.get_object_id()\n        if object_id is None:\n            return\n\n        iid = self.tree.focus()\n        if not iid:\n            return\n        repr_str = self.tree.item(iid)[\"values\"][2]\n\n        if repr_str == \"<bound_method>\":\n            from thonny.plugins.micropython import MicroPythonProxy\n\n            if isinstance(get_runner().get_backend_proxy(), MicroPythonProxy):\n                messagebox.showinfo(\n                    \"Not supported\",\n                    \"Inspecting bound methods is not supported with MicroPython\",\n                    master=self,\n                )\n                return\n\n        get_workbench().event_generate(\"ObjectSelect\", object_id=object_id)", "is_method": true, "class_name": "AttributesFrame", "function_description": "Triggers an 'ObjectSelect' event with the ID of the currently focused object, allowing other components to display its information. It prevents inspection of bound methods when using a MicroPython backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "create_tab", "line_number": 58, "body": "def create_tab(col, caption, page):\n            if page == self.active_page:\n                style = \"Active.ViewTab.TLabel\"\n            else:\n                style = \"Inactive.ViewTab.TLabel\"\n            tab = ttk.Label(toolbar, text=caption, style=style)\n            tab.grid(row=0, column=col, pady=5, padx=5, sticky=\"nsew\")\n            self.tabs.append(tab)\n            page.tab = tab\n\n            def on_click(event):\n                if self.active_page == page:\n                    return\n                else:\n                    if self.active_page is not None:\n                        self.active_page.grid_forget()\n                        self.active_page.tab.configure(style=\"Inactive.ViewTab.TLabel\")\n\n                    self.active_page = page\n                    page.grid(row=1, column=0, sticky=\"nsew\", padx=0)\n                    tab.configure(style=\"Active.ViewTab.TLabel\")\n                    if (\n                        self.active_page == self.attributes_page\n                        and (self.object_info is None or not self.object_info.get(\"attributes\"))\n                        and self.object_id is not None\n                    ):\n                        self.request_object_info()\n\n            tab.bind(\"<1>\", on_click)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Provides an interactive tab within the `ObjectInspector` interface. Clicking it switches the displayed content page, updates tab styling, and triggers data loading if required."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "create_navigation_link", "line_number": 92, "body": "def create_navigation_link(col, image_filename, action, tooltip, padx=0):\n            button = ttk.Button(\n                toolbar,\n                # command=handler,\n                image=get_workbench().get_image(image_filename),\n                style=\"ViewToolbar.Toolbutton\",  # TODO: does this cause problems in some Macs?\n                state=tk.NORMAL,\n            )\n            ui_utils.create_tooltip(button, tooltip)\n\n            button.grid(row=0, column=col, sticky=tk.NE, padx=padx, pady=4)\n            button.bind(\"<Button-1>\", action)\n            return button", "is_method": true, "class_name": "ObjectInspector", "function_description": "Creates and configures a GUI toolbar button with an image and tooltip, associating it with a specified action. This button facilitates navigation or interaction within the ObjectInspector's interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "configure", "line_number": 106, "body": "def configure(event):\n            if event.width > 20:\n                self.title_label.configure(wraplength=event.width - 10)", "is_method": true, "class_name": "ObjectInspector", "function_description": "Dynamically adjusts the title label's text wrapping based on window width. This ensures the title remains readable during UI resizing events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/object_inspector.py", "function": "on_click", "line_number": 68, "body": "def on_click(event):\n                if self.active_page == page:\n                    return\n                else:\n                    if self.active_page is not None:\n                        self.active_page.grid_forget()\n                        self.active_page.tab.configure(style=\"Inactive.ViewTab.TLabel\")\n\n                    self.active_page = page\n                    page.grid(row=1, column=0, sticky=\"nsew\", padx=0)\n                    tab.configure(style=\"Active.ViewTab.TLabel\")\n                    if (\n                        self.active_page == self.attributes_page\n                        and (self.object_info is None or not self.object_info.get(\"attributes\"))\n                        and self.object_id is not None\n                    ):\n                        self.request_object_info()", "is_method": true, "class_name": "ObjectInspector", "function_description": "Handles a click event to switch the active view in the ObjectInspector's UI. It updates the displayed page, adjusts tab styles, and fetches object attributes if the attributes page is activated without data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/general_config_page.py", "function": "load_plugin", "line_number": 128, "body": "def load_plugin() -> None:\n    get_workbench().add_configuration_page(\"general\", tr(\"General\"), GeneralConfigurationPage, 10)", "is_method": false, "function_description": "Part of a plugin's initialization, it registers a \"General\" configuration page to be displayed within the application's workbench settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/general_config_page.py", "function": "apply", "line_number": 116, "body": "def apply(self):\n        get_workbench().set_option(\n            \"general.language\", languages.get_language_code_by_name(self._language_name_var.get())\n        )\n        get_workbench().update_debug_mode()\n\n        env = []\n        for entry in self.env_box.text.get(\"1.0\", \"end\").strip(\"\\r\\n\").splitlines():\n            env.append(entry.strip(\"\\r\\n\"))\n        get_workbench().set_option(\"general.environment\", env)", "is_method": true, "class_name": "GeneralConfigurationPage", "function_description": "This method applies user-defined general settings, configuring the application's language, debug mode, and environment variables within the workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "load_plugin", "line_number": 145, "body": "def load_plugin() -> None:\n    get_workbench().add_view(OutlineView, tr(\"Outline\"), \"ne\")", "is_method": false, "function_description": "Loads a plugin by adding an \"Outline\" view component to the application's workbench. This enables the display of document or project outlines within the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "destroy", "line_number": 26, "body": "def destroy(self):\n        try:\n            # Not sure if editor notebook is still living\n            get_workbench().get_editor_notebook().unbind(\n                \"<<NotebookTabChanged>>\", self._tab_changed_binding\n            )\n        except Exception:\n            pass\n        self.vert_scrollbar[\"command\"] = None\n        ttk.Frame.destroy(self)", "is_method": true, "class_name": "OutlineView", "function_description": "Cleans up resources and unbinds event listeners associated with the OutlineView instance. It ensures proper shutdown by disconnecting UI components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_init_widgets", "line_number": 37, "body": "def _init_widgets(self):\n        # init and place scrollbar\n        self.vert_scrollbar = SafeScrollbar(self, orient=tk.VERTICAL)\n        self.vert_scrollbar.grid(row=0, column=1, sticky=tk.NSEW)\n\n        # init and place tree\n        self.tree = ttk.Treeview(self, yscrollcommand=self.vert_scrollbar.set)\n        self.tree.grid(row=0, column=0, sticky=tk.NSEW)\n        self.vert_scrollbar[\"command\"] = self.tree.yview\n\n        # set single-cell frame\n        self.columnconfigure(0, weight=1)\n        self.rowconfigure(0, weight=1)\n\n        # init tree events\n        self.tree.bind(\"<<TreeviewSelect>>\", self._on_select, True)\n        self.tree.bind(\"<Map>\", self._update_frame_contents, True)\n\n        # configure the only tree column\n        self.tree.column(\"#0\", anchor=tk.W, stretch=True)\n        # self.tree.heading('#0', text='Item (type @ line)', anchor=tk.W)\n        self.tree[\"show\"] = (\"tree\",)\n\n        self._class_img = get_workbench().get_image(\"outline-class\")\n        self._method_img = get_workbench().get_image(\"outline-method\")", "is_method": true, "class_name": "OutlineView", "function_description": "Initializes and configures the core GUI widgets\u2014a scrollbar and a treeview\u2014for the `OutlineView`. It sets up their layout and event bindings, preparing the view for hierarchical content display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_update_frame_contents", "line_number": 63, "body": "def _update_frame_contents(self, event=None):\n        if not self.winfo_ismapped():\n            return\n\n        self._clear_tree()\n\n        editor = get_workbench().get_editor_notebook().get_current_editor()\n        if editor is None:\n            return\n\n        root = self._parse_source(editor.get_code_view().get_content())\n        for child in root[2]:\n            self._add_item_to_tree(\"\", child)", "is_method": true, "class_name": "OutlineView", "function_description": "Updates the OutlineView by parsing the current editor's source code. It populates a tree structure, providing a navigable overview of the active file's code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_parse_source", "line_number": 77, "body": "def _parse_source(self, source):\n        # all nodes in format (parent, node_indent, node_children, name, type, linenumber)\n        root_node = (None, 0, [], None, None, None)  # name, type and linenumber not needed for root\n        active_node = root_node\n\n        lineno = 0\n        for line in source.split(\"\\n\"):\n            lineno += 1\n            m = re.match(r\"[ ]*[\\w]{1}\", line)\n            if m:\n                indent = len(m.group(0))\n                while indent <= active_node[1]:\n                    active_node = active_node[0]\n\n                t = re.match(r\"[ ]*(?P<type>(def|class){1})[ ]+(?P<name>[\\w]+)\", line)\n                if t:\n                    current = (active_node, indent, [], t.group(\"name\"), t.group(\"type\"), lineno)\n                    active_node[2].append(current)\n                    active_node = current\n\n        return root_node", "is_method": true, "class_name": "OutlineView", "function_description": "This method analyzes source code to construct a hierarchical outline. It extracts and organizes class and function definitions based on indentation for an `OutlineView`."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_add_item_to_tree", "line_number": 100, "body": "def _add_item_to_tree(self, parent, item):\n        # create the text to be played for this item\n        item_type = item[4]\n        item_text = \" \" + item[3]\n\n        if item_type == \"class\":\n            image = self._class_img\n        elif item_type == \"def\":\n            image = self._method_img\n        else:\n            image = None\n\n        # insert the item, set lineno as a 'hidden' value\n        current = self.tree.insert(parent, \"end\", text=item_text, values=item[5], image=image)\n\n        for child in item[2]:\n            self._add_item_to_tree(current, child)", "is_method": true, "class_name": "OutlineView", "function_description": "Recursively populates the OutlineView's hierarchical display. It adds code elements like classes and methods, using specific icons to build a navigable outline structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_clear_tree", "line_number": 119, "body": "def _clear_tree(self):\n        for child_id in self.tree.get_children():\n            self.tree.delete(child_id)", "is_method": true, "class_name": "OutlineView", "function_description": "Clears all existing nodes from the outline tree view, preparing it for new content or a refresh."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/outline.py", "function": "_on_select", "line_number": 123, "body": "def _on_select(self, event):\n        editor = get_workbench().get_editor_notebook().get_current_editor()\n        if editor:\n            code_view = editor.get_code_view()\n            focus = self.tree.focus()\n            if not focus:\n                return\n\n            values = self.tree.item(focus)[\"values\"]\n            if not values:\n                return\n\n            lineno = values[0]\n            index = code_view.text.index(str(lineno) + \".0\")\n            code_view.text.see(index)  # make sure that the double-clicked item is visible\n            code_view.text.select_lines(lineno, lineno)\n\n            get_workbench().event_generate(\n                \"OutlineDoubleClick\", item_text=self.tree.item(self.tree.focus(), option=\"text\")\n            )", "is_method": true, "class_name": "OutlineView", "function_description": "Handles selection within the OutlineView by navigating the current code editor to the corresponding line number and selecting it. It also generates an `OutlineDoubleClick` event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "transpose_path", "line_number": 418, "body": "def transpose_path(\n    source_path: str,\n    source_dir: str,\n    target_dir: str,\n    source_path_class: Type[PurePath],\n    target_path_class: Type[PurePath],\n) -> str:\n    assert not source_dir.endswith(\":\")\n    source_path_parts = source_path_class(source_path).parts\n    source_dir_parts = source_path_class(source_dir).parts\n    assert source_path_parts[: len(source_dir_parts)] == source_dir_parts\n    source_suffix_parts = source_path_parts[len(source_dir_parts) :]\n\n    target = target_path_class(target_dir).joinpath(*source_suffix_parts)\n    return str(target)", "is_method": false, "function_description": "Transforms a given source path by re-rooting it from a specified source directory to a new target directory. It preserves the path's relative structure and supports different OS path conventions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "pick_transfer_items", "line_number": 435, "body": "def pick_transfer_items(\n    prepared_items: List[Dict], existing_target_items: Dict[str, Dict], master\n) -> List[Dict]:\n    if not existing_target_items:\n        return prepared_items\n\n    errors = []\n    overwrites = []\n\n    for item in prepared_items:\n        if item[\"target_path\"] in existing_target_items:\n            target_info = existing_target_items[item[\"target_path\"]]\n            if item[\"kind\"] != target_info[\"kind\"]:\n                errors.append(\n                    \"Can't overwrite '%s' with '%s', because former is a %s but latter is a %s\"\n                    % (item[\"target_path\"], item[\"source_path\"], target_info[\"kind\"], item[\"kind\"])\n                )\n            elif item[\"kind\"] == \"file\":\n                size_diff = item[\"size\"] - target_info[\"size\"]\n                if size_diff > 0:\n                    replacement = \"a larger file (%s + %s)\" % (\n                        sizeof_fmt(target_info[\"size\"]),\n                        sizeof_fmt(size_diff),\n                    )\n                elif size_diff < 0:\n                    replacement = \"a smaller file (%s - %s)\" % (\n                        sizeof_fmt(target_info[\"size\"]),\n                        sizeof_fmt(-size_diff),\n                    )\n                else:\n                    replacement = \"a file of same size (%s)\" % sizeof_fmt(target_info[\"size\"])\n\n                overwrites.append(\"'%s' with %s\" % (item[\"target_path\"], replacement))\n\n    if errors:\n        showerror(\"Error\", format_items(errors), master=master)\n        return []\n    elif overwrites:\n        if askokcancel(\n            \"Overwrite?\",\n            \"This operation will overwrite\\n\\n\" + format_items(overwrites),\n            master=master,\n        ):\n            return prepared_items\n        else:\n            return []\n    else:\n        return prepared_items", "is_method": false, "function_description": "This function determines which prepared items can be transferred by checking for conflicts with existing target items. It prevents transfers with type mismatches and prompts the user for confirmation before allowing file overwrites."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "format_items", "line_number": 485, "body": "def format_items(items):\n    max_count = 10\n    if len(items) == 1:\n        return items[0]\n    msg = \"\u2022 \" + \"\\n\u2022 \".join(items[:max_count])\n    if len(items) > max_count:\n        msg += \"\\n ... %d more ...\"\n\n    return msg", "is_method": false, "function_description": "Formats a list of items into a human-readable string, using bullet points and truncating long lists for concise display. It provides a standardized way to present item lists."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "upload", "line_number": 496, "body": "def upload(paths, target_dir, master) -> bool:\n    dlg = UploadDialog(master, paths, target_dir)\n    ui_utils.show_dialog(dlg)\n    return dlg.response is not None", "is_method": false, "function_description": "Manages user-initiated file and directory uploads. It displays an interactive dialog, returning whether the user confirmed the upload operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "prepare_upload_items", "line_number": 502, "body": "def prepare_upload_items(\n    source_path: str, source_context_dir: str, target_dir: str\n) -> Iterable[Dict]:\n    # assuming target system has Posix paths\n    if os.path.isdir(source_path):\n        kind = \"dir\"\n        size = None\n    else:\n        kind = \"file\"\n        size = os.path.getsize(source_path)\n\n    result = [\n        {\n            \"kind\": kind,\n            \"size\": size,\n            \"source_path\": source_path,\n            \"target_path\": transpose_path(\n                source_path, source_context_dir, target_dir, pathlib.Path, PurePosixPath\n            ),\n        }\n    ]\n\n    if os.path.isdir(source_path):\n        for child in os.listdir(source_path):\n            if child not in IGNORED_FILES_AND_DIRS:\n                result.extend(\n                    prepare_upload_items(\n                        os.path.join(source_path, child), source_context_dir, target_dir\n                    )\n                )\n    return result", "is_method": false, "function_description": "Generates a comprehensive list of files and directories, recursively, along with their mapped target paths and metadata, suitable for an upload operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "get_transfer_description", "line_number": 535, "body": "def get_transfer_description(verb, paths, target_dir):\n    if len(paths) == 1:\n        subject = \"'%s'\" % paths[0]\n    else:\n        subject = \"%d items\" % len(paths)\n\n    return \"%s %s to %s\" % (verb, subject, target_dir)", "is_method": false, "function_description": "Constructs a human-readable description of a file transfer operation, detailing the action, items involved, and their destination."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "load_plugin", "line_number": 544, "body": "def load_plugin() -> None:\n    get_workbench().set_default(\n        \"file.last_browser_folder\", normpath_with_actual_case(os.path.expanduser(\"~\"))\n    )\n\n    get_workbench().set_default(HIDDEN_FILES_OPTION, False)\n\n    get_workbench().add_view(FilesView, tr(\"Files\"), \"nw\")\n\n    for ext in [\".py\", \".pyw\", \".pyi\", \".txt\", \".log\", \".json\", \".yml\", \".yaml\", \".md\", \".rst\"]:\n        get_workbench().set_default(get_file_handler_conf_key(ext), \"thonny\")", "is_method": false, "function_description": "Initializes and configures a file browsing plugin within the application's workbench. It sets default folder paths, hidden file visibility, and associates various file types with the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_show", "line_number": 52, "body": "def on_show(self):\n        self.reset_remote()\n        self.local_files.refresh_tree()", "is_method": true, "class_name": "FilesView", "function_description": "This method prepares the `FilesView` when it becomes visible, by resetting any remote connections and refreshing the display of local files. It ensures the view presents current file system states."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "reset_remote", "line_number": 56, "body": "def reset_remote(self, msg=None):\n        runner = get_runner()\n        if not runner:\n            return\n\n        proxy = runner.get_backend_proxy()\n        if not proxy:\n            self.hide_remote()\n            return\n\n        if proxy.supports_remote_files():\n            # remote pane is needed\n            if not self.remote_added:\n                self.add(self.remote_files, minsize=minsize)\n                self.remote_added = True\n                self.restore_split()\n            self.remote_files.clear()\n            self.remote_files.check_update_focus()\n        else:\n            # remote pane not needed\n            self.hide_remote()", "is_method": true, "class_name": "FilesView", "function_description": "Manages the remote file display within the `FilesView` by showing and clearing its content if the backend supports remote files, or hiding it otherwise."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "hide_remote", "line_number": 78, "body": "def hide_remote(self):\n        if self.remote_added:\n            self.save_split()\n            self.remove(self.remote_files)\n            self.remote_added = False", "is_method": true, "class_name": "FilesView", "function_description": "Hides previously added remote files from the FilesView. It removes them from the display and updates the view's state accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "save_split", "line_number": 84, "body": "def save_split(self):\n        _, y = self.sash_coord(0)\n        get_workbench().set_option(\"view.files_split\", y)", "is_method": true, "class_name": "FilesView", "function_description": "Persists the current vertical position of the file view's split pane. This allows the application to remember and restore the user's preferred layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "restore_split", "line_number": 88, "body": "def restore_split(self):\n        split = get_workbench().get_option(\"view.files_split\", None)\n        if split is None:\n            if self.winfo_height() > 5:\n                split = int(self.winfo_height() * 0.66)\n            else:\n                split = 600\n\n        self.sash_place(0, 0, split)", "is_method": true, "class_name": "FilesView", "function_description": "Restores the position of the file view's internal divider (sash). It retrieves a saved split setting or computes a sensible default based on window height, ensuring consistent layout."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_backend_restart", "line_number": 98, "body": "def on_backend_restart(self, event):\n        if event.get(\"full\"):\n            self.reset_remote(event)", "is_method": true, "class_name": "FilesView", "function_description": "This method handles backend restart events for the FilesView. It triggers a remote state reset if the restart is a full one."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_backend_terminate", "line_number": 102, "body": "def on_backend_terminate(self, event):\n        self.reset_remote(event)", "is_method": true, "class_name": "FilesView", "function_description": "Handles a backend termination event by resetting the remote state of the files view. It ensures the view properly manages its connection status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_workbench_close", "line_number": 105, "body": "def on_workbench_close(self, event=None):\n        if self.remote_added:\n            self.save_split()", "is_method": true, "class_name": "FilesView", "function_description": "This method handles the workbench close event. It saves the current UI split state if remote files or content were added, ensuring persistence of relevant view configurations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "get_active_local_dir", "line_number": 109, "body": "def get_active_local_dir(self):\n        return self.local_files.get_active_directory()", "is_method": true, "class_name": "FilesView", "function_description": "Retrieves the currently active local directory being displayed or managed. This provides the current directory context for the `FilesView`."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "get_active_remote_dir", "line_number": 112, "body": "def get_active_remote_dir(self):\n        if self.remote_added:\n            return self.remote_files.get_active_directory()\n        else:\n            return None", "is_method": true, "class_name": "FilesView", "function_description": "Retrieves the currently active directory from remote files if remote functionality is enabled, otherwise returns None."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "destroy", "line_number": 118, "body": "def destroy(self):\n        get_workbench().unbind(\"BackendTerminated\", self.on_backend_terminate)\n        get_workbench().unbind(\"BackendRestart\", self.on_backend_restart)\n        get_workbench().unbind(\"WorkbenchClose\", self.on_workbench_close)\n        super().destroy()", "is_method": true, "class_name": "FilesView", "function_description": "Ensures proper shutdown of the `FilesView` instance by unbinding its event handlers from the workbench, preventing resource leaks or erroneous callbacks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "is_active_browser", "line_number": 130, "body": "def is_active_browser(self):\n        return True", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "This method consistently indicates that the `ActiveLocalFileBrowser` instance is active. It serves as a simple flag for other system components to query its operational status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "create_new_file", "line_number": 133, "body": "def create_new_file(self):\n        path = super().create_new_file()\n        if path and path.endswith(\".py\"):\n            get_workbench().get_editor_notebook().show_file(path)", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Creates a new file and, if it's a Python file, automatically opens it in the workbench editor. This streamlines the file creation and editing workflow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "get_proposed_new_file_name", "line_number": 138, "body": "def get_proposed_new_file_name(self, folder, extension):\n        base = \"new_file\"\n\n        if os.path.exists(os.path.join(folder, base + extension)):\n            i = 2\n\n            while True:\n                name = base + \"_\" + str(i) + extension\n                path = os.path.join(folder, name)\n                if os.path.exists(path):\n                    i += 1\n                else:\n                    return name\n        else:\n            return base + extension", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "This method provides a unique, non-conflicting default file name for a new file within a specified folder. It appends an incremental number to the base name if a file with that name already exists."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "request_focus_into", "line_number": 154, "body": "def request_focus_into(self, path):\n        if path == \"\":\n            if running_on_windows():\n                # list of drives, can't cd\n                self.focus_into(path)\n                return\n            else:\n                path = \"/\"\n\n        if not os.path.isdir(path):\n            return\n\n        proxy = get_runner().get_backend_proxy()\n        if (\n            proxy\n            and proxy.uses_local_filesystem()\n            and proxy.get_cwd() != path\n            and get_runner().is_waiting_toplevel_command()\n        ):\n            get_shell().submit_magic_command(construct_cd_command(normpath_with_actual_case(path)))\n        else:\n            # it's OK, if it's already focused into this directory\n            # focus again to refresh\n            self.focus_into(path)\n            get_workbench().set_local_cwd(path)", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Changes the local file browser's current working directory to the specified path. It manages synchronization with the underlying shell or updates the workbench's internal state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_toplevel_response", "line_number": 180, "body": "def on_toplevel_response(self, event):\n        self.check_update_focus()", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Handles a `toplevel_response` event by triggering a focus update for the active file browser."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "check_update_focus", "line_number": 183, "body": "def check_update_focus(self):\n        cwd = get_workbench().get_local_cwd()\n        if cwd != self.current_focus and os.path.isdir(cwd):\n            self.focus_into(cwd)", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Automatically updates the file browser's current directory to match the workbench's working directory. This ensures the browser's view reflects the active context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "check_add_upload_command", "line_number": 188, "body": "def check_add_upload_command(self):\n        target_dir = self.master.get_active_remote_dir()\n        if target_dir is None:\n            return\n\n        proxy = get_runner().get_backend_proxy()\n\n        if not proxy.supports_remote_directories():\n            target_dir_desc = proxy.get_node_label()\n        else:\n            target_dir_desc = target_dir\n\n        def _upload():\n            selection = self.get_selection_info(True)\n            if not selection:\n                return\n\n            if \"dir\" in selection[\"kinds\"] and not proxy.supports_remote_directories():\n                messagebox.showerror(\n                    \"Can't upload directory\",\n                    \"%s does not support directories.\\n\" % proxy.get_node_label()\n                    + \"You can only upload files.\",\n                    master=self,\n                )\n            else:\n                if upload(selection[\"paths\"], target_dir, master=self):\n                    self.master.remote_files.refresh_tree()\n\n        self.menu.add_command(label=tr(\"Upload to %s\") % target_dir_desc, command=_upload)", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Adds an 'Upload' command to the local file browser's menu. This command facilitates uploading selected local files or directories to the active remote directory, managing backend compatibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "add_middle_menu_items", "line_number": 218, "body": "def add_middle_menu_items(self, context):\n        self.check_add_upload_command()\n        super().add_middle_menu_items(context)", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "Extends the middle menu of the file browser by adding specific items. It ensures the upload command is considered for inclusion alongside items from its parent."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "is_active_browser", "line_number": 229, "body": "def is_active_browser(self):\n        return True", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Confirms that this `ActiveRemoteFileBrowser` instance is currently active. Useful for verifying the browser's operational status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_toplevel_response", "line_number": 232, "body": "def on_toplevel_response(self, msg):\n        if not self.winfo_ismapped():\n            return\n        if get_runner().get_backend_proxy().supports_remote_files():\n            # pass cwd, as proxy may not yet know it\n            self.check_update_focus(msg.get(\"cwd\"))", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Updates the `ActiveRemoteFileBrowser`'s current working directory and focus from a received message. It processes the update only if the UI is visible and remote file support is enabled."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "on_remote_files_changed", "line_number": 239, "body": "def on_remote_files_changed(self, event=None):\n        if not self.winfo_ismapped():\n            return\n\n        if get_runner().get_backend_proxy().supports_remote_files():\n            self.refresh_tree()", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Refreshes the remote file display in the browser upon changes, ensuring the UI reflects current remote file states if active and supported."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "check_update_focus", "line_number": 246, "body": "def check_update_focus(self, new_cwd=None):\n        if new_cwd is None:\n            proxy = get_runner().get_backend_proxy()\n            new_cwd = proxy.get_cwd()\n\n        if self.current_focus != new_cwd:\n            self.focus_into(new_cwd)", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Synchronizes the remote file browser's current directory focus with the actual remote working directory if they differ. This ensures the browser view stays updated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "request_new_focus", "line_number": 254, "body": "def request_new_focus(self, path):\n        get_shell().submit_magic_command([\"%cd\", path if path != \"\" else \"/\"])", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Instructs the remote shell to change its current working directory. This allows the file browser to update the shell's focus to a new path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "add_download_command", "line_number": 257, "body": "def add_download_command(self):\n        target_dir = self.master.get_active_local_dir()\n\n        def download():\n            selection = self.get_selection_info(True)\n            if not selection:\n                return\n\n            dlg = DownloadDialog(\n                self,\n                selection[\"paths\"],\n                selection[\"description\"],\n                target_dir,\n            )\n            ui_utils.show_dialog(dlg)\n            if dlg.response is not None:\n                self.master.local_files.refresh_tree()\n\n        self.menu.add_command(label=tr(\"Download to %s\") % target_dir, command=download)", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Adds a \"Download\" command to the remote file browser's menu, enabling users to download selected remote files to the current local directory via a dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "add_middle_menu_items", "line_number": 277, "body": "def add_middle_menu_items(self, context):\n        self.add_download_command()\n        super().add_middle_menu_items(context)", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "Customizes the remote file browser's context menu, specifically adding a download command while incorporating standard menu items from its parent."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_on_response", "line_number": 283, "body": "def _on_response(self, response):\n        if response.get(\"command_id\") != self._cmd[\"id\"]:\n            return\n\n        if self._stage == \"preparation\":\n            if self._confirm_and_start_main_work(response):\n                self._stage = \"main_work\"\n            else:\n                self.response = None\n                self.report_done(True)\n\n        elif self._stage == \"main_work\":\n            self.response = response\n            self.report_done(self._check_success(response))\n\n        self.update_ui()", "is_method": true, "class_name": "TransferDialog", "function_description": "Processes incoming responses to control the progression and completion of the transfer dialog across its different stages, updating the UI accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_check_success", "line_number": 303, "body": "def _check_success(self, response):\n        if response.get(\"error\"):\n            self.set_action_text(\"Error\")\n            self.append_text(\"\\nError: %s\\n\" % response[\"error\"])\n            return False\n        elif response[\"errors\"]:\n            self.set_action_text(\"Error\")\n            self.append_text(\"\\nError: %s\\n\" % format_items(response[\"errors\"]))\n            return False\n        else:\n            self.set_action_text(\"Done!\")\n            return True", "is_method": true, "class_name": "TransferDialog", "function_description": "Checks an operation's response for success or failure. It updates the TransferDialog's status and displays any error messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_confirm_and_start_main_work", "line_number": 339, "body": "def _confirm_and_start_main_work(self, preparation_response):\n        picked_items = list(\n            sorted(\n                pick_transfer_items(self.items, preparation_response[\"existing_items\"], self),\n                key=lambda x: x[\"target_path\"],\n            )\n        )\n        if picked_items:\n            self._cmd = InlineCommand(\"upload\", items=picked_items)\n            get_runner().send_command(self._cmd)\n            return True\n        else:\n            return False", "is_method": true, "class_name": "UploadDialog", "function_description": "Confirms and selects items for upload based on a preparation response. If items are picked, it initiates the actual upload process by sending an \"upload\" command to the task runner."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_prepare_download_items", "line_number": 367, "body": "def _prepare_download_items(\n        self, all_source_items: Dict[str, Dict], target_dir: str\n    ) -> List[Dict]:\n        result = []\n        for source_path, source_item in all_source_items.items():\n            source_context_dir = universal_dirname(source_item[\"anchor\"])\n            result.append(\n                {\n                    \"kind\": source_item[\"kind\"],\n                    \"size\": source_item[\"size\"],\n                    \"source_path\": source_path,\n                    \"target_path\": transpose_path(\n                        source_path, source_context_dir, target_dir, PurePosixPath, pathlib.Path\n                    ),\n                }\n            )\n        return result", "is_method": true, "class_name": "DownloadDialog", "function_description": "Prepares a list of items for download by calculating each item's final destination path. It maps source paths relative to their original context into a specified target directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_get_existing_target_items", "line_number": 385, "body": "def _get_existing_target_items(self, prepared_items: List[Dict]) -> Dict[str, Dict]:\n        result = {}\n\n        for item in prepared_items:\n            target_path = item[\"target_path\"]\n            if os.path.exists(target_path):\n                if os.path.isdir(target_path):\n                    kind = \"dir\"\n                    size = None\n                else:\n                    kind = \"file\"\n                    size = os.path.getsize(target_path)\n\n                result[target_path] = {\n                    \"kind\": kind,\n                    \"size\": size,\n                }\n        return result", "is_method": true, "class_name": "DownloadDialog", "function_description": "Identifies and retrieves information about download target paths that already exist on the local filesystem. This helps the DownloadDialog manage conflicts or provide status updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_confirm_and_start_main_work", "line_number": 404, "body": "def _confirm_and_start_main_work(self, preparation_response):\n        prepared_items = self._prepare_download_items(\n            preparation_response[\"all_items\"], self._target_dir\n        )\n        existing_target_items = self._get_existing_target_items(prepared_items)\n        picked_items = pick_transfer_items(prepared_items, existing_target_items, self)\n        if picked_items:\n            self._cmd = InlineCommand(\"download\", items=picked_items)\n            get_runner().send_command(self._cmd)\n            return True\n        else:\n            return False", "is_method": true, "class_name": "DownloadDialog", "function_description": "For `DownloadDialog`, this method confirms selected download items, handling existing files. It then dispatches the download command to the execution runner, initiating the transfer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "_upload", "line_number": 200, "body": "def _upload():\n            selection = self.get_selection_info(True)\n            if not selection:\n                return\n\n            if \"dir\" in selection[\"kinds\"] and not proxy.supports_remote_directories():\n                messagebox.showerror(\n                    \"Can't upload directory\",\n                    \"%s does not support directories.\\n\" % proxy.get_node_label()\n                    + \"You can only upload files.\",\n                    master=self,\n                )\n            else:\n                if upload(selection[\"paths\"], target_dir, master=self):\n                    self.master.remote_files.refresh_tree()", "is_method": true, "class_name": "ActiveLocalFileBrowser", "function_description": "This method facilitates uploading selected local files or directories to a remote location. It validates if the target system supports directory uploads and refreshes the remote file display upon completion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/files.py", "function": "download", "line_number": 260, "body": "def download():\n            selection = self.get_selection_info(True)\n            if not selection:\n                return\n\n            dlg = DownloadDialog(\n                self,\n                selection[\"paths\"],\n                selection[\"description\"],\n                target_dir,\n            )\n            ui_utils.show_dialog(dlg)\n            if dlg.response is not None:\n                self.master.local_files.refresh_tree()", "is_method": true, "class_name": "ActiveRemoteFileBrowser", "function_description": "This method initiates and manages the download of selected remote files. It displays a user dialog for confirmation and refreshes the local file system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pgzero_frontend.py", "function": "toggle_variable", "line_number": 9, "body": "def toggle_variable():\n    var = get_workbench().get_variable(_OPTION_NAME)\n    var.set(not var.get())\n    update_environment()", "is_method": false, "function_description": "Flips the state of a designated application variable and refreshes the environment to apply the change."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pgzero_frontend.py", "function": "update_environment", "line_number": 15, "body": "def update_environment():\n    if get_workbench().in_simple_mode():\n        os.environ[\"PGZERO_MODE\"] = \"auto\"\n    else:\n        os.environ[\"PGZERO_MODE\"] = str(get_workbench().get_option(_OPTION_NAME))", "is_method": false, "function_description": "Configures the `PGZERO_MODE` environment variable based on the current workbench's operational mode or a specified option. This prepares the environment for a specific application context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pgzero_frontend.py", "function": "load_plugin", "line_number": 22, "body": "def load_plugin():\n    get_workbench().set_default(_OPTION_NAME, False)\n    get_workbench().add_command(\n        \"toggle_pgzero_mode\",\n        \"run\",\n        tr(\"Pygame Zero mode\"),\n        toggle_variable,\n        flag_name=_OPTION_NAME,\n        group=40,\n    )\n    update_environment()", "is_method": false, "function_description": "Initializes a Pygame Zero plugin within the application's workbench. It sets a default option and registers a command to toggle Pygame Zero mode.\nInitializes a Pygame Zero plugin within the application's workbench. It sets a default option and registers a command to toggle Pygame Zero mode."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_get_focused_writable_text", "line_number": 11, "body": "def _get_focused_writable_text():\n    widget = get_workbench().focus_get()\n    # In Ubuntu when moving from one menu to another, this may give None when text is actually focused\n    if isinstance(widget, tk.Text) and (\n        not hasattr(widget, \"is_read_only\") or not widget.is_read_only()\n    ):\n        return widget\n    else:\n        return None", "is_method": false, "function_description": "This function identifies and returns the currently focused, writable Tkinter text widget. It enables operations directly on the user's active text input area."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_writable_text_is_focused", "line_number": 22, "body": "def _writable_text_is_focused():\n    return _get_focused_writable_text() is not None", "is_method": false, "function_description": "Checks if a writable text element currently has focus within the application's UI. This helps determine if user input should be directed to a text field."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_selection_is_line_commented", "line_number": 26, "body": "def _selection_is_line_commented(text):\n    sel_range = _get_focused_code_range(text)\n\n    for lineno in range(sel_range.lineno, sel_range.end_lineno + 1):\n        line = text.get(str(lineno) + \".0\", str(lineno) + \".end\")\n        if not line.startswith(BLOCK_COMMENT_PREFIX):\n            return False\n\n    return True", "is_method": false, "function_description": "Determines if all lines within a focused code selection are consistently line-commented. It verifies if every line starts with a specific comment prefix, useful for editor features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_select_lines", "line_number": 37, "body": "def _select_lines(text, first_line, last_line):\n    text.tag_remove(\"sel\", \"1.0\", tk.END)\n    text.tag_add(\"sel\", str(first_line) + \".0\", str(last_line) + \".end\")", "is_method": false, "function_description": "This function programmatically selects a specific range of lines within a Tkinter Text widget. It first clears any existing selection, then highlights the specified line block."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_toggle_selection_comment", "line_number": 42, "body": "def _toggle_selection_comment(text):\n    if _selection_is_line_commented(text):\n        _uncomment_selection(text)\n    else:\n        _comment_selection(text)", "is_method": false, "function_description": "Toggles the comment status of the provided text selection. It comments the text if uncommented, or uncomments it if already commented."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_comment_selection", "line_number": 49, "body": "def _comment_selection(text):\n    \"\"\"Adds ## in front of all selected lines if any lines are selected,\n    or just the current line otherwise\"\"\"\n\n    sel_range = _get_focused_code_range(text)\n\n    for lineno in range(sel_range.lineno, sel_range.end_lineno + 1):\n        text.insert(str(lineno) + \".0\", BLOCK_COMMENT_PREFIX)\n\n    if sel_range.end_lineno > sel_range.lineno:\n        _select_lines(text, sel_range.lineno, sel_range.end_lineno)\n\n    text.edit_separator()", "is_method": false, "function_description": "This function adds a `##` block comment prefix to either the currently selected lines or the current line. It provides a utility for commenting out code within a text editing interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_uncomment_selection", "line_number": 64, "body": "def _uncomment_selection(text):\n    sel_range = _get_focused_code_range(text)\n\n    for lineno in range(sel_range.lineno, sel_range.end_lineno + 1):\n        line = text.get(str(lineno) + \".0\", str(lineno) + \".end\")\n        if line.startswith(BLOCK_COMMENT_PREFIX):\n            text.delete(str(lineno) + \".0\", str(lineno) + \".\" + str(len(BLOCK_COMMENT_PREFIX)))", "is_method": false, "function_description": "Uncomments selected lines in a text editor by removing the block comment prefix. It provides a convenient way to reactivate code sections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_get_focused_code_range", "line_number": 73, "body": "def _get_focused_code_range(text):\n    if len(text.tag_ranges(\"sel\")) > 0:\n        lineno, col_offset = map(int, text.index(tk.SEL_FIRST).split(\".\"))\n        end_lineno, end_col_offset = map(int, text.index(tk.SEL_LAST).split(\".\"))\n\n        if end_lineno > lineno and end_col_offset == 0:\n            # SelectAll includes nonexisting extra line\n            end_lineno -= 1\n            end_col_offset = int(text.index(str(end_lineno) + \".end\").split(\".\")[1])\n    else:\n        lineno, col_offset = map(int, text.index(tk.INSERT).split(\".\"))\n        end_lineno, end_col_offset = lineno, col_offset\n\n    return TextRange(lineno, col_offset, end_lineno, end_col_offset)", "is_method": false, "function_description": "Provides the `TextRange` object representing the current text selection within a text editor. If no text is selected, it returns the range at the cursor's position, useful for context-aware operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_cmd_toggle_selection_comment", "line_number": 89, "body": "def _cmd_toggle_selection_comment():\n    text = _get_focused_writable_text()\n    if text is not None:\n        _toggle_selection_comment(text)", "is_method": false, "function_description": "Provides a command to toggle commenting on or off for the currently selected text. This is a common feature in text editors and IDEs for code manipulation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_cmd_comment_selection", "line_number": 95, "body": "def _cmd_comment_selection():\n    text = _get_focused_writable_text()\n    if text is not None:\n        _comment_selection(text)", "is_method": false, "function_description": "Adds comment characters to the currently focused or selected text block. It provides a common editor command to quickly comment out code or text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_cmd_uncomment_selection", "line_number": 101, "body": "def _cmd_uncomment_selection():\n    text = _get_focused_writable_text()\n    if text is not None:\n        _uncomment_selection(text)", "is_method": false, "function_description": "Provides a command to uncomment the currently selected text in a text editing interface. It allows users to quickly re-enable commented-out code or content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_cmd_indent_selection", "line_number": 107, "body": "def _cmd_indent_selection():\n    text = _get_focused_writable_text()\n    if text is not None and hasattr(text, \"indent_region\"):\n        text.indent_region()", "is_method": false, "function_description": "Applies an indentation operation to the selected text within the currently focused writable text component, if supported."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_cmd_dedent_selection", "line_number": 113, "body": "def _cmd_dedent_selection():\n    text = _get_focused_writable_text()\n    if text is not None and hasattr(text, \"dedent_region\"):\n        text.dedent_region()", "is_method": false, "function_description": "Reduces the indentation level of the currently selected text region. It provides a command for formatting text within an interactive editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "_cmd_replace_tabs", "line_number": 119, "body": "def _cmd_replace_tabs():\n    text = _get_focused_writable_text()\n    if text is not None:\n        orig_lines = text.get(\"1.0\", \"end\").splitlines(keepends=True)\n        new_lines = []\n        for line in orig_lines:\n            leading_tab_count = 0\n            for char in line:\n                if char == \"\\t\":\n                    leading_tab_count += 1\n                else:\n                    break\n            new_lines.append(leading_tab_count * \"    \" + line[leading_tab_count:])\n\n        text.delete(\"1.0\", \"end\")\n\n        text.insert(\"1.0\", \"\".join(new_lines))", "is_method": false, "function_description": "This function modifies the focused text by replacing all leading tabs with four spaces, standardizing indentation for consistent formatting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/commenting_indenting.py", "function": "load_plugin", "line_number": 138, "body": "def load_plugin() -> None:\n\n    get_workbench().add_command(\n        \"indent\",\n        \"edit\",\n        tr(\"Indent selected lines\"),\n        _cmd_indent_selection,\n        tester=_writable_text_is_focused,\n        accelerator=\"Tab\",\n        group=49,\n    )\n\n    get_workbench().add_command(\n        \"dedent\",\n        \"edit\",\n        tr(\"Dedent selected lines\"),\n        _cmd_dedent_selection,\n        tester=_writable_text_is_focused,\n        accelerator=\"Shift+Tab\",\n        group=49,\n    )\n\n    get_workbench().add_command(\n        \"replace_tabs\",\n        \"edit\",\n        tr(\"Replace tabs with spaces\"),\n        _cmd_replace_tabs,\n        tester=_writable_text_is_focused,\n        group=49,\n    )\n\n    get_workbench().add_command(\n        \"toggle_comment\",\n        \"edit\",\n        tr(\"Toggle comment\"),\n        _cmd_toggle_selection_comment,\n        default_sequence=select_sequence(\"<Control-Key-3>\", \"<Command-Key-3>\"),\n        tester=_writable_text_is_focused,\n        group=50,\n    )\n\n    get_workbench().add_command(\n        \"comment_selection\",\n        \"edit\",\n        tr(\"Comment out\"),\n        _cmd_comment_selection,\n        default_sequence=\"<Alt-Key-3>\",\n        tester=_writable_text_is_focused,\n        group=50,\n    )\n\n    get_workbench().add_command(\n        \"uncomment_selection\",\n        \"edit\",\n        tr(\"Uncomment\"),\n        _cmd_uncomment_selection,\n        default_sequence=\"<Alt-Key-4>\",\n        tester=_writable_text_is_focused,\n        group=50,\n    )", "is_method": false, "function_description": "Registers essential text editing commands\u2014like indent, dedent, and comment toggling\u2014with the application's workbench. It enables core editor functionalities for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/notes.py", "function": "load_plugin", "line_number": 62, "body": "def load_plugin():\n    get_workbench().add_view(NotesView, tr(\"Notes\"), \"ne\", default_position_key=\"zz\")", "is_method": false, "function_description": "This function serves to initialize a plugin by adding a \"Notes\" view to the application's main workbench. It integrates a specific UI component into the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/notes.py", "function": "on_secondary_click", "line_number": 14, "body": "def on_secondary_click(self, event=None):\n        super().on_secondary_click(event=event)\n        self.context_menu.tk_popup(event.x_root, event.y_root)", "is_method": true, "class_name": "NotesText", "function_description": "Handles a secondary click event on the text widget. It displays a context menu at the mouse cursor's position, providing contextual options to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/notes.py", "function": "load_content", "line_number": 31, "body": "def load_content(self):\n        if not os.path.isfile(self.filename):\n            self.text.insert(\n                \"1.0\",\n                tr(\n                    \"This box is meant for your working notes -- assignment instructions, \"\n                    + \"code snippets, whatever.\\n\\n\"\n                    + \"Everything will be saved automatically \"\n                    + \"and loaded when you open Thonny next time.\\n\\n\"\n                    + \"Feel free to delete this text to make room for your own notes.\"\n                ),\n            )\n            return\n\n        with open(self.filename, encoding=\"utf-8\") as fp:\n            content = fp.read()\n\n        self.text.delete(\"1.0\", \"end\")\n        self.text.insert(\"1.0\", content)\n        self.text.mark_set(\"insert\", \"1.0\")\n        self.text.see(\"1.0\")", "is_method": true, "class_name": "NotesView", "function_description": "Initializes the NotesView's text area by loading content from a file or providing default instructions if no file exists. It prepares the notes interface for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/notes.py", "function": "save_content", "line_number": 53, "body": "def save_content(self, event=None):\n        with open(self.filename, \"w\", encoding=\"utf-8\") as fp:\n            fp.write(self.text.get(\"1.0\", \"end-1c\"))", "is_method": true, "class_name": "NotesView", "function_description": "Persists the user's notes from the view to a file, ensuring the current content is saved for future access."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/notes.py", "function": "destroy", "line_number": 57, "body": "def destroy(self):\n        self.save_content()\n        super().destroy()", "is_method": true, "class_name": "NotesView", "function_description": "This method saves the `NotesView`'s current content and then properly disposes of the view instance, ensuring a clean shutdown and resource release."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_debugger_command_enabled", "line_number": 1166, "body": "def _debugger_command_enabled(command):\n    if _current_debugger is None:\n        return False\n    else:\n        return _current_debugger.command_enabled(command)", "is_method": false, "function_description": "Determines if a specific debugger command is enabled and available for use through the currently active debugger instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_issue_debugger_command", "line_number": 1173, "body": "def _issue_debugger_command(command):\n    if _current_debugger is None:\n        raise AssertionError(\"Trying to send debugger command without debugger\")\n    else:\n        return _current_debugger.check_issue_command(command)", "is_method": false, "function_description": "Sends a command to the currently active debugger, ensuring a debugger instance is available. It serves as an internal utility for debugger interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_start_debug_enabled", "line_number": 1180, "body": "def _start_debug_enabled():\n    return (\n        _current_debugger is None\n        and get_workbench().get_editor_notebook().get_current_editor() is not None\n        and \"debug\" in get_runner().get_supported_features()\n    )", "is_method": false, "function_description": "Determines if a new debug session can be initiated. It checks for no active debugger, an open editor, and debugger support in the execution environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_request_debug", "line_number": 1188, "body": "def _request_debug(command_name):\n    # Don't assume Debug command gets issued after this\n    # This may just call the %cd command\n    # or the user may deny saving current editor\n    if get_workbench().in_simple_mode():\n        get_workbench().show_view(\"VariablesView\")\n\n    get_runner().execute_current(command_name)", "is_method": false, "function_description": "This internal function prepares the user interface by optionally showing the Variables View, then executes a specified command. It likely assists in initiating debug-related operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_debug_accepted", "line_number": 1198, "body": "def _debug_accepted(event):\n    # Called when proxy accepted the debug command\n    global _current_debugger\n    cmd = event.command\n    if cmd.get(\"name\") in [\"Debug\", \"FastDebug\"]:\n        assert _current_debugger is None\n        if get_workbench().get_option(\"debugger.frames_in_separate_windows\"):\n            _current_debugger = StackedWindowsDebugger()\n        else:\n            _current_debugger = SingleWindowDebugger()", "is_method": false, "function_description": "Initializes the global debugger instance when a debug command is accepted. It configures the debugger's display mode (stacked or single window) based on user preferences."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_handle_debugger_progress", "line_number": 1210, "body": "def _handle_debugger_progress(msg):\n    global _current_debugger\n    assert _current_debugger is not None\n    _current_debugger.handle_debugger_progress(msg)\n    _update_run_or_resume_button()", "is_method": false, "function_description": "This function processes incoming progress messages for the active debugger. It updates the debugger's internal state and refreshes related UI elements, such as a run/resume button."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_handle_toplevel_response", "line_number": 1217, "body": "def _handle_toplevel_response(msg):\n    global _current_debugger\n    if _current_debugger is not None:\n        _current_debugger.close()\n        _current_debugger = None\n\n    _update_run_or_resume_button()", "is_method": false, "function_description": "Ensures a clean debugger state by closing any active debugger and resetting its reference. It also updates relevant UI controls for execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_handle_debugger_return", "line_number": 1226, "body": "def _handle_debugger_return(msg):\n    global _current_debugger\n    assert _current_debugger is not None\n    _current_debugger.handle_debugger_return(msg)", "is_method": false, "function_description": "Dispatches a debugger's return message to the active debugger instance. It ensures the global debugger processes the incoming communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_run_or_resume", "line_number": 1232, "body": "def _run_or_resume():\n    state = get_runner().get_state()\n    if state == \"waiting_debugger_command\":\n        _issue_debugger_command(\"resume\")\n    elif state == \"waiting_toplevel_command\":\n        get_runner().cmd_run_current_script()", "is_method": false, "function_description": "Resumes script execution or debugger operation based on the runner's current state, enabling continuation of paused processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_run_or_resume_enabled", "line_number": 1240, "body": "def _run_or_resume_enabled():\n    return get_runner().cmd_run_current_script_enabled() or _debugger_command_enabled(\"resume\")", "is_method": false, "function_description": "Checks if running the current script or resuming a debugger session is enabled. This function indicates if execution can proceed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_run_or_resume_button", "line_number": 1244, "body": "def _update_run_or_resume_button():\n    if not get_workbench().in_simple_mode():\n        return\n\n    state = get_runner().get_state()\n    if state == \"waiting_debugger_command\":\n        caption = RESUME_COMMAND_CAPTION\n        image = get_workbench().get_image(\"resume\")\n    elif state == \"waiting_toplevel_command\":\n        caption = running.RUN_COMMAND_CAPTION\n        image = get_workbench().get_image(\"run-current-script\")\n    else:\n        return\n\n    button = get_workbench().get_toolbar_button(\"runresume\")\n    button.configure(text=caption, image=image)", "is_method": false, "function_description": "Updates the 'run/resume' toolbar button's appearance based on the application's execution state, specifically in simple mode. It dynamically sets the button's text and icon to prompt running or resuming."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_current_debugger", "line_number": 1262, "body": "def get_current_debugger():\n    return _current_debugger", "is_method": false, "function_description": "Provides access to the currently configured debugger object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "run_preferred_debug_command", "line_number": 1266, "body": "def run_preferred_debug_command():\n    preferred_debugger = get_workbench().get_option(\"debugger.preferred_debugger\").lower()\n    if preferred_debugger == \"faster\":\n        return _request_debug(\"FastDebug\")\n    elif preferred_debugger == \"birdseye\":\n        from thonny.plugins.birdseye_frontend import debug_with_birdseye\n\n        return debug_with_birdseye()\n    else:\n        return _request_debug(\"Debug\")", "is_method": false, "function_description": "Launches the user's preferred debugger based on their workbench configuration, providing a unified command for various debugging tools."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "load_plugin", "line_number": 1278, "body": "def load_plugin() -> None:\n\n    global RESUME_COMMAND_CAPTION\n    RESUME_COMMAND_CAPTION = tr(\"Resume\")\n\n    if get_workbench().in_simple_mode():\n        get_workbench().set_default(\"debugger.frames_in_separate_windows\", False)\n    else:\n        get_workbench().set_default(\"debugger.frames_in_separate_windows\", True)\n\n    get_workbench().set_default(\"debugger.automatic_stack_view\", True)\n    get_workbench().set_default(\n        \"debugger.preferred_debugger\", \"faster\" if running_on_rpi() else \"nicer\"\n    )\n    get_workbench().set_default(\"debugger.allow_stepping_into_libraries\", False)\n\n    get_workbench().add_command(\n        \"runresume\",\n        \"run\",\n        tr(\"Run / resume\"),\n        _run_or_resume,\n        caption=running.RUN_COMMAND_CAPTION,\n        tester=_run_or_resume_enabled,\n        default_sequence=None,\n        group=10,\n        image=\"run-current-script\",\n        include_in_menu=False,\n        include_in_toolbar=get_workbench().in_simple_mode(),\n        alternative_caption=RESUME_COMMAND_CAPTION,\n    )\n\n    get_workbench().add_command(\n        \"debug_preferred\",\n        \"run\",\n        tr(\"Debug current script\"),\n        run_preferred_debug_command,\n        caption=tr(\"Debug\"),\n        tester=_start_debug_enabled,\n        group=10,\n        image=\"debug-current-script\",\n        include_in_menu=False,\n        include_in_toolbar=True,\n    )\n\n    get_workbench().add_command(\n        \"debug_nicer\",\n        \"run\",\n        tr(\"Debug current script (nicer)\"),\n        lambda: _request_debug(\"Debug\"),\n        caption=\"Debug (nicer)\",\n        tester=_start_debug_enabled,\n        default_sequence=\"<Control-F5>\",\n        group=10,\n        # image=\"debug-current-script\",\n    )\n\n    get_workbench().add_command(\n        \"debug_faster\",\n        \"run\",\n        tr(\"Debug current script (faster)\"),\n        lambda: _request_debug(\"FastDebug\"),\n        caption=\"Debug (faster)\",\n        tester=_start_debug_enabled,\n        default_sequence=\"<Shift-F5>\",\n        group=10,\n    )\n\n    get_workbench().add_command(\n        \"step_over\",\n        \"run\",\n        tr(\"Step over\"),\n        lambda: _issue_debugger_command(\"step_over\"),\n        caption=tr(\"Over\"),\n        tester=lambda: _debugger_command_enabled(\"step_over\"),\n        default_sequence=\"<F6>\",\n        group=30,\n        image=\"step-over\",\n        include_in_toolbar=True,\n    )\n\n    get_workbench().add_command(\n        \"step_into\",\n        \"run\",\n        tr(\"Step into\"),\n        lambda: _issue_debugger_command(\"step_into\"),\n        caption=tr(\"Into\"),\n        tester=lambda: _debugger_command_enabled(\"step_into\"),\n        default_sequence=\"<F7>\",\n        group=30,\n        image=\"step-into\",\n        include_in_toolbar=True,\n    )\n\n    get_workbench().add_command(\n        \"step_out\",\n        \"run\",\n        tr(\"Step out\"),\n        lambda: _issue_debugger_command(\"step_out\"),\n        caption=tr(\"Out\"),\n        tester=lambda: _debugger_command_enabled(\"step_out\"),\n        group=30,\n        image=\"step-out\",\n        include_in_toolbar=True,\n    )\n\n    get_workbench().add_command(\n        \"resume\",\n        \"run\",\n        RESUME_COMMAND_CAPTION,\n        lambda: _issue_debugger_command(\"resume\"),\n        caption=RESUME_COMMAND_CAPTION,\n        tester=lambda: _debugger_command_enabled(\"resume\"),\n        default_sequence=\"<F8>\",\n        group=30,\n        image=\"resume\",\n        include_in_toolbar=not get_workbench().in_simple_mode(),\n    )\n\n    get_workbench().add_command(\n        \"run_to_cursor\",\n        \"run\",\n        tr(\"Run to cursor\"),\n        lambda: _issue_debugger_command(\"run_to_cursor\"),\n        tester=lambda: _debugger_command_enabled(\"run_to_cursor\"),\n        default_sequence=select_sequence(\"<Control-F8>\", \"<Control-F8>\"),\n        group=30,\n        image=\"run-to-cursor\",\n        include_in_toolbar=False,\n    )\n\n    get_workbench().add_command(\n        \"step_back\",\n        \"run\",\n        tr(\"Step back\"),\n        lambda: _issue_debugger_command(\"step_back\"),\n        caption=tr(\"Back\"),\n        tester=lambda: _debugger_command_enabled(\"step_back\"),\n        default_sequence=select_sequence(\"<Control-b>\", \"<Command-b>\"),\n        group=30,\n    )\n\n    get_workbench().add_view(StackView, tr(\"Stack\"), \"se\")\n    get_workbench().add_view(ExceptionView, tr(\"Exception\"), \"s\")\n    get_workbench().bind(\"DebuggerResponse\", _handle_debugger_progress, True)\n    get_workbench().bind(\"ToplevelResponse\", _handle_toplevel_response, True)\n    get_workbench().bind(\"debugger_return_response\", _handle_debugger_return, True)\n    get_workbench().bind(\"CommandAccepted\", _debug_accepted, True)", "is_method": false, "function_description": "Configures and initializes the integrated debugging environment. It sets debugger preferences, adds run/debug commands, and registers associated views and event handlers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "check_issue_command", "line_number": 48, "body": "def check_issue_command(self, command, **kwargs):\n        cmd = DebuggerCommand(command, **kwargs)\n        self._last_debugger_command = cmd\n\n        if get_runner().is_waiting_debugger_command():\n            logging.debug(\"_check_issue_debugger_command: %s\", cmd)\n\n            # tell MainCPythonBackend the state we are seeing\n            cmd.setdefault(\n                frame_id=self._last_progress_message.stack[-1].id,\n                breakpoints=self.get_effective_breakpoints(command),\n                state=self._last_progress_message.stack[-1].event,\n                focus=self._last_progress_message.stack[-1].focus,\n                allow_stepping_into_libraries=get_workbench().get_option(\n                    \"debugger.allow_stepping_into_libraries\"\n                ),\n            )\n            if command == \"run_to_cursor\":\n                # cursor position was added as another breakpoint\n                cmd.name = \"resume\"\n\n            get_runner().send_command(cmd)\n            if command == \"resume\":\n                self.clear_last_frame()\n        else:\n            logging.debug(\"Bad state for sending debugger command \" + str(command))", "is_method": true, "class_name": "Debugger", "function_description": "Issues debugger commands to the debugged process. It prepares the command with current debugging context and sends it when the process is ready to receive it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_effective_breakpoints", "line_number": 78, "body": "def get_effective_breakpoints(self, command):\n        result = editors.get_current_breakpoints()\n\n        if command == \"run_to_cursor\":\n            bp = self.get_run_to_cursor_breakpoint()\n            if bp is not None:\n                filename, lineno = bp\n                result.setdefault(filename, set())\n                result[filename].add(lineno)\n\n        return result", "is_method": true, "class_name": "Debugger", "function_description": "This Debugger method determines the effective set of breakpoints by combining existing breakpoints with a dynamically added \"run-to-cursor\" breakpoint, if specified. It guides the debugger's execution flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "command_enabled", "line_number": 90, "body": "def command_enabled(self, command):\n        if not get_runner().is_waiting_debugger_command():\n            return False\n\n        if command == \"run_to_cursor\":\n            return self.get_run_to_cursor_breakpoint() is not None\n        elif command == \"step_back\":\n            return (\n                self._last_progress_message\n                and self._last_progress_message[\"tracer_class\"] == \"NiceTracer\"\n            )\n        else:\n            return True", "is_method": true, "class_name": "Debugger", "function_description": "Checks if a specific debugger command is currently available for execution. It determines command availability based on the debugger's current state and command-specific conditions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close", "line_number": 110, "body": "def close(self) -> None:\n        self._last_brought_out_frame_id = None\n\n        if get_workbench().get_option(\"debugger.automatic_stack_view\"):\n            get_workbench().hide_view(\"StackView\")", "is_method": true, "class_name": "Debugger", "function_description": "As a method of the `Debugger` class, this function cleanly shuts down the current debugging session. It resets internal state and conditionally hides the StackView for a tidy exit."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_frame_by_id", "line_number": 119, "body": "def get_frame_by_id(self, frame_id):\n        for frame_info in self._last_progress_message.stack:\n            if frame_info.id == frame_id:\n                return frame_info\n\n        raise ValueError(\"Could not find frame %d\" % frame_id)", "is_method": true, "class_name": "Debugger", "function_description": "Retrieves a specific execution frame from the debugger's captured stack using its unique ID. This enables inspection and navigation within the program's execution flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_editor_context_menu", "line_number": 130, "body": "def get_editor_context_menu(self):\n        def create_edit_command_handler(virtual_event_sequence):\n            def handler(event=None):\n                widget = get_workbench().focus_get()\n                if widget:\n                    return widget.event_generate(virtual_event_sequence)\n\n                return None\n\n            return handler\n\n        if self._editor_context_menu is None:\n            menu = tk.Menu(get_workbench())\n            menu.add(\n                \"command\",\n                label=tr(\"Run to cursor\"),\n                command=lambda: self.check_issue_command(\"run_to_cursor\"),\n            )\n            menu.add(\"separator\")\n            menu.add(\"command\", label=\"Copy\", command=create_edit_command_handler(\"<<Copy>>\"))\n            menu.add(\n                \"command\",\n                label=tr(\"Select all\"),\n                command=create_edit_command_handler(\"<<SelectAll>>\"),\n            )\n            self._editor_context_menu = menu\n\n        return self._editor_context_menu", "is_method": true, "class_name": "Debugger", "function_description": "Provides or creates the editor's context menu within the debugger. It offers essential debugging actions like 'Run to cursor' and standard text editing commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_run_to_cursor_breakpoint", "line_number": 167, "body": "def get_run_to_cursor_breakpoint(self):\n        editor = get_workbench().get_editor_notebook().get_current_editor()\n        if editor:\n            filename = editor.get_filename()\n            selection = editor.get_code_view().get_selected_range()\n            lineno = selection.lineno\n            if filename and lineno:\n                return filename, lineno\n\n        return None", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "Provides the file path and line number for the current editor's cursor position. This enables setting a 'run to cursor' debugger breakpoint."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handle_debugger_progress", "line_number": 178, "body": "def handle_debugger_progress(self, msg):\n        super().handle_debugger_progress(msg)\n        self._last_progress_message = msg\n        self.bring_out_frame(self._last_progress_message.stack[-1].id, force=True)\n\n        if get_workbench().get_option(\"debugger.automatic_stack_view\"):\n            if len(msg.stack) > 1:\n                get_workbench().show_view(\"StackView\")\n\n        get_workbench().get_view(\"ExceptionView\").set_exception(\n            msg[\"exception_info\"][\"lines_with_frame_info\"]\n        )", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "This method updates the debugger's user interface based on progress messages. It brings the current stack frame into focus, conditionally displays the stack view, and presents exception details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close", "line_number": 191, "body": "def close(self):\n        super().close()\n        if self._last_frame_visualizer is not None:\n            self._last_frame_visualizer.close()\n            self._last_frame_visualizer = None", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "Closes the debugger window, releasing its resources. It also ensures the proper shutdown of any associated frame visualizer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear_last_frame", "line_number": 197, "body": "def clear_last_frame(self):\n        if self._last_frame_visualizer is not None:\n            self._last_frame_visualizer.clear()", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "Clears the display of the last visualized debugging frame, removing its visual representation from the debugger's window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "bring_out_frame", "line_number": 201, "body": "def bring_out_frame(self, frame_id, force=False):\n        if not force and frame_id == self._last_brought_out_frame_id:\n            return\n\n        self._last_brought_out_frame_id = frame_id\n\n        frame_info = self.get_frame_by_id(frame_id)\n\n        if (\n            self._last_frame_visualizer is not None\n            and self._last_frame_visualizer._frame_id != frame_info.id\n        ):\n            self._last_frame_visualizer.close()\n            self._last_frame_visualizer = None\n\n        if self._last_frame_visualizer is None:\n            self._last_frame_visualizer = EditorVisualizer(frame_info)\n\n        self._last_frame_visualizer._update_this_frame(self._last_progress_message, frame_info)\n\n        # show variables\n        var_view = get_workbench().get_view(\"VariablesView\")\n        if frame_info.code_name == \"<module>\":\n            var_view.show_globals(frame_info.globals, frame_info.module_name)\n        else:\n            var_view.show_frame_variables(\n                frame_info.locals,\n                frame_info.globals,\n                frame_info.freevars,\n                frame_info.module_name\n                if frame_info.code_name == \"<module>\"\n                else frame_info.code_name,\n            )", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "For the SingleWindowDebugger, this method displays a specified execution frame and its associated variables, updating the debugger's UI to show the current code and variable states."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handle_debugger_return", "line_number": 235, "body": "def handle_debugger_return(self, msg):\n        if (\n            self._last_frame_visualizer is not None\n            and self._last_frame_visualizer.get_frame_id() == msg.get(\"frame_id\")\n        ):\n            self._last_frame_visualizer.close()", "is_method": true, "class_name": "SingleWindowDebugger", "function_description": "Closes the last visualized debugger frame if the incoming message indicates a return from it, ensuring display consistency within the debugger window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_run_to_cursor_breakpoint", "line_number": 248, "body": "def get_run_to_cursor_breakpoint(self):\n        visualizer = self._get_topmost_selected_visualizer()\n        if visualizer:\n            assert isinstance(visualizer._text_frame, CodeView)\n            code_view = visualizer._text_frame\n            selection = code_view.get_selected_range()\n\n            target_lineno = visualizer._firstlineno - 1 + selection.lineno\n            return visualizer._filename, target_lineno\n        else:\n            return None", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "This method retrieves the file and line number for a \"run to cursor\" breakpoint. It targets the selected code within the debugger's active visualizer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handle_debugger_progress", "line_number": 260, "body": "def handle_debugger_progress(self, msg):\n        super().handle_debugger_progress(msg)\n\n        self._last_progress_message = msg\n\n        main_frame_id = msg.stack[0].id\n\n        # clear obsolete main frame visualizer\n        if (\n            self._main_frame_visualizer\n            and self._main_frame_visualizer.get_frame_id() != main_frame_id\n        ):\n            self._main_frame_visualizer.close()\n            self._main_frame_visualizer = None\n\n        if not self._main_frame_visualizer:\n            self._main_frame_visualizer = EditorVisualizer(msg.stack[0])\n\n        self._main_frame_visualizer.update_this_and_next_frames(msg)\n\n        self.bring_out_frame(msg.stack[-1].id, force=True)\n\n        get_workbench().get_view(\"ExceptionView\").set_exception(\n            msg[\"exception_info\"][\"lines_with_frame_info\"]\n        )", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Updates the debugger's UI based on execution progress, managing the main stack frame visualization and displaying exception information for the current debugging session."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close", "line_number": 286, "body": "def close(self):\n        super().close()\n        if self._main_frame_visualizer is not None:\n            self._main_frame_visualizer.close()\n            self._main_frame_visualizer = None", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Shuts down the debugger, releasing its resources. It also closes any associated main frame visualizer to ensure proper cleanup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear_last_frame", "line_number": 292, "body": "def clear_last_frame(self):\n        visualizer = self._get_topmost_visualizer()\n        if visualizer is not None:\n            visualizer.clear()", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Clears the content of the topmost visual debugging frame. This service helps reset the display of the active debugging window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_get_topmost_visualizer", "line_number": 297, "body": "def _get_topmost_visualizer(self):\n        visualizer = self._main_frame_visualizer\n        if visualizer is None:\n            return None\n\n        while visualizer._next_frame_visualizer is not None:\n            visualizer = visualizer._next_frame_visualizer\n\n        return visualizer", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Retrieves the topmost visualizer in the debugger's stacked window chain. This provides access to the currently active or most recent visual frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_get_topmost_selected_visualizer", "line_number": 307, "body": "def _get_topmost_selected_visualizer(self):\n        visualizer = self._get_topmost_visualizer()\n        if visualizer is None:\n            return None\n\n        topmost_text_widget = visualizer._text\n        focused_widget = get_workbench().focus_get()\n\n        if focused_widget is None:\n            return None\n        elif focused_widget == topmost_text_widget:\n            return visualizer\n        else:\n            return None", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Retrieves the topmost visualizer only if its associated text content widget is currently focused. This identifies the actively selected visualizer for debugging operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "bring_out_frame", "line_number": 322, "body": "def bring_out_frame(self, frame_id, force=False):\n        if not force and frame_id == self._last_brought_out_frame_id:\n            return\n\n        self._last_brought_out_frame_id = frame_id\n\n        self._main_frame_visualizer.bring_out_frame(frame_id)\n\n        # show variables\n        var_view = get_workbench().get_view(\"VariablesView\")\n        frame_info = self.get_frame_by_id(frame_id)\n        var_view.show_globals(frame_info.globals, frame_info.module_name)", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "Activates a specified debugging frame for inspection within the UI. It updates the VariablesView to display the global variables of that frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handle_debugger_return", "line_number": 335, "body": "def handle_debugger_return(self, msg):\n        if self._main_frame_visualizer is None:\n            return\n\n        self._main_frame_visualizer.close(msg[\"frame_id\"])\n        if msg[\"frame_id\"] == self._main_frame_visualizer.get_frame_id():\n            self._main_frame_visualizer = None", "is_method": true, "class_name": "StackedWindowsDebugger", "function_description": "This method processes a debugger return message to close a visualizer frame. If the closed frame was the main one, it resets the main frame visualizer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_translate_lineno", "line_number": 370, "body": "def _translate_lineno(self, lineno):\n        return lineno - self._firstlineno + 1", "is_method": true, "class_name": "FrameVisualizer", "function_description": "This method translates an absolute line number into a 1-based relative line number, typically for presentation within the visualized code frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_reconfigure_tags", "line_number": 373, "body": "def _reconfigure_tags(self):\n        for tag in [\"active_focus\", \"exception_focus\"]:\n            conf = get_syntax_options_for_tag(tag).copy()\n            if self._line_debug:\n                # meaning data comes from line-debug\n                conf[\"borderwidth\"] = 0\n\n            self._text.tag_configure(tag, **conf)", "is_method": true, "class_name": "FrameVisualizer", "function_description": "This method of `FrameVisualizer` reconfigures the visual properties of \"active_focus\" and \"exception_focus\" tags in a text widget. It adjusts their border width based on the line debugging state, enabling dynamic display for active lines or exceptions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close", "line_number": 382, "body": "def close(self, frame_id=None):\n        if self._next_frame_visualizer:\n            self._next_frame_visualizer.close(frame_id)\n            if frame_id is None or self._next_frame_visualizer.get_frame_id() == frame_id:\n                self._next_frame_visualizer = None\n\n        if frame_id is None or frame_id == self._frame_id:\n            self._text.set_read_only(False)\n            self.clear()", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Closes the currently active visualization frame or a specific one by ID. It also recursively closes any chained visualizers and performs local cleanup actions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear", "line_number": 393, "body": "def clear(self):\n        self.remove_focus_tags()\n        self.hide_expression_box()\n        self.close_note()", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Resets the FrameVisualizer's display by clearing focus elements, hiding the expression box, and closing any open notes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_frame_id", "line_number": 398, "body": "def get_frame_id(self):\n        return self._frame_id", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Retrieves the unique identifier of the frame currently being visualized. This allows other components to reference or manipulate the specific frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "update_this_and_next_frames", "line_number": 401, "body": "def update_this_and_next_frames(self, msg):\n        \"\"\"Must not be used on obsolete frame\"\"\"\n\n        # debug(\"State: %s, focus: %s\", msg.state, msg.focus)\n\n        frame_info, next_frame_info = self._find_this_and_next_frame(msg.stack)\n        self._update_this_frame(msg, frame_info)\n\n        # clear obsolete next frame visualizer\n        if self._next_frame_visualizer and (\n            not next_frame_info or self._next_frame_visualizer.get_frame_id() != next_frame_info.id\n        ):\n            self._next_frame_visualizer.close()\n            self._next_frame_visualizer = None\n\n        if next_frame_info and not self._next_frame_visualizer:\n            self._next_frame_visualizer = self._create_next_frame_visualizer(next_frame_info)\n            self._next_frame_visualizer._prev_frame_visualizer = self\n\n        if self._next_frame_visualizer:\n            self._next_frame_visualizer.update_this_and_next_frames(msg)", "is_method": true, "class_name": "FrameVisualizer", "function_description": "This method updates the visualization of the current execution frame. It then recursively updates and manages the visualizers for subsequent frames, ensuring consistent display along a sequence."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "remove_focus_tags", "line_number": 423, "body": "def remove_focus_tags(self):\n        for name in [\n            \"exception_focus\",\n            \"active_focus\",\n            \"completed_focus\",\n            \"suspended_focus\",\n            \"sel\",\n        ]:\n            self._text.tag_remove(name, \"0.0\", \"end\")", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Removes all predefined focus-related tags from the visualized text content. This action clears visual highlighting for various states like exceptions, active lines, or selections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "hide_expression_box", "line_number": 433, "body": "def hide_expression_box(self):\n        if self._expression_box is not None:\n            self._expression_box.clear_debug_view()", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Provides the capability to hide the expression box by clearing its visual display, if it is active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_this_frame", "line_number": 437, "body": "def _update_this_frame(self, msg, frame_info):\n        self._frame_info = frame_info\n        self.remove_focus_tags()\n\n        if frame_info.event == \"line\":\n            if (\n                frame_info.id in msg[\"exception_info\"][\"affected_frame_ids\"]\n                and msg[\"exception_info\"][\"is_fresh\"]\n            ):\n                self._tag_range(frame_info.focus, \"exception_focus\")\n            else:\n                self._tag_range(frame_info.focus, \"active_focus\")\n        else:\n            if \"statement\" in frame_info.event:\n                if msg[\"exception_info\"][\"msg\"] is not None and msg[\"exception_info\"][\"is_fresh\"]:\n                    stmt_tag = \"exception_focus\"\n                elif frame_info.event.startswith(\"before\"):\n                    stmt_tag = \"active_focus\"\n                else:\n                    stmt_tag = \"completed_focus\"\n            else:\n                assert \"expression\" in frame_info.event\n                stmt_tag = \"suspended_focus\"\n\n            if frame_info.current_statement is not None:\n                self._tag_range(frame_info.current_statement, stmt_tag)\n            else:\n                logging.warning(\"Missing current_statement: %s\", frame_info)\n\n        self._expression_box.update_expression(msg, frame_info)\n\n        if (\n            frame_info.id in msg[\"exception_info\"][\"affected_frame_ids\"]\n            and msg[\"exception_info\"][\"is_fresh\"]\n        ):\n            self._show_exception(msg[\"exception_info\"][\"lines_with_frame_info\"], frame_info)\n        else:\n            self.close_note()", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Updates the visual state of a code frame, highlighting the current execution point (line, statement, or expression) and indicating any active exceptions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_show_exception", "line_number": 476, "body": "def _show_exception(self, lines, frame_info):\n        last_line_text = lines[-1][0]\n        self.show_note(\n            last_line_text.strip() + \" \",\n            (\"...\", lambda _: get_workbench().show_view(\"ExceptionView\")),\n            focus=frame_info.focus,\n        )", "is_method": true, "class_name": "FrameVisualizer", "function_description": "As part of FrameVisualizer, this method displays the last line of an exception message and provides an interactive link to open a detailed ExceptionView."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_find_this_and_next_frame", "line_number": 484, "body": "def _find_this_and_next_frame(self, stack):\n        for i in range(len(stack)):\n            if stack[i].id == self._frame_id:\n                if i == len(stack) - 1:  # last frame\n                    return stack[i], None\n                else:\n                    return stack[i], stack[i + 1]\n\n        raise AssertionError(\"Frame doesn't exist anymore\")", "is_method": true, "class_name": "FrameVisualizer", "function_description": "This method helps the FrameVisualizer locate a specific frame and its direct successor within a given stack. It enables sequential processing or visualization of frames."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_tag_range", "line_number": 494, "body": "def _tag_range(self, text_range, tag):\n        # For most statements I want to highlight block of whole lines\n        # but for pseudo-statements (like header in for-loop) I want to highlight only the indicated range\n\n        self._text.tag_raise(tag)\n\n        line_prefix = self._text.get(\n            \"%d.0\" % self._translate_lineno(text_range.lineno),\n            \"%d.%d\" % (self._translate_lineno(text_range.lineno), text_range.col_offset),\n        )\n        if line_prefix.strip():\n            # pseudo-statement\n            first_line = self._translate_lineno(text_range.lineno)\n            last_line = self._translate_lineno(text_range.end_lineno)\n            self._text.tag_add(\n                tag,\n                \"%d.%d\" % (first_line, text_range.col_offset),\n                \"%d.%d\" % (last_line, text_range.end_col_offset),\n            )\n        else:\n            # normal statement\n            first_line, first_col, last_line = self._get_text_range_block(text_range)\n\n            for lineno in range(first_line, last_line + 1):\n                self._text.tag_add(tag, \"%d.%d\" % (lineno, first_col), \"%d.0\" % (lineno + 1))\n\n        self._text.update_idletasks()\n        self._text.see(\"%d.0\" % (last_line))\n        self._text.see(\"%d.0\" % (first_line))\n\n        if last_line - first_line < 3:\n            # if it's safe to assume that whole code fits into screen\n            # then scroll it down a bit so that expression view doesn't hide behind\n            # lower edge of the editor\n            self._text.update_idletasks()\n            self._text.see(\"%d.0\" % (first_line + 3))", "is_method": true, "class_name": "FrameVisualizer", "function_description": "The FrameVisualizer method highlights a given code range in a text display, adjusting between full-line blocks and precise character spans. It ensures the highlighted area is visible on screen."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_get_text_range_block", "line_number": 531, "body": "def _get_text_range_block(self, text_range):\n        first_line = text_range.lineno - self._firstlineno + 1\n        last_line = (\n            text_range.end_lineno - self._firstlineno + (1 if text_range.end_col_offset > 0 else 0)\n        )\n        first_line_content = self._text.get(\"%d.0\" % first_line, \"%d.end\" % first_line)\n        if first_line_content.strip().startswith(\"elif \"):\n            first_col = first_line_content.find(\"elif \")\n        else:\n            first_col = text_range.col_offset\n\n        return (first_line, first_col, last_line)", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Calculates the adjusted start line, start column, and end line of a text range within the visualized frame. This prepares the range for accurate display or highlighting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_create_next_frame_visualizer", "line_number": 544, "body": "def _create_next_frame_visualizer(self, next_frame_info):\n        if next_frame_info.code_name == \"<module>\":\n            return ModuleLoadDialog(self._text, next_frame_info)\n        else:\n            dialog = FunctionCallDialog(self._text.master, next_frame_info)\n\n            if self._expression_box.winfo_ismapped():\n                dialog.title(self._expression_box.get_focused_text())\n            else:\n                dialog.title(tr(\"Function call at %s\") % hex(self._frame_id))\n\n            return dialog", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Generates a specific dialog window to visualize the subsequent execution frame. It differentiates between module loading and function calls, offering tailored visual representation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "bring_out_frame", "line_number": 557, "body": "def bring_out_frame(self, frame_id):\n        if self._frame_id == frame_id:\n            self.bring_out_this_frame()\n        elif self._next_frame_visualizer is not None:\n            self._next_frame_visualizer.bring_out_frame(frame_id)", "is_method": true, "class_name": "FrameVisualizer", "function_description": "This method activates a specific frame among a sequence of `FrameVisualizer` objects by delegating the request along the chain. It ensures the correct frame is brought to the foreground."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "show_note", "line_number": 566, "body": "def show_note(self, *content_items: Union[str, List], target=None, focus=None) -> None:\n        if target is None:\n            target = self._text\n\n        self._note_box.show_note(*content_items, target=target, focus=focus)", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Displays a customizable note within the visual frame. It allows specifying content, a target element for placement, and an area to focus on."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close_note", "line_number": 572, "body": "def close_note(self):\n        self._note_box.close()", "is_method": true, "class_name": "FrameVisualizer", "function_description": "Closes the visual note box associated with the frame. This function dismisses the displayed note from the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_this_frame", "line_number": 589, "body": "def _update_this_frame(self, msg, frame_info):\n        FrameVisualizer._update_this_frame(self, msg, frame_info)\n        if msg.in_present:\n            self._decorate_editor_title(\"\")\n        else:\n            self._decorate_editor_title(\"   <<< REPLAYING >>> \")", "is_method": true, "class_name": "EditorVisualizer", "function_description": "This method updates the editor's display for a given frame. It visually indicates whether the frame represents live content or is part of a replay."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_decorate_editor_title", "line_number": 596, "body": "def _decorate_editor_title(self, suffix):\n        self.editor.master.update_editor_title(self.editor, self.editor.get_title() + suffix)", "is_method": true, "class_name": "EditorVisualizer", "function_description": "Appends a specified suffix to the current title of the associated editor, updating its display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "bring_out_this_frame", "line_number": 599, "body": "def bring_out_this_frame(self):\n        get_workbench().focus_set()", "is_method": true, "class_name": "EditorVisualizer", "function_description": "Brings the main application workbench into focus, ensuring it is the active window for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear", "line_number": 602, "body": "def clear(self):\n        super().clear()\n        self._decorate_editor_title(\"\")", "is_method": true, "class_name": "EditorVisualizer", "function_description": "Resets the editor's visual state. It clears all displayed content and removes the editor's title."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_text_options", "line_number": 623, "body": "def get_text_options(self):\n        opts = dict(\n            height=1,\n            width=1,\n            relief=tk.RAISED,\n            background=\"#DCEDF2\",\n            borderwidth=1,\n            highlightthickness=0,\n            padx=7,\n            pady=7,\n            wrap=tk.NONE,\n            font=\"EditorFont\",\n        )\n        opts.update(get_syntax_options_for_tag(\"expression_box\"))\n        return opts", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Generates the default and syntax-specific display options for the text area of the expression box, defining its visual appearance and behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "update_expression", "line_number": 639, "body": "def update_expression(self, msg, frame_info):\n        focus = frame_info.focus\n        event = frame_info.event\n\n        if frame_info.current_root_expression is not None:\n\n            if self._last_root_expression != frame_info.current_root_expression:\n                # can happen, eg. when focus jumps from the last expr in while body\n                # to while test expression\n                self.clear_debug_view()\n\n            with open(frame_info.filename, \"rb\") as fp:\n                whole_source = fp.read()\n\n            lines = whole_source.splitlines()\n            if len(lines) < frame_info.current_root_expression.end_lineno:\n                # it must be on a synthetical line which is not actually present in the editor\n                self.clear_debug_view()\n                return\n\n            self._load_expression(\n                whole_source, frame_info.filename, frame_info.current_root_expression\n            )\n            for subrange, value in frame_info.current_evaluations:\n                self._replace(subrange, value)\n            if \"expression\" in event:\n                # Event may be also after_statement_again\n                self._highlight_range(\n                    focus,\n                    event,\n                    (\n                        frame_info.id in msg[\"exception_info\"][\"affected_frame_ids\"]\n                        and msg[\"exception_info\"][\"is_fresh\"]\n                    ),\n                )\n                self._last_focus = focus\n\n            self._update_position(frame_info.current_root_expression)\n            self._update_size()\n\n        else:\n            # hide and clear on non-expression events\n            self.clear_debug_view()\n\n        self._last_root_expression = frame_info.current_root_expression", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Provides a service to dynamically update a visual debugging box, displaying the current code expression, its evaluated sub-parts, and highlighting the execution focus."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_focused_text", "line_number": 685, "body": "def get_focused_text(self):\n        if self._last_focus:\n            start_mark = self._get_mark_name(self._last_focus.lineno, self._last_focus.col_offset)\n            end_mark = self._get_mark_name(\n                self._last_focus.end_lineno, self._last_focus.end_col_offset\n            )\n            return self.text.get(start_mark, end_mark)\n        else:\n            return \"\"", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Retrieves the text content corresponding to the last focused or selected region within the expression box."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear_debug_view", "line_number": 695, "body": "def clear_debug_view(self):\n        self._main_range = None\n        self._last_focus = None\n        self._clear_expression()", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Clears the internal state and resets the display for the expression box's debug view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_clear_expression", "line_number": 700, "body": "def _clear_expression(self):\n        for tag in self.text.tag_names():\n            self.text.tag_remove(tag, \"1.0\", \"end\")\n\n        self.text.mark_unset(*self.text.mark_names())\n        self.text.delete(\"1.0\", \"end\")", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Resets the expression box by clearing all text content, formatting tags, and text marks. This prepares the input area for new data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_replace", "line_number": 707, "body": "def _replace(self, focus, value):\n        start_mark = self._get_mark_name(focus.lineno, focus.col_offset)\n        end_mark = self._get_mark_name(focus.end_lineno, focus.end_col_offset)\n\n        self.text.delete(start_mark, end_mark)\n\n        id_str = memory.format_object_id(value.id)\n        if get_workbench().in_heap_mode():\n            value_str = id_str\n        else:\n            value_str = shorten_repr(value.repr, 100)\n\n        object_tag = \"object_\" + str(value.id)\n        self.text.insert(start_mark, value_str, (\"value\", object_tag))\n        if misc_utils.running_on_mac_os():\n            sequence = \"<Command-Button-1>\"\n        else:\n            sequence = \"<Control-Button-1>\"\n        self.text.tag_bind(\n            object_tag,\n            sequence,\n            lambda _: get_workbench().event_generate(\"ObjectSelect\", object_id=value.id),\n        )", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Within an expression display box, this method replaces a focused text segment with an object's string representation. It enables interaction, allowing users to select the underlying object by clicking its display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_load_expression", "line_number": 731, "body": "def _load_expression(self, whole_source, filename, text_range):\n\n        root = ast_utils.parse_source(whole_source, filename)\n        main_node = ast_utils.find_expression(root, text_range)\n\n        source = ast_utils.extract_text_range(whole_source, text_range)\n        logging.debug(\"EV.load_exp: %s\", (text_range, main_node, source))\n\n        self._clear_expression()\n\n        self.text.insert(\"1.0\", source)\n\n        # create node marks\n        def _create_index(lineno, col_offset):\n            local_lineno = lineno - main_node.lineno + 1\n            if lineno == main_node.lineno:\n                local_col_offset = col_offset - main_node.col_offset\n            else:\n                local_col_offset = col_offset\n\n            return str(local_lineno) + \".\" + str(local_col_offset)\n\n        for node in ast.walk(main_node):\n            if \"lineno\" in node._attributes and hasattr(node, \"end_lineno\"):\n                index1 = _create_index(node.lineno, node.col_offset)\n                index2 = _create_index(node.end_lineno, node.end_col_offset)\n\n                start_mark = self._get_mark_name(node.lineno, node.col_offset)\n                if not start_mark in self.text.mark_names():\n                    self.text.mark_set(start_mark, index1)\n                    # print(\"Creating mark\", start_mark, index1)\n                    self.text.mark_gravity(start_mark, tk.LEFT)\n\n                end_mark = self._get_mark_name(node.end_lineno, node.end_col_offset)\n                if not end_mark in self.text.mark_names():\n                    self.text.mark_set(end_mark, index2)\n                    # print(\"Creating mark\", end_mark, index2)\n                    self.text.mark_gravity(end_mark, tk.RIGHT)", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Loads a specific Python expression into the text display. It creates text marks corresponding to the expression's Abstract Syntax Tree (AST) nodes, enabling interactive analysis or navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_get_mark_name", "line_number": 770, "body": "def _get_mark_name(self, lineno, col_offset):\n        return str(lineno) + \"_\" + str(col_offset)", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "This method generates a unique identifier string using a line number and column offset. It likely serves to mark or reference specific positions within an expression or code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_get_tag_name", "line_number": 773, "body": "def _get_tag_name(self, node_or_text_range):\n        return (\n            str(node_or_text_range.lineno)\n            + \"_\"\n            + str(node_or_text_range.col_offset)\n            + \"_\"\n            + str(node_or_text_range.end_lineno)\n            + \"_\"\n            + str(node_or_text_range.end_col_offset)\n        )", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Provides a unique string identifier (tag name) for a code element, derived from its precise line and column start/end coordinates. This is useful for referencing specific code regions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_highlight_range", "line_number": 784, "body": "def _highlight_range(self, text_range, state, has_exception):\n        logging.debug(\"EV._highlight_range: %s\", text_range)\n        self.text.tag_remove(\"after\", \"1.0\", \"end\")\n        self.text.tag_remove(\"before\", \"1.0\", \"end\")\n        self.text.tag_remove(\"exception\", \"1.0\", \"end\")\n\n        if state.startswith(\"after\"):\n            tag = \"after\"\n        elif state.startswith(\"before\"):\n            tag = \"before\"\n        else:\n            return\n\n        start_index = self._get_mark_name(text_range.lineno, text_range.col_offset)\n        end_index = self._get_mark_name(text_range.end_lineno, text_range.end_col_offset)\n        self.text.tag_add(tag, start_index, end_index)\n\n        if has_exception:\n            self.text.tag_add(\"exception\", start_index, end_index)", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Manages visual highlighting of a text range within the expression box. It applies 'before', 'after', or 'exception' tags based on provided state and error conditions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_position", "line_number": 804, "body": "def _update_position(self, text_range):\n        self._codeview.update_idletasks()\n        text_line_number = text_range.lineno - self._codeview._first_line_number + 1\n        bbox = self._codeview.text.bbox(str(text_line_number) + \".\" + str(text_range.col_offset))\n\n        if isinstance(bbox, tuple):\n            x = bbox[0] - self._codeview.text.cget(\"padx\") + 6\n            y = bbox[1] - self._codeview.text.cget(\"pady\") - 6\n        else:\n            x = 30\n            y = 30\n\n        self._set_position_make_visible(x, y)", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Calculates the screen coordinates for a specified text range within a code view. It then positions the expression box to appear at these calculated coordinates, making it visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_size", "line_number": 818, "body": "def _update_size(self):\n        content = self.text.get(\"1.0\", tk.END)\n        lines = content.splitlines()\n        self.text[\"height\"] = len(lines)\n        self.text[\"width\"] = max(map(len, lines))", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "Dynamically adjusts the display size of the text box. It sets height to the number of lines and width to the longest line's length, ensuring all content is visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear_debug_view", "line_number": 833, "body": "def clear_debug_view(self):\n        if self.winfo_ismapped():\n            self.place_forget()\n\n        super().clear_debug_view()", "is_method": true, "class_name": "PlacedExpressionBox", "function_description": "Clears the debug view for the `PlacedExpressionBox` by hiding it if currently displayed. It also ensures the parent class's debug view is cleared."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_set_position_make_visible", "line_number": 839, "body": "def _set_position_make_visible(self, rel_x, rel_y):\n        x = rel_x\n        y = rel_y\n\n        widget = self._codeview.text\n        while widget != self.master:\n            x += widget.winfo_x()\n            y += widget.winfo_y()\n            widget = widget.master\n\n        if not self.winfo_ismapped():\n            self.place(x=x, y=y, anchor=tk.NW)\n            self.update()", "is_method": true, "class_name": "PlacedExpressionBox", "function_description": "Positions the `PlacedExpressionBox` by calculating its absolute screen coordinates from relative inputs. It ensures the box is displayed if not already visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "clear_debug_view", "line_number": 880, "body": "def clear_debug_view(self):\n        if self.winfo_ismapped():\n            self.withdraw()\n\n        super().clear_debug_view()", "is_method": true, "class_name": "ToplevelExpressionBox", "function_description": "Clears and hides the ToplevelExpressionBox's debug view, ensuring it's no longer visible and its underlying debug state is reset."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_set_position_make_visible", "line_number": 886, "body": "def _set_position_make_visible(self, rel_x, rel_y):\n        \"\"\"\n        widget = self._codeview.text\n        while widget is not None:\n            x += widget.winfo_x()\n            y += widget.winfo_y()\n            widget = widget.master\n        \"\"\"\n        x = rel_x + self._codeview.text.winfo_rootx()\n        y = rel_y + self._codeview.text.winfo_rooty()\n\n        if not self.winfo_ismapped():\n            self.update()\n            self.deiconify()\n        self.geometry(\"+%d+%d\" % (x, y))", "is_method": true, "class_name": "ToplevelExpressionBox", "function_description": "Positions the `ToplevelExpressionBox` on the screen relative to an internal text widget. It also ensures the box is visible before setting its final coordinates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "get_text_options", "line_number": 902, "body": "def get_text_options(self):\n        opts = super().get_text_options()\n        opts[\"relief\"] = \"flat\"\n        opts[\"borderwidth\"] = 0\n        return opts", "is_method": true, "class_name": "ToplevelExpressionBox", "function_description": "This method customizes the display options for text elements within a `ToplevelExpressionBox`. It ensures text widgets have a flat relief and no border."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_init_layout_widgets", "line_number": 944, "body": "def _init_layout_widgets(self, master, frame_info):\n        self.main_frame = ttk.Frame(\n            self\n        )  # just a background behind padding of main_pw, without this OS X leaves white border\n        self.main_frame.grid(sticky=tk.NSEW)\n        self.rowconfigure(0, weight=1)\n        self.columnconfigure(0, weight=1)\n        self.main_pw = ui_utils.AutomaticPanedWindow(self.main_frame, orient=tk.VERTICAL)\n        self.main_pw.grid(sticky=tk.NSEW, padx=10, pady=10)\n        self.main_frame.rowconfigure(0, weight=1)\n        self.main_frame.columnconfigure(0, weight=1)\n\n        self._code_book = ttk.Notebook(self.main_pw)\n        self._text_frame = CodeView(\n            self._code_book, first_line_number=frame_info.firstlineno, font=\"EditorFont\"\n        )\n        self._code_book.add(self._text_frame, text=tr(\"Source code\"))\n        self.main_pw.add(self._code_book, minsize=200)\n        self._code_book.preferred_size_in_pw = 400", "is_method": true, "class_name": "DialogVisualizer", "function_description": "Initializes the main graphical layout for the DialogVisualizer. It sets up core UI components like frames, paned windows, and a notebook with a source code view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_load_code", "line_number": 964, "body": "def _load_code(self, frame_info):\n        self._text_frame.set_content(frame_info.source)", "is_method": true, "class_name": "DialogVisualizer", "function_description": "This method loads source code from provided frame information. It populates the visualizer's text display with the retrieved source code for viewing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "bring_out_this_frame", "line_number": 970, "body": "def bring_out_this_frame(self):\n        self.focus_set()  # no effect when clicking on stack view\n        var_view = get_workbench().get_view(\"VariablesView\")\n        var_view.show_globals(self._frame_info.globals, self._frame_info.module_name)", "is_method": true, "class_name": "DialogVisualizer", "function_description": "Displays the global variables and module context of a specific execution frame within the 'VariablesView' UI, enabling inspection of program state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_on_close", "line_number": 979, "body": "def _on_close(self):\n        showinfo(\n            tr(\"Can't close yet\"),\n            tr('Use \"Stop\" command if you want to cancel debugging'),\n            master=self,\n        )", "is_method": true, "class_name": "DialogVisualizer", "function_description": "This method prevents direct closure of the debug visualization dialog. It informs the user to use the \"Stop\" command to properly terminate debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "close", "line_number": 986, "body": "def close(self, frame_id=None):\n        super().close()\n\n        if frame_id is None or frame_id == self._frame_id:\n            self.destroy()", "is_method": true, "class_name": "DialogVisualizer", "function_description": "Closes and destroys the visual dialog, optionally targeting a specific frame ID to ensure the correct dialog is terminated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_init_layout_widgets", "line_number": 997, "body": "def _init_layout_widgets(self, master, frame_info):\n        DialogVisualizer._init_layout_widgets(self, master, frame_info)\n        self._locals_book = ttk.Notebook(self.main_pw)\n        self._locals_frame = VariablesFrame(self._locals_book)\n        self._locals_book.preferred_size_in_pw = 200\n        self._locals_book.add(self._locals_frame, text=tr(\"Local variables\"))\n        self.main_pw.add(self._locals_book, minsize=100)", "is_method": true, "class_name": "FunctionCallDialog", "function_description": "Initializes the user interface of the function call dialog. It creates and configures GUI widgets, including a tabbed section dedicated to displaying local variables."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_load_code", "line_number": 1005, "body": "def _load_code(self, frame_info):\n        DialogVisualizer._load_code(self, frame_info)\n\n        function_label = frame_info.code_name\n\n        # change tab label\n        self._code_book.tab(self._text_frame, text=function_label)", "is_method": true, "class_name": "FunctionCallDialog", "function_description": "This method loads code information and updates the associated GUI tab's label to display the name of the function whose code is being viewed. It ensures the dialog's visual representation reflects the current function."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_this_frame", "line_number": 1013, "body": "def _update_this_frame(self, msg, frame_info):\n        DialogVisualizer._update_this_frame(self, msg, frame_info)\n        self._locals_frame.update_variables(frame_info.locals)", "is_method": true, "class_name": "FunctionCallDialog", "function_description": "Updates the function call dialog's visual state and refreshes the displayed local variables for the current execution frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_update_stack", "line_number": 1041, "body": "def _update_stack(self, msg):\n        self._clear_tree()\n\n        node_id = None\n        for frame in msg.stack:\n            lineno = frame.focus.lineno\n\n            node_id = self.tree.insert(\"\", \"end\")\n            self.tree.set(node_id, \"function\", frame.code_name)\n            self.tree.set(\n                node_id, \"location\", \"%s, line %s\" % (os.path.basename(frame.filename), lineno)\n            )\n            self.tree.set(node_id, \"id\", frame.id)\n\n        # select last frame\n        if node_id is not None:\n            self.tree.see(node_id)\n            self.tree.selection_add(node_id)\n            self.tree.focus(node_id)", "is_method": true, "class_name": "StackView", "function_description": "Updates the StackView's UI to display the current call stack. It populates the view with function names and locations for each frame, highlighting the latest."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_handle_debugger_return", "line_number": 1061, "body": "def _handle_debugger_return(self, msg):\n        delete = False\n        for iid in self.tree.get_children():\n            if self.tree.set(iid, \"id\") == msg[\"frame_id\"]:\n                # start deleting from this frame\n                delete = True\n\n            if delete:\n                self.tree.delete(iid)", "is_method": true, "class_name": "StackView", "function_description": "Handles debugger return events by pruning the displayed call stack. It removes all stack frames from the view that are above the frame from which the debugger returned."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "on_select", "line_number": 1071, "body": "def on_select(self, event):\n        iid = self.tree.focus()\n        if iid != \"\":\n            # assuming id is in the last column\n            frame_id = self.tree.item(iid)[\"values\"][-1]\n            if _current_debugger is not None:\n                _current_debugger.bring_out_frame(frame_id)", "is_method": true, "class_name": "StackView", "function_description": "Handles user selection of a call frame in the stack view. It instructs the active debugger to display or focus on the selected frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_show_description", "line_number": 1107, "body": "def _show_description(self):\n        self.text.configure(foreground=get_syntax_options_for_tag(\"TEXT\")[\"foreground\"])\n        self.text.direct_insert(\n            \"end\",\n            tr(\"If last command raised an exception then this view will show the stacktrace.\"),\n        )", "is_method": true, "class_name": "ExceptionView", "function_description": "Displays a descriptive message in the ExceptionView, explaining its purpose to show stack traces for raised exceptions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "set_exception", "line_number": 1114, "body": "def set_exception(self, exception_lines_with_frame_info):\n        if exception_lines_with_frame_info == self._prev_exception:\n            return\n\n        self.text.direct_delete(\"1.0\", \"end\")\n\n        if exception_lines_with_frame_info is None:\n            self._show_description()\n            return\n\n        self.text.configure(foreground=get_syntax_options_for_tag(\"stderr\")[\"foreground\"])\n        for line, frame_id, filename, lineno in exception_lines_with_frame_info:\n\n            if frame_id is not None:\n                frame_tag = \"frame_%d\" % frame_id\n\n                def handle_frame_click(event, frame_id=frame_id, filename=filename, lineno=lineno):\n                    get_runner().send_command(InlineCommand(\"get_frame_info\", frame_id=frame_id))\n                    if os.path.exists(filename):\n                        get_workbench().get_editor_notebook().show_file(\n                            filename, lineno, set_focus=False\n                        )\n\n                self.text.tag_bind(frame_tag, \"<1>\", handle_frame_click, True)\n\n                start = max(line.find(\"File\"), 0)\n                end = line.replace(\"\\r\", \"\").find(\"\\n\")\n                if end < 10:\n                    end = len(line)\n\n                self.text.direct_insert(\"end\", line[:start])\n                self.text.direct_insert(\"end\", line[start:end], (\"hyperlink\", frame_tag))\n                self.text.direct_insert(\"end\", line[end:])\n\n            else:\n                self.text.direct_insert(\"end\", line)\n\n        self._prev_exception = exception_lines_with_frame_info", "is_method": true, "class_name": "ExceptionView", "function_description": "Updates the `ExceptionView` to display a Python exception traceback. It renders clickable links for stack frames, allowing navigation to the source code location."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_on_toplevel_response", "line_number": 1153, "body": "def _on_toplevel_response(self, msg):\n        if \"user_exception\" in msg:\n            self.set_exception(msg[\"user_exception\"][\"items\"])\n        else:\n            self.set_exception(None)", "is_method": true, "class_name": "ExceptionView", "function_description": "Updates the `ExceptionView`'s display of user exception details based on an incoming message. It sets the exception information or clears it if no user exception is present."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_hyperlink_enter", "line_number": 1159, "body": "def _hyperlink_enter(self, event):\n        self.text.config(cursor=\"hand2\")", "is_method": true, "class_name": "ExceptionView", "function_description": "Changes the mouse cursor to a hand icon when it enters an interactive text area within the exception view. This provides visual feedback for clickable elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_hyperlink_leave", "line_number": 1162, "body": "def _hyperlink_leave(self, event):\n        self.text.config(cursor=\"\")", "is_method": true, "class_name": "ExceptionView", "function_description": "Resets the text display's cursor to its default state when the mouse leaves a hyperlink region, providing visual feedback in a GUI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "create_edit_command_handler", "line_number": 131, "body": "def create_edit_command_handler(virtual_event_sequence):\n            def handler(event=None):\n                widget = get_workbench().focus_get()\n                if widget:\n                    return widget.event_generate(virtual_event_sequence)\n\n                return None\n\n            return handler", "is_method": true, "class_name": "Debugger", "function_description": "Creates an event handler that dispatches a specified virtual event to the currently focused GUI widget. This enables applying edit commands dynamically within the debugger interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "_create_index", "line_number": 744, "body": "def _create_index(lineno, col_offset):\n            local_lineno = lineno - main_node.lineno + 1\n            if lineno == main_node.lineno:\n                local_col_offset = col_offset - main_node.col_offset\n            else:\n                local_col_offset = col_offset\n\n            return str(local_lineno) + \".\" + str(local_col_offset)", "is_method": true, "class_name": "BaseExpressionBox", "function_description": "This internal helper method generates a unique string index representing a code position relative to a main node. It provides a standardized way to track specific locations within an expression."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/debugger.py", "function": "handle_frame_click", "line_number": 1130, "body": "def handle_frame_click(event, frame_id=frame_id, filename=filename, lineno=lineno):\n                    get_runner().send_command(InlineCommand(\"get_frame_info\", frame_id=frame_id))\n                    if os.path.exists(filename):\n                        get_workbench().get_editor_notebook().show_file(\n                            filename, lineno, set_focus=False\n                        )", "is_method": true, "class_name": "ExceptionView", "function_description": "Responds to user clicks on exception stack frames. It fetches detailed frame information and displays the associated source file and line in the editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "get_ssh_password", "line_number": 293, "body": "def get_ssh_password(conf_group):\n    host = get_workbench().get_option(conf_group + \".host\")\n    user = get_workbench().get_option(conf_group + \".user\")\n    method = get_workbench().get_option(conf_group + \".auth_method\")\n    if method == PUBLIC_KEY_NO_PASS_METHOD:\n        return None\n    elif os.path.exists(get_ssh_password_file_path()):\n        with open(get_ssh_password_file_path()) as fp:\n            return fp.read().strip()\n    else:\n        dlg = PasswordDialog(get_workbench(), host, user, method)\n        ui_utils.show_dialog(dlg)\n        if dlg.password and dlg.save_password:\n            with open(get_ssh_password_file_path(), \"w\") as fp:\n                fp.write(dlg.password)\n\n        if not dlg.save_password or not dlg.password:\n            delete_stored_ssh_password()\n\n        return dlg.password", "is_method": false, "function_description": "Provides the SSH password for a given configuration group, retrieving it from storage, user input, or determining if no password is needed. It manages password persistence."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "load_plugin", "line_number": 315, "body": "def load_plugin() -> None:\n    def select_device():\n        get_workbench().show_options(\"interpreter\")\n\n    get_workbench().add_configuration_page(\n        \"interpreter\", tr(\"Interpreter\"), BackendConfigurationPage, 20\n    )\n    get_workbench().add_command(\n        \"select_interpreter\", \"run\", tr(\"Select interpreter\") + \"...\", select_device, group=1\n    )", "is_method": false, "function_description": "Initializes the application's interpreter management by adding a configuration page and a command to select an interpreter within the workbench UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "_add_text_field", "line_number": 25, "body": "def _add_text_field(\n        self, label_text, variable_name, row, show=None, pady: Union[int, tuple] = 0, width=None\n    ):\n\n        if isinstance(pady, int):\n            pady = (pady, pady)\n\n        entry_label = ttk.Label(self, text=label_text)\n        entry_label.grid(row=row, column=0, sticky=\"w\", pady=pady)\n\n        variable = create_string_var(get_workbench().get_option(variable_name), self._on_change)\n        entry = ttk.Entry(self, textvariable=variable, show=show, width=width)\n        entry.grid(row=row, column=1, sticky=\"we\", pady=pady, padx=ems_to_pixels(1))\n        return variable", "is_method": true, "class_name": "BackendDetailsConfigPage", "function_description": "This internal method adds a labeled text input field to a Tkinter GUI. It links the field's value to a specific backend configuration option, enabling user modification of settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "_add_combobox_field", "line_number": 40, "body": "def _add_combobox_field(\n        self, label_text, variable_name, row, options, pady: Union[int, tuple] = 0, width=None\n    ):\n        if isinstance(pady, int):\n            pady = (pady, pady)\n\n        label = ttk.Label(self, text=label_text)\n        label.grid(row=row, column=0, sticky=\"w\", pady=pady)\n\n        variable = create_string_var(get_workbench().get_option(variable_name), self._on_change)\n        return self.add_combobox(\n            variable, options, row=row, column=1, pady=pady, padx=ems_to_pixels(1), width=width\n        )", "is_method": true, "class_name": "BackendDetailsConfigPage", "function_description": "This method adds a labeled combobox GUI element to the configuration page. It allows users to select values for specific backend configuration options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "should_restart", "line_number": 61, "body": "def should_restart(self):\n        return False", "is_method": true, "class_name": "OnlyTextConfigurationPage", "function_description": "Indicates that configuring this text-only page never requires a system or application restart."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "_backend_changed", "line_number": 114, "body": "def _backend_changed(self, *args):\n        backend_desc = self._combo_variable.get()\n\n        if backend_desc == \"\":\n            if self._current_page is not None:\n                self._current_page.grid_forget()\n            return\n\n        page = self._get_conf_page(backend_desc)\n\n        if page != self._current_page:\n\n            if self._current_page is not None:\n                self._current_page.grid_forget()\n\n            page.grid(sticky=\"nsew\", padx=10, pady=5)\n            self._current_page = page", "is_method": true, "class_name": "BackendConfigurationPage", "function_description": "Updates the displayed configuration page based on a selected backend. It ensures only the relevant backend's configuration is shown, dynamically managing UI visibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "_get_conf_page", "line_number": 132, "body": "def _get_conf_page(self, backend_desc):\n        if backend_desc not in self._conf_pages:\n            cp_constructor = self._backend_specs_by_desc[backend_desc].config_page_constructor\n            if isinstance(cp_constructor, str):\n                self._conf_pages[backend_desc] = OnlyTextConfigurationPage(\n                    self.labelframe, cp_constructor\n                )\n            else:\n                assert issubclass(cp_constructor, ConfigurationPage)\n                self._conf_pages[backend_desc] = cp_constructor(self.labelframe)\n\n        return self._conf_pages[backend_desc]", "is_method": true, "class_name": "BackendConfigurationPage", "function_description": "Retrieves or instantiates a specific configuration page for a given backend. It ensures efficient access by caching pages after creation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "apply", "line_number": 145, "body": "def apply(self):\n        if self._current_page is None:\n            return None\n\n        result = self._current_page.apply()\n\n        if result is False:\n            return False\n\n        backend_desc = self._combo_variable.get()\n        backend_name = self._backend_specs_by_desc[backend_desc].name\n        get_workbench().set_option(\"run.backend_name\", backend_name)\n\n        if getattr(self._combo_variable, \"modified\") or self._current_page.should_restart():\n            self.dialog.backend_restart_required = True\n\n        return None", "is_method": true, "class_name": "BackendConfigurationPage", "function_description": "Applies the selected backend configuration from the page, updating the workbench's run backend setting. It also determines if a backend restart is required due to the applied changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "_on_change", "line_number": 203, "body": "def _on_change(self):\n        self._changed = True", "is_method": true, "class_name": "BaseSshProxyConfigPage", "function_description": "Marks the configuration page as modified, signaling that its state has changed and potentially needs saving."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "apply", "line_number": 206, "body": "def apply(self):\n        if self._changed:\n            get_workbench().set_option(self._conf_group + \".host\", self._host_var.get())\n            get_workbench().set_option(self._conf_group + \".user\", self._user_var.get())\n            get_workbench().set_option(self._conf_group + \".auth_method\", self._method_var.get())\n            get_workbench().set_option(\n                self._conf_group + \".executable\", self._interpreter_var.get()\n            )\n\n            delete_stored_ssh_password()\n\n            # reset cwd setting to default\n            get_workbench().set_option(self._conf_group + \".cwd\", \"\")", "is_method": true, "class_name": "BaseSshProxyConfigPage", "function_description": "Applies and saves the current SSH proxy configuration settings from the page to the application's workbench. It updates host, user, authentication, and clears any stored SSH password."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "should_restart", "line_number": 220, "body": "def should_restart(self):\n        return self._changed", "is_method": true, "class_name": "BaseSshProxyConfigPage", "function_description": "Provides a flag indicating whether changes have occurred that necessitate a restart of the SSH proxy configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "on_ok", "line_number": 282, "body": "def on_ok(self, event=None):\n        self.password = self.entry_widget.get()\n        self.save_password = self.save_variable.get()\n        self.destroy()", "is_method": true, "class_name": "PasswordDialog", "function_description": "This method handles the 'OK' action in a password dialog. It retrieves the entered password and the 'save password' preference, then closes the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "on_cancel", "line_number": 287, "body": "def on_cancel(self, event=None):\n        self.password = None\n        self.save_variable = False\n        self.destroy()", "is_method": true, "class_name": "PasswordDialog", "function_description": "Handles the user's decision to cancel the password dialog. It clears any input, prevents saving, and closes the dialog window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend_config_page.py", "function": "select_device", "line_number": 316, "body": "def select_device():\n        get_workbench().show_options(\"interpreter\")", "is_method": false, "function_description": "This function presents options to the user for selecting an interpreter, enabling configuration of the execution environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_view.py", "function": "load_plugin", "line_number": 37, "body": "def load_plugin() -> None:\n    if get_workbench().get_option(\"general.debug_mode\"):\n        get_workbench().add_view(EventsView, tr(\"Events\"), \"se\")", "is_method": false, "function_description": "Conditionally loads an 'Events' view into the workbench. It provides event monitoring capabilities when the application is in debug mode."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_view.py", "function": "_log_event", "line_number": 21, "body": "def _log_event(self, event):\n        self.text.insert(\"end\", event.sequence + \"\\n\")\n        for name in dir(event):\n            if name not in [\"sequence\", \"setdefault\", \"update\"] and not name.startswith(\"_\"):\n                self.text.insert(\n                    \"end\", \"    \" + name + \": \" + repr(getattr(event, name))[:100] + \"\\n\"\n                )\n\n        if isinstance(event, DebuggerResponse):\n            frame = event.stack[-1]\n            self.text.insert(\"end\", \"    \" + \"event\" + \": \" + frame.event + \"\\n\")\n            self.text.insert(\"end\", \"    \" + \"focus\" + \": \" + str(frame.focus) + \"\\n\")\n\n        self.text.see(\"end\")", "is_method": true, "class_name": "EventsView", "function_description": "Displays detailed information for a given event, including its attributes and specific debugger response data, within the view's text log. This provides a clear, structured view of events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/remove_old_data_dir.py", "function": "load_plugin", "line_number": 7, "body": "def load_plugin():\n    old_data_dir = os.path.join(os.path.expanduser(\"~\"), \".thonny\")\n    if os.path.exists(old_data_dir):\n\n        def doit():\n            import shutil\n\n            if not os.path.exists(old_data_dir):\n                showinfo(\n                    \"Already deleted\", \"Looks like it's already deleted\", master=get_workbench()\n                )\n                return\n\n            answer = askyesno(\n                \"Delete old data directory?\",\n                \"Thonny versions before 3.0 (and first 3.0 betas) used to keep \"\n                + \"configuration, logs and such in '%s'\" % old_data_dir\n                + \". \"\n                + \"Since 3.0 this data is kept in a new location: '%s'.\\n\\n\" % THONNY_USER_DIR\n                + \"If you don't intend to use older Thonny versions anymore, \"\n                + \"you probably want to delete the old directory and reclaim disk space.\\n\\n\"\n                + \"Do you want me to delete this directory now?\",\n                master=get_workbench(),\n            )\n            if answer:\n                shutil.rmtree(old_data_dir, True)\n                shutil.rmtree(old_data_dir, True)  # first one may keep empty directory\n                showinfo(\"Done!\", \"Done!\", master=get_workbench())\n\n        get_workbench().add_command(\n            \"delolddatadir\", \"tools\", \"Clean up Thonny 2.1 data folder ...\", doit, group=110\n        )", "is_method": false, "function_description": "Registers a workbench command that enables users to clean up and delete an old, obsolete Thonny data directory, reclaiming disk space."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/remove_old_data_dir.py", "function": "doit", "line_number": 11, "body": "def doit():\n            import shutil\n\n            if not os.path.exists(old_data_dir):\n                showinfo(\n                    \"Already deleted\", \"Looks like it's already deleted\", master=get_workbench()\n                )\n                return\n\n            answer = askyesno(\n                \"Delete old data directory?\",\n                \"Thonny versions before 3.0 (and first 3.0 betas) used to keep \"\n                + \"configuration, logs and such in '%s'\" % old_data_dir\n                + \". \"\n                + \"Since 3.0 this data is kept in a new location: '%s'.\\n\\n\" % THONNY_USER_DIR\n                + \"If you don't intend to use older Thonny versions anymore, \"\n                + \"you probably want to delete the old directory and reclaim disk space.\\n\\n\"\n                + \"Do you want me to delete this directory now?\",\n                master=get_workbench(),\n            )\n            if answer:\n                shutil.rmtree(old_data_dir, True)\n                shutil.rmtree(old_data_dir, True)  # first one may keep empty directory\n                showinfo(\"Done!\", \"Done!\", master=get_workbench())", "is_method": false, "function_description": "Offers a utility to remove obsolete Thonny user data directories, reclaiming disk space. It prompts the user for confirmation before permanent deletion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/misc_analyzers.py", "function": "load_plugin", "line_number": 297, "body": "def load_plugin():\n    add_program_analyzer(ProgramNamingAnalyzer)", "is_method": false, "function_description": "This function loads a plugin that registers the `ProgramNamingAnalyzer`. It integrates a program naming analysis capability into the system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/misc_analyzers.py", "function": "start_analysis", "line_number": 224, "body": "def start_analysis(self, main_file_path, imported_file_paths):\n        self.completion_handler(self, list(self._get_warnings(main_file_path)))", "is_method": true, "class_name": "ProgramNamingAnalyzer", "function_description": "Initiates the analysis of a main program file to retrieve warnings. It then dispatches these warnings to a completion handler for further processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/misc_analyzers.py", "function": "_get_warnings", "line_number": 227, "body": "def _get_warnings(self, main_file_path):\n        from thonny import rst_utils\n\n        # TODO: current dir may be different\n        main_file_dir = os.path.dirname(main_file_path)\n        if not os.path.isdir(main_file_dir):\n            return\n\n        library_modules = known_stdlib_modules | self._get_3rd_party_modules()\n\n        for item in os.listdir(main_file_dir):\n            full_path = os.path.join(main_file_dir, item)\n            if item.endswith(\".py\") and item[:-3] in library_modules:\n\n                if is_same_path(full_path, main_file_path):\n                    prelude = \"Your program file is named '%s'.\" % item\n                    rename_hint = \" (*File \u2192 Rename\u2026* )\"\n                else:\n                    prelude = (\n                        \"Your working directory `%s <%s>`__ contains a file named '%s'.\\n\\n\"\n                        % (rst_utils.escape(main_file_dir), rst_utils.escape(main_file_dir), item)\n                    )\n                    rename_hint = \"\"\n\n                yield {\n                    \"filename\": full_path,\n                    \"lineno\": 0,\n                    \"symbol\": \"file-shadows-library-module\",\n                    \"msg\": \"Possibly bad file name\",\n                    \"explanation_rst\": prelude\n                    + \"\\n\\n\"\n                    + \"When you try to import library module ``%s``, your file will be imported instead.\\n\\n\"\n                    % item[:-3]\n                    + \"Rename your '%s'%s to make the library module visible again.\"\n                    % (item, rename_hint),\n                    \"group\": \"warnings\",\n                    \"relevance\": 5,\n                }", "is_method": true, "class_name": "ProgramNamingAnalyzer", "function_description": "This method identifies Python files in the current directory that have names conflicting with standard or third-party library modules. It generates warnings to alert users about potential import shadowing issues, suggesting file renames."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/misc_analyzers.py", "function": "_get_3rd_party_modules", "line_number": 266, "body": "def _get_3rd_party_modules(self):\n        proxy = get_runner().get_backend_proxy()\n        from thonny.plugins.cpython import CPythonProxy\n\n        if not isinstance(proxy, CPythonProxy):\n            return []\n\n        try:\n            sys_path = proxy.get_sys_path()\n        except Exception:\n            logging.exception(\"Can't get sys path from proxy\")\n            return []\n\n        module_names = set()\n        for item in sys_path:\n            if os.path.isdir(item) and (\"site-packages\" in item or \"dist-packages\" in item):\n                module_names.update(self._get_module_names(item))\n                for name in os.listdir(item):\n                    if \"-\" not in name:\n                        module_names.add(name.replace(\".py\", \"\"))\n\n        return module_names", "is_method": true, "class_name": "ProgramNamingAnalyzer", "function_description": "This internal method identifies and retrieves names of third-party Python modules installed in standard locations like site-packages. It supports the analysis of program names by distinguishing external libraries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/misc_analyzers.py", "function": "_get_module_names", "line_number": 289, "body": "def _get_module_names(self, dir_path):\n        result = set()\n        for name in os.listdir(dir_path):\n            if \"-\" not in name:\n                result.add(name.replace(\".py\", \"\"))\n        return result", "is_method": true, "class_name": "ProgramNamingAnalyzer", "function_description": "Identifies and extracts a set of potential Python module names from a directory. It filters out names containing hyphens and removes the '.py' file extension, aiding in program naming analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/about.py", "function": "load_plugin", "line_number": 139, "body": "def load_plugin() -> None:\n    def open_about(*args):\n        ui_utils.show_dialog(AboutDialog(get_workbench()))\n\n    def open_url(url):\n        import webbrowser\n\n        # webbrowser.open returns bool, but add_command expects None\n        webbrowser.open(url)\n\n    get_workbench().add_command(\n        \"changelog\",\n        \"help\",\n        tr(\"Version history\"),\n        lambda: open_url(\"https://github.com/thonny/thonny/blob/master/CHANGELOG.rst\"),\n        group=60,\n    )\n    get_workbench().add_command(\n        \"issues\",\n        \"help\",\n        tr(\"Report problems\"),\n        lambda: open_url(\"https://github.com/thonny/thonny/issues/new\"),\n        group=60,\n    )\n    get_workbench().add_command(\"about\", \"help\", tr(\"About Thonny\"), open_about, group=61)\n\n    # For Mac\n    get_workbench().createcommand(\"tkAboutDialog\", open_about)", "is_method": false, "function_description": "Configures the application's help menu by adding commands for accessing version history, reporting issues, and viewing program information. It provides users with direct access to support and documentation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/about.py", "function": "_ok", "line_number": 127, "body": "def _ok(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "AboutDialog", "function_description": "Closes the About Dialog window. It provides the capability to dismiss the dialog, typically triggered by an \"OK\" button."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/about.py", "function": "get_os_word_size_guess", "line_number": 130, "body": "def get_os_word_size_guess(self):\n        if \"32\" in platform.machine() and \"64\" not in platform.machine():\n            return \"(32-bit)\"\n        elif \"64\" in platform.machine() and \"32\" not in platform.machine():\n            return \"(64-bit)\"\n        else:\n            return \"\"", "is_method": true, "class_name": "AboutDialog", "function_description": "Determines and returns a guessed string representation of the operating system's word size (32-bit or 64-bit). Provides system architecture information for display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/about.py", "function": "open_about", "line_number": 140, "body": "def open_about(*args):\n        ui_utils.show_dialog(AboutDialog(get_workbench()))", "is_method": false, "function_description": "Displays an informational \"About\" dialog box to the user, providing application details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/about.py", "function": "open_url", "line_number": 143, "body": "def open_url(url):\n        import webbrowser\n\n        # webbrowser.open returns bool, but add_command expects None\n        webbrowser.open(url)", "is_method": false, "function_description": "This function opens the specified URL in the user's default web browser. It provides a simple way to launch web pages programmatically."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "show_dialog", "line_number": 80, "body": "def show_dialog():\n    dlg = ShellMacroDialog(get_workbench())\n    ui_utils.show_dialog(dlg)", "is_method": false, "function_description": "This function displays a Shell Macro Dialog to the user. It provides a user interface for interacting with shell macros."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "execute_macro", "line_number": 85, "body": "def execute_macro():\n    if get_runner().is_waiting_toplevel_command():\n        source = get_workbench().get_option(\"run.shell_macro_main\")\n        if source is not None:\n            shell = get_workbench().show_view(\"ShellView\")\n            shell.submit_python_code(source.strip() + \"\\n\")", "is_method": false, "function_description": "Provides a service to execute a pre-defined Python macro. It retrieves the macro's code from workbench options and submits it to the shell for immediate execution when the system is awaiting a command."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_load_plugin", "line_number": 93, "body": "def _load_plugin():\n    get_workbench().set_default(\"run.shell_macro_main\", None)\n    get_workbench().add_command(\n        \"configure_shell_macro\", \"run\", \"Configure shell macro...\", show_dialog\n    )\n    get_workbench().add_command(\n        \"execute_shell_macro\", \"run\", \"Execute shell macro\", execute_macro, default_sequence=\"<F9>\"\n    )", "is_method": false, "function_description": "Registers commands to configure and execute shell macros within the workbench environment. It provides users with direct access to these functionalities via UI commands and shortcuts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_create_widgets", "line_number": 26, "body": "def _create_widgets(self):\n\n        bg = \"#ffff99\"\n        banner_frame = tk.Frame(self, background=bg)\n        banner_frame.grid(row=0, column=0, sticky=\"nsew\")\n        banner_frame.rowconfigure(0, weight=1)\n        banner_frame.columnconfigure(0, weight=1)\n        banner_text = tk.Label(\n            banner_frame,\n            text=\"These\\nare\\ninstructions asdfa afs fa sfasdf\",\n            background=bg,\n            justify=\"left\",\n        )\n        banner_text.grid(column=0, row=0, pady=10, padx=10, sticky=\"nsew\")\n\n        main_frame = ttk.Frame(self)\n        main_frame.grid(row=1, column=0, sticky=tk.NSEW, padx=15, pady=15)\n        self.rowconfigure(0, weight=1)\n        self.columnconfigure(0, weight=1)\n\n        self.main_command_text = CodeView(main_frame, height=5)\n        self.main_command_text.grid(column=0, row=1, sticky=\"nsew\")\n        # main_command_text[\"relief\"] = \"groove\"\n\n        main_frame.rowconfigure(1, weight=1)\n        main_frame.columnconfigure(0, weight=1)\n\n        button_frame = ttk.Frame(main_frame)\n        button_frame.grid(row=2, column=0, sticky=\"nsew\")\n\n        run_button = ttk.Button(button_frame, text=\"Save and execute\", command=self._save_exec)\n        run_button.grid(row=0, column=1, sticky=\"nsew\")\n        ok_button = ttk.Button(button_frame, text=\"Save\", command=self._save)\n        ok_button.grid(row=0, column=2, sticky=\"nsew\")\n        cancel_button = ttk.Button(button_frame, text=\"Cancel\", command=self._cancel)\n        cancel_button.grid(row=0, column=3, sticky=\"nsew\")\n        button_frame.columnconfigure(0, weight=1)", "is_method": true, "class_name": "ShellMacroDialog", "function_description": "This internal method constructs and arranges all the graphical user interface elements for the `ShellMacroDialog`. It sets up the layout for the banner, command input area, and action buttons."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_on_close", "line_number": 64, "body": "def _on_close(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "ShellMacroDialog", "function_description": "Manages the closure of the ShellMacroDialog window. It destroys the dialog instance, typically triggered by a close event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_save_exec", "line_number": 67, "body": "def _save_exec(self, event=None):\n        self._save(event)\n        execute_macro()", "is_method": true, "class_name": "ShellMacroDialog", "function_description": "Saves the current macro's configuration from the dialog and then immediately executes the macro."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_save", "line_number": 71, "body": "def _save(self, event=None):\n        source = self.main_command_text.text.get(\"1.0\", \"end\")\n        get_workbench().set_option(\"run.shell_macro_main\", repr(source))\n        self.destroy()", "is_method": true, "class_name": "ShellMacroDialog", "function_description": "Saves the user-defined main shell command from the dialog to the workbench options. It then closes the dialog after saving the macro content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_macro.py", "function": "_cancel", "line_number": 76, "body": "def _cancel(self, event=None):\n        self.destroy()", "is_method": true, "class_name": "ShellMacroDialog", "function_description": "Closes the dialog window, typically in response to a user's cancel action."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "load_plugin", "line_number": 357, "body": "def load_plugin() -> None:\n    def open_replayer():\n        win = ReplayWindow(get_workbench())\n        ui_utils.show_dialog(win)\n\n    get_workbench().set_default(\"tools.replayer_last_browser_folder\", None)\n    if get_workbench().get_ui_mode() == \"expert\":\n        get_workbench().add_command(\n            \"open_replayer\", \"tools\", tr(\"Open replayer...\"), open_replayer, group=110\n        )", "is_method": false, "function_description": "Registers and enables a \"Replayer\" tool within the application's workbench. It provides expert users with a command to open the Replayer window for specific analysis or playback tasks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "on_double_click", "line_number": 63, "body": "def on_double_click(self, event):\n        # self.save_current_folder()\n        path = self.get_selected_path()\n        if path:\n            kind = self.get_selected_kind()\n            if kind == \"dir\":\n                self.focus_into(path)\n            else:\n                self.log_frame.load_log(path)\n\n        return \"break\"", "is_method": true, "class_name": "ReplayerFileBrowser", "function_description": "Manages double-click events in the file browser, allowing navigation into selected directories or loading chosen log files for display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "load_log", "line_number": 105, "body": "def load_log(self, filename):\n        self._clear_tree()\n        self.details_frame._clear_tree()\n        self.all_events = []\n        self.last_event_index = -1\n        self.loading = True\n        self.editor_notebook.reset()\n        self.shell.reset()\n\n        import json\n\n        with open(filename, encoding=\"UTF-8\") as f:\n            events = json.load(f)\n            last_event_time = None\n            for event in events:\n                node_id = self.tree.insert(\"\", \"end\")\n                self.tree.set(node_id, \"desc\", event[\"sequence\"])\n                if len(event[\"time\"]) == 19:\n                    # 0 fraction may have been skipped\n                    event[\"time\"] += \".0\"\n                event_time = datetime.strptime(event[\"time\"], \"%Y-%m-%dT%H:%M:%S.%f\")\n                if last_event_time:\n                    delta = event_time - last_event_time\n                    pause = delta.seconds\n                else:\n                    pause = 0\n                self.tree.set(node_id, \"pause\", str(pause if pause else \"\"))\n                self.all_events.append(event)\n\n                last_event_time = event_time\n\n        self.loading = False", "is_method": true, "class_name": "LogFrame", "function_description": "Loads event data from a specified JSON file, clearing existing entries. It populates the log display and internal event list, calculating time pauses between events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "replay_event", "line_number": 138, "body": "def replay_event(self, event):\n        \"this should be called with events in correct order\"\n        # print(\"log replay\", event)\n\n        if \"text_widget_id\" in event:\n            if (\n                event.get(\"text_widget_context\", None) == \"shell\"\n                or event.get(\"text_widget_class\") == \"ShellText\"\n            ):\n                self.shell.replay_event(event)\n            else:\n                self.editor_notebook.replay_event(event)", "is_method": true, "class_name": "LogFrame", "function_description": "Replays a historical UI event by dispatching it to the correct internal component (shell or editor notebook). This reconstructs the application's state from a log."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "reset", "line_number": 151, "body": "def reset(self):\n        self.shell.reset()\n        self.editor_notebook.reset()\n        self.last_event_index = -1", "is_method": true, "class_name": "LogFrame", "function_description": "This method resets the LogFrame instance and its core components, such as the shell and editor notebook, to their default initial state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "on_select", "line_number": 156, "body": "def on_select(self, event):\n        # parameter \"event\" is here tkinter event\n        if self.loading:\n            return\n        iid = self.tree.focus()\n        if iid != \"\":\n            self.select_event(self.tree.index(iid))", "is_method": true, "class_name": "LogFrame", "function_description": "Handles a treeview selection event in the UI, delegating the selected item's index to `select_event` for processing. It ignores events when the frame is loading."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "select_event", "line_number": 164, "body": "def select_event(self, event_index):\n        event = self.all_events[event_index]\n        self.details_frame.load_event(event)\n\n        # here event means logged event\n        if event_index > self.last_event_index:\n            # replay all events between last replayed event up to and including this event\n            while self.last_event_index < event_index:\n                self.replay_event(self.all_events[self.last_event_index + 1])\n                self.last_event_index += 1\n\n        elif event_index < self.last_event_index:\n            # Undo by resetting and replaying again\n            self.reset()\n            self.select_event(event_index)", "is_method": true, "class_name": "LogFrame", "function_description": "Manages the display and state of a sequence of log events. It selects an event by index, loading its details and replaying prior events to synchronize the system state up to that point."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "load_event", "line_number": 188, "body": "def load_event(self, event):\n        self._clear_tree()\n        for name in self.order_keys(event):\n            node_id = self.tree.insert(\"\", \"end\")\n            self.tree.set(node_id, \"attribute\", name)\n            self.tree.set(node_id, \"value\", event[name])", "is_method": true, "class_name": "EventDetailsFrame", "function_description": "Populates the EventDetailsFrame's display with attributes and values from an event object. It provides a structured view of event details within the UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "order_keys", "line_number": 195, "body": "def order_keys(self, event):\n        return event.keys()", "is_method": true, "class_name": "EventDetailsFrame", "function_description": "Retrieves the keys (attribute names) from a given event object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "replay_event", "line_number": 240, "body": "def replay_event(self, event):\n        if event[\"sequence\"] in [\"TextInsert\", \"TextDelete\"]:\n            if event[\"sequence\"] == \"TextInsert\":\n                self.code_view.text.insert(\n                    event[\"index\"], event[\"text\"], ast.literal_eval(event[\"tags\"])\n                )\n\n            elif event[\"sequence\"] == \"TextDelete\":\n                if event[\"index2\"] and event[\"index2\"] != \"None\":\n                    self.code_view.text.delete(event[\"index1\"], event[\"index2\"])\n                else:\n                    self.code_view.text.delete(event[\"index1\"])\n\n            self.see_event(event)", "is_method": true, "class_name": "ReplayerEditor", "function_description": "This method facilitates replaying text editing events (insertions or deletions) on a code view. It applies historical changes to synchronize the editor's content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "see_event", "line_number": 255, "body": "def see_event(self, event):\n        for key in [\"index\", \"index1\", \"index2\"]:\n            if key in event and event[key] and event[key] != \"None\":\n                self.code_view.text.see(event[key])", "is_method": true, "class_name": "ReplayerEditor", "function_description": "For a ReplayerEditor, this method scrolls the code view to a specific text index specified within an event. It ensures the relevant code snippet is visible during event replay."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "reset", "line_number": 260, "body": "def reset(self):\n        self.code_view.text.delete(\"1.0\", \"end\")", "is_method": true, "class_name": "ReplayerEditor", "function_description": "Resets the editor's code view by deleting all text content. This provides a clean slate for new input or display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "set_colorer", "line_number": 269, "body": "def set_colorer(self):\n        self.colorer = SyntaxColorer(self.code_view.text)", "is_method": true, "class_name": "ReplayerEditorProper", "function_description": "Configures the editor by initializing a syntax colorer for its code view. This enables syntax highlighting for the displayed text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "replay_event", "line_number": 272, "body": "def replay_event(self, event):\n        ReplayerEditor.replay_event(self, event)", "is_method": true, "class_name": "ReplayerEditorProper", "function_description": "Facilitates event replaying for `ReplayerEditorProper` instances by directly invoking the base class's `replay_event` method."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "reset", "line_number": 277, "body": "def reset(self):\n        ReplayerEditor.reset(self)\n        self.set_colorer()", "is_method": true, "class_name": "ReplayerEditorProper", "function_description": "Resets the editor to its initial state by calling the base class's reset and re-configuring its display colorer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "clear", "line_number": 287, "body": "def clear(self):\n\n        for child in self.winfo_children():\n            child.destroy()\n\n        self._editors_by_text_widget_id = {}", "is_method": true, "class_name": "ReplayerEditorNotebook", "function_description": "Removes all currently displayed editor widgets and associated internal state from the notebook, preparing it for new content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "get_editor_by_text_widget_id", "line_number": 294, "body": "def get_editor_by_text_widget_id(self, text_widget_id):\n        if text_widget_id not in self._editors_by_text_widget_id:\n            editor = ReplayerEditorProper(self)\n            self.add(editor, text=\"<untitled>\")\n            self._editors_by_text_widget_id[text_widget_id] = editor\n\n        return self._editors_by_text_widget_id[text_widget_id]", "is_method": true, "class_name": "ReplayerEditorNotebook", "function_description": "Manages and provides access to editor instances by text widget ID. This method ensures an editor exists, creating one if necessary, for use within the notebook."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "replay_event", "line_number": 302, "body": "def replay_event(self, event):\n        if \"text_widget_id\" in event:\n            editor = self.get_editor_by_text_widget_id(event[\"text_widget_id\"])\n            # print(event.editor_id, id(editor), event)\n            self.select(editor)\n            editor.replay_event(event)\n\n            if \"filename\" in event:\n                self.tab(editor, text=os.path.basename(event[\"filename\"]))", "is_method": true, "class_name": "ReplayerEditorNotebook", "function_description": "Replays a recorded event on the corresponding text editor within the notebook. It activates the target editor and updates its display, such as the tab name, if event data specifies."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "reset", "line_number": 312, "body": "def reset(self):\n        for editor in self.winfo_children():\n            self.forget(editor)\n            editor.destroy()\n\n        self._editors_by_text_widget_id = {}", "is_method": true, "class_name": "ReplayerEditorNotebook", "function_description": "Clears all active editor widgets and their internal mapping from the notebook. This prepares the ReplayerEditorNotebook for a fresh set of content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/replayer.py", "function": "open_replayer", "line_number": 358, "body": "def open_replayer():\n        win = ReplayWindow(get_workbench())\n        ui_utils.show_dialog(win)", "is_method": false, "function_description": "Displays a new ReplayWindow, providing users with a graphical interface to interact with replay functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "load_plugin", "line_number": 398, "body": "def load_plugin() -> None:\n    def cmd_open_find_dialog():\n        if _active_find_dialog is not None:\n            _active_find_dialog.focus_set()\n        else:\n            editor = get_workbench().get_editor_notebook().get_current_editor()\n            if editor:\n                FindDialog(editor._code_view)\n\n    def find_f3(event):\n        if _active_find_dialog is None:\n            cmd_open_find_dialog()\n        else:\n            _active_find_dialog._perform_find(event)\n\n    get_workbench().add_command(\n        \"OpenFindDialog\",\n        \"edit\",\n        tr(\"Find & Replace\"),\n        cmd_open_find_dialog,\n        default_sequence=select_sequence(\"<Control-f>\", \"<Command-f>\"),\n        extra_sequences=[\"<Control-Greek_phi>\"],\n    )\n\n    get_workbench().bind(\"<F3>\", find_f3, True)", "is_method": false, "function_description": "This plugin function integrates \"Find & Replace\" functionality into the application. It registers commands to open the find dialog and binds hotkeys for navigating search results."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "focus_set", "line_number": 163, "body": "def focus_set(self):\n        self.find_entry.focus_set()\n        self.find_entry.selection_range(0, tk.END)", "is_method": true, "class_name": "FindDialog", "function_description": "Prepares the find input field for immediate user interaction by setting keyboard focus and selecting its entire current content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_update_button_statuses", "line_number": 168, "body": "def _update_button_statuses(self, *args):\n        find_text = self.find_entry_var.get()\n        if len(find_text) == 0:\n            self.find_button.config(state=\"disabled\")\n            self.replace_and_find_button.config(state=\"disabled\")\n            self.replace_all_button.config(state=\"disabled\")\n        else:\n            self.find_button.config(state=\"normal\")\n            self.replace_all_button.config(state=\"normal\")\n            if self.active_found_tag is not None:\n                self.replace_and_find_button.config(state=\"normal\")", "is_method": true, "class_name": "FindDialog", "function_description": "Adjusts the enabled state of find and replace buttons in the dialog. Buttons are enabled only when find text is present, and \"replace and find\" requires an active match."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_is_search_case_sensitive", "line_number": 181, "body": "def _is_search_case_sensitive(self):\n        return self.case_var.get() != 0", "is_method": true, "class_name": "FindDialog", "function_description": "Reports whether the text search initiated from this dialog should be case-sensitive based on user settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_repeats_last_search", "line_number": 185, "body": "def _repeats_last_search(self, tofind):\n        return (\n            tofind == FindDialog.last_searched_word\n            and self.last_processed_indexes is not None\n            and self.last_search_case == self._is_search_case_sensitive()\n        )", "is_method": true, "class_name": "FindDialog", "function_description": "Checks if the current find operation duplicates the last search, based on the term, prior results, and case sensitivity. This helps optimize repeated searches."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_perform_replace", "line_number": 193, "body": "def _perform_replace(self):\n\n        # nothing is currently in found status\n        if self.active_found_tag == None:\n            return\n\n        # get the found word bounds\n        del_start = self.active_found_tag[0]\n        del_end = self.active_found_tag[1]\n\n        # erase all tags - these would not be correct anyway after new word is inserted\n        self._remove_all_tags()\n        toreplace = self.replace_entry.get()  # get the text to replace\n\n        # delete the found word\n        self.codeview.text.delete(del_start, del_end)\n        # insert the new word\n        self.codeview.text.insert(del_start, toreplace)\n        # mark the inserted word boundaries\n        self.last_processed_indexes = (\n            del_start,\n            self.codeview.text.index(\"%s+%dc\" % (del_start, len(toreplace))),\n        )\n\n        get_workbench().event_generate(\n            \"Replace\",\n            widget=self.codeview.text,\n            old_text=self.codeview.text.get(del_start, del_end),\n            new_text=toreplace,\n        )", "is_method": true, "class_name": "FindDialog", "function_description": "Replaces the currently highlighted text occurrence with a user-specified string within the text editor. It updates the display and emits a 'Replace' event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_perform_replace_and_find", "line_number": 225, "body": "def _perform_replace_and_find(self):\n        if self.active_found_tag == None:\n            return\n        self._perform_replace()\n        self._perform_find()", "is_method": true, "class_name": "FindDialog", "function_description": "Performs a \"replace and find next\" operation within the dialog, replacing the current match and then searching for the next occurrence."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_perform_replace_all", "line_number": 232, "body": "def _perform_replace_all(self):\n\n        tofind = self.find_entry.get()\n        if len(tofind) == 0:\n            self.infotext_label_var.set(tr(\"Enter string to be replaced.\"))\n            return\n\n        toreplace = self.replace_entry.get()\n\n        self._remove_all_tags()\n\n        currentpos = 1.0\n        end = self.codeview.text.index(\"end\")\n\n        while True:\n            currentpos = self.codeview.text.search(\n                tofind, currentpos, end, nocase=not self._is_search_case_sensitive()\n            )\n            if currentpos == \"\":\n                break\n\n            endpos = self.codeview.text.index(\"%s+%dc\" % (currentpos, len(tofind)))\n\n            self.codeview.text.delete(currentpos, endpos)\n\n            if toreplace != \"\":\n                self.codeview.text.insert(currentpos, toreplace)\n\n            currentpos = self.codeview.text.index(\"%s+%dc\" % (currentpos, len(toreplace)))\n\n        get_workbench().event_generate(\n            \"ReplaceAll\", widget=self.codeview.text, old_text=tofind, new_text=toreplace\n        )", "is_method": true, "class_name": "FindDialog", "function_description": "Executes a 'replace all' operation within the code editor. It finds and replaces all occurrences of a specified string with another, optionally case-insensitively."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_perform_find", "line_number": 266, "body": "def _perform_find(self, event=None):\n        self.infotext_label_var.set(\"\")  # reset the info label text\n        tofind = self.find_entry.get()  # get the text to find\n        if len(tofind) == 0:  # in the case of empty string, cancel\n            return  # TODO - set warning text to info label?\n\n        search_backwards = (\n            self.direction_var.get() == 1\n        )  # True - search backwards ('up'), False - forwards ('down')\n\n        if self._repeats_last_search(\n            tofind\n        ):  # continuing previous search, find the next occurrence\n            if search_backwards:\n                search_start_index = self.last_processed_indexes[0]\n            else:\n                search_start_index = self.last_processed_indexes[1]\n\n            if self.active_found_tag is not None:\n                self.codeview.text.tag_remove(\n                    \"current_found\", self.active_found_tag[0], self.active_found_tag[1]\n                )  # remove the active tag from the previously found string\n                self.passive_found_tags.add(\n                    (self.active_found_tag[0], self.active_found_tag[1])\n                )  # ..and set it to passive instead\n                self.codeview.text.tag_add(\n                    \"found\", self.active_found_tag[0], self.active_found_tag[1]\n                )\n\n        else:  # start a new search, start from the current insert line position\n            if self.active_found_tag is not None:\n                self.codeview.text.tag_remove(\n                    \"current_found\", self.active_found_tag[0], self.active_found_tag[1]\n                )  # remove the previous active tag if it was present\n            for tag in self.passive_found_tags:\n                self.codeview.text.tag_remove(\n                    \"found\", tag[0], tag[1]\n                )  # and remove all the previous passive tags that were present\n            search_start_index = self.codeview.text.index(\n                \"insert\"\n            )  # start searching from the current insert position\n            self._find_and_tag_all(tofind)  # set the passive tag to ALL found occurrences\n            FindDialog.last_searched_word = tofind  # set the data about last search\n            self.last_search_case = self._is_search_case_sensitive()\n\n        wordstart = self.codeview.text.search(\n            tofind,\n            search_start_index,\n            backwards=search_backwards,\n            forwards=not search_backwards,\n            nocase=not self._is_search_case_sensitive(),\n        )  # performs the search and sets the start index of the found string\n        if len(wordstart) == 0:\n            self.infotext_label_var.set(\n                tr(\"The specified text was not found!\")\n            )  # TODO - better text, also move it to the texts resources list\n            self.replace_and_find_button.config(state=\"disabled\")\n            self.replace_button.config(state=\"disabled\")\n            return\n\n        self.last_processed_indexes = (\n            wordstart,\n            self.codeview.text.index(\"%s+1c\" % wordstart),\n        )  # sets the data about last search\n        self.codeview.text.see(wordstart)  # moves the view to the found index\n        wordend = self.codeview.text.index(\n            \"%s+%dc\" % (wordstart, len(tofind))\n        )  # calculates the end index of the found string\n        self.codeview.text.tag_add(\n            \"current_found\", wordstart, wordend\n        )  # tags the found word as active\n        self.active_found_tag = (wordstart, wordend)\n        self.replace_and_find_button.config(state=\"normal\")\n        self.replace_button.config(state=\"normal\")\n\n        get_workbench().event_generate(\n            \"Find\",\n            widget=self.codeview.text,\n            text=tofind,\n            backwards=search_backwards,\n            case_sensitive=self._is_search_case_sensitive(),\n        )", "is_method": true, "class_name": "FindDialog", "function_description": "This method executes a text search within the code editor. It finds and highlights the next (or previous) occurrence of a string, managing search direction and repeated searches, and updating the UI accordingly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_ok", "line_number": 349, "body": "def _ok(self, event=None):\n        \"\"\"Called when the window is closed. responsible for handling all cleanup.\"\"\"\n        self._remove_all_tags()\n        self.destroy()\n\n        global _active_find_dialog\n        _active_find_dialog = None", "is_method": true, "class_name": "FindDialog", "function_description": "Handles the graceful closure of the FindDialog window. It performs necessary cleanup tasks and deactivates the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_remove_all_tags", "line_number": 358, "body": "def _remove_all_tags(self):\n        for tag in self.passive_found_tags:\n            self.codeview.text.tag_remove(\"found\", tag[0], tag[1])  # removes the passive tags\n\n        if self.active_found_tag is not None:\n            self.codeview.text.tag_remove(\n                \"current_found\", self.active_found_tag[0], self.active_found_tag[1]\n            )  # removes the currently active tag\n\n        self.active_found_tag = None\n        self.replace_and_find_button.config(state=\"disabled\")\n        self.replace_button.config(state=\"disabled\")", "is_method": true, "class_name": "FindDialog", "function_description": "Removes all visual highlights for found text and resets the active search result within the find dialog. It also disables associated replace buttons."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "_find_and_tag_all", "line_number": 372, "body": "def _find_and_tag_all(self, tofind, force=False):\n        # TODO - to be improved so only whole words are matched - surrounded by whitespace, parentheses, brackets, colons, semicolons, points, plus, minus\n\n        if (\n            self._repeats_last_search(tofind) and not force\n        ):  # nothing to do, all passive tags already set\n            return\n\n        currentpos = 1.0\n        end = self.codeview.text.index(\"end\")\n\n        # searches and tags until the end of codeview\n        while True:\n            currentpos = self.codeview.text.search(\n                tofind, currentpos, end, nocase=not self._is_search_case_sensitive()\n            )\n            if currentpos == \"\":\n                break\n\n            endpos = self.codeview.text.index(\"%s+%dc\" % (currentpos, len(tofind)))\n            self.passive_found_tags.add((currentpos, endpos))\n            self.codeview.text.tag_add(\"found\", currentpos, endpos)\n\n            currentpos = self.codeview.text.index(\"%s+1c\" % currentpos)", "is_method": true, "class_name": "FindDialog", "function_description": "Locates and visually highlights all instances of a specified string within the text display of the dialog, marking each occurrence for user visibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "cmd_open_find_dialog", "line_number": 399, "body": "def cmd_open_find_dialog():\n        if _active_find_dialog is not None:\n            _active_find_dialog.focus_set()\n        else:\n            editor = get_workbench().get_editor_notebook().get_current_editor()\n            if editor:\n                FindDialog(editor._code_view)", "is_method": false, "function_description": "Opens or activates a find dialog for the current editor. It brings an existing dialog to focus or creates a new one if none is active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/find_replace.py", "function": "find_f3", "line_number": 407, "body": "def find_f3(event):\n        if _active_find_dialog is None:\n            cmd_open_find_dialog()\n        else:\n            _active_find_dialog._perform_find(event)", "is_method": false, "function_description": "Manages text search operations by either opening a new find dialog or performing a find action using an already active one."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "create_bitmap_file", "line_number": 15, "body": "def create_bitmap_file(width, height, predicate, name):\n\n    cache_dir = os.path.join(thonny.THONNY_USER_DIR, \"image_cache\")\n    name = \"%s_%d_%d.xbm\" % (name, width, height)\n    filename = os.path.join(cache_dir, name)\n\n    # if os.path.exists(filename):\n    #    return filename\n\n    hex_lines = []\n\n    if width % 8 == 0:\n        row_size = width\n    else:\n        # need to pad row size so that it is multiple of 8\n        row_size = width + 8 - (width % 8)\n\n    for y in range(height):\n        byte_hexes = []\n        for byte_index in range(row_size // 8):\n            byte = 0\n            for bit_index in range(7, -1, -1):\n                x = byte_index * 8 + bit_index\n\n                byte <<= 1\n                if predicate(x, y):\n                    byte |= 1\n\n            byte_hexes.append(format(byte, \"#04x\"))\n        hex_lines.append(\",\".join(byte_hexes))\n\n    data = (\n        \"#define im_width %d\\n\" % width\n        + \"#define im_height %d\\n\" % height\n        + \"static char im_bits[] = {\\n\"\n        + \"%s\\n\" % \",\\n\".join(hex_lines)\n        + \"};\"\n    )\n\n    os.makedirs(cache_dir, exist_ok=True)\n    with open(filename, \"w\") as fp:\n        fp.write(data)\n    return filename", "is_method": false, "function_description": "This function generates a monochrome XBM bitmap file with specified dimensions. It uses a given `predicate` function to determine each pixel's state, saving the resulting image data to a cached file."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "configure_text", "line_number": 60, "body": "def configure_text(text):\n    spacing1 = 2\n    spacing3 = 3\n    text_font = text[\"font\"]\n    text.configure(spacing1=spacing1, spacing3=spacing3)\n    text.master._gutter.configure(spacing1=spacing1, spacing3=spacing3)\n    if isinstance(text_font, str):\n        text_font = font.nametofont(text_font)\n\n    indent_width = text_font.measure(\"    \")\n    bbox = text.bbox(\"1.0\")\n    if bbox is None or bbox[3] < 5:\n        # text not ready yet\n        # TODO: Text in Tk 8.6 has sync method\n        return False\n\n    line_height = bbox[3] + spacing1 + spacing3\n\n    print(indent_width, line_height)\n\n    def ver(x: int, y: int, top: bool, bottom: bool) -> bool:\n        # tells where to show pixels in vertical border of the statement\n        # It would be convenient if tiling started from the start of\n        # 1st char, but it is offset a bit\n        # In order to make computation easier, I'm offsetting x as well\n        x = (x - 5) % indent_width\n\n        stripe_width = 8\n        gap = 3\n        left = indent_width - stripe_width - gap\n\n        return (\n            left <= x < left + stripe_width\n            or top\n            and y == 0\n            and x >= left\n            or bottom\n            and y == line_height - 1\n            and x >= left\n        )\n\n    def hor(x: int, y: int, top: bool, bottom: bool) -> bool:\n        # tells where to show pixels in statement line\n        return top and y == 0 or bottom and y == line_height - 1\n\n    color = get_syntax_options_for_tag(\"GUTTER\").get(\"background\", \"gray\")\n    for orient, base_predicate in [(\"hor\", hor), (\"ver\", ver)]:\n        for top in [False, True]:\n            for bottom in [False, True]:\n\n                def predicate(\n                    x,\n                    y,\n                    # need to make base_predicate, top and bottom local\n                    base_predicate=base_predicate,\n                    top=top,\n                    bottom=bottom,\n                ):\n                    return base_predicate(x, y, top, bottom)\n\n                tag_name = \"%s_%s_%s\" % (orient, top, bottom)\n                bitmap_path = create_bitmap_file(indent_width, line_height, predicate, tag_name)\n                text.tag_configure(tag_name, background=color, bgstipple=\"@\" + bitmap_path)\n\n    return True", "is_method": false, "function_description": "Configures a text widget's visual layout, including line spacing and indentation. It generates custom background patterns (bitmaps) to render structural guides or visual cues within the text area or its gutter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "print_tree", "line_number": 127, "body": "def print_tree(node, level=0):\n    from parso.python import tree as python_tree\n\n    indent = \"  \" * level\n    # if (isinstance(node, python_tree.PythonNode) and node.type == \"sim\"\n    if node.type in (\"simple_stmt\",) or isinstance(node, python_tree.Flow):\n        print(indent, node.type, node.start_pos, node.end_pos)\n\n    if hasattr(node, \"children\"):\n        for child in node.children:\n            print_tree(child, level + 1)", "is_method": false, "function_description": "Recursively traverses a `parso` parse tree. It prints the type and position of simple statements and flow control nodes, providing a visual representation of the code's structural elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "clear_tags", "line_number": 140, "body": "def clear_tags(text):\n    for pos in [\"ver\", \"hor\"]:\n        for top in [True, False]:\n            for bottom in [True, False]:\n                text.tag_remove(\"%s_%s_%s\" % (pos, top, bottom), \"1.0\", \"end\")", "is_method": false, "function_description": "Clears all 'vertical' and 'horizontal' position-related formatting tags from the entire content of a text object. This function ensures a clean slate for new text display or styling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "add_tags", "line_number": 147, "body": "def add_tags(text):\n    source = text.get(\"1.0\", \"end\")\n    clear_tags(text)\n    tree = jedi_utils.parse_source(source)\n\n    print_tree(tree)\n    last_line = 0\n    last_col = 0\n\n    def tag_tree(node):\n        nonlocal last_line, last_col\n        from parso.python import tree as python_tree\n\n        if node.type == \"simple_stmt\" or isinstance(node, (python_tree.Flow, python_tree.Scope)):\n\n            start_line, start_col = node.start_pos\n            end_line, end_col = node.end_pos\n\n            # Before dealing with this node,\n            # handle the case, where last vertical tag was meant for\n            # same column, but there were empty or comment lines between\n            if start_col == last_col:\n                for i in range(last_line + 1, start_line):\n                    # NB! tag not visible when logically empty line\n                    # doesn't have indent prefix\n                    text.tag_add(\n                        \"ver_False_False\", \"%d.%d\" % (i, last_col - 1), \"%d.%d\" % (i, last_col)\n                    )\n                    print(\"ver_False_False\", \"%d.%d\" % (i, last_col - 1), \"%d.%d\" % (i, last_col))\n\n            print(node)\n\n            # usually end_col is 0\n            # exceptions: several statements on the same line (semicoloned statements)\n            # also unclosed parens in if-header\n            for lineno in range(start_line, end_line if end_col == 0 else end_line + 1):\n\n                top = lineno == start_line and lineno > 1\n                bottom = False  # start_line == end_line-1\n\n                # horizontal line (only for first or last line)\n                if top or bottom:\n                    text.tag_add(\n                        \"hor_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col),\n                        \"%d.%d\" % (lineno + 1 if end_col == 0 else lineno, 0),\n                    )\n\n                    print(\n                        \"hor_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col),\n                        \"%d.%d\" % (lineno + 1, 0),\n                    )\n\n                # vertical line (only for indented statements)\n                # Note that I'm using start col for all lines\n                # (statement's indent shouldn't decrease in continuation lines)\n                if start_col > 0:\n                    text.tag_add(\n                        \"ver_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col - 1),\n                        \"%d.%d\" % (lineno, start_col),\n                    )\n                    print(\n                        \"ver_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col - 1),\n                        \"%d.%d\" % (lineno, start_col),\n                    )\n\n                    last_line = lineno\n                    last_col = start_col\n\n        # Recurse\n        if node.type != \"simple_stmt\" and hasattr(node, \"children\"):\n            for child in node.children:\n                tag_tree(child)\n\n    tag_tree(tree)", "is_method": false, "function_description": "Parses Python source code from a text widget and applies visual tags to highlight code blocks and indentation structure, aiding code comprehension."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "handle_editor_event", "line_number": 227, "body": "def handle_editor_event(event):\n    configure_and_add_tags(event.editor.get_text_widget())", "is_method": false, "function_description": "Responds to an editor event by applying configuration and tags to the associated text widget. This dynamically updates the text display or behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "handle_events", "line_number": 231, "body": "def handle_events(event):\n    if hasattr(event, \"text_widget\"):\n        text = event.text_widget\n    else:\n        text = event.widget\n\n    configure_and_add_tags(text)", "is_method": false, "function_description": "This function serves as an event handler, identifying the relevant text widget from an event. It then applies specific configurations and adds tags to that text widget, likely for UI formatting or metadata."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "configure_and_add_tags", "line_number": 240, "body": "def configure_and_add_tags(text):\n    if not getattr(text, \"structure_tags_configured\", False):\n        try:\n            if configure_text(text):\n                text.structure_tags_configured = True\n            else:\n                text.after(500, lambda: configure_and_add_tags(text))\n                return\n        except Exception:\n            logging.exception(\"Problem with defining structure tags\")\n            return\n\n    add_tags(text)", "is_method": false, "function_description": "Configures and applies structural tags to a text object. It attempts configuration, retrying later if necessary, before adding the tags for structured processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "_load_plugin", "line_number": 255, "body": "def _load_plugin() -> None:\n    wb = get_workbench()\n\n    wb.set_default(\"view.program_structure\", False)\n    wb.bind(\"Save\", handle_editor_event, True)\n    wb.bind(\"Open\", handle_editor_event, True)\n    wb.bind_class(\"CodeViewText\", \"<<TextChange>>\", handle_events, True)", "is_method": false, "function_description": "Configures a plugin within an application workbench. It sets a default view preference and binds event handlers for editor actions like saving, opening, and text changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "ver", "line_number": 80, "body": "def ver(x: int, y: int, top: bool, bottom: bool) -> bool:\n        # tells where to show pixels in vertical border of the statement\n        # It would be convenient if tiling started from the start of\n        # 1st char, but it is offset a bit\n        # In order to make computation easier, I'm offsetting x as well\n        x = (x - 5) % indent_width\n\n        stripe_width = 8\n        gap = 3\n        left = indent_width - stripe_width - gap\n\n        return (\n            left <= x < left + stripe_width\n            or top\n            and y == 0\n            and x >= left\n            or bottom\n            and y == line_height - 1\n            and x >= left\n        )", "is_method": false, "function_description": "Checks if a given pixel coordinate (x, y) should be rendered as part of a vertical border, considering specific conditions for top and bottom edges. This function assists in UI rendering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "hor", "line_number": 101, "body": "def hor(x: int, y: int, top: bool, bottom: bool) -> bool:\n        # tells where to show pixels in statement line\n        return top and y == 0 or bottom and y == line_height - 1", "is_method": false, "function_description": "Determines if a pixel should be drawn horizontally at the very top or bottom edge of a line segment. This is used for rendering boundaries in a display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "tag_tree", "line_number": 156, "body": "def tag_tree(node):\n        nonlocal last_line, last_col\n        from parso.python import tree as python_tree\n\n        if node.type == \"simple_stmt\" or isinstance(node, (python_tree.Flow, python_tree.Scope)):\n\n            start_line, start_col = node.start_pos\n            end_line, end_col = node.end_pos\n\n            # Before dealing with this node,\n            # handle the case, where last vertical tag was meant for\n            # same column, but there were empty or comment lines between\n            if start_col == last_col:\n                for i in range(last_line + 1, start_line):\n                    # NB! tag not visible when logically empty line\n                    # doesn't have indent prefix\n                    text.tag_add(\n                        \"ver_False_False\", \"%d.%d\" % (i, last_col - 1), \"%d.%d\" % (i, last_col)\n                    )\n                    print(\"ver_False_False\", \"%d.%d\" % (i, last_col - 1), \"%d.%d\" % (i, last_col))\n\n            print(node)\n\n            # usually end_col is 0\n            # exceptions: several statements on the same line (semicoloned statements)\n            # also unclosed parens in if-header\n            for lineno in range(start_line, end_line if end_col == 0 else end_line + 1):\n\n                top = lineno == start_line and lineno > 1\n                bottom = False  # start_line == end_line-1\n\n                # horizontal line (only for first or last line)\n                if top or bottom:\n                    text.tag_add(\n                        \"hor_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col),\n                        \"%d.%d\" % (lineno + 1 if end_col == 0 else lineno, 0),\n                    )\n\n                    print(\n                        \"hor_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col),\n                        \"%d.%d\" % (lineno + 1, 0),\n                    )\n\n                # vertical line (only for indented statements)\n                # Note that I'm using start col for all lines\n                # (statement's indent shouldn't decrease in continuation lines)\n                if start_col > 0:\n                    text.tag_add(\n                        \"ver_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col - 1),\n                        \"%d.%d\" % (lineno, start_col),\n                    )\n                    print(\n                        \"ver_%s_%s\" % (top, bottom),\n                        \"%d.%d\" % (lineno, start_col - 1),\n                        \"%d.%d\" % (lineno, start_col),\n                    )\n\n                    last_line = lineno\n                    last_col = start_col\n\n        # Recurse\n        if node.type != \"simple_stmt\" and hasattr(node, \"children\"):\n            for child in node.children:\n                tag_tree(child)", "is_method": false, "function_description": "Recursively traverses a Python AST, adding visual tags to a text display. It highlights code structure and indentation by drawing horizontal and vertical lines for statements and blocks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/statement_boxes.py", "function": "predicate", "line_number": 110, "body": "def predicate(\n                    x,\n                    y,\n                    # need to make base_predicate, top and bottom local\n                    base_predicate=base_predicate,\n                    top=top,\n                    bottom=bottom,\n                ):\n                    return base_predicate(x, y, top, bottom)", "is_method": false, "function_description": "Invokes a `base_predicate` function, passing `x` and `y` along with specified `top` and `bottom` values. It serves as a specialized predicate evaluator."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "update_coloring_on_event", "line_number": 307, "body": "def update_coloring_on_event(event):\n    if hasattr(event, \"text_widget\"):\n        text = event.text_widget\n    else:\n        text = event.widget\n\n    try:\n        update_coloring_on_text(text, event)\n    except Exception as e:\n        logger.error(\"Problem with coloring\", exc_info=e)", "is_method": false, "function_description": "Updates the coloring of a text widget in response to a UI event. It primarily serves as an event handler to apply or refresh syntax highlighting or text styling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "update_coloring_on_text", "line_number": 319, "body": "def update_coloring_on_text(text, event=None):\n    if not hasattr(text, \"syntax_colorer\"):\n        if isinstance(text, ShellText):\n            class_ = ShellSyntaxColorer\n        elif isinstance(text, CodeViewText):\n            class_ = CodeViewSyntaxColorer\n        else:\n            return\n\n        text.syntax_colorer = class_(text)\n        # mark whole text as unprocessed\n        text.syntax_colorer.mark_dirty()\n    else:\n        text.syntax_colorer.mark_dirty(event)\n\n    text.syntax_colorer.schedule_update()", "is_method": false, "function_description": "Initializes a syntax colorer for the given text object if not present, then marks the text for re-coloring and schedules a syntax highlighting update. This ensures the displayed text's syntax is correctly colored."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "load_plugin", "line_number": 337, "body": "def load_plugin() -> None:\n    wb = get_workbench()\n\n    wb.set_default(\"view.syntax_coloring\", True)\n    wb.set_default(\"view.highlight_tabs\", True)\n    wb.bind(\"TextInsert\", update_coloring_on_event, True)\n    wb.bind(\"TextDelete\", update_coloring_on_event, True)\n    wb.bind_class(\"CodeViewText\", \"<<VerticalScroll>>\", update_coloring_on_event, True)\n    wb.bind(\"<<UpdateAppearance>>\", update_coloring_on_event, True)", "is_method": false, "function_description": "Initializes a workbench plugin by enabling syntax coloring and tab highlighting. It also binds editor events to automatically update the visual display, ensuring a consistent user experience."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_compile_regexes", "line_number": 40, "body": "def _compile_regexes(self):\n        from thonny.token_utils import (\n            BUILTIN,\n            COMMENT,\n            COMMENT_WITH_Q3DELIMITER,\n            KEYWORD,\n            MAGIC_COMMAND,\n            NUMBER,\n            STRING3,\n            STRING3_DELIMITER,\n            STRING_CLOSED,\n            STRING_OPEN,\n            TAB,\n        )\n\n        self.uniline_regex = re.compile(\n            KEYWORD\n            + \"|\"\n            + BUILTIN\n            + \"|\"\n            + NUMBER\n            + \"|\"\n            + COMMENT\n            + \"|\"\n            + MAGIC_COMMAND\n            + \"|\"\n            + STRING3_DELIMITER  # to avoid marking \"\"\" and ''' as single line string in uniline mode\n            + \"|\"\n            + STRING_CLOSED\n            + \"|\"\n            + STRING_OPEN\n            + \"|\"\n            + TAB,\n            re.S,  # @UndefinedVariable\n        )\n\n        # need to notice triple-quotes inside comments and magic commands\n        self.multiline_regex = re.compile(\n            \"(\" + STRING3 + \")|\" + COMMENT_WITH_Q3DELIMITER + \"|\" + MAGIC_COMMAND,\n            re.S,  # @UndefinedVariable\n        )\n\n        self.id_regex = re.compile(r\"\\s+(\\w+)\", re.S)", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Prepares the regular expressions for the SyntaxColorer to accurately identify and categorize different Python language elements. This enables the class to perform syntax highlighting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_config_tags", "line_number": 84, "body": "def _config_tags(self):\n        self.uniline_tags = {\n            \"comment\",\n            \"magic\",\n            \"string\",\n            \"open_string\",\n            \"keyword\",\n            \"number\",\n            \"builtin\",\n            \"definition\",\n        }\n        self.multiline_tags = {\"string3\", \"open_string3\"}\n        self._raise_tags()", "is_method": true, "class_name": "SyntaxColorer", "function_description": "This internal method of the `SyntaxColorer` class initializes and configures the sets of uniline and multiline tags used for identifying and categorizing different syntax elements. It prepares the colorer for its main task."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_raise_tags", "line_number": 98, "body": "def _raise_tags(self):\n        self.text.tag_raise(\"string3\")\n        self.text.tag_raise(\"open_string3\")\n        # yes, unclosed_expression is another plugin's issue,\n        # but it must be higher than *string3\n        self.text.tag_raise(\"tab\")\n        self.text.tag_raise(\"unclosed_expression\")\n        self.text.tag_raise(\"sel\")\n        \"\"\"\n        tags = self.text.tag_names()\n        # take into account that without themes some tags may be undefined\n        if \"string3\" in tags:\n            self.text.tag_raise(\"string3\")\n        if \"open_string3\" in tags:\n            self.text.tag_raise(\"open_string3\")\n        \"\"\"", "is_method": true, "class_name": "SyntaxColorer", "function_description": "This method of the `SyntaxColorer` class adjusts the visual display order of text tags, ensuring specific elements like strings, tabs, and selections are visible above others in the text widget. It prioritizes certain syntax highlights."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "mark_dirty", "line_number": 115, "body": "def mark_dirty(self, event=None):\n        start_index = \"1.0\"\n        end_index = \"end\"\n\n        if hasattr(event, \"sequence\"):\n            if event.sequence == \"TextInsert\":\n                index = self.text.index(event.index)\n                start_row = int(index.split(\".\")[0])\n                end_row = start_row + event.text.count(\"\\n\")\n                start_index = \"%d.%d\" % (start_row, 0)\n                end_index = \"%d.%d\" % (end_row + 1, 0)\n                if not event.trivial_for_coloring:\n                    self._multiline_dirty = True\n\n            elif event.sequence == \"TextDelete\":\n                index = self.text.index(event.index1)\n                start_row = int(index.split(\".\")[0])\n                start_index = \"%d.%d\" % (start_row, 0)\n                end_index = \"%d.%d\" % (start_row + 1, 0)\n                if not event.trivial_for_coloring:\n                    self._multiline_dirty = True\n\n        self.text.tag_add(TODO, start_index, end_index)", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Marks affected text ranges within the editor as needing syntax recoloring. This function identifies changed areas after insertions or deletions, ensuring highlighting is refreshed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "schedule_update", "line_number": 139, "body": "def schedule_update(self):\n        self._highlight_tabs = get_workbench().get_option(\"view.highlight_tabs\")\n        self._use_coloring = (\n            get_workbench().get_option(\"view.syntax_coloring\") and self.text.is_python_text()\n        )\n\n        if not self._update_scheduled:\n            self._update_scheduled = True\n            self.text.after_idle(self.perform_update)", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Schedules a deferred syntax highlighting update for the text editor. It applies coloring based on user settings and text type, running efficiently when the system is idle."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "perform_update", "line_number": 149, "body": "def perform_update(self):\n        try:\n            self._update_coloring()\n        finally:\n            self._update_scheduled = False", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Initiates the syntax coloring update for the editor. It ensures the update scheduling flag is reset after the attempt, regardless of success."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_update_uniline_tokens", "line_number": 158, "body": "def _update_uniline_tokens(self, start, end):\n        chars = self.text.get(start, end)\n\n        # clear old tags\n        for tag in self.uniline_tags | {\"tab\"}:\n            self.text.tag_remove(tag, start, end)\n\n        if self._use_coloring:\n            for match in self.uniline_regex.finditer(chars):\n                for token_type, token_text in match.groupdict().items():\n                    if token_text and token_type in self.uniline_tags:\n                        token_text = token_text.strip()\n                        match_start, match_end = match.span(token_type)\n\n                        self.text.tag_add(\n                            token_type, start + \"+%dc\" % match_start, start + \"+%dc\" % match_end\n                        )\n\n                        # Mark also the word following def or class\n                        if token_text in (\"def\", \"class\"):\n                            id_match = self.id_regex.match(chars, match_end)\n                            if id_match:\n                                id_match_start, id_match_end = id_match.span(1)\n                                self.text.tag_add(\n                                    \"definition\",\n                                    start + \"+%dc\" % id_match_start,\n                                    start + \"+%dc\" % id_match_end,\n                                )\n\n        if self._highlight_tabs:\n            self._update_tabs(start, end)\n\n        self.text.tag_remove(TODO, start, end)", "is_method": true, "class_name": "SyntaxColorer", "function_description": "An internal method of `SyntaxColorer`, it updates the visual syntax highlighting for a specified text range. It applies appropriate tags for code tokens, definitions, and tabs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_update_multiline_tokens", "line_number": 192, "body": "def _update_multiline_tokens(self, start, end):\n        chars = self.text.get(start, end)\n        # clear old tags\n        for tag in self.multiline_tags:\n            self.text.tag_remove(tag, start, end)\n\n        if not self._use_coloring:\n            return\n\n        for match in self.multiline_regex.finditer(chars):\n            token_text = match.group(1)\n            if token_text is None:\n                # not string3\n                continue\n\n            match_start, match_end = match.span()\n            if (\n                token_text.startswith('\"\"\"')\n                and not token_text.endswith('\"\"\"')\n                or token_text.startswith(\"'''\")\n                and not token_text.endswith(\"'''\")\n                or len(token_text) == 3\n            ):\n                token_type = \"open_string3\"\n            elif len(token_text) >= 4 and token_text[-4] == \"\\\\\":\n                token_type = \"open_string3\"\n            else:\n                token_type = \"string3\"\n\n            token_start = start + \"+%dc\" % match_start\n            token_end = start + \"+%dc\" % match_end\n            self.text.tag_add(token_type, token_start, token_end)\n\n        self._multiline_dirty = False\n        self._raise_tags()", "is_method": true, "class_name": "SyntaxColorer", "function_description": "Updates syntax highlighting for multi-line string tokens within a specified text range. It identifies and applies color tags to triple-quoted strings, enhancing code readability in a text editor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_update_tabs", "line_number": 228, "body": "def _update_tabs(self, start, end):\n        while True:\n            pos = self.text.search(\"\\t\", start, end)\n            if pos:\n                self.text.tag_add(\"tab\", pos)\n                start = self.text.index(\"%s +1 c\" % pos)\n            else:\n                break", "is_method": true, "class_name": "SyntaxColorer", "function_description": "This private method identifies all tab characters within a text range. It applies a \"tab\" tag to them, which enables the `SyntaxColorer` to visually style tabs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_update_coloring", "line_number": 239, "body": "def _update_coloring(self):\n        viewport_start = self.text.index(\"@0,0\")\n        viewport_end = self.text.index(\n            \"@%d,%d lineend\" % (self.text.winfo_width(), self.text.winfo_height())\n        )\n\n        search_start = viewport_start\n        search_end = viewport_end\n\n        while True:\n            res = self.text.tag_nextrange(TODO, search_start, search_end)\n            if res:\n                update_start = res[0]\n                update_end = res[1]\n            else:\n                # maybe the range started earlier\n                res = self.text.tag_prevrange(TODO, search_start)\n                if res and self.text.compare(res[1], \">\", search_end):\n                    update_start = search_start\n                    update_end = res[1]\n                else:\n                    break\n\n            if self.text.compare(update_end, \">\", search_end):\n                update_end = search_end\n\n            self._update_uniline_tokens(update_start, update_end)\n\n            if update_end == search_end:\n                break\n            else:\n                search_start = update_end\n\n        # Multiline tokens need to be searched from the whole source\n        if self._multiline_dirty:\n            self._update_multiline_tokens(\"1.0\", \"end\")\n\n        # Get rid of wrong open string tags (https://github.com/thonny/thonny/issues/943)\n        search_start = viewport_start\n        while True:\n            tag_range = self.text.tag_nextrange(\"open_string\", search_start, viewport_end)\n            if not tag_range:\n                break\n\n            if \"string3\" in self.text.tag_names(tag_range[0]):\n                self.text.tag_remove(\"open_string\", tag_range[0], tag_range[1])\n\n            search_start = tag_range[1]", "is_method": true, "class_name": "CodeViewSyntaxColorer", "function_description": "Ensures correct syntax highlighting for the code view. It updates visible tokens and re-evaluates all multi-line tokens, including cleanup of incorrect tags."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/coloring.py", "function": "_update_coloring", "line_number": 290, "body": "def _update_coloring(self):\n        parts = self.text.tag_prevrange(\"command\", \"end\")\n\n        if parts:\n            end_row, end_col = map(int, self.text.index(parts[1]).split(\".\"))\n\n            if end_col != 0:  # if not just after the last linebreak\n                end_row += 1  # then extend the range to the beginning of next line\n                end_col = 0  # (otherwise open strings are not displayed correctly)\n\n            start_index = parts[0]\n            end_index = \"%d.%d\" % (end_row, end_col)\n\n            self._update_uniline_tokens(start_index, end_index)\n            self._update_multiline_tokens(start_index, end_index)", "is_method": true, "class_name": "ShellSyntaxColorer", "function_description": "Updates the shell text's syntax coloring. It determines the effective range for re-coloring, then applies highlighting for both single-line and multi-line tokens within that section."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/common_editing_commands.py", "function": "load_plugin", "line_number": 7, "body": "def load_plugin() -> None:\n    def create_edit_command_handler(virtual_event_sequence):\n        def handler(event=None):\n            widget = get_workbench().focus_get()\n            if widget:\n                return widget.event_generate(virtual_event_sequence)\n\n            return None\n\n        return handler\n\n    get_workbench().add_command(\n        \"undo\",\n        \"edit\",\n        tr(\"Undo\"),\n        create_edit_command_handler(\"<<Undo>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-z>\", \"<Command-z>\"),\n        extra_sequences=[\"<Control-Greek_zeta>\"],\n        skip_sequence_binding=True,\n        group=10,\n    )\n\n    get_workbench().add_command(\n        \"redo\",\n        \"edit\",\n        tr(\"Redo\"),\n        create_edit_command_handler(\"<<Redo>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-y>\", \"<Command-y>\"),\n        extra_sequences=[\n            select_sequence(\"<Control-Shift-Z>\", \"<Command-Shift-Z>\"),\n            \"<Control-Greek_upsilon>\",\n            \"<Control-Shift-Greek_ZETA>\",\n        ],\n        skip_sequence_binding=True,\n        group=10,\n    )\n\n    get_workbench().add_command(\n        \"Cut\",\n        \"edit\",\n        tr(\"Cut\"),\n        create_edit_command_handler(\"<<Cut>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-x>\", \"<Command-x>\"),\n        extra_sequences=[\"<Control-Greek_chi>\"],\n        skip_sequence_binding=True,\n        group=20,\n    )\n\n    get_workbench().add_command(\n        \"Copy\",\n        \"edit\",\n        tr(\"Copy\"),\n        create_edit_command_handler(\"<<Copy>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-c>\", \"<Command-c>\"),\n        extra_sequences=[\"<Control-Greek_psi>\"],\n        skip_sequence_binding=True,\n        group=20,\n    )\n\n    get_workbench().add_command(\n        \"Paste\",\n        \"edit\",\n        tr(\"Paste\"),\n        create_edit_command_handler(\"<<Paste>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-v>\", \"<Command-v>\"),\n        extra_sequences=[\"<Control-Greek_omega>\"],\n        skip_sequence_binding=True,\n        group=20,\n    )\n\n    get_workbench().add_command(\n        \"SelectAll\",\n        \"edit\",\n        tr(\"Select all\"),\n        create_edit_command_handler(\"<<SelectAll>>\"),\n        tester=None,  # TODO:\n        default_sequence=select_sequence(\"<Control-a>\", \"<Command-a>\"),\n        extra_sequences=[\"<Control-Greek_alpha>\"],\n        skip_sequence_binding=True,\n        group=20,\n    )", "is_method": false, "function_description": "Registers standard editing commands like Undo, Redo, Cut, Copy, Paste, and Select All with the application's workbench. This enables common keyboard shortcuts and menu actions for focused widgets."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/common_editing_commands.py", "function": "create_edit_command_handler", "line_number": 8, "body": "def create_edit_command_handler(virtual_event_sequence):\n        def handler(event=None):\n            widget = get_workbench().focus_get()\n            if widget:\n                return widget.event_generate(virtual_event_sequence)\n\n            return None\n\n        return handler", "is_method": false, "function_description": "Provides a factory for creating event handlers. Each handler dispatches a specific virtual event to the currently focused GUI widget, enabling generic command execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/common_editing_commands.py", "function": "handler", "line_number": 9, "body": "def handler(event=None):\n            widget = get_workbench().focus_get()\n            if widget:\n                return widget.event_generate(virtual_event_sequence)\n\n            return None", "is_method": false, "function_description": "Triggers a specific virtual event on the currently focused UI widget. This allows programmatic simulation of user interactions or dispatching actions to the active component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/thonny_folders.py", "function": "load_plugin", "line_number": 9, "body": "def load_plugin() -> None:\n    def cmd_open_data_dir():\n        open_path_in_system_file_manager(THONNY_USER_DIR)\n\n    def cmd_open_program_dir():\n        open_path_in_system_file_manager(get_workbench().get_package_dir())\n\n    get_workbench().add_command(\n        \"open_program_dir\",\n        \"tools\",\n        tr(\"Open Thonny program folder...\"),\n        cmd_open_program_dir,\n        group=110,\n    )\n    get_workbench().add_command(\n        \"open_data_dir\", \"tools\", tr(\"Open Thonny data folder...\"), cmd_open_data_dir, group=110\n    )", "is_method": false, "function_description": "Registers two commands with the Thonny workbench, enabling users to open Thonny's program installation and user data folders directly from the 'Tools' menu."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/thonny_folders.py", "function": "cmd_open_data_dir", "line_number": 10, "body": "def cmd_open_data_dir():\n        open_path_in_system_file_manager(THONNY_USER_DIR)", "is_method": false, "function_description": "Opens the application's user data directory in the operating system's file manager. This provides quick access to application-specific files for users."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/thonny_folders.py", "function": "cmd_open_program_dir", "line_number": 13, "body": "def cmd_open_program_dir():\n        open_path_in_system_file_manager(get_workbench().get_package_dir())", "is_method": false, "function_description": "Opens the application's main program directory using the system's file manager. This provides users direct access to program files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/birdseye_frontend.py", "function": "_start_debug_enabled", "line_number": 13, "body": "def _start_debug_enabled():\n    return (\n        get_workbench().get_editor_notebook().get_current_editor() is not None\n        and \"debug\" in get_runner().get_supported_features()\n    )", "is_method": false, "function_description": "Determines if debugging can be enabled by checking for an active editor and debug support in the current execution environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/birdseye_frontend.py", "function": "start_server", "line_number": 20, "body": "def start_server():\n    global _server_process\n\n    out_err_filename = os.path.join(THONNY_USER_DIR, \"birdseye.log\")\n    output_file = open(out_err_filename, \"w\")\n    _server_process = subprocess.Popen(\n        [\n            running.get_interpreter_for_subprocess(),\n            \"-m\",\n            \"birdseye\",\n            \"-p\",\n            str(get_workbench().get_option(\"run.birdseye_port\")),\n        ],\n        stdout=output_file,\n        stderr=output_file,\n    )\n    atexit.register(close_server)", "is_method": false, "function_description": "Launches the `birdseye` server as a separate subprocess, redirecting its output to a log file. It also registers a cleanup function to ensure the server is closed upon program exit."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/birdseye_frontend.py", "function": "close_server", "line_number": 39, "body": "def close_server():\n    if _server_process is not None:\n        try:\n            _server_process.kill()\n        except Exception:\n            pass", "is_method": false, "function_description": "Terminates the active server process if it is currently running."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/birdseye_frontend.py", "function": "debug_with_birdseye", "line_number": 47, "body": "def debug_with_birdseye():\n    global _server_started\n\n    try:\n        import birdseye  # @UnusedImport\n    except ImportError:\n        if messagebox.askyesno(\n            tr(\"About Birdseye\"),\n            tr(\n                \"Birdseye is a Python debugger which needs to be installed separately.\\n\\n\"\n                + \"Do you want to open the help page and learn more?\"\n            ),\n            master=get_workbench(),\n        ):\n            get_workbench().open_help_topic(\"birdseye\")\n\n        return\n\n    if not _server_started:\n        start_server()\n        _server_started = True\n\n    os.environ[\"BIRDSEYE_PORT\"] = str(get_workbench().get_option(\"run.birdseye_port\"))\n    get_runner().execute_current(\"Birdseye\")", "is_method": false, "function_description": "Launches and configures the Birdseye debugger for the current code. It handles installation checks, server startup, and executes the code in debug mode."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/birdseye_frontend.py", "function": "load_plugin", "line_number": 78, "body": "def load_plugin():\n    get_workbench().set_default(\"run.birdseye_port\", 7777)\n    get_workbench().add_command(\n        \"birdseye\",\n        \"run\",\n        tr(\"Debug current script (birdseye)\"),\n        debug_with_birdseye,\n        caption=\"birdseye\",\n        tester=_start_debug_enabled,\n        default_sequence=\"<Control-B>\",\n        group=10,\n        image=os.path.join(os.path.dirname(__file__), \"..\", \"res\", \"birdseye.png\"),\n    )", "is_method": false, "function_description": "Integrates the 'birdseye' debugging tool by adding a command to the application's workbench. It enables debugging the current script and configures its default port."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "update_highlighting", "line_number": 104, "body": "def update_highlighting(event):\n    if not get_workbench().ready:\n        # don't slow down loading process\n        return\n\n    assert isinstance(event.widget, tk.Text)\n    text = event.widget\n\n    if not hasattr(text, \"local_highlighter\"):\n        text.local_highlighter = LocalsHighlighter(text)\n\n    text.local_highlighter.schedule_update()", "is_method": false, "function_description": "Updates the highlighting within a Tkinter text widget. It efficiently schedules the refreshment of code or content highlighting, avoiding performance issues during application loading."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "load_plugin", "line_number": 118, "body": "def load_plugin() -> None:\n    wb = get_workbench()\n    wb.set_default(\"view.locals_highlighting\", False)\n    wb.bind_class(\"CodeViewText\", \"<<TextChange>>\", update_highlighting, True)\n    wb.bind(\"<<UpdateAppearance>>\", update_highlighting, True)", "is_method": false, "function_description": "Configures the workbench's text highlighting behavior when a plugin is loaded. It disables default local highlighting and binds update functions to text change and appearance events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "get_positions", "line_number": 13, "body": "def get_positions(self):\n        from jedi import parser_utils\n        from parso.python import tree\n\n        locs = []\n\n        def process_scope(scope):\n            if isinstance(scope, tree.Function):\n                # process all children after name node,\n                # (otherwise name of global function will be marked as local def)\n                local_names = set()\n                global_names = set()\n                for child in scope.children[2:]:\n                    process_node(child, local_names, global_names)\n            else:\n                if hasattr(scope, \"subscopes\"):\n                    for child in scope.subscopes:\n                        process_scope(child)\n                elif hasattr(scope, \"children\"):\n                    for child in scope.children:\n                        process_scope(child)\n\n        def process_node(node, local_names, global_names):\n            if isinstance(node, tree.GlobalStmt):\n                global_names.update([n.value for n in node.get_global_names()])\n\n            elif isinstance(node, tree.Name):\n                if node.value in global_names:\n                    return\n\n                if node.is_definition():  # local def\n                    locs.append(node)\n                    local_names.add(node.value)\n                elif node.value in local_names:  # use of local\n                    locs.append(node)\n\n            elif isinstance(node, tree.BaseNode):\n                # ref: jedi/parser/grammar*.txt\n                if node.type == \"trailer\" and node.children[0].value == \".\":\n                    # this is attribute\n                    return\n\n                if isinstance(node, tree.Function):\n                    global_names = set()  # outer global statement doesn't have effect anymore\n\n                for child in node.children:\n                    process_node(child, local_names, global_names)\n\n        source = self.text.get(\"1.0\", \"end\")\n        module = jedi_utils.parse_source(source)\n        for child in module.children:\n            if isinstance(child, tree.BaseNode) and parser_utils.is_scope(child):\n                process_scope(child)\n\n        loc_pos = set(\n            (\n                \"%d.%d\" % (usage.start_pos[0], usage.start_pos[1]),\n                \"%d.%d\" % (usage.start_pos[0], usage.start_pos[1] + len(usage.value)),\n            )\n            for usage in locs\n        )\n\n        return loc_pos", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "The `LocalsHighlighter` method identifies and returns the character positions of local variable definitions and their usages in Python code, typically for syntax highlighting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "_highlight", "line_number": 77, "body": "def _highlight(self, pos_info):\n        for pos in pos_info:\n            start_index, end_index = pos[0], pos[1]\n            self.text.tag_add(\"local_name\", start_index, end_index)", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "Highlights specified text ranges with a 'local_name' tag. This method, part of LocalsHighlighter, visually marks local variable occurrences within a text display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "schedule_update", "line_number": 82, "body": "def schedule_update(self):\n        def perform_update():\n            try:\n                self.update()\n            finally:\n                self._update_scheduled = False\n\n        if not self._update_scheduled:\n            self._update_scheduled = True\n            self.text.after_idle(perform_update)", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "This method schedules a single update for the locals highlighting component to occur when the GUI is idle, preventing redundant operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "update", "line_number": 93, "body": "def update(self):\n        self.text.tag_remove(\"local_name\", \"1.0\", \"end\")\n\n        if get_workbench().get_option(\"view.locals_highlighting\") and self.text.is_python_text():\n            try:\n                highlight_positions = self.get_positions()\n                self._highlight(highlight_positions)\n            except Exception:\n                logging.exception(\"Problem when updating local variable tags\")", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "Updates the highlighting of local variables within the associated Python text, clearing existing highlights and applying new ones according to user settings. This enhances code readability and navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "process_scope", "line_number": 19, "body": "def process_scope(scope):\n            if isinstance(scope, tree.Function):\n                # process all children after name node,\n                # (otherwise name of global function will be marked as local def)\n                local_names = set()\n                global_names = set()\n                for child in scope.children[2:]:\n                    process_node(child, local_names, global_names)\n            else:\n                if hasattr(scope, \"subscopes\"):\n                    for child in scope.subscopes:\n                        process_scope(child)\n                elif hasattr(scope, \"children\"):\n                    for child in scope.children:\n                        process_scope(child)", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "Traverses a code scope hierarchy, distinguishing local from global names within function definitions. It facilitates accurate variable highlighting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "process_node", "line_number": 35, "body": "def process_node(node, local_names, global_names):\n            if isinstance(node, tree.GlobalStmt):\n                global_names.update([n.value for n in node.get_global_names()])\n\n            elif isinstance(node, tree.Name):\n                if node.value in global_names:\n                    return\n\n                if node.is_definition():  # local def\n                    locs.append(node)\n                    local_names.add(node.value)\n                elif node.value in local_names:  # use of local\n                    locs.append(node)\n\n            elif isinstance(node, tree.BaseNode):\n                # ref: jedi/parser/grammar*.txt\n                if node.type == \"trailer\" and node.children[0].value == \".\":\n                    # this is attribute\n                    return\n\n                if isinstance(node, tree.Function):\n                    global_names = set()  # outer global statement doesn't have effect anymore\n\n                for child in node.children:\n                    process_node(child, local_names, global_names)", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "This method traverses a code's abstract syntax tree to identify and collect all local variable definitions and usages. It correctly handles scoping rules, distinguishing locals from globals for highlighting purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/locals_marker.py", "function": "perform_update", "line_number": 83, "body": "def perform_update():\n            try:\n                self.update()\n            finally:\n                self._update_scheduled = False", "is_method": true, "class_name": "LocalsHighlighter", "function_description": "Performs the main update operation for the LocalsHighlighter. It reliably clears the internal update scheduling flag, ensuring consistent state management regardless of execution outcome."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_generate_timestamp_file_name", "line_number": 159, "body": "def _generate_timestamp_file_name(extension):\n    # generate log filename\n    folder = _get_log_dir()\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n\n    for i in range(100):\n        filename = os.path.join(\n            folder, time.strftime(\"%Y-%m-%d_%H-%M-%S_{}.{}\".format(i, extension))\n        )\n        if not os.path.exists(filename):\n            return filename\n\n    raise RuntimeError()", "is_method": false, "function_description": "Provides a unique, timestamped file path within a designated log directory. It ensures the directory exists and generates an incremented filename if the original already exists, preventing overwrites."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_get_log_dir", "line_number": 175, "body": "def _get_log_dir():\n    return os.path.join(THONNY_USER_DIR, \"user_logs\")", "is_method": false, "function_description": "Provides the file system path for user-specific application logs. It specifies where log files should be stored within the Thonny user directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "export", "line_number": 179, "body": "def export():\n    import zipfile\n\n    filename = asksaveasfilename(\n        filetypes=[(\"Zip-files\", \".zip\"), (\"all files\", \".*\")],\n        defaultextension=\".zip\",\n        initialdir=get_workbench().get_local_cwd(),\n        initialfile=time.strftime(\"ThonnyUsageLogs_%Y-%m-%d.zip\"),\n        parent=get_workbench(),\n    )\n\n    if not filename:\n        return\n\n    log_dir = _get_log_dir()\n\n    with zipfile.ZipFile(filename, \"w\", compression=zipfile.ZIP_DEFLATED) as zipf:\n        for item in os.listdir(log_dir):\n            if item.endswith(\".txt\") or item.endswith(\".zip\"):\n                zipf.write(os.path.join(log_dir, item), arcname=item)", "is_method": false, "function_description": "This function enables users to export Thonny usage log files. It prompts for a zip file location and archives all relevant text and zip logs into it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "load_plugin", "line_number": 201, "body": "def load_plugin() -> None:\n    get_workbench().set_default(\"general.event_logging\", False)\n\n    if get_workbench().get_option(\"general.event_logging\"):\n        get_workbench().add_command(\n            \"export_usage_logs\", \"tools\", tr(\"Export usage logs...\"), export, group=110\n        )\n\n        filename = _generate_timestamp_file_name(\"txt\")\n        # create logger\n        EventLogger(filename)", "is_method": false, "function_description": "Configures event logging for the application. It optionally sets up event logging, including adding an export command and initializing the event logger."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_bind_workbench", "line_number": 61, "body": "def _bind_workbench(self, sequence, only_workbench_widget=False):\n        def handle(event):\n            if not only_workbench_widget or event.widget == get_workbench():\n                self._log_event(sequence, event)\n\n        get_workbench().bind(sequence, handle, True)", "is_method": true, "class_name": "EventLogger", "function_description": "This method registers an event handler with the workbench to log specific user interactions. It can selectively log events originating only from the workbench widget itself."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_bind_all", "line_number": 68, "body": "def _bind_all(self, sequence):\n        def handle(event):\n            self._log_event(sequence, event)\n\n        tk._default_root.bind_all(sequence, handle, True)", "is_method": true, "class_name": "EventLogger", "function_description": "Configures the EventLogger to capture and log occurrences of a specific Tkinter event sequence across all application widgets. This enables comprehensive tracking of user interactions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_extract_interesting_data", "line_number": 74, "body": "def _extract_interesting_data(self, event, sequence):\n        attributes = vars(event)\n\n        # generate some new attributes\n        if \"text_widget\" not in attributes:\n            if \"editor\" in attributes:\n                attributes[\"text_widget\"] = attributes[\"editor\"].get_text_widget()\n\n            if \"widget\" in attributes and isinstance(attributes[\"widget\"], tk.Text):\n                attributes[\"text_widget\"] = attributes[\"widget\"]\n\n        if \"text_widget\" in attributes:\n            widget = attributes[\"text_widget\"]\n            if isinstance(widget.master.master, ShellView):\n                attributes[\"text_widget_context\"] = \"shell\"\n\n        # select attributes\n        data = {}\n        for name in attributes:\n            # skip some attributes\n            if (\n                name.startswith(\"_\")\n                or isinstance(event, WorkbenchEvent)\n                and name in [\"update\", \"setdefault\"]\n                or isinstance(event, tk.Event)\n                and name not in [\"widget\", \"text_widget\", \"text_widget_context\"]\n            ):\n                continue\n\n            value = attributes[name]\n\n            if isinstance(value, (tk.BaseWidget, tk.Tk)):\n                data[name + \"_id\"] = id(value)\n                data[name + \"_class\"] = value.__class__.__name__\n\n            elif isinstance(value, (str, int, float)):\n                data[name] = value\n\n            else:\n                data[name] = repr(value)\n\n        return data", "is_method": true, "class_name": "EventLogger", "function_description": "An internal helper method that extracts, enriches, and formats relevant attributes from an event object into a dictionary, preparing the data for logging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_log_event", "line_number": 117, "body": "def _log_event(self, sequence, event):\n        data = self._extract_interesting_data(event, sequence)\n        data[\"sequence\"] = sequence\n        data[\"time\"] = datetime.now().isoformat()\n        if len(data[\"time\"]) == 19:\n            # 0 fraction gets skipped, but reader assumes it\n            data[\"time\"] += \".0\"\n        self._events.append(data)", "is_method": true, "class_name": "EventLogger", "function_description": "Captures and stores structured event data, including its sequence and a precise timestamp, into the logger's event log. This provides a centralized record of events for analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_on_worbench_close", "line_number": 126, "body": "def _on_worbench_close(self, event=None):\n        import json\n\n        with open(self._filename, encoding=\"UTF-8\", mode=\"w\") as fp:\n            json.dump(self._events, fp, indent=\"    \")\n\n        self._check_compress_logs()", "is_method": true, "class_name": "EventLogger", "function_description": "Provides the service of persisting accumulated events to a JSON file when the workbench closes, followed by log compression."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "_check_compress_logs", "line_number": 134, "body": "def _check_compress_logs(self):\n        import zipfile\n\n        # if uncompressed logs have grown over 10MB,\n        # compress these into new zipfile\n\n        log_dir = _get_log_dir()\n        total_size = 0\n        uncompressed_files = []\n        for item in os.listdir(log_dir):\n            if item.endswith(\".txt\"):\n                full_name = os.path.join(log_dir, item)\n                total_size += os.stat(full_name).st_size\n                uncompressed_files.append((item, full_name))\n\n        if total_size > 10 * 1024 * 1024:\n            zip_filename = _generate_timestamp_file_name(\"zip\")\n            with zipfile.ZipFile(zip_filename, \"w\", compression=zipfile.ZIP_DEFLATED) as zipf:\n                for item, full_name in uncompressed_files:\n                    zipf.write(full_name, arcname=item)\n\n            for _, full_name in uncompressed_files:\n                os.remove(full_name)", "is_method": true, "class_name": "EventLogger", "function_description": "Periodically checks the total size of uncompressed log files. If logs exceed 10MB, it compresses them into a zip archive and deletes the originals to manage storage."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "handle", "line_number": 62, "body": "def handle(event):\n            if not only_workbench_widget or event.widget == get_workbench():\n                self._log_event(sequence, event)", "is_method": true, "class_name": "EventLogger", "function_description": "Processes an incoming event for the EventLogger. It selectively logs the event, typically based on whether it originates from the main workbench interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/event_logging.py", "function": "handle", "line_number": 69, "body": "def handle(event):\n            self._log_event(sequence, event)", "is_method": true, "class_name": "EventLogger", "function_description": "This method of EventLogger processes and logs an incoming event. It serves as the primary public interface for recording events within the system.\nThis method of EventLogger processes and logs an incoming event. It serves as the primary public interface for recording events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/clean_ui_themes.py", "function": "clean", "line_number": 9, "body": "def clean(\n    frame_background: str,\n    text_background: str,\n    normal_detail: str,\n    high_detail: str,\n    low_detail: str,\n    normal_foreground: str,\n    high_foreground: str,\n    low_foreground: str,\n    custom_menubar: Optional[\n        int\n    ] = None,  # NB! Should be 1 or 0, not True or False (Tk would convert False to \"False\")\n) -> UiThemeSettings:\n\n    # https://wiki.tcl.tk/37973 (Changing colors)\n    # https://github.com/tcltk/tk/blob/master/library/ttk/clamTheme.tcl\n    # https://github.com/tcltk/tk/blob/master/generic/ttk/ttkClamTheme.c\n\n    return {\n        \".\": {\n            \"configure\": {\n                \"foreground\": normal_foreground,\n                \"background\": frame_background,\n                \"lightcolor\": frame_background,\n                \"darkcolor\": frame_background,\n                \"bordercolor\": frame_background,\n                \"selectbackground\": high_detail,\n                \"selectforeground\": high_foreground,\n            },\n            \"map\": {\n                \"foreground\": [(\"disabled\", low_foreground), (\"active\", high_foreground)],\n                \"background\": [(\"disabled\", frame_background), (\"active\", high_detail)],\n                \"selectbackground\": [(\"!focus\", low_detail)],\n                \"selectforeground\": [(\"!focus\", normal_foreground)],\n            },\n        },\n        \"TNotebook\": {\n            # https://github.com/tcltk/tk/blob/master/generic/ttk/ttkNotebook.c\n            \"configure\": {\n                \"bordercolor\": normal_detail,\n                \"tabmargins\": [scale(1), 0, 0, 0],  # Margins around tab row\n            }\n        },\n        \"ButtonNotebook.TNotebook\": {\"configure\": {\"bordercolor\": frame_background}},\n        \"AutomaticNotebook.TNotebook\": {\"configure\": {\"bordercolor\": frame_background}},\n        \"TNotebook.Tab\": {\n            \"configure\": {\"background\": frame_background, \"bordercolor\": normal_detail},\n            \"map\": {\n                \"background\": [\n                    (\"selected\", normal_detail),\n                    (\"!selected\", \"!active\", frame_background),\n                    (\"active\", \"!selected\", high_detail),\n                ],\n                \"bordercolor\": [(\"selected\", frame_background), (\"!selected\", normal_detail)],\n                \"lightcolor\": [(\"selected\", normal_detail), (\"!selected\", frame_background)],\n            },\n        },\n        \"Treeview\": {\n            \"configure\": {\"background\": text_background, \"borderwidth\": 0, \"relief\": \"flat\"},\n            \"map\": {\n                \"background\": [\n                    (\"selected\", \"focus\", high_detail),\n                    (\"selected\", \"!focus\", low_detail),\n                ],\n                \"foreground\": [\n                    (\"selected\", \"focus\", high_foreground),\n                    (\"selected\", \"!focus\", normal_foreground),\n                ],\n            },\n        },\n        \"Treeview.Heading\": {\n            # https://stackoverflow.com/questions/32051780/how-to-edit-the-style-of-a-heading-in-treeview-python-ttk\n            \"configure\": {\n                \"background\": normal_detail,\n                \"lightcolor\": normal_detail,\n                \"borderwidth\": 0,\n            },\n            \"map\": {\"background\": [(\"!active\", normal_detail), (\"active\", normal_detail)]},\n        },\n        \"TEntry\": {\n            \"configure\": {\n                \"fieldbackground\": text_background,\n                \"lightcolor\": normal_detail,\n                \"insertcolor\": normal_foreground,\n            },\n            \"map\": {\n                \"background\": [(\"readonly\", text_background)],\n                \"bordercolor\": [],\n                \"lightcolor\": [(\"focus\", high_detail)],\n                \"darkcolor\": [],\n            },\n        },\n        \"TCombobox\": {\n            \"configure\": {\n                \"background\": text_background,\n                \"fieldbackground\": text_background,\n                \"selectbackground\": text_background,\n                \"lightcolor\": text_background,\n                \"darkcolor\": text_background,\n                \"bordercolor\": text_background,\n                \"arrowcolor\": normal_foreground,\n                \"foreground\": normal_foreground,\n                \"seleftforeground\": normal_foreground,\n                # \"padding\" : [12,2,12,2],\n            },\n            \"map\": {\n                \"background\": [(\"active\", text_background)],\n                \"fieldbackground\": [],\n                \"selectbackground\": [],\n                \"selectforeground\": [],\n                \"foreground\": [],\n                \"arrowcolor\": [],\n            },\n        },\n        \"TScrollbar\": {\n            \"configure\": {\n                \"gripcount\": 0,\n                \"borderwidth\": 0,\n                \"relief\": \"flat\",\n                \"darkcolor\": normal_detail,\n                \"lightcolor\": normal_detail,\n                \"bordercolor\": text_background,\n                \"troughcolor\": text_background,\n                # arrowcolor=\"white\"\n            },\n            \"map\": {\n                \"background\": [(\"!disabled\", normal_detail), (\"disabled\", normal_detail)],\n                \"darkcolor\": [(\"!disabled\", text_background), (\"disabled\", text_background)],\n                \"lightcolor\": [(\"!disabled\", text_background), (\"disabled\", text_background)],\n            },\n        },\n        \"Vertical.TScrollbar\": {\n            # Remove scrollbar buttons/arrows:\n            \"layout\": [\n                (\n                    \"Vertical.Scrollbar.trough\",\n                    {\n                        \"sticky\": \"ns\",\n                        \"children\": [\n                            (\"Vertical.Scrollbar.thumb\", {\"expand\": \"1\", \"sticky\": \"nswe\"})\n                        ],\n                    },\n                )\n            ]\n        },\n        \"Horizontal.TScrollbar\": {\n            # Remove scrollbar buttons/arrows:\n            \"layout\": [\n                (\n                    \"Horizontal.Scrollbar.trough\",\n                    {\n                        \"sticky\": \"we\",\n                        \"children\": [\n                            (\"Horizontal.Scrollbar.thumb\", {\"expand\": \"1\", \"sticky\": \"nswe\"})\n                        ],\n                    },\n                )\n            ],\n            \"map\": {\n                # Make disabled Hor Scrollbar invisible\n                \"background\": [(\"disabled\", frame_background), (\"!disabled\", normal_detail)],\n                \"troughcolor\": [(\"disabled\", frame_background)],\n                \"bordercolor\": [(\"disabled\", frame_background)],\n                \"darkcolor\": [(\"disabled\", frame_background)],\n                \"lightcolor\": [(\"disabled\", frame_background)],\n            },\n        },\n        \"TButton\": {\n            \"configure\": {\"background\": normal_detail, \"foreground\": normal_foreground},\n            \"map\": {\n                \"foreground\": [(\"disabled\", low_foreground), (\"alternate\", high_foreground)],\n                \"background\": [(\"pressed\", low_detail), (\"active\", high_detail)],\n                \"bordercolor\": [(\"alternate\", high_detail)],\n            },\n        },\n        \"TCheckbutton\": {\n            \"configure\": {\n                \"indicatorforeground\": normal_foreground,\n                \"indicatorbackground\": text_background,\n            },\n            \"map\": {\n                \"indicatorforeground\": [\n                    (\"disabled\", \"alternate\", low_foreground),\n                    (\"disabled\", low_foreground),\n                ],\n                \"indicatorbackground\": [\n                    (\"disabled\", \"alternate\", text_background),\n                    (\"disabled\", text_background),\n                ],\n            },\n        },\n        \"TRadiobutton\": {\n            \"configure\": {\n                \"indicatorforeground\": normal_foreground,\n                \"indicatorbackground\": text_background,\n            },\n            \"map\": {\n                \"indicatorforeground\": [\n                    (\"disabled\", \"alternate\", low_foreground),\n                    (\"disabled\", low_foreground),\n                ]\n            },\n        },\n        \"Toolbutton\": {\n            \"configure\": {\"background\": frame_background},\n            \"map\": {\"background\": [(\"disabled\", frame_background), (\"active\", high_detail)]},\n        },\n        \"TLabel\": {\"configure\": {\"foreground\": normal_foreground}},\n        \"Url.TLabel\": {\"configure\": {\"foreground\": normal_foreground}},\n        \"Tip.TLabel\": {\"configure\": {\"foreground\": normal_foreground, \"background\": low_detail}},\n        \"Tip.TFrame\": {\"configure\": {\"background\": low_detail}},\n        \"TScale\": {\n            \"configure\": {\n                \"background\": high_detail,\n                \"troughcolor\": normal_detail,\n                \"lightcolor\": high_detail,\n                \"darkcolor\": high_detail,\n                # \"bordercolor\" : \"red\",\n                # \"sliderlength\" : 40,\n                # \"sliderthickness\" : 60,\n                \"gripcount\": 0,\n            },\n            \"map\": {\"background\": [], \"troughcolor\": []},\n        },\n        \"TScale.slider\": {\n            \"configure\": {\n                \"background\": \"red\",\n                \"troughcolor\": \"yellow\",\n                \"lightcolor\": \"green\",\n                \"darkcolor\": \"white\",\n                # \"sliderlength\" : 40,\n                # \"sliderthickness\" : 60,\n            }\n        },\n        \"ViewBody.TFrame\": {\"configure\": {\"background\": text_background}},\n        \"ViewToolbar.TFrame\": {\"configure\": {\"background\": normal_detail}},\n        \"ViewToolbar.Toolbutton\": {\"configure\": {\"background\": normal_detail}},\n        \"ViewTab.TLabel\": {\"configure\": {\"background\": normal_detail, \"padding\": [5, 0]}},\n        \"ViewToolbar.TLabel\": {\n            \"configure\": {\"background\": normal_detail, \"padding\": [scale(4), 0]}\n        },\n        \"Active.ViewTab.TLabel\": {\n            \"configure\": {\n                \"foreground\": high_foreground,\n                # \"font\" : \"BoldTkDefaultFont\",\n                \"background\": text_background,\n            }\n        },\n        \"Inactive.ViewTab.TLabel\": {\n            \"configure\": {\"foreground\": normal_foreground},\n            \"map\": {\"background\": [(\"hover\", high_detail)]},\n        },\n        \"Text\": {\"configure\": {\"background\": text_background, \"foreground\": normal_foreground}},\n        \"Gutter\": {\"configure\": {\"background\": low_detail, \"foreground\": low_foreground}},\n        \"Listbox\": {\n            \"configure\": {\n                \"background\": text_background,\n                \"foreground\": normal_foreground,\n                \"selectbackground\": high_detail,\n                \"selectforeground\": high_foreground,\n                \"disabledforeground\": low_foreground,\n                \"highlightbackground\": normal_detail,\n                \"highlightcolor\": high_detail,\n                \"highlightthickness\": 1,\n            }\n        },\n        \"Menubar\": {\n            \"configure\": {\n                # Regular, system-provided Windows menubar doesn't allow changing colors.\n                # custom=True replaces it with a custom-built menubar.\n                \"custom\": running_on_windows() if custom_menubar is None else custom_menubar,\n                \"background\": frame_background,\n                \"foreground\": normal_foreground,\n                \"activebackground\": normal_foreground,\n                \"activeforeground\": frame_background,\n                \"relief\": \"flat\",\n            }\n        },\n        \"Menu\": {\n            \"configure\": {\n                \"background\": normal_detail,\n                \"foreground\": high_foreground,\n                \"selectcolor\": normal_foreground,\n                # \"borderwidth\": 0, # Interacts badly with right-clicks in Linux\n                \"activebackground\": normal_foreground,\n                \"activeforeground\": frame_background,\n                # \"activeborderwidth\": 0, # Interacts badly with right-clicks in Linux\n                \"relief\": \"flat\",\n            }\n        },\n        \"CustomMenubarLabel.TLabel\": {\n            \"configure\": {\"padding\": [scale(10), scale(2), 0, scale(15)]}\n        },\n    }", "is_method": false, "function_description": "This function generates a comprehensive UI theme configuration dictionary. It maps abstract color roles to specific styling properties for various GUI widgets, enabling a consistent visual appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/clean_ui_themes.py", "function": "load_plugin", "line_number": 305, "body": "def load_plugin() -> None:\n    dark_images = {\"tab-close-active\": \"tab-close-active-clam-dark\"}\n\n    get_workbench().add_ui_theme(\n        \"Clean Dark\",\n        \"Enhanced Clam\",\n        clean(\n            frame_background=\"#252525\",\n            text_background=\"#2d2d2d\",\n            normal_detail=\"#3D3D3D\",\n            high_detail=\"#6E6E6E\",\n            low_detail=\"#404040\",\n            normal_foreground=\"#9f9f9f\",\n            high_foreground=\"#eeeeee\",\n            low_foreground=\"#666666\",\n        ),\n        dark_images,\n    )\n\n    dark_tip_background = (\"#b8c28d\",)\n\n    get_workbench().add_ui_theme(\n        \"Clean Dark Green\",\n        \"Enhanced Clam\",\n        clean(\n            frame_background=\"#1D291A\",\n            text_background=\"#273627\",\n            normal_detail=\"#2D452F\",\n            high_detail=\"#3C6E40\",\n            low_detail=\"#33402F\",\n            normal_foreground=\"#9E9E9E\",\n            high_foreground=\"#eeeeee\",\n            low_foreground=\"#5a725b\",\n        ),\n        dark_images,\n    )\n\n    get_workbench().add_ui_theme(\n        \"Clean Dark Blue\",\n        \"Enhanced Clam\",\n        clean(\n            frame_background=\"#1A1C29\",\n            text_background=\"#272936\",\n            normal_detail=\"#2D3345\",\n            high_detail=\"#3C436E\",\n            low_detail=\"#2F3640\",\n            normal_foreground=\"#9E9E9E\",\n            high_foreground=\"#eeeeee\",\n            low_foreground=\"#5a5c72\",\n        ),\n        dark_images,\n    )\n\n    get_workbench().add_ui_theme(\n        \"Clean Sepia\",\n        \"Enhanced Clam\",\n        clean(\n            frame_background=\"#E8E7DC\",\n            text_background=\"#F7F6F0\",\n            normal_detail=\"#DEDCC8\",\n            high_detail=\"#eeebe7\",\n            low_detail=\"#D4D0B8\",\n            normal_foreground=\"#222222\",\n            high_foreground=\"#000000\",\n            low_foreground=\"#999999\",\n            custom_menubar=0,\n        ),\n    )", "is_method": false, "function_description": "Registers multiple pre-defined UI themes with the application's workbench. This allows users to customize the visual appearance, offering various color schemes like dark and sepia."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "scale", "line_number": 9, "body": "def scale(value) -> float:\n    # dimensions in this module were designed with a 1.67 scale\n    return get_workbench().scale(value / 1.67)", "is_method": false, "function_description": "Corrects an input value based on a module's inherent design scale of 1.67, then applies the global workbench scaling factor."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_treeview_settings", "line_number": 14, "body": "def _treeview_settings() -> BasicUiThemeSettings:\n    light_blue = \"#ADD8E6\"\n    light_grey = \"#D3D3D3\"\n\n    if running_on_linux() or running_on_mac_os():\n        bg_sel_focus = light_blue\n        fg_sel_focus = \"black\"\n        fg_sel_notfocus = \"black\"\n    else:\n        bg_sel_focus = \"SystemHighlight\"\n        fg_sel_focus = \"SystemHighlightText\"\n        fg_sel_notfocus = \"SystemWindowText\"\n\n    return {\n        \"Treeview\": {\n            \"configure\": {\"font\": \"TreeviewFont\"},\n            \"map\": {\n                \"background\": [\n                    (\"selected\", \"focus\", bg_sel_focus),\n                    (\"selected\", \"!focus\", light_grey),\n                ],\n                \"foreground\": [\n                    (\"selected\", \"focus\", fg_sel_focus),\n                    (\"selected\", \"!focus\", fg_sel_notfocus),\n                ],\n            },\n            \"layout\": [\n                # get rid of borders\n                (\"Treeview.treearea\", {\"sticky\": \"nswe\"})\n            ],\n        },\n        \"treearea\": {\"configure\": {\"borderwidth\": 0}},\n    }", "is_method": false, "function_description": "This function defines UI theme settings for a Treeview widget, specifying colors, fonts, and layout. It provides a consistent visual style, adapting selections based on OS and focus state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_menubutton_settings", "line_number": 49, "body": "def _menubutton_settings() -> BasicUiThemeSettings:\n    return {\n        \"TMenubutton\": {\n            \"configure\": {\"padding\": scale(14)},\n            \"layout\": [\n                (\"Menubutton.dropdown\", {\"side\": \"right\", \"sticky\": \"ns\"}),\n                (\n                    \"Menubutton.button\",\n                    {\n                        \"children\": [\n                            # ('Menubutton.padding', {'children': [\n                            (\"Menubutton.label\", {\"sticky\": \"\"})\n                            # ], 'expand': '1', 'sticky': 'we'})\n                        ],\n                        \"expand\": \"1\",\n                        \"sticky\": \"nswe\",\n                    },\n                ),\n            ],\n        }\n    }", "is_method": false, "function_description": "This internal function defines the visual configuration and layout specifications for a 'Menubutton' UI element. It provides standard theme settings for consistent styling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_paned_window_settings", "line_number": 72, "body": "def _paned_window_settings() -> BasicUiThemeSettings:\n    return {\"Sash\": {\"configure\": {\"sashthickness\": ems_to_pixels(0.6)}}}", "is_method": false, "function_description": "Provides default UI theme settings for paned window sashes, specifically configuring their thickness."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_menu_settings", "line_number": 76, "body": "def _menu_settings() -> BasicUiThemeSettings:\n    return {\"Menubar\": {\"configure\": {\"activeborderwidth\": 0, \"relief\": \"flat\"}}}", "is_method": false, "function_description": "This internal helper function provides a fixed dictionary of basic theme settings, defining specific visual configurations for a UI menubar component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_text_settings", "line_number": 80, "body": "def _text_settings() -> BasicUiThemeSettings:\n    return {\n        \"Text\": {\n            \"configure\": {\n                \"background\": \"SystemWindow\" if running_on_windows() else \"white\",\n                \"foreground\": \"SystemWindowText\" if running_on_windows() else \"black\",\n            }\n        },\n        \"Syntax.Text\": {\"map\": {\"background\": [(\"readonly\", \"Yellow\")]}},\n        \"Gutter\": {\"configure\": {\"background\": \"#e0e0e0\", \"foreground\": \"#999999\"}},\n    }", "is_method": false, "function_description": "This function provides default UI theme settings for various text display components. It configures colors for text, syntax highlighting, and the gutter, with some settings being OS-dependent."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_link_settings", "line_number": 93, "body": "def _link_settings() -> BasicUiThemeSettings:\n    tip_background = \"#b8c28d\"\n    tip_background = \"systemInfoBackground\"\n    return {\n        \"Url.TLabel\": {\"configure\": {\"foreground\": \"DarkBlue\"}},\n        \"Tip.TLabel\": {\"configure\": {\"background\": tip_background, \"foreground\": \"black\"}},\n        \"Tip.TFrame\": {\"configure\": {\"background\": tip_background}},\n    }", "is_method": false, "function_description": "Generates a predefined dictionary of basic UI theme settings, configuring visual styles for specific interface elements like URL labels and tooltips."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "_button_notebook_settings", "line_number": 103, "body": "def _button_notebook_settings() -> BasicUiThemeSettings:\n    # Adapted from https://github.com/python/cpython/blob/2.7/Demo/tkinter/ttk/notebook_closebtn.py\n    return {\n        \"closebutton\": {\n            \"element create\": (\n                \"image\",\n                \"img_close\",\n                (\"active\", \"pressed\", \"!disabled\", \"img_close_active\"),\n                (\"active\", \"!disabled\", \"img_close_active\"),\n                {\"padding\": scale(2), \"sticky\": \"\"},\n            )\n        },\n        \"ButtonNotebook.TNotebook.Tab\": {\n            \"layout\": [\n                (\n                    \"Notebook.tab\",\n                    {\n                        \"sticky\": \"nswe\",\n                        \"children\": [\n                            (\n                                \"Notebook.padding\",\n                                {\n                                    \"side\": \"top\",\n                                    \"sticky\": \"nswe\",\n                                    \"children\": [\n                                        (\n                                            \"Notebook.focus\",\n                                            {\n                                                \"side\": \"left\",\n                                                \"sticky\": \"nswe\",\n                                                \"children\": [\n                                                    (\n                                                        \"Notebook.label\",\n                                                        {\"side\": \"left\", \"sticky\": \"\"},\n                                                    )\n                                                ],\n                                            },\n                                        ),\n                                        (\"Notebook.closebutton\", {\"side\": \"right\", \"sticky\": \"\"}),\n                                    ],\n                                },\n                            )\n                        ],\n                    },\n                )\n            ]\n        },\n    }", "is_method": false, "function_description": "This function defines comprehensive UI theme settings for a notebook tab, including the visual design and layout of its integrated close button. It provides a reusable configuration for customized tab appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "clam", "line_number": 153, "body": "def clam() -> BasicUiThemeSettings:\n    # Transcribed from https://github.com/tcltk/tk/blob/master/library/ttk/clamTheme.tcl\n    defaultfg = \"#000000\"\n    disabledfg = \"#999999\"\n    frame = \"#dcdad5\"\n    window = \"#ffffff\"\n    dark = \"#cfcdc8\"\n    darker = \"#bab5ab\"\n    darkest = \"#9e9a91\"\n    lighter = \"#eeebe7\"\n    selectbg = \"#4a6984\"\n    selectfg = \"#ffffff\"\n    altindicator = \"#5895bc\"\n    disabledaltindicator = \"#a0a0a0\"\n\n    return {\n        \".\": {\n            \"configure\": {\n                \"background\": frame,\n                \"foreground\": defaultfg,\n                \"bordercolor\": darkest,\n                \"darkcolor\": dark,\n                \"lightcolor\": lighter,\n                \"troughcolor\": darker,\n                \"selectbackground\": selectbg,\n                \"selectforeground\": selectfg,\n                \"selectborderwidth\": 0,\n                \"font\": \"TkDefaultFont\",\n            },\n            \"map\": {\n                \"background\": [(\"disabled\", frame), (\"active\", lighter)],\n                \"foreground\": [(\"disabled\", disabledfg)],\n                \"selectbackground\": [(\"!focus\", darkest)],\n                \"selectforeground\": [(\"!focus\", \"white\")],\n            },\n        },\n        \"TButton\": {\n            \"configure\": {\n                \"anchor\": \"center\",\n                \"width\": scale(11),\n                \"padding\": scale(5),\n                \"relief\": \"raised\",\n            },\n            \"map\": {\n                \"background\": [(\"disabled\", frame), (\"pressed\", darker), (\"active\", lighter)],\n                \"lightcolor\": [(\"pressed\", darker)],\n                \"darkcolor\": [(\"pressed\", darker)],\n                \"bordercolor\": [(\"alternate\", \"#000000\")],\n            },\n        },\n        \"Toolbutton\": {\n            \"configure\": {\"anchor\": \"center\", \"padding\": scale(2), \"relief\": \"flat\"},\n            \"map\": {\n                \"relief\": [\n                    (\"disabled\", \"flat\"),\n                    (\"selected\", \"sunken\"),\n                    (\"pressed\", \"sunken\"),\n                    (\"active\", \"raised\"),\n                ],\n                \"background\": [(\"disabled\", frame), (\"pressed\", darker), (\"active\", lighter)],\n                \"lightcolor\": [(\"pressed\", darker)],\n                \"darkcolor\": [(\"pressed\", darker)],\n            },\n        },\n        \"TCheckbutton\": {\n            \"configure\": {\n                \"indicatorbackground\": \"#ffffff\",\n                \"indicatormargin\": [scale(1), scale(1), scale(6), scale(1)],\n                \"padding\": scale(2),\n            },\n            \"map\": {\n                \"indicatorbackground\": [\n                    (\"pressed\", frame),\n                    (\"!disabled\", \"alternate\", altindicator),\n                    (\"disabled\", \"alternate\", disabledaltindicator),\n                    (\"disabled\", frame),\n                ]\n            },\n        },\n        # TRadiobutton has same style as TCheckbutton\n        \"TRadiobutton\": {\n            \"configure\": {\n                \"indicatorbackground\": \"#ffffff\",\n                \"indicatormargin\": [scale(1), scale(1), scale(6), scale(1)],\n                \"padding\": scale(2),\n            },\n            \"map\": {\n                \"indicatorbackground\": [\n                    (\"pressed\", frame),\n                    (\"!disabled\", \"alternate\", altindicator),\n                    (\"disabled\", \"alternate\", disabledaltindicator),\n                    (\"disabled\", frame),\n                ]\n            },\n        },\n        \"TMenubutton\": {\"configure\": {\"width\": scale(11), \"padding\": scale(5), \"relief\": \"raised\"}},\n        \"TEntry\": {\n            \"configure\": {\"padding\": scale(1), \"insertwidth\": scale(1)},\n            \"map\": {\n                \"background\": [(\"readonly\", frame)],\n                \"bordercolor\": [(\"focus\", selectbg)],\n                \"lightcolor\": [(\"focus\", \"#6f9dc6\")],\n                \"darkcolor\": [(\"focus\", \"#6f9dc6\")],\n            },\n        },\n        \"TCombobox\": {\n            \"configure\": {\n                \"padding\": [scale(4), scale(2), scale(2), scale(2)],\n                \"insertwidth\": scale(1),\n            },\n            \"map\": {\n                \"background\": [(\"active\", lighter), (\"pressed\", lighter)],\n                \"fieldbackground\": [(\"readonly\", \"focus\", selectbg), (\"readonly\", frame)],\n                \"foreground\": [(\"readonly\", \"focus\", selectfg)],\n                \"arrowcolor\": [(\"disabled\", disabledfg)],\n            },\n        },\n        \"ComboboxPopdownFrame\": {\"configure\": {\"relief\": \"solid\", \"borderwidth\": scale(1)}},\n        \"TSpinbox\": {\n            \"configure\": {\"arrowsize\": scale(10), \"padding\": [scale(2), 0, scale(10), 0]},\n            \"map\": {\"background\": [(\"readonly\", frame)], \"arrowcolor\": [(\"disabled\", disabledfg)]},\n        },\n        \"TNotebook.Tab\": {\n            \"configure\": {\"padding\": [scale(6), scale(2), scale(6), scale(2)]},\n            \"map\": {\n                \"padding\": [(\"selected\", [scale(6), scale(4), scale(6), scale(4)])],\n                \"background\": [(\"selected\", frame), (\"\", darker)],\n                \"lightcolor\": [(\"selected\", lighter), (\"\", dark)],\n            },\n        },\n        \"Treeview\": {\n            \"configure\": {\"background\": window},\n            \"map\": {\n                \"background\": [\n                    (\"disabled\", frame),\n                    (\"!disabled\", \"!selected\", window),\n                    (\"selected\", selectbg),\n                ],\n                \"foreground\": [\n                    (\"disabled\", disabledfg),\n                    (\"!disabled\", \"!selected\", defaultfg),\n                    (\"selected\", selectfg),\n                ],\n            },\n        },\n        # Treeview heading\n        \"Heading\": {\n            \"configure\": {\n                \"font\": \"TkHeadingFont\",\n                \"relief\": \"raised\",\n                \"padding\": [scale(3), scale(3), scale(3), scale(3)],\n            }\n        },\n        \"TLabelframe\": {\"configure\": {\"labeloutside\": True, \"labelmargins\": [0, 0, 0, scale(4)]}},\n        \"TProgressbar\": {\"configure\": {\"background\": frame}},\n        \"Sash\": {\"configure\": {\"sashthickness\": ems_to_pixels(0.6), \"gripcount\": 10}},\n    }", "is_method": false, "function_description": "This function defines and returns the complete configuration settings for the \"Clam\" user interface theme. It provides consistent visual styles, including colors and layouts, for various UI widgets."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "xpnative", "line_number": 312, "body": "def xpnative() -> BasicUiThemeSettings:\n    # Transcribed from https://github.com/tcltk/tk/blob/master/library/ttk/xpTheme.tcl\n    return {\n        \".\": {\n            \"configure\": {\n                \"background\": \"SystemButtonFace\",\n                \"foreground\": \"SystemWindowText\",\n                \"selectbackground\": \"SystemHighlight\",\n                \"selectforeground\": \"SystemHighlightText\",\n                \"font\": \"TkDefaultFont\",\n            },\n            \"map\": {\"foreground\": [(\"disabled\", \"SystemGrayText\")]},\n        },\n        \"TButton\": {\n            \"configure\": {\"anchor\": \"center\", \"width\": scale(11), \"padding\": [scale(1), scale(1)]}\n        },\n        \"Toolbutton\": {\"configure\": {\"padding\": [scale(4), scale(4)]}},\n        \"TCheckbutton\": {\"configure\": {\"padding\": scale(2)}},\n        # TRadiobutton has same style as TCheckbutton\n        \"TRadiobutton\": {\"configure\": {\"padding\": scale(2)}},\n        \"TMenubutton\": {\"configure\": {\"padding\": [scale(8), scale(4)]}},\n        \"TEntry\": {\n            \"configure\": {\"padding\": [scale(2), scale(2), scale(2), scale(4)]},\n            \"map\": {\n                \"selectbackground\": [(\"!focus\", \"SystemWindow\")],\n                \"selectforeground\": [(\"!focus\", \"SystemWindowText\")],\n            },\n        },\n        \"TCombobox\": {\n            \"configure\": {\"padding\": scale(2)},\n            \"map\": {\n                \"selectbackground\": [(\"!focus\", \"SystemWindow\")],\n                \"selectforeground\": [(\"!focus\", \"SystemWindowText\")],\n                \"foreground\": [\n                    (\"disabled\", \"SystemGrayText\"),\n                    (\"readonly\", \"focus\", \"SystemHighlightText\"),\n                ],\n                \"focusfill\": [(\"readonly\", \"focus\", \"SystemHighlight\")],\n            },\n        },\n        \"ComboboxPopdownFrame\": {\"configure\": {\"relief\": \"solid\", \"borderwidth\": scale(1)}},\n        \"TSpinbox\": {\n            \"configure\": {\"padding\": [scale(2), 0, scale(14), 0]},\n            \"map\": {\n                \"selectbackground\": [(\"!focus\", \"SystemWindow\")],\n                \"selectforeground\": [(\"!focus\", \"SystemWindowText\")],\n            },\n        },\n        \"TNotebook\": {\"configure\": {\"tabmargins\": [scale(2), scale(2), scale(2), 0]}},\n        \"TNotebook.Tab\": {\n            \"map\": {\"expand\": [(\"selected\", [scale(2), scale(2), scale(2), scale(2)])]}\n        },\n        \"Treeview\": {\n            \"configure\": {\"background\": \"SystemWindow\"},\n            \"map\": {\n                \"background\": [\n                    (\"disabled\", \"SystemButtonFace\"),\n                    (\"!disabled\", \"!selected\", \"SystemWindow\"),\n                    (\"selected\", \"SystemHighlight\"),\n                ],\n                \"foreground\": [\n                    (\"disabled\", \"SystemGrayText\"),\n                    (\"!disabled\", \"!selected\", \"SystemWindowText\"),\n                    (\"selected\", \"SystemHighlightText\"),\n                ],\n            },\n        },\n        \"Heading\": {\"configure\": {\"font\": \"TkHeadingFont\", \"relief\": \"raised\"}},  # Treeview heading\n        \"TLabelframe.Label\": {\"configure\": {\"foreground\": \"#0046d5\"}},\n    }", "is_method": false, "function_description": "Provides a predefined dictionary of UI theme settings for various widgets, replicating the appearance of the Windows XP native theme. It enables applications to adopt a consistent, system-like look and feel."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "aqua", "line_number": 384, "body": "def aqua() -> BasicUiThemeSettings:\n    # https://github.com/tcltk/tk/blob/master/library/ttk/aquaTheme.tcl\n    return {\n        \".\": {\n            \"configure\": {\n                \"font\": \"TkDefaultFont\",\n                \"background\": \"systemWindowBody\",\n                \"foreground\": \"systemModelessDialogActiveText\",\n                \"selectbackground\": \"systemHighlight\",\n                \"selectforeground\": \"systemModelessDialogActiveText\",\n                \"selectborderwidth\": 0,\n                \"insertwidth\": 1,\n                \"stipple\": \"\",\n            },\n            \"map\": {\n                \"foreground\": [\n                    (\"disabled\", \"systemModelessDialogInactiveText\"),\n                    (\"background\", \"systemModelessDialogInactiveText\"),\n                ],\n                \"selectbackground\": [\n                    (\"background\", \"systemHighlightSecondary\"),\n                    (\"!focus\", \"systemHighlightSecondary\"),\n                ],\n                \"selectforeground\": [\n                    (\"background\", \"systemModelessDialogInactiveText\"),\n                    (\"!focus\", \"systemDialogActiveText\"),\n                ],\n            },\n        },\n        \"TButton\": {\"configure\": {\"anchor\": \"center\", \"width\": \"6\"}},\n        \"Toolbutton\": {\"configure\": {\"padding\": 4}},\n        \"TNotebook\": {\n            \"configure\": {\"tabmargins\": [10, 0], \"tabposition\": \"n\", \"padding\": [18, 8, 18, 17]}\n        },\n        \"TNotebook.Tab\": {\"configure\": {\"padding\": [12, 3, 12, 2]}},\n        \"TCombobox\": {\"configure\": {\"postoffset\": [5, -2, -10, 0]}},\n        \"Heading\": {\"configure\": {\"font\": \"TkHeadingFont\"}},\n        \"Treeview\": {\n            \"configure\": {\"rowheight\": 18, \"background\": \"white\"},\n            \"map\": {\n                \"background\": [\n                    (\"disabled\", \"systemDialogBackgroundInactive\"),\n                    (\"!disabled\", \"!selected\", \"systemWindowBody\"),\n                    (\"selected\", \"background\", \"systemHighlightSecondary\"),\n                    (\"selected\", \"systemHighlight\"),\n                ],\n                \"foreground\": [\n                    (\"disabled\", \"systemModelessDialogInactiveText\"),\n                    (\"!disabled\", \"!selected\", \"black\"),\n                    (\"selected\", \"systemModelessDialogActiveText\"),\n                ],\n            },\n        },\n        \"TProgressbar\": {\"configure\": {\"period\": 100, \"maxphase\": 255}},\n        \"Labelframe\": {\"configure\": {\"labeloutside\": True, \"labelmargins\": [14, 0, 14, 4]}},\n    }", "is_method": false, "function_description": "Provides a complete set of configuration settings for the Tkinter Aqua UI theme. It defines visual properties like fonts, colors, and padding for various widgets."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "windows", "line_number": 442, "body": "def windows() -> CompoundUiThemeSettings:\n    tip_background = \"#bbbbbb\"\n    return [\n        xpnative(),\n        _treeview_settings(),\n        _menubutton_settings(),\n        _paned_window_settings(),\n        _menu_settings(),\n        _text_settings(),\n        _link_settings(),\n        _button_notebook_settings(),\n        {\n            \"Tip.TLabel\": {\"configure\": {\"background\": tip_background, \"foreground\": \"black\"}},\n            \"Tip.TFrame\": {\"configure\": {\"background\": tip_background}},\n        },\n        {\n            \"TNotebook\": {\n                \"configure\": {\n                    # With tabmargins I can get a gray line below tab, which separates\n                    # tab content from label\n                    \"tabmargins\": [scale(2), scale(2), scale(2), scale(2)]\n                }\n            },\n            \"Tab\": {\"configure\": {\"padding\": [scale(3), scale(1), scale(3), 0]}},\n            \"ButtonNotebook.TNotebook.Tab\": {\n                \"configure\": {\"padding\": (scale(4), scale(1), scale(1), 0)}\n            },\n            \"TCombobox\": {\n                \"map\": {\n                    \"selectbackground\": [\n                        (\"readonly\", \"!focus\", \"SystemWindow\"),\n                        (\"readonly\", \"focus\", \"SystemHighlight\"),\n                    ],\n                    \"selectforeground\": [\n                        (\"readonly\", \"!focus\", \"SystemWindowText\"),\n                        (\"readonly\", \"focus\", \"SystemHighlightText\"),\n                    ],\n                }\n            },\n            \"Listbox\": {\n                \"configure\": {\n                    \"background\": \"SystemWindow\",\n                    \"foreground\": \"SystemWindowText\",\n                    \"disabledforeground\": \"SystemGrayText\",\n                    \"highlightbackground\": \"SystemActiveBorder\",\n                    \"highlightcolor\": \"SystemActiveBorder\",\n                    \"highlightthickness\": scale(1),\n                }\n            },\n            \"ViewBody.TFrame\": {\n                \"configure\": {\n                    \"background\": \"SystemButtonFace\"  # to create the fine line below toolbar\n                }\n            },\n            \"ViewToolbar.TFrame\": {\"configure\": {\"background\": \"SystemWindow\"}},\n            \"ViewToolbar.Toolbutton\": {\"configure\": {\"background\": \"SystemWindow\"}},\n            \"ViewTab.TLabel\": {\n                \"configure\": {\"background\": \"SystemWindow\", \"padding\": [scale(5), 0]}\n            },\n            \"ViewToolbar.TLabel\": {\n                \"configure\": {\"background\": \"SystemWindow\", \"padding\": [scale(5), 0]}\n            },\n            \"ViewToolbar.Link.TLabel\": {\n                \"configure\": {\"background\": \"SystemWindow\", \"padding\": [scale(5), 0]}\n            },\n            \"Active.ViewTab.TLabel\": {\n                \"configure\": {\n                    # \"font\" : \"BoldTkDefaultFont\",\n                    \"relief\": \"sunken\",\n                    \"borderwidth\": scale(1),\n                }\n            },\n            \"Inactive.ViewTab.TLabel\": {\"map\": {\"relief\": [(\"hover\", \"raised\")]}},\n        },\n    ]", "is_method": false, "function_description": "Provides a complete UI theme configuration, defining visual styles for various widgets to achieve a Windows-like appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "enhanced_clam", "line_number": 519, "body": "def enhanced_clam() -> CompoundUiThemeSettings:\n    tip_background = \"#bab5ab\"\n    return [\n        clam(),\n        _treeview_settings(),\n        _menubutton_settings(),\n        _paned_window_settings(),\n        _menu_settings(),\n        _text_settings(),\n        _link_settings(),\n        {\n            \"Tip.TLabel\": {\"configure\": {\"background\": tip_background, \"foreground\": \"black\"}},\n            \"Tip.TFrame\": {\"configure\": {\"background\": tip_background}},\n        },\n        _button_notebook_settings(),\n        {\n            \"ButtonNotebook.Tab\": {\n                \"configure\": {\"padding\": (scale(6), scale(4), scale(2), scale(3))}\n            },\n            \"TScrollbar\": {\n                \"configure\": {\n                    \"gripcount\": 0,\n                    \"arrowsize\": scale(14),\n                    # \"arrowcolor\" : \"DarkGray\"\n                    # \"width\" : 99 # no effect\n                }\n            },\n            \"TCombobox\": {\n                \"configure\": {\"arrowsize\": scale(14)},\n                \"map\": {\n                    \"selectbackground\": [(\"readonly\", \"!focus\", \"#dcdad5\")],\n                    \"selectforeground\": [(\"readonly\", \"!focus\", \"#000000\")],\n                },\n            },\n            \"TCheckbutton\": {\"configure\": {\"indicatorsize\": scale(12)}},\n            \"TRadiobutton\": {\"configure\": {\"indicatorsize\": scale(12)}},\n            \"Listbox\": {\n                \"configure\": {\n                    \"background\": \"white\",\n                    \"foreground\": \"black\",\n                    \"disabledforeground\": \"#999999\",\n                    \"highlightbackground\": \"#4a6984\",\n                    \"highlightcolor\": \"#4a6984\",\n                    \"highlightthickness\": scale(1),\n                }\n            },\n            \"ViewTab.TLabel\": {\"configure\": {\"padding\": [scale(5), 0]}},\n            \"Active.ViewTab.TLabel\": {\n                \"configure\": {\n                    # \"font\" : \"BoldTkDefaultFont\",\n                    \"relief\": \"sunken\",\n                    \"borderwidth\": scale(1),\n                }\n            },\n            \"Inactive.ViewTab.TLabel\": {\"map\": {\"relief\": [(\"hover\", \"raised\")]}},\n        },\n    ]", "is_method": false, "function_description": "This function generates a comprehensive set of customized user interface (UI) theme settings. It enhances the default 'clam' theme for various Tkinter widgets."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "enhanced_aqua", "line_number": 578, "body": "def enhanced_aqua() -> CompoundUiThemeSettings:\n    return [\n        _treeview_settings(),\n        _menubutton_settings(),\n        # _paned_window_settings(),\n        _menu_settings(),\n        {\n            \"TPanedWindow\": {\"configure\": {\"background\": \"systemDialogBackgroundActive\"}},\n            \"TFrame\": {\"configure\": {\"background\": \"systemDialogBackgroundActive\"}},\n            \"Tab\": {\"map\": {\"foreground\": [(\"selected\", \"white\")]}},\n            \"ViewTab.TLabel\": {\"configure\": {\"padding\": [scale(5), 0]}},\n            \"Active.ViewTab.TLabel\": {\n                \"configure\": {\n                    # \"font\" : \"BoldTkDefaultFont\",\n                    \"relief\": \"sunken\",\n                    \"borderwidth\": scale(1),\n                }\n            },\n            \"Inactive.ViewTab.TLabel\": {\"map\": {\"relief\": [(\"hover\", \"raised\")]}},\n        },\n    ]", "is_method": false, "function_description": "Configures and returns a comprehensive set of UI theme settings, providing an enhanced Aqua-like visual style for various GUI components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/base_ui_themes.py", "function": "load_plugin", "line_number": 601, "body": "def load_plugin() -> None:\n    from tkinter import ttk\n\n    original_themes = ttk.Style().theme_names()\n\n    # load all base themes\n    for name in original_themes:\n        settings = {}  # type: Union[Dict, Callable[[], Dict]]\n        if name == \"clam\":\n            settings = clam\n        elif name == \"xpnative\":\n            settings = xpnative\n        elif name == \"aqua\":\n            settings = aqua\n\n        get_workbench().add_ui_theme(name, None, settings)\n\n    get_workbench().add_ui_theme(\n        \"Enhanced Clam\",\n        \"clam\",\n        enhanced_clam,\n        {\"tab-close\": \"tab-close-clam\", \"tab-close-active\": \"tab-close-active-clam\"},\n    )\n\n    if \"xpnative\" in original_themes:\n        get_workbench().add_ui_theme(\"Windows\", \"xpnative\", windows)\n\n    if \"aqua\" in original_themes:\n        get_workbench().add_ui_theme(\"Kind of Aqua\", \"aqua\", enhanced_aqua)", "is_method": false, "function_description": "Loads and registers a collection of user interface themes, including default Tkinter styles and custom enhanced variations. It makes these themes available for selection within the application's workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/shell_config_page.py", "function": "load_plugin", "line_number": 72, "body": "def load_plugin() -> None:\n    get_workbench().add_configuration_page(\"shell\", tr(\"Shell\"), ShellConfigurationPage, 70)", "is_method": false, "function_description": "Registers the 'Shell' configuration page within the application's workbench. This makes the shell settings accessible via the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/dock_user_windows_frontend.py", "function": "toggle_variable", "line_number": 9, "body": "def toggle_variable():\n    var = get_workbench().get_variable(_OPTION_NAME)\n    var.set(not var.get())\n    update_environment()", "is_method": false, "function_description": "This function toggles the boolean state of a predefined workbench option, then triggers an environment update to reflect the change."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/dock_user_windows_frontend.py", "function": "update_environment", "line_number": 15, "body": "def update_environment():\n    os.environ[\"DOCK_USER_WINDOWS\"] = str(get_workbench().get_option(_OPTION_NAME))", "is_method": false, "function_description": "Sets the 'DOCK_USER_WINDOWS' environment variable based on a workbench configuration option. This synchronizes an application setting with the operating system environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/dock_user_windows_frontend.py", "function": "on_window_appear", "line_number": 19, "body": "def on_window_appear(event):\n    get_workbench().become_active_window(force=False)", "is_method": false, "function_description": "Handles a window appearance event by making the current window the active one within the application's workbench, without forcing activation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/dock_user_windows_frontend.py", "function": "load_plugin", "line_number": 23, "body": "def load_plugin():\n    get_workbench().set_default(_OPTION_NAME, False)\n    get_workbench().add_command(\n        \"toggle_dock_user_windows\",\n        \"run\",\n        tr(\"Dock user windows\"),\n        toggle_variable,\n        flag_name=_OPTION_NAME,\n        group=40,\n    )\n    update_environment()\n\n    get_workbench().bind(\"UserWindowAppeared\", on_window_appear, True)", "is_method": false, "function_description": "This function initializes and configures a plugin for an application's workbench, adding a command to toggle user window docking. It also sets up an event handler to manage newly appearing user windows."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/assistant_config_page.py", "function": "load_plugin", "line_number": 72, "body": "def load_plugin():\n    get_workbench().add_configuration_page(\"assistant\", tr(\"Assistant\"), AssistantConfigPage, 80)", "is_method": false, "function_description": "Registers the configuration page for an 'assistant' plugin with the main application's workbench, enabling users to customize its settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/assistant_config_page.py", "function": "apply", "line_number": 61, "body": "def apply(self):\n        disabled_checks_str = (\n            self.disabled_checks_box.text.get(\"1.0\", \"end\")\n            .replace(\"\\r\", \"\")\n            .replace('\"', \"\")\n            .replace(\"'\", \"\")\n            .strip()\n        )\n        get_workbench().set_option(\"assistance.disabled_checks\", disabled_checks_str.splitlines())", "is_method": true, "class_name": "AssistantConfigPage", "function_description": "Applies user-defined settings for an assistant feature. It parses and cleans a list of disabled checks from a text box, then updates the application's configuration."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_find_closest_containing_node", "line_number": 151, "body": "def _find_closest_containing_node(tree, text_range):\n    # first look among children\n    for child in ast.iter_child_nodes(tree):\n        result = _find_closest_containing_node(child, text_range)\n        if result is not None:\n            return result\n\n    # no suitable child was found\n    if hasattr(tree, \"lineno\") and range_contains_smaller(\n        TextRange(tree.lineno, tree.col_offset, tree.end_lineno, tree.end_col_offset), text_range\n    ):\n        return tree\n    # nope\n    else:\n        return None", "is_method": false, "function_description": "Recursively finds the most specific Abstract Syntax Tree (AST) node in a given tree that completely contains a specified text range. It's crucial for mapping source code locations to their structural representation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "pretty", "line_number": 168, "body": "def pretty(node, key=\"/\", level=0):\n    \"\"\"Used for exporting ASTView content\"\"\"\n    if isinstance(node, ast.AST):\n        fields = list(ast.iter_fields(node))\n        value_label = node.__class__.__name__\n        if isinstance(node, ast.Call):\n            # Try to make 3.4 AST-s more similar to 3.5\n            if sys.version_info[:2] == (3, 4):\n                if (\"kwargs\", None) in fields:\n                    fields.remove((\"kwargs\", None))\n                if (\"starargs\", None) in fields:\n                    fields.remove((\"starargs\", None))\n\n            # TODO: translate also non-None kwargs and starargs\n\n    elif isinstance(node, list):\n        fields = list(enumerate(node))\n        if len(node) == 0:\n            value_label = \"[]\"\n        else:\n            value_label = \"[...]\"\n    else:\n        fields = []\n        value_label = repr(node)\n\n    item_text = level * \"    \" + str(key) + \"=\" + value_label\n\n    if hasattr(node, \"lineno\"):\n        item_text += \" @ \" + str(getattr(node, \"lineno\"))\n        if hasattr(node, \"col_offset\"):\n            item_text += \".\" + str(getattr(node, \"col_offset\"))\n\n        if hasattr(node, \"end_lineno\"):\n            item_text += \"  -  \" + str(getattr(node, \"end_lineno\"))\n            if hasattr(node, \"end_col_offset\"):\n                item_text += \".\" + str(getattr(node, \"end_col_offset\"))\n\n    lines = [item_text] + [\n        pretty(field_value, field_key, level + 1) for field_key, field_value in fields\n    ]\n\n    return \"\\n\".join(lines)", "is_method": false, "function_description": "Recursively generates a human-readable, indented string representation of a Python Abstract Syntax Tree (AST) node or a list. It helps visualize the AST's structure and associated details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "load_plugin", "line_number": 212, "body": "def load_plugin() -> None:\n    get_workbench().add_view(AstView, tr(\"Program tree\"), \"s\")", "is_method": false, "function_description": "The `load_plugin` function integrates an Abstract Syntax Tree (AST) view into the application's workbench. This enables users to visualize and inspect the program's structural representation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_update", "line_number": 49, "body": "def _update(self, event):\n        if not self.winfo_ismapped():\n            return\n\n        editor = get_workbench().get_editor_notebook().get_current_editor()\n\n        if not editor:\n            self._current_code_view = None\n            return\n\n        new_cw = editor.get_code_view()\n        new_source = new_cw.get_content_as_bytes()\n        if self._current_code_view == new_cw and self._current_source == new_source:\n            return\n\n        self._current_code_view = new_cw\n        self._current_source = new_source\n        selection = self._current_code_view.get_selected_range()\n\n        self._clear_tree()\n\n        if not self._current_source.strip():\n            return\n\n        try:\n            root = ast_utils.parse_source(self._current_source, fallback_to_one_char=True)\n            selected_ast_node = _find_closest_containing_node(root, selection)\n\n        except Exception as e:\n            self.tree.insert(\"\", \"end\", text=str(e), open=True)\n            logger.exception(\"Could not select AST node\", exc_info=e)\n            return\n\n        def _format(key, node, parent_id):\n\n            if isinstance(node, ast.AST):\n                fields = list(ast.iter_fields(node))\n\n                value_label = node.__class__.__name__\n\n            elif isinstance(node, list):\n                fields = list(enumerate(node))\n                if len(node) == 0:\n                    value_label = \"[]\"\n                else:\n                    value_label = \"[...]\"\n            else:\n                fields = []\n                value_label = repr(node)\n\n            item_text = str(key) + \"=\" + value_label\n            node_id = self.tree.insert(parent_id, \"end\", text=item_text, open=True)\n            if node == selected_ast_node:\n                self.tree.see(node_id)\n                self.tree.selection_add(node_id)\n\n            if hasattr(node, \"lineno\") and hasattr(node, \"col_offset\"):\n                self.tree.set(node_id, \"lineno\", node.lineno)\n                self.tree.set(node_id, \"col_offset\", node.col_offset)\n\n                range_str = str(node.lineno) + \".\" + str(node.col_offset)\n                if hasattr(node, \"end_lineno\") and hasattr(node, \"end_col_offset\"):\n                    self.tree.set(node_id, \"end_lineno\", node.end_lineno)\n                    self.tree.set(node_id, \"end_col_offset\", node.end_col_offset)\n                    range_str += \"  -  \" + str(node.end_lineno) + \".\" + str(node.end_col_offset)\n                else:\n                    # fallback\n                    self.tree.set(node_id, \"end_lineno\", node.lineno)\n                    self.tree.set(node_id, \"end_col_offset\", node.col_offset + 1)\n\n                self.tree.set(node_id, \"range\", range_str)\n\n            for field_key, field_value in fields:\n                _format(field_key, field_value, node_id)\n\n        _format(\"root\", root, \"\")", "is_method": true, "class_name": "AstView", "function_description": "Updates the Abstract Syntax Tree (AST) view by parsing the active editor's code. It visualizes the code structure in a tree, highlighting the node corresponding to the current selection for user navigation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_locate_code", "line_number": 126, "body": "def _locate_code(self, event):\n        if self._current_code_view is None:\n            return\n\n        iid = self.tree.focus()\n\n        if iid != \"\":\n            values = self.tree.item(iid)[\"values\"]\n            if isinstance(values, list) and len(values) >= 5:\n                start_line, start_col, end_line, end_col = values[1:5]\n                self._current_code_view.select_range(\n                    TextRange(start_line, start_col, end_line, end_col)\n                )", "is_method": true, "class_name": "AstView", "function_description": "This `AstView` method synchronizes a tree view selection with a code view. It locates and highlights the corresponding code span based on the selected tree item's metadata."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_clear_tree", "line_number": 140, "body": "def _clear_tree(self):\n        for child_id in self.tree.get_children():\n            self.tree.delete(child_id)", "is_method": true, "class_name": "AstView", "function_description": "Clears all displayed nodes from the GUI's AST tree view. This prepares the view for rendering a new Abstract Syntax Tree."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_copy_to_clipboard", "line_number": 144, "body": "def _copy_to_clipboard(self, event):\n        self.clipboard_clear()\n        if self._current_source is not None:\n            pretty_ast = pretty(ast_utils.parse_source(self._current_source))\n            self.clipboard_append(pretty_ast)", "is_method": true, "class_name": "AstView", "function_description": "Copies a prettified Abstract Syntax Tree (AST) of the current source code to the clipboard. This provides an easily sharable, human-readable structural representation of the code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/ast_view.py", "function": "_format", "line_number": 82, "body": "def _format(key, node, parent_id):\n\n            if isinstance(node, ast.AST):\n                fields = list(ast.iter_fields(node))\n\n                value_label = node.__class__.__name__\n\n            elif isinstance(node, list):\n                fields = list(enumerate(node))\n                if len(node) == 0:\n                    value_label = \"[]\"\n                else:\n                    value_label = \"[...]\"\n            else:\n                fields = []\n                value_label = repr(node)\n\n            item_text = str(key) + \"=\" + value_label\n            node_id = self.tree.insert(parent_id, \"end\", text=item_text, open=True)\n            if node == selected_ast_node:\n                self.tree.see(node_id)\n                self.tree.selection_add(node_id)\n\n            if hasattr(node, \"lineno\") and hasattr(node, \"col_offset\"):\n                self.tree.set(node_id, \"lineno\", node.lineno)\n                self.tree.set(node_id, \"col_offset\", node.col_offset)\n\n                range_str = str(node.lineno) + \".\" + str(node.col_offset)\n                if hasattr(node, \"end_lineno\") and hasattr(node, \"end_col_offset\"):\n                    self.tree.set(node_id, \"end_lineno\", node.end_lineno)\n                    self.tree.set(node_id, \"end_col_offset\", node.end_col_offset)\n                    range_str += \"  -  \" + str(node.end_lineno) + \".\" + str(node.end_col_offset)\n                else:\n                    # fallback\n                    self.tree.set(node_id, \"end_lineno\", node.lineno)\n                    self.tree.set(node_id, \"end_col_offset\", node.col_offset + 1)\n\n                self.tree.set(node_id, \"range\", range_str)\n\n            for field_key, field_value in fields:\n                _format(field_key, field_value, node_id)", "is_method": true, "class_name": "AstView", "function_description": "Recursively formats and populates a tree view with AST nodes, their attributes, and source code location details. It visually represents the structure of an Abstract Syntax Tree."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/run_debug_config_page.py", "function": "load_plugin", "line_number": 73, "body": "def load_plugin():\n    get_workbench().add_configuration_page(\"run\", tr(\"Run & Debug\"), RunDebugConfigurationPage, 50)", "is_method": false, "function_description": "This function adds a \"Run & Debug\" configuration page to the application's workbench. It provides a dedicated user interface for managing execution and debugging settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "handle_autocomplete_request", "line_number": 289, "body": "def handle_autocomplete_request(event=None):\n    if event is None:\n        text = get_workbench().focus_get()\n    else:\n        text = event.widget\n\n    _handle_autocomplete_request_for_text(text)", "is_method": false, "function_description": "This function initiates an autocomplete operation, determining the relevant text input field from the current focus or an event widget. It then triggers the underlying autocomplete logic for that text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_handle_autocomplete_request_for_text", "line_number": 298, "body": "def _handle_autocomplete_request_for_text(text):\n    if not hasattr(text, \"autocompleter\"):\n        if isinstance(text, (CodeViewText, ShellText)) and text.is_python_text():\n            if isinstance(text, CodeViewText):\n                text.autocompleter = Completer(text)\n            elif isinstance(text, ShellText):\n                text.autocompleter = ShellCompleter(text)\n            text.bind(\"<1>\", text.autocompleter.on_text_click)\n        else:\n            return\n\n    text.autocompleter.handle_autocomplete_request()", "is_method": false, "function_description": "Initializes and triggers an autocomplete request for a given text widget. It provides context-aware code completion for Python text in code views or shell environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "patched_perform_midline_tab", "line_number": 312, "body": "def patched_perform_midline_tab(text, event):\n    if text.is_python_text():\n        if isinstance(text, ShellText):\n            option_name = \"edit.tab_complete_in_shell\"\n        else:\n            option_name = \"edit.tab_complete_in_editor\"\n\n        if get_workbench().get_option(option_name):\n            if not text.has_selection():\n                _handle_autocomplete_request_for_text(text)\n                return \"break\"\n            else:\n                return None\n\n    return text.perform_dumb_tab(event)", "is_method": false, "function_description": "Handles Tab key presses to trigger code autocomplete in Python text, respecting user configuration. Otherwise, it performs a standard tab insertion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "load_plugin", "line_number": 329, "body": "def load_plugin() -> None:\n\n    get_workbench().add_command(\n        \"autocomplete\",\n        \"edit\",\n        tr(\"Auto-complete\"),\n        handle_autocomplete_request,\n        default_sequence=\"<Control-space>\"\n        # TODO: tester\n    )\n\n    get_workbench().set_default(\"edit.tab_complete_in_editor\", True)\n    get_workbench().set_default(\"edit.tab_complete_in_shell\", True)\n\n    CodeViewText.perform_midline_tab = patched_perform_midline_tab  # type: ignore\n    ShellText.perform_midline_tab = patched_perform_midline_tab", "is_method": false, "function_description": "Initializes and configures an autocomplete plugin by registering a command and enabling enhanced tab completion functionality for the editor and shell environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_bind_result_event", "line_number": 45, "body": "def _bind_result_event(self):\n        # TODO: remove binding when editor gets closed\n        get_workbench().bind(\"editor_autocomplete_response\", self._handle_backend_response, True)", "is_method": true, "class_name": "Completer", "function_description": "This internal method registers an event handler with the workbench to receive autocomplete responses. It enables the Completer to process incoming suggestions from the backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "handle_autocomplete_request", "line_number": 49, "body": "def handle_autocomplete_request(self):\n        row, column = self._get_position()\n        source = self.text.get(\"1.0\", \"end-1c\")\n        get_runner().send_command(\n            InlineCommand(\n                \"editor_autocomplete\",\n                source=source,\n                row=row,\n                column=column,\n                filename=self._get_filename(),\n            )\n        )", "is_method": true, "class_name": "Completer", "function_description": "Triggers an autocomplete request for the current editor content. It retrieves the source code, cursor position, and filename, then sends them to an external command runner for processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_handle_backend_response", "line_number": 62, "body": "def _handle_backend_response(self, msg):\n        row, column = self._get_position()\n        source = self.text.get(\"1.0\", \"end-1c\")\n\n        if msg.source != source or msg.row != row or msg.column != column:\n            # situation has changed, information is obsolete\n            self._close()\n        elif msg.get(\"error\"):\n            self._close()\n            messagebox.showerror(\"Autocomplete error\", msg.error, master=self)\n        else:\n            self._present_completions(msg.completions)", "is_method": true, "class_name": "Completer", "function_description": "Handles incoming completion responses from the backend. It validates response relevance and errors, then either presents valid completions or dismisses outdated/erroneous ones."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_present_completions", "line_number": 75, "body": "def _present_completions(self, completions_):\n        # Check if autocompeted name starts with an underscore,\n        # if it doesn't - don't show names starting with '_'\n        source = self.text.get(\"insert linestart\", tk.INSERT)\n        try:\n            current_source_chunk = re.split(r\"\\W\", source)[-1]\n        except IndexError:\n            current_source_chunk = \"\"\n\n        if current_source_chunk.startswith(\"_\"):\n            completions = completions_\n        else:\n            completions = [c for c in completions_ if not c.get(\"name\", \"_\").startswith(\"_\")]\n\n        self.completions = completions\n\n        # broadcast logging info\n        row, column = self._get_position()\n        get_workbench().event_generate(\n            \"AutocompleteProposal\",\n            text_widget=self.text,\n            row=row,\n            column=column,\n            proposal_count=len(completions),\n        )\n\n        # present\n        if len(completions) == 0:\n            self._close()\n        elif len(completions) == 1:\n            self._insert_completion(completions[0])  # insert the only completion\n            self._close()\n        else:\n            self._show_box(completions)", "is_method": true, "class_name": "Completer", "function_description": "This internal method filters and presents autocompletion suggestions to the user. It either directly inserts a single completion or displays a selection box for multiple options, considering name visibility rules."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_show_box", "line_number": 110, "body": "def _show_box(self, completions):\n        self.delete(0, self.size())\n        self.insert(0, *[c[\"name\"] for c in completions])\n        self.activate(0)\n        self.selection_set(0)\n\n        # place box\n        if not self._is_visible():\n\n            # _, _, _, list_box_height = self.bbox(0)\n            height = 100  # min(150, list_box_height * len(completions) * 1.15)\n            typed_name_length = len(completions[0][\"name\"]) - len(completions[0][\"complete\"])\n            text_box_x, text_box_y, _, text_box_height = self.text.bbox(\n                \"insert-%dc\" % typed_name_length\n            )\n\n            # should the box appear below or above cursor?\n            space_below = self.master.winfo_height() - text_box_y - text_box_height\n            space_above = text_box_y\n\n            if space_below >= height or space_below > space_above:\n                height = min(height, space_below)\n                y = text_box_y + text_box_height\n            else:\n                height = min(height, space_above)\n                y = text_box_y - height\n\n            width = 400\n            self.place(x=text_box_x, y=y, width=width, height=height)\n\n            self._update_doc()", "is_method": true, "class_name": "Completer", "function_description": "This internal method displays a list of auto-completion suggestions in a GUI box. It populates the box with the given completions and dynamically positions it relative to the text input for optimal visibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_update_doc", "line_number": 142, "body": "def _update_doc(self):\n        c = self._get_selected_completion()\n\n        if c is None:\n            self.doc_label[\"text\"] = \"\"\n            self.doc_label.place_forget()\n        else:\n            docstring = c.get(\"docstring\", None)\n            if docstring:\n                self.doc_label[\"text\"] = docstring\n                self.doc_label.place(\n                    x=self.winfo_x() + self.winfo_width(),\n                    y=self.winfo_y(),\n                    width=400,\n                    height=self.winfo_height(),\n                )\n            else:\n                self.doc_label[\"text\"] = \"\"\n                self.doc_label.place_forget()", "is_method": true, "class_name": "Completer", "function_description": "Dynamically displays documentation for the currently selected auto-completion suggestion within a UI label, hiding it if no docstring is available.\nDynamically displays documentation for the currently selected auto-completion suggestion within a UI label, hiding it if no docstring is available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_is_visible", "line_number": 162, "body": "def _is_visible(self):\n        return self.winfo_ismapped()", "is_method": true, "class_name": "Completer", "function_description": "Determines if the Completer widget is currently displayed and visible on the screen. It provides a quick status check for the UI component."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_insert_completion", "line_number": 165, "body": "def _insert_completion(self, completion):\n        typed_len = len(completion[\"name\"]) - len(completion[\"complete\"])\n        typed_prefix = self.text.get(\"insert-{}c\".format(typed_len), \"insert\")\n        get_workbench().event_generate(\n            \"AutocompleteInsertion\",\n            text_widget=self.text,\n            typed_prefix=typed_prefix,\n            completed_name=completion[\"name\"],\n        )\n\n        if self._is_visible():\n            self._close()\n\n        if not completion[\"name\"].startswith(typed_prefix):\n            # eg. case of the prefix was not correct\n            self.text.delete(\"insert-{}c\".format(typed_len), \"insert\")\n            self.text.insert(\"insert\", completion[\"name\"])\n        else:\n            self.text.insert(\"insert\", completion[\"complete\"])", "is_method": true, "class_name": "Completer", "function_description": "Core method of the `Completer` class that inserts a selected autocomplete suggestion into the text widget. It correctly replaces the typed prefix and emits an `AutocompleteInsertion` event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_get_filename", "line_number": 185, "body": "def _get_filename(self):\n        # TODO: allow completing in shell\n        if not isinstance(self.text, CodeViewText):\n            return None\n\n        codeview = self.text.master\n\n        editor = get_workbench().get_editor_notebook().get_current_editor()\n        if editor.get_code_view() is codeview:\n            return editor.get_filename()\n        else:\n            return None", "is_method": true, "class_name": "Completer", "function_description": "Identifies and returns the filename of the code editor currently being used for completion. It helps ensure completions are contextually aware of the active file."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_move_selection", "line_number": 198, "body": "def _move_selection(self, delta):\n        selected = self.curselection()\n        if len(selected) == 0:\n            index = 0\n        else:\n            index = selected[0]\n\n        index += delta\n        index = max(0, min(self.size() - 1, index))\n\n        self.selection_clear(0, self.size() - 1)\n        self.selection_set(index)\n        self.activate(index)\n        self.see(index)\n        self._update_doc()", "is_method": true, "class_name": "Completer", "function_description": "Moves the current selection within the completer's list by a given delta, ensuring the selected item is within bounds, visible, and activated. It clears the old selection and updates the display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_get_request_id", "line_number": 214, "body": "def _get_request_id(self):\n        return \"autocomplete_\" + str(self.text.winfo_id())", "is_method": true, "class_name": "Completer", "function_description": "Generates a unique identifier for an autocomplete request. It combines a standard prefix with the associated text widget's internal ID for tracking purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_get_position", "line_number": 217, "body": "def _get_position(self):\n        return map(int, self.text.index(\"insert\").split(\".\"))", "is_method": true, "class_name": "Completer", "function_description": "The function retrieves the current line and column coordinates of the text insertion point. It parses a string representation of the position from the completer's internal text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_on_text_keypress", "line_number": 220, "body": "def _on_text_keypress(self, event=None):\n        if not self._is_visible():\n            return None\n\n        if event.keysym == \"Escape\":\n            self._close()\n            return \"break\"\n        elif event.keysym in [\"Up\", \"KP_Up\"]:\n            self._move_selection(-1)\n            return \"break\"\n        elif event.keysym in [\"Down\", \"KP_Down\"]:\n            self._move_selection(1)\n            return \"break\"\n        elif event.keysym in [\"Return\", \"KP_Enter\", \"Tab\"]:\n            assert self.size() > 0\n            self._insert_current_selection()\n            return \"break\"\n\n        return None", "is_method": true, "class_name": "Completer", "function_description": "Handles key presses to enable user interaction with the autocompletion interface, allowing navigation, selection, and dismissal of suggestions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_insert_current_selection", "line_number": 240, "body": "def _insert_current_selection(self, event=None):\n        self._insert_completion(self._get_selected_completion())", "is_method": true, "class_name": "Completer", "function_description": "This method inserts the currently selected completion from the completer's options into the active text area. It finalizes the user's choice within an autocompletion context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_get_selected_completion", "line_number": 243, "body": "def _get_selected_completion(self):\n        sel = self.curselection()\n        if len(sel) != 1:\n            return None\n\n        return self.completions[sel[0]]", "is_method": true, "class_name": "Completer", "function_description": "Retrieves the single completion suggestion currently selected by the user. Returns None if no or multiple items are selected."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_on_text_change", "line_number": 250, "body": "def _on_text_change(self, event=None):\n        if self._is_visible():\n            self.handle_autocomplete_request()", "is_method": true, "class_name": "Completer", "function_description": "When text changes, this method triggers an autocomplete request if the completer's suggestions are currently visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_close", "line_number": 254, "body": "def _close(self, event=None):\n        self.place_forget()\n        self.doc_label.place_forget()\n        self.text.focus_set()", "is_method": true, "class_name": "Completer", "function_description": "Hides the completer's UI elements and returns keyboard focus to the associated text input, effectively dismissing the completion interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "on_text_click", "line_number": 259, "body": "def on_text_click(self, event=None):\n        if self._is_visible():\n            self._close()", "is_method": true, "class_name": "Completer", "function_description": "Closes the completer's visible suggestion display upon a text click event."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_bind_result_event", "line_number": 265, "body": "def _bind_result_event(self):\n        # TODO: remove binding when editor gets closed\n        get_workbench().bind(\"shell_autocomplete_response\", self._handle_backend_response, True)", "is_method": true, "class_name": "ShellCompleter", "function_description": "This method binds the `shell_autocomplete_response` event to a handler, enabling the `ShellCompleter` to process backend autocompletion results. It sets up the communication for autocompletion functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "handle_autocomplete_request", "line_number": 269, "body": "def handle_autocomplete_request(self):\n        source = self._get_prefix()\n\n        get_runner().send_command(InlineCommand(\"shell_autocomplete\", source=source))", "is_method": true, "class_name": "ShellCompleter", "function_description": "Initiates a shell autocomplete request. It captures the user's current input prefix and delegates the actual completion logic to an external runner."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_handle_backend_response", "line_number": 274, "body": "def _handle_backend_response(self, msg):\n        if hasattr(msg, \"source\"):\n            # check if the response is relevant for current state\n            if msg.source != self._get_prefix():\n                self._close()\n            elif msg.get(\"error\"):\n                self._close()\n                messagebox.showerror(\"Autocomplete error\", msg.error, master=self)\n            else:\n                self._present_completions(msg.completions)", "is_method": true, "class_name": "ShellCompleter", "function_description": "Handles backend responses for shell autocompletion. It verifies response relevance, displays valid completions, or reports errors to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/autocomplete.py", "function": "_get_prefix", "line_number": 285, "body": "def _get_prefix(self):\n        return self.text.get(\"input_start\", \"insert\")", "is_method": true, "class_name": "ShellCompleter", "function_description": "Retrieves the current input prefix from the text buffer. This is used by the completer to identify the string needing autocompletion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "tomorrow", "line_number": 5, "body": "def tomorrow() -> SyntaxThemeSettings:\n    # https://github.com/chriskempson/tomorrow-theme/blob/master/GEdit/Tomorrow.xml\n    normal_fg = \"#4D4D4C\"\n    string_fg = \"#718C00\"\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#FFFFFF\"},\n        \"GUTTER\": {\"foreground\": \"#4d4d4c\", \"background\": \"#efefef\"},\n        \"current_line\": {\"background\": \"#efefef\"},\n        \"sel\": {\"foreground\": \"#4D4D4C\", \"background\": \"#D6D6D6\"},\n        \"number\": {\"foreground\": \"#718c00\"},\n        \"definition\": {\"foreground\": \"#4271AE\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string_fg},\n        \"open_string3\": {\"foreground\": string_fg},\n        \"keyword\": {\"foreground\": \"#8959A8\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#4271ae\"},\n        \"comment\": {\"foreground\": \"#8E908C\"},\n    }", "is_method": false, "function_description": "Provides a complete set of color and font definitions for the 'Tomorrow' syntax highlighting theme. This enables applications to apply a popular, consistent visual style for code display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "tomorrow_night", "line_number": 27, "body": "def tomorrow_night() -> SyntaxThemeSettings:\n    # https://github.com/chriskempson/tomorrow-theme/blob/master/GEdit/Tomorrow-Night.xml\n    normal_fg = \"#c5c8c6\"\n    string_fg = \"#b5bd68\"\n    string3_fg = string_fg\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#1d1f21\"},\n        \"GUTTER\": {\"foreground\": \"#c5c8c6\", \"background\": \"#282a2e\"},\n        \"sel\": {\"foreground\": \"#c5c8c6\", \"background\": \"#373b41\"},\n        \"current_line\": {\"background\": \"#282a2e\"},\n        \"number\": {\"foreground\": \"#de935f\"},\n        \"definition\": {\"foreground\": \"#81a2be\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string3_fg},\n        \"open_string3\": {\"foreground\": string3_fg},\n        \"keyword\": {\"foreground\": \"#b294bb\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#81a2be\"},\n        \"comment\": {\"foreground\": \"#969896\"},\n        # paren matcher\n        \"surrounding_parens\": {\n            \"background\": \"#373b41\",\n            \"foreground\": \"white\",\n            \"font\": \"BoldEditorFont\",\n        },\n    }", "is_method": false, "function_description": "This function defines and returns a complete color scheme for a text editor, implementing the \"Tomorrow Night\" syntax highlighting theme with specific color and font settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "tomorrow_night_blue", "line_number": 56, "body": "def tomorrow_night_blue() -> SyntaxThemeSettings:\n    # https://github.com/chriskempson/tomorrow-theme/blob/master/GEdit/Tomorrow-Night-Blue.xml\n    normal_fg = \"#ffffff\"\n    string_fg = \"#d1f1a9\"\n    string3_fg = string_fg\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#002451\"},\n        \"GUTTER\": {\"foreground\": \"#ffffff\", \"background\": \"#00346e\"},\n        \"sel\": {\"foreground\": \"#ffffff\", \"background\": \"#003f8e\"},\n        \"current_line\": {\"background\": \"#00346e\"},\n        \"number\": {\"foreground\": \"#ffc58f\"},\n        \"definition\": {\"foreground\": \"#bbdaff\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string3_fg},\n        \"open_string3\": {\"foreground\": string3_fg},\n        \"keyword\": {\"foreground\": \"#ebbbff\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#bbdaff\"},\n        \"comment\": {\"foreground\": \"#7285b7\"},\n        # paren matcher\n        \"surrounding_parens\": {\n            \"background\": \"#00346e\",\n            \"foreground\": \"white\",\n            \"font\": \"BoldEditorFont\",\n        },\n    }", "is_method": false, "function_description": "Defines and returns the comprehensive styling configuration for the 'Tomorrow Night Blue' syntax theme. It provides specific colors and font settings for various editor elements like text, keywords, and comments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "tomorrow_night_bright", "line_number": 85, "body": "def tomorrow_night_bright() -> SyntaxThemeSettings:\n    # https://github.com/chriskempson/tomorrow-theme/blob/master/GEdit/Tomorrow-Night-Bright.xml\n    normal_fg = \"#dedede\"\n    string_fg = \"#b9ca4a\"\n    string3_fg = string_fg\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#000000\"},\n        \"GUTTER\": {\"foreground\": \"#dedede\", \"background\": \"#2a2a2a\"},\n        \"current_line\": {\"background\": \"#2a2a2a\"},\n        \"sel\": {\"foreground\": \"#dedede\", \"background\": \"#424242\"},\n        \"number\": {\"foreground\": \"#e78c45\"},\n        \"definition\": {\"foreground\": \"#7aa6da\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string3_fg},\n        \"open_string3\": {\"foreground\": string3_fg},\n        \"keyword\": {\"foreground\": \"#c397d8\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#7aa6da\"},\n        \"comment\": {\"foreground\": \"#969896\"},\n        # paren matcher\n        \"surrounding_parens\": {\n            \"background\": \"#2a2a2a\",\n            \"foreground\": \"white\",\n            \"font\": \"BoldEditorFont\",\n        },\n    }", "is_method": false, "function_description": "Provides a complete color and font configuration for the 'Tomorrow Night Bright' syntax highlighting theme. It defines visual styles for various editor elements like text, keywords, strings, and comments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "tomorrow_night_eighties", "line_number": 114, "body": "def tomorrow_night_eighties() -> SyntaxThemeSettings:\n    # https://github.com/chriskempson/tomorrow-theme/blob/master/GEdit/Tomorrow-Night-Eighties.xml\n    normal_fg = \"#cccccc\"\n    string_fg = \"#99cc99\"\n    string3_fg = string_fg\n\n    return {\n        \"TEXT\": {\"foreground\": normal_fg, \"insertbackground\": normal_fg, \"background\": \"#2d2d2d\"},\n        \"GUTTER\": {\"foreground\": \"#cccccc\", \"background\": \"#393939\"},\n        \"current_line\": {\"background\": \"#393939\"},\n        \"sel\": {\"foreground\": \"#cccccc\", \"background\": \"#515151\"},\n        \"number\": {\"foreground\": \"#f99157\"},\n        \"definition\": {\"foreground\": \"#6699cc\", \"font\": \"BoldEditorFont\"},\n        \"string\": {\"foreground\": string_fg},\n        \"string3\": {\"foreground\": string_fg},\n        \"open_string\": {\"foreground\": string3_fg},\n        \"open_string3\": {\"foreground\": string3_fg},\n        \"keyword\": {\"foreground\": \"#cc99cc\", \"font\": \"BoldEditorFont\"},\n        \"builtin\": {\"foreground\": \"#6699cc\"},\n        \"comment\": {\"foreground\": \"#999999\"},\n        # paren matcher\n        \"surrounding_parens\": {\n            \"background\": \"#393939\",\n            \"foreground\": \"white\",\n            \"font\": \"BoldEditorFont\",\n        },\n    }", "is_method": false, "function_description": "Returns the complete styling settings for the \"Tomorrow Night Eighties\" syntax highlighting theme, providing color and font definitions for code elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/tomorrow_syntax_theme.py", "function": "load_plugin", "line_number": 143, "body": "def load_plugin() -> None:\n    get_workbench().add_syntax_theme(\"Tomorrow\", \"Default Light\", tomorrow)\n    get_workbench().add_syntax_theme(\"Tomorrow Night\", \"Default Dark\", tomorrow_night)\n    get_workbench().add_syntax_theme(\"Tomorrow Night Blue\", \"Tomorrow Night\", tomorrow_night_blue)\n    get_workbench().add_syntax_theme(\n        \"Tomorrow Night Bright\", \"Tomorrow Night\", tomorrow_night_bright\n    )\n    get_workbench().add_syntax_theme(\n        \"Tomorrow Night Eighties\", \"Tomorrow Night\", tomorrow_night_eighties()\n    )\n\n    get_workbench().set_default(\"view.syntax_theme\", \"Default Light\")", "is_method": false, "function_description": "Registers a collection of 'Tomorrow' syntax themes with the application's workbench. This function configures available visual themes and sets a default for the user interface.\nRegisters a collection of 'Tomorrow' syntax themes with the application's workbench. This function configures available visual themes and sets a default for the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/editor_config_page.py", "function": "load_plugin", "line_number": 74, "body": "def load_plugin() -> None:\n    get_workbench().add_configuration_page(\"editor\", tr(\"Editor\"), EditorConfigurationPage, 30)", "is_method": false, "function_description": "Registers the editor's configuration settings, making them accessible as a dedicated page within the application's main workbench. This enables users to customize editor-related options via the UI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/editor_config_page.py", "function": "apply", "line_number": 69, "body": "def apply(self):\n        ConfigurationPage.apply(self)\n        get_workbench().get_editor_notebook().update_appearance()", "is_method": true, "class_name": "EditorConfigurationPage", "function_description": "This method of `EditorConfigurationPage` applies configuration changes and refreshes the editor's visual appearance to reflect the updated settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "load_plugin", "line_number": 227, "body": "def load_plugin() -> None:\n    get_workbench().add_configuration_page(\n        \"theme\", tr(\"Theme & Font\"), ThemeAndFontConfigurationPage, 40\n    )", "is_method": false, "function_description": "Integrates a 'Theme & Font' configuration page into the application's workbench. This enables users to customize appearance settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_init_themes", "line_number": 29, "body": "def _init_themes(self):\n        self._original_ui_theme = get_workbench().get_option(\"view.ui_theme\")\n        self._original_syntax_theme = get_workbench().get_option(\"view.syntax_theme\")\n\n        self._ui_theme_variable = create_string_var(\n            self._original_ui_theme, modification_listener=self._update_appearance\n        )\n        self._syntax_theme_variable = create_string_var(\n            self._original_syntax_theme, modification_listener=self._update_appearance\n        )\n\n        ttk.Label(self, text=tr(\"UI theme\")).grid(\n            row=1, column=1, sticky=\"w\", pady=(0, 10), padx=(0, 5)\n        )\n        self._ui_theme_combo = ttk.Combobox(\n            self,\n            exportselection=False,\n            textvariable=self._ui_theme_variable,\n            state=\"readonly\",\n            height=15,\n            values=get_workbench().get_usable_ui_theme_names(),\n        )\n        self._ui_theme_combo.grid(row=1, column=2, sticky=\"nwe\", pady=(0, 5))\n\n        ttk.Label(self, text=tr(\"Syntax theme\")).grid(\n            row=2, column=1, sticky=\"w\", pady=(0, 10), padx=(0, 5)\n        )\n        self._syntax_theme_combo = ttk.Combobox(\n            self,\n            exportselection=False,\n            textvariable=self._syntax_theme_variable,\n            state=\"readonly\",\n            height=15,\n            values=get_workbench().get_syntax_theme_names(),\n        )\n        self._syntax_theme_combo.grid(row=2, column=2, sticky=\"nwe\", pady=(0, 5))", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Initializes and displays user interface and syntax theme selection controls. It loads current themes and allows users to choose from available options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_init_fonts", "line_number": 66, "body": "def _init_fonts(self):\n        self._original_editor_family = get_workbench().get_option(\"view.editor_font_family\")\n        self._original_editor_size = get_workbench().get_option(\"view.editor_font_size\")\n        self._original_io_family = get_workbench().get_option(\"view.io_font_family\")\n        self._original_io_size = get_workbench().get_option(\"view.io_font_size\")\n\n        self._editor_family_variable = create_string_var(\n            self._original_editor_family, modification_listener=self._update_appearance\n        )\n        self._editor_size_variable = create_string_var(\n            self._original_editor_size, modification_listener=self._update_appearance\n        )\n        self._io_family_variable = create_string_var(\n            self._original_io_family, modification_listener=self._update_appearance\n        )\n        self._io_size_variable = create_string_var(\n            self._original_io_size, modification_listener=self._update_appearance\n        )\n\n        ttk.Label(self, text=tr(\"Editor font\")).grid(\n            row=1, column=3, sticky=\"w\", pady=(0, 5), padx=(25, 5)\n        )\n        editor_family_combo = ttk.Combobox(\n            self,\n            exportselection=False,\n            state=\"readonly\",\n            height=15,\n            textvariable=self._editor_family_variable,\n            values=self._get_families_to_show(),\n        )\n        editor_family_combo.grid(row=1, column=4, sticky=\"nwe\", pady=(0, 5))\n        editor_size_combo = ttk.Combobox(\n            self,\n            width=4,\n            exportselection=False,\n            textvariable=self._editor_size_variable,\n            state=\"readonly\",\n            height=15,\n            values=[str(x) for x in range(3, 73)],\n        )\n        editor_size_combo.grid(row=1, column=5, sticky=\"nwe\", pady=(0, 5), padx=(5, 0))\n\n        ttk.Label(self, text=tr(\"IO font\")).grid(\n            row=2, column=3, sticky=\"w\", pady=(0, 5), padx=(25, 5)\n        )\n        io_family_combo = ttk.Combobox(\n            self,\n            exportselection=False,\n            state=\"readonly\",\n            height=15,\n            textvariable=self._io_family_variable,\n            values=self._get_families_to_show(),\n        )\n        io_family_combo.grid(row=2, column=4, sticky=\"nwe\", pady=(0, 5))\n\n        io_size_combo = ttk.Combobox(\n            self,\n            width=4,\n            exportselection=False,\n            textvariable=self._io_size_variable,\n            state=\"readonly\",\n            height=15,\n            values=[str(x) for x in range(3, 73)],\n        )\n        io_size_combo.grid(row=2, column=5, sticky=\"nwe\", pady=(0, 5), padx=(5, 0))", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "This method initializes the user interface for configuring editor and I/O fonts on the ThemeAndFontConfigurationPage. It retrieves current settings and creates interactive comboboxes for users to modify font family and size."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_init_previews", "line_number": 132, "body": "def _init_previews(self):\n        ttk.Label(self, text=tr(\"Preview\")).grid(\n            row=20, column=1, sticky=\"w\", pady=(5, 2), columnspan=5\n        )\n        self._preview_codeview = CodeView(\n            self, height=6, font=\"EditorFont\", relief=\"groove\", borderwidth=1, line_numbers=True\n        )\n\n        self._preview_codeview.set_content(\n            textwrap.dedent(\n                \"\"\"\n            def foo(bar):\n                if bar is None: # \"\"\"\n                + tr(\"This is a comment\")\n                + \"\"\"\n                    print('\"\"\"\n                + tr(\"The answer is\")\n                + \"\"\"', 33)\n\n            \"\"\"\n                + tr(\"unclosed_string\")\n                + ''' = \"'''\n                + tr(\"blah, blah\")\n                + \"\\n\"\n            ).strip()\n        )\n        self._preview_codeview.grid(row=21, column=1, columnspan=5, sticky=tk.NSEW)\n\n        self._shell_preview = tktextext.TextFrame(\n            self,\n            text_class=BaseShellText,\n            height=4,\n            vertical_scrollbar_style=scrollbar_style(\"Vertical\"),\n            horizontal_scrollbar_style=scrollbar_style(\"Horizontal\"),\n            horizontal_scrollbar_class=ui_utils.AutoScrollbar,\n            relief=\"groove\",\n            borderwidth=1,\n            font=\"EditorFont\",\n        )\n        self._shell_preview.grid(row=31, column=1, columnspan=5, sticky=tk.NSEW, pady=(5, 5))\n        self._shell_preview.text.set_read_only(True)\n        self._insert_shell_text()\n\n        ttk.Label(\n            self,\n            text=tr(\"NB! Some style elements change only after restarting Thonny!\"),\n            font=\"BoldTkDefaultFont\",\n        ).grid(row=40, column=1, columnspan=5, sticky=\"w\", pady=(5, 0))", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Initializes and displays UI widgets for code and shell output previews, enabling users to visualize selected theme and font configurations within the page."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "cancel", "line_number": 185, "body": "def cancel(self):\n        if (\n            getattr(self._editor_family_variable, \"modified\")\n            or getattr(self._editor_size_variable, \"modified\")\n            or getattr(self._ui_theme_variable, \"modified\")\n            or getattr(self._syntax_theme_variable, \"modified\")\n        ):\n            get_workbench().set_option(\"view.ui_theme\", self._original_ui_theme)\n            get_workbench().set_option(\"view.syntax_theme\", self._original_syntax_theme)\n            get_workbench().set_option(\"view.editor_font_size\", self._original_editor_size)\n            get_workbench().set_option(\"view.editor_font_family\", self._original_editor_family)\n            get_workbench().set_option(\"view.io_font_size\", self._original_io_size)\n            get_workbench().set_option(\"view.io_font_family\", self._original_io_family)\n            get_workbench().reload_themes()\n            get_workbench().update_fonts()", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "This method discards any unsaved changes made to theme and font settings on the configuration page, restoring them to their original values."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_update_appearance", "line_number": 201, "body": "def _update_appearance(self):\n        get_workbench().set_option(\"view.ui_theme\", self._ui_theme_variable.get())\n        get_workbench().set_option(\"view.syntax_theme\", self._syntax_theme_variable.get())\n        get_workbench().set_option(\"view.editor_font_size\", int(self._editor_size_variable.get()))\n        get_workbench().set_option(\"view.editor_font_family\", self._editor_family_variable.get())\n        get_workbench().set_option(\"view.io_font_size\", int(self._io_size_variable.get()))\n        get_workbench().set_option(\"view.io_font_family\", self._io_family_variable.get())\n        get_workbench().reload_themes()\n        get_workbench().update_fonts()", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Applies the selected UI and syntax themes, along with editor and I/O font settings, to update the application's appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_insert_shell_text", "line_number": 211, "body": "def _insert_shell_text(self):\n        text = self._shell_preview.text\n        text._insert_prompt()\n        text.direct_insert(\"end\", \"%Run demo.py\\n\", (\"magic\", \"before_io\"))\n        text.tag_add(\"before_io\", \"1.0\", \"1.0 lineend\")\n        text.direct_insert(\"end\", tr(\"Enter an integer\") + \": \", (\"io\", \"stdout\"))\n        text.direct_insert(\"end\", \"2.5\\n\", (\"io\", \"stdin\"))\n        text.direct_insert(\n            \"end\", \"ValueError: invalid literal for int() with base 10: '2.5'\\n\", (\"io\", \"stderr\")\n        )", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Populates the shell preview with a simulated command execution, including user input, program output, and an error message. This demonstrates the appearance of shell interactions for theme and font configurations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/theme_and_font_config_page.py", "function": "_get_families_to_show", "line_number": 222, "body": "def _get_families_to_show(self):\n        # In Linux, families may contain duplicates (actually different fonts get same names)\n        return sorted(set(filter(lambda name: name[0].isalpha(), tk_font.families())))", "is_method": true, "class_name": "ThemeAndFontConfigurationPage", "function_description": "Generates a sorted, unique list of alphabetic font family names. This method prepares displayable font options for the configuration page."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "load_plugin", "line_number": 85, "body": "def load_plugin() -> None:\n    get_workbench().add_view(HeapView, tr(\"Heap\"), \"e\")", "is_method": false, "function_description": "This function loads a plugin that registers a \"Heap\" view with the application's workbench, allowing users to inspect heap-related information. It provides a specific UI component for memory analysis.\nThis function loads a plugin, integrating a \"Heap\" view into the application's workbench. It enables users to visualize and analyze memory heap information within the main interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "_update_data", "line_number": 45, "body": "def _update_data(self, data):\n        self._clear_tree()\n        for value_id in sorted(data.keys()):\n            node_id = self.tree.insert(\"\", \"end\")\n            self.tree.set(node_id, \"id\", format_object_id(value_id))\n            self.tree.set(\n                node_id, \"value\", shorten_repr(data[value_id].repr, MAX_REPR_LENGTH_IN_GRID)\n            )", "is_method": true, "class_name": "HeapView", "function_description": "Refreshes the HeapView's visual representation of heap contents. It clears the current display and populates it with new object IDs and their shortened string values."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "before_show", "line_number": 54, "body": "def before_show(self):\n        self._request_heap_data(even_when_hidden=True)", "is_method": true, "class_name": "HeapView", "function_description": "This method prepares the `HeapView` by requesting updated heap data, ensuring it's fresh for display even if the view was previously hidden. It ensures the view always presents current information upon appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "get_object_id", "line_number": 57, "body": "def get_object_id(self):\n        iid = self.tree.focus()\n        if iid != \"\":\n            return parse_object_id(self.tree.item(iid)[\"values\"][0])\n\n        return None", "is_method": true, "class_name": "HeapView", "function_description": "Retrieves the unique identifier of the memory object currently selected within the HeapView's display. It provides the ID for the focused item in the interactive tree view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "_request_heap_data", "line_number": 64, "body": "def _request_heap_data(self, msg=None, even_when_hidden=False):\n        if self.winfo_ismapped() or even_when_hidden:\n            # TODO: update itself also when it becomes visible\n            if get_runner() is not None:\n                get_runner().send_command(InlineCommand(\"get_heap\"))", "is_method": true, "class_name": "HeapView", "function_description": "Requests current heap memory data from the associated runner. This service allows the `HeapView` to obtain and potentially display up-to-date memory usage information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "_handle_heap_event", "line_number": 70, "body": "def _handle_heap_event(self, msg):\n        if self.winfo_ismapped():\n            if hasattr(msg, \"heap\"):\n                self._update_data(msg.heap)", "is_method": true, "class_name": "HeapView", "function_description": "Processes incoming heap events. If the `HeapView` is visible and the event contains heap data, it updates the view to reflect the new heap state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "_on_map", "line_number": 75, "body": "def _on_map(self, event):\n        self.info_label.grid(row=0, column=1005)", "is_method": true, "class_name": "HeapView", "function_description": "This method repositions the `info_label` within the GUI grid to a specific far-right column. It acts as an event handler, typically invoked when a widget is mapped or becomes visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/heap.py", "function": "_on_unmap", "line_number": 78, "body": "def _on_unmap(self, event):\n        try:\n            self.info_label.grid_remove()\n        except TclError:\n            pass", "is_method": true, "class_name": "HeapView", "function_description": "Hides an information label from the GUI grid when an unmap event occurs. This prevents display issues and handles potential errors gracefully."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_fetch_url_future", "line_number": 1220, "body": "def _fetch_url_future(url, timeout=10):\n    from urllib.request import urlopen\n\n    def load_url():\n        with urlopen(url, timeout=timeout) as conn:\n            return (conn, conn.read())\n\n    from concurrent.futures.thread import ThreadPoolExecutor\n\n    executor = ThreadPoolExecutor(max_workers=1)\n    return executor.submit(load_url)", "is_method": false, "function_description": "Initiates an asynchronous fetch of content from a specified URL. It returns a future object that will provide the fetched data when available, allowing non-blocking operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_latest_stable_version", "line_number": 1233, "body": "def _get_latest_stable_version(version_strings):\n    from distutils.version import LooseVersion\n\n    versions = []\n    for s in version_strings:\n        if s.replace(\".\", \"\").isnumeric():  # Assuming stable versions have only dots and numbers\n            versions.append(\n                LooseVersion(s)\n            )  # LooseVersion __str__ doesn't change the version string\n\n    if len(versions) == 0:\n        return None\n\n    return str(sorted(versions)[-1])", "is_method": false, "function_description": "Identifies and returns the numerically latest \"stable\" version string from a given list. This is useful for finding the most recent release from a set of version candidates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_ask_installation_details", "line_number": 1249, "body": "def _ask_installation_details(master, data, selected_version, support_update_deps_switch):\n    dlg = DetailsDialog(master, data, selected_version, support_update_deps_switch)\n    ui_utils.show_dialog(dlg, master)\n    return dlg.result", "is_method": false, "function_description": "Displays a dialog box to the user to prompt for and collect specific installation details. It returns the gathered information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_fetching_package_info", "line_number": 1255, "body": "def _start_fetching_package_info(name, version_str, completion_handler):\n    import urllib.error\n    import urllib.parse\n\n    # Fetch info from PyPI\n    if version_str is None:\n        url = \"https://pypi.org/pypi/{}/json\".format(urllib.parse.quote(name))\n    else:\n        url = \"https://pypi.org/pypi/{}/{}/json\".format(\n            urllib.parse.quote(name), urllib.parse.quote(version_str)\n        )\n\n    url_future = _fetch_url_future(url)\n\n    def poll_fetch_complete():\n        import json\n\n        if url_future.done():\n            try:\n                _, bin_data = url_future.result()\n                raw_data = bin_data.decode(\"UTF-8\")\n                completion_handler(name, json.loads(raw_data))\n            except urllib.error.HTTPError as e:\n                completion_handler(\n                    name, {\"info\": {\"name\": name}, \"error\": str(e), \"releases\": {}}, e.code\n                )\n            except Exception as e:\n                completion_handler(\n                    name, {\"info\": {\"name\": name}, \"error\": str(e), \"releases\": {}}, e\n                )\n        else:\n            tk._default_root.after(200, poll_fetch_complete)\n\n    poll_fetch_complete()", "is_method": false, "function_description": "Asynchronously retrieves package metadata from PyPI for a specified package and version. It notifies a provided handler with the fetched data or error upon completion, suitable for non-blocking operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_fetching_search_results", "line_number": 1291, "body": "def _start_fetching_search_results(query, completion_handler):\n    import urllib.parse\n\n    url = \"https://pypi.org/search/?q={}\".format(urllib.parse.quote(query))\n\n    url_future = _fetch_url_future(url)\n\n    def poll_fetch_complete():\n\n        if url_future.done():\n            try:\n                _, bin_data = url_future.result()\n                raw_data = bin_data.decode(\"UTF-8\")\n                completion_handler(query, _extract_search_results(raw_data))\n            except Exception as e:\n                completion_handler(query, str(e))\n        else:\n            tk._default_root.after(200, poll_fetch_complete)\n\n    poll_fetch_complete()", "is_method": false, "function_description": "Initiates an asynchronous search for packages on PyPI based on a query. It processes the fetched results and delivers them to a provided completion handler."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_extract_search_results", "line_number": 1313, "body": "def _extract_search_results(html_data: str) -> List:\n    from html.parser import HTMLParser\n\n    def get_class(attrs):\n        for name, value in attrs:\n            if name == \"class\":\n                return value\n\n        return None\n\n    class_prefix = \"package-snippet__\"\n\n    class PypiSearchResultsParser(HTMLParser):\n        def __init__(self, data):\n            HTMLParser.__init__(self)\n            self.results = []\n            self.active_class = None\n            self.feed(data)\n\n        def handle_starttag(self, tag, attrs):\n            if tag == \"a\" and get_class(attrs) == \"package-snippet\":\n                self.results.append({})\n\n            if tag in (\"span\", \"p\"):\n                tag_class = get_class(attrs)\n                if tag_class in (\"package-snippet__name\", \"package-snippet__description\"):\n                    self.active_class = tag_class\n                else:\n                    self.active_class = None\n            else:\n                self.active_class = None\n\n        def handle_data(self, data):\n            if self.active_class is not None:\n                att_name = self.active_class[len(class_prefix) :]\n                self.results[-1][att_name] = data\n\n        def handle_endtag(self, tag):\n            self.active_class = None\n\n    return PypiSearchResultsParser(html_data).results", "is_method": false, "function_description": "Extracts structured search results, including package names and descriptions, by parsing provided HTML data. It is specifically designed to process PyPI search page content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_extract_click_text", "line_number": 1356, "body": "def _extract_click_text(widget, event, tag):\n    # http://stackoverflow.com/a/33957256/261181\n    try:\n        index = widget.index(\"@%s,%s\" % (event.x, event.y))\n        tag_indices = list(widget.tag_ranges(tag))\n        for start, end in zip(tag_indices[0::2], tag_indices[1::2]):\n            # check if the tag matches the mouse click index\n            if widget.compare(start, \"<=\", index) and widget.compare(index, \"<\", end):\n                return widget.get(start, end)\n    except Exception:\n        logging.exception(\"extracting click text\")\n\n    return None", "is_method": false, "function_description": "Extracts text from a GUI widget at the mouse click location, specifically if it's associated with a given tag. This enables identifying and retrieving clickable or specially marked text within the widget."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_not_supported_translation", "line_number": 1371, "body": "def get_not_supported_translation():\n    return tr(\"Package manager is not available for this interpreter\")", "is_method": false, "function_description": "Returns a localized message indicating that the package manager is not supported by the current interpreter, suitable for user-facing error messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "load_plugin", "line_number": 1375, "body": "def load_plugin() -> None:\n    def get_pip_gui_class():\n        proxy = get_runner().get_backend_proxy()\n        if proxy is None:\n            return None\n        return proxy.get_pip_gui_class()\n\n    def open_backend_pip_gui(*args):\n        pg_class = get_pip_gui_class()\n        if pg_class is None:\n            showerror(tr(\"Not supported\"), get_not_supported_translation())\n            return\n\n        if not get_runner().is_waiting_toplevel_command():\n            showerror(\n                tr(\"Not available\"),\n                tr(\"You need to stop your program before launching the package manager.\"),\n                master=get_workbench(),\n            )\n            return\n\n        pg = pg_class(get_workbench())\n        ui_utils.show_dialog(pg)\n\n    def open_backend_pip_gui_enabled():\n        return get_pip_gui_class() is not None\n\n    def open_frontend_pip_gui(*args):\n        pg = PluginsPipDialog(get_workbench())\n        ui_utils.show_dialog(pg)\n\n    get_workbench().add_command(\n        \"backendpipgui\",\n        \"tools\",\n        tr(\"Manage packages...\"),\n        open_backend_pip_gui,\n        tester=open_backend_pip_gui_enabled,\n        group=80,\n    )\n    get_workbench().add_command(\n        \"pluginspipgui\", \"tools\", tr(\"Manage plug-ins...\"), open_frontend_pip_gui, group=180\n    )", "is_method": false, "function_description": "Registers commands in the workbench for managing Python packages and application plugins via dedicated graphical user interfaces. It enables users to install and manage software components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_search_button_text", "line_number": 66, "body": "def get_search_button_text(self):\n        return tr(\"Search on PyPI\")", "is_method": true, "class_name": "PipDialog", "function_description": "Provides the display text for a \"Search on PyPI\" button within the Pip dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_install_button_text", "line_number": 69, "body": "def get_install_button_text(self):\n        return tr(\"Install\")", "is_method": true, "class_name": "PipDialog", "function_description": "Provides the localized text for an \"Install\" button, intended for display within the PipDialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_upgrade_button_text", "line_number": 72, "body": "def get_upgrade_button_text(self):\n        return tr(\"Upgrade\")", "is_method": true, "class_name": "PipDialog", "function_description": "Provides the localized text for an \"Upgrade\" button within the PipDialog, ensuring consistent UI labeling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_uninstall_button_text", "line_number": 75, "body": "def get_uninstall_button_text(self):\n        return tr(\"Uninstall\")", "is_method": true, "class_name": "PipDialog", "function_description": "Provides the localized text string for an \"Uninstall\" button within the PipDialog, ensuring correct display for the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_delete_selected_button_text", "line_number": 78, "body": "def get_delete_selected_button_text(self):\n        return tr(\"Delete selected\")", "is_method": true, "class_name": "PipDialog", "function_description": "Provides the localized text for the \"Delete selected\" button within the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_create_widgets", "line_number": 81, "body": "def _create_widgets(self, parent):\n\n        header_frame = ttk.Frame(parent)\n        header_frame.grid(row=1, column=0, sticky=\"nsew\", padx=15, pady=(15, 0))\n        header_frame.columnconfigure(0, weight=1)\n        header_frame.rowconfigure(1, weight=1)\n\n        name_font = tk.font.nametofont(\"TkDefaultFont\").copy()\n        name_font.configure(size=16)\n        self.search_box = ttk.Entry(header_frame)\n        self.search_box.grid(row=1, column=0, sticky=\"nsew\")\n        self.search_box.bind(\"<Return>\", self._on_search, False)\n        self.search_box.bind(\"<KP_Enter>\", self._on_search, False)\n\n        # Selecting chars in the search box with mouse didn't make the box active on Linux without following line\n        self.search_box.bind(\"<B1-Motion>\", lambda _: self.search_box.focus_set())\n\n        self.search_button = ttk.Button(\n            header_frame, text=self.get_search_button_text(), command=self._on_search, width=25\n        )\n        self.search_button.grid(row=1, column=1, sticky=\"nse\", padx=(10, 0))\n\n        main_pw = tk.PanedWindow(\n            parent,\n            orient=tk.HORIZONTAL,\n            background=lookup_style_option(\"TPanedWindow\", \"background\"),\n            sashwidth=15,\n        )\n        main_pw.grid(row=2, column=0, sticky=\"nsew\", padx=15, pady=15)\n        parent.rowconfigure(2, weight=1)\n        parent.columnconfigure(0, weight=1)\n\n        listframe = ttk.Frame(main_pw, relief=\"flat\", borderwidth=1)\n        listframe.rowconfigure(0, weight=1)\n        listframe.columnconfigure(0, weight=1)\n\n        self.listbox = ui_utils.ThemedListbox(\n            listframe,\n            activestyle=\"dotbox\",\n            width=20,\n            height=20,\n            selectborderwidth=0,\n            relief=\"flat\",\n            # highlightthickness=4,\n            # highlightbackground=\"red\",\n            # highlightcolor=\"green\",\n            borderwidth=0,\n        )\n        self.listbox.insert(\"end\", \" <\" + tr(\"INSTALL\") + \">\")\n        self.listbox.bind(\"<<ListboxSelect>>\", self._on_listbox_select, True)\n        self.listbox.grid(row=0, column=0, sticky=\"nsew\")\n        list_scrollbar = AutoScrollbar(\n            listframe, orient=tk.VERTICAL, style=scrollbar_style(\"Vertical\")\n        )\n        list_scrollbar.grid(row=0, column=1, sticky=\"ns\")\n        list_scrollbar[\"command\"] = self.listbox.yview\n        self.listbox[\"yscrollcommand\"] = list_scrollbar.set\n\n        info_frame = ttk.Frame(main_pw)\n        info_frame.columnconfigure(0, weight=1)\n        info_frame.rowconfigure(1, weight=1)\n\n        main_pw.add(listframe)\n        main_pw.add(info_frame)\n\n        self.title_label = ttk.Label(info_frame, text=\"\", font=name_font)\n        self.title_label.grid(row=0, column=0, sticky=\"w\", padx=5, pady=(0, ems_to_pixels(1)))\n\n        info_text_frame = tktextext.TextFrame(\n            info_frame,\n            read_only=True,\n            horizontal_scrollbar=False,\n            background=lookup_style_option(\"TFrame\", \"background\"),\n            vertical_scrollbar_class=AutoScrollbar,\n            vertical_scrollbar_style=scrollbar_style(\"Vertical\"),\n            horizontal_scrollbar_style=scrollbar_style(\"Horizontal\"),\n            width=70,\n            height=10,\n        )\n        info_text_frame.configure(borderwidth=0)\n        info_text_frame.grid(row=1, column=0, columnspan=4, sticky=\"nsew\", pady=(0, 10))\n        self.info_text = info_text_frame.text\n        link_color = lookup_style_option(\"Url.TLabel\", \"foreground\", \"red\")\n        self.info_text.tag_configure(\"url\", foreground=link_color, underline=True)\n        self.info_text.tag_bind(\"url\", \"<ButtonRelease-1>\", self._handle_url_click)\n        self.info_text.tag_bind(\"url\", \"<Enter>\", lambda e: self.info_text.config(cursor=\"hand2\"))\n        self.info_text.tag_bind(\"url\", \"<Leave>\", lambda e: self.info_text.config(cursor=\"\"))\n        self.info_text.tag_configure(\"install_reqs\", foreground=link_color, underline=True)\n        self.info_text.tag_bind(\n            \"install_reqs\", \"<ButtonRelease-1>\", self._handle_install_requirements_click\n        )\n        self.info_text.tag_bind(\n            \"install_reqs\", \"<Enter>\", lambda e: self.info_text.config(cursor=\"hand2\")\n        )\n        self.info_text.tag_bind(\n            \"install_reqs\", \"<Leave>\", lambda e: self.info_text.config(cursor=\"\")\n        )\n        self.info_text.tag_configure(\"install_file\", foreground=link_color, underline=True)\n        self.info_text.tag_bind(\n            \"install_file\", \"<ButtonRelease-1>\", self._handle_install_file_click\n        )\n        self.info_text.tag_bind(\n            \"install_file\", \"<Enter>\", lambda e: self.info_text.config(cursor=\"hand2\")\n        )\n        self.info_text.tag_bind(\n            \"install_file\", \"<Leave>\", lambda e: self.info_text.config(cursor=\"\")\n        )\n\n        default_font = tk.font.nametofont(\"TkDefaultFont\")\n        self.info_text.configure(font=default_font, wrap=\"word\")\n\n        bold_font = default_font.copy()\n        # need to explicitly copy size, because Tk 8.6 on certain Ubuntus use bigger font in copies\n        bold_font.configure(weight=\"bold\", size=default_font.cget(\"size\"))\n        self.info_text.tag_configure(\"caption\", font=bold_font)\n        self.info_text.tag_configure(\"bold\", font=bold_font)\n\n        self.command_frame = ttk.Frame(info_frame)\n        self.command_frame.grid(row=2, column=0, sticky=\"w\")\n\n        self.install_button = ttk.Button(\n            self.command_frame,\n            text=\" \" + self.get_upgrade_button_text() + \" \",\n            command=self._on_install_click,\n            width=20,\n        )\n\n        self.install_button.grid(row=0, column=0, sticky=\"w\", padx=0)\n\n        self.uninstall_button = ttk.Button(\n            self.command_frame,\n            text=self.get_uninstall_button_text(),\n            command=self._on_uninstall_click,\n            width=20,\n        )\n\n        self.uninstall_button.grid(row=0, column=1, sticky=\"w\", padx=(5, 0))\n\n        self.advanced_button = ttk.Button(\n            self.command_frame,\n            text=\"...\",\n            width=3,\n            command=lambda: self._perform_pip_action(\"advanced\"),\n        )\n\n        self.advanced_button.grid(row=0, column=2, sticky=\"w\", padx=(5, 0))\n\n        self.close_button = ttk.Button(info_frame, text=tr(\"Close\"), command=self._on_close)\n        self.close_button.grid(row=2, column=3, sticky=\"e\")", "is_method": true, "class_name": "PipDialog", "function_description": "Constructs and arranges all the graphical user interface elements for the PipDialog, including search input, package list, detailed information display, and action buttons for package management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_set_state", "line_number": 231, "body": "def _set_state(self, state, force_normal_cursor=False):\n        self._state = state\n        action_buttons = [\n            self.install_button,\n            self.advanced_button,\n            self.uninstall_button,\n        ]\n\n        other_widgets = [\n            self.listbox,\n            # self.search_box, # looks funny when disabled\n            self.search_button,\n        ]\n\n        if state == \"idle\" and not self._read_only():\n            for widget in action_buttons:\n                widget[\"state\"] = tk.NORMAL\n        else:\n            for widget in action_buttons:\n                widget[\"state\"] = tk.DISABLED\n\n        if state == \"idle\":\n            for widget in other_widgets:\n                widget[\"state\"] = tk.NORMAL\n        else:\n            self.config(cursor=get_busy_cursor())\n            for widget in other_widgets:\n                widget[\"state\"] = tk.DISABLED\n\n        if state == \"idle\" or force_normal_cursor:\n            self.config(cursor=\"\")\n        else:\n            self.config(cursor=get_busy_cursor())", "is_method": true, "class_name": "PipDialog", "function_description": "Controls the PipDialog's interactive state by enabling or disabling its UI components and setting the mouse cursor. It visually indicates whether the dialog is idle or busy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_state", "line_number": 265, "body": "def _get_state(self):\n        return self._state", "is_method": true, "class_name": "PipDialog", "function_description": "Returns the current internal state of the PipDialog object, allowing other methods to query its status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_instructions_for_command_line_install", "line_number": 268, "body": "def _instructions_for_command_line_install(self):\n        return (\n            \"Alternatively, if you have an older pip installed, then you can install packages \"\n            + \"on the command line (Tools \u2192 Open system shell...)\"\n        )", "is_method": true, "class_name": "PipDialog", "function_description": "Provides a textual instruction for users on how to install packages via the command line, specifically pointing to the \"Open system shell\" as an alternative method."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_update_list", "line_number": 277, "body": "def _update_list(self, name_to_show):\n        self.listbox.delete(1, \"end\")\n        for name in sorted(self._active_distributions.keys()):\n            self.listbox.insert(\"end\", \" \" + name)\n\n        if name_to_show is None or name_to_show not in self._active_distributions.keys():\n            self._show_instructions()\n        else:\n            self._on_listbox_select_package(name_to_show)", "is_method": true, "class_name": "PipDialog", "function_description": "Refreshes the listbox within the PipDialog, populating it with active Python distributions. It ensures the displayed list is current and sets the initial selection or shows instructions.\nRefreshes the listbox within the PipDialog, populating it with active Python distributions. It ensures the displayed list is current and sets the initial selection or shows instructions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_listbox_select", "line_number": 287, "body": "def _on_listbox_select(self, event):\n        self.listbox.focus_set()\n        selection = self.listbox.curselection()\n        if len(selection) == 1:\n            self.listbox.activate(selection[0])\n            if selection[0] == 0:  # special first item\n                self._show_instructions()\n            else:\n                self._on_listbox_select_package(self.listbox.get(selection[0]).strip())", "is_method": true, "class_name": "PipDialog", "function_description": "Handles a listbox item selection event in the PipDialog. It either displays instructions if the first item is chosen or processes the selected package name."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_listbox_select_package", "line_number": 297, "body": "def _on_listbox_select_package(self, name):\n        self._start_show_package_info(name)", "is_method": true, "class_name": "PipDialog", "function_description": "Responds to a user selecting a package from the dialog's listbox. It initiates the process of showing detailed information for the selected package."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_search", "line_number": 300, "body": "def _on_search(self, event=None):\n        if self._get_state() != \"idle\":\n            # Search box is not made inactive for busy-states\n            return\n\n        if self.search_box.get().strip() == \"\":\n            return\n\n        self._start_search(self.search_box.get().strip())", "is_method": true, "class_name": "PipDialog", "function_description": "Handles a search event by initiating a package search. It proceeds only if the dialog is idle and the search input is non-empty."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_install_click", "line_number": 310, "body": "def _on_install_click(self):\n        self._perform_pip_action(\"install\")", "is_method": true, "class_name": "PipDialog", "function_description": "Initiates a package installation action within the PipDialog, typically triggered by a user's \"install\" button click."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_uninstall_click", "line_number": 313, "body": "def _on_uninstall_click(self):\n        self._perform_pip_action(\"uninstall\")", "is_method": true, "class_name": "PipDialog", "function_description": "Initiates a package uninstallation process through pip when triggered by a user interface event within the PipDialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_clear", "line_number": 316, "body": "def _clear(self):\n        self.current_package_data = None\n        self.title_label.grid_remove()\n        self.command_frame.grid_remove()\n        self._clear_info_text()", "is_method": true, "class_name": "PipDialog", "function_description": "This method resets the PipDialog's state by clearing displayed package data and hiding its primary GUI elements, preparing it for a new view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_clear_info_text", "line_number": 322, "body": "def _clear_info_text(self):\n        self.info_text.direct_delete(\"1.0\", \"end\")", "is_method": true, "class_name": "PipDialog", "function_description": "Clears all content from the information text display within the PipDialog, resetting it to an empty state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_append_info_text", "line_number": 325, "body": "def _append_info_text(self, text, tags=()):\n        self.info_text.direct_insert(\"end\", text, tags)", "is_method": true, "class_name": "PipDialog", "function_description": "Appends specified text to the dialog's information display area, optionally applying formatting tags. This updates the user interface with informational messages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_instructions", "line_number": 328, "body": "def _show_instructions(self):\n        self._clear()\n        if self._read_only():\n            self._show_read_only_instructions()\n        else:\n            self._append_info_text(tr(\"Install from PyPI\") + \"\\n\", (\"caption\",))\n            self.info_text.direct_insert(\n                \"end\",\n                tr(\n                    \"If you don't know where to get the package from, \"\n                    + \"then most likely you'll want to search the Python Package Index. \"\n                    + \"Start by entering the name of the package in the search box above and pressing ENTER.\"\n                )\n                + \"\\n\\n\",\n            )\n\n            self.info_text.direct_insert(\n                \"end\", tr(\"Install from requirements file\") + \"\\n\", (\"caption\",)\n            )\n            self._append_info_text(tr(\"Click\" + \" \"))\n            self._append_info_text(tr(\"here\"), (\"install_reqs\",))\n            self.info_text.direct_insert(\n                \"end\",\n                \" \"\n                + tr(\"to locate requirements.txt file and install the packages specified in it.\")\n                + \"\\n\\n\",\n            )\n\n            self._show_instructions_about_installing_from_local_file()\n            self._show_instructions_about_existing_packages()\n\n            if self._get_target_directory():\n                self._show_instructions_about_target()\n\n        self._select_list_item(0)", "is_method": true, "class_name": "PipDialog", "function_description": "This method displays comprehensive instructions within the dialog for various Python package installation methods, including searching PyPI, using requirements files, or installing from local files. It adapts the displayed guidance based on the dialog's current state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_read_only_instructions", "line_number": 364, "body": "def _show_read_only_instructions(self):\n        self._append_info_text(tr(\"Browse the packages\") + \"\\n\", (\"caption\",))\n        self.info_text.direct_insert(\n            \"end\",\n            tr(\n                \"With current interpreter you can only browse the packages here.\\n\"\n                + \"Use 'Tools \u2192 Open system shell...' for installing, upgrading or uninstalling.\"\n            )\n            + \"\\n\\n\",\n        )\n\n        if self._get_target_directory():\n            self._append_info_text(tr(\"Packages' directory\") + \"\\n\", (\"caption\",))\n            self.info_text.direct_insert(\"end\", self._get_target_directory(), (\"target_directory\"))", "is_method": true, "class_name": "PipDialog", "function_description": "Informs the user that package management is read-only for the current interpreter, guiding them to external tools for installs/updates, and displays the packages' directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_instructions_about_installing_from_local_file", "line_number": 379, "body": "def _show_instructions_about_installing_from_local_file(self):\n        self._append_info_text(tr(\"Install from local file\") + \"\\n\", (\"caption\",))\n        self._append_info_text(tr(\"Click\") + \" \")\n        self._append_info_text(tr(\"here\"), (\"install_file\",))\n        self.info_text.direct_insert(\n            \"end\",\n            \" \"\n            + tr(\n                \"to locate and install the package file (usually with .whl, .tar.gz or .zip extension).\"\n            )\n            + \"\\n\\n\",\n        )", "is_method": true, "class_name": "PipDialog", "function_description": "This method displays instructions within the PipDialog, guiding users on how to install a Python package from a local file. It informs users about locating and selecting common package file types."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_instructions_about_existing_packages", "line_number": 392, "body": "def _show_instructions_about_existing_packages(self):\n        self._append_info_text(tr(\"Upgrade or uninstall\") + \"\\n\", (\"caption\",))\n        self.info_text.direct_insert(\n            \"end\", tr(\"Start by selecting the package from the left.\") + \"\\n\\n\"\n        )", "is_method": true, "class_name": "PipDialog", "function_description": "Displays instructions within the PipDialog for users to manage (upgrade or uninstall) existing Python packages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_instructions_about_target", "line_number": 398, "body": "def _show_instructions_about_target(self):\n        self._append_info_text(tr(\"Target:\") + \"  \", (\"caption\",))\n        if self._should_install_to_site_packages():\n            self.info_text.direct_insert(\"end\", tr(\"virtual environment\") + \"\\n\", (\"caption\",))\n        else:\n            self.info_text.direct_insert(\"end\", tr(\"user site packages\") + \"\\n\", (\"caption\",))\n\n        self.info_text.direct_insert(\n            \"end\",\n            tr(\n                \"This dialog lists all available packages,\"\n                + \" but allows upgrading and uninstalling only packages from\"\n            )\n            + \" \",\n        )\n        self._append_info_text(self._get_target_directory(), (\"url\"))\n        self.info_text.direct_insert(\n            \"end\",\n            \". \"\n            + tr(\n                \"New packages will be also installed into this directory.\"\n                + \" Other locations must be managed by alternative means.\"\n            ),\n        )", "is_method": true, "class_name": "PipDialog", "function_description": "Provides the user with instructions about the current Python package installation target. It clarifies where packages will be installed, upgraded, or uninstalled within the dialog's scope."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_show_package_info", "line_number": 423, "body": "def _start_show_package_info(self, name):\n        self.current_package_data = None\n        # Fetch info from PyPI\n        self._set_state(\"fetching\")\n        # Following fetches info about latest version.\n        # This is OK even when we're looking an installed older version\n        # because new version may have more relevant and complete info.\n        _start_fetching_package_info(name, None, self._show_package_info)\n\n        self._clear_info_text()\n        self.title_label[\"text\"] = \"\"\n        self.title_label.grid()\n        self.command_frame.grid()\n        self.uninstall_button[\"text\"] = self.get_uninstall_button_text()\n\n        active_dist = self._get_active_dist(name)\n        if active_dist is not None:\n            self.title_label[\"text\"] = active_dist[\"project_name\"]\n            self._append_info_text(tr(\"Installed version:\") + \" \", (\"caption\",))\n            self._append_info_text(active_dist[\"version\"] + \"\\n\")\n            self._append_info_text(tr(\"Installed to:\") + \" \", (\"caption\",))\n            # TODO: only show link if local backend\n            self.info_text.direct_insert(\n                \"end\", normpath_with_actual_case(active_dist[\"location\"]), (\"url\",)\n            )\n            self._append_info_text(\"\\n\\n\")\n            self._select_list_item(name)\n        else:\n            self._select_list_item(0)\n\n        # update gui\n        if self._is_read_only_package(name):\n            self.install_button.grid_remove()\n            self.uninstall_button.grid_remove()\n            self.advanced_button.grid_remove()\n        else:\n            self.install_button.grid(row=0, column=0)\n            self.advanced_button.grid(row=0, column=2)\n\n            if active_dist is not None:\n                # existing package in target directory\n                self.install_button[\"text\"] = self.get_upgrade_button_text()\n                self.install_button[\"state\"] = \"disabled\"\n                self.uninstall_button.grid(row=0, column=1)\n            else:\n                # new package\n                self.install_button[\"text\"] = self.get_install_button_text()\n                self.uninstall_button.grid_remove()", "is_method": true, "class_name": "PipDialog", "function_description": "Initiates fetching and displaying detailed information for a specified Python package within the dialog. It updates the GUI with package details, including installation status, and adjusts action buttons based on the package's state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_package_info", "line_number": 472, "body": "def _show_package_info(self, name, data, error_code=None):\n        self._set_state(\"idle\")\n\n        self.current_package_data = data\n\n        def write(s, tag=None):\n            if tag is None:\n                tags = ()\n            else:\n                tags = (tag,)\n            self._append_info_text(s, tags)\n\n        def write_att(caption, value, value_tag=None):\n            write(caption + \": \", \"caption\")\n            write(value, value_tag)\n            write(\"\\n\")\n\n        if error_code is not None:\n            if error_code == 404:\n                write(tr(\"Could not find the package from PyPI.\"))\n                if not self._get_active_version(name):\n                    # new package\n                    write(\"\\n\" + tr(\"Please check your spelling!\"))\n\n            else:\n                write(\n                    tr(\"Could not find the package info from PyPI.\")\n                    + \" \"\n                    + tr(\"Error code:\")\n                    + \" \"\n                    + str(error_code)\n                )\n\n            return\n\n        info = data[\"info\"]\n        self.title_label[\"text\"] = info[\"name\"]  # search name could have been a bit different\n        latest_stable_version = _get_latest_stable_version(data[\"releases\"].keys())\n        if latest_stable_version is not None:\n            write_att(tr(\"Latest stable version\"), latest_stable_version)\n        else:\n            write_att(tr(\"Latest version\"), data[\"info\"][\"version\"])\n        write_att(tr(\"Summary\"), info[\"summary\"])\n        write_att(tr(\"Author\"), info[\"author\"])\n        write_att(tr(\"Homepage\"), info[\"home_page\"], \"url\")\n        if info.get(\"bugtrack_url\", None):\n            write_att(tr(\"Bugtracker\"), info[\"bugtrack_url\"], \"url\")\n        if info.get(\"docs_url\", None):\n            write_att(tr(\"Documentation\"), info[\"docs_url\"], \"url\")\n        if info.get(\"package_url\", None):\n            write_att(tr(\"PyPI page\"), info[\"package_url\"], \"url\")\n        if info.get(\"requires_dist\", None):\n            # Available only when release is created by a binary wheel\n            # https://github.com/pypa/pypi-legacy/issues/622#issuecomment-305829257\n            write_att(tr(\"Requires\"), \", \".join(info[\"requires_dist\"]))\n\n        if self._get_active_version(name) != latest_stable_version or not self._get_active_version(\n            name\n        ):\n            self.install_button[\"state\"] = \"normal\"\n        else:\n            self.install_button[\"state\"] = \"disabled\"", "is_method": true, "class_name": "PipDialog", "function_description": "Renders comprehensive information for a specified Python package within the dialog, including details like version and summary. It also displays error messages if the package is not found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_is_read_only_package", "line_number": 535, "body": "def _is_read_only_package(self, name):\n        dist = self._get_active_dist(name)\n        if dist is None:\n            return False\n        else:\n            return normpath_with_actual_case(dist[\"location\"]) != self._get_target_directory()", "is_method": true, "class_name": "PipDialog", "function_description": "Identifies if a package is installed outside the dialog's editable target directory, classifying it as read-only for management purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_normalize_name", "line_number": 542, "body": "def _normalize_name(self, name):\n        # looks like (in some cases?) pip list gives the name as it was used during install\n        # ie. the list may contain lowercase entry, when actual metadata has uppercase name\n        # Example: when you \"pip install cx-freeze\", then \"pip list\"\n        # really returns \"cx-freeze\" although correct name is \"cx_Freeze\"\n\n        # https://www.python.org/dev/peps/pep-0503/#id4\n        return re.sub(r\"[-_.]+\", \"-\", name).lower().strip()", "is_method": true, "class_name": "PipDialog", "function_description": "Normalizes a Python package name string, converting variations found in pip output to a consistent, standardized format. This ensures reliable comparison and lookup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_search", "line_number": 551, "body": "def _start_search(self, query, discard_selection=True):\n        self.current_package_data = None\n        # Fetch info from PyPI\n        self._set_state(\"fetching\")\n        self._clear()\n        self.title_label.grid()\n        self.title_label[\"text\"] = tr(\"Search results\")\n        self.info_text.direct_insert(\"1.0\", tr(\"Searching\") + \" ...\")\n        _start_fetching_search_results(query, self._show_search_results)\n        if discard_selection:\n            self._select_list_item(0)", "is_method": true, "class_name": "PipDialog", "function_description": "Initiates an asynchronous search for Python packages based on a user query. It updates the dialog's UI to show the fetching state while waiting for results."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_search_results", "line_number": 563, "body": "def _show_search_results(self, query, results: Union[List[Dict], str]) -> None:\n        self._set_state(\"idle\")\n        self._clear_info_text()\n\n        results = self._tweak_search_results(results, query)\n\n        if isinstance(results, str) or not results:\n            if not results:\n                self._append_info_text(\"No results.\\n\\n\")\n            else:\n                self._append_info_text(\"Could not fetch search results:\\n\")\n                self._append_info_text(results + \"\\n\\n\")\n\n            self._append_info_text(\"Try opening the package directly:\\n\")\n            self._append_info_text(query, (\"url\",))\n            return\n\n        for item in results:\n            # self._append_info_text(\"\u2022\")\n            tags = (\"url\",)\n            if item[\"name\"].lower() == query.lower():\n                tags = tags + (\"bold\",)\n\n            self._append_info_text(item[\"name\"], tags)\n            self._append_info_text(\"\\n\")\n            self.info_text.direct_insert(\n                \"end\", item.get(\"description\", \"<No description>\").strip() + \"\\n\"\n            )\n            self._append_info_text(\"\\n\")", "is_method": true, "class_name": "PipDialog", "function_description": "Displays search results for Python packages within the PipDialog. It formats package names and descriptions, providing user feedback for no results or errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_select_list_item", "line_number": 593, "body": "def _select_list_item(self, name_or_index):\n        if isinstance(name_or_index, int):\n            index = name_or_index\n        else:\n            normalized_items = list(map(self._normalize_name, self.listbox.get(0, \"end\")))\n            try:\n                index = normalized_items.index(self._normalize_name(name_or_index))\n            except Exception:\n                exception(tr(\"Can't find package name from the list:\") + \" \" + name_or_index)\n                return\n\n        old_state = self.listbox[\"state\"]\n        try:\n            self.listbox[\"state\"] = \"normal\"\n            self.listbox.select_clear(0, \"end\")\n            self.listbox.select_set(index)\n            self.listbox.activate(index)\n            self.listbox.see(index)\n        finally:\n            self.listbox[\"state\"] = old_state", "is_method": true, "class_name": "PipDialog", "function_description": "This method programmatically selects an item in the dialog's listbox, either by its index or a normalized name. It ensures the selected item is visible and activated for user interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_install_command", "line_number": 614, "body": "def _get_install_command(self):\n        cmd = [\"install\", \"--no-cache-dir\"]\n        if self._use_user_install():\n            cmd.append(\"--user\")\n        return cmd", "is_method": true, "class_name": "PipDialog", "function_description": "Constructs the base `pip install` command arguments. It ensures installation without caching and optionally adds `--user` for user-specific installations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_perform_pip_action", "line_number": 620, "body": "def _perform_pip_action(self, action: str) -> bool:\n        if self._perform_pip_action_without_refresh(action):\n            if action == \"uninstall\":\n                self._show_instructions()  # Make the old package go away as fast as possible\n            self._start_update_list(\n                None if action == \"uninstall\" else self.current_package_data[\"info\"][\"name\"]\n            )\n\n            get_workbench().event_generate(\"RemoteFilesChanged\")", "is_method": true, "class_name": "PipDialog", "function_description": "Manages and executes a pip package action, such as install or uninstall. It then updates the UI and notifies the system about file changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_perform_pip_action_without_refresh", "line_number": 630, "body": "def _perform_pip_action_without_refresh(self, action: str) -> bool:\n        assert self._get_state() == \"idle\"\n        assert self.current_package_data is not None\n        data = self.current_package_data\n        name = self.current_package_data[\"info\"][\"name\"]\n\n        install_cmd = self._get_install_command()\n\n        if action == \"install\":\n            title = tr(\"Installing '%s'\") % name\n            if not self._confirm_install(self.current_package_data):\n                return False\n\n            args = install_cmd\n            if self._get_active_version(name) is not None:\n                title = tr(\"Upgrading '%s'\") % name\n                args.append(\"--upgrade\")\n\n            args.append(name)\n        elif action == \"uninstall\":\n            title = tr(\"Uninstalling '%s'\") % name\n            if name in [\"pip\", \"setuptools\"] and not messagebox.askyesno(\n                tr(\"Really uninstall?\"),\n                tr(\n                    \"Package '{}' is required for installing and uninstalling other packages.\"\n                ).format(name)\n                + \"\\n\\n\"\n                + tr(\"Are you sure you want to uninstall it?\"),\n                master=self,\n            ):\n                return False\n            args = [\"uninstall\", \"-y\", name]\n        elif action == \"advanced\":\n            title = tr(\"Installing\")\n            details = _ask_installation_details(\n                self,\n                data,\n                _get_latest_stable_version(list(data[\"releases\"].keys())),\n                self.does_support_update_deps_switch(),\n            )\n            if details is None:  # Cancel\n                return False\n\n            version, package_data, upgrade_deps = details\n            if not self._confirm_install(package_data):\n                return False\n\n            args = install_cmd\n            if upgrade_deps:\n                args.append(\"--upgrade\")\n            args.append(name + \"==\" + version)\n        else:\n            raise RuntimeError(\"Unknown action\")\n\n        returncode, _, _ = self._run_pip_with_dialog(args, title=title)\n        return returncode == 0", "is_method": true, "class_name": "PipDialog", "function_description": "This method performs a specified pip action (install, uninstall, or advanced install) for the current package. It constructs the necessary pip commands, handles user confirmations, and executes the operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "does_support_update_deps_switch", "line_number": 687, "body": "def does_support_update_deps_switch(self):\n        return True", "is_method": true, "class_name": "PipDialog", "function_description": "Indicates that the PipDialog supports an option or switch for updating dependencies."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_handle_install_file_click", "line_number": 690, "body": "def _handle_install_file_click(self, event):\n        if self._get_state() != \"idle\":\n            return\n\n        filename = askopenfilename(\n            master=self,\n            filetypes=[(tr(\"Package\"), \".whl .zip .tar.gz\"), (tr(\"all files\"), \".*\")],\n            initialdir=get_workbench().get_local_cwd(),\n            parent=self.winfo_toplevel(),\n        )\n        if filename:  # Note that missing filename may be \"\" or () depending on tkinter version\n            self._install_local_file(filename, False)", "is_method": true, "class_name": "PipDialog", "function_description": "Handles a user click to install a local Python package. It prompts the user to select a package file, then initiates its installation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_handle_install_requirements_click", "line_number": 703, "body": "def _handle_install_requirements_click(self, event):\n        if self._get_state() != \"idle\":\n            return\n\n        filename = askopenfilename(\n            master=self,\n            filetypes=[(\"requirements\", \".txt\"), (tr(\"all files\"), \".*\")],\n            initialdir=get_workbench().get_local_cwd(),\n            parent=self.winfo_toplevel(),\n        )\n        if filename:  # Note that missing filename may be \"\" or () depending on tkinter version\n            self._install_local_file(filename, True)", "is_method": true, "class_name": "PipDialog", "function_description": "Handles a user's action to install Python package requirements. It prompts the user to select a `requirements.txt` file and then initiates the package installation process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_handle_target_directory_click", "line_number": 716, "body": "def _handle_target_directory_click(self, event):\n        if self._get_target_directory():\n            open_path_in_system_file_manager(self._get_target_directory())", "is_method": true, "class_name": "PipDialog", "function_description": "Handles a click event to open the configured target directory in the system's file manager, if a valid path is available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_install_local_file", "line_number": 720, "body": "def _install_local_file(self, filename, is_requirements_file):\n        args = [\"install\"]\n        if self._use_user_install():\n            args.append(\"--user\")\n        if is_requirements_file:\n            args.append(\"-r\")\n        args.append(filename)\n\n        returncode, out, err = self._run_pip_with_dialog(\n            args, title=tr(\"Installing '%s'\") % os.path.basename(filename)\n        )\n\n        # Try to find out the name of the package we're installing\n        name = None\n\n        # output should include a line like this:\n        # Installing collected packages: pytz, six, python-dateutil, numpy, pandas\n        inst_lines = re.findall(\n            \"^Installing collected packages:.*?$\", out, re.MULTILINE | re.IGNORECASE\n        )  # @UndefinedVariable\n        if len(inst_lines) == 1:\n            # take last element\n            elements = re.split(\",|:\", inst_lines[0])\n            name = elements[-1].strip()\n\n        self._start_update_list(name)", "is_method": true, "class_name": "PipDialog", "function_description": "This method facilitates the installation of a local Python package or requirements file using pip, providing interactive feedback through a dialog. It identifies the installed package name for subsequent list updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_handle_url_click", "line_number": 747, "body": "def _handle_url_click(self, event):\n        url = _extract_click_text(self.info_text, event, \"url\")\n        if url is not None:\n            if url.startswith(\"http:\") or url.startswith(\"https:\"):\n                import webbrowser\n\n                webbrowser.open(url)\n            elif os.path.sep in url:\n                os.makedirs(url, exist_ok=True)\n                open_path_in_system_file_manager(url)\n            else:\n                self._start_show_package_info(url)", "is_method": true, "class_name": "PipDialog", "function_description": "Handles clicks on text within the dialog's info display. It intelligently opens web URLs in a browser, local paths in a file manager, or fetches detailed information for package names.\nHandles clicks on text within the dialog's info display. It intelligently opens web URLs in a browser, local paths in a file manager, or fetches detailed information for package names."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_on_close", "line_number": 760, "body": "def _on_close(self, event=None):\n        self._closed = True\n        self.destroy()", "is_method": true, "class_name": "PipDialog", "function_description": "This method handles the closure of the `PipDialog` instance. It updates an internal state to reflect closure and disposes of the dialog's graphical interface elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_active_version", "line_number": 764, "body": "def _get_active_version(self, name):\n        dist = self._get_active_dist(name)\n        if dist is None:\n            return None\n        else:\n            return dist[\"version\"]", "is_method": true, "class_name": "PipDialog", "function_description": "Retrieves the version of a specified active Python package. Returns None if the package is not found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_active_dist", "line_number": 771, "body": "def _get_active_dist(self, name):\n        normname = self._normalize_name(name)\n        for key in self._active_distributions:\n\n            if self._normalize_name(key) == normname:\n                return self._active_distributions[key]\n\n        return None", "is_method": true, "class_name": "PipDialog", "function_description": "Retrieves an active Python package distribution by its normalized name. It returns the distribution object if found, otherwise None."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_use_user_install", "line_number": 789, "body": "def _use_user_install(self):\n        return not self._should_install_to_site_packages()", "is_method": true, "class_name": "PipDialog", "function_description": "This method determines if packages should be installed to the user's local directory instead of system-wide. It helps control the installation scope within the PipDialog context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_title", "line_number": 795, "body": "def _get_title(self):\n        return tr(\"Manage packages for %s\") % self._get_interpreter()", "is_method": true, "class_name": "PipDialog", "function_description": "This method dynamically generates the title for the package management dialog. It specifies that packages are being managed for a particular Python interpreter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_read_only", "line_number": 801, "body": "def _read_only(self):\n        if self._should_install_to_site_packages():\n            return False\n        else:\n            # readonly if not in a virtual environment\n            # and user site packages is disabled\n            import site\n\n            return not site.ENABLE_USER_SITE", "is_method": true, "class_name": "PipDialog", "function_description": "Determines if the current Python environment is read-only for package installations. It considers virtual environment usage and user site package settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_extra_switches", "line_number": 814, "body": "def _get_extra_switches(self):\n        result = [\"--disable-pip-version-check\"]\n        proxy = os.environ.get(\"https_proxy\", os.environ.get(\"http_proxy\", None))\n        if proxy:\n            result.append(\"--proxy=\" + proxy)\n\n        return result", "is_method": true, "class_name": "PipDialog", "function_description": "This method generates a list of command-line switches for pip, including disabling version checks and adding proxy configurations if defined in environment variables."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_update_list", "line_number": 830, "body": "def _start_update_list(self, name_to_show=None):\n        assert self._get_state() in [None, \"idle\"]\n        self._set_state(\"listing\")\n\n        get_workbench().bind(\"get_active_distributions_response\", self._complete_update_list, True)\n        self._last_name_to_show = name_to_show\n        logger.debug(\"Sending get_active_distributions\")\n        get_runner().send_command(InlineCommand(\"get_active_distributions\"))", "is_method": true, "class_name": "BackendPipDialog", "function_description": "Starts the process of asynchronously fetching a list of active Python distributions from the backend. It prepares the dialog to handle the upcoming response, setting its state to 'listing'."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_complete_update_list", "line_number": 839, "body": "def _complete_update_list(self, msg):\n        if self._closed:\n            return\n\n        get_workbench().unbind(\"get_active_distributions_response\", self._complete_update_list)\n        if \"error\" in msg:\n            self._clear_info_text()\n            self.info_text.direct_insert(\"1.0\", msg[\"error\"])\n            self._set_state(\"idle\", True)\n            return\n\n        self._active_distributions = msg.distributions\n        self._set_state(\"idle\", True)\n        self._update_list(self._last_name_to_show)", "is_method": true, "class_name": "BackendPipDialog", "function_description": "Finalizes the asynchronous retrieval of active distributions for the dialog. It updates the internal list based on the backend response and refreshes the display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_interpreter", "line_number": 860, "body": "def _get_interpreter(self):\n        return get_runner().get_local_executable()", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Retrieves the path to the local Python interpreter executable. Essential for the CPythonBackendPipDialog to manage its associated Python environment.\nRetrieves the path to the local Python interpreter executable. Essential for the CPythonBackendPipDialog to manage its associated Python environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_create_python_process", "line_number": 863, "body": "def _create_python_process(self, args):\n        proc = running.create_backend_python_process(args, stderr=subprocess.STDOUT)\n        return proc, proc.cmd", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "This method launches a new CPython backend process, likely for executing pip commands. It returns the process object and its command for further management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_confirm_install", "line_number": 867, "body": "def _confirm_install(self, package_data):\n        name = package_data[\"info\"][\"name\"]\n\n        if name.lower().startswith(\"thonny\"):\n            return messagebox.askyesno(\n                tr(\"Confirmation\"),\n                tr(\n                    \"Looks like you are installing a Thonny-related package.\\n\"\n                    + \"If you meant to install a Thonny plugin, then you should\\n\"\n                    + \"choose 'Tools \u2192 Manage plugins...' instead\\n\"\n                    + \"\\n\"\n                    + \"Are you sure you want to install %s for the back-end?\"\n                )\n                % name,\n                master=self,\n            )\n        else:\n            return True", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Provides conditional user confirmation before installing a Python package. It specifically warns users about Thonny-related packages, guiding them to the correct plugin management tool."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_target_directory", "line_number": 886, "body": "def _get_target_directory(self):\n        if self._should_install_to_site_packages():\n            return normpath_with_actual_case(self._backend_proxy.get_site_packages())\n        else:\n            usp = self._backend_proxy.get_user_site_packages()\n            if isinstance(self._backend_proxy, CPythonProxy):\n                os.makedirs(usp, exist_ok=True)\n                return normpath_with_actual_case(usp)\n            else:\n                return usp", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "This method determines and returns the appropriate directory for Python package installations. It selects between system-wide or user-specific site-packages, ensuring the latter exists for CPython environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_should_install_to_site_packages", "line_number": 897, "body": "def _should_install_to_site_packages(self):\n        return self._targets_virtual_environment()", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Determines if packages should be installed into the `site-packages` directory of the current Python environment. This decision is based on whether a virtual environment is being targeted."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_targets_virtual_environment", "line_number": 900, "body": "def _targets_virtual_environment(self):\n        return get_runner().using_venv()", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Indicates whether the Python environment used by the dialog is a virtual environment. This determines how subsequent package operations will behave."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_run_pip_with_dialog", "line_number": 903, "body": "def _run_pip_with_dialog(self, args, title) -> Tuple[int, str, str]:\n        proxy = get_runner().get_backend_proxy()\n        assert isinstance(proxy, CPythonProxy)\n        sub_cmd = [proxy._reported_executable, \"-m\", \"pip\"] + args + self._get_extra_switches()\n        back_cmd = InlineCommand(\"execute_system_command\", cmd_line=sub_cmd)\n        dlg = InlineCommandDialog(\n            self,\n            back_cmd,\n            title=\"pip\",\n            instructions=title,\n            autostart=True,\n            output_prelude=subprocess.list2cmdline(sub_cmd) + \"\\n\\n\",\n        )\n        ui_utils.show_dialog(dlg)\n\n        return dlg.returncode, dlg.stdout, dlg.stderr", "is_method": true, "class_name": "CPythonBackendPipDialog", "function_description": "Runs a pip command on the CPython backend. It displays the command's execution and output in a user interface dialog, returning the results."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_update_list", "line_number": 929, "body": "def _start_update_list(self, name_to_show=None):\n        assert self._get_state() in [None, \"idle\"]\n        import pkg_resources\n\n        pkg_resources._initialize_master_working_set()\n\n        self._active_distributions = {\n            dist.key: {\n                \"project_name\": dist.project_name,\n                \"key\": dist.key,\n                \"location\": dist.location,\n                \"version\": dist.version,\n            }\n            for dist in pkg_resources.working_set  # pylint: disable=not-an-iterable\n        }\n\n        self._update_list(name_to_show)", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "This method initializes and populates the dialog's internal data structure with details of all currently installed Python packages. It prepares the information needed to display the list of plugins."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_conflicts_with_thonny_version", "line_number": 947, "body": "def _conflicts_with_thonny_version(self, req_strings):\n        import pkg_resources\n\n        try:\n            conflicts = []\n            for req_string in req_strings:\n                req = pkg_resources.Requirement.parse(req_string)\n                if req.project_name == \"thonny\" and thonny.get_version() not in req:\n                    conflicts.append(req_string)\n\n            return conflicts\n        except Exception:\n            logging.exception(\"Problem computing conflicts\")\n            return None", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Identifies Thonny version requirements within a list of package strings that conflict with the currently running Thonny version. Essential for plugin compatibility checks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_interpreter", "line_number": 962, "body": "def _get_interpreter(self):\n        return get_interpreter_for_subprocess(sys.executable)", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "This method provides the Python interpreter path optimized for running subprocesses. It is used by the PluginsPipDialog to ensure plugin management operations execute correctly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_should_install_to_site_packages", "line_number": 965, "body": "def _should_install_to_site_packages(self):\n        return self._targets_virtual_environment()", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "This method determines if packages should be installed into the `site-packages` directory of the currently targeted Python environment, specifically checking if a virtual environment is active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_targets_virtual_environment", "line_number": 968, "body": "def _targets_virtual_environment(self):\n        # https://stackoverflow.com/a/42580137/261181\n        return (\n            hasattr(sys, \"base_prefix\")\n            and sys.base_prefix != sys.prefix\n            or hasattr(sys, \"real_prefix\")\n            and getattr(sys, \"real_prefix\") != sys.prefix\n        )", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Checks if the currently running Python interpreter operates within a virtual environment. This service helps the dialog determine the correct installation context for managing plugins."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_confirm_install", "line_number": 977, "body": "def _confirm_install(self, package_data):\n        name = package_data[\"info\"][\"name\"]\n        reqs = package_data[\"info\"].get(\"requires_dist\", None)\n\n        other_version_text = tr(\n            \"NB! There may be another version available \"\n            + \"which is compatible with current Thonny version. \"\n            + \"Click on '...' button to choose the version to install.\"\n        )\n\n        if name.lower().startswith(\"thonny-\") and not reqs:\n            showerror(\n                tr(\"Thonny plugin without requirements\"),\n                tr(\n                    \"Looks like you are trying to install an outdated Thonny\\n\"\n                    + \"plug-in (it doesn't specify required Thonny version).\\n\\n\"\n                    + \"If you still want it, then please install it from the command line.\"\n                )\n                + \"\\n\\n\"\n                + other_version_text,\n                master=self,\n            )\n            return False\n        elif reqs:\n            conflicts = self._conflicts_with_thonny_version(reqs)\n            if conflicts:\n                showerror(\n                    tr(\"Unsuitable requirements\"),\n                    tr(\"This package requires different Thonny version:\")\n                    + \"\\n\\n  \"\n                    + \"\\n  \".join(conflicts)\n                    + \"\\n\\n\"\n                    + tr(\"If you still want it, then please install it from the command line.\")\n                    + \"\\n\\n\"\n                    + other_version_text,\n                    master=self,\n                )\n                return False\n\n        return True", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Confirms if a chosen package is suitable for installation by validating its compatibility with the current Thonny version. It prevents installing outdated Thonny plugins or packages with conflicting requirements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_target_directory", "line_number": 1018, "body": "def _get_target_directory(self):\n        if self._use_user_install():\n            import site\n\n            assert hasattr(site, \"getusersitepackages\")\n            os.makedirs(site.getusersitepackages(), exist_ok=True)\n            return normpath_with_actual_case(site.getusersitepackages())\n        else:\n            for d in sys.path:\n                if (\"site-packages\" in d or \"dist-packages\" in d) and path_startswith(\n                    d, sys.prefix\n                ):\n                    return normpath_with_actual_case(d)\n            return None", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Determines the appropriate Python package installation directory, either user-specific or system-wide, for installing plugins."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_create_widgets", "line_number": 1033, "body": "def _create_widgets(self, parent):\n        banner = ttk.Frame(parent, style=\"Tip.TFrame\")\n        banner.grid(row=0, column=0, sticky=\"nsew\")\n\n        banner_msg = (\n            tr(\n                \"This dialog is for managing Thonny plug-ins and their dependencies.\\n\"\n                + \"If you want to install packages for your own programs then choose 'Tools \u2192 Manage packages...'\"\n            )\n            + \"\\n\"\n        )\n\n        runner = get_runner()\n        if (\n            runner is not None\n            and runner.get_local_executable() is not None\n            and is_same_path(self._get_interpreter(), get_runner().get_local_executable())\n        ):\n            banner_msg += (\n                tr(\n                    \"(In this case Thonny's back-end uses same interpreter, so both dialogs manage same packages.)\"\n                )\n                + \"\\n\"\n            )\n\n        banner_msg += \"\\n\" + tr(\n            \"NB! You need to restart Thonny after installing / upgrading / uninstalling a plug-in.\"\n        )\n\n        banner_text = ttk.Label(banner, text=banner_msg, style=\"Tip.TLabel\", justify=\"left\")\n        banner_text.grid(pady=10, padx=10)\n\n        PipDialog._create_widgets(self, parent)", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Sets up the graphical user interface for the plugin management dialog. It displays an informative banner about plugin management and restart requirements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_get_title", "line_number": 1067, "body": "def _get_title(self):\n        return tr(\"Thonny plug-ins\")", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Provides the title string specifically for the Thonny plug-ins dialog window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_run_pip_with_dialog", "line_number": 1070, "body": "def _run_pip_with_dialog(self, args, title) -> Tuple[int, str, str]:\n        args = [\"-m\", \"pip\"] + args + self._get_extra_switches()\n        proc = running.create_frontend_python_process(args, stderr=subprocess.STDOUT)\n        cmd = proc.cmd\n        dlg = SubprocessDialog(self, proc, \"pip\", long_description=title, autostart=True)\n        ui_utils.show_dialog(dlg)\n        return dlg.returncode, dlg.stdout, dlg.stderr", "is_method": true, "class_name": "PluginsPipDialog", "function_description": "Provides a user interface dialog to execute pip commands, displaying real-time output and status. It facilitates interactive package management for plugins or dependencies."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_set_state", "line_number": 1158, "body": "def _set_state(self, state):\n        self._state = state\n        widgets = [\n            self.version_combo,\n            # self.search_box, # looks funny when disabled\n            self.ok_button,\n            self.update_deps_cb,\n        ]\n\n        if state == \"idle\":\n            self.config(cursor=\"\")\n            for widget in widgets:\n                if widget == self.version_combo:\n                    widget.state([\"!disabled\", \"readonly\"])\n                else:\n                    widget[\"state\"] = tk.NORMAL\n        else:\n            self.config(cursor=get_busy_cursor())\n            for widget in widgets:\n                widget[\"state\"] = tk.DISABLED\n\n        if self.version_var.get().strip() == \"\" or not self._version_data:\n            self.ok_button[\"state\"] = tk.DISABLED", "is_method": true, "class_name": "DetailsDialog", "function_description": "Sets the interactive state of the dialog's UI elements. It enables or disables specific widgets and changes the cursor based on the dialog's current operational status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_start_fetching_version_info", "line_number": 1182, "body": "def _start_fetching_version_info(self):\n        self._set_state(\"busy\")\n        _start_fetching_package_info(\n            self._package_name, self.version_var.get(), self._show_version_info\n        )", "is_method": true, "class_name": "DetailsDialog", "function_description": "Initiates the retrieval of specific package version information for display. It sets the dialog's state to 'busy' while fetching, with a callback to process the results."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_show_version_info", "line_number": 1188, "body": "def _show_version_info(self, name, info, error_code=None):\n        if self._closed:\n            return\n\n        self._version_data = info\n        if (\n            not error_code\n            and \"requires_dist\" in info[\"info\"]\n            and isinstance(info[\"info\"][\"requires_dist\"], list)\n        ):\n            reqs = tr(\"Requires:\") + \"\\n  * \" + \"\\n  * \".join(info[\"info\"][\"requires_dist\"])\n        elif error_code:\n            reqs = tr(\"Error code:\") + \" \" + str(error_code)\n            if \"error\" in info:\n                reqs += \"\\n\" + tr(\"Error:\") + \" \" + info[\"error\"]\n        else:\n            reqs = \"\"\n\n        self.requires_label.configure(text=reqs)\n        self._set_state(\"idle\")", "is_method": true, "class_name": "DetailsDialog", "function_description": "Updates the DetailsDialog's display to show version information, including software dependencies or associated error messages, in a dedicated label."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_ok", "line_number": 1209, "body": "def _ok(self, event=None):\n        self.result = (self.version_var.get(), self._version_data, bool(self.update_deps_var.get()))\n        self._closed = True\n        self.destroy()", "is_method": true, "class_name": "DetailsDialog", "function_description": "Handles the 'OK' action for the `DetailsDialog`. It collects the user's final selections, stores them as the dialog's result, and then closes the dialog window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "_cancel", "line_number": 1214, "body": "def _cancel(self, event=None):\n        self.result = None\n        self._closed = True\n        self.destroy()", "is_method": true, "class_name": "DetailsDialog", "function_description": "Dismisses the dialog window, clearing its current result. It signals that the user has aborted the operation without making a selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "load_url", "line_number": 1223, "body": "def load_url():\n        with urlopen(url, timeout=timeout) as conn:\n            return (conn, conn.read())", "is_method": false, "function_description": "Provides a core utility to fetch raw data from a specified URL. It returns both the active connection object and the full content for subsequent processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "poll_fetch_complete", "line_number": 1269, "body": "def poll_fetch_complete():\n        import json\n\n        if url_future.done():\n            try:\n                _, bin_data = url_future.result()\n                raw_data = bin_data.decode(\"UTF-8\")\n                completion_handler(name, json.loads(raw_data))\n            except urllib.error.HTTPError as e:\n                completion_handler(\n                    name, {\"info\": {\"name\": name}, \"error\": str(e), \"releases\": {}}, e.code\n                )\n            except Exception as e:\n                completion_handler(\n                    name, {\"info\": {\"name\": name}, \"error\": str(e), \"releases\": {}}, e\n                )\n        else:\n            tk._default_root.after(200, poll_fetch_complete)", "is_method": false, "function_description": "Polls an asynchronous URL fetch operation, processing retrieved JSON data or handling errors upon completion. It then dispatches results to a specified handler."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "poll_fetch_complete", "line_number": 1298, "body": "def poll_fetch_complete():\n\n        if url_future.done():\n            try:\n                _, bin_data = url_future.result()\n                raw_data = bin_data.decode(\"UTF-8\")\n                completion_handler(query, _extract_search_results(raw_data))\n            except Exception as e:\n                completion_handler(query, str(e))\n        else:\n            tk._default_root.after(200, poll_fetch_complete)", "is_method": false, "function_description": "Polls an asynchronous web request until completion. It then processes the fetched raw data to extract search results and dispatches them to a designated completion handler, managing potential errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_class", "line_number": 1316, "body": "def get_class(attrs):\n        for name, value in attrs:\n            if name == \"class\":\n                return value\n\n        return None", "is_method": false, "function_description": "Extracts the value of the \"class\" attribute from a sequence of name-value pairs. It returns None if the \"class\" attribute is not found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "get_pip_gui_class", "line_number": 1376, "body": "def get_pip_gui_class():\n        proxy = get_runner().get_backend_proxy()\n        if proxy is None:\n            return None\n        return proxy.get_pip_gui_class()", "is_method": false, "function_description": "Retrieves the class responsible for the pip graphical user interface from the application's backend system. This provides access to a GUI component for managing Python packages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "open_backend_pip_gui", "line_number": 1382, "body": "def open_backend_pip_gui(*args):\n        pg_class = get_pip_gui_class()\n        if pg_class is None:\n            showerror(tr(\"Not supported\"), get_not_supported_translation())\n            return\n\n        if not get_runner().is_waiting_toplevel_command():\n            showerror(\n                tr(\"Not available\"),\n                tr(\"You need to stop your program before launching the package manager.\"),\n                master=get_workbench(),\n            )\n            return\n\n        pg = pg_class(get_workbench())\n        ui_utils.show_dialog(pg)", "is_method": false, "function_description": "Launches a graphical user interface for managing Python packages (pip). It ensures the program is stopped and the GUI is supported before opening."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "open_backend_pip_gui_enabled", "line_number": 1399, "body": "def open_backend_pip_gui_enabled():\n        return get_pip_gui_class() is not None", "is_method": false, "function_description": "Checks if a graphical user interface for the PIP backend is available. This enables other functions to conditionally display or utilize GUI-dependent features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "open_frontend_pip_gui", "line_number": 1402, "body": "def open_frontend_pip_gui(*args):\n        pg = PluginsPipDialog(get_workbench())\n        ui_utils.show_dialog(pg)", "is_method": false, "function_description": "Opens a graphical user interface (GUI) for managing plugins using pip."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "write", "line_number": 477, "body": "def write(s, tag=None):\n            if tag is None:\n                tags = ()\n            else:\n                tags = (tag,)\n            self._append_info_text(s, tags)", "is_method": true, "class_name": "PipDialog", "function_description": "Outputs a string to the PipDialog, optionally applying a specified tag for formatting or categorization. This provides a way to display information to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "write_att", "line_number": 484, "body": "def write_att(caption, value, value_tag=None):\n            write(caption + \": \", \"caption\")\n            write(value, value_tag)\n            write(\"\\n\")", "is_method": true, "class_name": "PipDialog", "function_description": "Displays a captioned attribute and its value within the PipDialog, formatting them for clear textual output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "version_sort_key", "line_number": 1102, "body": "def version_sort_key(s):\n            # Trying to massage understandable versions into valid StrictVersions\n            if s.replace(\".\", \"\").isnumeric():  # stable release\n                s2 = s + \"b999\"  # make it latest beta version\n            elif \"rc\" in s:\n                s2 = s.replace(\"rc\", \"b8\")\n            else:\n                s2 = s\n            try:\n                return StrictVersion(s2)\n            except Exception:\n                # use only numbers\n                nums = re.findall(r\"\\d+\", s)\n                while len(nums) < 2:\n                    nums.append(\"0\")\n                return StrictVersion(\".\".join(nums[:3]))", "is_method": true, "class_name": "DetailsDialog", "function_description": "This function transforms a version string into a sortable object, handling various non-standard formats. It enables accurate chronological sorting of software versions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "handle_starttag", "line_number": 1332, "body": "def handle_starttag(self, tag, attrs):\n            if tag == \"a\" and get_class(attrs) == \"package-snippet\":\n                self.results.append({})\n\n            if tag in (\"span\", \"p\"):\n                tag_class = get_class(attrs)\n                if tag_class in (\"package-snippet__name\", \"package-snippet__description\"):\n                    self.active_class = tag_class\n                else:\n                    self.active_class = None\n            else:\n                self.active_class = None", "is_method": true, "class_name": "PypiSearchResultsParser", "function_description": "In the `PypiSearchResultsParser`, this method identifies package snippet HTML elements. It initializes data structures and prepares the parser to extract package name and description."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "handle_data", "line_number": 1345, "body": "def handle_data(self, data):\n            if self.active_class is not None:\n                att_name = self.active_class[len(class_prefix) :]\n                self.results[-1][att_name] = data", "is_method": true, "class_name": "PypiSearchResultsParser", "function_description": "This method processes incoming data during PyPI search result parsing. It assigns the data to a specific attribute of the latest collected search result entry."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pip_gui.py", "function": "handle_endtag", "line_number": 1350, "body": "def handle_endtag(self, tag):\n            self.active_class = None", "is_method": true, "class_name": "PypiSearchResultsParser", "function_description": "Clears the internal state variable tracking the active CSS class when an HTML end tag is processed. This helps maintain correct contextual parsing within PyPI search results."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "update_highlighting", "line_number": 329, "body": "def update_highlighting(event):\n    if not get_workbench().ready:\n        # don't slow down loading process\n        return\n\n    global tree\n    if not tree:\n        # using lazy importing to speed up Thonny loading\n        from parso.python import tree  # pylint: disable=redefined-outer-name\n\n    assert isinstance(event.widget, tk.Text)\n    text = event.widget\n\n    if not hasattr(text, \"name_highlighter\"):\n        text.name_highlighter = VariablesHighlighter(text)\n        # Alternatives:\n        # NB! usages() is too slow when used on library names\n        # text.name_highlighter = CombinedHighlighter(text)\n        # text.name_highlighter = UsagesHighlighter(text)\n\n    text.name_highlighter.schedule_update()", "is_method": false, "function_description": "Schedules an update for variable highlighting within a Tkinter text widget. It initializes the highlighting mechanism if not already present, ensuring code readability is maintained."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "load_plugin", "line_number": 352, "body": "def load_plugin() -> None:\n    wb = get_workbench()\n    wb.set_default(\"view.name_highlighting\", False)\n    wb.bind_class(\"CodeViewText\", \"<<CursorMove>>\", update_highlighting, True)\n    wb.bind_class(\"CodeViewText\", \"<<TextChange>>\", update_highlighting, True)\n    wb.bind(\"<<UpdateAppearance>>\", update_highlighting, True)", "is_method": false, "function_description": "Initializes a workbench plugin to manage text highlighting in code views. It disables default name highlighting and sets up custom updates for cursor movements, text changes, and appearance events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "get_positions", "line_number": 19, "body": "def get_positions(self):\n        index = self.text.index(\"insert\")\n\n        # ignore if cursor in open string\n        if self.text.tag_prevrange(\"open_string\", index) or self.text.tag_prevrange(\n            \"open_string3\", index\n        ):\n\n            return set()\n\n        source = self.text.get(\"1.0\", \"end\")\n        index_parts = index.split(\".\")\n        line, column = int(index_parts[0]), int(index_parts[1])\n\n        return self.get_positions_for(source, line, column)", "is_method": true, "class_name": "BaseNameHighlighter", "function_description": "For `BaseNameHighlighter`, this method identifies valid text positions for highlighting based on the current cursor. It explicitly ignores positions within open string literals, leveraging `get_positions_for` for core logic."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "schedule_update", "line_number": 35, "body": "def schedule_update(self):\n        def perform_update():\n            try:\n                self.update()\n            finally:\n                self._update_scheduled = False\n\n        if not self._update_scheduled:\n            self._update_scheduled = True\n            self.text.after_idle(perform_update)", "is_method": true, "class_name": "BaseNameHighlighter", "function_description": "Schedules the text highlighting update to run efficiently when the application is idle, preventing multiple rapid updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "update", "line_number": 46, "body": "def update(self):\n        self.text.tag_remove(\"matched_name\", \"1.0\", \"end\")\n\n        if get_workbench().get_option(\"view.name_highlighting\") and self.text.is_python_text():\n            try:\n                positions = self.get_positions()\n                if len(positions) > 1:\n                    for pos in positions:\n                        start_index, end_index = pos[0], pos[1]\n                        self.text.tag_add(\"matched_name\", start_index, end_index)\n            except Exception as e:\n                logger.exception(\"Problem when updating name highlighting\", exc_info=e)", "is_method": true, "class_name": "BaseNameHighlighter", "function_description": "The `update` method of `BaseNameHighlighter` refreshes name highlighting in the text editor. It removes existing highlights and applies new ones to identified names, if enabled for Python text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_is_name_function_call_name", "line_number": 64, "body": "def _is_name_function_call_name(self, name):\n        stmt = name.get_definition()\n        return stmt.type == \"power\" and stmt.children[0] == name", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Determines if a code `name` serves as the callable target in a function call expression, distinguishing it from other variable uses."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_is_name_function_definition", "line_number": 68, "body": "def _is_name_function_definition(self, name):\n        scope = name.get_definition()\n        return (\n            isinstance(scope, tree.Function)\n            and hasattr(scope.children[1], \"value\")\n            and scope.children[1].value == name.value\n        )", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Checks if a given name object directly corresponds to the definition of a function. This method is used by the `VariablesHighlighter` to accurately identify and process function declarations.\nChecks if a given name object directly corresponds to the definition of a function. This method is used by the `VariablesHighlighter` to accurately identify and process function declarations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_get_def_from_function_params", "line_number": 76, "body": "def _get_def_from_function_params(self, func_node, name):\n        params = func_node.get_params()\n        for param in params:\n            if param.children[0].value == name.value:\n                return param.children[0]\n        return None", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "This method checks if a given variable name is defined as a parameter in a function node. It returns the AST node for the parameter definition if a match is found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_get_statement_for_position", "line_number": 84, "body": "def _get_statement_for_position(self, node, pos):\n        for c in node.children:\n            # sorted here, because the end_pos property depends on the last child having the last position,\n            # there seems to be a problem with jedi, where the children of a node are not always in the right order\n            if isinstance(c, tree.Class):\n                c.children.sort(key=lambda x: x.end_pos)\n            if c.start_pos <= pos <= c.end_pos:\n                if c.type not in (\"decorated\", \"simple_stmt\", \"suite\") and not isinstance(\n                    c, (tree.Flow, tree.ClassOrFunc)\n                ):\n                    return c\n                else:\n                    try:\n                        return jedi_utils.get_statement_of_position(c, pos)\n                    except AttributeError as e:\n                        logger.exception(\"Could not get statement of position\", exc_info=e)\n        return None", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "This method pinpoints the exact abstract syntax tree node or statement encompassing a given source code position. It's crucial for tools needing to identify specific code constructs for analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_is_global_stmt_with_name", "line_number": 102, "body": "def _is_global_stmt_with_name(self, node, name_str):\n        return (\n            isinstance(node, tree.BaseNode)\n            and node.type == \"simple_stmt\"\n            and isinstance(node.children[0], tree.GlobalStmt)\n            and node.children[0].children[1].value == name_str\n        )", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Identifies if an Abstract Syntax Tree node defines a global variable with a specified name. This helps in highlighting global variable declarations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_find_definition", "line_number": 110, "body": "def _find_definition(self, scope, name):\n        from jedi import parser_utils\n\n        # if the name is the name of a function definition\n        if isinstance(scope, tree.Function):\n            if scope.children[1] == name:\n                return scope.children[1]  # 0th child is keyword \"def\", 1st is name\n            else:\n                definition = self._get_def_from_function_params(scope, name)\n                if definition:\n                    return definition\n\n        for c in scope.children:\n            if (\n                isinstance(c, tree.BaseNode)\n                and c.type == \"simple_stmt\"\n                and isinstance(c.children[0], tree.ImportName)\n            ):\n                for n in c.children[0].get_defined_names():\n                    if n.value == name.value:\n                        return n\n                # print(c.path_for_name(name.value))\n            if (\n                isinstance(c, tree.Function)\n                and c.children[1].value == name.value\n                and not isinstance(parser_utils.get_parent_scope(c), tree.Class)\n            ):\n                return c.children[1]\n            if isinstance(c, tree.BaseNode) and c.type == \"suite\":\n                for x in c.children:\n                    if self._is_global_stmt_with_name(x, name.value):\n                        return self._find_definition(parser_utils.get_parent_scope(scope), name)\n                    if isinstance(x, tree.Name) and x.is_definition() and x.value == name.value:\n                        return x\n                    def_candidate = self._find_def_in_simple_node(x, name)\n                    if def_candidate:\n                        return def_candidate\n\n        if not isinstance(scope, tree.Module):\n            return self._find_definition(parser_utils.get_parent_scope(scope), name)\n\n        # if name itself is the left side of an assignment statement, then the name is the definition\n        if name.is_definition():\n            return name\n\n        return None", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Locates the originating definition of a specified variable, function, or imported name within a given code scope. This is a core capability for code analysis tools like 'go to definition'."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_find_def_in_simple_node", "line_number": 157, "body": "def _find_def_in_simple_node(self, node, name):\n        if isinstance(node, tree.Name) and node.is_definition() and node.value == name.value:\n            return name\n        if not isinstance(node, tree.BaseNode):\n            return None\n        for c in node.children:\n            return self._find_def_in_simple_node(c, name)", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "This internal helper method recursively searches an Abstract Syntax Tree (AST) node for the definition of a specified variable name. It assists in locating variable declarations within code structures."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_get_dot_names", "line_number": 165, "body": "def _get_dot_names(self, stmt):\n        try:\n            if (\n                hasattr(stmt, \"children\")\n                and len(stmt.children) >= 2\n                and hasattr(stmt.children[1], \"children\")\n                and len(stmt.children[1].children) >= 1\n                and hasattr(stmt.children[1].children[0], \"value\")\n                and stmt.children[1].children[0].value == \".\"\n            ):\n                return stmt.children[0], stmt.children[1].children[1]\n        except Exception as e:\n            logger.exception(\"_get_dot_names\", exc_info=e)\n            return ()\n        return ()", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Extracts the object and attribute components from an abstract syntax tree (AST) node representing a dot access expression. This helps identify qualified variable references for highlighting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "_find_usages", "line_number": 181, "body": "def _find_usages(self, name, stmt):\n        from jedi import parser_utils\n\n        # check if stmt is dot qualified, disregard these\n        dot_names = self._get_dot_names(stmt)\n        if len(dot_names) > 1 and dot_names[1].value == name.value:\n            return set()\n\n        # search for definition\n        definition = self._find_definition(parser_utils.get_parent_scope(name), name)\n\n        searched_scopes = set()\n\n        is_function_definition = (\n            self._is_name_function_definition(definition) if definition else False\n        )\n\n        def find_usages_in_node(node, global_encountered=False):\n            names = []\n            if isinstance(node, tree.BaseNode):\n                if parser_utils.is_scope(node):\n                    global_encountered = False\n                    if node in searched_scopes:\n                        return names\n                    searched_scopes.add(node)\n                    if isinstance(node, tree.Function):\n                        d = self._get_def_from_function_params(node, name)\n                        if d and d != definition:\n                            return []\n\n                for c in node.children:\n                    dot_names = self._get_dot_names(c)\n                    if len(dot_names) > 1 and dot_names[1].value == name.value:\n                        continue\n                    sub_result = find_usages_in_node(c, global_encountered=global_encountered)\n\n                    if sub_result is None:\n                        if not parser_utils.is_scope(node):\n                            return (\n                                None\n                                if definition and node != parser_utils.get_parent_scope(definition)\n                                else [definition]\n                            )\n                        else:\n                            sub_result = []\n                    names.extend(sub_result)\n                    if self._is_global_stmt_with_name(c, name.value):\n                        global_encountered = True\n            elif isinstance(node, tree.Name) and node.value == name.value:\n                if definition and definition != node:\n                    if self._is_name_function_definition(node):\n                        if isinstance(\n                            parser_utils.get_parent_scope(parser_utils.get_parent_scope(node)),\n                            tree.Class,\n                        ):\n                            return []\n                        else:\n                            return None\n                    if (\n                        node.is_definition()\n                        and not global_encountered\n                        and (\n                            is_function_definition\n                            or parser_utils.get_parent_scope(node)\n                            != parser_utils.get_parent_scope(definition)\n                        )\n                    ):\n                        return None\n                    if self._is_name_function_definition(definition) and isinstance(\n                        parser_utils.get_parent_scope(parser_utils.get_parent_scope(definition)),\n                        tree.Class,\n                    ):\n                        return None\n                names.append(node)\n            return names\n\n        if definition:\n            if self._is_name_function_definition(definition):\n                scope = parser_utils.get_parent_scope(parser_utils.get_parent_scope(definition))\n            else:\n                scope = parser_utils.get_parent_scope(definition)\n        else:\n            scope = parser_utils.get_parent_scope(name)\n\n        usages = find_usages_in_node(scope)\n        return usages", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Identifies all usages of a specific variable or identifier within its scope in the Python abstract syntax tree. This supports features like variable highlighting and refactoring."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "get_positions_for", "line_number": 268, "body": "def get_positions_for(self, source, line, column):\n        module_node = jedi_utils.parse_source(source)\n        pos = (line, column)\n        stmt = self._get_statement_for_position(module_node, pos)\n\n        name = None\n        if isinstance(stmt, tree.Name):\n            name = stmt\n        elif isinstance(stmt, tree.BaseNode):\n            name = stmt.get_name_of_position(pos)\n\n        if not name:\n            return set()\n\n        # format usage positions as tkinter text widget indices\n        return set(\n            (\n                \"%d.%d\" % (usage.start_pos[0], usage.start_pos[1]),\n                \"%d.%d\" % (usage.start_pos[0], usage.start_pos[1] + len(name.value)),\n            )\n            for usage in self._find_usages(name, stmt)\n        )", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Identifies all occurrences of a variable or identifier at a specified position in Python source code. It returns their start and end positions, formatted for UI highlighting, useful for code navigation and refactoring tools."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "get_positions_for", "line_number": 303, "body": "def get_positions_for(self, source, line, column):\n        # https://github.com/davidhalter/jedi/issues/897\n        from jedi import Script\n\n        script = Script(source + \")\")\n        usages = script.get_references(line, column, include_builtins=False)\n\n        result = {\n            (\n                \"%d.%d\" % (usage.line, usage.column),\n                \"%d.%d\" % (usage.line, usage.column + len(usage.name)),\n            )\n            for usage in usages\n            if usage.module_name == \"\"\n        }\n\n        return result", "is_method": true, "class_name": "UsagesHighlighter", "function_description": "Identifies all occurrences of a symbol at a specified code location within a source string. It returns their precise start and end character positions for highlighting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "get_positions_for", "line_number": 323, "body": "def get_positions_for(self, source, line, column):\n        usages = UsagesHighlighter.get_positions_for(self, source, line, column)\n        variables = VariablesHighlighter.get_positions_for(self, source, line, column)\n        return usages | variables", "is_method": true, "class_name": "CombinedHighlighter", "function_description": "Retrieves all relevant highlighting positions for a given source code location by combining results from both usage and variable highlighters."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "perform_update", "line_number": 36, "body": "def perform_update():\n            try:\n                self.update()\n            finally:\n                self._update_scheduled = False", "is_method": true, "class_name": "BaseNameHighlighter", "function_description": "Executes the class's core update logic, guaranteeing that the update scheduling flag is reset afterwards, even if the update operation encounters an error."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/highlight_names.py", "function": "find_usages_in_node", "line_number": 198, "body": "def find_usages_in_node(node, global_encountered=False):\n            names = []\n            if isinstance(node, tree.BaseNode):\n                if parser_utils.is_scope(node):\n                    global_encountered = False\n                    if node in searched_scopes:\n                        return names\n                    searched_scopes.add(node)\n                    if isinstance(node, tree.Function):\n                        d = self._get_def_from_function_params(node, name)\n                        if d and d != definition:\n                            return []\n\n                for c in node.children:\n                    dot_names = self._get_dot_names(c)\n                    if len(dot_names) > 1 and dot_names[1].value == name.value:\n                        continue\n                    sub_result = find_usages_in_node(c, global_encountered=global_encountered)\n\n                    if sub_result is None:\n                        if not parser_utils.is_scope(node):\n                            return (\n                                None\n                                if definition and node != parser_utils.get_parent_scope(definition)\n                                else [definition]\n                            )\n                        else:\n                            sub_result = []\n                    names.extend(sub_result)\n                    if self._is_global_stmt_with_name(c, name.value):\n                        global_encountered = True\n            elif isinstance(node, tree.Name) and node.value == name.value:\n                if definition and definition != node:\n                    if self._is_name_function_definition(node):\n                        if isinstance(\n                            parser_utils.get_parent_scope(parser_utils.get_parent_scope(node)),\n                            tree.Class,\n                        ):\n                            return []\n                        else:\n                            return None\n                    if (\n                        node.is_definition()\n                        and not global_encountered\n                        and (\n                            is_function_definition\n                            or parser_utils.get_parent_scope(node)\n                            != parser_utils.get_parent_scope(definition)\n                        )\n                    ):\n                        return None\n                    if self._is_name_function_definition(definition) and isinstance(\n                        parser_utils.get_parent_scope(parser_utils.get_parent_scope(definition)),\n                        tree.Class,\n                    ):\n                        return None\n                names.append(node)\n            return names", "is_method": true, "class_name": "VariablesHighlighter", "function_description": "Recursively traverses an Abstract Syntax Tree (AST) node to find all valid usages of a specific variable, excluding its definition. It respects Python's scoping rules to accurately identify relevant occurrences for features like highlighting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "load_plugin", "line_number": 137, "body": "def load_plugin() -> None:\n    get_workbench().add_view(VariablesView, tr(\"Variables\"), \"ne\", default_position_key=\"AAA\")", "is_method": false, "function_description": "Adds the VariablesView to the application's main workbench. This integrates a variables display into the user interface when the plugin is loaded."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_update_back_button", "line_number": 33, "body": "def _update_back_button(self, visible):\n        if visible:\n            assert self._last_active_info is not None\n            self.back_button.configure(text=tr(\"Back to\\n%s\") % self._last_active_info[-1])\n            self.back_button.place(relx=1, x=-5, y=5, anchor=\"ne\")\n        else:\n            self.back_button.place_forget()", "is_method": true, "class_name": "VariablesView", "function_description": "Controls the visibility and text of the 'back' button in the `VariablesView` user interface. It customizes the button's label to indicate the previous state when visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_handle_back_button", "line_number": 41, "body": "def _handle_back_button(self):\n        assert self._last_active_info is not None\n        if len(self._last_active_info) == 2:\n            self.show_globals(*self._last_active_info)\n        else:\n            assert len(self._last_active_info) == 4\n            self.show_frame_variables(*self._last_active_info)", "is_method": true, "class_name": "VariablesView", "function_description": "Restores the `VariablesView` to a previously displayed state. This allows users to navigate back to viewing global variables or those within a specific stack frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_handle_backend_restart", "line_number": 49, "body": "def _handle_backend_restart(self, event):\n        self._clear_tree()", "is_method": true, "class_name": "VariablesView", "function_description": "Responds to a backend restart event by clearing the displayed variables in the view, ensuring data consistency."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_handle_get_globals_response", "line_number": 52, "body": "def _handle_get_globals_response(self, event):\n        if \"error\" in event:\n            self._clear_tree()\n            messagebox.showerror(\"Error querying global variables\", event[\"error\"], master=self)\n        elif \"globals\" not in event:\n            self._clear_tree()\n            messagebox.showerror(\"Error querying global variables\", str(event), master=self)\n        else:\n            self.show_globals(event[\"globals\"], event[\"module_name\"])", "is_method": true, "class_name": "VariablesView", "function_description": "Manages the outcome of a global variable retrieval request. It displays errors or updates the view with the received global variable data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_handle_toplevel_response", "line_number": 62, "body": "def _handle_toplevel_response(self, event):\n        if \"globals\" in event:\n            self.show_globals(event[\"globals\"], \"__main__\")\n        else:\n            # MicroPython\n            get_runner().send_command(InlineCommand(\"get_globals\", module_name=\"__main__\"))", "is_method": true, "class_name": "VariablesView", "function_description": "Processes incoming data to display `__main__` module's global variables or to request them from the runtime, ensuring the variables view is updated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "show_globals", "line_number": 69, "body": "def show_globals(self, globals_, module_name, is_active=True):\n        # TODO: update only if something has changed\n        self.update_variables(globals_)\n        if module_name == \"__main__\":\n            self._set_tab_caption(tr(\"Variables\"))\n        else:\n            self._set_tab_caption(tr(\"Variables\") + \" (%s)\" % module_name)\n\n        if is_active:\n            self._last_active_info = (globals_, module_name)\n\n        self._update_back_button(not is_active)", "is_method": true, "class_name": "VariablesView", "function_description": "Updates the VariablesView to display global variables from a specific module. It sets the view's caption and manages which global scope is currently active for inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "show_frame_variables", "line_number": 82, "body": "def show_frame_variables(self, locals_, globals_, freevars, frame_name, is_active=True):\n        # TODO: update only if something has changed\n        actual_locals = {}\n        nonlocals = {}\n        for name in locals_:\n            if name in freevars:\n                nonlocals[name] = locals_[name]\n            else:\n                actual_locals[name] = locals_[name]\n\n        groups = [(\"LOCALS\", actual_locals), (\"GLOBALS\", globals_)]\n        if nonlocals:\n            groups.insert(1, (\"NONLOCALS\", nonlocals))\n\n        self.update_variables(groups)\n        self._set_tab_caption(\"Variables (%s)\" % frame_name)\n\n        if is_active:\n            self._last_active_info = (locals_, globals_, freevars, frame_name)\n\n        self._update_back_button(not is_active)", "is_method": true, "class_name": "VariablesView", "function_description": "Organizes and updates the display of local, global, and nonlocal variables for a specific execution frame, typically within a debugger's variable view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_handle_frame_info_event", "line_number": 104, "body": "def _handle_frame_info_event(self, frame_info):\n        if frame_info.get(\"error\"):\n            \"probably non-existent frame\"\n            return\n        else:\n            is_active = frame_info[\n                \"location\"\n            ] == \"stack\" or (  # same __main__ globals can be in different frames\n                frame_info[\"code_name\"] == \"<module>\"\n                and frame_info[\"module_name\"] == \"__main__\"\n                and self._last_active_info[-1] == \"__main__\"\n                and self._last_active_info[0] == frame_info[\"globals\"]\n            )\n\n            if frame_info[\"code_name\"] == \"<module>\":\n                self.show_globals(frame_info[\"globals\"], frame_info[\"module_name\"], is_active)\n            else:\n                self.show_frame_variables(\n                    frame_info[\"locals\"],\n                    frame_info[\"globals\"],\n                    frame_info[\"freevars\"],\n                    frame_info[\"code_name\"],\n                    is_active,\n                )", "is_method": true, "class_name": "VariablesView", "function_description": "This method processes execution frame details to appropriately display global or specific frame variables within the `VariablesView`, based on the frame's context and activity status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/variables.py", "function": "_set_tab_caption", "line_number": 129, "body": "def _set_tab_caption(self, text):\n        # pylint: disable=no-member\n        if self.hidden:\n            return\n\n        self.home_widget.master.tab(self.home_widget, text=text)", "is_method": true, "class_name": "VariablesView", "function_description": "Sets the visible caption or title for the `VariablesView`'s associated tab in the user interface. It updates the tab's display text unless the view is hidden."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "load_plugin", "line_number": 146, "body": "def load_plugin():\n    get_workbench().set_default(\"ssh.host\", \"\")\n    get_workbench().set_default(\"ssh.user\", \"\")\n    get_workbench().set_default(\"ssh.auth_method\", \"password\")\n    get_workbench().set_default(\"ssh.executable\", \"python3\")\n    get_workbench().set_default(\"ssh.cwd\", \"~\")\n    get_workbench().add_backend(\n        \"SSHProxy\", SshCPythonProxy, tr(\"Remote Python 3 (SSH)\"), SshProxyConfigPage, sort_key=\"15\"\n    )", "is_method": false, "function_description": "Configures default SSH settings and registers a remote Python 3 backend, enabling the application to execute Python code remotely via SSH."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "_get_launcher_with_args", "line_number": 20, "body": "def _get_launcher_with_args(self):\n        return [\n            \"-m\",\n            \"thonny.plugins.cpython_ssh\",\n            repr(\n                {\n                    \"host\": self._host,\n                    \"user\": self._user,\n                    \"password\": get_ssh_password(\"ssh\"),\n                    \"interpreter\": self._remote_interpreter,\n                    \"cwd\": self._get_initial_cwd(),\n                }\n            ),\n        ]", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "This method prepares the command-line arguments required to launch a remote CPython interpreter via SSH, leveraging the Thonny plugin and its configured connection details."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "_get_initial_cwd", "line_number": 38, "body": "def _get_initial_cwd(self):\n        return get_workbench().get_option(\"ssh.cwd\")", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Fetches the default current working directory specified for SSH connections. This setting is used to establish the initial directory for remote CPython sessions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "_publish_cwd", "line_number": 41, "body": "def _publish_cwd(self, cwd):\n        return get_workbench().set_option(\"ssh.cwd\", cwd)", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Communicates the current working directory of the SSH session to the workbench. It updates the `ssh.cwd` option, enabling the workbench to track the remote environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "interrupt", "line_number": 44, "body": "def interrupt(self):\n        # Don't interrupt local process, but direct it to device\n        self._send_msg(ImmediateCommand(\"interrupt\"))", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Sends an interrupt command to the remote CPython process managed by this SSH proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "fetch_next_message", "line_number": 48, "body": "def fetch_next_message(self):\n        msg = super().fetch_next_message()\n        if msg and \"welcome_text\" in msg:\n            assert hasattr(self, \"_reported_executable\")\n            msg[\"welcome_text\"] += \" (\" + self._reported_executable + \" on \" + self._host + \")\"\n        return msg", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Retrieves the next message from the proxy, enriching any \"welcome_text\" with details about the reported executable and host. This provides users with clear connection context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "supports_remote_files", "line_number": 55, "body": "def supports_remote_files(self):\n        return self._proc is not None", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "This method indicates whether the SshCPythonProxy is connected and capable of supporting remote file operations. It serves as a check for remote file system accessibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "uses_local_filesystem", "line_number": 58, "body": "def uses_local_filesystem(self):\n        return False", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Indicates that the SshCPythonProxy does not directly interact with the local filesystem, operating only remotely."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "ready_for_remote_file_operations", "line_number": 61, "body": "def ready_for_remote_file_operations(self):\n        return self._proc is not None and get_runner().is_waiting_toplevel_command()", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Checks if the SSH CPython proxy is ready to perform remote file operations. It verifies the underlying process is active and the remote interpreter is awaiting commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "supports_remote_directories", "line_number": 64, "body": "def supports_remote_directories(self):\n        return self._cwd is not None and self._cwd != \"\"", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Determines if the SshCPythonProxy instance is configured to support remote directory operations. It confirms if a remote current working directory is established."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "supports_trash", "line_number": 67, "body": "def supports_trash(self):\n        return False", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Reports if the SshCPythonProxy supports 'trash' functionality for file operations. This proxy explicitly indicates it does not."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "is_connected", "line_number": 70, "body": "def is_connected(self):\n        return self._proc is not None", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Reports whether the SSH CPython proxy has an active connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "_show_error", "line_number": 73, "body": "def _show_error(self, text):\n        get_shell().print_error(\"\\n\" + text + \"\\n\")", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Displays an error message to the user through the shell interface controlled by the proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "disconnect", "line_number": 76, "body": "def disconnect(self):\n        self.destroy()", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Terminates the SSH-based connection managed by this CPython proxy, effectively shutting down the remote session. This frees up resources and ensures a clean exit."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "get_node_label", "line_number": 79, "body": "def get_node_label(self):\n        return self._host", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Returns the hostname or label identifying the remote SSH node this proxy connects to."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "destroy", "line_number": 85, "body": "def destroy(self):\n        try:\n            self.send_command(ImmediateCommand(\"kill\"))\n        except BrokenPipeError:\n            pass\n        except OSError:\n            pass\n        super().destroy()", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Terminates the remote CPython process managed by this proxy. It sends a kill signal to the process and performs necessary cleanup, handling connection errors gracefully."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "can_run_remote_files", "line_number": 94, "body": "def can_run_remote_files(self):\n        return True", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Confirms the SshCPythonProxy's ability to execute remote files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "can_run_local_files", "line_number": 97, "body": "def can_run_local_files(self):\n        return False", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "This method of `SshCPythonProxy` signals that this proxy instance is not configured to execute files located on the local machine. It declares a specific operational limitation of the proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "should_show_in_switcher", "line_number": 101, "body": "def should_show_in_switcher(cls):\n        # Show when the executable, user and host are configured\n        return (\n            get_workbench().get_option(\"ssh.host\")\n            and get_workbench().get_option(\"ssh.user\")\n            and get_workbench().get_option(\"ssh.executable\")\n        )", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Determines if the SSH CPython proxy should appear in a UI switcher. It checks if required SSH host, user, and executable configurations are set."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "get_switcher_entries", "line_number": 110, "body": "def get_switcher_entries(cls):\n        if cls.should_show_in_switcher():\n            return [(cls.get_current_switcher_configuration(), cls.backend_description)]\n        else:\n            return []", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Provides entries for a configuration switcher, returning the current backend configuration and description if it should be displayed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "get_pip_gui_class", "line_number": 116, "body": "def get_pip_gui_class(self):\n        from thonny.plugins import pip_gui\n\n        return pip_gui.CPythonBackendPipDialog", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Provides the class for the graphical user interface (GUI) dialog used to manage pip packages within the remote CPython environment. This enables visual package management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "has_custom_system_shell", "line_number": 121, "body": "def has_custom_system_shell(self):\n        return True", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "This method indicates that the `SshCPythonProxy` operates with a custom system shell, signaling a specific environment characteristic."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/__init__.py", "function": "open_custom_system_shell", "line_number": 124, "body": "def open_custom_system_shell(self):\n        if not shutil.which(\"ssh\"):\n            messagebox.showerror(\n                \"Command not found\", \"Command 'ssh' not found\", master=get_workbench()\n            )\n            return\n\n        from thonny import terminal\n\n        userhost = \"%s@%s\" % (self._user, self._host)\n        terminal.run_in_terminal(\n            [\"ssh\", userhost], cwd=get_workbench().get_local_cwd(), keep_open=False, title=userhost\n        )", "is_method": true, "class_name": "SshCPythonProxy", "function_description": "Provides an interactive SSH shell session to the remote system associated with the proxy. It opens a new terminal window to connect to the configured remote host."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_handle_eof_command", "line_number": 38, "body": "def _handle_eof_command(self, msg: EOFCommand) -> None:\n        self._forward_incoming_command(msg)", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Receives and forwards end-of-file commands within the SSH CPython backend. This ensures proper propagation of termination signals."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_handle_user_input", "line_number": 41, "body": "def _handle_user_input(self, msg: InputSubmission) -> None:\n        self._forward_incoming_command(msg)", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "This method receives user input submissions for the SSH CPython backend. It immediately forwards this incoming command for further processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_handle_normal_command", "line_number": 44, "body": "def _handle_normal_command(self, cmd: CommandToBackend) -> None:\n        if cmd.name[0].isupper():\n            if \"expected_cwd\" in cmd:\n                self._cwd = cmd[\"expected_cwd\"]\n            self._restart_main_backend()\n\n        handler = getattr(self, \"_cmd_\" + cmd.name, None)\n        if handler is not None:\n            # SFTP methods defined in SshMixin\n            try:\n                response = handler(cmd)\n            except Exception as e:\n                response = {\"error\": str(e)}  # TODO:\n\n            self.send_message(self._prepare_command_response(response, cmd))\n        else:\n            # other methods running in the remote process\n            self._forward_incoming_command(cmd)", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "This method processes and dispatches incoming commands for the SSH CPython backend. It either handles commands internally, forwards them to a remote process, or triggers a backend restart, managing command responses."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_handle_immediate_command", "line_number": 63, "body": "def _handle_immediate_command(self, cmd: ImmediateCommand) -> None:\n        SshMixin._handle_immediate_command(self, cmd)\n        # It is possible that there is a command being executed both in the local and remote process,\n        # interrupt them both\n        with self._interrupt_lock:\n            interrupt_local_process()\n            self._proc.stdin.write(\"\\x03\")", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Handles an immediate command by interrupting both the local process and the remote CPython process. It provides a mechanism to stop ongoing operations across the SSH connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "send_message", "line_number": 71, "body": "def send_message(self, msg: MessageFromBackend) -> None:\n        with self._response_lock:\n            super().send_message(msg)", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Transmits a message originating from the backend. It ensures synchronized message dispatch using an internal response lock."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_forward_incoming_command", "line_number": 75, "body": "def _forward_incoming_command(self, msg):\n        self._proc.stdin.write(serialize_message(msg) + \"\\n\")", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Forwards serialized commands to the remote CPython backend's standard input. This enables the SshCPythonBackend to control or send data to the remote interpreter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_start_response_forwarder", "line_number": 78, "body": "def _start_response_forwarder(self):\n        self._response_forwarder = Thread(target=self._forward_main_responses, daemon=True)\n        self._response_forwarder.start()", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "It starts a background daemon thread that asynchronously forwards responses. This ensures continuous communication from the remote CPython backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_forward_main_responses", "line_number": 82, "body": "def _forward_main_responses(self):\n        while self._should_keep_going():\n            line = self._proc.stdout.readline()\n            if self._main_backend_is_fresh and self._looks_like_echo(line):\n                # In the beginning the backend may echo commands sent to it (perhaps this echo-avoiding trick\n                # takes time). Don't forward those lines.\n                continue\n\n            if not line:\n                break\n            with self._response_lock:\n                sys.stdout.write(line)\n                sys.stdout.flush()\n                self._main_backend_is_fresh = False", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Continuously reads and forwards output from the CPython backend process to the local standard output, allowing monitoring of the backend's activity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_looks_like_echo", "line_number": 97, "body": "def _looks_like_echo(self, line):\n        return line.startswith(\"^B\")", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "This internal method determines if a line of text, likely from an SSH session, matches a specific echo pattern."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_should_keep_going", "line_number": 100, "body": "def _should_keep_going(self) -> bool:\n        return self._proc is not None and self._proc.poll() is None", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Checks if the managed background process, likely the SSH CPython backend, is still active and running. This indicates whether ongoing operations should continue."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_start_main_backend", "line_number": 103, "body": "def _start_main_backend(self) -> RemoteProcess:\n        env = {\"THONNY_USER_DIR\": \"~/.config/Thonny\", \"THONNY_FRONTEND_SYS_PATH\": \"[]\"}\n        self._main_backend_is_fresh = True\n        return self._create_remote_process(\n            [self._remote_interpreter, \"-m\", \"thonny.plugins.cpython\", self._cwd],\n            cwd=self._get_remote_program_directory(),\n            env=env,\n        )", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Initiates the main Thonny CPython backend as a remote process. It configures the necessary environment for its operation on a remote host."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_restart_main_backend", "line_number": 112, "body": "def _restart_main_backend(self):\n        self._proc.kill()\n        self._proc = None\n        self._response_forwarder.join()\n        self._proc = self._start_main_backend()\n        self._start_response_forwarder()", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Provides the capability to fully restart the main CPython backend process, including its associated response forwarder, ensuring a fresh operational state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_get_remote_program_directory", "line_number": 119, "body": "def _get_remote_program_directory(self):\n        return \"/tmp/thonny-backend-\" + thonny.get_version()", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Provides the standardized temporary directory path on the remote system where the Thonny backend stores its operational files. This ensures version-specific isolation for remote operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "_upload_main_backend", "line_number": 122, "body": "def _upload_main_backend(self):\n        launch_dir = self._get_remote_program_directory()\n        if self._get_stat_mode_for_upload(launch_dir) and not launch_dir.endswith(\"-dev\"):\n            # don't overwrite unless in dev mode\n            return\n\n        ensure_posix_directory(\n            launch_dir + \"/thonny/plugins/cpython\",\n            self._get_stat_mode_for_upload,\n            self._mkdir_for_upload,\n        )\n\n        import thonny.ast_utils\n        import thonny.jedi_utils\n        import thonny.backend\n        import thonny.common\n        import thonny.plugins.cpython.cpython_backend\n\n        local_context = os.path.dirname(os.path.dirname(thonny.__file__))\n        for local_path in [\n            thonny.__file__,\n            thonny.common.__file__,\n            thonny.ast_utils.__file__,\n            thonny.jedi_utils.__file__,\n            thonny.backend.__file__,\n            thonny.plugins.cpython.cpython_backend.__file__,\n            thonny.plugins.cpython.__file__.replace(\"__init__\", \"__main__\"),\n        ]:\n            local_suffix = local_path[len(local_context) :]\n            remote_path = launch_dir + local_suffix.replace(\"\\\\\", \"/\")\n            self._perform_sftp_operation_with_retry(lambda sftp: sftp.put(local_path, remote_path))\n\n        def create_empty_cpython_init(sftp):\n            with sftp.open(thonny.plugins.cpython.__file__, \"w\") as fp:\n                fp.close(self._perform_sftp_operation_with_retry(create_empty_cpython_init))", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Prepares the remote environment by uploading essential Thonny CPython backend files to a designated directory via SFTP, enabling remote code execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython_ssh/ssh_cpython_backend.py", "function": "create_empty_cpython_init", "line_number": 154, "body": "def create_empty_cpython_init(sftp):\n            with sftp.open(thonny.plugins.cpython.__file__, \"w\") as fp:\n                fp.close(self._perform_sftp_operation_with_retry(create_empty_cpython_init))", "is_method": true, "class_name": "SshCPythonBackend", "function_description": "Creates or empties the `__init__.py` file for the `thonny.plugins.cpython` module on a remote system via SFTP. This ensures a clean or reset state for the remote CPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pi/__init__.py", "function": "pix", "line_number": 17, "body": "def pix():\n    MAIN_BACKGROUND = \"#ededed\"\n    detail_bg = \"#d0d0d0\"\n    detail_bg2 = \"#cfcdc8\"\n    res_dir = os.path.join(os.path.dirname(__file__), \"res\")\n    scrollbar_button_settings = {}\n    for direction, element_name in [\n        (\"up\", \"Vertical.Scrollbar.uparrow\"),\n        (\"down\", \"Vertical.Scrollbar.downarrow\"),\n        (\"left\", \"Horizontal.Scrollbar.leftarrow\"),\n        (\"right\", \"Horizontal.Scrollbar.rightarrow\"),\n    ]:\n        # load the image\n        img_name = \"scrollbar-button-\" + direction\n        for suffix in [\"\", \"-insens\"]:\n            get_workbench().get_image(\n                os.path.join(res_dir, img_name + suffix + \".png\"), img_name + suffix\n            )\n\n        scrollbar_button_settings[element_name] = {\n            \"element create\": (\n                \"image\",\n                img_name,\n                (\"!disabled\", img_name),\n                (\"disabled\", img_name + \"-insens\"),\n            )\n        }\n\n    settings = {\n        \".\": {\"configure\": {\"background\": MAIN_BACKGROUND}},\n        \"Toolbutton\": {\n            \"configure\": {\"borderwidth\": 1},\n            \"map\": {\n                \"relief\": [(\"disabled\", \"flat\"), (\"hover\", \"groove\"), (\"!hover\", \"flat\")],\n                \"background\": [\n                    (\"disabled\", MAIN_BACKGROUND),\n                    (\"!hover\", MAIN_BACKGROUND),\n                    (\"hover\", \"#ffffff\"),\n                ],\n            },\n        },\n        \"Treeview.Heading\": {\n            \"configure\": {\n                \"background\": \"#f0f0f0\",\n                \"foreground\": \"#808080\",\n                \"relief\": \"flat\",\n                \"borderwidth\": 1,\n            },\n            \"map\": {\"foreground\": [(\"active\", \"black\")]},\n        },\n        \"TNotebook.Tab\": {\n            \"map\": {\"background\": [(\"!selected\", detail_bg), (\"selected\", MAIN_BACKGROUND)]}\n        },\n        \"ButtonNotebook.TNotebook.Tab\": {\n            \"map\": {\n                \"background\": [(\"!selected\", detail_bg), (\"selected\", MAIN_BACKGROUND)],\n                \"padding\": [\n                    (\"selected\", [scale(4), scale(2), scale(4), scale(3)]),\n                    (\"!selected\", [scale(4), scale(2), scale(4), scale(3)]),\n                ],\n            }\n        },\n        \"TScrollbar\": {\n            \"configure\": {\n                \"gripcount\": 0,\n                \"borderwidth\": 0,\n                \"padding\": scale(1),\n                \"relief\": \"solid\",\n                \"background\": \"#9e9e9e\",\n                \"darkcolor\": \"#d6d6d6\",\n                \"lightcolor\": \"#d6d6d6\",\n                \"bordercolor\": \"#d6d6d6\",\n                \"troughcolor\": \"#d6d6d6\",\n                \"arrowsize\": scale(1),\n                \"arrowcolor\": \"gray\",\n            },\n            \"map\": {\"background\": [], \"darkcolor\": [], \"lightcolor\": []},\n        },\n        # Padding allows twaking thumb width\n        \"Vertical.TScrollbar\": {\n            \"layout\": [\n                (\n                    \"Vertical.Scrollbar.trough\",\n                    {\n                        \"sticky\": \"ns\",\n                        \"children\": [\n                            (\"Vertical.Scrollbar.uparrow\", {\"side\": \"top\", \"sticky\": \"\"}),\n                            (\"Vertical.Scrollbar.downarrow\", {\"side\": \"bottom\", \"sticky\": \"\"}),\n                            (\n                                \"Vertical.Scrollbar.padding\",\n                                {\n                                    \"sticky\": \"nswe\",\n                                    \"children\": [\n                                        (\n                                            \"Vertical.Scrollbar.thumb\",\n                                            {\"expand\": 1, \"sticky\": \"nswe\"},\n                                        )\n                                    ],\n                                },\n                            ),\n                        ],\n                    },\n                )\n            ]\n        },\n        \"Horizontal.TScrollbar\": {\n            \"layout\": [\n                (\n                    \"Horizontal.Scrollbar.trough\",\n                    {\n                        \"sticky\": \"we\",\n                        \"children\": [\n                            (\"Horizontal.Scrollbar.leftarrow\", {\"side\": \"left\", \"sticky\": \"\"}),\n                            (\"Horizontal.Scrollbar.rightarrow\", {\"side\": \"right\", \"sticky\": \"\"}),\n                            (\n                                \"Horizontal.Scrollbar.padding\",\n                                {\n                                    \"sticky\": \"nswe\",\n                                    \"children\": [\n                                        (\n                                            \"Horizontal.Scrollbar.thumb\",\n                                            {\"expand\": 1, \"sticky\": \"nswe\"},\n                                        )\n                                    ],\n                                },\n                            ),\n                        ],\n                    },\n                )\n            ],\n            \"map\": {\n                # Make disabled Hor Scrollbar invisible\n                \"background\": [(\"disabled\", \"#d6d6d6\")],\n                \"troughcolor\": [(\"disabled\", \"#d6d6d6\")],\n                \"bordercolor\": [(\"disabled\", \"#d6d6d6\")],\n                \"darkcolor\": [(\"disabled\", \"#d6d6d6\")],\n                \"lightcolor\": [(\"disabled\", \"#d6d6d6\")],\n            },\n        },\n        \"TCombobox\": {\"configure\": {\"arrowsize\": scale(10)}},\n        \"Menubar\": {\n            \"configure\": {\n                \"background\": MAIN_BACKGROUND,\n                \"relief\": \"flat\",\n                \"activebackground\": \"#ffffff\",\n                \"activeborderwidth\": 0,\n            }\n        },\n        \"Menu\": {\n            \"configure\": {\n                \"background\": \"#ffffff\",\n                \"relief\": \"flat\",\n                \"borderwidth\": 1,\n                \"activeborderwidth\": 0,\n                # \"activebackground\" : bg, # updated below\n                # \"activeforeground\" : fg,\n            }\n        },\n        \"Tooltip\": {\n            \"configure\": {\n                \"background\": \"#808080\",\n                \"foreground\": \"#ffffff\",\n                \"borderwidth\": 0,\n                \"padx\": 10,\n                \"pady\": 10,\n            }\n        },\n        \"Tip.TLabel\": {\"configure\": {\"background\": detail_bg2, \"foreground\": \"black\"}},\n        \"Tip.TFrame\": {\"configure\": {\"background\": detail_bg2}},\n        \"OPTIONS\": {\"configure\": {\"icons_in_menus\": False, \"shortcuts_in_tooltips\": False}},\n    }\n\n    settings.update(scrollbar_button_settings)\n\n    # try to refine settings according to system configuration\n    \"\"\"Note that fonts are set globally, \n    ie. all themes will later inherit these\"\"\"\n    update_fonts()\n\n    for path in [GLOBAL_CONFIGURATION_PATH, CONFIGURATION_PATH]:\n        if os.path.exists(path):\n            with open(path) as fp:\n                try:\n                    for line in fp:\n                        if \"sGtk/ColorScheme\" in line:\n                            if \"selected_bg_color\" in line:\n                                bgr = re.search(\n                                    r\"selected_bg_color:#([0-9a-fA-F]*)\", line, re.M\n                                ).group(\n                                    1\n                                )  # @UndefinedVariable\n                                color = \"#\" + bgr[0:2] + bgr[4:6] + bgr[8:10]\n                                if is_good_color(color):\n                                    settings[\"Menu\"][\"configure\"][\"activebackground\"] = color\n                            if \"selected_fg_color\" in line:\n                                fgr = re.search(\n                                    r\"selected_fg_color:#([0-9a-fA-F]*)\", line, re.M\n                                ).group(\n                                    1\n                                )  # @UndefinedVariable\n                                color = \"#\" + fgr[0:2] + fgr[4:6] + fgr[8:10]\n                                if is_good_color(color):\n                                    settings[\"Menu\"][\"configure\"][\"activeforeground\"] = color\n                except Exception as e:\n                    logger.error(\"Could not update colors\", exc_info=e)\n\n    return settings", "is_method": false, "function_description": "Configures and returns a dictionary of GUI widget styles and settings. It defines visual properties like colors, borders, and layouts, adapting to system theme configurations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pi/__init__.py", "function": "is_good_color", "line_number": 226, "body": "def is_good_color(s):\n    return bool(re.match(\"^#[0-9a-fA-F]{6}$\", s))", "is_method": false, "function_description": "Validates if an input string is a standard six-digit hexadecimal color code (e.g., #RRGGBB)."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pi/__init__.py", "function": "update_fonts", "line_number": 235, "body": "def update_fonts():\n    from tkinter import font\n\n    options = {}\n    for path in [GLOBAL_CONFIGURATION_PATH, CONFIGURATION_PATH]:\n        if os.path.exists(path):\n            try:\n                with open(path) as fp:\n                    for line in fp:\n                        if \"sGtk/FontName\" in line:\n                            result = re.search(\n                                r\"=([^0-9]*) ([0-9]*)\", line, re.M\n                            )  # @UndefinedVariable\n                            family = result.group(1)\n                            options[\"size\"] = int(result.group(2))\n\n                            if re.search(r\"\\bBold\\b\", family):\n                                options[\"weight\"] = \"bold\"\n                            else:\n                                options[\"weight\"] = \"normal\"\n\n                            if re.search(r\"\\bItalic\\b\", family):\n                                options[\"slant\"] = \"italic\"\n                            else:\n                                options[\"slant\"] = \"roman\"\n\n                            options[\"family\"] = family.replace(\" Bold\", \"\").replace(\" Italic\", \"\")\n            except Exception as e:\n                logger.error(\"Could not update fonts\", exc_info=e)\n\n    if options:\n        for name in [\"TkDefaultFont\", \"TkMenuFont\", \"TkTextFont\", \"TkHeadingFont\"]:\n            font.nametofont(name).configure(**options)", "is_method": false, "function_description": "This function reads font settings from configuration files and applies them to various default Tkinter UI fonts, such as menu, text, and heading fonts, to customize the application's appearance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pi/__init__.py", "function": "load_plugin", "line_number": 270, "body": "def load_plugin():\n\n    # set custom images\n    if get_workbench().get_ui_mode() == \"simple\" and get_workbench().winfo_screenwidth() >= 1280:\n        images = {\n            \"run-current-script\": \"media-playback-start48.png\",\n            \"stop\": \"process-stop48.png\",\n            \"new-file\": \"document-new48.png\",\n            \"open-file\": \"document-open48.png\",\n            \"save-file\": \"document-save48.png\",\n            \"debug-current-script\": \"debug-run48.png\",\n            \"step-over\": \"debug-step-over48.png\",\n            \"step-into\": \"debug-step-into48.png\",\n            \"step-out\": \"debug-step-out48.png\",\n            \"run-to-cursor\": \"debug-run-cursor48.png\",\n            \"tab-close\": \"window-close.png\",\n            \"tab-close-active\": \"window-close-act.png\",\n            \"resume\": \"resume48.png\",\n            \"zoom\": \"zoom48.png\",\n            \"quit\": \"quit48.png\",\n        }\n    else:\n        images = {\n            \"run-current-script\": \"media-playback-start.png\",\n            \"stop\": \"process-stop.png\",\n            \"new-file\": \"document-new.png\",\n            \"open-file\": \"document-open.png\",\n            \"save-file\": \"document-save.png\",\n            \"debug-current-script\": \"debug-run.png\",\n            \"step-over\": \"debug-step-over.png\",\n            \"step-into\": \"debug-step-into.png\",\n            \"step-out\": \"debug-step-out.png\",\n            \"run-to-cursor\": \"debug-run-cursor.png\",\n            \"tab-close\": \"window-close.png\",\n            \"tab-close-active\": \"window-close-act.png\",\n            \"resume\": \"resume.png\",\n            \"zoom\": \"zoom.png\",\n            \"quit\": \"quit.png\",\n        }\n\n    res_dir = os.path.join(os.path.dirname(__file__), \"res\")\n    theme_image_map = {}\n    for image in images:\n        theme_image_map[image] = os.path.join(res_dir, images[image])\n\n    get_workbench().add_ui_theme(\"Raspberry Pi\", \"Enhanced Clam\", pix, theme_image_map)\n    get_workbench().add_ui_theme(\"Raspberry Pi Dark\", \"Clean Dark\", pix_dark, theme_image_map)", "is_method": false, "function_description": "This function loads and configures custom UI themes for the application's workbench. It sets up theme-specific images, adapting them based on the display mode and screen resolution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "load_plugin", "line_number": 156, "body": "def load_plugin():\n    add_micropython_backend(\n        \"microbit\",\n        MicrobitProxy,\n        \"MicroPython (BBC micro:bit)\",\n        MicrobitConfigPage,\n        sort_key=\"31\",\n        validate_time=False,\n        sync_time=False,\n        write_block_size=128,\n    )\n\n    # Don't consider micro:bit in generic backends\n    # The main reason is to reduce the number of items in the backend switcher menu\n    import thonny.plugins.circuitpython\n    import thonny.plugins.micropython\n\n    thonny.plugins.circuitpython.VIDS_PIDS_TO_AVOID.update(MicrobitProxy.get_known_usb_vids_pids())\n    thonny.plugins.micropython.VIDS_PIDS_TO_AVOID_IN_GENERIC_BACKEND.update(\n        MicrobitProxy.get_known_usb_vids_pids()\n    )", "is_method": false, "function_description": "Registers the BBC micro:bit as a specific MicroPython backend within the application, ensuring it's handled by this dedicated interface instead of generic ones."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_start_background_process", "line_number": 23, "body": "def _start_background_process(self, clean=None, extra_args=[]):\n        # NB! Sometimes disconnecting and reconnecting (on macOS?)\n        # too quickly causes anomalies\n        # https://github.com/pyserial/pyserial/issues/176\n        # In my Sierra, Calliope and micro:bit seemed to soft-reboot\n        # when reconnected too quickly.\n\n        if clean and sys.platform == \"darwin\":\n            sleep(1.0)\n\n        super()._start_background_process(clean)", "is_method": true, "class_name": "MicrobitProxy", "function_description": "Starts a background process for the Microbit, leveraging the parent class's implementation. It includes a macOS-specific delay to prevent connection issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "supports_remote_directories", "line_number": 35, "body": "def supports_remote_directories(self):\n        return False", "is_method": true, "class_name": "MicrobitProxy", "function_description": "This method indicates that the MicrobitProxy does not support operations involving remote directories. It informs other components about this specific capability limitation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "should_consider_unknown_devices", "line_number": 39, "body": "def should_consider_unknown_devices(cls):\n        return False", "is_method": true, "class_name": "MicrobitProxy", "function_description": "This class method defines a policy, indicating that the MicrobitProxy should not consider or interact with unknown devices. It consistently returns false to enforce this behavior."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 43, "body": "def get_known_usb_vids_pids(self):\n        return {(0x0D28, 0x0204)}", "is_method": true, "class_name": "MicrobitProxy", "function_description": "This method provides a set of known USB Vendor ID (VID) and Product ID (PID) pairs, used by the MicrobitProxy to identify compatible Microbit devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_usb_driver_url", "line_number": 48, "body": "def _get_usb_driver_url(self):\n        return \"https://microbit-micropython.readthedocs.io/en/latest/devguide/repl.html\"", "is_method": true, "class_name": "MicrobitConfigPage", "function_description": "Provides the URL for documentation on Microbit USB drivers and REPL setup. Useful for users needing installation or configuration guidance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_intro_text", "line_number": 51, "body": "def _get_intro_text(self):\n        return (\n            super()._get_intro_text()\n            + \"\\n\\n\"\n            + tr(\"Make sure MicroPython has been installed to your micro:bit.\")\n            + \"\\n(\"\n            + tr(\"Don't forget that main.py only works without embedded main script.\")\n            + \")\"\n        )", "is_method": true, "class_name": "MicrobitConfigPage", "function_description": "Generates the introductory text for the configuration page, providing essential instructions and reminders for installing MicroPython on a micro:bit."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_has_flashing_dialog", "line_number": 61, "body": "def _has_flashing_dialog(self):\n        return True", "is_method": true, "class_name": "MicrobitConfigPage", "function_description": "This method indicates that the Microbit configuration page should display a flashing dialog, likely related to device updates or connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_open_flashing_dialog", "line_number": 64, "body": "def _open_flashing_dialog(self):\n        dlg = MicrobitFlashingDialog(self)\n        ui_utils.show_dialog(dlg)", "is_method": true, "class_name": "MicrobitConfigPage", "function_description": "This method opens a dialog for flashing firmware or code onto a Microbit device. It provides the user interface to initiate this process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_instructions", "line_number": 70, "body": "def get_instructions(self) -> Optional[str]:\n        return (\n            \"This dialog allows you to install or update MicroPython firmware on your micro:bit.\\n\"\n            \"\\n\"\n            \"1. Plug in your micro:bit.\\n\"\n            \"2. Wait until device information appears.\\n\"\n            \"3. Click 'Install' and wait for some seconds until done.\\n\"\n            \"4. Close the dialog and start programming!\\n\"\n            \"\\n\"\n            \"NB! Installing a new firmware will erase all files you may have on your\\n\"\n            \"device. Make sure you have important files backed up!\"\n        )", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Provides detailed, step-by-step instructions for users on how to install or update MicroPython firmware on a micro:bit, including a data loss warning."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_release_info_url", "line_number": 83, "body": "def _get_release_info_url(self):\n        return \"https://raw.githubusercontent.com/thonny/thonny/master/data/microbit-firmware.json\"", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Provides the URL endpoint to access official Microbit firmware release information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_unknown_version_text", "line_number": 86, "body": "def get_unknown_version_text(self):\n        return \"?\"", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Provides the placeholder text \"?\" used to indicate an unknown Microbit device version within the flashing dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_firmware_description", "line_number": 89, "body": "def get_firmware_description(self):\n        info = self._get_latest_firmware_info_for_current_device()\n        if info is None:\n            return None\n        return \"%s (%s)\" % (info[\"version\"], info[\"date\"])", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Retrieves and formats the version and date of the latest firmware for the connected Microbit device. It provides a concise description for display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_latest_firmware_info_for_current_device", "line_number": 95, "body": "def _get_latest_firmware_info_for_current_device(self):\n        if self._possible_targets is None or len(self._possible_targets) != 1:\n            return None\n        else:\n            board_id = self._possible_targets[0][1]\n            return self._get_latest_firmware_info_for_device(board_id)", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Retrieves the latest firmware information for the currently detected Micro:bit device. It returns None if multiple or no devices are identified."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_latest_firmware_info_for_device", "line_number": 102, "body": "def _get_latest_firmware_info_for_device(self, board_id):\n        if self._release_info is None:\n            return None\n        else:\n            return self._release_info[\"latest_firmwares\"].get(board_id, None)", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Retrieves the latest firmware information for a specified Microbit board ID from pre-loaded release data. Returns None if the information is not found or not loaded."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_download_url_and_size", "line_number": 108, "body": "def get_download_url_and_size(self, board_id):\n        info = self._get_latest_firmware_info_for_device(board_id)\n        if info is None:\n            return None\n\n        return info[\"hex_download\"], info[\"size\"]", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "This method retrieves the download URL and size for the latest firmware specific to a given Microbit board, enabling the flashing process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_target_filename", "line_number": 115, "body": "def get_target_filename(self):\n        return \"firmware.hex\"", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Provides the standard filename \"firmware.hex\" expected for Microbit firmware during flashing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "find_device_board_id_and_model", "line_number": 119, "body": "def find_device_board_id_and_model(cls, mount_path):\n        info_path = os.path.join(mount_path, \"DETAILS.TXT\")\n        if not os.path.isfile(info_path):\n            return None\n\n        # https://tech.microbit.org/latest-revision/editors/\n        models = {\n            \"9900\": \"BBC micro:bit v1.3\",\n            \"9901\": \"BBC micro:bit v1.5\",\n            \"9903\": \"BBC micro:bit v2.0 (9903)\",\n            \"9904\": \"BBC micro:bit v2.0\",\n        }\n\n        with open(info_path, \"r\", encoding=\"UTF-8\", errors=\"replace\") as fp:\n            id_marker = \"Unique ID:\"\n            for line in fp:\n                if line.startswith(id_marker):\n                    board_id = line[len(id_marker) :].strip()[:4]\n                    if board_id in models:\n                        return board_id, models[board_id]\n\n            # With older bootloaders, the file may be different\n            fp.seek(0)\n            for line in fp:\n                if \"Version: 0234\" in line:\n                    board_id = \"9900\"\n                    return board_id, models[board_id]\n\n        return None", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Provides the board ID and model of a connected Micro:bit device by parsing its `DETAILS.TXT` file. Essential for identifying the specific Micro:bit version."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "get_title", "line_number": 149, "body": "def get_title(self):\n        return \"Install MicroPython firmware for BBC micro:bit\"", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Provides the specific title text for the BBC micro:bit firmware installation dialog window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/microbit/__init__.py", "function": "_get_vid_pids_to_wait_for", "line_number": 152, "body": "def _get_vid_pids_to_wait_for(self):\n        return MicrobitProxy.get_known_usb_vids_pids()", "is_method": true, "class_name": "MicrobitFlashingDialog", "function_description": "Retrieves the list of known USB Vendor and Product IDs (VID/PID) for Microbit devices. This identifies which devices the dialog should monitor or interact with."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "load_plugin", "line_number": 389, "body": "def load_plugin():\n    add_micropython_backend(\n        \"ESP32\",\n        ESP32Proxy,\n        \"MicroPython (ESP32)\",\n        ESP32ConfigPage,\n        sort_key=\"35\",\n    )\n    add_micropython_backend(\n        \"ESP8266\", ESP8266Proxy, \"MicroPython (ESP8266)\", ESP8266ConfigPage, sort_key=\"36\"\n    )", "is_method": false, "function_description": "This function registers MicroPython backend plugins for ESP32 and ESP8266 devices. It enables support for these microcontrollers within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_is_potential_port", "line_number": 31, "body": "def _is_potential_port(cls, p):\n        # They have UART adapter\n        return (\n            (p.vid, p.pid) in cls.get_known_usb_vids_pids()\n            or (p.vid, None) in cls.get_known_usb_vids_pids()\n            or p.description in cls.get_known_port_descriptions()\n            or cls.should_consider_unknown_devices()\n            and (p.vid, p.pid) not in cls.get_vids_pids_to_avoid()\n            and (\n                (\"USB\" in p.description and \"serial\" in p.description.lower())\n                or \"UART\" in p.description\n                or \"DAPLink\" in p.description\n                or \"STLink\" in p.description\n            )\n            and getattr(p, \"manufacturer\", \"\") != \"MicroPython\"  # adapter can't have this?\n            and \"python\" not in p.description.lower()\n        )", "is_method": true, "class_name": "ESPProxy", "function_description": "Identifies if a given serial port is a potential ESP device or a compatible programming adapter. It filters ports based on known hardware identifiers and descriptions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_vids_pids_to_avoid", "line_number": 50, "body": "def get_vids_pids_to_avoid(self):\n        # micro:bit\n        return {(0x0D28, 0x0204)}", "is_method": true, "class_name": "ESPProxy", "function_description": "Returns a predefined set of Vendor ID and Product ID pairs (specifically for micro:bit) that the `ESPProxy` system should exclude or ignore."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 60, "body": "def get_known_usb_vids_pids(cls):\n        return cls.get_uart_adapter_vids_pids()", "is_method": true, "class_name": "ESP8266Proxy", "function_description": "Provides a list of known USB Vendor IDs and Product IDs (Vids/Pids) specifically for UART adapters. This helps identify compatible USB-to-serial devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_get_api_stubs_path", "line_number": 63, "body": "def _get_api_stubs_path(self):\n        return os.path.join(os.path.dirname(__file__), \"esp8266_api_stubs\")", "is_method": true, "class_name": "ESP8266Proxy", "function_description": "Provides the absolute file system path to the 'esp8266_api_stubs' directory. This path is used by the proxy to locate necessary API definition files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 69, "body": "def get_known_usb_vids_pids(cls):\n        return cls.get_uart_adapter_vids_pids()", "is_method": true, "class_name": "ESP32Proxy", "function_description": "Provides a list of known USB Vendor IDs (VIDs) and Product IDs (PIDs) primarily for identifying compatible UART adapters used in ESP32 communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_get_api_stubs_path", "line_number": 72, "body": "def _get_api_stubs_path(self):\n        return os.path.join(os.path.dirname(__file__), \"esp32_api_stubs\")", "is_method": true, "class_name": "ESP32Proxy", "function_description": "This method determines the absolute file path to the ESP32 API stubs directory. It provides a consistent way for the proxy to locate these essential files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_open_flashing_dialog", "line_number": 85, "body": "def _open_flashing_dialog(self):\n        dlg = ESPFlashingDialog(self.winfo_toplevel(), self._chip, self._firmware_start_address)\n        ui_utils.show_dialog(dlg)", "is_method": true, "class_name": "ESPConfigPage", "function_description": "Opens a dialog for the user to manage the firmware flashing process for the configured ESP chip. This allows initiating the write operation to the chip."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "allow_webrepl", "line_number": 90, "body": "def allow_webrepl(self):\n        return True", "is_method": true, "class_name": "ESPConfigPage", "function_description": "This method of `ESPConfigPage` unconditionally enables WebREPL remote access. It serves as a configuration flag to allow this service."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_title", "line_number": 121, "body": "def get_title(self):\n        return \"%s firmware installer\" % self._chip.upper()", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "This method generates a dynamic title for the ESP firmware installer dialog, incorporating the specific chip type being flashed. It provides a clear, chip-specific identification for the user interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_instructions", "line_number": 124, "body": "def get_instructions(self) -> Optional[str]:\n        return (\n            \"This dialog allows installing or updating firmware on %s using the most common settings.\\n\"\n            % self._chip.upper()\n            + \"If you need to set other options, then please use 'esptool' on the command line.\\n\\n\"\n            + \"Note that there are many variants of MicroPython for ESP devices. If the firmware provided\\n\"\n            + \"at micropython.org/download doesn't work for your device, then there may exist better\\n\"\n            + \"alternatives -- look around in your device's documentation or at MicroPython forum.\"\n        )", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Provides user instructions for flashing firmware onto an ESP chip using this dialog. It explains default settings and advises on command-line alternatives for advanced configurations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "is_ready_for_work", "line_number": 134, "body": "def is_ready_for_work(self):\n        return self._port_desc_variable.get() and self._firmware_entry.get()", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Verifies if the ESP flashing dialog has a selected port and firmware path, indicating it's ready for flashing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_action_text_max_length", "line_number": 137, "body": "def get_action_text_max_length(self):\n        return 35", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Returns the maximum allowed length for action text displayed or entered in the ESP flashing dialog. It serves as a fixed configuration value for UI elements."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "populate_main_frame", "line_number": 140, "body": "def populate_main_frame(self):\n        epadx = self.get_padding()\n        ipadx = self.get_internal_padding()\n        epady = epadx\n        ipady = ipadx\n\n        # Port\n        port_label = ttk.Label(self.main_frame, text=\"Port\")\n        port_label.grid(row=1, column=1, sticky=\"w\", padx=(epadx, 0), pady=(epady, 0))\n\n        self._port_desc_variable = tk.StringVar(value=\"\")\n        self._port_combo = ttk.Combobox(\n            self.main_frame, exportselection=False, textvariable=self._port_desc_variable, values=[]\n        )\n        self._port_combo.state([\"!disabled\", \"readonly\"])\n        self._port_combo.grid(row=1, column=2, sticky=\"nsew\", padx=ipadx, pady=(epady, 0))\n\n        port_reload_button = ttk.Button(self.main_frame, text=\"Reload\", command=self._reload_ports)\n        port_reload_button.grid(row=1, column=3, sticky=\"ew\", padx=(0, epadx), pady=(epady, 0))\n\n        # Firmware\n        firmware_label = ttk.Label(self.main_frame, text=\"Firmware\")\n        firmware_label.grid(row=2, column=1, sticky=\"w\", padx=(epadx, 0), pady=(ipady, 0))\n\n        self._firmware_entry = ttk.Entry(self.main_frame, width=55)\n        self._firmware_entry.grid(row=2, column=2, sticky=\"nsew\", padx=ipadx, pady=(ipady, 0))\n\n        browse_button = ttk.Button(self.main_frame, text=\"Browse...\", command=self._browse)\n        browse_button.grid(row=2, column=3, sticky=\"we\", padx=(0, epadx), pady=(ipady, 0))\n\n        # FLASH_MODE\n        self._flashmode = tk.StringVar(None, \"keep\")\n        flashmode_group = ttk.Labelframe(self.main_frame, text=\"Flash mode\")\n        flashmode_group.grid(\n            row=4, column=1, columnspan=2, sticky=\"w\", padx=(epadx, 0), pady=(ipady * 2, 0)\n        )\n\n        self._flashmode_keep_radiobutton = ttk.Radiobutton(\n            flashmode_group, text=\"From image file (keep)\", variable=self._flashmode, value=\"keep\"\n        )\n        self._flashmode_keep_radiobutton.grid(row=0, column=0, sticky=\"w\")\n\n        # self._flashmode_variable.value=False\n        self._flashmode_qio_radiobutton = ttk.Radiobutton(\n            flashmode_group, text=\"Quad I/O (qio)\", variable=self._flashmode, value=\"qio\"\n        )\n        self._flashmode_qio_radiobutton.grid(row=0, column=1, sticky=\"w\")\n\n        self._flashmode_dio_radiobutton = ttk.Radiobutton(\n            flashmode_group, text=\"Dual I/O (dio)\", variable=self._flashmode, value=\"dio\"\n        )\n        self._flashmode_dio_radiobutton.grid(row=1, column=0, sticky=\"w\")\n\n        self._flashmode_dout_radiobutton = ttk.Radiobutton(\n            flashmode_group, text=\"Dual Output (dout)\", variable=self._flashmode, value=\"dout\"\n        )\n        self._flashmode_dout_radiobutton.grid(row=1, column=1, sticky=\"w\")\n\n        # Erase\n        self._erase_variable = tk.BooleanVar(value=True)\n        self._erase_checkbutton = ttk.Checkbutton(\n            self.main_frame, text=\"Erase flash before installing\", variable=self._erase_variable\n        )\n        self._erase_checkbutton.grid(\n            row=6, column=1, columnspan=2, sticky=\"w\", padx=(epadx, 0), pady=(ipady, epady)\n        )\n\n        self._reload_ports()", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "It builds the main user interface for the ESP flashing dialog, arranging widgets for port selection, firmware path, flash mode, and erase options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_get_esptool_command", "line_number": 209, "body": "def _get_esptool_command(self):\n        try:\n            import esptool\n\n            return [get_interpreter_for_subprocess(), \"-u\", \"-m\", \"esptool\"]\n        except ImportError:\n            import shutil\n\n            result = shutil.which(\"esptool\")\n            if result:\n                return [result]\n            else:\n                result = shutil.which(\"esptool.py\")\n                if result:\n                    return [result]\n                else:\n                    return None", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Locates and returns the command path for the `esptool` utility. It prioritizes the Python module, falling back to system-wide executables for flashing ESP devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_reload_ports", "line_number": 227, "body": "def _reload_ports(self):\n        pairs = list_serial_ports_with_descriptions()\n        self._ports_by_desc = OrderedDict(pairs)\n        self._port_combo.configure(values=list(self._ports_by_desc.keys()))", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Refreshes the list of available serial ports and updates the port selection dropdown in the dialog. This ensures users can select current connections for ESP flashing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_browse", "line_number": 232, "body": "def _browse(self):\n        initialdir = os.path.normpath(os.path.expanduser(\"~/Downloads\"))\n        if not os.path.isdir(initialdir):\n            initialdir = None\n\n        path = ui_utils.askopenfilename(\n            filetypes=[(\"bin-files\", \".bin\"), (\"all files\", \".*\")],\n            parent=self.winfo_toplevel(),\n            initialdir=initialdir,\n        )\n        if path:\n            self._firmware_entry.delete(0, \"end\")\n            self._firmware_entry.insert(0, path)", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Allows the user to browse and select a firmware file from their local file system using a file dialog. It then displays the chosen file path in the UI's firmware entry field."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_check_connection", "line_number": 246, "body": "def _check_connection(self, port):\n        # wait a bit in case existing connection was just closed\n        time.sleep(1.5)\n\n        # Maybe another program is connected\n        # or the user doesn't have sufficient permissions?\n        try:\n            import serial\n\n            conn = serial.Serial(port)\n            conn.close()\n            return True\n        except Exception as e:\n            messagebox.showerror(\"Can't connect\", str(e), master=self)\n            return False", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Verifies if a specified serial port is accessible and ready for use by attempting to establish and close a connection. This is crucial for setting up ESP device communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "start_work", "line_number": 262, "body": "def start_work(self):\n        port = self._ports_by_desc[self._port_desc_variable.get()]\n        if not self._port_desc_variable.get():\n            messagebox.showerror(\"Select port\", \"Please select port\", parent=self)\n            return False\n\n        firmware_path = self._firmware_entry.get()\n        if not os.path.exists(firmware_path):\n            messagebox.showerror(\n                \"Bad firmware path\", \"Can't find firmware, please check path\", master=self\n            )\n            return False\n\n        flash_mode = self._flashmode.get()\n        erase_flash = self._erase_variable.get()\n\n        proxy = get_runner().get_backend_proxy()\n        port_was_used_in_thonny = (\n            isinstance(proxy, BareMetalMicroPythonProxy) and proxy._port == port\n        )\n        if port_was_used_in_thonny:\n            proxy.disconnect()\n\n        commands = []\n        threading.Thread(\n            target=self.work_in_thread,\n            daemon=True,\n            args=[port, firmware_path, flash_mode, erase_flash, port_was_used_in_thonny],\n        ).start()", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Initiates the ESP device firmware flashing process. It validates user selections, manages port conflicts, and dispatches the flashing operation to a background thread."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "work_in_thread", "line_number": 292, "body": "def work_in_thread(self, port, firmware_path, flash_mode, erase_flash, port_was_used_in_thonny):\n        if port_was_used_in_thonny:\n            time.sleep(1.5)\n\n        erase_command = self._esptool_command + [\n            \"--chip\",\n            self._chip,\n            \"--port\",\n            port,\n            \"erase_flash\",\n        ]\n\n        write_command = self._esptool_command + [\n            \"--chip\",\n            self._chip,\n            \"--port\",\n            port,\n            \"write_flash\",\n            \"--flash_mode\",\n            flash_mode,\n            \"--flash_size\",  # default changed in esptool 3.0\n            \"detect\",\n            self._start_address,\n            firmware_path,\n        ]\n\n        if not self._check_connection(port):\n            self.set_action_text(\"Problem\")\n            self.append_text(\"Could not connect to port\\n\")\n            self.report_done(False)\n            return\n\n        if erase_flash:\n            self.set_action_text(\"Erasing flash\")\n            self.append_text(subprocess.list2cmdline(erase_command) + \"\\n\")\n            self._proc = self._create_subprocess(erase_command)\n            while True:\n                line = self._proc.stdout.readline()\n                if not line:\n                    break\n                self.append_text(line)\n                self.set_action_text_smart(line)\n            returncode = self._proc.wait()\n            if returncode:\n                self.set_action_text(\"Error\")\n                self.append_text(\"\\nErase command returned with error code %s\" % returncode)\n                self.report_done(False)\n                return\n            else:\n                self.append_text(\"Erasing done\\n------------------------------------\\n\\n\")\n\n        self.set_action_text(\"Writing firmware\")\n        self.append_text(subprocess.list2cmdline(write_command) + \"\\n\")\n        self._proc = self._create_subprocess(write_command)\n        while True:\n            line = self._proc.stdout.readline()\n            if not line:\n                break\n            self.append_text(line)\n            self.set_action_text_smart(line)\n        returncode = self._proc.wait()\n        if returncode:\n            self.set_action_text(\"Error\")\n            self.append_text(\"\\nWrite command returned with error code %s\" % returncode)\n        else:\n            self.set_action_text(\"Done!\")\n            self.append_text(\"Done!\")\n        self.report_done(returncode == 0)", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Performs the ESP device firmware flashing process in a background thread. It optionally erases the flash and then writes the specified firmware, reporting progress and status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "_create_subprocess", "line_number": 361, "body": "def _create_subprocess(self, cmd) -> subprocess.Popen:\n        return subprocess.Popen(\n            cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True\n        )", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Creates and initiates a new background process to execute a command. It configures the process to capture all its output streams."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "get_ok_text", "line_number": 366, "body": "def get_ok_text(self):\n        return tr(\"Install\")", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "Provides the localized text for the \"Install\" or primary action button within the ESP Flashing dialog. This service customizes the button's display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/__init__.py", "function": "cancel_work", "line_number": 369, "body": "def cancel_work(self):\n        super().cancel_work()\n        # try gently first\n        try:\n            try:\n                if running_on_windows():\n                    os.kill(self._proc.pid, signal.CTRL_BREAK_EVENT)  # pylint: disable=no-member\n                else:\n                    os.kill(self._proc.pid, signal.SIGINT)\n\n                self._proc.wait(2)\n            except subprocess.TimeoutExpired:\n                if self._proc.poll() is None:\n                    # now let's be more concrete\n                    self._proc.kill()\n        except OSError as e:\n            messagebox.showerror(\"Error\", \"Could not kill subprocess: \" + str(e), master=self)\n            logger.error(\"Could not kill subprocess\", exc_info=e)", "is_method": true, "class_name": "ESPFlashingDialog", "function_description": "This method terminates the active subprocess associated with the ESP flashing operation. It attempts a graceful shutdown first, then forcefully kills the process if it does not respond."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/esp32_api_stubs/builtins.py", "function": "globals", "line_number": 355, "body": "def globals():\n    pass", "is_method": false, "function_description": "Provides a dictionary representing the current global symbol table. It enables dynamic inspection and manipulation of global variables and functions within the current module."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/esp32_api_stubs/builtins.py", "function": "clear", "line_number": 529, "body": "def clear():\n        pass", "is_method": true, "class_name": "set", "function_description": "Provides the capability to clear all elements from the set, effectively making it empty for reuse."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/esp8266_api_stubs/builtins.py", "function": "globals", "line_number": 332, "body": "def globals():\n    pass", "is_method": false, "function_description": "Provides a dictionary representing the current module's global symbol table. This allows access and manipulation of all names defined at the global scope."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/esp8266_api_stubs/builtins.py", "function": "clear", "line_number": 238, "body": "def clear():\n        pass", "is_method": true, "class_name": "dict", "function_description": "Removes all key-value pairs from the dictionary, making it empty. This service is useful for resetting a dictionary's content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/esp/esp8266_api_stubs/builtins.py", "function": "values", "line_number": 268, "body": "def values():\n        pass", "is_method": true, "class_name": "dict", "function_description": "Provides a dynamic view of all values in the dictionary. This is useful for iterating over or processing only the dictionary's contents."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "open_help", "line_number": 75, "body": "def open_help():\n    get_workbench().show_view(\"HelpView\")", "is_method": false, "function_description": "Opens the application's help view, providing users with access to documentation and assistance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "load_plugin", "line_number": 79, "body": "def load_plugin() -> None:\n    get_workbench().add_view(HelpView, tr(\"Help\"), \"ne\")\n    get_workbench().add_command(\"help_contents\", \"help\", tr(\"Help contents\"), open_help, group=30)", "is_method": false, "function_description": "Loads and registers core help functionalities within the application's workbench, including adding a help view and a command to access help contents."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "on_workbench_ready", "line_number": 40, "body": "def on_workbench_ready(self, event=None):\n        self.load_index()", "is_method": true, "class_name": "HelpView", "function_description": "Responds to the workbench readiness event by loading the help system's index. It ensures help content is available when the UI initializes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "on_show", "line_number": 43, "body": "def on_show(self):\n        self.load_index()", "is_method": true, "class_name": "HelpView", "function_description": "This method prepares the HelpView for display by loading its required index. It ensures the help content is ready for the user when the view becomes visible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "load_index", "line_number": 46, "body": "def load_index(self):\n        self.load_rst_file(\"index.rst\")", "is_method": true, "class_name": "HelpView", "function_description": "Loads the main \"index.rst\" file to display the default help content for the view."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "load_topic", "line_number": 49, "body": "def load_topic(self, topic, fragment=None):\n        self.load_rst_file(topic + \".rst\")", "is_method": true, "class_name": "HelpView", "function_description": "Loads and displays the reStructuredText help file for a specified topic, providing its content for user viewing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/help/__init__.py", "function": "load_rst_file", "line_number": 53, "body": "def load_rst_file(self, filename):\n        self.text.clear()\n        self.text.direct_insert(\"1.0\", \"\\n\")\n\n        if os.path.isabs(filename):\n            full_path = filename\n        else:\n            # try to access filename in a language subdirectory\n            full_path = os.path.join(self.language_dir, filename)\n            if not os.path.exists(full_path):\n                # if the localized file does not exist, default to English\n                full_path = os.path.join(os.path.dirname(__file__), filename)\n\n        with open(full_path, encoding=\"UTF-8\") as fp:\n            rst_source = fp.read()\n\n        if not filename.endswith(\"index.rst\"):\n            rst_source = \"`\" + tr(\"Home\") + \" <index.rst>`_\\n\\n\" + rst_source\n\n        self.text.append_rst(rst_source)", "is_method": true, "class_name": "HelpView", "function_description": "This method loads and displays reStructuredText (RST) help files into the `HelpView`. It resolves file paths, supporting localization, and prepares the content for presentation within the help viewer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "prepare_hooks", "line_number": 1221, "body": "def prepare_hooks(method):\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        try:\n            sys.meta_path.insert(0, self)\n            self._backend._install_custom_import()\n            return method(self, *args, **kwargs)\n        finally:\n            del sys.meta_path[0]\n            if hasattr(self._backend, \"_original_import\"):\n                self._backend._restore_original_import()\n\n    return wrapper", "is_method": false, "function_description": "This decorator temporarily installs custom import hooks and mechanisms, allowing the wrapped method to operate within a controlled import environment. It ensures the original import system is restored upon completion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "return_execution_result", "line_number": 1236, "body": "def return_execution_result(method):\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = method(self, *args, **kwargs)\n            if result is not None:\n                return result\n            return {\"context_info\": \"after normal execution\"}\n        except Exception:\n            return {\"user_exception\": self._backend._prepare_user_exception()}\n\n    return wrapper", "is_method": false, "function_description": "This decorator wraps a method's execution to standardize its return value, providing the method's result, a default success context, or structured exception information upon failure. It ensures consistent handling of outcomes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_frame_prefix", "line_number": 2716, "body": "def _get_frame_prefix(frame):\n    return str(id(frame)) + \" \" + \">\" * len(inspect.getouterframes(frame, 0)) + \" \"", "is_method": false, "function_description": "Generates a unique string prefix for an execution frame. This prefix incorporates the frame's ID and a visual indicator of its depth in the call stack, useful for debugging or logging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_fetch_frame_source_info", "line_number": 2720, "body": "def _fetch_frame_source_info(frame):\n    if frame.f_code.co_filename is None or not os.path.exists(frame.f_code.co_filename):\n        return None, None, True\n\n    is_libra = _is_library_file(frame.f_code.co_filename)\n\n    if frame.f_code.co_name == \"<lambda>\":\n        source = inspect.getsource(frame.f_code)\n        return source, frame.f_code.co_firstlineno, is_libra\n    elif frame.f_code.co_name == \"<module>\":\n        # inspect.getsource and getsourcelines don't help here\n        with tokenize.open(frame.f_code.co_filename) as fp:\n            return fp.read(), 1, is_libra\n    else:\n        # function or class\n        try:\n            source = inspect.getsource(frame.f_code)\n\n            # inspect.getsource is not reliable, see eg:\n            # https://bugs.python.org/issue35101\n            # If the code name is not present as definition\n            # in the beginning of the source,\n            # then play safe and return the whole script\n            first_line = source.splitlines()[0]\n            if re.search(r\"\\b(class|def)\\b\\s+\\b%s\\b\" % frame.f_code.co_name, first_line) is None:\n                with tokenize.open(frame.f_code.co_filename) as fp:\n                    return fp.read(), 1, is_libra\n\n            else:\n                return source, frame.f_code.co_firstlineno, is_libra\n        except OSError:\n            logger.exception(\"Problem getting source\")\n            return None, None, True", "is_method": false, "function_description": "Retrieves the source code, starting line number, and library status for a given Python frame. It handles various code types like lambdas, modules, and functions, ensuring robust source retrieval for debugging or introspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "format_exception_with_frame_info", "line_number": 2755, "body": "def format_exception_with_frame_info(e_type, e_value, e_traceback, shorten_filenames=False):\n    \"\"\"Need to suppress thonny frames to avoid confusion\"\"\"\n\n    _traceback_message = \"Traceback (most recent call last):\\n\"\n\n    _cause_message = getattr(\n        traceback,\n        \"_cause_message\",\n        (\"\\nThe above exception was the direct cause \" + \"of the following exception:\") + \"\\n\\n\",\n    )\n\n    _context_message = getattr(\n        traceback,\n        \"_context_message\",\n        (\"\\nDuring handling of the above exception, \" + \"another exception occurred:\") + \"\\n\\n\",\n    )\n\n    def rec_format_exception_with_frame_info(etype, value, tb, chain=True):\n        # Based on\n        # https://www.python.org/dev/peps/pep-3134/#enhanced-reporting\n        # and traceback.format_exception\n\n        if etype is None:\n            etype = type(value)\n\n        if tb is None:\n            tb = value.__traceback__\n\n        if chain:\n            if value.__cause__ is not None:\n                yield from rec_format_exception_with_frame_info(None, value.__cause__, None)\n                yield (_cause_message, None, None, None)\n            elif value.__context__ is not None and not value.__suppress_context__:\n                yield from rec_format_exception_with_frame_info(None, value.__context__, None)\n                yield (_context_message, None, None, None)\n\n        if tb is not None:\n            yield (_traceback_message, None, None, None)\n\n            tb_temp = tb\n            for entry in traceback.extract_tb(tb):\n                assert tb_temp is not None  # actual tb doesn't end before extract_tb\n                if (\n                    \"cpython_backend\" not in entry.filename\n                    and \"thonny/backend\" not in entry.filename.replace(\"\\\\\", \"/\")\n                    and (\n                        not entry.filename.endswith(os.sep + \"ast.py\")\n                        or entry.name != \"parse\"\n                        or etype is not SyntaxError\n                    )\n                ):\n                    fmt = '  File \"{}\", line {}, in {}\\n'.format(\n                        entry.filename, entry.lineno, entry.name\n                    )\n\n                    if entry.line:\n                        fmt += \"    {}\\n\".format(entry.line.strip())\n\n                    yield (fmt, id(tb_temp.tb_frame), entry.filename, entry.lineno)\n\n                tb_temp = tb_temp.tb_next\n\n            assert tb_temp is None  # tb was exhausted\n\n        for line in traceback.format_exception_only(etype, value):\n            if etype is SyntaxError and line.endswith(\"^\\n\"):\n                # for some reason it may add several empty lines before ^-line\n                partlines = line.splitlines()\n                while len(partlines) >= 2 and partlines[-2].strip() == \"\":\n                    del partlines[-2]\n                line = \"\\n\".join(partlines) + \"\\n\"\n\n            yield (line, None, None, None)\n\n    items = rec_format_exception_with_frame_info(e_type, e_value, e_traceback)\n\n    return list(items)", "is_method": false, "function_description": "Given exception details, this function formats a traceback by suppressing specific internal frames. It provides a cleaner, more focused error message for users."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "in_debug_mode", "line_number": 2834, "body": "def in_debug_mode():\n    return os.environ.get(\"THONNY_DEBUG\", False) in [1, \"1\", True, \"True\", \"true\"]", "is_method": false, "function_description": "This function checks if the application is running in debug mode by inspecting the \"THONNY_DEBUG\" environment variable. It allows other parts of the code to conditionally enable debug-specific behaviors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_library_file", "line_number": 2838, "body": "def _is_library_file(filename):\n    return (\n        filename is None\n        or path_startswith(filename, sys.prefix)\n        or hasattr(sys, \"base_prefix\")\n        and path_startswith(filename, sys.base_prefix)\n        or hasattr(sys, \"real_prefix\")\n        and path_startswith(filename, getattr(sys, \"real_prefix\"))\n        or site.ENABLE_USER_SITE\n        and path_startswith(filename, site.getusersitepackages())\n    )", "is_method": false, "function_description": "Checks if a given file path belongs to the Python standard library, a virtual environment, or user-installed packages. It helps identify files that are part of the core Python ecosystem."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "get_backend", "line_number": 2851, "body": "def get_backend():\n    return _backend", "is_method": false, "function_description": "Retrieves the currently configured backend object, providing access to its services or functionalities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_install_signal_handler", "line_number": 159, "body": "def _install_signal_handler(self):\n        import signal\n\n        def signal_handler(signal_, frame):\n            raise KeyboardInterrupt(\"Execution interrupted\")\n\n        if os.name == \"nt\":\n            signal.signal(signal.SIGBREAK, signal_handler)  # pylint: disable=no-member\n        else:\n            signal.signal(signal.SIGINT, signal_handler)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Installs an OS-specific signal handler to convert system termination signals (like Ctrl+C) into a Python `KeyboardInterrupt`. This enables graceful program interruption and shutdown."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_fetch_next_incoming_message", "line_number": 170, "body": "def _fetch_next_incoming_message(self, timeout=None) -> CommandToBackend:\n        # Reading must be done synchronously\n        # https://github.com/thonny/thonny/issues/1363\n        self._read_one_incoming_message()\n        return self._incoming_message_queue.get()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Retrieves the next incoming command for the backend, first ensuring the message has been synchronously read and queued. This enables the backend to process subsequent commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_command", "line_number": 176, "body": "def add_command(self, command_name, handler):\n        \"\"\"Handler should be 1-argument function taking command object.\n\n        Handler may return None (in this case no response is sent to frontend)\n        or a BackendResponse\n        \"\"\"\n        self._command_handlers[command_name] = handler", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Registers a handler function for a given command name, enabling the backend to execute specific logic when that command is received."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_object_info_tweaker", "line_number": 184, "body": "def add_object_info_tweaker(self, tweaker):\n        \"\"\"Tweaker should be 2-argument function taking value and export record\"\"\"\n        self._object_info_tweakers.append(tweaker)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Registers a custom function (tweaker) to modify or enhance object information. This extends the backend's capability to process data before export."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_import_handler", "line_number": 188, "body": "def add_import_handler(self, module_name, handler):\n        if module_name not in self._import_handlers:\n            self._import_handlers[module_name] = []\n        self._import_handlers[module_name].append(handler)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides a mechanism to register a handler that executes when a specific module is imported. This enables custom actions or extensions during the module loading process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_source_preprocessor", "line_number": 193, "body": "def add_source_preprocessor(self, func):\n        self._source_preprocessors.append(func)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method registers a function to be applied as a source preprocessor. It allows dynamically extending the backend's source code processing pipeline."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_ast_postprocessor", "line_number": 196, "body": "def add_ast_postprocessor(self, func):\n        self._ast_postprocessors.append(func)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Registers a function as an AST postprocessor within the backend. This enables custom operations or modifications on the Abstract Syntax Tree after its initial parsing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "get_main_module", "line_number": 199, "body": "def get_main_module(self):\n        return __main__", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides access to the `__main__` module object. This allows other parts of the program to interact with the top-level execution scope and its defined attributes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_read_incoming_msg_line", "line_number": 202, "body": "def _read_incoming_msg_line(self) -> str:\n        return self._original_stdin.readline()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Reads a single line from the standard input stream. This provides the core mechanism for receiving incoming messages or commands for the backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_user_input", "line_number": 205, "body": "def _handle_user_input(self, msg: InputSubmission) -> None:\n        self._input_queue.put(msg)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Queues user input messages for processing within the backend. This allows for asynchronous handling of user submissions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_eof_command", "line_number": 208, "body": "def _handle_eof_command(self, msg: EOFCommand) -> None:\n        self.send_message(ToplevelResponse(SystemExit=True))\n        sys.exit()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Handles an end-of-file command by instructing the system to terminate. This method ensures the Python process exits in response to a shutdown signal."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_normal_command", "line_number": 212, "body": "def _handle_normal_command(self, cmd: CommandToBackend) -> None:\n        assert isinstance(cmd, (ToplevelCommand, InlineCommand))\n\n        if isinstance(cmd, ToplevelCommand):\n            self._source_info_by_frame = {}\n            self._input_queue = queue.Queue()\n\n        if cmd.name in self._command_handlers:\n            handler = self._command_handlers[cmd.name]\n        else:\n            handler = getattr(self, \"_cmd_\" + cmd.name, None)\n\n        if handler is None:\n            response = {\"error\": \"Unknown command: \" + cmd.name}\n        else:\n            try:\n                response = handler(cmd)\n            except SystemExit as e:\n                # Must be caused by Thonny or plugins code\n                if isinstance(cmd, ToplevelCommand):\n                    logger.exception(\"Unexpected SystemExit\", exc_info=e)\n                response = {\"SystemExit\": True}\n            except UserError as e:\n                sys.stderr.write(str(e) + \"\\n\")\n                response = {}\n            except KeyboardInterrupt:\n                response = {\"user_exception\": self._prepare_user_exception()}\n            except Exception as e:\n                self._report_internal_exception(e)\n                response = {\"context_info\": \"other unhandled exception\"}\n\n        if response is False:\n            # Command doesn't want to send any response\n            return\n\n        real_response = self._prepare_command_response(response, cmd)\n\n        if isinstance(real_response, ToplevelResponse):\n            real_response[\"gui_is_active\"] = (\n                self._get_tcl() is not None or self._get_qt_app() is not None\n            )\n\n        self.send_message(real_response)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Dispatches and executes commands received by the backend, routing them to specific handlers. It robustly handles execution errors and sends structured responses."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_immediate_command", "line_number": 256, "body": "def _handle_immediate_command(self, cmd: ImmediateCommand) -> None:\n        if cmd.name == \"interrupt\":\n            with self._interrupt_lock:\n                interrupt_local_process()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This private method processes immediate commands for the CPython backend. It specifically handles the 'interrupt' command by safely stopping the local process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "get_option", "line_number": 264, "body": "def get_option(self, name, default=None):\n        section, subname = self._parse_option_name(name)\n        val = self._get_ini().get(section, subname, fallback=default)\n        try:\n            return ast.literal_eval(val)\n        except Exception:\n            return val", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Retrieves a configuration option by name from an internal INI source, using a default if not found. It attempts to convert the value to a Python literal, otherwise returning it as a string."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "set_option", "line_number": 272, "body": "def set_option(self, name, value):\n        ini = self._get_ini()\n        section, subname = self._parse_option_name(name)\n        if not ini.has_section(section):\n            ini.add_section(section)\n        if not isinstance(value, str):\n            value = repr(value)\n        ini.set(section, subname, value)\n        self.save_settings()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method sets a specific configuration option for the CPython backend. It ensures the value is properly formatted and saved, allowing programmatic modification of application settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_parse_option_name", "line_number": 282, "body": "def _parse_option_name(self, name):\n        if \".\" in name:\n            return name.split(\".\", 1)\n        else:\n            return \"general\", name", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Parses an option name, separating it into a category/scope and the option itself. It defaults to the 'general' category if no explicit scope is provided."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_ini", "line_number": 288, "body": "def _get_ini(self):\n        if self._ini is None:\n            import configparser\n\n            self._ini = configparser.ConfigParser(interpolation=None)\n            self._ini.read(_CONFIG_FILENAME)\n\n        return self._ini", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides a lazily initialized `ConfigParser` object containing settings from a configuration file. It ensures the configuration file is read only once."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "save_settings", "line_number": 297, "body": "def save_settings(self):\n        if self._ini is None:\n            return\n\n        with open(_CONFIG_FILENAME, \"w\") as fp:\n            self._ini.write(fp)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Saves the current application settings, stored in the internal configuration object, to a file. This ensures settings persist for future use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "switch_env_to_script_mode", "line_number": 304, "body": "def switch_env_to_script_mode(self, cmd):\n        if \"\" in sys.path:\n            sys.path.remove(\"\")  # current directory\n\n        filename = cmd.args[0]\n        if os.path.isfile(filename):\n            sys.path.insert(0, os.path.abspath(os.path.dirname(filename)))\n            __main__.__dict__[\"__file__\"] = filename", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Prepares the Python environment for executing a script. It adjusts `sys.path` to include the script's directory and sets `__main__.__file__` to the script's path, mimicking standard script execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_custom_import", "line_number": 313, "body": "def _custom_import(self, *args, **kw):\n        module = self._original_import(*args, **kw)\n\n        if not hasattr(module, \"__name__\"):\n            return module\n\n        # module specific handlers\n        for handler in self._import_handlers.get(module.__name__, []):\n            try:\n                handler(module)\n            except Exception as e:\n                self._report_internal_exception(e)\n\n        # general handlers\n        for handler in self._import_handlers.get(\"*\", []):\n            try:\n                handler(module)\n            except Exception as e:\n                self._report_internal_exception(e)\n\n        return module", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method overrides the standard Python import to execute registered handlers immediately after a module is loaded. It enables custom post-import processing for specific or all modules within the backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_load_plugins", "line_number": 335, "body": "def _load_plugins(self):\n        # built-in plugins\n        try:\n            import thonny.plugins.backend  # pylint: disable=redefined-outer-name\n        except ImportError:\n            # May happen eg. in ssh session\n            return\n\n        try_load_modules_with_frontend_sys_path(\"thonnycontrib\")\n        self._load_plugins_from_path(thonny.plugins.backend.__path__, \"thonny.plugins.backend.\")\n\n        # 3rd party plugins from namespace package\n        try:\n            import thonnycontrib.backend  # @UnresolvedImport\n        except ImportError:\n            # No 3rd party plugins installed\n            pass\n        else:\n            self._load_plugins_from_path(thonnycontrib.backend.__path__, \"thonnycontrib.backend.\")", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method loads both built-in and third-party plugins for the Thonny backend. It ensures the backend is initialized with all necessary plugin functionalities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_load_plugins_from_path", "line_number": 355, "body": "def _load_plugins_from_path(self, path, prefix):\n        load_function_name = \"load_plugin\"\n        for _, module_name, _ in sorted(pkgutil.iter_modules(path, prefix), key=lambda x: x[1]):\n            try:\n                m = importlib.import_module(module_name)\n                if hasattr(m, load_function_name):\n                    f = getattr(m, load_function_name)\n                    sig = inspect.signature(f)\n                    if len(sig.parameters) == 0:\n                        f()\n                    else:\n                        f(self)\n            except Exception as e:\n                logger.exception(\"Failed loading plugin '\" + module_name + \"'\", exc_info=e)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Dynamically discovers and loads Python modules as plugins from a specified path. It executes each plugin's 'load_plugin' function, enabling extensible backend functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_environment_info", "line_number": 370, "body": "def _cmd_get_environment_info(self, cmd):\n        return ToplevelResponse(\n            main_dir=self._main_dir,\n            sys_path=sys.path,\n            usersitepackages=site.getusersitepackages() if site.ENABLE_USER_SITE else None,\n            prefix=sys.prefix,\n            welcome_text=\"Python \" + get_python_version_string(),\n            executable=sys.executable,\n            exe_dirs=get_exe_dirs(),\n            in_venv=(\n                hasattr(sys, \"base_prefix\")\n                and sys.base_prefix != sys.prefix\n                or hasattr(sys, \"real_prefix\")\n                and getattr(sys, \"real_prefix\") != sys.prefix\n            ),\n            python_version=get_python_version_string(),\n            cwd=os.getcwd(),\n        )", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides a comprehensive snapshot of the current Python execution environment. It gathers details like paths, directories, Python version, and virtual environment status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_cd", "line_number": 389, "body": "def _cmd_cd(self, cmd):\n        if len(cmd.args) == 1:\n            path = cmd.args[0]\n            try:\n                os.chdir(path)\n                return ToplevelResponse()\n            except FileNotFoundError:\n                raise UserError(\"No such folder: \" + path)\n            except OSError as e:\n                raise UserError(\"\\n\".join(traceback.format_exception_only(type(e), e)))\n        else:\n            raise UserError(\"cd takes one parameter\")", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method implements the 'cd' command for the backend. It changes the current working directory, handling user input errors and file system issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_Run", "line_number": 402, "body": "def _cmd_Run(self, cmd):\n        self.switch_env_to_script_mode(cmd)\n        return self._execute_file(cmd, SimpleRunner)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Executes a Python command or script after configuring the environment for script mode."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_run", "line_number": 406, "body": "def _cmd_run(self, cmd):\n        return self._execute_file(cmd, SimpleRunner)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This internal method of MainCPythonBackend executes a specified command or file. It provides a straightforward way to run operations using a simple, default runner."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_FastDebug", "line_number": 409, "body": "def _cmd_FastDebug(self, cmd):\n        self.switch_env_to_script_mode(cmd)\n        return self._execute_file(cmd, FastTracer)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Prepares the environment and executes a specified command or file in a fast debugging mode. It utilizes a FastTracer for efficient tracing during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_Debug", "line_number": 413, "body": "def _cmd_Debug(self, cmd):\n        self.switch_env_to_script_mode(cmd)\n        return self._execute_file(cmd, NiceTracer)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Executes a specified command or file within a debug environment. It configures the environment for script mode and runs the file with a debugger."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_debug", "line_number": 417, "body": "def _cmd_debug(self, cmd):\n        return self._execute_file(cmd, NiceTracer)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Executes a specified command or file within a debugging environment, enabling detailed tracing of its execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_execute_source", "line_number": 420, "body": "def _cmd_execute_source(self, cmd):\n        \"\"\"Executes Python source entered into shell\"\"\"\n        self._check_update_tty_mode(cmd)\n        filename = \"<pyshell>\"\n        source = cmd.source.strip()\n\n        try:\n            root = ast.parse(source, filename=filename, mode=\"exec\")\n        except SyntaxError as e:\n            error = \"\".join(traceback.format_exception_only(type(e), e))\n            sys.stderr.write(error)\n            return ToplevelResponse()\n\n        assert isinstance(root, ast.Module)\n\n        result_attributes = self._execute_source(\n            source,\n            filename,\n            \"repl\",\n            NiceTracer if getattr(cmd, \"debug_mode\", False) else SimpleRunner,\n            cmd,\n        )\n\n        return ToplevelResponse(command_name=\"execute_source\", **result_attributes)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Parses and executes user-provided Python source code from an interactive shell, handling syntax errors and returning a response."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_execute_system_command", "line_number": 445, "body": "def _cmd_execute_system_command(self, cmd):\n        self._check_update_tty_mode(cmd)\n        try:\n            returncode = execute_system_command(cmd, disconnect_stdin=True)\n            return {\"returncode\": returncode}\n        except Exception as e:\n            logger.exception(\"Could not execute system command %s\", cmd, exc_info=e)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Executes a specified system command, returning its process exit code. This internal backend method also handles execution errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_process_gui_events", "line_number": 453, "body": "def _cmd_process_gui_events(self, cmd):\n        # advance the event loop\n        try:\n            # First try Tkinter.\n            # Need to update even when tkinter._default_root is None\n            # because otherwise destroyed window will stay up in macOS.\n\n            # When switching between closed user Tk window and another window,\n            # the closed window may reappear in IDLE and CLI REPL\n            tcl = self._get_tcl()\n            if tcl is not None and tcl.has_default_root or tcl.updates_without_root < 1:\n                # http://bugs.python.org/issue989712\n                # http://bugs.python.org/file6090/run.py.diff\n                # https://bugs.python.org/review/989712/diff/4528/Lib/idlelib/run.py\n                tcl.eval(\"update\")\n                # if not tcl.has_default_root:\n                #    tcl.updates_without_root += 1\n            else:\n                # Try Qt only when Tkinter is not used\n                app = self._get_qt_app()\n                if app is not None:\n                    app.processEvents()\n\n        except Exception:\n            pass\n\n        return False", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides a service to process pending graphical user interface events for Tkinter or Qt. It ensures the application's GUI remains responsive by updating its display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_globals", "line_number": 481, "body": "def _cmd_get_globals(self, cmd):\n        # warnings.warn(\"_cmd_get_globals is deprecated for CPython\")\n        try:\n            return InlineResponse(\n                \"get_globals\",\n                module_name=cmd.module_name,\n                globals=self.export_globals(cmd.module_name),\n            )\n        except Exception as e:\n            return InlineResponse(\"get_globals\", module_name=cmd.module_name, error=str(e))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Processes a command to retrieve the global variables of a specified Python module, offering a service for module introspection within the CPython backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_frame_info", "line_number": 492, "body": "def _cmd_get_frame_info(self, cmd):\n        atts = {}\n        try:\n            # TODO: make it work also in past states\n            frame, location = self._lookup_frame_by_id(cmd[\"frame_id\"])\n            if frame is None:\n                atts[\"error\"] = \"Frame not found\"\n            else:\n                atts[\"code_name\"] = frame.f_code.co_name\n                atts[\"module_name\"] = frame.f_globals[\"__name__\"]\n                atts[\"locals\"] = (\n                    None\n                    if frame.f_locals is frame.f_globals\n                    else self.export_variables(frame.f_locals)\n                )\n                atts[\"globals\"] = self.export_variables(frame.f_globals)\n                atts[\"freevars\"] = frame.f_code.co_freevars\n                atts[\"location\"] = location\n        except Exception as e:\n            atts[\"error\"] = str(e)\n\n        return InlineResponse(\"get_frame_info\", frame_id=cmd.frame_id, **atts)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method retrieves detailed information about a specific Python execution frame, including its name, module, local/global variables, and location. It provides crucial context for debugger or introspection tools."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_active_distributions", "line_number": 515, "body": "def _cmd_get_active_distributions(self, cmd):\n        try:\n            # if it is called after first installation to user site packages\n            # this dir is not yet in sys.path\n            if (\n                site.ENABLE_USER_SITE\n                and site.getusersitepackages()\n                and os.path.exists(site.getusersitepackages())\n                and site.getusersitepackages() not in sys.path\n            ):\n                # insert before first site packages item\n                for i, item in enumerate(sys.path):\n                    if \"site-packages\" in item or \"dist-packages\" in item:\n                        sys.path.insert(i, site.getusersitepackages())\n                        break\n                else:\n                    sys.path.append(site.getusersitepackages())\n\n            import pkg_resources\n\n            pkg_resources._initialize_master_working_set()\n            dists = {\n                dist.key: {\n                    \"project_name\": dist.project_name,\n                    \"key\": dist.key,\n                    \"location\": dist.location,\n                    \"version\": dist.version,\n                }\n                for dist in pkg_resources.working_set  # pylint: disable=not-an-iterable\n            }\n\n            return InlineResponse(\n                \"get_active_distributions\",\n                distributions=dists,\n                usersitepackages=site.getusersitepackages() if site.ENABLE_USER_SITE else None,\n            )\n        except Exception:\n            return InlineResponse(\"get_active_distributions\", error=traceback.format_exc())", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This function retrieves details of all active Python package distributions currently loaded. It ensures user-installed packages are discoverable for a comprehensive list."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_locals", "line_number": 554, "body": "def _cmd_get_locals(self, cmd):\n        for frame in inspect.stack():\n            if id(frame) == cmd.frame_id:\n                return InlineResponse(\"get_locals\", locals=self.export_variables(frame.f_locals))\n\n        raise RuntimeError(\"Frame '{0}' not found\".format(cmd.frame_id))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Retrieves the local variables of a specified call stack frame by its ID. This provides a crucial introspection capability for debugging or interactive environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_heap", "line_number": 561, "body": "def _cmd_get_heap(self, cmd):\n        result = {}\n        for key in self._heap:\n            result[key] = self.export_value(self._heap[key])\n\n        return InlineResponse(\"get_heap\", heap=result)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides an exported view of the backend's internal heap, enabling external inspection of the current state of tracked objects within the CPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_shell_autocomplete", "line_number": 568, "body": "def _cmd_shell_autocomplete(self, cmd):\n        try_load_modules_with_frontend_sys_path([\"jedi\", \"parso\"])\n\n        error = None\n        try:\n            import jedi\n        except ImportError:\n            jedi = None\n            completions = []\n            error = \"Could not import jedi\"\n        else:\n            try:\n                with warnings.catch_warnings():\n                    jedi_completions = jedi_utils.get_interpreter_completions(\n                        cmd.source, [__main__.__dict__]\n                    )\n                    completions = self._export_completions(jedi_completions)\n            except Exception as e:\n                completions = []\n                logger.info(\"Autocomplete error\", exc_info=e)\n                error = \"Autocomplete error: \" + str(e)\n\n        return InlineResponse(\n            \"shell_autocomplete\", source=cmd.source, completions=completions, error=error\n        )", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method provides shell autocomplete capabilities. It generates code completion suggestions for interactive Python sessions using the `jedi` library."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_editor_autocomplete", "line_number": 594, "body": "def _cmd_editor_autocomplete(self, cmd):\n        try_load_modules_with_frontend_sys_path([\"jedi\", \"parso\"])\n\n        error = None\n        try:\n            import jedi\n\n            self._debug(jedi.__file__, sys.path)\n            with warnings.catch_warnings():\n                jedi_completions = jedi_utils.get_script_completions(\n                    cmd.source, cmd.row, cmd.column, cmd.filename\n                )\n                completions = self._export_completions(jedi_completions)\n\n        except ImportError:\n            jedi = None\n            completions = []\n            error = \"Could not import jedi\"\n        except Exception as e:\n            completions = []\n            logger.info(\"Autocomplete error\", exc_info=e)\n            error = \"Autocomplete error: \" + str(e)\n\n        return InlineResponse(\n            \"editor_autocomplete\",\n            source=cmd.source,\n            row=cmd.row,\n            column=cmd.column,\n            filename=cmd.filename,\n            completions=completions,\n            error=error,\n        )", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides a service to retrieve code autocompletion suggestions for an editor's Python source code. It leverages the `jedi` library and handles potential errors during generation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_get_object_info", "line_number": 627, "body": "def _cmd_get_object_info(self, cmd):\n        if isinstance(self._current_executor, NiceTracer) and self._current_executor.is_in_past():\n            info = {\"id\": cmd.object_id, \"error\": \"past info not available\"}\n\n        elif cmd.object_id in self._heap:\n            value = self._heap[cmd.object_id]\n            attributes = {}\n            if cmd.include_attributes:\n                for name in dir(value):\n                    if not name.startswith(\"__\") or cmd.all_attributes:\n                        # attributes[name] = inspect.getattr_static(value, name)\n                        try:\n                            attributes[name] = getattr(value, name)\n                        except Exception:\n                            pass\n\n            self._heap[id(type(value))] = type(value)\n            info = {\n                \"id\": cmd.object_id,\n                \"repr\": repr(value),\n                \"type\": str(type(value)),\n                \"full_type_name\": str(type(value))\n                .replace(\"<class '\", \"\")\n                .replace(\"'>\", \"\")\n                .strip(),\n                \"attributes\": self.export_variables(attributes),\n            }\n\n            if isinstance(value, io.TextIOWrapper):\n                self._add_file_handler_info(value, info)\n            elif isinstance(\n                value,\n                (\n                    types.BuiltinFunctionType,\n                    types.BuiltinMethodType,\n                    types.FunctionType,\n                    types.LambdaType,\n                    types.MethodType,\n                ),\n            ):\n                self._add_function_info(value, info)\n            elif isinstance(value, (list, tuple, set)):\n                self._add_elements_info(value, info)\n            elif isinstance(value, dict):\n                self._add_entries_info(value, info)\n            elif isinstance(value, float):\n                self._add_float_info(value, info)\n            elif hasattr(value, \"image_data\"):\n                info[\"image_data\"] = value.image_data\n\n            for tweaker in self._object_info_tweakers:\n                try:\n                    tweaker(value, info, cmd)\n                except Exception:\n                    logger.exception(\"Failed object info tweaker: \" + str(tweaker))\n\n        else:\n            info = {\"id\": cmd.object_id, \"error\": \"object info not available\"}\n\n        return InlineResponse(\"get_object_info\", id=cmd.object_id, info=info)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Retrieves comprehensive runtime information about a Python object identified by its ID. It includes its type, representation, attributes, and specific details based on its kind, useful for introspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_mkdir", "line_number": 688, "body": "def _cmd_mkdir(self, cmd):\n        os.mkdir(cmd.path)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method creates a new directory on the file system based on a received command object. It facilitates backend operations requiring directory creation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_delete", "line_number": 691, "body": "def _cmd_delete(self, cmd):\n        for path in cmd.paths:\n            try:\n                if os.path.isfile(path):\n                    os.remove(path)\n                elif os.path.isdir(path):\n                    import shutil\n\n                    shutil.rmtree(path)\n            except Exception as e:\n                print(\"Could not delete %s: %s\" % (path, str(e)), file=sys.stderr)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method systematically deletes files and directories specified in a command object. It safely removes both individual files and entire directory trees, reporting any encountered errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_sep", "line_number": 703, "body": "def _get_sep(self) -> str:\n        return os.path.sep", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides the operating system's native path separator character, which is crucial for building cross-platform file paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_dir_children_info", "line_number": 706, "body": "def _get_dir_children_info(\n        self, path: str, include_hidden: bool = False\n    ) -> Optional[Dict[str, Dict]]:\n        return get_single_dir_child_data(path, include_hidden)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method retrieves information about the immediate children (files and subdirectories) of a specified directory, optionally including hidden items. It provides a listing of directory contents."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_path_info", "line_number": 711, "body": "def _get_path_info(self, path: str) -> Optional[Dict]:\n\n        try:\n            if not os.path.exists(path):\n                return None\n        except OSError:\n            pass\n\n        try:\n            kind = \"dir\" if os.path.isdir(path) else \"file\"\n            return {\n                \"path\": path,\n                \"kind\": kind,\n                \"size\": None if kind == \"dir\" else os.path.getsize(path),\n                \"modified\": os.path.getmtime(path),\n                \"error\": None,\n            }\n        except OSError as e:\n            return {\n                \"path\": path,\n                \"kind\": None,\n                \"size\": None,\n                \"modified\": None,\n                \"error\": str(e),\n            }", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides a service to retrieve detailed metadata for a given file system path, including its type, size, and last modified time, or reports an error if inaccessible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_export_completions", "line_number": 737, "body": "def _export_completions(self, jedi_completions):\n        result = []\n        for c in jedi_completions:\n            if not c.name.startswith(\"__\"):\n                record = {\n                    \"name\": c.name,\n                    \"complete\": c.complete,\n                    \"type\": c.type,\n                    \"description\": c.description,\n                }\n                \"\"\" TODO: \n                try:\n                    if c.type in [\"class\", \"module\", \"function\"]:\n                        if c.type == \"function\":\n                            record[\"docstring\"] = c.docstring()\n                        else:\n                            record[\"docstring\"] = c.description + \"\\n\" + c.docstring()\n                except Exception:\n                    pass\n                \"\"\"\n                result.append(record)\n        return result", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method processes Jedi autocompletion objects, filters out internal names, and formats them into a list of simplified dictionaries for external consumption, such as by an IDE's completion feature."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_tcl", "line_number": 760, "body": "def _get_tcl(self):\n        if self._tcl is not None:\n            return self._tcl\n\n        tkinter = sys.modules.get(\"tkinter\")\n        if tkinter is None:\n            return None\n\n        if self._tcl is None:\n            try:\n                self._tcl = tkinter.Tcl()\n                self._tcl.updates_without_root = 0\n            except Exception as e:\n                logger.error(\"Could not get Tcl\", exc_info=e)\n                self._tcl = None\n                return None\n\n        self._tcl.has_default_root = tkinter._default_root is not None\n        return self._tcl", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides or initializes the `tkinter.Tcl` interpreter instance, which is essential for the backend's interaction with Tkinter. It ensures a single, configured Tcl interpreter for GUI operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_qt_app", "line_number": 780, "body": "def _get_qt_app(self):\n        mod = sys.modules.get(\"PyQt5.QtCore\")\n        if mod is None:\n            mod = sys.modules.get(\"PyQt4.QtCore\")\n        if mod is None:\n            mod = sys.modules.get(\"PySide.QtCore\")\n        if mod is None:\n            return None\n\n        app_class = getattr(mod, \"QCoreApplication\", None)\n        if app_class is not None:\n            try:\n                return app_class.instance()\n            except Exception:\n                return None\n        else:\n            return None", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method attempts to retrieve the active `QCoreApplication` instance from any installed PyQt5, PyQt4, or PySide modules. It provides a convenient way to access the Qt application context for backend operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_add_file_handler_info", "line_number": 798, "body": "def _add_file_handler_info(self, value, info):\n        try:\n            assert isinstance(value.name, str)\n            assert value.mode in (\"r\", \"rt\", \"tr\", \"br\", \"rb\")\n            assert value.errors in (\"strict\", None)\n            assert value.newlines is None or value.tell() > 0\n            # TODO: cache the content\n            # TODO: don't read too big files\n            with open(value.name, encoding=value.encoding) as f:\n                info[\"file_encoding\"] = f.encoding\n                info[\"file_content\"] = f.read()\n                info[\"file_tell\"] = value.tell()\n        except Exception as e:\n            info[\"file_error\"] = \"Could not get file content, error:\" + str(e)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This function extracts details from a given file handler, including its encoding, content, and current read position. It enriches a provided information dictionary with these file attributes, handling potential errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_add_function_info", "line_number": 813, "body": "def _add_function_info(self, value, info):\n        try:\n            info[\"source\"] = inspect.getsource(value)\n        except Exception:\n            pass", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Enrich an information dictionary by attempting to retrieve and store the source code of a Python object, aiding introspection or debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_add_elements_info", "line_number": 819, "body": "def _add_elements_info(self, value, info):\n        info[\"elements\"] = []\n        for element in value:\n            info[\"elements\"].append(self.export_value(element))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This helper method populates a dictionary with processed representations of a collection of elements. It prepares structured output containing exported individual items."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_add_entries_info", "line_number": 824, "body": "def _add_entries_info(self, value, info):\n        info[\"entries\"] = []\n        for key in value:\n            info[\"entries\"].append((self.export_value(key), self.export_value(value[key])))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method populates a dictionary with a list of processed key-value pairs. It transforms input entries using `export_value` for a specific backend representation or serialization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_add_float_info", "line_number": 829, "body": "def _add_float_info(self, value, info):\n        if not value.is_integer():\n            info[\"as_integer_ratio\"] = value.as_integer_ratio()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method enhances an information dictionary by including the integer ratio of a floating-point number, but only if the number is not an integer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_execute_file", "line_number": 833, "body": "def _execute_file(self, cmd, executor_class):\n        self._check_update_tty_mode(cmd)\n\n        if len(cmd.args) >= 1:\n            sys.argv = cmd.args\n            filename = cmd.args[0]\n            if filename == \"-c\" or os.path.isabs(filename):\n                full_filename = filename\n            else:\n                full_filename = os.path.abspath(filename)\n\n            if full_filename == \"-c\":\n                source = cmd.source\n            else:\n                with tokenize.open(full_filename) as fp:\n                    source = fp.read()\n\n            for preproc in self._source_preprocessors:\n                source = preproc(source, cmd)\n\n            result_attributes = self._execute_source(\n                source, full_filename, \"exec\", executor_class, cmd, self._ast_postprocessors\n            )\n            result_attributes[\"filename\"] = full_filename\n            return ToplevelResponse(command_name=cmd.name, **result_attributes)\n        else:\n            raise UserError(\"Command '%s' takes at least one argument\" % cmd.name)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method provides the CPython backend with the capability to execute Python code from a file path or a direct string. It prepares the source, sets up arguments, and processes the code before execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_execute_source", "line_number": 861, "body": "def _execute_source(\n        self, source, filename, execution_mode, executor_class, cmd, ast_postprocessors=[]\n    ):\n        self._current_executor = executor_class(self, cmd)\n\n        try:\n            return self._current_executor.execute_source(\n                source, filename, execution_mode, ast_postprocessors\n            )\n        finally:\n            self._current_executor = None", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This internal method orchestrates the execution of Python source code within the backend. It initializes a specified executor, delegates the code execution, and manages the executor's lifecycle."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_install_repl_helper", "line_number": 873, "body": "def _install_repl_helper(self):\n        def _handle_repl_value(obj):\n            if obj is not None:\n                try:\n                    obj_repr = repr(obj)\n                    if len(obj_repr) > 5000:\n                        obj_repr = obj_repr[:5000] + \"\u2026\"\n                except Exception as e:\n                    obj_repr = \"<repr error: \" + str(e) + \">\"\n                print(OBJECT_LINK_START % id(obj), obj_repr, OBJECT_LINK_END, sep=\"\")\n                self._heap[id(obj)] = obj\n                builtins._ = obj\n\n        setattr(builtins, _REPL_HELPER_NAME, _handle_repl_value)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Configures a REPL helper to display the last evaluated expression and make it accessible via `builtins._`. It enhances interactive debugging and object inspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_install_fake_streams", "line_number": 888, "body": "def _install_fake_streams(self):\n        self._original_stdin = sys.stdin\n        self._original_stdout = sys.stdout\n        self._original_stderr = sys.stderr\n\n        # yes, both out and err will be directed to out (but with different tags)\n        # this allows client to see the order of interleaving writes to stdout/stderr\n        sys.stdin = FakeInputStream(self, sys.stdin)\n        sys.stdout = FakeOutputStream(self, sys.stdout, \"stdout\")\n        sys.stderr = FakeOutputStream(self, sys.stdout, \"stderr\")\n\n        # fake it properly: replace also \"backup\" streams\n        sys.__stdin__ = sys.stdin\n        sys.__stdout__ = sys.stdout\n        sys.__stderr__ = sys.stderr", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method replaces Python's standard I/O streams with custom objects. It enables capturing, controlling, and reordering program input/output, typically for sandboxed execution or testing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_install_custom_import", "line_number": 904, "body": "def _install_custom_import(self):\n        self._original_import = builtins.__import__\n        builtins.__import__ = self._custom_import", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method installs a custom import mechanism by replacing the built-in `__import__` function. It enables the class to control and intercept all module import operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_restore_original_import", "line_number": 908, "body": "def _restore_original_import(self):\n        builtins.__import__ = self._original_import", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Restores the standard Python import mechanism, reverting any custom import behavior previously set by the backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "send_message", "line_number": 911, "body": "def send_message(self, msg: MessageFromBackend) -> None:\n        sys.stdout.flush()\n\n        if isinstance(msg, ToplevelResponse):\n            if \"cwd\" not in msg:\n                msg[\"cwd\"] = os.getcwd()\n            if \"globals\" not in msg:\n                msg[\"globals\"] = self.export_globals()\n\n        self._original_stdout.write(serialize_message(msg) + \"\\n\")\n        self._original_stdout.flush()", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Transmits serialized messages from the backend. It enriches `ToplevelResponse` messages with the current working directory and global variables before output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "export_value", "line_number": 923, "body": "def export_value(self, value, max_repr_length=5000):\n        self._heap[id(value)] = value\n        try:\n            rep = repr(value)\n        except Exception:\n            # See https://bitbucket.org/plas/thonny/issues/584/problem-with-thonnys-back-end-obj-no\n            rep = \"??? <repr error>\"\n\n        if len(rep) > max_repr_length:\n            rep = rep[:max_repr_length] + \"\u2026\"\n\n        return ValueInfo(id(value), rep)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides a stable reference and a formatted string representation for a given Python object from the backend. It ensures the object remains accessible by its ID for external consumption."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "export_variables", "line_number": 936, "body": "def export_variables(self, variables):\n        result = {}\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            for name in variables:\n                if not name.startswith(\"__\"):\n                    result[name] = self.export_value(variables[name], 100)\n\n        return result", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method processes and exports selected user-defined variables, excluding internal Python attributes. It prepares these variables for display or use within a CPython backend environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "export_globals", "line_number": 946, "body": "def export_globals(self, module_name=\"__main__\"):\n        if module_name in sys.modules:\n            return self.export_variables(sys.modules[module_name].__dict__)\n        else:\n            raise RuntimeError(\"Module '{0}' is not loaded\".format(module_name))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Exports the global variables of a specified Python module. It enables external access or persistence of a module's current global state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_debug", "line_number": 952, "body": "def _debug(self, *args):\n        logger.debug(\"MainCPythonBackend: \" + str(args))", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Provides an internal debugging mechanism for the MainCPythonBackend class, logging specified arguments to aid in development and troubleshooting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_enter_io_function", "line_number": 955, "body": "def _enter_io_function(self):\n        self._io_level += 1", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Increments an internal counter, `_io_level`, to track entry into an I/O function. This helps the backend manage the current I/O context or depth."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_exit_io_function", "line_number": 958, "body": "def _exit_io_function(self):\n        self._io_level -= 1", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Manages the internal I/O state within the backend by decrementing a level counter. This indicates the completion or exit from an I/O operation scope."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "is_doing_io", "line_number": 961, "body": "def is_doing_io(self):\n        return self._io_level > 0", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Checks if the CPython backend is currently performing any input/output operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_export_stack", "line_number": 964, "body": "def _export_stack(self, newest_frame, relevance_checker=None):\n        result = []\n\n        system_frame = newest_frame\n\n        while system_frame is not None:\n            module_name = system_frame.f_globals[\"__name__\"]\n            code_name = system_frame.f_code.co_name\n\n            if not relevance_checker or relevance_checker(system_frame):\n                source, firstlineno, in_library = self._get_frame_source_info(system_frame)\n\n                result.insert(\n                    0,\n                    FrameInfo(\n                        # TODO: can this id be reused by a later frame?\n                        # Need to store the reference to avoid GC?\n                        # I guess it is not required, as id will be required\n                        # only for stacktrace inspection, and sys.last_exception\n                        # will have the reference anyway\n                        # (NiceTracer has its own reference keeping)\n                        id=id(system_frame),\n                        filename=system_frame.f_code.co_filename,\n                        module_name=module_name,\n                        code_name=code_name,\n                        locals=self.export_variables(system_frame.f_locals),\n                        globals=self.export_variables(system_frame.f_globals),\n                        freevars=system_frame.f_code.co_freevars,\n                        source=source,\n                        lineno=system_frame.f_lineno,\n                        firstlineno=firstlineno,\n                        in_library=in_library,\n                        event=\"line\",\n                        focus=TextRange(system_frame.f_lineno, 0, system_frame.f_lineno + 1, 0),\n                        node_tags=None,\n                        current_statement=None,\n                        current_evaluations=None,\n                        current_root_expression=None,\n                    ),\n                )\n\n            if module_name == \"__main__\" and code_name == \"<module>\":\n                # this was last frame relevant to the user\n                break\n\n            system_frame = system_frame.f_back\n\n        assert result  # not empty\n        return result", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method walks the Python call stack from a given frame, extracting detailed information for each relevant frame, including source, variables, and line numbers. It provides a structured representation of the execution stack, useful for debuggers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_lookup_frame_by_id", "line_number": 1014, "body": "def _lookup_frame_by_id(self, frame_id):\n        def lookup_from_stack(frame):\n            if frame is None:\n                return None\n            elif id(frame) == frame_id:\n                return frame\n            else:\n                return lookup_from_stack(frame.f_back)\n\n        def lookup_from_tb(entry):\n            if entry is None:\n                return None\n            elif id(entry.tb_frame) == frame_id:\n                return entry.tb_frame\n            else:\n                return lookup_from_tb(entry.tb_next)\n\n        result = lookup_from_stack(inspect.currentframe())\n        if result is not None:\n            return result, \"stack\"\n\n        if getattr(sys, \"last_traceback\"):\n            result = lookup_from_tb(getattr(sys, \"last_traceback\"))\n            if result:\n                return result, \"last_traceback\"\n\n        _, _, tb = sys.exc_info()\n        return lookup_from_tb(tb), \"current_exception\"", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Locates a Python frame object by its ID, searching the current call stack, the last traceback, and the current exception's traceback. This capability is essential for debugging and introspection tools."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_frame_source_info", "line_number": 1043, "body": "def _get_frame_source_info(self, frame):\n        fid = id(frame)\n        if fid not in self._source_info_by_frame:\n            self._source_info_by_frame[fid] = _fetch_frame_source_info(frame)\n\n        return self._source_info_by_frame[fid]", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Retrieves and caches source code information for a Python frame. It optimizes performance by ensuring source data is fetched only once per frame."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_prepare_user_exception", "line_number": 1050, "body": "def _prepare_user_exception(self):\n        e_type, e_value, e_traceback = sys.exc_info()\n        sys.last_type, sys.last_value, sys.last_traceback = (e_type, e_value, e_traceback)\n\n        processed_tb = traceback.extract_tb(e_traceback)\n\n        tb = e_traceback\n        while tb.tb_next is not None:\n            tb = tb.tb_next\n        last_frame = tb.tb_frame\n\n        if e_type is SyntaxError:\n            # Don't show ast frame\n            while last_frame.f_code.co_filename and last_frame.f_code.co_filename == ast.__file__:\n                last_frame = last_frame.f_back\n\n        if e_type is SyntaxError:\n            msg = (\n                traceback.format_exception_only(e_type, e_value)[-1]\n                .replace(e_type.__name__ + \":\", \"\")\n                .strip()\n            )\n        else:\n            msg = str(e_value)\n\n        return {\n            \"type_name\": e_type.__name__,\n            \"message\": msg,\n            \"stack\": self._export_stack(last_frame),\n            \"items\": format_exception_with_frame_info(e_type, e_value, e_traceback),\n            \"filename\": getattr(e_value, \"filename\", processed_tb[-1].filename),\n            \"lineno\": getattr(e_value, \"lineno\", processed_tb[-1].lineno),\n            \"col_offset\": getattr(e_value, \"offset\", None),\n            \"line\": getattr(e_value, \"text\", processed_tb[-1].line),\n        }", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Prepares a structured dictionary containing detailed information about a user-generated exception. This includes the error type, message, and a cleaned stack trace for backend processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_check_update_tty_mode", "line_number": 1086, "body": "def _check_update_tty_mode(self, cmd):\n        if \"tty_mode\" in cmd:\n            self._tty_mode = cmd[\"tty_mode\"]", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method updates the backend's internal TTY mode setting. It applies a new mode if specified within the provided command."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "isatty", "line_number": 1097, "body": "def isatty(self):\n        return self._backend._tty_mode and (os.name != \"nt\" or \"click\" not in sys.modules)", "is_method": true, "class_name": "FakeStream", "function_description": "Determines if this fake stream is connected to an interactive terminal, enabling conditional behavior for applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "__getattr__", "line_number": 1100, "body": "def __getattr__(self, name):\n        # TODO: is it safe to perform those other functions without notifying backend\n        # via _enter_io_function?\n        return getattr(self._target_stream, name)", "is_method": true, "class_name": "FakeStream", "function_description": "This method allows `FakeStream` to transparently delegate all attribute access to an underlying stream object. It acts as a proxy for the target stream."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "write", "line_number": 1111, "body": "def write(self, data):\n        try:\n            self._backend._enter_io_function()\n            # click may send bytes instead of strings\n            if isinstance(data, bytes):\n                data = data.decode(errors=\"replace\")\n\n            if data != \"\":\n                self._backend._send_output(data=data, stream_name=self._stream_name)\n                self._processed_symbol_count += len(data)\n        finally:\n            self._backend._exit_io_function()", "is_method": true, "class_name": "FakeOutputStream", "function_description": "Provides the capability to write processed data to a simulated output stream. It decodes bytes and tracks output, offering a controlled way to capture or redirect data for testing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "writelines", "line_number": 1124, "body": "def writelines(self, lines):\n        try:\n            self._backend._enter_io_function()\n            self.write(\"\".join(lines))\n        finally:\n            self._backend._exit_io_function()", "is_method": true, "class_name": "FakeOutputStream", "function_description": "Provides the capability to write multiple lines of text to the simulated output stream. It handles the necessary I/O context management for the fake stream."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_generic_read", "line_number": 1138, "body": "def _generic_read(self, method, original_limit):\n        if original_limit is None:\n            effective_limit = -1\n        elif method == \"readlines\" and original_limit > -1:\n            # NB! size hint is defined in weird way\n            # \"no more lines will be read if the total size (in bytes/characters)\n            # of all lines so far **exceeds** the hint\".\n            effective_limit = original_limit + 1\n        else:\n            effective_limit = original_limit\n\n        try:\n            self._backend._enter_io_function()\n            while True:\n                if effective_limit == 0:\n                    result = \"\"\n                    break\n\n                elif effective_limit > 0 and len(self._buffer) >= effective_limit:\n                    result = self._buffer[:effective_limit]\n                    self._buffer = self._buffer[effective_limit:]\n                    if method == \"readlines\" and not result.endswith(\"\\n\") and \"\\n\" in self._buffer:\n                        # limit is just a hint\n                        # https://docs.python.org/3/library/io.html#io.IOBase.readlines\n                        extra = self._buffer[: self._buffer.find(\"\\n\") + 1]\n                        result += extra\n                        self._buffer = self._buffer[len(extra) :]\n                    break\n\n                elif method == \"readline\" and \"\\n\" in self._buffer:\n                    pos = self._buffer.find(\"\\n\") + 1\n                    result = self._buffer[:pos]\n                    self._buffer = self._buffer[pos:]\n                    break\n\n                elif self._eof:\n                    result = self._buffer\n                    self._buffer = \"\"\n                    self._eof = False  # That's how official implementation does\n                    break\n\n                else:\n                    self._backend.send_message(\n                        BackendEvent(\"InputRequest\", method=method, limit=original_limit)\n                    )\n                    msg = self._backend._fetch_next_incoming_message()\n                    if isinstance(msg, InputSubmission):\n                        self._buffer += msg.data\n                        self._processed_symbol_count += len(msg.data)\n                    elif isinstance(msg, EOFCommand):\n                        self._eof = True\n                    elif isinstance(msg, InlineCommand):\n                        self._backend._handle_normal_command(msg)\n                    else:\n                        raise RuntimeError(\n                            \"Wrong type of command (%r) when waiting for input\" % (msg,)\n                        )\n\n            return result\n\n        finally:\n            self._backend._exit_io_function()", "is_method": true, "class_name": "FakeInputStream", "function_description": "An internal method for `FakeInputStream` that simulates reading input. It fetches data from a backend, managing a buffer and implementing common read operations like `readline` and `readlines` with size limits."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "read", "line_number": 1201, "body": "def read(self, limit=-1):\n        return self._generic_read(\"read\", limit)", "is_method": true, "class_name": "FakeInputStream", "function_description": "Reads data from the fake input stream, optionally limiting the amount read. It serves as a mock or test utility for stream-consuming components."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "readline", "line_number": 1204, "body": "def readline(self, limit=-1):\n        return self._generic_read(\"readline\", limit)", "is_method": true, "class_name": "FakeInputStream", "function_description": "Simulates reading a single line of input from the fake stream, mirroring the behavior of a standard file-like object's readline method."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "readlines", "line_number": 1207, "body": "def readlines(self, limit=-1):\n        return self._generic_read(\"readlines\", limit).splitlines(True)", "is_method": true, "class_name": "FakeInputStream", "function_description": "Simulates a file's `readlines` method, returning a list of lines from the fake input stream. It can optionally limit the number of lines read."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "__next__", "line_number": 1210, "body": "def __next__(self):\n        result = self.readline()\n        if not result:\n            raise StopIteration\n\n        return result", "is_method": true, "class_name": "FakeInputStream", "function_description": "Enables iteration over the FakeInputStream by returning the next line from the simulated stream. It raises StopIteration when no more lines are available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "__iter__", "line_number": 1217, "body": "def __iter__(self):\n        return self", "is_method": true, "class_name": "FakeInputStream", "function_description": "Enables iteration over `FakeInputStream` objects. It allows the instance to serve as its own iterator, making it usable in loops."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "wrapper", "line_number": 1223, "body": "def wrapper(self, *args, **kwargs):\n        try:\n            sys.meta_path.insert(0, self)\n            self._backend._install_custom_import()\n            return method(self, *args, **kwargs)\n        finally:\n            del sys.meta_path[0]\n            if hasattr(self._backend, \"_original_import\"):\n                self._backend._restore_original_import()", "is_method": false, "function_description": "This wrapper temporarily customizes Python's module import mechanism before executing the wrapped method. It ensures the import system is restored to its original state afterwards."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "wrapper", "line_number": 1238, "body": "def wrapper(self, *args, **kwargs):\n        try:\n            result = method(self, *args, **kwargs)\n            if result is not None:\n                return result\n            return {\"context_info\": \"after normal execution\"}\n        except Exception:\n            return {\"user_exception\": self._backend._prepare_user_exception()}", "is_method": false, "function_description": "Provides a resilient execution layer for another method, normalizing its output or supplying default context if no result. It captures exceptions, returning detailed error information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "execute_source", "line_number": 1256, "body": "def execute_source(self, source, filename, mode, ast_postprocessors):\n        if isinstance(source, str):\n            # TODO: simplify this or make sure encoding is correct\n            source = source.encode(\"utf-8\")\n\n        if os.path.exists(filename):\n            self._main_module_path = filename\n\n        global_vars = __main__.__dict__\n\n        try:\n            if mode == \"repl\":\n                assert not ast_postprocessors\n                # Useful in shell to get last expression value in multi-statement block\n                root = self._prepare_ast(source, filename, \"exec\")\n                # https://bugs.python.org/issue35894\n                # https://github.com/pallets/werkzeug/pull/1552/files#diff-9e75ca133f8601f3b194e2877d36df0eR950\n                module = ast.parse(\"\")\n                module.body = root.body\n                self._instrument_repl_code(module)\n                statements = compile(module, filename, \"exec\")\n            elif mode == \"exec\":\n                root = self._prepare_ast(source, filename, mode)\n                for func in ast_postprocessors:\n                    func(root)\n                statements = compile(root, filename, mode)\n            else:\n                raise ValueError(\"Unknown mode\", mode)\n\n            return self._execute_prepared_user_code(statements, global_vars)\n        except SyntaxError:\n            return {\"user_exception\": self._backend._prepare_user_exception()}\n        except SystemExit:\n            return {\"SystemExit\": True}\n        except Exception as e:\n            self._backend._report_internal_exception(e)\n            return {}", "is_method": true, "class_name": "Executor", "function_description": "Executes provided Python source code after compilation, supporting different modes like REPL or script execution. It allows AST post-processing for custom code transformation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_execute_prepared_user_code", "line_number": 1296, "body": "def _execute_prepared_user_code(self, statements, global_vars):\n        exec(statements, global_vars)", "is_method": true, "class_name": "Executor", "function_description": "Provides the capability to dynamically execute user-defined Python code supplied as a string within a specific global namespace."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_prepare_ast", "line_number": 1303, "body": "def _prepare_ast(self, source, filename, mode):\n        return ast.parse(source, filename, mode)", "is_method": true, "class_name": "Executor", "function_description": "Parses Python source code into an Abstract Syntax Tree (AST). This structured representation enables the Executor to analyze, transform, or prepare code for execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_instrument_repl_code", "line_number": 1306, "body": "def _instrument_repl_code(self, root):\n        # modify all expression statements to print and register their non-None values\n        for node in ast.walk(root):\n            if (\n                isinstance(node, ast.FunctionDef)\n                or hasattr(ast, \"AsyncFunctionDef\")\n                and isinstance(node, ast.AsyncFunctionDef)\n            ):\n                first_stmt = node.body[0]\n                if isinstance(first_stmt, ast.Expr) and isinstance(first_stmt.value, ast.Str):\n                    first_stmt.contains_docstring = True\n            if isinstance(node, ast.Expr) and not getattr(node, \"contains_docstring\", False):\n                node.value = ast.Call(\n                    func=ast.Name(id=_REPL_HELPER_NAME, ctx=ast.Load()),\n                    args=[node.value],\n                    keywords=[],\n                )\n                ast.fix_missing_locations(node)", "is_method": true, "class_name": "Executor", "function_description": "This internal method instruments an Abstract Syntax Tree (AST) to modify code for a REPL. It ensures expression statements automatically print and register their non-None values during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_canonic_path", "line_number": 1362, "body": "def _get_canonic_path(self, path):\n        # adapted from bdb\n        result = self._canonic_path_cache.get(path)\n        if result is None:\n            if path.startswith(\"<\"):\n                result = path\n            else:\n                result = os.path.normcase(os.path.abspath(path))\n\n            self._canonic_path_cache[path] = result\n\n        return result", "is_method": true, "class_name": "Tracer", "function_description": "Provides a cached, canonical, and absolute representation of file paths for consistent comparison. This is vital for accurately tracking code execution locations within the Tracer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_execute_prepared_user_code", "line_number": 1378, "body": "def _execute_prepared_user_code(self, statements, global_vars):\n        try:\n            sys.settrace(self._trace)\n            if hasattr(sys, \"breakpointhook\"):\n                old_breakpointhook = sys.breakpointhook\n                sys.breakpointhook = self._breakpointhook\n\n            return super()._execute_prepared_user_code(statements, global_vars)\n        finally:\n            sys.settrace(None)\n            if hasattr(sys, \"breakpointhook\"):\n                sys.breakpointhook = old_breakpointhook", "is_method": true, "class_name": "Tracer", "function_description": "Executes user code under the Tracer's control, enabling system-level tracing and custom breakpoint handling for detailed monitoring."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_interesting_frame", "line_number": 1391, "body": "def _is_interesting_frame(self, frame):\n        code = frame.f_code\n\n        return not (\n            code is None\n            or code.co_filename is None\n            or not self._is_interesting_module_file(code.co_filename)\n            or code.co_flags & _CO_GENERATOR\n            and code.co_flags & _CO_COROUTINE\n            and code.co_flags & _CO_ITERABLE_COROUTINE\n            and code.co_flags & _CO_ASYNC_GENERATOR\n            # or \"importlib._bootstrap\" in code.co_filename\n            or code.co_name in [\"<listcomp>\", \"<setcomp>\", \"<dictcomp>\"]\n        )", "is_method": true, "class_name": "Tracer", "function_description": "This method determines if an execution frame is relevant for tracing by the `Tracer` class, filtering out internal, boilerplate, or uninteresting code such as comprehensions and generators."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_interesting_module_file", "line_number": 1406, "body": "def _is_interesting_module_file(self, path):\n        # interesting files are the files in the same directory as main module\n        # or the ones with breakpoints\n        # When command is \"resume\", then only modules with breakpoints are interesting\n        # (used to be more flexible, but this caused problems\n        # when main script was in ~/. Then user site library became interesting as well)\n\n        result = self._file_interest_cache.get(path, None)\n        if result is not None:\n            return result\n\n        _, extension = os.path.splitext(path.lower())\n\n        result = (\n            self._get_breakpoints_in_file(path)\n            or self._main_module_path is not None\n            and is_same_path(path, self._main_module_path)\n            or extension in (\".py\", \".pyw\")\n            and (\n                self._current_command.get(\"allow_stepping_into_libraries\", False)\n                or (\n                    path_startswith(path, os.path.dirname(self._main_module_path))\n                    # main module may be at the root of the fs\n                    and not path_startswith(path, sys.prefix)\n                    and not path_startswith(path, sys.base_prefix)\n                    and not path_startswith(path, site.getusersitepackages() or \"usersitenotexists\")\n                )\n            )\n            and not path_startswith(path, self._thonny_src_dir)\n        )\n\n        self._file_interest_cache[path] = result\n\n        return result", "is_method": true, "class_name": "Tracer", "function_description": "Determines if a Python module file is \"interesting\" for the Tracer to monitor during execution. It considers breakpoints, the main module status, and its location relative to user or system libraries to control tracing scope."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_interesting_exception", "line_number": 1441, "body": "def _is_interesting_exception(self, frame, arg):\n        return arg[0] not in (StopIteration, StopAsyncIteration)", "is_method": true, "class_name": "Tracer", "function_description": "It determines if an exception is relevant for tracing by excluding typical control flow exceptions like `StopIteration`."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_fetch_next_debugger_command", "line_number": 1444, "body": "def _fetch_next_debugger_command(self, current_frame):\n        while True:\n            cmd = self._backend._fetch_next_incoming_message()\n            if isinstance(cmd, InlineCommand):\n                self._backend._handle_normal_command(cmd)\n            else:\n                assert isinstance(cmd, DebuggerCommand)\n                self._prev_breakpoints = self._current_command.breakpoints\n                self._current_command = cmd\n                self._initialize_new_command(current_frame)\n                return", "is_method": true, "class_name": "Tracer", "function_description": "This method continuously fetches the next debugger command from the backend, processing any inline commands encountered, to update the tracer's state for subsequent execution control."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_initialize_new_command", "line_number": 1456, "body": "def _initialize_new_command(self, current_frame):\n        self._command_completion_handler = getattr(\n            self, \"_cmd_%s_completed\" % self._current_command.name\n        )\n\n        if self._current_command.breakpoints != self._prev_breakpoints:\n            self._file_interest_cache = {}  # because there may be new breakpoints\n            self._file_breakpoints_cache = {}\n            for path, linenos in self._current_command.breakpoints.items():\n                self._file_breakpoints_cache[path] = linenos\n                self._file_breakpoints_cache[self._get_canonic_path(path)] = linenos", "is_method": true, "class_name": "Tracer", "function_description": "Prepares the Tracer for a new command. It sets the command's completion handler and updates internal breakpoint caches if breakpoints have changed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_register_affected_frame", "line_number": 1468, "body": "def _register_affected_frame(self, exception_obj, frame):\n        # I used to store the frame ids in a new field inside exception object,\n        # but Python 3.8 doesn't allow this (https://github.com/thonny/thonny/issues/1403)\n        exc_id = id(exception_obj)\n        if exc_id not in self._affected_frame_ids_per_exc_id:\n            self._affected_frame_ids_per_exc_id[exc_id] = set()\n        self._affected_frame_ids_per_exc_id[exc_id].add(id(frame))", "is_method": true, "class_name": "Tracer", "function_description": "This internal method records the ID of an execution frame as being affected by a specific exception. It helps the `Tracer` class track which frames are involved when an exception occurs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_breakpoints_in_file", "line_number": 1476, "body": "def _get_breakpoints_in_file(self, filename):\n        result = self._file_breakpoints_cache.get(filename, None)\n\n        if result is not None:\n            return result\n\n        canonic_path = self._get_canonic_path(filename)\n        result = self._file_breakpoints_cache.get(canonic_path, set())\n        self._file_breakpoints_cache[filename] = result\n        return result", "is_method": true, "class_name": "Tracer", "function_description": "This method retrieves the set of breakpoints associated with a given file. It efficiently uses an internal cache, checking both the provided filename and its canonical path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_current_exception", "line_number": 1487, "body": "def _get_current_exception(self):\n        if self._fresh_exception is not None:\n            return self._fresh_exception\n        else:\n            return sys.exc_info()", "is_method": true, "class_name": "Tracer", "function_description": "Returns the most recent exception information. It either provides a stored \"fresh\" exception or defaults to `sys.exc_info()`."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_export_exception_info", "line_number": 1493, "body": "def _export_exception_info(self):\n        exc = self._get_current_exception()\n\n        if exc[0] is None:\n            return {\n                \"id\": None,\n                \"msg\": None,\n                \"type_name\": None,\n                \"lines_with_frame_info\": None,\n                \"affected_frame_ids\": set(),\n                \"is_fresh\": False,\n            }\n        else:\n            return {\n                \"id\": id(exc[1]),\n                \"msg\": str(exc[1]),\n                \"type_name\": exc[0].__name__,\n                \"lines_with_frame_info\": format_exception_with_frame_info(*exc),\n                \"affected_frame_ids\": self._affected_frame_ids_per_exc_id.get(id(exc[1]), set()),\n                \"is_fresh\": exc == self._fresh_exception,\n            }", "is_method": true, "class_name": "Tracer", "function_description": "Gathers and formats detailed information about the currently active Python exception. It provides a structured dictionary for error logging or analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_check_notify_return", "line_number": 1518, "body": "def _check_notify_return(self, frame_id):\n        if frame_id in self._last_reported_frame_ids:\n            # Need extra notification, because it may be long time until next interesting event\n            self._backend.send_message(InlineResponse(\"debugger_return\", frame_id=frame_id))", "is_method": true, "class_name": "Tracer", "function_description": "Notifies the debugger backend about the return of a specific execution frame. This ensures timely updates for frames that might otherwise experience long gaps between tracing events."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_check_store_main_frame_id", "line_number": 1523, "body": "def _check_store_main_frame_id(self, frame):\n        # initial command doesn't have a frame id\n        if self._current_command.frame_id is None and self._get_canonic_path(\n            frame.f_code.co_filename\n        ) == self._get_canonic_path(self._main_module_path):\n            self._current_command.frame_id = id(frame)", "is_method": true, "class_name": "Tracer", "function_description": "Checks if the current command's main frame ID is unset and the frame belongs to the main module. If so, it stores the frame's ID to anchor the execution trace."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_initialize_new_command", "line_number": 1539, "body": "def _initialize_new_command(self, current_frame):\n        super()._initialize_new_command(current_frame)\n        self._command_frame_returned = False\n        if self._current_command.breakpoints != self._prev_breakpoints:\n            self._code_breakpoints_cache = {}\n\n            # restore tracing for active frames which were skipped before\n            # but have breakpoints now\n            frame = current_frame\n            while frame is not None:\n                if (\n                    frame.f_trace is None\n                    and frame.f_code is not None\n                    and self._get_breakpoints_in_code(frame.f_code)\n                ):\n                    frame.f_trace = self._trace\n\n                frame = frame.f_back", "is_method": true, "class_name": "FastTracer", "function_description": "Initializes the tracer for a new command. It clears breakpoint caches and re-enables tracing on call stack frames that now contain breakpoints, ensuring proper debugging flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_breakpointhook", "line_number": 1558, "body": "def _breakpointhook(self, *args, **kw):\n        frame = inspect.currentframe()\n        while not self._is_interesting_frame(frame):\n            frame = frame.f_back\n        self._report_current_state(frame)\n        self._fetch_next_debugger_command(frame)", "is_method": true, "class_name": "FastTracer", "function_description": "Handles a breakpoint event for `FastTracer` by identifying the relevant call frame. It then reports the frame's state and awaits interactive debugger commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_should_skip_frame", "line_number": 1565, "body": "def _should_skip_frame(self, frame, event):\n        if event == \"call\":\n            # new frames\n            return (\n                (\n                    self._current_command.name == \"resume\"\n                    and not self._get_breakpoints_in_code(frame.f_code)\n                    or self._current_command.name == \"step_over\"\n                    and not self._get_breakpoints_in_code(frame.f_code)\n                    and id(frame) not in self._last_reported_frame_ids\n                    or self._current_command.name == \"step_out\"\n                    and not self._get_breakpoints_in_code(frame.f_code)\n                )\n                or not self._is_interesting_frame(frame)\n                or self._backend.is_doing_io()\n            )\n\n        else:\n            # once we have entered a frame, we need to reach the return event\n            return False", "is_method": true, "class_name": "FastTracer", "function_description": "This internal method of FastTracer determines whether to skip processing an execution frame during tracing, considering the current debugger command, active breakpoints, and frame relevance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_trace", "line_number": 1586, "body": "def _trace(self, frame, event, arg):\n        if self._should_skip_frame(frame, event):\n            return None\n\n        # return None\n        # return self._trace\n\n        frame_id = id(frame)\n\n        if event == \"call\":\n            self._check_store_main_frame_id(frame)\n\n            self._fresh_exception = None\n            # can we skip this frame?\n            if self._current_command.name == \"step_over\" and not self._current_command.breakpoints:\n                return None\n\n        elif event == \"return\":\n            self._fresh_exception = None\n            if frame_id == self._current_command[\"frame_id\"]:\n                self._command_frame_returned = True\n            self._check_notify_return(frame_id)\n\n        elif event == \"exception\":\n            if self._is_interesting_exception(frame, arg):\n                self._fresh_exception = arg\n                self._register_affected_frame(arg[1], frame)\n                # UI doesn't know about separate exception events\n                self._report_current_state(frame)\n                self._fetch_next_debugger_command(frame)\n\n        elif event == \"line\":\n            self._fresh_exception = None\n\n            if self._command_completion_handler(frame):\n                self._report_current_state(frame)\n                self._fetch_next_debugger_command(frame)\n\n        else:\n            self._fresh_exception = None\n\n        return self._trace", "is_method": true, "class_name": "FastTracer", "function_description": "The core method of `FastTracer`, it processes Python execution events (call, return, line, exception). It manages debugger state, reports status, and fetches commands for interactive debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_report_current_state", "line_number": 1629, "body": "def _report_current_state(self, frame):\n        stack = self._backend._export_stack(frame, self._is_interesting_frame)\n        msg = DebuggerResponse(\n            stack=stack,\n            in_present=True,\n            io_symbol_count=None,\n            exception_info=self._export_exception_info(),\n            tracer_class=\"FastTracer\",\n        )\n\n        self._last_reported_frame_ids = set(map(lambda f: f.id, stack))\n\n        self._backend.send_message(msg)", "is_method": true, "class_name": "FastTracer", "function_description": "This method captures the program's current call stack and exception details. It then packages and sends this comprehensive debug state to the tracing backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_into_completed", "line_number": 1643, "body": "def _cmd_step_into_completed(self, frame):\n        return True", "is_method": true, "class_name": "FastTracer", "function_description": "Provides an unconditional signal indicating that a 'step into' command has completed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_over_completed", "line_number": 1646, "body": "def _cmd_step_over_completed(self, frame):\n        return (\n            id(frame) == self._current_command.frame_id\n            or self._command_frame_returned\n            or self._at_a_breakpoint(frame)\n        )", "is_method": true, "class_name": "FastTracer", "function_description": "Determines if the active 'step over' debugging command has completed for the FastTracer. It signals completion when the execution frame aligns or a breakpoint is encountered."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_out_completed", "line_number": 1653, "body": "def _cmd_step_out_completed(self, frame):\n        return self._command_frame_returned or self._at_a_breakpoint(frame)", "is_method": true, "class_name": "FastTracer", "function_description": "Checks if a 'step out' debugging command has completed, either because the function returned or execution reached an active breakpoint. This determines if tracing should halt after a step-out operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_resume_completed", "line_number": 1656, "body": "def _cmd_resume_completed(self, frame):\n        return self._at_a_breakpoint(frame)", "is_method": true, "class_name": "FastTracer", "function_description": "Checks if the current execution frame is at a breakpoint. This method validates the tracer's state after a resume command finishes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_get_breakpoints_in_code", "line_number": 1659, "body": "def _get_breakpoints_in_code(self, f_code):\n\n        bps_in_file = self._get_breakpoints_in_file(f_code.co_filename)\n\n        code_id = id(f_code)\n        result = self._code_breakpoints_cache.get(code_id, None)\n\n        if result is None:\n            if not bps_in_file:\n                result = set()\n            else:\n                co_linenos = self._code_linenos_cache.get(code_id, None)\n                if co_linenos is None:\n                    co_linenos = {pair[1] for pair in dis.findlinestarts(f_code)}\n                    self._code_linenos_cache[code_id] = co_linenos\n\n                result = bps_in_file.intersection(co_linenos)\n\n            self._code_breakpoints_cache[code_id] = result\n\n        return result", "is_method": true, "class_name": "FastTracer", "function_description": "For a given code object, this FastTracer method efficiently identifies and returns the set of active breakpoints relevant to its execution, using caching for speed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_at_a_breakpoint", "line_number": 1681, "body": "def _at_a_breakpoint(self, frame):\n        # TODO: try re-entering same line in loop\n        return frame.f_lineno in self._get_breakpoints_in_code(frame.f_code)", "is_method": true, "class_name": "FastTracer", "function_description": "Determines if the current execution line within a given frame is set as a breakpoint. This helper function assists a tracer or debugger in identifying breakpoint hits."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_interesting_exception", "line_number": 1685, "body": "def _is_interesting_exception(self, frame, arg):\n        return super()._is_interesting_exception(frame, arg) and (\n            self._current_command.name in [\"step_into\", \"step_over\"]\n            and (\n                # in command frame or its parent frames\n                id(frame) == self._current_command[\"frame_id\"]\n                or self._command_frame_returned\n            )\n        )", "is_method": true, "class_name": "FastTracer", "function_description": "Determines if an exception is relevant to the current debugger \"step_into\" or \"step_over\" command, considering the call frame. This helps the FastTracer focus on specific exceptions during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_breakpointhook", "line_number": 1710, "body": "def _breakpointhook(self, *args, **kw):\n        self._report_state(len(self._saved_states) - 1)\n        self._fetch_next_debugger_command(None)", "is_method": true, "class_name": "NiceTracer", "function_description": "Provides the core logic for breakpoint handling within NiceTracer. It reports the program's current state and then awaits a command from the interactive debugger."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_install_marker_functions", "line_number": 1714, "body": "def _install_marker_functions(self):\n        # Make dummy marker functions universally available by putting them\n        # into builtin scope\n        self.marker_function_names = {\n            BEFORE_STATEMENT_MARKER,\n            AFTER_STATEMENT_MARKER,\n            BEFORE_EXPRESSION_MARKER,\n            AFTER_EXPRESSION_MARKER,\n        }\n\n        for name in self.marker_function_names:\n            if not hasattr(builtins, name):\n                setattr(builtins, name, getattr(self, name))", "is_method": true, "class_name": "NiceTracer", "function_description": "Installs specific internal tracing marker functions into Python's built-in namespace. This makes them globally available for instrumentation and detailed code execution tracing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_prepare_ast", "line_number": 1728, "body": "def _prepare_ast(self, source, filename, mode):\n        # ast_utils need to be imported after asttokens\n        # is (custom-)imported\n        try_load_modules_with_frontend_sys_path([\"asttokens\", \"six\", \"astroid\"])\n        from thonny import ast_utils\n\n        root = ast.parse(source, filename, mode)\n\n        ast_utils.mark_text_ranges(root, source)\n        self._tag_nodes(root)\n        self._insert_expression_markers(root)\n        self._insert_statement_markers(root)\n        self._insert_for_target_markers(root)\n        self._instrumented_files.add(filename)\n\n        return root", "is_method": true, "class_name": "NiceTracer", "function_description": "Chain of Thought:\nThe function `_prepare_ast` within the `NiceTracer` class clearly deals with Abstract Syntax Trees (AST). It first parses the source code into an AST. Then, it calls several internal methods (`_tag_nodes`, `_insert_expression_markers`, etc.) that modify or \"instrument\" this AST. Given the class name `NiceTracer`, the purpose of this instrumentation is likely for tracing the execution of the code represented by the AST. The core service is to produce an AST that is ready for tracing.\nThis method parses Python source code into an Abstract Syntax Tree (AST). It then instruments the AST by adding various markers for tracing code execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_should_skip_frame", "line_number": 1745, "body": "def _should_skip_frame(self, frame, event):\n        # nice tracer can't skip any of the frames which need to be\n        # shown in the stacktrace\n        code = frame.f_code\n        if code is None:\n            return True\n\n        if event == \"call\":\n            # new frames\n            if code.co_name in self.marker_function_names:\n                return False\n\n            else:\n                return not self._is_interesting_frame(frame) or self._backend.is_doing_io()\n\n        else:\n            # once we have entered a frame, we need to reach the return event\n            return False", "is_method": true, "class_name": "NiceTracer", "function_description": "Determines if a Python stack frame should be traced or skipped by the NiceTracer. It filters frames based on event type, function name, and the tracer's internal state or I/O activity."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_is_interesting_frame", "line_number": 1764, "body": "def _is_interesting_frame(self, frame):\n        return (\n            frame.f_code.co_filename in self._instrumented_files\n            and super()._is_interesting_frame(frame)\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "Filters execution frames to identify those originating from files explicitly configured for instrumentation, combined with parent class filtering logic."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "find_spec", "line_number": 1770, "body": "def find_spec(self, fullname, path=None, target=None):\n        spec = PathFinder.find_spec(fullname, path, target)\n\n        if (\n            spec is not None\n            and isinstance(spec.loader, SourceFileLoader)\n            and getattr(spec, \"origin\", None)\n            and self._is_interesting_module_file(spec.origin)\n        ):\n            spec.loader = FancySourceFileLoader(fullname, spec.origin, self)\n            return spec\n        else:\n            return super().find_spec(fullname, path, target)", "is_method": true, "class_name": "NiceTracer", "function_description": "This `NiceTracer` method customizes Python's module import process. It identifies specific source files and replaces their standard loader with a custom one, enabling tracing or modifications during module loading."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "is_in_past", "line_number": 1784, "body": "def is_in_past(self):\n        return self._current_state_index < len(self._saved_states) - 1", "is_method": true, "class_name": "NiceTracer", "function_description": "Determines if the tracer's current position is behind the latest saved state. This indicates if \"future\" states are available to navigate forward to."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_trace", "line_number": 1787, "body": "def _trace(self, frame, event, arg):\n        try:\n            return self._trace_and_catch(frame, event, arg)\n        except BaseException as e:\n            logger.exception(\"Exception in _trace\", exc_info=e)\n            sys.settrace(None)\n            return None", "is_method": true, "class_name": "NiceTracer", "function_description": "Acts as the core `sys.settrace` callback for the NiceTracer. It safely executes the tracing logic, catching any exceptions and disabling the tracer to prevent crashes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_trace_and_catch", "line_number": 1795, "body": "def _trace_and_catch(self, frame, event, arg):\n        \"\"\"\n        1) Detects marker calls and responds to client queries in these spots\n        2) Maintains a customized view of stack\n        \"\"\"\n        # frame skipping test should be done both in new frames and old ones (because of Resume)\n        # Note that intermediate frames can't be skipped when jumping to a breakpoint\n        # because of the need to maintain custom stack\n        if self._should_skip_frame(frame, event):\n            return None\n\n        code_name = frame.f_code.co_name\n\n        if event == \"call\":\n            self._fresh_exception = (\n                None  # some code is running, therefore exception is not fresh anymore\n            )\n\n            if code_name in self.marker_function_names:\n                self._check_store_main_frame_id(frame.f_back)\n\n                # the main thing\n                if code_name == BEFORE_STATEMENT_MARKER:\n                    event = \"before_statement\"\n                elif code_name == AFTER_STATEMENT_MARKER:\n                    event = \"after_statement\"\n                elif code_name == BEFORE_EXPRESSION_MARKER:\n                    event = \"before_expression\"\n                elif code_name == AFTER_EXPRESSION_MARKER:\n                    event = \"after_expression\"\n                else:\n                    raise AssertionError(\"Unknown marker function\")\n\n                marker_function_args = frame.f_locals.copy()\n                node = self._nodes[marker_function_args[\"node_id\"]]\n\n                del marker_function_args[\"self\"]\n\n                if \"call_function\" not in node.tags:\n                    self._handle_progress_event(frame.f_back, event, marker_function_args, node)\n                self._try_interpret_as_again_event(frame.f_back, event, marker_function_args, node)\n\n                # Don't need any more events from these frames\n                return None\n\n            else:\n                # Calls to proper functions.\n                # Client doesn't care about these events,\n                # it cares about \"before_statement\" events in the first statement of the body\n                self._custom_stack.append(CustomStackFrame(frame, \"call\"))\n\n        elif event == \"exception\":\n            # Note that Nicer can't filter out exception based on current command\n            # because it must be possible to go back and replay with different command\n            if self._is_interesting_exception(frame, arg):\n                self._fresh_exception = arg\n                self._register_affected_frame(arg[1], frame)\n\n                # Last command (step_into or step_over) produced this exception\n                # Show red after-state for this focus\n                # use the state prepared by previous event\n                last_custom_frame = self._custom_stack[-1]\n                assert last_custom_frame.system_frame == frame\n\n                # TODO: instead of producing an event here, next before_-event\n                # should create matching after event for each before event\n                # which would remain unclosed because of this exception.\n                # Existence of these after events would simplify step_over management\n\n                assert last_custom_frame.event.startswith(\"before_\")\n                pseudo_event = last_custom_frame.event.replace(\"before_\", \"after_\").replace(\n                    \"_again\", \"\"\n                )\n                # print(\"handle\", pseudo_event, {}, last_custom_frame.node)\n                self._handle_progress_event(frame, pseudo_event, {}, last_custom_frame.node)\n\n        elif event == \"return\":\n            self._fresh_exception = None\n\n            if code_name not in self.marker_function_names:\n                frame_id = id(self._custom_stack[-1].system_frame)\n                self._check_notify_return(frame_id)\n                self._custom_stack.pop()\n                if len(self._custom_stack) == 0:\n                    # We popped last frame, this means our program has ended.\n                    # There may be more events coming from upper (system) frames\n                    # but we're not interested in those\n                    sys.settrace(None)\n            else:\n                pass\n\n        else:\n            self._fresh_exception = None\n\n        return self._trace", "is_method": true, "class_name": "NiceTracer", "function_description": "Handles Python trace events to track program execution. It processes custom markers for granular progress updates and maintains a specialized call stack, enabling debugging and analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_progress_event", "line_number": 1891, "body": "def _handle_progress_event(self, frame, event, args, node):\n        self._save_current_state(frame, event, args, node)\n        self._respond_to_commands()", "is_method": true, "class_name": "NiceTracer", "function_description": "Handles an execution progress event by saving the current state. It then responds to commands, enabling interactive control or debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_save_current_state", "line_number": 1895, "body": "def _save_current_state(self, frame, event, args, node):\n        \"\"\"\n        Updates custom stack and stores the state\n\n        self._custom_stack always keeps last info,\n        which gets exported as FrameInfos to _saved_states[\"stack\"]\n        \"\"\"\n        focus = TextRange(node.lineno, node.col_offset, node.end_lineno, node.end_col_offset)\n\n        custom_frame = self._custom_stack[-1]\n        custom_frame.event = event\n        custom_frame.focus = focus\n        custom_frame.node = node\n        custom_frame.node_tags = node.tags\n\n        if self._saved_states:\n            prev_state = self._saved_states[-1]\n            prev_state_frame = self._create_actual_active_frame(prev_state)\n        else:\n            prev_state = None\n            prev_state_frame = None\n\n        # store information about current statement / expression\n        if \"statement\" in event:\n            custom_frame.current_statement = focus\n\n            if event == \"before_statement_again\":\n                # keep the expression information from last event\n                pass\n            else:\n                custom_frame.current_root_expression = None\n                custom_frame.current_evaluations = []\n        else:\n            assert \"expression\" in event\n            assert prev_state_frame is not None\n\n            # may need to update current_statement, because the parent statement was\n            # not the last one visited (eg. with test expression of a loop,\n            # starting from 2nd iteration)\n            if hasattr(node, \"parent_statement_focus\"):\n                custom_frame.current_statement = node.parent_statement_focus\n\n            # see whether current_root_expression needs to be updated\n            prev_root_expression = prev_state_frame.current_root_expression\n            if event == \"before_expression\" and (\n                id(frame) != id(prev_state_frame.system_frame)\n                or \"statement\" in prev_state_frame.event\n                or prev_root_expression\n                and not range_contains_smaller_or_equal(prev_root_expression, focus)\n            ):\n                custom_frame.current_root_expression = focus\n                custom_frame.current_evaluations = []\n\n            if event == \"after_expression\" and \"value\" in args:\n                # value is missing in case of exception\n                custom_frame.current_evaluations.append(\n                    (focus, self._backend.export_value(args[\"value\"]))\n                )\n\n        # Save the snapshot.\n        # Check if we can share something with previous state\n        if (\n            prev_state is not None\n            and id(prev_state_frame.system_frame) == id(frame)\n            and prev_state[\"exception_value\"] is self._get_current_exception()[1]\n            and prev_state[\"fresh_exception_id\"] == id(self._fresh_exception)\n            and (\"before\" in event or \"skipexport\" in node.tags)\n        ):\n\n            exception_info = prev_state[\"exception_info\"]\n            # share the stack ...\n            stack = prev_state[\"stack\"]\n            # ... but override certain things\n            active_frame_overrides = {\n                \"event\": custom_frame.event,\n                \"focus\": custom_frame.focus,\n                \"node_tags\": custom_frame.node_tags,\n                \"current_root_expression\": custom_frame.current_root_expression,\n                \"current_evaluations\": custom_frame.current_evaluations.copy(),\n                \"current_statement\": custom_frame.current_statement,\n            }\n        else:\n            # make full export\n            stack = self._export_stack()\n            exception_info = self._export_exception_info()\n            active_frame_overrides = {}\n\n        msg = {\n            \"stack\": stack,\n            \"active_frame_overrides\": active_frame_overrides,\n            \"in_client_log\": False,\n            \"io_symbol_count\": (\n                sys.stdin._processed_symbol_count\n                + sys.stdout._processed_symbol_count\n                + sys.stderr._processed_symbol_count\n            ),\n            \"exception_value\": self._get_current_exception()[1],\n            \"fresh_exception_id\": id(self._fresh_exception),\n            \"exception_info\": exception_info,\n        }\n\n        self._saved_states.append(msg)", "is_method": true, "class_name": "NiceTracer", "function_description": "This NiceTracer method captures a detailed program execution state, including stack, code focus, and evaluated expressions. It builds a historical sequence of states for debugging and analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_respond_to_commands", "line_number": 1998, "body": "def _respond_to_commands(self):\n        \"\"\"Tries to respond to client commands with states collected so far.\n        Returns if these states don't suffice anymore and Python needs\n        to advance the program\"\"\"\n\n        # while the state for current index is already saved:\n        while self._current_state_index < len(self._saved_states):\n            state = self._saved_states[self._current_state_index]\n\n            # Get current state's most recent frame (together with overrides\n            frame = self._create_actual_active_frame(state)\n\n            # Is this state meant to be seen?\n            if \"skip_\" + frame.event not in frame.node_tags:\n                # if True:\n                # Has the command completed?\n                tester = getattr(self, \"_cmd_\" + self._current_command.name + \"_completed\")\n                cmd_complete = tester(frame, self._current_command)\n\n                if cmd_complete:\n                    state[\"in_client_log\"] = True\n                    self._report_state(self._current_state_index)\n                    self._fetch_next_debugger_command(frame)\n\n            if self._current_command.name == \"step_back\":\n                if self._current_state_index == 0:\n                    # Already in first state. Remain in this loop\n                    pass\n                else:\n                    assert self._current_state_index > 0\n                    # Current event is no longer present in GUI \"undo log\"\n                    self._saved_states[self._current_state_index][\"in_client_log\"] = False\n                    self._current_state_index -= 1\n            else:\n                # Other commands move the pointer forward\n                self._current_state_index += 1", "is_method": true, "class_name": "NiceTracer", "function_description": "NiceTracer's method processes client commands by navigating through collected program states. It advances or steps back through states, reporting completed commands and fetching the next client instruction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_create_actual_active_frame", "line_number": 2035, "body": "def _create_actual_active_frame(self, state):\n        return state[\"stack\"][-1]._replace(**state[\"active_frame_overrides\"])", "is_method": true, "class_name": "NiceTracer", "function_description": "This method computes the actual active execution frame for tracing by applying specified overrides to the current frame on the stack."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_report_state", "line_number": 2038, "body": "def _report_state(self, state_index):\n        in_present = state_index == len(self._saved_states) - 1\n        if in_present:\n            # For reported new events re-export stack to make sure it is not shared.\n            # (There is tiny chance that sharing previous state\n            # after executing BinOp, Attribute, Compare or Subscript\n            # was not the right choice. See tag_nodes for more.)\n            # Re-exporting reduces the harm by showing correct data at least\n            # for present states.\n            self._saved_states[state_index][\"stack\"] = self._export_stack()\n\n        # need to make a copy for applying overrides\n        # and removing helper fields without modifying original\n        state = self._saved_states[state_index].copy()\n        state[\"stack\"] = state[\"stack\"].copy()\n\n        state[\"in_present\"] = in_present\n        if not in_present:\n            # for past states fix the newest frame\n            state[\"stack\"][-1] = self._create_actual_active_frame(state)\n\n        del state[\"exception_value\"]\n        del state[\"active_frame_overrides\"]\n\n        # Convert stack of TempFrameInfos to stack of FrameInfos\n        new_stack = []\n        self._last_reported_frame_ids = set()\n        for tframe in state[\"stack\"]:\n            system_frame = tframe.system_frame\n            module_name = system_frame.f_globals[\"__name__\"]\n            code_name = system_frame.f_code.co_name\n\n            source, firstlineno, in_library = self._backend._get_frame_source_info(system_frame)\n\n            assert firstlineno is not None, \"nofir \" + str(system_frame)\n            frame_id = id(system_frame)\n            new_stack.append(\n                FrameInfo(\n                    id=frame_id,\n                    filename=system_frame.f_code.co_filename,\n                    module_name=module_name,\n                    code_name=code_name,\n                    locals=tframe.locals,\n                    globals=tframe.globals,\n                    freevars=system_frame.f_code.co_freevars,\n                    source=source,\n                    lineno=system_frame.f_lineno,\n                    firstlineno=firstlineno,\n                    in_library=in_library,\n                    event=tframe.event,\n                    focus=tframe.focus,\n                    node_tags=tframe.node_tags,\n                    current_statement=tframe.current_statement,\n                    current_evaluations=tframe.current_evaluations,\n                    current_root_expression=tframe.current_root_expression,\n                )\n            )\n\n            self._last_reported_frame_ids.add(frame_id)\n\n        state[\"stack\"] = new_stack\n        state[\"tracer_class\"] = \"NiceTracer\"\n\n        self._backend.send_message(DebuggerResponse(**state))", "is_method": true, "class_name": "NiceTracer", "function_description": "Prepares and dispatches a detailed snapshot of a specific program execution state. It transforms internal tracing data, including call stack frames, into a structured format for debugger consumption."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_try_interpret_as_again_event", "line_number": 2103, "body": "def _try_interpret_as_again_event(self, frame, original_event, original_args, original_node):\n        \"\"\"\n        Some after_* events can be interpreted also as\n        \"before_*_again\" events (eg. when last argument of a call was\n        evaluated, then we are just before executing the final stage of the call)\n        \"\"\"\n\n        if original_event == \"after_expression\":\n            value = original_args.get(\"value\")\n\n            if (\n                \"last_child\" in original_node.tags\n                or \"or_arg\" in original_node.tags\n                and value\n                or \"and_arg\" in original_node.tags\n                and not value\n            ):\n\n                # there may be explicit exceptions\n                if (\n                    \"skip_after_statement_again\" in original_node.parent_node.tags\n                    or \"skip_after_expression_again\" in original_node.parent_node.tags\n                ):\n                    return\n\n                # next step will be finalizing evaluation of parent of current expr\n                # so let's say we're before that parent expression\n                again_args = {\"node_id\": id(original_node.parent_node)}\n                again_event = (\n                    \"before_expression_again\"\n                    if \"child_of_expression\" in original_node.tags\n                    else \"before_statement_again\"\n                )\n\n                self._handle_progress_event(\n                    frame, again_event, again_args, original_node.parent_node\n                )", "is_method": true, "class_name": "NiceTracer", "function_description": "Reinterprets certain \"after\" tracing events as \"before_again\" events, providing a more precise indication of execution flow within the tracer. This allows the tracer to mark points just before a parent expression's final evaluation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_over_completed", "line_number": 2141, "body": "def _cmd_step_over_completed(self, frame, cmd):\n        \"\"\"\n        Identifies the moment when piece of code indicated by cmd.frame_id and cmd.focus\n        has completed execution (either successfully or not).\n        \"\"\"\n\n        if self._at_a_breakpoint(frame, cmd):\n            return True\n\n        # Make sure the correct frame_id is selected\n        if id(frame.system_frame) == cmd.frame_id:\n            # We're in the same frame\n            if \"before_\" in cmd.state:\n                if not range_contains_smaller_or_equal(cmd.focus, frame.focus):\n                    # Focus has changed, command has completed\n                    return True\n                else:\n                    # Keep running\n                    return False\n            elif \"after_\" in cmd.state:\n                if (\n                    frame.focus != cmd.focus\n                    or \"before_\" in frame.event\n                    or \"_expression\" in cmd.state\n                    and \"_statement\" in frame.event\n                    or \"_statement\" in cmd.state\n                    and \"_expression\" in frame.event\n                ):\n                    # The state has changed, command has completed\n                    return True\n                else:\n                    # Keep running\n                    return False\n        else:\n            # We're in another frame\n            if self._frame_is_alive(cmd.frame_id):\n                # We're in a successor frame, keep running\n                return False\n            else:\n                # Original frame has completed, assumedly because of an exception\n                # We're done\n                return True\n\n        return True", "is_method": true, "class_name": "NiceTracer", "function_description": "Determines if a \"step over\" debugging command, tied to a specific code focus and frame, has completed. It's a core utility for managing the tracer's execution flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_into_completed", "line_number": 2186, "body": "def _cmd_step_into_completed(self, frame, cmd):\n        return frame.event != \"after_statement\"", "is_method": true, "class_name": "NiceTracer", "function_description": "Determines if a 'step into' tracing command has completed for a given frame, based on its current event, within the `NiceTracer` debugging utility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_back_completed", "line_number": 2189, "body": "def _cmd_step_back_completed(self, frame, cmd):\n        # Check if the selected message has been previously sent to front-end\n        return (\n            self._saved_states[self._current_state_index][\"in_client_log\"]\n            or self._current_state_index == 0\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "Chain of Thought:\nThe function `_cmd_step_back_completed` is a method within the `NiceTracer` class, implying a system for tracing execution or states.\nIt checks two conditions:\n1. `self._saved_states[self._current_state_index][\"in_client_log\"]`: This suggests it's checking if the current state, identified by `_current_state_index` within `_saved_states`, has already been logged or sent to a client.\n2. `self._current_state_index == 0`: This checks if the current state is the very first state.\nThe name `_cmd_step_back_completed` strongly hints that this function validates whether a 'step back' command (likely in a debugger or tracer) is valid or has reached a 'completed' (i.e., previously processed or initial) state.\n\nThe core service provided is to determine if a state, typically reached after a 'step back' operation, has already been processed or if it's the starting point. This prevents redundant operations or invalid navigation in a tracing system.\n\nDescription: Determines if the current tracing state has already been logged to the client or if it's the initial state, typically to validate a 'step back' operation.\nDetermines if the current tracing state has already been logged to the client or if it's the initial state, typically to validate a 'step back' operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_step_out_completed", "line_number": 2196, "body": "def _cmd_step_out_completed(self, frame, cmd):\n        if self._current_state_index == 0:\n            return False\n\n        if frame.event == \"after_statement\":\n            return False\n\n        if self._at_a_breakpoint(frame, cmd):\n            return True\n\n        prev_state_frame = self._saved_states[self._current_state_index - 1][\"stack\"][-1]\n\n        return (\n            # the frame has completed\n            not self._frame_is_alive(cmd.frame_id)\n            # we're in the same frame but on higher level\n            # TODO: expression inside statement expression has same range as its parent\n            or id(frame.system_frame) == cmd.frame_id\n            and range_contains_smaller(frame.focus, cmd.focus)\n            # or we were there in prev state\n            or id(prev_state_frame.system_frame) == cmd.frame_id\n            and range_contains_smaller(prev_state_frame.focus, cmd.focus)\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "Determines if a 'step out' command has completed its execution within the NiceTracer's debugging environment. It evaluates frame state, event progression, and breakpoint encounters."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_cmd_resume_completed", "line_number": 2220, "body": "def _cmd_resume_completed(self, frame, cmd):\n        return self._at_a_breakpoint(frame, cmd)", "is_method": true, "class_name": "NiceTracer", "function_description": "Checks if the program execution has stopped at a breakpoint after a 'resume' command has completed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_at_a_breakpoint", "line_number": 2223, "body": "def _at_a_breakpoint(self, frame, cmd, breakpoints=None):\n        if breakpoints is None:\n            breakpoints = cmd[\"breakpoints\"]\n\n        return (\n            frame.event in [\"before_statement\", \"before_expression\"]\n            and frame.system_frame.f_code.co_filename in breakpoints\n            and frame.focus.lineno in breakpoints[frame.system_frame.f_code.co_filename]\n            # consider only first event on a line\n            # (but take into account that same line may be reentered)\n            and (\n                cmd.focus is None\n                or (cmd.focus.lineno != frame.focus.lineno)\n                or (cmd.focus == frame.focus and cmd.state == frame.event)\n                or id(frame.system_frame) != cmd.frame_id\n            )\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "Within `NiceTracer`, this internal method determines if the current execution frame matches an active breakpoint. It intelligently handles re-entries to avoid duplicate triggers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_frame_is_alive", "line_number": 2241, "body": "def _frame_is_alive(self, frame_id):\n        for frame in self._custom_stack:\n            if id(frame.system_frame) == frame_id:\n                return True\n\n        return False", "is_method": true, "class_name": "NiceTracer", "function_description": "It determines if a given frame ID corresponds to an active frame within the tracer's custom stack."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_export_stack", "line_number": 2248, "body": "def _export_stack(self):\n        result = []\n\n        exported_globals_per_module = {}\n\n        def export_globals(module_name, frame):\n            if module_name not in exported_globals_per_module:\n                exported_globals_per_module[module_name] = self._backend.export_variables(\n                    frame.f_globals\n                )\n            return exported_globals_per_module[module_name]\n\n        for custom_frame in self._custom_stack:\n            system_frame = custom_frame.system_frame\n            module_name = system_frame.f_globals[\"__name__\"]\n\n            result.append(\n                TempFrameInfo(\n                    # need to store the reference to the frame to avoid it being GC-d\n                    # otherwise frame id-s would be reused and this would\n                    # mess up communication with the frontend.\n                    system_frame=system_frame,\n                    locals=None\n                    if system_frame.f_locals is system_frame.f_globals\n                    else self._backend.export_variables(system_frame.f_locals),\n                    globals=export_globals(module_name, system_frame),\n                    event=custom_frame.event,\n                    focus=custom_frame.focus,\n                    node_tags=custom_frame.node_tags,\n                    current_evaluations=custom_frame.current_evaluations.copy(),\n                    current_statement=custom_frame.current_statement,\n                    current_root_expression=custom_frame.current_root_expression,\n                )\n            )\n\n        assert result  # not empty\n        return result", "is_method": true, "class_name": "NiceTracer", "function_description": "Provides a structured, exportable representation of the current custom execution stack. It serializes detailed frame information, including local and global variables, for tracing or visualization purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_thonny_hidden_before_stmt", "line_number": 2286, "body": "def _thonny_hidden_before_stmt(self, node_id):\n        # The code to be debugged will be instrumented with this function\n        # inserted before each statement.\n        # Entry into this function indicates that statement as given\n        # by the code range is about to be evaluated next.\n        return None", "is_method": true, "class_name": "NiceTracer", "function_description": "Provides an internal hook for the Thonny debugger, indicating that a specific statement is about to be executed. It enables statement-level code tracing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_thonny_hidden_after_stmt", "line_number": 2293, "body": "def _thonny_hidden_after_stmt(self, node_id):\n        # The code to be debugged will be instrumented with this function\n        # inserted after each statement.\n        # Entry into this function indicates that statement as given\n        # by the code range was just executed successfully.\n        return None", "is_method": true, "class_name": "NiceTracer", "function_description": "This method is a core component of a debugger's tracing mechanism. It is inserted after each statement in instrumented code to signal successful execution to the tracer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_thonny_hidden_before_expr", "line_number": 2300, "body": "def _thonny_hidden_before_expr(self, node_id):\n        # Entry into this function indicates that expression as given\n        # by the code range is about to be evaluated next\n        return node_id", "is_method": true, "class_name": "NiceTracer", "function_description": "This method from `NiceTracer` serves as a programmatic hook, signaling that a specific code expression is about to be evaluated. It enables tracing tools to observe or log execution flow before expression evaluation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_thonny_hidden_after_expr", "line_number": 2305, "body": "def _thonny_hidden_after_expr(self, node_id, value):\n        # The code to be debugged will be instrumented with this function\n        # wrapped around each expression (given as 2nd argument).\n        # Entry into this function indicates that expression as given\n        # by the code range was just evaluated to given value\n        return value", "is_method": true, "class_name": "NiceTracer", "function_description": "Provides an internal debugging hook for the Thonny tracer. It signals that an expression has just been evaluated and returns its value."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_tag_nodes", "line_number": 2312, "body": "def _tag_nodes(self, root):\n        \"\"\"Marks interesting properties of AST nodes\"\"\"\n        # ast_utils need to be imported after asttokens\n        # is (custom-)imported\n        try_load_modules_with_frontend_sys_path([\"asttokens\", \"six\", \"astroid\"])\n        from thonny import ast_utils\n\n        def add_tag(node, tag):\n            if not hasattr(node, \"tags\"):\n                node.tags = set()\n                node.tags.add(\"class=\" + node.__class__.__name__)\n            node.tags.add(tag)\n\n        # ignore module docstring if it is before from __future__ import\n        if (\n            isinstance(root.body[0], ast.Expr)\n            and isinstance(root.body[0].value, ast.Str)\n            and len(root.body) > 1\n            and isinstance(root.body[1], ast.ImportFrom)\n            and root.body[1].module == \"__future__\"\n        ):\n            add_tag(root.body[0], \"ignore\")\n            add_tag(root.body[0].value, \"ignore\")\n            add_tag(root.body[1], \"ignore\")\n\n        for node in ast.walk(root):\n            if not isinstance(node, (ast.expr, ast.stmt)):\n                if isinstance(node, ast.comprehension):\n                    for expr in node.ifs:\n                        add_tag(expr, \"comprehension.if\")\n\n                continue\n\n            # tag last children\n            last_child = ast_utils.get_last_child(node)\n            assert last_child in [True, False, None] or isinstance(\n                last_child, (ast.expr, ast.stmt, type(None))\n            ), (\"Bad last child \" + str(last_child) + \" of \" + str(node))\n            if last_child is not None:\n                add_tag(node, \"has_children\")\n\n                if isinstance(last_child, ast.AST):\n                    last_child.parent_node = node\n                    add_tag(last_child, \"last_child\")\n                    if isinstance(node, _ast.expr):\n                        add_tag(last_child, \"child_of_expression\")\n                    else:\n                        add_tag(last_child, \"child_of_statement\")\n\n                    if isinstance(node, ast.Call):\n                        add_tag(last_child, \"last_call_arg\")\n\n            # other cases\n            if isinstance(node, ast.Call):\n                add_tag(node.func, \"call_function\")\n                node.func.parent_node = node\n\n            if isinstance(node, ast.BoolOp) and node.op == ast.Or():\n                for child in node.values:\n                    add_tag(child, \"or_arg\")\n                    child.parent_node = node\n\n            if isinstance(node, ast.BoolOp) and node.op == ast.And():\n                for child in node.values:\n                    add_tag(child, \"and_arg\")\n                    child.parent_node = node\n\n            # TODO: assert (it doesn't evaluate msg when test == True)\n\n            if isinstance(node, ast.stmt):\n                for child in ast.iter_child_nodes(node):\n                    child.parent_node = node\n                    child.parent_statement_focus = TextRange(\n                        node.lineno, node.col_offset, node.end_lineno, node.end_col_offset\n                    )\n\n            if isinstance(node, ast.Str):\n                add_tag(node, \"skipexport\")\n\n            if hasattr(ast, \"JoinedStr\") and isinstance(node, ast.JoinedStr):\n                # can't present children normally without\n                # ast giving correct locations for them\n                # https://bugs.python.org/issue29051\n                add_tag(node, \"ignore_children\")\n\n            elif isinstance(node, ast.Num):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.List):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Tuple):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Set):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Dict):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Name):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.NameConstant):\n                add_tag(node, \"skipexport\")\n\n            elif hasattr(ast, \"Constant\") and isinstance(node, ast.Constant):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Expr):\n                if not isinstance(node.value, (ast.Yield, ast.YieldFrom)):\n                    add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.If):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Return):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.While):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Continue):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Break):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Pass):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.For):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Try):\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.ListComp):\n                add_tag(node.elt, \"ListComp.elt\")\n                if len(node.generators) > 1:\n                    add_tag(node, \"ignore_children\")\n\n            elif isinstance(node, ast.SetComp):\n                add_tag(node.elt, \"SetComp.elt\")\n                if len(node.generators) > 1:\n                    add_tag(node, \"ignore_children\")\n\n            elif isinstance(node, ast.DictComp):\n                add_tag(node.key, \"DictComp.key\")\n                add_tag(node.value, \"DictComp.value\")\n                if len(node.generators) > 1:\n                    add_tag(node, \"ignore_children\")\n\n            elif isinstance(node, ast.BinOp):\n                # TODO: use static analysis to detect type of left child\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Attribute):\n                # TODO: use static analysis to detect type of left child\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Subscript):\n                # TODO: use static analysis to detect type of left child\n                add_tag(node, \"skipexport\")\n\n            elif isinstance(node, ast.Compare):\n                # TODO: use static analysis to detect type of left child\n                add_tag(node, \"skipexport\")\n\n            if isinstance(node, (ast.Assign)):\n                # value will be presented in assignment's before_statement_again\n                add_tag(node.value, \"skip_after_expression\")\n\n            if isinstance(node, (ast.Expr, ast.While, ast.For, ast.If, ast.Try, ast.With)):\n                add_tag(node, \"skip_after_statement_again\")\n\n            # make sure every node has this field\n            if not hasattr(node, \"tags\"):\n                node.tags = set()", "is_method": true, "class_name": "NiceTracer", "function_description": "Annotates each Abstract Syntax Tree (AST) node with contextual tags describing its type, role, and special properties. This enriches nodes with metadata for code tracing or analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_should_instrument_as_expression", "line_number": 2492, "body": "def _should_instrument_as_expression(self, node):\n        return (\n            isinstance(node, _ast.expr)\n            and hasattr(node, \"end_lineno\")\n            and hasattr(node, \"end_col_offset\")\n            and not getattr(node, \"incorrect_range\", False)\n            and \"ignore\" not in node.tags\n            and (not hasattr(node, \"ctx\") or isinstance(node.ctx, ast.Load))\n            # TODO: repeatedly evaluated subexpressions of comprehensions\n            # can be supported (but it requires some redesign both in backend and GUI)\n            and \"ListComp.elt\" not in node.tags\n            and \"SetComp.elt\" not in node.tags\n            and \"DictComp.key\" not in node.tags\n            and \"DictComp.value\" not in node.tags\n            and \"comprehension.if\" not in node.tags\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "Determines if a given Abstract Syntax Tree (AST) expression node should be instrumented by the tracer for dynamic code analysis and execution tracking."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_should_instrument_as_statement", "line_number": 2509, "body": "def _should_instrument_as_statement(self, node):\n        return (\n            isinstance(node, _ast.stmt)\n            and not getattr(node, \"incorrect_range\", False)\n            and \"ignore\" not in node.tags\n            # Shouldn't insert anything before from __future__ import\n            # as this is not a normal statement\n            # https://bitbucket.org/plas/thonny/issues/183/thonny-throws-false-positive-syntaxerror\n            and (not isinstance(node, ast.ImportFrom) or node.module != \"__future__\")\n        )", "is_method": true, "class_name": "NiceTracer", "function_description": "This method determines if an Abstract Syntax Tree (AST) node should be instrumented as a regular statement. It filters out special cases like future imports, ignored, or malformed nodes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_insert_statement_markers", "line_number": 2520, "body": "def _insert_statement_markers(self, root):\n        # find lists of statements and insert before/after markers for each statement\n        for name, value in ast.iter_fields(root):\n            if isinstance(root, ast.Try) and name == \"handlers\":\n                # contains statements but is not statement itself\n                for handler in value:\n                    self._insert_statement_markers(handler)\n            elif isinstance(value, ast.AST):\n                self._insert_statement_markers(value)\n            elif isinstance(value, list):\n                if len(value) > 0:\n                    new_list = []\n                    for node in value:\n                        if self._should_instrument_as_statement(node):\n                            # self._debug(\"EBFOMA\", node)\n                            # add before marker\n                            new_list.append(\n                                self._create_statement_marker(node, BEFORE_STATEMENT_MARKER)\n                            )\n\n                        # original statement\n                        if self._should_instrument_as_statement(node):\n                            self._insert_statement_markers(node)\n                        new_list.append(node)\n\n                        if (\n                            self._should_instrument_as_statement(node)\n                            and \"skipexport\" not in node.tags\n                        ):\n                            # add after marker\n                            new_list.append(\n                                self._create_statement_marker(node, AFTER_STATEMENT_MARKER)\n                            )\n                    setattr(root, name, new_list)", "is_method": true, "class_name": "NiceTracer", "function_description": "Recursively modifies an Abstract Syntax Tree (AST) to insert special markers around statements. This enables the NiceTracer to track and report detailed code execution flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_create_statement_marker", "line_number": 2555, "body": "def _create_statement_marker(self, node, function_name):\n        call = self._create_simple_marker_call(node, function_name)\n        stmt = ast.Expr(value=call)\n        ast.copy_location(stmt, node)\n        ast.fix_missing_locations(stmt)\n        return stmt", "is_method": true, "class_name": "NiceTracer", "function_description": "Constructs an Abstract Syntax Tree (AST) statement representing a marker function call. This facilitates code instrumentation for tracing or debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_insert_for_target_markers", "line_number": 2562, "body": "def _insert_for_target_markers(self, root):\n        \"\"\"inserts markers which notify assignment to for-loop variables\"\"\"\n        for node in ast.walk(root):\n            if isinstance(node, ast.For):\n                old_target = node.target\n                # print(vars(old_target))\n                temp_name = \"__for_loop_var\"\n                node.target = ast.Name(temp_name, ast.Store())\n\n                name_load = ast.Name(temp_name, ast.Load())\n                # value will be visible in parent's before_statement_again event\n                name_load.tags = {\"skip_before_expression\", \"skip_after_expression\", \"last_child\"}\n                name_load.lineno, name_load.col_offset = (node.iter.lineno, node.iter.col_offset)\n                name_load.end_lineno, name_load.end_col_offset = (\n                    node.iter.end_lineno,\n                    node.iter.end_col_offset,\n                )\n\n                before_name_load = self._create_simple_marker_call(\n                    name_load, BEFORE_EXPRESSION_MARKER\n                )\n                after_name_load = ast.Call(\n                    func=ast.Name(id=AFTER_EXPRESSION_MARKER, ctx=ast.Load()),\n                    args=[before_name_load, name_load],\n                    keywords=[],\n                )\n\n                ass = ast.Assign([old_target], after_name_load)\n                ass.lineno, ass.col_offset = old_target.lineno, old_target.col_offset\n                ass.end_lineno, ass.end_col_offset = (\n                    node.iter.end_lineno,\n                    node.iter.end_col_offset,\n                )\n                ass.tags = {\"skip_before_statement\"}  # before_statement_again will be shown\n\n                name_load.parent_node = ass\n\n                ass_before = self._create_statement_marker(ass, BEFORE_STATEMENT_MARKER)\n                node.body.insert(0, ass_before)\n                node.body.insert(1, ass)\n                node.body.insert(2, self._create_statement_marker(ass, AFTER_STATEMENT_MARKER))\n\n                ast.fix_missing_locations(node)", "is_method": true, "class_name": "NiceTracer", "function_description": "This method modifies the Abstract Syntax Tree (AST) to instrument `for`-loop variable assignments with tracing markers. This allows the NiceTracer to monitor and report on loop variable values during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_insert_expression_markers", "line_number": 2606, "body": "def _insert_expression_markers(self, node):\n        \"\"\"\n        TODO: this docstring is outdated\n        each expression e gets wrapped like this:\n            _after(_before(_loc, _node_is_zoomable), e, _node_role, _parent_range)\n        where\n            _after is function that gives the resulting value\n            _before is function that signals the beginning of evaluation of e\n            _loc gives the code range of e\n            _node_is_zoomable indicates whether this node has subexpressions\n            _node_role is either 'last_call_arg', 'last_op_arg', 'first_or_arg',\n                                 'first_and_arg', 'function' or None\n        \"\"\"\n        tracer = self\n\n        class ExpressionVisitor(ast.NodeTransformer):\n            def generic_visit(self, node):\n                if isinstance(node, _ast.expr):\n                    if isinstance(node, ast.Starred):\n                        # keep this node as is, but instrument its children\n                        return ast.NodeTransformer.generic_visit(self, node)\n                    elif tracer._should_instrument_as_expression(node):\n                        # before marker\n                        before_marker = tracer._create_simple_marker_call(\n                            node, BEFORE_EXPRESSION_MARKER\n                        )\n                        ast.copy_location(before_marker, node)\n\n                        if \"ignore_children\" in node.tags:\n                            transformed_node = node\n                        else:\n                            transformed_node = ast.NodeTransformer.generic_visit(self, node)\n\n                        # after marker\n                        after_marker = ast.Call(\n                            func=ast.Name(id=AFTER_EXPRESSION_MARKER, ctx=ast.Load()),\n                            args=[before_marker, transformed_node],\n                            keywords=[],\n                        )\n                        ast.copy_location(after_marker, node)\n                        ast.fix_missing_locations(after_marker)\n                        # further transformations may query original node location from after marker\n                        if hasattr(node, \"end_lineno\"):\n                            after_marker.end_lineno = node.end_lineno\n                            after_marker.end_col_offset = node.end_col_offset\n\n                        return after_marker\n                    else:\n                        # This expression (and its children) should be ignored\n                        return node\n                else:\n                    # Descend into statements\n                    return ast.NodeTransformer.generic_visit(self, node)\n\n        return ExpressionVisitor().visit(node)", "is_method": true, "class_name": "NiceTracer", "function_description": "This private method transforms a given Abstract Syntax Tree (AST). It wraps each expression with distinct \"before\" and \"after\" marker calls for detailed execution tracing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_create_simple_marker_call", "line_number": 2662, "body": "def _create_simple_marker_call(self, node, fun_name, extra_args=[]):\n        args = [self._export_node(node)] + extra_args\n\n        return ast.Call(func=ast.Name(id=fun_name, ctx=ast.Load()), args=args, keywords=[])", "is_method": true, "class_name": "NiceTracer", "function_description": "It generates an Abstract Syntax Tree (AST) node representing a function call. This internal helper facilitates injecting marker or tracing calls, where the first argument describes an AST node."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_export_node", "line_number": 2667, "body": "def _export_node(self, node):\n        assert isinstance(node, (ast.expr, ast.stmt))\n        node_id = id(node)\n        self._nodes[node_id] = node\n        return ast.Num(node_id)", "is_method": true, "class_name": "NiceTracer", "function_description": "Registers an Abstract Syntax Tree (AST) node internally for tracking. It returns an AST node representing the registered node's unique identifier."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_debug", "line_number": 2673, "body": "def _debug(self, *args):\n        logger.debug(\"TRACER: \" + str(args))", "is_method": true, "class_name": "NiceTracer", "function_description": "This private method logs debug messages, prefixed with 'TRACER:', for internal diagnostic tracing within the NiceTracer class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_execute_prepared_user_code", "line_number": 2676, "body": "def _execute_prepared_user_code(self, statements, global_vars):\n        try:\n            return Tracer._execute_prepared_user_code(self, statements, global_vars)\n        finally:\n            \"\"\"\n            from thonny.misc_utils import _win_get_used_memory\n            print(\"Memory:\", _win_get_used_memory() / 1024 / 1024)\n            print(\"States:\", len(self._saved_states))\n            print(self._fulltags.most_common())\n            \"\"\"", "is_method": true, "class_name": "NiceTracer", "function_description": "Executes prepared user code by delegating to the base tracer. It provides a critical hook for the NiceTracer to perform post-execution analysis or monitoring."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "source_to_code", "line_number": 2706, "body": "def source_to_code(self, data, path, *, _optimize=-1):\n        old_tracer = sys.gettrace()\n        sys.settrace(None)\n        try:\n            root = self._tracer._prepare_ast(data, path, \"exec\")\n            return super().source_to_code(root, path)\n        finally:\n            sys.settrace(old_tracer)", "is_method": true, "class_name": "FancySourceFileLoader", "function_description": "Converts source code into an executable code object. It prepares the Abstract Syntax Tree while temporarily disabling system tracing for controlled processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "rec_format_exception_with_frame_info", "line_number": 2772, "body": "def rec_format_exception_with_frame_info(etype, value, tb, chain=True):\n        # Based on\n        # https://www.python.org/dev/peps/pep-3134/#enhanced-reporting\n        # and traceback.format_exception\n\n        if etype is None:\n            etype = type(value)\n\n        if tb is None:\n            tb = value.__traceback__\n\n        if chain:\n            if value.__cause__ is not None:\n                yield from rec_format_exception_with_frame_info(None, value.__cause__, None)\n                yield (_cause_message, None, None, None)\n            elif value.__context__ is not None and not value.__suppress_context__:\n                yield from rec_format_exception_with_frame_info(None, value.__context__, None)\n                yield (_context_message, None, None, None)\n\n        if tb is not None:\n            yield (_traceback_message, None, None, None)\n\n            tb_temp = tb\n            for entry in traceback.extract_tb(tb):\n                assert tb_temp is not None  # actual tb doesn't end before extract_tb\n                if (\n                    \"cpython_backend\" not in entry.filename\n                    and \"thonny/backend\" not in entry.filename.replace(\"\\\\\", \"/\")\n                    and (\n                        not entry.filename.endswith(os.sep + \"ast.py\")\n                        or entry.name != \"parse\"\n                        or etype is not SyntaxError\n                    )\n                ):\n                    fmt = '  File \"{}\", line {}, in {}\\n'.format(\n                        entry.filename, entry.lineno, entry.name\n                    )\n\n                    if entry.line:\n                        fmt += \"    {}\\n\".format(entry.line.strip())\n\n                    yield (fmt, id(tb_temp.tb_frame), entry.filename, entry.lineno)\n\n                tb_temp = tb_temp.tb_next\n\n            assert tb_temp is None  # tb was exhausted\n\n        for line in traceback.format_exception_only(etype, value):\n            if etype is SyntaxError and line.endswith(\"^\\n\"):\n                # for some reason it may add several empty lines before ^-line\n                partlines = line.splitlines()\n                while len(partlines) >= 2 and partlines[-2].strip() == \"\":\n                    del partlines[-2]\n                line = \"\\n\".join(partlines) + \"\\n\"\n\n            yield (line, None, None, None)", "is_method": false, "function_description": "Generates a formatted exception traceback, including detailed frame information and handling exception chaining. It filters out internal stack frames for clearer user display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "signal_handler", "line_number": 162, "body": "def signal_handler(signal_, frame):\n            raise KeyboardInterrupt(\"Execution interrupted\")", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This signal handler for `MainCPythonBackend` translates a received system signal into a `KeyboardInterrupt` exception. It provides a standard way to gracefully interrupt Python execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "_handle_repl_value", "line_number": 874, "body": "def _handle_repl_value(obj):\n            if obj is not None:\n                try:\n                    obj_repr = repr(obj)\n                    if len(obj_repr) > 5000:\n                        obj_repr = obj_repr[:5000] + \"\u2026\"\n                except Exception as e:\n                    obj_repr = \"<repr error: \" + str(e) + \">\"\n                print(OBJECT_LINK_START % id(obj), obj_repr, OBJECT_LINK_END, sep=\"\")\n                self._heap[id(obj)] = obj\n                builtins._ = obj", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "This method processes and displays the result of a REPL expression. It generates its string representation, prints it with object links, and stores it for subsequent access via `builtins._` and internal management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "lookup_from_stack", "line_number": 1015, "body": "def lookup_from_stack(frame):\n            if frame is None:\n                return None\n            elif id(frame) == frame_id:\n                return frame\n            else:\n                return lookup_from_stack(frame.f_back)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Navigates the Python call stack backward from a given frame to find and return a specific execution frame identified by its unique ID."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "lookup_from_tb", "line_number": 1023, "body": "def lookup_from_tb(entry):\n            if entry is None:\n                return None\n            elif id(entry.tb_frame) == frame_id:\n                return entry.tb_frame\n            else:\n                return lookup_from_tb(entry.tb_next)", "is_method": true, "class_name": "MainCPythonBackend", "function_description": "Recursively navigates a traceback chain to locate a specific stack frame. It serves to retrieve a particular execution context for CPython backend operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "export_globals", "line_number": 2253, "body": "def export_globals(module_name, frame):\n            if module_name not in exported_globals_per_module:\n                exported_globals_per_module[module_name] = self._backend.export_variables(\n                    frame.f_globals\n                )\n            return exported_globals_per_module[module_name]", "is_method": true, "class_name": "NiceTracer", "function_description": "Exports and caches a module's global variables via the tracer's backend, providing a cached snapshot of its state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "add_tag", "line_number": 2319, "body": "def add_tag(node, tag):\n            if not hasattr(node, \"tags\"):\n                node.tags = set()\n                node.tags.add(\"class=\" + node.__class__.__name__)\n            node.tags.add(tag)", "is_method": true, "class_name": "NiceTracer", "function_description": "Adds a tag to a given node, initializing the node's tag set with its class name if it doesn't exist. This method enables attaching descriptive metadata to trace elements for categorization or analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/cpython_backend.py", "function": "generic_visit", "line_number": 2622, "body": "def generic_visit(self, node):\n                if isinstance(node, _ast.expr):\n                    if isinstance(node, ast.Starred):\n                        # keep this node as is, but instrument its children\n                        return ast.NodeTransformer.generic_visit(self, node)\n                    elif tracer._should_instrument_as_expression(node):\n                        # before marker\n                        before_marker = tracer._create_simple_marker_call(\n                            node, BEFORE_EXPRESSION_MARKER\n                        )\n                        ast.copy_location(before_marker, node)\n\n                        if \"ignore_children\" in node.tags:\n                            transformed_node = node\n                        else:\n                            transformed_node = ast.NodeTransformer.generic_visit(self, node)\n\n                        # after marker\n                        after_marker = ast.Call(\n                            func=ast.Name(id=AFTER_EXPRESSION_MARKER, ctx=ast.Load()),\n                            args=[before_marker, transformed_node],\n                            keywords=[],\n                        )\n                        ast.copy_location(after_marker, node)\n                        ast.fix_missing_locations(after_marker)\n                        # further transformations may query original node location from after marker\n                        if hasattr(node, \"end_lineno\"):\n                            after_marker.end_lineno = node.end_lineno\n                            after_marker.end_col_offset = node.end_col_offset\n\n                        return after_marker\n                    else:\n                        # This expression (and its children) should be ignored\n                        return node\n                else:\n                    # Descend into statements\n                    return ast.NodeTransformer.generic_visit(self, node)", "is_method": true, "class_name": "ExpressionVisitor", "function_description": "The `generic_visit` method of `ExpressionVisitor` transforms an Abstract Syntax Tree (AST) by injecting instrumentation points around specific expression nodes. This enables dynamic analysis, tracing, or profiling of expression evaluation during program execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_private_venv_path", "line_number": 304, "body": "def get_private_venv_path():\n    if is_bundled_python(sys.executable.lower()):\n        prefix = \"BundledPython\"\n    else:\n        prefix = \"Python\"\n    return os.path.join(\n        THONNY_USER_DIR, prefix + \"%d%d\" % (sys.version_info[0], sys.version_info[1])\n    )", "is_method": false, "function_description": "Calculates the specific path for a private virtual environment within the Thonny user directory. This path is unique to the current Python version, enabling isolated environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_private_venv_executable", "line_number": 314, "body": "def get_private_venv_executable():\n    venv_path = get_private_venv_path()\n\n    if running_on_windows():\n        exe = os.path.join(venv_path, \"Scripts\", WINDOWS_EXE)\n    else:\n        exe = os.path.join(venv_path, \"bin\", \"python3\")\n\n    return exe", "is_method": false, "function_description": "Provides the full path to the Python executable within a private virtual environment. It adapts for the operating system to ensure correct execution within that isolated environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_venv_info", "line_number": 325, "body": "def _get_venv_info(venv_path):\n    cfg_path = os.path.join(venv_path, \"pyvenv.cfg\")\n    result = {}\n\n    with open(cfg_path, encoding=\"UTF-8\") as fp:\n        for line in fp:\n            if \"=\" in line:\n                key, val = line.split(\"=\", maxsplit=1)\n                result[key.strip()] = val.strip()\n\n    return result", "is_method": false, "function_description": "Provides configuration details of a Python virtual environment by parsing its `pyvenv.cfg` file. It returns these details as a dictionary of key-value pairs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_interpreters", "line_number": 498, "body": "def _get_interpreters():\n    result = set()\n\n    if running_on_windows():\n        # registry\n        result.update(_get_interpreters_from_windows_registry())\n\n        for minor in [6, 7, 8, 9, 10]:\n            for dir_ in [\n                \"C:\\\\Python3%d\" % minor,\n                \"C:\\\\Python3%d-32\" % minor,\n                \"C:\\\\Python3%d-64\" % minor,\n                \"C:\\\\Program Files\\\\Python 3.%d\" % minor,\n                \"C:\\\\Program Files\\\\Python 3.%d-64\" % minor,\n                \"C:\\\\Program Files (x86)\\\\Python 3.%d\" % minor,\n                \"C:\\\\Program Files (x86)\\\\Python 3.%d-32\" % minor,\n                \"C:\\\\Program Files (x86)\\\\Python 3.%d-32\" % minor,\n                os.path.expanduser(\"~\\\\AppData\\Local\\Programs\\Python\\Python3%d\" % minor),\n                os.path.expanduser(\"~\\\\AppData\\Local\\Programs\\Python\\Python3%d-32\" % minor),\n            ]:\n                path = os.path.join(dir_, WINDOWS_EXE)\n                if os.path.exists(path):\n                    result.add(normpath_with_actual_case(path))\n\n        # other locations\n        for dir_ in [\n            \"C:\\\\Anaconda3\",\n            \"C:\\\\ProgramData\\\\Anaconda3\",\n            os.path.expanduser(\"~\\\\Anaconda3\"),\n        ]:\n            path = os.path.join(dir_, WINDOWS_EXE)\n            if os.path.exists(path):\n                result.add(normpath_with_actual_case(path))\n\n    else:\n        # Common unix locations\n        dirs = [\n            \"/bin\",\n            \"/usr/bin\",\n            \"/usr/local/bin\",\n            os.path.expanduser(\"~/.local/bin\"),\n            os.path.expanduser(\"~/anaconda3/bin\"),\n        ]\n        for dir_ in dirs:\n            # if the dir_ is just a link to another dir_, skip it\n            # (not to show items twice)\n            # for example on Fedora /bin -> usr/bin\n            if not os.path.exists(dir_):\n                continue\n\n            apath = normpath_with_actual_case(dir_)\n            if apath != dir_ and apath in dirs:\n                continue\n            for name in [\"python3\", \"python3.5\", \"python3.6\", \"python3.7\", \"python3.8\"]:\n                path = os.path.join(dir_, name)\n                if os.path.exists(path):\n                    result.add(path)\n\n    if running_on_mac_os():\n        for version in [\"3.6\", \"3.7\", \"3.8\", \"3.9\"]:\n            dir_ = os.path.join(\"/Library/Frameworks/Python.framework/Versions\", version, \"bin\")\n            path = os.path.join(dir_, \"python3\")\n\n            if os.path.exists(path):\n                result.add(path)\n\n    from shutil import which\n\n    for command in [\"python3\", \"python3.6\", \"python3.7\", \"python3.8\", \"python3.9\"]:\n        path = which(command)\n        if path is not None and os.path.isabs(path):\n            result.add(path)\n\n    for path in get_workbench().get_option(\"CustomInterpreter.used_paths\"):\n        if os.path.exists(path):\n            result.add(normpath_with_actual_case(path))\n\n    return sorted(result)", "is_method": false, "function_description": "Discovers and collects paths to all Python interpreter executables found on the system. It aggregates locations from common installation directories, system PATH, and user configurations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_interpreters_from_windows_registry", "line_number": 578, "body": "def _get_interpreters_from_windows_registry():\n    # https://github.com/python/cpython/blob/master/Tools/msi/README.txt\n    # https://www.python.org/dev/peps/pep-0514/#installpath\n    import winreg\n\n    result = set()\n    for key in [winreg.HKEY_LOCAL_MACHINE, winreg.HKEY_CURRENT_USER]:\n        for version in [\n            \"3.6\",\n            \"3.6-32\",\n            \"3.6-64\",\n            \"3.7\",\n            \"3.7-32\",\n            \"3.7-64\",\n            \"3.8\",\n            \"3.8-32\",\n            \"3.8-64\",\n            \"3.9\",\n            \"3.9-32\",\n            \"3.9-64\",\n            \"3.10\",\n            \"3.10-32\",\n            \"3.10-64\",\n        ]:\n            for subkey in [\n                \"SOFTWARE\\\\Python\\\\PythonCore\\\\\" + version + \"\\\\InstallPath\",\n                \"SOFTWARE\\\\Python\\\\PythonCore\\\\Wow6432Node\\\\\" + version + \"\\\\InstallPath\",\n            ]:\n                try:\n                    dir_ = winreg.QueryValue(key, subkey)\n                    if dir_:\n                        path = os.path.join(dir_, WINDOWS_EXE)\n                        if os.path.exists(path):\n                            result.add(path)\n                except Exception:\n                    pass\n\n    return result", "is_method": false, "function_description": "This function discovers installed Python interpreters on a Windows system. It queries both local machine and current user registry hives for common Python installation paths to return valid executable locations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_check_venv_installed", "line_number": 618, "body": "def _check_venv_installed(parent):\n    try:\n        import venv\n\n        return True\n    except ImportError:\n        messagebox.showerror(\"Error\", \"Package 'venv' is not available.\", parent=parent)\n        return False", "is_method": false, "function_description": "Checks if the standard 'venv' module is importable, returning true if available. Displays an error message via a parent GUI element if 'venv' is not found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "load_plugin", "line_number": 628, "body": "def load_plugin():\n    wb = get_workbench()\n    wb.set_default(\"run.backend_name\", \"SameAsFrontend\")\n    wb.set_default(\"CustomInterpreter.used_paths\", [])\n    wb.set_default(\"CustomInterpreter.path\", \"\")\n\n    wb.add_backend(\n        \"SameAsFrontend\",\n        SameAsFrontendCPythonProxy,\n        tr(\"The same interpreter which runs Thonny (default)\"),\n        SameAsFrontEndConfigurationPage,\n        \"01\",\n    )\n\n    wb.add_backend(\n        \"CustomCPython\",\n        CustomCPythonProxy,\n        tr(\"Alternative Python 3 interpreter or virtual environment\"),\n        CustomCPythonConfigurationPage,\n        \"02\",\n    )\n\n    wb.add_backend(\n        \"PrivateVenv\",\n        PrivateVenvCPythonProxy,\n        tr(\"A special virtual environment (deprecated)\"),\n        PrivateVenvConfigurationPage,\n        \"zz\",\n    )", "is_method": false, "function_description": "Registers various Python interpreter backends and their default configurations with the application's workbench. It enables users to select different execution environments for their code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_initial_cwd", "line_number": 41, "body": "def _get_initial_cwd(self):\n        return get_workbench().get_local_cwd()", "is_method": true, "class_name": "CPythonProxy", "function_description": "Retrieves the initial current working directory of the CPython environment. This provides the base file path for operations within that specific interpreter session."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_launch_cwd", "line_number": 44, "body": "def _get_launch_cwd(self):\n        # launch in the directory containing thonny package, so that other interpreters can import it as well\n        return os.path.dirname(os.path.dirname(thonny.__file__))", "is_method": true, "class_name": "CPythonProxy", "function_description": "Provides the suitable current working directory for launching processes. This allows other interpreters to correctly import the Thonny package."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_launcher_with_args", "line_number": 48, "body": "def _get_launcher_with_args(self):\n        return [\"-m\", \"thonny.plugins.cpython\", self.get_cwd()]", "is_method": true, "class_name": "CPythonProxy", "function_description": "This method prepares the command-line arguments for launching the Thonny CPython plugin. It provides the configuration to initiate a CPython interpreter process within its current working directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_store_state_info", "line_number": 51, "body": "def _store_state_info(self, msg):\n        super()._store_state_info(msg)\n\n        if \"gui_is_active\" in msg:\n            self._update_gui_updating(msg)", "is_method": true, "class_name": "CPythonProxy", "function_description": "Extends the base state storage by updating the proxy's GUI activity status. It ensures the proxy reflects the CPython interpreter's GUI state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_clear_environment", "line_number": 57, "body": "def _clear_environment(self):\n        self._close_backend()\n        self._start_background_process()", "is_method": true, "class_name": "CPythonProxy", "function_description": "This method refreshes the CPython execution environment managed by the proxy. It ensures a clean operational state by restarting underlying processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_close_backend", "line_number": 61, "body": "def _close_backend(self):\n        self._cancel_gui_update_loop()\n        super()._close_backend()", "is_method": true, "class_name": "CPythonProxy", "function_description": "Safely shuts down the CPythonProxy's backend by terminating any active GUI update processes and then calling the parent class's backend closure method."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_local_executable", "line_number": 65, "body": "def get_local_executable(self):\n        return self._executable", "is_method": true, "class_name": "CPythonProxy", "function_description": "Provides the path to the local Python executable managed by this CPython proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_update_gui_updating", "line_number": 68, "body": "def _update_gui_updating(self, msg):\n        \"\"\"Enables running Tkinter or Qt programs which doesn't call mainloop.\n\n        When mainloop is omitted, then program can be interacted with\n        from the shell after it runs to the end.\n\n        Each ToplevelResponse is supposed to tell, whether gui is active\n        and needs updating.\n        \"\"\"\n        if not \"gui_is_active\" in msg:\n            return\n\n        if msg[\"gui_is_active\"] and self._gui_update_loop_id is None:\n            # Start updating\n            self._loop_gui_update(True)\n        elif not msg[\"gui_is_active\"] and self._gui_update_loop_id is not None:\n            self._cancel_gui_update_loop()", "is_method": true, "class_name": "CPythonProxy", "function_description": "This method dynamically manages the continuous updating of a GUI, especially for Tkinter or Qt programs that do not call `mainloop`. It starts or stops the GUI update loop based on whether the GUI is reported as active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_loop_gui_update", "line_number": 86, "body": "def _loop_gui_update(self, force=False):\n        if force or get_runner().is_waiting_toplevel_command():\n            try:\n                self.send_command(InlineCommand(\"process_gui_events\"))\n            except OSError:\n                # the backend process may have been closed already\n                # https://github.com/thonny/thonny/issues/966\n                logger.exception(\"Could not send process_gui_events\")\n\n        self._gui_update_loop_id = get_workbench().after(50, self._loop_gui_update)", "is_method": true, "class_name": "CPythonProxy", "function_description": "This method manages a recurring loop to prompt the CPython backend to process GUI events. It ensures the user interface remains responsive during long-running operations or when the backend is waiting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_cancel_gui_update_loop", "line_number": 97, "body": "def _cancel_gui_update_loop(self):\n        if self._gui_update_loop_id is not None:\n            try:\n                get_workbench().after_cancel(self._gui_update_loop_id)\n            finally:\n                self._gui_update_loop_id = None", "is_method": true, "class_name": "CPythonProxy", "function_description": "Cancels a previously scheduled GUI update loop to stop its execution. It clears the associated loop identifier."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "interrupt", "line_number": 104, "body": "def interrupt(self):\n        import signal\n\n        if self._proc is not None and self._proc.poll() is None:\n            if running_on_windows():\n                try:\n                    os.kill(self._proc.pid, signal.CTRL_BREAK_EVENT)  # pylint: disable=no-member\n                except Exception:\n                    logging.exception(\"Could not interrupt backend process\")\n            else:\n                self._proc.send_signal(signal.SIGINT)", "is_method": true, "class_name": "CPythonProxy", "function_description": "Sends an interrupt signal to the associated CPython subprocess if it is active. This allows for controlled termination of the child process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "run_script_in_terminal", "line_number": 116, "body": "def run_script_in_terminal(self, script_path, args, interactive, keep_open):\n        cmd = [self._executable]\n        if interactive:\n            cmd.append(\"-i\")\n        cmd.append(os.path.basename(script_path))\n        cmd.extend(args)\n\n        run_in_terminal(cmd, os.path.dirname(script_path), keep_open=keep_open)", "is_method": true, "class_name": "CPythonProxy", "function_description": "Provides the capability to execute a Python script in a system terminal, optionally in interactive mode and controlling terminal persistence."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_supported_features", "line_number": 125, "body": "def get_supported_features(self):\n        return {\"run\", \"debug\", \"run_in_terminal\", \"pip_gui\", \"system_shell\"}", "is_method": true, "class_name": "CPythonProxy", "function_description": "Provides a list of features and capabilities supported by the CPythonProxy instance. Useful for determining which operations are available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_pip_gui_class", "line_number": 128, "body": "def get_pip_gui_class(self):\n        from thonny.plugins.pip_gui import CPythonBackendPipDialog\n\n        return CPythonBackendPipDialog", "is_method": true, "class_name": "CPythonProxy", "function_description": "Retrieves the CPython-specific GUI class for a pip management dialog. This enables the Thonny backend to open and interact with a pip GUI."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "can_run_remote_files", "line_number": 133, "body": "def can_run_remote_files(self):\n        return False", "is_method": true, "class_name": "CPythonProxy", "function_description": "This method indicates that the `CPythonProxy` is not capable of executing files from a remote source. It serves to declare a specific limitation of the proxy's functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "can_run_local_files", "line_number": 136, "body": "def can_run_local_files(self):\n        return True", "is_method": true, "class_name": "CPythonProxy", "function_description": "Indicates that the CPythonProxy instance has the capability to execute local files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_prepare_private_venv", "line_number": 145, "body": "def _prepare_private_venv(self):\n        path = get_private_venv_path()\n        if os.path.isdir(path) and os.path.isfile(os.path.join(path, \"pyvenv.cfg\")):\n            self._check_upgrade_private_venv(path)\n        else:\n            self._create_private_venv(\n                path, \"Please wait!\\nThonny prepares its virtual environment.\"\n            )", "is_method": true, "class_name": "PrivateVenvCPythonProxy", "function_description": "This method prepares Thonny's private virtual environment. It either creates a new venv if none exists or checks an existing one for necessary upgrades."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_check_upgrade_private_venv", "line_number": 154, "body": "def _check_upgrade_private_venv(self, path):\n        # If home is wrong then regenerate\n        # If only micro version is different, then upgrade\n        info = _get_venv_info(path)\n\n        if not is_same_path(info[\"home\"], os.path.dirname(sys.executable)):\n            self._create_private_venv(\n                path,\n                \"Thonny's virtual environment was created for another interpreter.\\n\"\n                + \"Regenerating the virtual environment for current interpreter.\\n\"\n                + \"(You may need to reinstall your 3rd party packages)\\n\"\n                + \"Please wait!.\",\n                clear=True,\n            )\n        else:\n            venv_version = tuple(map(int, info[\"version\"].split(\".\")))\n            sys_version = sys.version_info[:3]\n            assert venv_version[0] == sys_version[0]\n            assert venv_version[1] == sys_version[1]\n\n            if venv_version[2] != sys_version[2]:\n                self._create_private_venv(\n                    path, \"Please wait!\\nUpgrading Thonny's virtual environment.\", upgrade=True\n                )", "is_method": true, "class_name": "PrivateVenvCPythonProxy", "function_description": "This method ensures Thonny's private virtual environment is consistent with the current Python interpreter. It regenerates or upgrades the environment based on interpreter path or micro-version changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_create_private_venv", "line_number": 179, "body": "def _create_private_venv(self, path, description, clear=False, upgrade=False):\n        if not _check_venv_installed(self):\n            return\n        # Don't include system site packages\n        # This way all students will have similar configuration\n        # independently of system Python (if Thonny is used with system Python)\n\n        # NB! Cant run venv.create directly, because in Windows bundle\n        # it tries to link venv to thonny.exe.\n        # Need to run it via proper python\n        args = [\"-m\", \"venv\"]\n        if clear:\n            args.append(\"--clear\")\n        if upgrade:\n            args.append(\"--upgrade\")\n\n        try:\n            import ensurepip\n        except ImportError:\n            args.append(\"--without-pip\")\n\n        args.append(path)\n\n        proc = create_frontend_python_process(args)\n\n        from thonny.workdlg import SubprocessDialog\n\n        dlg = SubprocessDialog(\n            get_workbench(),\n            proc,\n            \"Preparing the backend\",\n            long_description=description,\n            autostart=True,\n        )\n        try:\n            ui_utils.show_dialog(dlg)\n        except Exception:\n            # if using --without-pip the dialog may close very quickly\n            # and for some reason wait_window would give error then\n            logging.exception(\"Problem with waiting for venv creation dialog\")\n        get_workbench().become_active_window()  # Otherwise focus may get stuck somewhere\n\n        bindir = os.path.dirname(get_private_venv_executable())\n        # create private env marker\n        marker_path = os.path.join(bindir, \"is_private\")\n        with open(marker_path, mode=\"w\") as fp:\n            fp.write(\"# This file marks Thonny-private venv\")\n\n        # Create recommended pip conf to get rid of list deprecation warning\n        # https://github.com/pypa/pip/issues/4058\n        pip_conf = \"pip.ini\" if running_on_windows() else \"pip.conf\"\n        with open(os.path.join(path, pip_conf), mode=\"w\") as fp:\n            fp.write(\"[list]\\nformat = columns\")\n\n        assert os.path.isdir(path)", "is_method": true, "class_name": "PrivateVenvCPythonProxy", "function_description": "This method creates a private, isolated Python virtual environment for internal use. It ensures a consistent setup, independent of the system's Python installation, to prepare the Thonny backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "fetch_next_message", "line_number": 244, "body": "def fetch_next_message(self):\n        msg = super().fetch_next_message()\n        if msg and \"welcome_text\" in msg:\n            if is_bundled_python(self._executable):\n                msg[\"welcome_text\"] += \" (bundled)\"\n            else:\n                msg[\"welcome_text\"] += \" (\" + self._executable + \")\"\n        return msg", "is_method": true, "class_name": "SameAsFrontendCPythonProxy", "function_description": "Fetches the next message, enhancing its \"welcome_text\" attribute with details about the Python executable's origin (bundled or specific path)."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_clean_description", "line_number": 253, "body": "def get_clean_description(self):\n        return \"Python \" + get_python_version_string()", "is_method": true, "class_name": "SameAsFrontendCPythonProxy", "function_description": "Returns a descriptive string identifying the current Python version associated with the CPython proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "fetch_next_message", "line_number": 269, "body": "def fetch_next_message(self):\n        msg = super().fetch_next_message()\n        if msg and \"welcome_text\" in msg:\n            msg[\"welcome_text\"] += \" (\" + self._executable + \")\"\n        return msg", "is_method": true, "class_name": "CustomCPythonProxy", "function_description": "Retrieves the next message from the base proxy. It enhances messages containing 'welcome_text' by appending details about the executable from the `CustomCPythonProxy` instance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_clean_description", "line_number": 275, "body": "def get_clean_description(self):\n        desc = get_workbench().get_option(\"CustomInterpreter.path\")\n        if not desc:\n            desc = sys.executable\n\n        return desc", "is_method": true, "class_name": "CustomCPythonProxy", "function_description": "Retrieves the configured path or the current executable's path for the CPython interpreter associated with this custom proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_get_switcher_entry_for_executable", "line_number": 283, "body": "def _get_switcher_entry_for_executable(cls, executable):\n        return (\n            {\"run.backend_name\": cls.backend_name, \"CustomInterpreter.path\": executable},\n            executable,\n        )", "is_method": true, "class_name": "CustomCPythonProxy", "function_description": "Generates a structured entry for a \"switcher\" system. This entry maps an executable path to its associated backend configuration, enabling dynamic interpreter selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_current_switcher_configuration", "line_number": 290, "body": "def get_current_switcher_configuration(cls):\n        return cls._get_switcher_entry_for_executable(\n            get_workbench().get_option(\"CustomInterpreter.path\")\n        )[0]", "is_method": true, "class_name": "CustomCPythonProxy", "function_description": "Retrieves the configuration for the active custom CPython interpreter, based on the path currently set in the development environment's workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "get_switcher_entries", "line_number": 296, "body": "def get_switcher_entries(cls):\n        return [\n            cls._get_switcher_entry_for_executable(executable)\n            for executable in _get_interpreters()\n            if os.path.exists(executable)\n        ]", "is_method": true, "class_name": "CustomCPythonProxy", "function_description": "Gathers and validates CPython interpreter entries. It provides a structured list of available interpreter configurations suitable for environment switching or selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "should_restart", "line_number": 344, "body": "def should_restart(self):\n        return False", "is_method": true, "class_name": "SameAsFrontEndConfigurationPage", "function_description": "This method consistently indicates that a restart is never required for any configuration changes managed by this front-end page. It provides a fixed \"no restart\" policy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "should_restart", "line_number": 360, "body": "def should_restart(self):\n        return False", "is_method": true, "class_name": "PrivateVenvConfigurationPage", "function_description": "Indicates that actions on or configuration of this page never require a system restart. It provides a fixed response for restart checks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_select_executable", "line_number": 416, "body": "def _select_executable(self):\n        # TODO: get dir of current interpreter\n        options = {\"parent\": self.winfo_toplevel()}\n        if running_on_windows():\n            options[\"filetypes\"] = [\n                (tr(\"Python interpreters\"), \"python.exe\"),\n                (tr(\"all files\"), \".*\"),\n            ]\n\n        filename = askopenfilename(**options)\n        if not filename:\n            return\n\n        if filename.endswith(\"/activate\"):\n            filename = filename[: -len(\"activate\")] + \"python3\"\n\n        if filename:\n            self._configuration_variable.set(filename)", "is_method": true, "class_name": "CustomCPythonConfigurationPage", "function_description": "Allows users to select a Python executable file via a file dialog. It updates a configuration setting with the chosen interpreter's path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "_create_venv", "line_number": 435, "body": "def _create_venv(self, event=None):\n        if not _check_venv_installed(self):\n            return\n\n        messagebox.showinfo(\n            \"Creating new virtual environment\",\n            \"After clicking 'OK' you need to choose an empty directory, \"\n            \"which will be the root of your new virtual environment.\",\n            parent=self,\n        )\n        path = None\n        while True:\n            path = askdirectory(\n                parent=self.winfo_toplevel(),\n                initialdir=path,\n                title=tr(\"Select empty directory for new virtual environment\"),\n            )\n            if not path:\n                return\n\n            if os.listdir(path):\n                messagebox.showerror(\n                    tr(\"Bad directory\"),\n                    tr(\"Selected directory is not empty.\\nSelect another or cancel.\"),\n                    master=self,\n                )\n            else:\n                break\n        assert os.path.isdir(path)\n        path = normpath_with_actual_case(path)\n\n        proc = subprocess.Popen(\n            [running.get_interpreter_for_subprocess(), \"-m\", \"venv\", path],\n            stdin=None,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            universal_newlines=True,\n        )\n        from thonny.workdlg import SubprocessDialog\n\n        dlg = SubprocessDialog(self, proc, tr(\"Creating virtual environment\"), autostart=True)\n        ui_utils.show_dialog(dlg)\n\n        if running_on_windows():\n            exe_path = normpath_with_actual_case(os.path.join(path, \"Scripts\", \"python.exe\"))\n        else:\n            exe_path = os.path.join(path, \"bin\", \"python3\")\n\n        if os.path.exists(exe_path):\n            self._configuration_variable.set(exe_path)", "is_method": true, "class_name": "CustomCPythonConfigurationPage", "function_description": "Creates a new Python virtual environment. It guides the user to select an empty directory, executes the venv command, and sets the configuration to the new interpreter path."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "should_restart", "line_number": 486, "body": "def should_restart(self):\n        return self._configuration_variable.modified", "is_method": true, "class_name": "CustomCPythonConfigurationPage", "function_description": "Determines if the custom CPython configuration requires a restart by checking if its associated configuration variable has been modified. This capability signals when changes necessitate a system reload."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/cpython/__init__.py", "function": "apply", "line_number": 489, "body": "def apply(self):\n        if not self.should_restart():\n            return\n\n        path = self._configuration_variable.get()\n        if os.path.isfile(path):\n            get_workbench().set_option(\"CustomInterpreter.path\", path)", "is_method": true, "class_name": "CustomCPythonConfigurationPage", "function_description": "Applies the user-defined path for a custom CPython interpreter. It updates the workbench settings if the path is valid and a restart is indicated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/birdseye_backend.py", "function": "_cmd_Birdseye", "line_number": 11, "body": "def _cmd_Birdseye(cmd):\n    backend = get_backend()\n    backend.switch_env_to_script_mode(cmd)\n    return backend._execute_file(cmd, BirdsEyeRunner)", "is_method": false, "function_description": "Executes a specified command or script within a dedicated 'Birdseye' environment. It prepares the backend and runs the file using the BirdsEyeRunner for specialized execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/birdseye_backend.py", "function": "load_plugin", "line_number": 42, "body": "def load_plugin():\n    try:\n        os.environ[\"OUTDATED_IGNORE\"] = \"1\"\n        # TODO: it would be good to do this here, but it's slow\n        # import birdseye.bird  # need to import at plugin load time, because later it may not be in path\n    except ImportError:\n        pass\n    get_backend().add_command(\"Birdseye\", _cmd_Birdseye)", "is_method": false, "function_description": "This function registers the 'Birdseye' command with the system's backend, enabling its functionality within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/birdseye_backend.py", "function": "execute_source", "line_number": 20, "body": "def execute_source(self, source, filename, mode, ast_postprocessors):\n        import webbrowser\n\n        assert mode == \"exec\"\n        # ignore ast_postprocessors, because birdseye requires source\n\n        if isinstance(source, bytes):\n            source = source.decode(\"utf-8\")\n\n        import __main__  # @UnresolvedImport\n\n        global_vars = __main__.__dict__\n\n        # Following is a trick, which allows importing birdseye in the backends,\n        # which doesn't have it installed (provided it is installed for frontend Python)\n        from birdseye.bird import eye\n\n        eye.exec_string(source, filename, globs=global_vars, locs=global_vars, deep=True)\n        port = os.environ.get(\"BIRDSEYE_PORT\", \"7777\")\n        webbrowser.open_new_tab(\"http://localhost:%s/ipython_call/\" % port + eye._last_call_id)", "is_method": true, "class_name": "BirdsEyeRunner", "function_description": "Executes Python source code using the BirdsEye library for detailed runtime tracing. It then automatically opens the BirdsEye web interface to visualize the code's execution flow."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/pgzero_backend.py", "function": "augment_ast", "line_number": 8, "body": "def augment_ast(root):\n    mode = os.environ.get(\"PGZERO_MODE\", \"False\")\n    assert mode != \"False\"\n\n    warning_prelude = \"WARNING: Pygame Zero mode is turned on (Run \u2192 Pygame Zero mode)\"\n    try:\n        import pgzero  # @UnusedImport\n    except ImportError:\n        if mode == \"True\":\n            print(\n                warning_prelude\n                + \",\\nbut pgzero module is not found. Running program in regular mode.\\n\",\n                file=sys.stderr,\n            )\n        else:\n            assert mode == \"auto\"\n\n        return\n\n    # Check if draw is defined\n    for stmt in root.body:\n        if isinstance(stmt, ast.FunctionDef) and stmt.name == \"draw\":\n            break\n    else:\n        if mode == \"auto\":\n            return\n        else:\n            print(\n                warning_prelude\n                + \",\\nbut your program doesn't look like usual Pygame Zero program\\n\"\n                + \"(draw function is missing).\\n\",\n                file=sys.stderr,\n            )\n\n    # need more checks in auto mode\n    if mode == \"auto\":\n        # check that draw method is not called in the code\n        for node in ast.walk(root):\n            if (\n                isinstance(node, ast.Call)\n                and isinstance(node.func, ast.Name)\n                and node.func.id == \"draw\"\n            ):\n                return\n\n    # prepend \"import pgzrun as __pgzrun\"\n    imp = ast.Import([ast.alias(\"pgzrun\", \"__pgzrun\")])\n    imp.lineno = 0\n    imp.col_offset = 0\n    ast.fix_missing_locations(imp)\n    imp.tags = {\"ignore\"}\n    root.body.insert(0, imp)\n\n    # append \"__pgzrun.go()\"\n    go = ast.Expr(\n        ast.Call(ast.Attribute(ast.Name(\"__pgzrun\", ast.Load()), \"go\", ast.Load()), [], [])\n    )\n    go.lineno = 1000000\n    go.col_offset = 0\n    ast.fix_missing_locations(go)\n    go.tags = {\"ignore\"}\n    root.body.append(go)", "is_method": false, "function_description": "Transforms a Python Abstract Syntax Tree (AST) to enable Pygame Zero execution. It injects necessary Pygame Zero boilerplate code if the script meets specific criteria and environment settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/pgzero_backend.py", "function": "patched_editor_autocomplete", "line_number": 72, "body": "def patched_editor_autocomplete(self, cmd):\n    # Make extra builtins visible for Jedi\n    prefix = \"from pgzero.builtins import *\\n\"\n    cmd[\"source\"] = prefix + cmd[\"source\"]\n    cmd[\"row\"] = cmd[\"row\"] + 1\n\n    result = get_backend()._original_editor_autocomplete(cmd)\n    result[\"row\"] = result[\"row\"] - 1\n    result[\"source\"] = result[\"source\"][len(prefix) :]\n\n    return result", "is_method": false, "function_description": "This function extends editor autocompletion by making `pgzero.builtins` visible to the underlying engine. It transparently modifies the source code to provide better suggestions for `pgzero` projects."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/pgzero_backend.py", "function": "load_plugin", "line_number": 85, "body": "def load_plugin():\n    if os.environ.get(\"PGZERO_MODE\", \"False\").lower() == \"false\":\n        return\n\n    get_backend().add_ast_postprocessor(augment_ast)\n    MainCPythonBackend._original_editor_autocomplete = MainCPythonBackend._cmd_editor_autocomplete\n    MainCPythonBackend._cmd_editor_autocomplete = patched_editor_autocomplete", "is_method": false, "function_description": "This function loads a plugin that enhances the PgZero environment. It customizes code processing and improves the editor's autocomplete feature."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/flask_backend.py", "function": "augment_source", "line_number": 6, "body": "def augment_source(source, cmd):\n    if \"Flask\" not in source:\n        # don't bother analyzing further\n        return source\n\n    try:\n        tree = ast.parse(source)\n    except SyntaxError:\n        return source\n\n    var_name = None\n    found_run = False\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, ast.Assign)\n            and isinstance(node.value, ast.Call)\n            and isinstance(node.value.func, ast.Name)  # TODO: could be also flask.Flask\n            and node.value.func.id == \"Flask\"\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], ast.Name)\n        ):\n            var_name = node.targets[0].id\n        elif (\n            isinstance(node, ast.Call)\n            and isinstance(node.func, ast.Attribute)\n            and isinstance(node.func.value, ast.Name)\n            and node.func.value.id == var_name\n            and node.func.attr == \"run\"\n        ):\n            found_run = True\n\n    if not var_name or found_run:\n        return source\n    else:\n        return (\n            source\n            + \"\"\"\n\nif \"{app_name}\" in globals():\n    import os as __temp_os__\n    if \"FLASK_ENV\" not in __temp_os__.environ:\n        __temp_os__.environ[\"FLASK_ENV\"] = \"development\"\n    del __temp_os__\n    \n    # Conservative options for minimum technical risks.\n    # Users who need more control should call run explicitly.\n    print(\" # Running the app with options chosen by Thonny. See Help for details.\")\n    {app_name}.run(threaded=False, debug=False, use_reloader=False)\n\"\"\".format(\n                app_name=var_name\n            )\n        )", "is_method": false, "function_description": "Augments Flask application source code by injecting `app.run()` with conservative options. This enables direct execution when `app.run()` is not explicitly defined, simplifying development."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/flask_backend.py", "function": "load_plugin", "line_number": 61, "body": "def load_plugin():\n    get_backend().add_source_preprocessor(augment_source)", "is_method": false, "function_description": "Registers a source preprocessor (`augment_source`) with the backend system. This dynamically extends the system's data processing capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/matplotlib_backend.py", "function": "set_default_backend", "line_number": 13, "body": "def set_default_backend(matplotlib):\n    global done\n\n    # Tried with overwriting settings only when MacOSX backend is selected\n    # but querying this failed because of strange import behavior\n    if (\n        done\n        or \"MPLBACKEND\" in os.environ\n        or os.path.exists(local_conf_file)\n        or os.path.exists(user_conf_file1)\n        or os.path.exists(user_conf_file2)\n    ):\n        # done or the user knows what (s)he's doing\n        pass\n    else:\n\n        try:\n            import tkinter  # @UnusedImport\n\n            os.environ[\"MPLBACKEND\"] = \"TkAgg\"\n        except ImportError:\n            pass\n\n    done = True", "is_method": false, "function_description": "Automatically configures a default Matplotlib backend, preferring 'TkAgg' if Tkinter is available. This ensures Matplotlib can display plots when no backend is explicitly set."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/matplotlib_backend.py", "function": "load_plugin", "line_number": 39, "body": "def load_plugin():\n    if platform.system() == \"Darwin\":\n        # https://github.com/thonny/thonny/issues/676\n        backend = get_backend()\n        backend.add_import_handler(\"matplotlib\", set_default_backend)", "is_method": false, "function_description": "Configures the application's backend to handle `matplotlib` imports specially on macOS, likely to resolve a known compatibility issue."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/dock_user_windows_backend.py", "function": "on_configure", "line_number": 11, "body": "def on_configure(event):\n    global _last_pos, _notification_is_sent\n    pos = event.x, event.y\n    if pos != _last_pos:\n        get_backend().set_option(_LAST_POS_SETTING, pos)\n\n    if not _notification_is_sent:\n        get_backend().send_message(BackendEvent(\"UserWindowAppeared\"))\n        _notification_is_sent = True", "is_method": false, "function_description": "This function handles UI configuration events, updating the application's stored last window position if it has changed. It also sends a one-time notification to the backend when a user window first appears."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/dock_user_windows_backend.py", "function": "patch_tkinter", "line_number": 22, "body": "def patch_tkinter(module):\n    flag_name = \"has_docking_patch\"\n    if getattr(module, flag_name, False):\n        return\n\n    original_constructor = module.Tk.__init__\n\n    def patched_Tk_constructor(self, *args, **kw):\n        original_constructor(self, *args, **kw)\n\n        try:\n            # move window to the same place it was previously\n            last_pos = get_backend().get_option(_LAST_POS_SETTING)\n            if isinstance(last_pos, tuple):\n                self.geometry(\"+%d+%d\" % last_pos)\n\n            self.wm_attributes(\"-topmost\", 1)\n            # self.overrideredirect(1)\n\n            # I'm using bind_class because turtle._Screen later overwrites the bind handler\n            self.bind_class(\"Tk\", \"<Configure>\", on_configure, True)\n        except Exception:\n            # expected to fail when constructing Tcl for _cmd_process_gui_events\n            pass\n\n    module.Tk.__init__ = patched_Tk_constructor\n    setattr(module, flag_name, True)", "is_method": false, "function_description": "Patches the Tkinter `Tk` class constructor to customize window behavior, making windows remember their last position and always stay on top."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/dock_user_windows_backend.py", "function": "patch_turtle", "line_number": 51, "body": "def patch_turtle(module):\n    # Turtle needs more tweaking because it later overrides the position set in the Tk constructor\n    turtle_config = getattr(module, \"_CFG\", None)\n    if isinstance(turtle_config, dict):\n        last_pos = get_backend().get_option(_LAST_POS_SETTING)\n        if isinstance(last_pos, tuple):\n            turtle_config[\"leftright\"], turtle_config[\"topbottom\"] = last_pos", "is_method": false, "function_description": "Adjusts the `turtle` module's configuration to establish its initial `leftright` and `topbottom` position. It ensures the turtle starts at a specified previous location."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/dock_user_windows_backend.py", "function": "load_plugin", "line_number": 60, "body": "def load_plugin():\n    if os.environ.get(\"DOCK_USER_WINDOWS\", \"False\").lower() == \"true\":\n        backend = get_backend()\n        backend.add_import_handler(\"tkinter\", patch_tkinter)\n        backend.add_import_handler(\"turtle\", patch_turtle)", "is_method": false, "function_description": "Conditionally loads a backend plugin to patch `tkinter` and `turtle` modules. This ensures compatibility for GUI libraries when operating in a Windows-like environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/backend/dock_user_windows_backend.py", "function": "patched_Tk_constructor", "line_number": 29, "body": "def patched_Tk_constructor(self, *args, **kw):\n        original_constructor(self, *args, **kw)\n\n        try:\n            # move window to the same place it was previously\n            last_pos = get_backend().get_option(_LAST_POS_SETTING)\n            if isinstance(last_pos, tuple):\n                self.geometry(\"+%d+%d\" % last_pos)\n\n            self.wm_attributes(\"-topmost\", 1)\n            # self.overrideredirect(1)\n\n            # I'm using bind_class because turtle._Screen later overwrites the bind handler\n            self.bind_class(\"Tk\", \"<Configure>\", on_configure, True)\n        except Exception:\n            # expected to fail when constructing Tcl for _cmd_process_gui_events\n            pass", "is_method": false, "function_description": "This patched Tk constructor extends the default behavior to restore the window's last position and keep it always on top. It also configures an event handler for automatically saving its new position."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "print_current_script", "line_number": 10, "body": "def print_current_script():\n    editor = _get_current_editor()\n    assert editor is not None\n\n    template_fn = os.path.join(os.path.dirname(__file__), \"template.html\")\n    with open(template_fn, encoding=\"utf-8\") as f:\n        template_html = f.read()\n\n    script_html = _export_text_as_html(editor.get_text_widget())\n    title_html = escape_html(editor.get_title())\n    full_html = template_html.replace(\"%title%\", title_html).replace(\"%script%\", script_html)\n\n    import tempfile\n\n    temp_handle, temp_fn = tempfile.mkstemp(\n        suffix=\".html\", prefix=\"thonny_\", dir=get_workbench().get_temp_dir()\n    )\n    with os.fdopen(temp_handle, \"w\", encoding=\"utf-8\") as f:\n        f.write(full_html)\n\n    if platform.system() == \"Darwin\":\n        subprocess.Popen([\"open\", temp_fn])\n    else:\n        import webbrowser\n\n        webbrowser.open(temp_fn)", "is_method": false, "function_description": "Converts the current editor's script into an HTML page. It then opens this temporary HTML file in a web browser for easy viewing or printing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "can_print_current_script", "line_number": 38, "body": "def can_print_current_script():\n    return _get_current_editor() is not None", "is_method": false, "function_description": "Checks if an active editor is available, indicating whether the current script can be printed. This determines if the environment supports printing the script."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "_export_text_as_html", "line_number": 42, "body": "def _export_text_as_html(text):\n    last_line = int(float(text.index(\"end-1c\")))\n    result = \"\"\n    for i in range(1, last_line + 1):\n        result += \"<code>\" + _export_line_as_html(text, i) + \"</code>\\n\"\n    return result", "is_method": false, "function_description": "Transforms a multi-line text object into an HTML string, wrapping each line in `<code>` tags. Useful for exporting code or plain text for web display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "_export_line_as_html", "line_number": 50, "body": "def _export_line_as_html(text, lineno):\n    s = text.get(\"%d.0\" % lineno, \"%d.0 lineend\" % lineno).strip(\"\\r\\n\")\n\n    parts = []\n    for i in range(len(s)):\n        tag_names = text.tag_names(\"%d.%d\" % (lineno, i))\n        if not parts or parts[-1][1] != tag_names:\n            parts.append([s[i], tag_names])\n        else:\n            parts[-1][0] += s[i]\n\n    # print(lineno, parts)\n    result = \"\"\n    for s, tags in parts:\n        if tags:\n            result += \"<span class='%s'>%s</span>\" % (\" \".join(tags), escape_html(s))\n        else:\n            result += escape_html(s)\n\n    return result", "is_method": false, "function_description": "Converts a specified line from a tagged text source into an HTML string. It translates text tags into HTML `<span>` elements with class attributes to maintain styling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "escape_html", "line_number": 72, "body": "def escape_html(s):\n    return s.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")", "is_method": false, "function_description": "This function converts special HTML characters in a string into their corresponding HTML entities. It ensures the string can be safely displayed within an HTML document without being interpreted as markup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "_get_current_editor", "line_number": 76, "body": "def _get_current_editor():\n    return get_workbench().get_editor_notebook().get_current_editor()", "is_method": false, "function_description": "Provides access to the editor currently in focus within the application's workbench interface, allowing other functions to interact with the active editing session."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/printing/__init__.py", "function": "load_plugin", "line_number": 80, "body": "def load_plugin():\n    get_workbench().add_command(\n        \"printcurrent\",\n        \"file\",\n        tr(\"Print...\"),\n        print_current_script,\n        can_print_current_script,\n        default_sequence=select_sequence(\"<Control-p>\", \"<Command-p>\"),\n        extra_sequences=[\"<Control-Greek_pi>\"],\n        group=11,\n    )", "is_method": false, "function_description": "This function registers a \"print current script\" command with the application's workbench. It enables users to print their active script, accessible via a menu item and keyboard shortcuts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "load_plugin", "line_number": 159, "body": "def load_plugin():\n    add_micropython_backend(\n        \"CircuitPython\",\n        CircuitPythonProxy,\n        tr(\"CircuitPython (generic)\"),\n        CircuitPythonConfigPage,\n        sort_key=\"50\",\n    )", "is_method": false, "function_description": "This function registers the CircuitPython backend, making it available within the application. It enables support and configuration for CircuitPython devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 27, "body": "def get_known_usb_vids_pids(cls):\n        \"\"\"Information gathered from\n        https://github.com/mu-editor/mu/blob/master/mu/modes/circuitpython.py\n        https://github.com/microsoft/uf2-samdx1\n        \"\"\"\n        return {\n            (0x03EB, 0x2402),  # Generic Corp., SAMD21 or SAME54 Board\n            (0x04D8, 0xEC72),  # XinaBox CC03\n            (0x04D8, 0xEC75),  # XinaBox CS11\n            (0x04D8, 0xED94),  # PyCubed\n            (0x04D8, 0xED5E),  # XinaBox CW03\n            (0x04D8, 0xEDB3),  # Capable Robot Components, Programmable USB Hub\n            (0x04D8, 0xEDBE),  # maholli, SAM32\n            (0x04D8, 0xEF66),  # eduSense, senseBox MCU\n            (0x1209, 0x2017),  # Benjamin Shockley, Mini SAM M4\n            (0x1209, 0x4D44),  # Robotics Masters, Robo HAT MM1 M4\n            (0x1209, 0x7102),  # Mini SAM M0\n            (0x1209, 0xBAB1),  # Electronic Cats Meow Meow\n            (0x1209, 0xBAB2),  # Electronic Cats CatWAN USBStick\n            (0x1209, 0xBAB3),  # Electronic Cats Bast Pro Mini M0\n            (0x1209, 0xBAB6),  # Electronic Cats Escornabot Makech\n            (0x16D0, 0x0CDA),  # dadamachines, automat\n            (0x1B4F, 0x0016),  # Sparkfun Thing Plus - SAMD51\n            (0x1B4F, 0x8D22),  # SparkFun SAMD21 Mini Breakout\n            (0x1B4F, 0x8D23),  # SparkFun SAMD21 Dev Breakout\n            (0x1D50, 0x60E8),  # PewPew Game Console\n            (0x1D50, 0x6110),  # Eitech, Robotics\n            (0x1D50, 0x6112),  # Watterott electronic, Wattuino RC\n            (0x2341, 0x8053),  # Arduino LLC, Arduino MKR1300\n            (0x2341, 0x8057),  # Arduino Nano 33 IoT board\n            (0x239A, None),  # Adafruit\n            (0x2886, 0x802D),  # Seeed Wio Terminal\n            (0x2886, 0x000D),  # Seeed Studio, Grove Zero\n            (0x2B04, 0xC00C),  # Particle Argon\n            (0x2B04, 0xC00D),  # Particle Boron\n            (0x2B04, 0xC00E),  # Particle Xenon\n            (0x3171, 0x0101),  # 8086.net Commander\n        }", "is_method": true, "class_name": "CircuitPythonProxy", "function_description": "Provides a predefined set of USB Vendor ID and Product ID pairs for known CircuitPython-compatible devices. This enables identification and interaction with specific hardware."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "get_vids_pids_to_avoid", "line_number": 67, "body": "def get_vids_pids_to_avoid(self):\n        return VIDS_PIDS_TO_AVOID", "is_method": true, "class_name": "CircuitPythonProxy", "function_description": "Provides a fixed list of Vendor IDs and Product IDs that should be avoided. This is useful for filtering specific hardware devices when interacting with CircuitPython."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_get_usb_driver_url", "line_number": 72, "body": "def _get_usb_driver_url(self):\n        return \"https://learn.adafruit.com/welcome-to-circuitpython/installing-circuitpython\"", "is_method": true, "class_name": "CircuitPythonConfigPage", "function_description": "Provides the official URL for CircuitPython USB driver installation instructions, enabling access to necessary setup guidance."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_has_flashing_dialog", "line_number": 75, "body": "def _has_flashing_dialog(self):\n        return True", "is_method": true, "class_name": "CircuitPythonConfigPage", "function_description": "This `CircuitPythonConfigPage` method signals that a flashing dialog is always present, informing the UI to prepare or display it."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_open_flashing_dialog", "line_number": 78, "body": "def _open_flashing_dialog(self):\n        dlg = CircuitPythonFlashingDialog(self)\n        ui_utils.show_dialog(dlg)", "is_method": true, "class_name": "CircuitPythonConfigPage", "function_description": "Provides a user interface for CircuitPython flashing by opening a dedicated dialog window."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "get_instructions", "line_number": 88, "body": "def get_instructions(self) -> Optional[str]:\n        return (\n            \"This dialog allows you to install or update CircuitPython firmware on your device.\\n\"\n            \"\\n\"\n            \"1. Plug in your device into bootloader mode by double-pressing the reset button.\\n\"\n            \"2. Wait until device information appears.\\n\"\n            \"3. (If nothing happens in 10 seconds, then try shorter or longer pauses between presses.)\\n\"\n            \"4. Click 'Install' and wait until done.\\n\"\n            \"5. Close the dialog and start programming!\"\n        )", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Provides step-by-step instructions for users to install or update CircuitPython firmware on a device. It guides users through the process within the flashing dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_get_release_info_url", "line_number": 99, "body": "def _get_release_info_url(self):\n        return \"https://api.github.com/repos/adafruit/circuitpython/releases/latest\"", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Provides the GitHub API URL to fetch the latest CircuitPython release information for update checks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_get_devices_info_url", "line_number": 102, "body": "def _get_devices_info_url(self):\n        # use the master version, not bundled version\n        return \"https://raw.githubusercontent.com/thonny/thonny/master/thonny/plugins/circuitpython/devices.json\"", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Provides the URL for the CircuitPython devices information file. This allows the dialog to fetch up-to-date compatibility data for flashing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_download_release_info", "line_number": 106, "body": "def _download_release_info(self):\n        # First download devices\n        import json\n        from urllib.request import urlopen\n\n        try:\n            with urlopen(self._get_devices_info_url()) as fp:\n                self._devices_info = json.loads(fp.read().decode(\"UTF-8\"))\n        except Exception as e:\n            logger.warning(\n                \"Could not find release info from %s\", self._get_release_info_url(), exc_info=e\n            )\n            return\n\n        # ... and then release\n        super(CircuitPythonFlashingDialog, self)._download_release_info()", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Fetches and parses CircuitPython device configuration data from a remote source. This essential information supports the dialog's functionality for flashing devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "get_download_url_and_size", "line_number": 123, "body": "def get_download_url_and_size(self, board_id):\n        # TODO: should take vid/pid also into account. It looks like different models may have same board_id\n        if self._release_info is None or self._devices_info is None:\n            return None\n\n        if not \"tag_name\" in self._release_info:\n            raise RuntimeError(\"Could not find tag_name from %s\" % self._get_release_info_url())\n\n        release = self._release_info[\"tag_name\"]\n\n        if not self._devices_info.get(board_id, {}).get(\"FIRMWARE_DOWNLOAD\", None):\n            raise RuntimeError(\n                \"Could not find your board (%s) or its download url from %s (consider making a PR). \"\n                % (board_id, self._get_devices_info_url())\n                + \"Please find the firmware from https://circuitpython.org/ and install it manually.\"\n            )\n\n        url = self._devices_info[board_id][\"FIRMWARE_DOWNLOAD\"].format(\n            lang=\"en_US\", release=release\n        )\n\n        # reporting approximate size for now. Downloader can take precise value from the header later\n        size = 2 ** 20  # 1 MiB\n        return (url, size)", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Retrieves the firmware download URL and estimated size for a specified CircuitPython board, facilitating firmware flashing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "get_title", "line_number": 152, "body": "def get_title(self):\n        return \"Install CircuitPython firmware for your device\"", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "Provides the specific title text for the CircuitPython firmware installation dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/__init__.py", "function": "_get_vid_pids_to_wait_for", "line_number": 155, "body": "def _get_vid_pids_to_wait_for(self):\n        return CircuitPythonProxy.get_known_usb_vids_pids()", "is_method": true, "class_name": "CircuitPythonFlashingDialog", "function_description": "This method provides the USB Vendor ID (VID) and Product ID (PID) pairs for known CircuitPython devices. It helps the dialog identify and monitor relevant devices during flashing or connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/update_firmware_mapping.py", "function": "update_info", "line_number": 24, "body": "def update_info(existing_map, name, info_path):\n    info = {}\n    with open(info_path, encoding=\"utf-8\") as fp:\n        for line in fp:\n            if \" //\" in line:\n                line = line[: line.find(\" //\")]\n            parts = list(map(str.strip, line.strip().split(maxsplit=2)))\n            if len(parts) == 3 and parts[0] == \"#define\" and parts[1] in relevant_vars:\n                value = parts[2]\n                if value.startswith('\"'):\n                    value = value[1:-1]\n                info[parts[1]] = value\n\n    if \"BOARD_ID\" in info:\n        combined_record = existing_map.get(info[\"BOARD_ID\"], {})\n        combined_record.update(info)\n        if \"FIRMWARE_DOWNLOAD\" in combined_record:\n            combined_record[\"FIRMWARE_DOWNLOAD\"] = \"\"\n        if \"CP_URL\" not in combined_record:\n            combined_record[\"CP_URL\"] = \"\"\n        existing_map[info[\"BOARD_ID\"]] = combined_record\n\n        if combined_record[\"CP_URL\"] and not combined_record[\"FIRMWARE_DOWNLOAD\"]:\n            board_key = combined_record[\"CP_URL\"].strip(\"/\").split(\"/\")[-1]\n            url = DOWNLOAD_URL_PATTERN.replace(\"BOARD_KEY\", board_key)\n            # print(url.format(lang=\"en_US\", release=CP_LATEST_VER))\n            combined_record[\"FIRMWARE_DOWNLOAD\"] = url", "is_method": false, "function_description": "Updates a mapping of board records by parsing definition data from a file. It populates or amends entries for specific board IDs, dynamically generating firmware download links when applicable."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/circuitpython/cirpy_backend.py", "function": "_soft_reboot_without_running_main", "line_number": 14, "body": "def _soft_reboot_without_running_main(self):\n        logger.debug(\"_soft_reboot_without_running_main\")\n        # no point in going to raw mode at all\n        self._write(SOFT_REBOOT_CMD + INTERRUPT_CMD)\n\n        logger.debug(\"Extra interrupts for CP\")\n        # CP runs code.py after soft-reboot even in raw repl, so I'll send some Ctrl-C to intervene\n        # # (they don't do anything when already in raw repl)\n        self._write(INTERRUPT_CMD)\n        time.sleep(0.05)\n        self._write(INTERRUPT_CMD)\n        time.sleep(0.3)\n        self._write(INTERRUPT_CMD)\n        time.sleep(0.05)\n        self._write(INTERRUPT_CMD)\n\n        self._capture_output_until_active_prompt()", "is_method": true, "class_name": "CircuitPythonBackend", "function_description": "Triggers a soft reboot on the CircuitPython device. It then sends interrupts to prevent `code.py` from automatically executing, enabling the host to gain immediate control."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "load_plugin", "line_number": 101, "body": "def load_plugin():\n    add_micropython_backend(\n        \"RPiPico\",\n        RaspberryPiPicoBackendProxy,\n        \"MicroPython (Raspberry Pi Pico)\",\n        RaspberryPiPicoBackendConfigPage,\n        bare_metal=True,\n        sort_key=\"32\",\n        validate_time=False,\n        sync_time=True,\n        write_block_size=64,\n    )\n\n    # Don't consider Pico in generic backends\n    # The main reason is to reduce the number of items in the backend switcher menu\n    import thonny.plugins.circuitpython\n    import thonny.plugins.micropython\n\n    thonny.plugins.micropython.VIDS_PIDS_TO_AVOID_IN_GENERIC_BACKEND.update(\n        RaspberryPiPicoBackendProxy.get_known_usb_vids_pids()\n    )", "is_method": false, "function_description": "Registers and configures a dedicated MicroPython backend for the Raspberry Pi Pico. It also ensures the Pico is not treated as a generic device, providing specialized support."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "consider_unknown_devices", "line_number": 18, "body": "def consider_unknown_devices(self):\n        return False", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "A configuration method that prevents the Raspberry Pi Pico backend proxy from considering unknown devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "should_consider_unknown_devices", "line_number": 22, "body": "def should_consider_unknown_devices(cls):\n        return False", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "This function defines a configuration policy, stating that the backend proxy should not consider unknown devices. It provides a system-wide setting regarding device discovery."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "known_usb_vids_pids", "line_number": 26, "body": "def known_usb_vids_pids(self):\n        # Required for backward compatibility\n        return RaspberryPiPicoBackendProxy.get_known_usb_vids_pids()", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Provides a list of known USB Vendor IDs and Product IDs. This method allows other functions to identify compatible Raspberry Pi Pico devices for backend interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 31, "body": "def get_known_usb_vids_pids(cls):\n        return {(0x2E8A, 0x0005)}", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Provides a set of known USB Vendor ID and Product ID pairs. This identifies Raspberry Pi Pico devices for recognition by the backend proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "device_is_present_in_bootloader_mode", "line_number": 35, "body": "def device_is_present_in_bootloader_mode(cls):\n        return bool(PicoFlashingDialog.get_possible_targets())", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Checks if a Raspberry Pi Pico device is currently detected in bootloader mode, indicating it's ready for flashing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "get_node_label", "line_number": 38, "body": "def get_node_label(self):\n        return \"Raspberry Pi Pico\"", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Provides a human-readable label for the Raspberry Pi Pico backend proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_propose_install_firmware", "line_number": 41, "body": "def _propose_install_firmware(self):\n        dlg = PicoFlashingDialog(get_workbench())\n        show_dialog(dlg)\n        return dlg.success", "is_method": true, "class_name": "RaspberryPiPicoBackendProxy", "function_description": "Initiates a user-facing dialog to propose and guide the installation of firmware onto a Raspberry Pi Pico. It returns whether the firmware flashing operation was successful."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_has_flashing_dialog", "line_number": 48, "body": "def _has_flashing_dialog(self):\n        return True", "is_method": true, "class_name": "RaspberryPiPicoBackendConfigPage", "function_description": "This method indicates that the `RaspberryPiPicoBackendConfigPage` always includes a flashing dialog. It serves as a static flag for UI or feature availability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_open_flashing_dialog", "line_number": 51, "body": "def _open_flashing_dialog(self):\n        dlg = PicoFlashingDialog(self.winfo_toplevel())\n        ui_utils.show_dialog(dlg)", "is_method": true, "class_name": "RaspberryPiPicoBackendConfigPage", "function_description": "Opens a dedicated dialog window to facilitate the firmware flashing process for a Raspberry Pi Pico device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "get_instructions", "line_number": 57, "body": "def get_instructions(self) -> Optional[str]:\n        return (\n            \"Here you can install or update MicroPython firmware on Raspberry Pi Pico.\\n\"\n            \"\\n\"\n            \"1. Plug in your Pico while holding the BOOTSEL button.\\n\"\n            \"2. Wait until device information appears.\\n\"\n            \"3. Click 'Install'.\\n\"\n            \"\\n\"\n            \"When the process finishes, your Pico will be running the latest version of\\n\"\n            \"MicroPython. Close the dialog and start programming!\"\n        )", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "Provides step-by-step instructions for installing or updating MicroPython firmware on a Raspberry Pi Pico."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_get_release_info_url", "line_number": 69, "body": "def _get_release_info_url(self):\n        return \"https://raw.githubusercontent.com/thonny/thonny/master/data/rpi-pico-firmware.json\"", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "Provides the URL to the official Raspberry Pi Pico firmware release information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "get_download_url_and_size", "line_number": 72, "body": "def get_download_url_and_size(self, board_id):\n        if self._release_info is None:\n            return None\n\n        logger.info(\n            \"Assets from %s: %r\", self._get_release_info_url(), self._release_info[\"assets\"]\n        )\n        candidates = self._release_info[\"assets\"]\n\n        if len(candidates) == 0:\n            raise RuntimeError(\n                \"Could not find the right file from the release info (%s)\"\n                % self._get_release_info_url()\n            )\n        else:\n            # The json is meant for Thonny, so take the first one for now\n            return (candidates[0][\"browser_download_url\"], candidates[0][\"size\"])", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "Retrieves the download URL and file size of the primary firmware asset from pre-fetched release information. This prepares for the actual download needed for device flashing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_is_relevant_board_id", "line_number": 91, "body": "def _is_relevant_board_id(cls, board_id):\n        return \"RPI\" in board_id", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "This method determines if a given board ID corresponds to a Raspberry Pi (RPI) device. It identifies relevant boards for operations within the Pico Flashing Dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "get_title", "line_number": 94, "body": "def get_title(self):\n        return \"Install MicroPython firmware for Raspberry Pi Pico\"", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "Provides the fixed title string for the Pico Flashing dialog window. This clearly describes the dialog's purpose to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/__init__.py", "function": "_get_vid_pids_to_wait_for", "line_number": 97, "body": "def _get_vid_pids_to_wait_for(self):\n        return RaspberryPiPicoBackendProxy.get_known_usb_vids_pids()", "is_method": true, "class_name": "PicoFlashingDialog", "function_description": "Provides the specific USB Vendor and Product IDs (VIDs/PIDs) for known Raspberry Pi Pico devices. This enables the dialog to detect devices during flashing operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/rpi_pico_backend.py", "function": "_sync_time", "line_number": 11, "body": "def _sync_time(self):\n        \"\"\"Sets the time to match the time on the host.\"\"\"\n\n        logger.info(\"Syncing time in Pico\")\n\n        # RTC works on UTC\n        now = self._get_time_for_rtc()\n\n        specific_script = dedent(\n            \"\"\"\n            try:\n                __th_dt_ts = {datetime_ts}\n                from machine import RTC as __thonny_RTC\n                try:\n                    __thonny_RTC().datetime(__th_dt_ts)\n                except:\n                    __thonny_RTC().init({init_ts})\n                del __thonny_RTC\n            except ImportError:\n                assert __thonny_helper.os.uname().sysname == 'rp2'\n                from machine import mem32 as __th_mem32\n                __th_mem32[0x4005c004] =  __th_dt_ts[0] << 12 | __th_dt_ts[1] << 8 | __th_dt_ts[2]\n                __th_mem32[0x4005c008] = (__th_dt_ts[3] % 7) << 24 | __th_dt_ts[4] << 16 | __th_dt_ts[5] << 8 | __th_dt_ts[6]\n                __th_mem32[0x4005c00c] |= 0x10\n                del __th_mem32\n            finally:\n                del __th_dt_ts\n                    \n        \"\"\"\n        ).format(\n            datetime_ts=(\n                now.tm_year,\n                now.tm_mon,\n                now.tm_mday,\n                now.tm_wday + 1,\n                now.tm_hour,\n                now.tm_min,\n                now.tm_sec,\n                0,\n            ),\n            init_ts=tuple(now)[:6] + (0, 0),\n        )\n\n        script = (\n            dedent(\n                \"\"\"\n            try:\n            %s\n                __thonny_helper.print_mgmt_value(True)\n            except Exception as e:\n                import sys\n                sys.print_exception(e)\n                __thonny_helper.print_mgmt_value(str(e))\n        \"\"\"\n            )\n            % indent(specific_script, \"    \")\n        )\n\n        val = self._evaluate(script)\n        if isinstance(val, str):\n            print(\"WARNING: Could not sync device's clock: \" + val)", "is_method": true, "class_name": "RaspberryPiPicoBackend", "function_description": "Sets the Raspberry Pi Pico's Real-Time Clock to match the host machine's current time. This ensures accurate timekeeping on the device for functions like logging or scheduling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/api_stubs/builtins.py", "function": "globals", "line_number": 356, "body": "def globals():\n    pass", "is_method": false, "function_description": "Returns a dictionary representing the current global symbol table. This provides access to all global variables and functions within the current module."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/api_stubs/builtins.py", "function": "clear", "line_number": 258, "body": "def clear():\n        pass", "is_method": true, "class_name": "dict", "function_description": "Removes all key-value pairs from the dictionary, making it empty. It provides the capability to reset the dictionary's contents."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/api_stubs/builtins.py", "function": "clear", "line_number": 530, "body": "def clear():\n        pass", "is_method": true, "class_name": "set", "function_description": "Removes all elements from the set. This method provides a way to reset the set to an empty state for reuse."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/rpi_pico/api_stubs/builtins.py", "function": "islower", "line_number": 625, "body": "def islower():\n        pass", "is_method": true, "class_name": "str", "function_description": "Checks if all cased characters in the string are lowercase and if there is at least one cased character. Useful for validating string content."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_resolve_executable", "line_number": 71, "body": "def _resolve_executable(self, executable):\n        result = self._which(executable)\n        if result:\n            return result\n        else:\n            msg = \"Executable '%s' not found. Please check your configuration!\" % executable\n            if not executable.startswith(\"/\"):\n                msg += \" You may need to provide its absolute path.\"\n            raise ConnectionFailedException(msg)", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Resolves the full path of a specified executable on the Unix system. It ensures that necessary external tools are found, raising an error if the executable is not located."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_tweak_welcome_text", "line_number": 87, "body": "def _tweak_welcome_text(self, original: str) -> str:\n        return (\n            original.replace(\"Use Ctrl-D to exit, Ctrl-E for paste mode\\n\", \"\").strip()\n            + \" (\"\n            + self._interpreter\n            + \")\\n\"\n        )", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Customizes the MicroPython interpreter's welcome message. It removes standard exit instructions and appends the interpreter name for a clearer display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_get_custom_helpers", "line_number": 95, "body": "def _get_custom_helpers(self):\n        return textwrap.dedent(\n            \"\"\"\n            # https://github.com/pfalcon/pycopy-lib/blob/master/os/os/__init__.py\n            \n            import ffi\n            \n            libc = ffi.open(\n                \"libc.so.6\" if sys.platform == \"linux\" else \"libc.dylib\"\n            )\n            \n            @classmethod\n            def check_error(cls, ret):\n                if ret == -1:\n                    raise OSError(cls.os.errno())\n            \n            _getcwd = libc.func(\"s\", \"getcwd\", \"si\")\n            @classmethod\n            def getcwd(cls):\n                buf = bytearray(512)\n                return cls._getcwd(buf, 512)\n\n            _chdir = libc.func(\"i\", \"chdir\", \"s\")\n            @classmethod\n            def chdir(cls, dir):\n                r = cls._chdir(dir)\n                cls.check_error(r)\n            \n            _rmdir = libc.func(\"i\", \"rmdir\", \"s\")\n            @classmethod\n            def rmdir(cls, name):\n                e = cls._rmdir(name)\n                cls.check_error(e)                                    \n            \"\"\"\n        )", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Provides a string of Python code that defines core OS file system helpers (getcwd, chdir, rmdir) using FFI. This enables essential Unix-like functionality within the MicroPython backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_process_until_initial_prompt", "line_number": 131, "body": "def _process_until_initial_prompt(self, clean):\n        # This will be called only when the interpreter gets run without script.\n        # (%Run script.py does not create a new instance of this class)\n        output = []\n\n        def collect_output(data, stream_name):\n            output.append(data)\n\n        self._report_time(\"befini\")\n        self._forward_output_until_active_prompt(collect_output, \"stdout\")\n        self._original_welcome_text = \"\".join(output).replace(\"\\r\\n\", \"\\n\")\n        self._welcome_text = self._tweak_welcome_text(self._original_welcome_text)\n        self._report_time(\"afini\")", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "This method captures and processes the initial welcome banner and prompt displayed by the MicroPython interpreter when it starts interactively, storing a tweaked version for internal use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_fetch_builtin_modules", "line_number": 145, "body": "def _fetch_builtin_modules(self):\n        return FALLBACK_BUILTIN_MODULES", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Provides a predefined list of fallback built-in modules. This ensures the Unix MicroPython backend has a default set when dynamic retrieval is not possible."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_execute_with_consumer", "line_number": 148, "body": "def _execute_with_consumer(\n        self, script: str, output_consumer: Callable[[str, str], None]\n    ) -> None:\n        \"\"\"Ensures prompt and submits the script.\n        Returns (out, value_repr, err) if there are no problems, ie. all parts of the\n        output are present and it reaches active prompt.\n        Otherwise raises ManagementError.\n\n        The execution may block. In this case the user should do something (eg. provide\n        required input or issue an interrupt). The UI should remind the interrupt in case\n        of Thonny commands.\n        \"\"\"\n        end_marker = \"#uIuIu\"\n        self._connection.write(PASTE_MODE_CMD)\n        self._connection.read_until(PASTE_MODE_LINE_PREFIX)\n        self._connection.write(script + end_marker)\n        self._connection.read_until(end_marker.encode(\"ascii\"))\n        self._connection.write(EOT)\n        self._connection.read_until(b\"\\n\")\n\n        out = self._connection.read_until(NORMAL_PROMPT)[: -len(NORMAL_PROMPT)]\n        output_consumer(self._decode(out), \"stdout\")", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Executes a given MicroPython script on the backend. It captures the standard output of the script's execution and delivers it to a provided consumer function for processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_forward_output_until_active_prompt", "line_number": 171, "body": "def _forward_output_until_active_prompt(\n        self, output_consumer: Callable[[str, str], None], stream_name=\"stdout\"\n    ):\n        INCREMENTAL_OUTPUT_BLOCK_CLOSERS = re.compile(\n            b\"|\".join(map(re.escape, [LF, NORMAL_PROMPT]))\n        )\n\n        pending = b\"\"\n        while True:\n            # There may be an input submission waiting\n            # and we can't progress without resolving it first\n            self._check_for_side_commands()\n\n            # Prefer whole lines, but allow also incremental output to single line\n            new_data = self._connection.soft_read_until(\n                INCREMENTAL_OUTPUT_BLOCK_CLOSERS, timeout=0.05\n            )\n            if not new_data:\n                continue\n\n            pending += new_data\n\n            if pending.endswith(LF):\n                output_consumer(self._decode(pending), stream_name)\n                pending = b\"\"\n\n            elif pending.endswith(NORMAL_PROMPT):\n                out = pending[: -len(NORMAL_PROMPT)]\n                output_consumer(self._decode(out), stream_name)\n                return NORMAL_PROMPT\n\n            elif ends_overlap(pending, NORMAL_PROMPT):\n                # Maybe we have a prefix of the prompt and the rest is still coming?\n                follow_up = self._connection.soft_read(1, timeout=0.1)\n                if not follow_up:\n                    # most likely not a Python prompt, let's forget about it\n                    output_consumer(self._decode(pending), stream_name)\n                    pending = b\"\"\n                else:\n                    # Let's withhold this for now\n                    pending += follow_up\n\n            else:\n                # No prompt in sight.\n                # Output and keep working.\n                output_consumer(self._decode(pending), stream_name)\n                pending = b\"\"", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "This method reads and forwards output from a MicroPython backend connection to a consumer. It continues until a prompt is detected, signaling the backend is ready for further commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_forward_unexpected_output", "line_number": 219, "body": "def _forward_unexpected_output(self, stream_name=\"stdout\"):\n        \"Invoked between commands\"\n        data = self._connection.read_all()\n        if data.endswith(NORMAL_PROMPT):\n            out = data[: -len(NORMAL_PROMPT)]\n        else:\n            out = data\n        self._send_output(self._decode(out), \"stdout\")", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Forwards background or asynchronous output from the MicroPython device. It removes trailing command prompts to ensure only clean program output is presented."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_write", "line_number": 228, "body": "def _write(self, data):\n        self._connection.write(data)", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Writes raw data to the underlying communication connection, enabling direct data transfer to the MicroPython backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_cmd_Run", "line_number": 231, "body": "def _cmd_Run(self, cmd):\n        self._connection.close()\n        self._report_time(\"befconn\")\n        args = cmd.args\n        if cmd.source and args[0] == \"-c\":\n            if len(args) > 1:\n                self._send_error_message(\n                    \"Warning: MicroPython doesn't allow program arguments (%s) together with '-c'\"\n                    % \" \".join(map(shlex.quote, args[1:]))\n                )\n            args = [\"-c\", cmd.source]\n\n        self._connection = self._create_connection(args)\n        self._report_time(\"afconn\")\n        self._forward_output_until_active_prompt(self._send_output, \"stdout\")\n        self._report_time(\"afforv\")\n        self.send_message(\n            BackendEvent(event_type=\"HideTrailingOutput\", text=self._original_welcome_text)\n        )\n        self._report_time(\"beffhelp\")\n        self._prepare_after_soft_reboot()\n        self._report_time(\"affhelp\")", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Provides the core functionality to execute a MicroPython command or script by managing the backend connection and preparing the environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_cmd_execute_system_command", "line_number": 254, "body": "def _cmd_execute_system_command(self, cmd):\n        assert cmd.cmd_line.startswith(\"!\")\n        cmd_line = cmd.cmd_line[1:]\n        # \"or None\" in order to avoid MP repl to print its value\n        self._execute(\"__thonny_helper.os.system(%r) or None\" % cmd_line)", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "This method executes a host system command through the MicroPython backend by leveraging `os.system`. It provides a way to run shell commands from within the MicroPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_cmd_get_fs_info", "line_number": 261, "body": "def _cmd_get_fs_info(self, cmd):\n        script = \"\"\"__thonny_helper.os.system(\"stat -f -c '%b %f %a %S' {path}\") or None\"\"\".format(\n            path=cmd.path\n        )\n        out, err = self._execute(script, capture_output=True)\n\n        try:\n            total, free, available, block_size = map(int, out.strip().split())\n            return {\n                \"total\": total * block_size,\n                \"free\": available * block_size,\n                \"used\": (total - free) * block_size,\n            }\n        except Exception:\n            raise ManagementError(script, out, err)", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "This method retrieves file system usage information (total, free, used bytes) for a specified path on a MicroPython device. It provides essential data for managing storage."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_is_connected", "line_number": 277, "body": "def _is_connected(self):\n        return not self._connection._error", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Verifies if the connection to the MicroPython backend is currently error-free. It indicates whether the underlying communication link is operational."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_get_epoch_offset", "line_number": 280, "body": "def _get_epoch_offset(self) -> int:\n        try:\n            return super()._get_epoch_offset()\n        except NotImplementedError:\n            return 0", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Retrieves the system's epoch offset. It provides a default value of zero if the base implementation does not define one, ensuring consistent time references."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_resolve_unknown_epoch", "line_number": 286, "body": "def _resolve_unknown_epoch(self) -> int:\n        return 1970", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "This method provides the standard Unix epoch year (1970) as a default value when the actual epoch cannot be determined."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_sync_time", "line_number": 289, "body": "def _sync_time(self):\n        self._show_error(\"WARNING: Automatic time synchronization by Thonny is not supported.\")", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "This method displays a warning message to the user, indicating that automatic time synchronization is not supported by Thonny."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_get_utc_timetuple_from_device", "line_number": 292, "body": "def _get_utc_timetuple_from_device(self) -> Union[tuple, str]:\n        out, err = self._execute(\"__thonny_helper.os.system('date -u +%s')\", capture_output=True)\n        if err:\n            return err\n\n        if not out:\n            return \"Failed querying device's UTC time\"\n\n        try:\n            secs = int(out.splitlines()[0].strip())\n            return tuple(time.gmtime(secs))\n        except Exception as e:\n            return str(e)", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "Retrieves the current UTC time from the connected Unix-based MicroPython device. It returns the time as a standard Python time tuple."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_create_connection", "line_number": 308, "body": "def _create_connection(self, run_args=[]):\n        from thonny.plugins.micropython.subprocess_connection import SubprocessConnection\n\n        return SubprocessConnection(self._interpreter, [\"-i\"] + run_args)", "is_method": true, "class_name": "LocalUnixMicroPythonBackend", "function_description": "Establishes a subprocess connection to the local MicroPython interpreter. This enables the backend to communicate with the MicroPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_which", "line_number": 313, "body": "def _which(self, executable):\n        import shutil\n\n        return shutil.which(executable)", "is_method": true, "class_name": "LocalUnixMicroPythonBackend", "function_description": "This method locates the full path of a specified executable program within the system's PATH, ensuring external tools are discoverable for the backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_cmd_cd", "line_number": 318, "body": "def _cmd_cd(self, cmd):\n        result = super()._cmd_cd(cmd)\n        os.chdir(self._cwd)\n        return result", "is_method": true, "class_name": "LocalUnixMicroPythonBackend", "function_description": "Manages a change directory command by updating the actual operating system's current working directory to match the backend's internal state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_get_sep", "line_number": 323, "body": "def _get_sep(self) -> str:\n        return os.path.sep", "is_method": true, "class_name": "LocalUnixMicroPythonBackend", "function_description": "Provides the operating system's standard path separator character. This is useful for constructing or parsing file paths correctly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_decode", "line_number": 326, "body": "def _decode(self, data: bytes) -> str:\n        return data.decode(errors=\"replace\")", "is_method": true, "class_name": "LocalUnixMicroPythonBackend", "function_description": "Converts raw byte data into a string, replacing decoding errors. It provides a textual representation of binary input for backend processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_which", "line_number": 337, "body": "def _which(self, executable):\n        cmd_str = \" \".join(map(shlex.quote, [\"which\", executable]))\n        _, stdout, _ = self._client.exec_command(cmd_str, bufsize=0, timeout=3, get_pty=False)\n        return stdout.readline().strip() or None", "is_method": true, "class_name": "SshUnixMicroPythonBackend", "function_description": "Locates the full path of a specified executable on the remote Unix-like system managed by this SSH backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_create_connection", "line_number": 342, "body": "def _create_connection(self, run_args=[]):\n        # NB! It's connection to the micropython process, not to the host\n        from thonny.plugins.micropython.ssh_connection import SshProcessConnection\n\n        return SshProcessConnection(self._client, self._cwd, self._interpreter, [\"-i\"] + run_args)", "is_method": true, "class_name": "SshUnixMicroPythonBackend", "function_description": "Establishes an SSH connection specifically to a remote MicroPython process. It provides the necessary connection object to interact with the interpreter."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_tweak_welcome_text", "line_number": 348, "body": "def _tweak_welcome_text(self, original):\n        return (\n            super()._tweak_welcome_text(original).strip()\n            + \"\\n\"\n            + self._user\n            + \"@\"\n            + self._host\n            + \"\\n\"\n        )", "is_method": true, "class_name": "SshUnixMicroPythonBackend", "function_description": "Enhances the SSH backend's welcome text by appending the current user and host information for connection context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_get_sep", "line_number": 358, "body": "def _get_sep(self) -> str:\n        return \"/\"", "is_method": true, "class_name": "SshUnixMicroPythonBackend", "function_description": "Provides the Unix-style path separator character ('/') for file system operations on the MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "_decode", "line_number": 361, "body": "def _decode(self, data: bytes) -> str:\n        return data.decode(ENCODING, errors=\"replace\")", "is_method": true, "class_name": "SshUnixMicroPythonBackend", "function_description": "Converts byte data, typically from an SSH connection, into a human-readable string. It ensures robust decoding by replacing unrepresentable characters."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/os_mp_backend.py", "function": "collect_output", "line_number": 136, "body": "def collect_output(data, stream_name):\n            output.append(data)", "is_method": true, "class_name": "UnixMicroPythonBackend", "function_description": "This method adds provided data to an internal list, serving to collect output from the MicroPython backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "debug", "line_number": 168, "body": "def debug(*args, file=sys.stderr):\n    print(*args, file=file)", "is_method": false, "function_description": "Provides a utility to print debug messages to the standard error stream or a specified file. Useful for logging diagnostic information during development."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "write", "line_number": 82, "body": "def write(self, data):\n        size = self._serial.write(data)\n        # print(data.decode(), end=\"\")\n        assert size == len(data)\n        return len(data)", "is_method": true, "class_name": "SerialConnection", "function_description": "Provides the capability to transmit data bytes over the serial connection, ensuring all provided data is successfully written to the connected device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "_listen_serial", "line_number": 88, "body": "def _listen_serial(self):\n        \"NB! works in background thread\"\n        try:\n            data = b\"\"\n            while not self._reader_stopped:\n                data += self._serial.read(1)  # To avoid busy loop\n                if len(data) == 0:\n                    self._error = \"EOF\"\n                    # print(\"LISTEN EOFFFFFFFFFF\")\n                    break\n                data += self._serial.read_all()\n\n                # don't publish incomplete utf-8 data\n                try:\n                    if self.unicode_guard:\n                        data.decode(\"utf-8\")  # testing if data decodes\n                    to_be_published = data\n                    data = b\"\"\n                except UnicodeDecodeError as e:\n                    if e.start == 0:\n                        # Invalid start byte, ie. we have missed first byte(s) of the codepoint.\n                        # No use of waiting, output everything\n                        to_be_published = data\n                        data = b\"\"\n                    else:\n                        to_be_published = data[: e.start]\n                        data = data[e.start :]\n\n                if to_be_published:\n                    self._make_output_available(to_be_published)\n\n        except Exception as e:\n            self._error = str(e)", "is_method": true, "class_name": "SerialConnection", "function_description": "Continuously reads and processes incoming data from the serial port in a background thread. It ensures data integrity by handling Unicode decoding errors before making it available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "incoming_is_empty", "line_number": 122, "body": "def incoming_is_empty(self):\n        return self._serial.in_waiting == 0 and super().incoming_is_empty()", "is_method": true, "class_name": "SerialConnection", "function_description": "Determines if the serial port's incoming buffer, and any higher-level buffers, are entirely empty, signifying no pending data to process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "outgoing_is_empty", "line_number": 125, "body": "def outgoing_is_empty(self):\n        return self._serial.out_waiting == 0", "is_method": true, "class_name": "SerialConnection", "function_description": "Reports if the serial connection's outgoing buffer is empty, indicating all previously written data has been transmitted."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "reset_output_buffer", "line_number": 128, "body": "def reset_output_buffer(self):\n        self._serial.reset_output_buffer()", "is_method": true, "class_name": "SerialConnection", "function_description": "Clears the output buffer of the serial connection. This immediately stops any data currently queued for transmission from being sent."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "close", "line_number": 131, "body": "def close(self):\n        if self._serial is not None:\n            try:\n                self._serial.cancel_read()\n                if self._reading_thread:\n                    self._reading_thread.join()\n            finally:\n                try:\n                    self._serial.close()\n                    self._serial = None\n                except Exception:\n                    logging.exception(\"Couldn't close serial\")", "is_method": true, "class_name": "SerialConnection", "function_description": "Safely closes the serial port connection by canceling active reads and joining any reading threads. This ensures a complete and clean release of the communication resource."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/serial_connection.py", "function": "_make_output_available", "line_number": 148, "body": "def _make_output_available(self, data, block=True):\n\n        # output prompts in parts\n        if FIRST_RAW_PROMPT in data or NORMAL_PROMPT in data:\n            if FIRST_RAW_PROMPT in data:\n                start = data.find(FIRST_RAW_PROMPT)\n                end = start + len(FIRST_RAW_PROMPT)\n            else:\n                start = data.find(NORMAL_PROMPT)\n                end = start + len(NORMAL_PROMPT)\n\n            super()._make_output_available(data[: start + 1], block=block)\n            time.sleep(0.1)\n            super()._make_output_available(data[start + 1 : end - 1], block=block)\n            time.sleep(0.1)\n            super()._make_output_available(data[end - 1 :], block=block)\n        else:\n            super()._make_output_available(data, block=block)", "is_method": true, "class_name": "DifficultSerialConnection", "function_description": "Provides controlled output transmission for challenging serial connections. It specifically fragments and delays data containing prompts to ensure reliable communication with the connected device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "soft_read", "line_number": 30, "body": "def soft_read(self, size, timeout=1):\n        return self.read(size, timeout, True)", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Facilitates reading data from the MicroPython connection in a \"soft\" or specific mode. It enables a distinct data retrieval behavior from the connected device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "read", "line_number": 33, "body": "def read(self, size, timeout=10, timeout_is_soft=False):\n        if timeout == 0:\n            if timeout_is_soft:\n                return b\"\"\n            else:\n                raise TimeoutError()\n\n        timer = TimeHelper(timeout)\n\n        while len(self._read_buffer) < size:\n            self._check_for_error()\n\n            try:\n                self._read_buffer.extend(self._read_queue.get(True, timer.time_left))\n            except queue.Empty:\n                if timeout_is_soft:\n                    return b\"\"\n                else:\n                    raise TimeoutError(\"Reaction timeout. Bytes read: %s\" % self._read_buffer)\n\n        try:\n            data = self._read_buffer[:size]\n            return data\n        finally:\n            del self._read_buffer[:size]", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "This method reads a specified number of bytes from the MicroPython connection's input buffer. It handles timeouts strictly or softly, ensuring reliable data retrieval or appropriate error signaling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "soft_read_until", "line_number": 59, "body": "def soft_read_until(self, terminator, timeout=1000000):\n        return self.read_until(terminator, timeout, timeout_is_soft=True)", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Reads data from the MicroPython connection until a specified terminator, applying a soft timeout. This allows for more tolerant handling of communication, preventing premature timeouts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "read_until", "line_number": 62, "body": "def read_until(self, terminator, timeout=1000000, timeout_is_soft=False):\n        timer = TimeHelper(timeout)\n\n        if isinstance(terminator, str):\n            terminator = re.compile(re.escape(terminator))\n\n        match = None\n        while True:\n            self._check_for_error()\n\n            match = re.search(terminator, self._read_buffer)\n            if match:\n                break\n\n            try:\n                data = self._read_queue.get(True, timer.time_left)\n                # print(\"RR\", repr(data), file=sys.stderr)\n                assert len(data) > 0\n                self._read_buffer.extend(data)\n            except queue.Empty:\n                if timeout_is_soft:\n                    break\n                else:\n                    raise TimeoutError(\"Reaction timeout. Bytes read: %s\" % self._read_buffer)\n\n        if match:\n            size = match.end()\n        else:\n            assert timeout_is_soft\n            size = len(self._read_buffer)\n\n        data = self._read_buffer[:size]\n        del self._read_buffer[:size]\n        return data", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Reads incoming data from the MicroPython device until a specified terminator pattern is found or a timeout occurs. It handles connection errors during the read process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "_fetch_to_buffer", "line_number": 97, "body": "def _fetch_to_buffer(self):\n        while not self._read_queue.empty():\n            self._read_buffer.extend(self._read_queue.get(True))", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "An internal utility method that transfers all available data from an internal read queue to a consolidated read buffer. It prepares incoming bytes for subsequent processing by the connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "peek_incoming", "line_number": 101, "body": "def peek_incoming(self):\n        self._fetch_to_buffer()\n        return self._read_buffer", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Provides a non-consuming view of all currently buffered incoming data from the MicroPython connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "read_all", "line_number": 105, "body": "def read_all(self, check_error=True):\n        self._fetch_to_buffer()\n\n        if len(self._read_buffer) == 0 and check_error:\n            self._check_for_error()\n\n        try:\n            return self._read_buffer\n        finally:\n            self._read_buffer = bytearray()", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Retrieves all available data from the MicroPython device connection. It returns the data and clears the internal buffer for subsequent operations, optionally checking for errors.\nChain of Thought:\nThe user wants a concise description of the `read_all` method within the `MicroPythonConnection` class.\nI need to focus on *what* it does, not *how*.\nThe description must be less than 40 words and at most 2 sentences.\n\n1.  **Understand the context:** `MicroPythonConnection` suggests this class manages a connection to a MicroPython device.\n2.  **Analyze the method name:** `read_all` implies reading all available data.\n3.  **Examine the code:**\n    *   `self._fetch_to_buffer()`: This likely populates an internal buffer with data from the connection.\n    *   `if len(self._read_buffer) == 0 and check_error: self._check_for_error()`: If no data was read and `check_error` is true, it checks for an error. This implies it's trying to ensure data is actually present or an error explains its absence.\n    *   `return self._read_buffer`: It returns the content of the buffer.\n    *   `finally: self._read_buffer = bytearray()`: This is crucial. It clears the buffer after reading, meaning it's a \"read once and clear\" operation.\n\n4.  **Primary purpose:** The function's main job is to read all data currently available from the MicroPython connection into a buffer, return it, and then clear the buffer for the next read. It also includes error checking.\n\n5.  **What service/capability does it provide?** It provides the ability to retrieve all buffered data from the MicroPython device, ensuring the buffer is ready for subsequent reads. It's a way to get the full response from the device.\n\n6.  **Drafting descriptions:**\n    *   \"Reads all available data from the MicroPython connection, returns it, and clears the internal buffer. It also checks for errors if no data is found.\" (Too long, 25 words, fits within limits)\n    *   \"Retrieves all data currently available from the MicroPython device's connection buffer. It returns the data and then clears the buffer for future reads, optionally checking for errors.\" (32 words)\n    *   \"Fetches all available data from the MicroPython connection, returning it and clearing the internal buffer for the next operation. Includes optional error checking.\" (26 words)\n\n7.  **Refine for conciseness and clarity:**\n    *   \"Retrieves all available data from the MicroPython device connection's buffer. It returns the data, then clears the buffer for subsequent operations, with optional error checking.\"\n    *   \"Retrieves all available data from the MicroPython device connection. It returns the data and clears the internal buffer for future operations, optionally checking for errors.\" (28 words) - This seems good.\n\nLet's try to make it even more direct about the \"service\":\n\"Retrieves all available data from the MicroPython device connection. It returns the data and clears the internal buffer for subsequent operations, optionally checking for errors.\"\nRetrieves all available data from the MicroPython device connection. It returns the data and clears the internal buffer for subsequent operations, optionally checking for errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "read_all_expected", "line_number": 116, "body": "def read_all_expected(self, expected, timeout=None):\n        actual = self.read(len(expected), timeout=timeout)\n        actual += self.read_all()\n        assert expected == actual, \"Expected %r, got %r\" % (expected, actual)", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "This method reads all available data from the MicroPython device, asserting that the received content exactly matches a given expected sequence. It ensures precise data reception for communication validation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "_check_for_error", "line_number": 121, "body": "def _check_for_error(self):\n        if self._error is None:\n            return\n\n        raise ConnectionClosedException(self._error)", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Checks for a stored connection error within the connection object. If an error exists, it raises a `ConnectionClosedException` to signal a closed or failed connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "unread", "line_number": 127, "body": "def unread(self, data):\n        if not data:\n            return\n\n        if isinstance(data, str):\n            data = data.encode(self.encoding)\n        elif isinstance(data, bytes):\n            data = bytearray(data)\n\n        self._read_buffer = data + self._read_buffer", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "This method places provided data back into the connection's internal read buffer. It effectively \"unreads\" data, ensuring it is available for subsequent reading operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "_log_data", "line_number": 141, "body": "def _log_data(self, data):\n        print(\n            data.decode(self.encoding, errors=\"replace\")\n            .replace(\"\\r\\n\", \"\\n\")\n            .replace(\"\\x01\", \"\u2460\")\n            .replace(\"\\x02\", \"\u2461\")\n            .replace(\"\\x03\", \"\u2462\")\n            .replace(\"\\x04\", \"\u2463\"),\n            end=\"\",\n        )", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "This method formats raw byte data received from the MicroPython connection into a readable string. It replaces control characters with symbols for clear console output.\nThis method formats raw byte data received from the MicroPython connection into a readable string. It replaces control characters with symbols for clear console output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "_make_output_available", "line_number": 152, "body": "def _make_output_available(self, data, block=True):\n        # self._log_data(data)\n        if data:\n            self._read_queue.put(data, block=block)\n            self.num_bytes_received += len(data)", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "This internal method makes incoming data available for consumption by adding it to an internal read queue. It also tracks the total number of bytes received by the connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "incoming_is_empty", "line_number": 158, "body": "def incoming_is_empty(self):\n        return self._read_queue.empty() and len(self._read_buffer) == 0", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "This method checks if all incoming data from the MicroPython device has been processed. It indicates if the connection's read queue and buffer are entirely empty."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "buffers_are_empty", "line_number": 164, "body": "def buffers_are_empty(self):\n        return self.incoming_is_empty() and self.outgoing_is_empty()", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Determines if both the incoming and outgoing data buffers of the MicroPython connection are empty, indicating no pending data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "reset_input_buffer", "line_number": 167, "body": "def reset_input_buffer(self):\n        return self.read_all()", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "This method resets the MicroPython connection's input buffer. It clears all pending incoming data to ensure a clean state for subsequent communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "set_unicode_guard", "line_number": 173, "body": "def set_unicode_guard(self, value):\n        self.unicode_guard = value", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Sets the `unicode_guard` flag for the MicroPython connection instance. This enables configuration of Unicode handling behavior during device communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/connection.py", "function": "stop_reader", "line_number": 176, "body": "def stop_reader(self):\n        self._reader_stopped = True\n        self._read_queue = Queue()\n        self._read_buffer = bytearray()", "is_method": true, "class_name": "MicroPythonConnection", "function_description": "Stops the data reading process for the MicroPython connection. It sets a stop flag and clears all pending read data from buffers and queues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "read_line", "line_number": 56, "body": "def read_line(sock):\n    ret = b\"\"\n    while True:\n        c = sock.recv(1)\n        if c == b\"\":\n            break\n        elif c == b\"\\n\":\n            ret += c\n            break\n        else:\n            ret += c\n    return ret", "is_method": false, "function_description": "Reads a single line of bytes from a network socket until a newline or end of stream. It provides a way to process line-delimited data from a connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "read_lines", "line_number": 71, "body": "def read_lines(sock):\n    s = b\"\"\n    while True:\n        s1 = read_line(sock)\n        s += s1\n        if s1 == b\"\\r\\n\" or s1 == b\"\":\n            break\n    return s", "is_method": false, "function_description": "Reads and concatenates multiple lines from a given socket connection. The process stops upon encountering an empty line or end of stream, returning the complete block of data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "_makedirs", "line_number": 82, "body": "def _makedirs(name):\n    dirname = os.path.dirname(name)\n\n    def split_path(lst, path):\n        q = os.path.split(path)\n        if q[1] != \"\":\n            lst.append(q[1])\n            split_path(lst, q[0])\n\n    lst = []\n    split_path(lst, dirname)\n    lst.reverse()\n    mypath = os.path.abspath(\"/\")\n    for elem in lst:\n        mypath = os.path.join(mypath, elem)\n        if not os.path.exists(mypath):\n            try:\n                os.mkdir(mypath)\n            except OSError as e:\n                if e.args[0] != errno.EEXIST and e.args[0] != errno.EISDIR:\n                    raise", "is_method": false, "function_description": "This utility function ensures that all intermediate directories in the path leading to a given file `name` exist. It creates missing directories one by one, suppressing errors if a directory already exists.\nThis utility function ensures that all intermediate directories in the path leading to a given file `name` exist. It creates missing directories one by one, suppressing errors if a directory already exists."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "install_tar", "line_number": 105, "body": "def install_tar(f, prefix):\n    meta = {}\n    for info in f:\n        # print(info)\n        fname = info.name\n        try:\n            fname = fname[fname.index(\"/\") + 1 :]\n        except ValueError:\n            fname = \"\"\n\n        save = True\n        for p in (\"setup.\", \"PKG-INFO\", \"README\"):\n            # print(fname, p)\n            if fname.startswith(p) or \".egg-info\" in fname:\n                if fname.endswith(\"/requires.txt\"):\n                    meta[\"deps\"] = f.extractfile(info).read()\n                save = False\n                if debug:\n                    print(\"Skipping\", fname)\n                break\n\n        if save:\n            outfname = prefix + fname\n            if info.type != tarfile.DIRTYPE:\n                if debug:\n                    print(\"Extracting \" + outfname)\n                _makedirs(outfname)\n                subf = f.extractfile(info)\n                with open(outfname, \"wb\") as outf:\n                    outf.write(subf.read())\n    return meta", "is_method": false, "function_description": "Extracts source files from a tar archive into a specified directory. It intelligently skips common metadata files while optionally capturing dependency information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "url_open", "line_number": 141, "body": "def url_open(url):\n    global warn_ussl\n\n    if debug:\n        print(url)\n\n    proto, _, host, urlpath = url.split(\"/\", 3)\n    try:\n        ai = usocket.getaddrinfo(host, 443)\n    except OSError as e:\n        print(\"Unable to resolve %s (no Internet?)\" % host)\n        raise\n    addr = ai[0][4]\n    s = usocket.socket(ai[0][0])\n    try:\n        if proto == \"https:\":\n            s = ussl.wrap_socket(s)\n            if warn_ussl:\n                print(\"Warning: %s SSL certificate is not validated\" % host)\n                warn_ussl = False\n        s.connect(addr)\n        s.setblocking(True)\n\n        s.send((\"GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n\" % (urlpath, host)).encode(\"UTF8\"))\n        l = read_line(s)\n        protover, status, msg = l.split(None, 2)\n        if status != b\"200\":\n            if status == b\"404\" or status == b\"301\":\n                raise NotFoundError(\"Package not found\")\n            raise ValueError(status)\n        while 1:\n            l = read_line(s)\n            if not l:\n                raise ValueError(\"Unexpected EOF in HTTP headers\")\n            if l == b\"\\r\\n\":\n                break\n    except Exception as e:\n        s.close()\n        raise e\n\n    return s", "is_method": false, "function_description": "Establishes a low-level HTTP or HTTPS connection to a given URL and sends a GET request. It returns the raw socket object after processing response headers, enabling direct reading of the content body."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "get_pkg_metadata", "line_number": 185, "body": "def get_pkg_metadata(pkg_spec):\n    if \"==\" in pkg_spec:\n        name, ver = pkg_spec.split(\"==\", maxsplit=1)\n        f = url_open(\"https://pypi.org/pypi/%s/%s/json\" % (name, ver))\n    else:\n        try:\n            f = url_open(MICROPYTHON_ORG_JSON % pkg_spec)\n        except:\n            f = url_open(\"https://pypi.org/pypi/%s/json\" % pkg_spec)\n    s = read_lines(f)\n    try:\n        return json.loads(s.decode(\"UTF8\"))\n    finally:\n        f.close()", "is_method": false, "function_description": "This function retrieves detailed metadata for a specified Python package from PyPI or MicroPython.org. It parses and returns the package information as a JSON object.\nThis function retrieves detailed metadata for a specified Python package from PyPI or MicroPython.org. It parses and returns the package information as a JSON object."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "fatal", "line_number": 201, "body": "def fatal(msg):\n    print(\"Error:\", msg)\n    sys.exit(1)", "is_method": false, "function_description": "Reports a critical error by printing a message to the console. It then immediately terminates the program with an error exit code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "install_pkg", "line_number": 206, "body": "def install_pkg(pkg_spec, install_path):\n    data = get_pkg_metadata(pkg_spec)\n\n    latest_ver = data[\"info\"][\"version\"]\n    packages = data[\"releases\"][latest_ver]\n    assert len(packages) == 1, \"This doesn't look like MicroPython package\"\n    package_url = packages[0][\"url\"]\n    print(\"Installing %s %s from %s\" % (pkg_spec, latest_ver, package_url))\n    f1 = url_open(package_url)\n    s = read_lines(f1)\n    try:\n        str1 = zlib.decompress(s, gzdict_sz)\n        with tempfile.TemporaryFile() as temp_file:\n            temp_file.write(str1)\n            temp_file.seek(0)\n            with tarfile.TarFile(fileobj=temp_file) as tar_file:  # Expects a file object\n                meta = install_tar(tar_file, install_path)\n    finally:\n        f1.close()\n    return meta", "is_method": false, "function_description": "Installs a specified MicroPython package. It handles retrieving metadata, downloading the compressed archive, and extracting its contents to the target directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "install", "line_number": 228, "body": "def install(to_install):\n    install_path = g_install_path\n    install_path = os.path.join(install_path, \"\")  # Append final /\n    if not isinstance(to_install, list):\n        to_install = [to_install]\n    print(\"Installing to: \" + install_path)\n    # sets would be perfect here, but don't depend on them\n    installed = []\n    try:\n        while to_install:\n            if debug:\n                print(\"Queue:\", to_install)\n            pkg_spec = to_install.pop(0)\n            if pkg_spec in installed:\n                continue\n            meta = install_pkg(pkg_spec, install_path)\n            installed.append(pkg_spec)\n            if debug:\n                print(meta)\n            deps = meta.get(\"deps\", \"\").rstrip()\n            if deps:\n                deps = deps.decode(\"utf-8\").split(\"\\n\")\n                to_install.extend(deps)\n        return True\n    except Exception as e:\n        print(\n            \"Error installing '{}': {}\".format(pkg_spec, e),\n            file=sys.stderr,\n        )\n        return False", "is_method": false, "function_description": "Installs specified packages and their dependencies to a designated path. It manages the installation process, ensuring all required components are set up correctly."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "help_msg", "line_number": 260, "body": "def help_msg():\n    print(\n        \"\"\"\\\nmicropip - Simple PyPI package manager for MicroPython\nRuns on a PC under Python 3.2 or above, and installs to a PC directory for\nsubsequent transfer to target hardware.\n\nUsage: micropip.py install [-p <path>] <package>... | -r <requirements.txt>\nThe above requires micropip.py to have executable permission.\nAlternatively: python3 -m micropip install [-p <path>] <package>... | -r <requirements.txt>\n\nIf <path> is not given, packages will be installed into the current directory.\n\nNote: only MicroPython packages (usually, named micropython-*) are supported\nfor installation, upip does not support arbitrary code in setup.py.\n\"\"\"\n    )", "is_method": false, "function_description": "Displays comprehensive usage instructions and detailed information for the `micropip` package manager. It provides guidance on installation commands and supported package types."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "main", "line_number": 279, "body": "def main():\n    global debug\n    global g_install_path\n\n    if len(sys.argv) < 2 or sys.argv[1] == \"-h\" or sys.argv[1] == \"--help\":\n        help_msg()\n        return\n\n    if sys.argv[1] != \"install\":\n        fatal(\"Only 'install' command supported\")\n\n    to_install = []\n\n    i = 2\n    while i < len(sys.argv) and sys.argv[i][0] == \"-\":\n        opt = sys.argv[i]\n        i += 1\n        if opt == \"-h\" or opt == \"--help\":\n            help_msg()\n            return\n        elif opt == \"-p\":\n            g_install_path = sys.argv[i]\n            i += 1\n        elif opt == \"-r\":\n            list_file = sys.argv[i]\n            i += 1\n            with open(list_file) as f:\n                while True:\n                    l = f.readline()\n                    if not l:\n                        break\n                    if l[0] == \"#\":\n                        continue\n                    to_install.append(l.rstrip())\n        elif opt == \"--debug\":\n            debug = True\n        else:\n            fatal(\"Unknown/unsupported option: \" + opt)\n\n    to_install.extend(sys.argv[i:])\n    if not to_install:\n        help_msg()\n        return\n\n    g_install_path = os.path.expanduser(g_install_path)\n    g_install_path = os.path.abspath(g_install_path)\n    if not install(to_install):\n        sys.exit(1)", "is_method": false, "function_description": "This `main` function serves as the command-line interface for an installation utility. It parses arguments to configure the installation path and items, then initiates the core installation process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/micropip.py", "function": "split_path", "line_number": 85, "body": "def split_path(lst, path):\n        q = os.path.split(path)\n        if q[1] != \"\":\n            lst.append(q[1])\n            split_path(lst, q[0])", "is_method": false, "function_description": "Recursively splits a file path into its individual directory and file components. It populates the given list with these components, from the last part backward."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "populate_main_frame", "line_number": 38, "body": "def populate_main_frame(self):\n        pad = self.get_padding()\n        inpad = self.get_internal_padding()\n\n        latest_ver_caption = tr(\"Version to be installed\")\n        version_caption_label = ttk.Label(self.main_frame, text=latest_ver_caption + \":\")\n        version_caption_label.grid(\n            row=0, column=0, sticky=\"w\", padx=(pad, inpad), pady=(pad, inpad)\n        )\n        self._version_label = ttk.Label(self.main_frame, text=tr(\"please wait\") + \" ...\")\n        self._version_label.grid(row=0, column=1, padx=(0, pad), pady=(pad, inpad), sticky=\"w\")\n\n        device_location_caption = tr(\"Target device location\")\n        self.target_caption_label = ttk.Label(self.main_frame, text=device_location_caption + \":\")\n        self.target_caption_label.grid(\n            row=1, column=0, padx=(pad, inpad), pady=(0, inpad), sticky=\"w\"\n        )\n\n        # add width, so that this label prescribes the width of the dialog and it doesn't grow\n        # when the progressbar and action text are gridded\n        self.target_label = ttk.Label(self.main_frame, text=\"\", width=self.get_info_text_width())\n        self.target_label.grid(row=1, column=1, padx=(0, pad), pady=(0, inpad), sticky=\"w\")\n\n        device_model_caption = tr(\"Target device model\")\n        self.model_caption_label = ttk.Label(self.main_frame, text=device_model_caption + \":\")\n        self.model_caption_label.grid(\n            row=2, column=0, padx=(pad, inpad), pady=(0, inpad), sticky=\"w\"\n        )\n        self.model_label = ttk.Label(self.main_frame, text=\"\", width=self.get_info_text_width())\n        self.model_label.grid(row=2, column=1, padx=(0, pad), pady=(0, inpad), sticky=\"w\")\n\n        # Resize progress bar to align with this grid\n        default_font = tkfont.nametofont(\"TkDefaultFont\")\n        max_caption_len = max(\n            [\n                default_font.measure(caption + \":\")\n                for caption in [latest_ver_caption, device_location_caption, device_model_caption]\n            ]\n        )\n        self._progress_bar[\"length\"] = max_caption_len", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Populates the dialog's main frame with labels and captions for displaying flashing information like version, device location, and model. It establishes the initial visual layout for the UF2 flashing process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_info_text_width", "line_number": 79, "body": "def get_info_text_width(self):\n        return 40", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Provides a fixed width value of 40 for displaying informational text within the Uf2FlashingDialog, likely for UI layout purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_action_text_max_length", "line_number": 82, "body": "def get_action_text_max_length(self):\n        return 20", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "This method provides the maximum character length allowed for action text displayed within the dialog, likely for UI formatting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_instructions", "line_number": 85, "body": "def get_instructions(self) -> Optional[str]:\n        return (\n            \"This dialog allows you to install or update MicroPython on your device.\\n\"\n            \"\\n\"\n            \"1. Put your device into bootloader mode.\\n\"\n            \"2. Wait until device information appears.\\n\"\n            \"3. Click 'Install' and wait for some seconds until done.\\n\"\n            \"4. Close the dialog and start programming!\"\n        )", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "This method provides clear, step-by-step instructions for users on how to flash or update MicroPython on a device, guiding them through the installation process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_ok_text", "line_number": 95, "body": "def get_ok_text(self):\n        return tr(\"Install\")", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Provides the localized text for the confirmation button in the UF2 flashing dialog, specifically the word \"Install.\""}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_start_downloading_release_info", "line_number": 101, "body": "def _start_downloading_release_info(self):\n        self._release_info = None  # invalidate last info if downloading again\n        threading.Thread(target=self._download_release_info, daemon=True).start()", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Prepares for and initiates the asynchronous download of release information. It clears any previously stored data before starting the background fetching process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_download_release_info", "line_number": 105, "body": "def _download_release_info(self):\n        import json\n        from urllib.request import urlopen\n\n        try:\n            req = urllib.request.Request(\n                self._get_release_info_url(),\n                data=None,\n                headers={\n                    \"User-Agent\": FAKE_USER_AGENT,\n                    \"Cache-Control\": \"no-cache\",\n                },\n            )\n            with urlopen(req) as fp:\n                json_str = fp.read().decode(\"UTF-8\")\n                logger.debug(\"Release info: %r\", json_str)\n                self._release_info = json.loads(json_str)\n                if self._release_info.get(\"message\", \"\") == \"Not Found\":\n                    self._release_info = None\n        except Exception as e:\n            self.append_text(\"Could not find release info from %s\\n\" % self._get_release_info_url())\n            self.set_action_text(\"Error!\")\n            self.grid_progress_widgets()", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Downloads and parses software release information from a configured URL. This data is then stored to assist the Uf2FlashingDialog's flashing process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "update_ui", "line_number": 129, "body": "def update_ui(self):\n        if self._state == \"idle\":\n            self._possible_targets = self.get_possible_targets()\n            if not self._possible_targets:\n                set_text_if_different(self.target_label, \"\")\n                set_text_if_different(self.model_label, \"\")\n            else:\n                unpacked = list(zip(*self._possible_targets))\n                set_text_if_different(self.target_label, \"\\n\".join(unpacked[0]))\n                model_changed = set_text_if_different(self.model_label, \"\\n\".join(unpacked[2]))\n\n            desc = self.get_firmware_description()\n            if desc is None:\n                set_text_if_different(self._version_label, self.get_unknown_version_text())\n            else:\n                set_text_if_different(self._version_label, desc)\n\n        super(Uf2FlashingDialog, self).update_ui()", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "This method updates the user interface of the UF2 flashing dialog. It populates labels with available flashing targets, their models, and the current firmware version when the dialog is idle."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_unknown_version_text", "line_number": 148, "body": "def get_unknown_version_text(self):\n        return tr(\"Please wait\") + \"...\"", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Returns a localized 'Please wait...' message, suitable for display when system status is pending or unknown."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_firmware_description", "line_number": 154, "body": "def get_firmware_description(self):\n        if self._release_info is None:\n            return None\n        else:\n            return (\n                self._release_info[\"tag_name\"]\n                + \" (\"\n                + self._release_info[\"published_at\"][:10]\n                + \")\"\n            )", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "This method retrieves and formats a concise description of the firmware release. It combines the release tag name and publication date for display purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_download_url_and_size", "line_number": 165, "body": "def get_download_url_and_size(self, board_id):\n        if self._release_info is None:\n            return None\n\n        candidates = [\n            asset\n            for asset in self._release_info[\"assets\"]\n            if self._is_suitable_asset(asset, board_id)\n        ]\n\n        logger.info(\n            \"Assets from %s: %r\", self._get_release_info_url(), self._release_info[\"assets\"]\n        )\n        if len(candidates) == 0:\n            raise RuntimeError(\n                \"Could not find the right file from the release info (%s)\"\n                % self._get_release_info_url()\n            )\n        elif len(candidates) > 1:\n            raise RuntimeError(\n                \"Found several possible files from the release info (%s)\"\n                % self._get_release_info_url()\n            )\n        else:\n            return (candidates[0][\"browser_download_url\"], candidates[0][\"size\"])", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "For the `Uf2FlashingDialog`, this method identifies and retrieves the download URL and size for the correct UF2 firmware file for a given board ID. It ensures the proper asset is selected for flashing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "is_ready_for_work", "line_number": 194, "body": "def is_ready_for_work(self):\n        # Called after update_ui\n        return self._possible_targets and self._release_info", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "This method checks if the dialog has acquired necessary target and release information. It indicates whether the Uf2FlashingDialog is ready to proceed with its operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_possible_targets", "line_number": 199, "body": "def get_possible_targets(cls):\n        all_vol_infos = [\n            (vol, cls.find_device_board_id_and_model(vol))\n            for vol in list_volumes(skip_letters=[\"A\"])\n        ]\n\n        return [(info[0], info[1][0], info[1][1]) for info in all_vol_infos if info[1] is not None]", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Identifies and lists all connected volumes that are valid UF2 flashing targets. It provides device board ID and model for each recognized target."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "start_work", "line_number": 207, "body": "def start_work(self):\n        if len(self._possible_targets) > 1:\n            # size 0 is checked elsewhere\n            messagebox.showerror(\n                \"Can't proceed\",\n                \"You seem to have plugged in %d compatible devices.\\n\"\n                + \"Please leave only one and unplug the others!\",\n                parent=self,\n            )\n            return False\n\n        target_dir, board_id, _ = self._possible_targets[0]\n\n        try:\n            download_url, size = self.get_download_url_and_size(board_id)\n        except Exception as e:\n            logger.error(\"Could not determine download url\", exc_info=e)\n            messagebox.showerror(\"Could not determine download url\", str(e), parent=self)\n            return False\n\n        self.report_progress(0, size)\n        proxy = get_runner().get_backend_proxy()\n        if isinstance(proxy, BareMetalMicroPythonProxy):\n            proxy.disconnect()\n\n        threading.Thread(\n            target=self._perform_work, args=[download_url, size, target_dir], daemon=True\n        ).start()\n        return True", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "This dialog method begins the UF2 flashing sequence. It ensures only one device is connected, retrieves firmware details, and offloads the actual flashing work to a background thread."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "find_device_board_id_and_model", "line_number": 238, "body": "def find_device_board_id_and_model(cls, mount_path):\n        info_path = os.path.join(mount_path, \"INFO_UF2.TXT\")\n        if not os.path.isfile(info_path):\n            return None\n\n        board_id = None\n        model = None\n        with open(info_path, \"r\", encoding=\"UTF-8\", errors=\"replace\") as fp:\n            for line in fp:\n                parts = list(map(str.strip, line.split(\":\", maxsplit=1)))\n                if len(parts) == 2:\n                    if parts[0] == \"Model\":\n                        model = parts[1]\n                    elif parts[0] == \"Board-ID\":\n                        board_id = parts[1]\n                        if not cls._is_relevant_board_id(board_id):\n                            return None\n\n                    if board_id and model:\n                        return board_id, model\n\n        return None", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Identifies a UF2 device by extracting its board ID and model from the INFO_UF2.TXT file at the specified mount path. Returns these details if the board ID is relevant."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_perform_work", "line_number": 269, "body": "def _perform_work(self, download_url, size, target_dir):\n        try:\n            self._download_to_the_device(download_url, size, target_dir)\n            if self._state == \"working\" and self._get_vid_pids_to_wait_for():\n                self._wait_for_vid_pids()\n        except Exception as e:\n            self.append_text(\"\\n\" + \"\".join(traceback.format_exc()))\n            self.set_action_text(\"Error...\")\n            self.report_done(False)\n            return\n\n        if self._state == \"working\":\n            self.append_text(\"\\nDone!\\n\")\n            self.set_action_text(\"Done!\")\n            self.report_done(True)\n        else:\n            assert self._state == \"cancelling\"\n            self.append_text(\"\\nCancelled\\n\")\n            self.set_action_text(\"Cancelled\")\n            self.report_done(False)", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Orchestrates the UF2 flashing process, downloading firmware and waiting for device reconnection. It reports the operation's success, cancellation, or errors.\nOrchestrates the UF2 flashing process, downloading firmware and waiting for device reconnection. It reports the operation's success, cancellation, or errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_wait_for_vid_pids", "line_number": 290, "body": "def _wait_for_vid_pids(self):\n        target_set = set(self._get_vid_pids_to_wait_for())\n        if not target_set:\n            return\n\n        self.append_text(\"\\nWaiting for the port...\\n\")\n        self.set_action_text(\"Waiting for the port...\")\n\n        wait_time = 0\n        step = 0.2\n        while wait_time < 10:\n            for p in list_serial_ports():\n                vidpid = (p.vid, p.pid)\n                if vidpid in target_set or (p.vid, None) in target_set:\n                    self.append_text(\"Found %s at %s\\n\" % (\"%04x:%04x\" % vidpid, p.device))\n                    self.set_action_text(\"Found port\")\n                    return\n            if self._state == \"cancelling\":\n                return\n            time.sleep(step)\n            wait_time += step\n        else:\n            self.set_action_text(\"Warning: Could not find port\")\n            self.append_text(\"Warning: Could not find port in %s seconds\\n\" % int(wait_time))\n            # leave some time to see the warning\n            time.sleep(2)", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "This method waits for a specific USB device, identified by its VID/PID, to become available as a serial port. It provides UI feedback, handles cancellation, and times out if the device is not found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "_download_to_the_device", "line_number": 317, "body": "def _download_to_the_device(self, download_url, size, target_dir):\n        \"\"\"Running in a bg thread\"\"\"\n        target_path = os.path.join(target_dir, self.get_target_filename())\n        logger.debug(\"Downloading %d bytes from %s to %s\", size, download_url, target_path)\n\n        self.set_action_text(\"Starting...\")\n        self.append_text(\"Downloading %d bytes from %s\\n\" % (size, download_url))\n\n        req = urllib.request.Request(\n            download_url,\n            data=None,\n            headers={\n                \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.47 Safari/537.36\"\n            },\n        )\n\n        with urlopen(req, timeout=5) as fsrc:\n            bytes_copied = 0\n            self.append_text(\"Writing to %s\\n\" % target_path)\n            self.append_text(\"Starting...\")\n            if fsrc.length:\n                # override (possibly inaccurate) size\n                size = fsrc.length\n\n            block_size = 8 * 1024\n            with open(target_path, \"wb\") as fdst:\n                while True:\n\n                    block = fsrc.read(block_size)\n                    if not block:\n                        break\n\n                    if self._state == \"cancelling\":\n                        break\n\n                    fdst.write(block)\n                    fdst.flush()\n                    os.fsync(fdst.fileno())\n                    bytes_copied += len(block)\n                    percent_str = \"%.0f%%\" % (bytes_copied / size * 100)\n                    self.set_action_text(\"Copying... \" + percent_str)\n                    self.report_progress(bytes_copied, size)\n                    self.replace_last_line(percent_str)", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "A background method for `Uf2FlashingDialog` that downloads a file from a URL to a local directory, providing real-time progress updates to the user interface during the process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_target_filename", "line_number": 361, "body": "def get_target_filename(self):\n        return \"firmware\"", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Specifies the default target filename for the firmware to be used during the UF2 flashing process. This provides a consistent name for the operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/uf2dialog.py", "function": "get_title", "line_number": 364, "body": "def get_title(self):\n        return \"Install MicroPython firmware\"", "is_method": true, "class_name": "Uf2FlashingDialog", "function_description": "Provides the fixed title for the Uf2FlashingDialog. This method ensures the dialog consistently displays \"Install MicroPython firmware\" as its title."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "list_serial_ports", "line_number": 874, "body": "def list_serial_ports():\n    # serial.tools.list_ports.comports() can be too slow\n    # because os.path.islink can be too slow (https://github.com/pyserial/pyserial/pull/303)\n    # Workarond: temporally patch os.path.islink\n    import serial.tools.list_ports\n\n    try:\n        old_islink = os.path.islink\n        if platform.system() == \"Windows\":\n            os.path.islink = lambda _: False\n        return list(serial.tools.list_ports.comports())\n    finally:\n        os.path.islink = old_islink", "is_method": false, "function_description": "Provides a list of all currently available serial communication ports on the system. This allows applications to identify and interact with connected serial devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "port_exists", "line_number": 889, "body": "def port_exists(device):\n    for port in list_serial_ports():\n        if port.device == device:\n            return True\n\n    return False", "is_method": false, "function_description": "Checks if a specific serial port device is currently available on the system. This is useful for verifying hardware connectivity before attempting communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "list_serial_ports_with_descriptions", "line_number": 897, "body": "def list_serial_ports_with_descriptions():\n    def port_order(p):\n        name = p.device\n        if name is None:\n            return \"\"\n        elif name.startswith(\"COM\") and len(name) == 4:\n            # Make one-digit COM ports go before COM10\n            return name.replace(\"COM\", \"COM0\")\n        else:\n            return name\n\n    sorted_ports = sorted(list_serial_ports(), key=port_order)\n\n    return [\n        (\n            p.description if p.device in p.description else p.description + \" (\" + p.device + \")\",\n            p.device,\n        )\n        for p in sorted_ports\n    ]", "is_method": false, "function_description": "Provides a sorted list of available serial ports, each with a user-friendly description and its device name. Useful for applications requiring port selection or identification."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_port_info", "line_number": 919, "body": "def get_port_info(port):\n    for info in list_serial_ports():\n        if info.device == port:\n            return info\n    raise RuntimeError(\"Port %s not found\" % port)", "is_method": false, "function_description": "Retrieves detailed information for a specific serial port, identified by its device name. This allows other functions to access all available attributes for a given port."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "add_micropython_backend", "line_number": 926, "body": "def add_micropython_backend(\n    name,\n    proxy_class,\n    description,\n    config_page,\n    bare_metal=True,\n    sort_key=None,\n    validate_time=True,\n    sync_time=None,\n    utc_clock=False,\n    write_block_size=None,\n    write_block_delay=None,\n    dtr=None,\n    rts=None,\n):\n    if bare_metal:\n        get_workbench().set_default(name + \".port\", \"auto\")\n        get_workbench().set_default(name + \".webrepl_url\", DEFAULT_WEBREPL_URL)\n        get_workbench().set_default(name + \".webrepl_password\", \"\")\n        get_workbench().set_default(name + \".write_block_size\", write_block_size)\n        # write_block_delay is used only with \"raw\" submit_mode\n        get_workbench().set_default(name + \".write_block_delay\", write_block_delay)\n        get_workbench().set_default(name + \".used_vidpids\", set())\n        get_workbench().set_default(name + \".dtr\", dtr)\n        get_workbench().set_default(name + \".rts\", rts)\n        get_workbench().set_default(name + \".submit_mode\", None)\n\n        if sync_time is None:\n            sync_time = True\n    else:\n        if sync_time is None:\n            sync_time = False\n\n    get_workbench().set_default(name + \".sync_time\", sync_time)\n    get_workbench().set_default(name + \".utc_clock\", utc_clock)\n    get_workbench().set_default(name + \".validate_time\", validate_time)\n    get_workbench().add_backend(name, proxy_class, description, config_page, sort_key=sort_key)", "is_method": false, "function_description": "Registers a new MicroPython backend with the workbench. It configures default settings for communication, time synchronization, and other operational parameters based on the backend type."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "load_plugin", "line_number": 965, "body": "def load_plugin():\n    add_micropython_backend(\n        \"GenericMicroPython\",\n        GenericBareMetalMicroPythonProxy,\n        tr(\"MicroPython (generic)\"),\n        GenericBareMetalMicroPythonConfigPage,\n        sort_key=\"49\",\n    )\n\n    if platform.system() in (\"Linux\", \"Darwin\"):\n        add_micropython_backend(\n            \"LocalMicroPython\",\n            LocalMicroPythonProxy,\n            tr(\"MicroPython (local)\"),\n            LocalMicroPythonConfigPage,\n            bare_metal=False,\n            sort_key=\"21\",\n        )\n        get_workbench().set_default(\"LocalMicroPython.executable\", \"micropython\")\n\n    add_micropython_backend(\n        \"SshMicroPython\",\n        SshMicroPythonProxy,\n        tr(\"MicroPython (SSH)\"),\n        SshMicroPythonConfigPage,\n        bare_metal=False,\n        sort_key=\"22\",\n    )\n    get_workbench().set_default(\"SshMicroPython.executable\", \"micropython\")\n    get_workbench().set_default(\"SshMicroPython.cwd\", None)\n    get_workbench().set_default(\"SshMicroPython.host\", \"\")\n    get_workbench().set_default(\"SshMicroPython.user\", \"\")\n    get_workbench().set_default(\"SshMicroPython.auth_method\", \"password\")", "is_method": false, "function_description": "It registers various MicroPython backends, including generic, local, and SSH connection types. It also sets default configurations for these backends, enabling diverse connectivity options within the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_pip_gui_class", "line_number": 41, "body": "def get_pip_gui_class(self):\n        from thonny.plugins.micropython.pip_gui import MicroPythonPipDialog\n\n        return MicroPythonPipDialog", "is_method": true, "class_name": "MicroPythonProxy", "function_description": "This method returns the class definition for the MicroPython Pip GUI dialog, enabling its use for package management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_pip_target_dir", "line_number": 46, "body": "def get_pip_target_dir(self) -> Optional[str]:\n\n        lib_dirs = self.get_lib_dirs()\n        if not lib_dirs:\n            return None\n\n        for path in lib_dirs:\n            if path.startswith(\"/home/\"):\n                return path\n\n        for path in [\"/lib\", \"/flash/lib\"]:\n            if path in lib_dirs:\n                return path\n\n        return lib_dirs[0]", "is_method": true, "class_name": "MicroPythonProxy", "function_description": "Provides the primary target directory for installing Python packages on the MicroPython device, based on prioritized common library paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_lib_dirs", "line_number": 62, "body": "def get_lib_dirs(self):\n        return self._lib_dirs", "is_method": true, "class_name": "MicroPythonProxy", "function_description": "Provides access to the configured list of MicroPython library directories. This allows other parts of the system to locate MicroPython-specific modules and packages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_store_state_info", "line_number": 65, "body": "def _store_state_info(self, msg):\n        super(MicroPythonProxy, self)._store_state_info(msg)\n        if \"lib_dirs\" in msg:\n            self._lib_dirs = msg[\"lib_dirs\"]", "is_method": true, "class_name": "MicroPythonProxy", "function_description": "This method updates the MicroPythonProxy's internal state by storing library directory information from an incoming message, extending its superclass's state storage."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_time_args", "line_number": 70, "body": "def _get_time_args(self):\n        result = {\n            \"sync_time\": get_workbench().get_option(self.backend_name + \".sync_time\", False),\n            \"validate_time\": get_workbench().get_option(\n                self.backend_name + \".validate_time\", False\n            ),\n            \"utc_clock\": get_workbench().get_option(self.backend_name + \".utc_clock\", False),\n        }\n        return result", "is_method": true, "class_name": "MicroPythonProxy", "function_description": "This method retrieves configuration arguments for time synchronization, validation, and UTC clock settings relevant to the MicroPython backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_fix_port", "line_number": 94, "body": "def _fix_port(self):\n        if self._port == \"webrepl\":\n            return\n\n        elif self._port == \"auto\":\n            potential = self._detect_potential_ports()\n            if len(potential) == 1:\n                self._port = potential[0][0]\n            else:\n                if not potential and self.device_is_present_in_bootloader_mode():\n                    if self._propose_install_firmware():\n                        print(\"POSITIVE\")\n                        return self._fix_port()\n\n                self._port = None\n                message = dedent(\n                    \"\"\"\\\n                    Couldn't find the device automatically. \n                    Check the connection (making sure the device is not in bootloader mode) or choose\n                    \"Configure interpreter\" in the interpreter menu (bottom-right corner of the window)\n                    to select specific port or another interpreter.\"\"\"\n                )\n\n                if len(potential) > 1:\n                    _, descriptions = zip(*potential)\n                    message += \"\\n\\nLikely candidates are:\\n * \" + \"\\n * \".join(descriptions)\n\n                self._show_error(message)\n        elif not port_exists(self._port):\n            if self.device_is_present_in_bootloader_mode():\n                self._port = None\n                self._propose_install_firmware()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "This internal method attempts to automatically determine or validate the communication port for the MicroPython device. It guides the user with error messages or firmware installation prompts if connection issues arise."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_propose_install_firmware", "line_number": 127, "body": "def _propose_install_firmware(self):\n        \"\"\"Subclass may show firmware installation dialog and return True if installation succeeds\"\"\"\n        self._show_error(\n            \"Your device seems to be in bootloader mode.\\n\"\n            \"In this mode you can install or upgrade MicroPython firmware.\\n\\n\"\n            \"If your device already has MicroPython, then you can start using it after you put it into normal mode.\"\n        )\n\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Provides user guidance when a device is in bootloader mode, explaining options for firmware installation or returning to normal operation. It serves as a base method for potential subclass-specific installation prompts."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_start_background_process", "line_number": 137, "body": "def _start_background_process(self, clean=None, extra_args=[]):\n        if self._port is None:\n            return\n\n        super()._start_background_process(clean=clean, extra_args=extra_args)", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Conditionally starts a background process for the MicroPython proxy, delegating to the parent class. It only proceeds if a communication port is configured."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_launcher_with_args", "line_number": 143, "body": "def _get_launcher_with_args(self):\n        import thonny.plugins.micropython.bare_metal_backend\n\n        args = {\n            \"clean\": self._clean_start,\n            \"port\": self._port,\n            \"dtr\": get_workbench().get_option(self.backend_name + \".dtr\"),\n            \"rts\": get_workbench().get_option(self.backend_name + \".rts\"),\n            \"submit_mode\": get_workbench().get_option(self.backend_name + \".submit_mode\"),\n            \"api_stubs_path\": self._get_api_stubs_path(),\n            \"write_block_size\": self._get_write_block_size(),\n            \"write_block_delay\": self._get_write_block_delay(),\n            \"proxy_class\": self.__class__.__name__,\n        }\n        if self._port == \"webrepl\":\n            args[\"url\"] = get_workbench().get_option(self.backend_name + \".webrepl_url\")\n            args[\"password\"] = get_workbench().get_option(self.backend_name + \".webrepl_password\")\n\n        args.update(self._get_time_args())\n\n        cmd = [\n            thonny.plugins.micropython.bare_metal_backend.__file__,\n            repr(args),\n        ]\n\n        return cmd", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Prepares the command and arguments for launching the bare-metal MicroPython backend. It aggregates necessary configuration options from the proxy and user settings."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_write_block_size", "line_number": 170, "body": "def _get_write_block_size(self):\n        return get_workbench().get_option(self.backend_name + \".write_block_size\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "This method provides the configured write block size for the proxy's backend, essential for controlling data transfer operations to a MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_write_block_delay", "line_number": 173, "body": "def _get_write_block_delay(self):\n        return get_workbench().get_option(self.backend_name + \".write_block_delay\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Retrieves the configured write block delay specific to the MicroPython backend. This value likely governs pacing for data writes to the bare metal device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "interrupt", "line_number": 176, "body": "def interrupt(self):\n        # Don't interrupt local process, but direct it to device\n        self._send_msg(ImmediateCommand(\"interrupt\"))", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "The `interrupt` method sends a command to halt the currently executing process on the bare metal MicroPython device. It provides a means to programmatically stop device operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "send_command", "line_number": 180, "body": "def send_command(self, cmd: CommandToBackend) -> Optional[str]:\n        if isinstance(cmd, EOFCommand):\n            get_shell().restart()  # Runner doesn't notice restart\n\n        return super().send_command(cmd)", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "This method sends commands to the MicroPython backend. It provides the capability to restart the MicroPython shell if an `EOFCommand` is received, ensuring proper session management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_detect_potential_ports", "line_number": 190, "body": "def _detect_potential_ports(cls):\n        all_ports = list_serial_ports()\n        \"\"\"\n        for p in all_ports:\n            print(vars(p))\n        \"\"\"\n        return [(p.device, p.description) for p in all_ports if cls._is_potential_port(p)]", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "This internal method of `BareMetalMicroPythonProxy` identifies and lists serial ports that are likely connected MicroPython devices. It filters all available ports based on specific criteria to facilitate device connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_is_potential_port", "line_number": 199, "body": "def _is_potential_port(cls, p):\n        return (\n            (p.vid, p.pid) in cls.get_known_usb_vids_pids()\n            or (p.vid, None) in cls.get_known_usb_vids_pids()\n            or p.description in cls.get_known_port_descriptions()\n            or cls.should_consider_unknown_devices()\n            and (p.vid, p.pid) not in cls.get_vids_pids_to_avoid()\n            and (\n                getattr(p, \"manufacturer\", \"\") == \"MicroPython\"\n                or (\"USB\" in p.description and \"serial\" in p.description.lower())\n                or \"UART\" in p.description\n                or \"DAPLink\" in p.description\n                or \"STLink\" in p.description\n                or \"python\" in p.description.lower()\n            )\n        )", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Identifies if a given port likely corresponds to a MicroPython device or development board. It checks against known USB identifiers, descriptions, and manufacturer data."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 217, "body": "def get_known_usb_vids_pids(cls):\n        \"\"\"Return set of pairs of USB device VID, PID\"\"\"\n        return cls.get_used_usb_vidpids()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "This class method retrieves the set of recognized USB Vendor ID and Product ID pairs. It helps identify compatible MicroPython devices for the proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_vids_pids_to_avoid", "line_number": 222, "body": "def get_vids_pids_to_avoid(cls):\n        \"\"\"Return set of pairs of USB device VID, PID to explicitly not consider\n        either because they are not compatible or to reduce the number of choices\n        in the switcher.\n        \"\"\"\n        return set()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "This method identifies specific USB device Vendor and Product ID pairs. These pairs are explicitly excluded from consideration to filter incompatible devices or simplify device selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_used_usb_vidpids", "line_number": 230, "body": "def get_used_usb_vidpids(cls):\n        return get_workbench().get_option(cls.backend_name + \".used_vidpids\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Retrieves configured USB Vendor/Product IDs used by the BareMetalMicroPythonProxy's backend from the workbench."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_uart_adapter_vids_pids", "line_number": 234, "body": "def get_uart_adapter_vids_pids(cls):\n        return {\n            (0x1A86, 0x7523),  # HL-340\n            (0x10C4, 0xEA60),  # CP210x\"),\n            (0x0403, 0x6001),  # FT232/FT245 (XinaBox CW01, CW02)\n            (0x0403, 0x6010),  # FT2232C/D/L/HL/Q (ESP-WROVER-KIT)\n            (0x0403, 0x6011),  # FT4232\n            (0x0403, 0x6014),  # FT232H\n            (0x0403, 0x6015),  # FT X-Series (Sparkfun ESP32)\n            (0x0403, 0x601C),  # FT4222H\n        }", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "This class method provides a predefined set of Vendor ID and Product ID pairs for common UART adapters. It identifies compatible serial chipsets for connecting to MicroPython devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_consider_unknown_devices", "line_number": 247, "body": "def should_consider_unknown_devices(cls):\n        return True", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "This method indicates that the BareMetalMicroPythonProxy should consider and potentially interact with devices that are not explicitly known."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_api_stubs_path", "line_number": 254, "body": "def _get_api_stubs_path(self):\n        import inspect\n\n        return os.path.join(os.path.dirname(inspect.getfile(self.__class__)), \"api_stubs\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Returns the file system path to the API stub directory. This path is determined relative to the location of the `BareMetalMicroPythonProxy` class file itself."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_files", "line_number": 259, "body": "def supports_remote_files(self):\n        return self.is_connected()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Indicates whether the BareMetalMicroPythonProxy's connection to the MicroPython device supports remote file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "uses_local_filesystem", "line_number": 262, "body": "def uses_local_filesystem(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Provides a status indicating that the BareMetalMicroPythonProxy environment does not use or support a local filesystem."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "ready_for_remote_file_operations", "line_number": 265, "body": "def ready_for_remote_file_operations(self):\n        return self.is_connected() and get_runner().is_waiting_toplevel_command()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Determines if the MicroPython device is connected and in a state to accept remote file system commands. This confirms its readiness for file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_directories", "line_number": 268, "body": "def supports_remote_directories(self):\n        return self._cwd is not None and self._cwd != \"\"", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Checks if the proxy instance supports operations on remote directories. It indicates whether a current working directory is established on the remote MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_trash", "line_number": 271, "body": "def supports_trash(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Reports that this BareMetal MicroPython proxy does not support trash functionality."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "is_connected", "line_number": 274, "body": "def is_connected(self):\n        return self._port is not None and self._proc is not None", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Determines if the BareMetalMicroPythonProxy has an active connection to a port and an associated process. It signals the proxy's readiness for operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_show_error", "line_number": 277, "body": "def _show_error(self, text):\n        get_shell().print_error(\"\\n\" + text + \"\\n\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Prints a formatted error message to the MicroPython shell. It offers a consistent way to display error information to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "disconnect", "line_number": 280, "body": "def disconnect(self):\n        self.destroy()", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Terminates the connection to the BareMetal MicroPython device. It releases all associated resources by calling the destroy method."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_node_label", "line_number": 283, "body": "def get_node_label(self):\n        if \"CircuitPython\" in self._welcome_text:\n            return tr(\"CircuitPython device\")\n        elif \"micro:bit\" in self._welcome_text.lower():\n            return \"micro:bit\"\n        else:\n            return tr(\"MicroPython device\")", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Provides a descriptive label for the connected device by inspecting its welcome message. It classifies the device as CircuitPython, micro:bit, or generic MicroPython for identification."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_full_label", "line_number": 291, "body": "def get_full_label(self):\n        if self.is_connected():\n            return self.get_node_label() + \" @ \" + self._port\n        else:\n            return self.get_node_label() + \" (\" + tr(\"Not connected\") + \")\"", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Provides a formatted label for the MicroPython proxy, including its node identifier and connection status for display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_local_files", "line_number": 300, "body": "def can_run_local_files(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Informs callers that the `BareMetalMicroPythonProxy` instance does not support executing files directly from the local filesystem."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_remote_files", "line_number": 303, "body": "def can_run_remote_files(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "This method informs callers that the BareMetalMicroPythonProxy cannot execute files directly from remote sources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "fetch_next_message", "line_number": 306, "body": "def fetch_next_message(self):\n        msg = super(BareMetalMicroPythonProxy, self).fetch_next_message()\n        if (\n            not self._have_stored_pidwid\n            and getattr(msg, \"event_type\", None) == \"ToplevelResponse\"\n            and self._port != \"webrepl\"\n        ):\n            # Let's remember that this vidpid was used with this backend\n            # need to copy and store explicitly, because otherwise I may change the default value\n            used_vidpids = get_workbench().get_option(self.backend_name + \".used_vidpids\").copy()\n            from serial.tools.list_ports_common import ListPortInfo\n\n            info = get_port_info(self._port)\n            used_vidpids.add((info.vid, info.pid))\n            self._have_stored_pidwid = True\n            get_workbench().set_option(self.backend_name + \".used_vidpids\", used_vidpids)\n\n        return msg", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "This method retrieves the next message from the MicroPython device. It also stores the device's Vendor/Product ID if it's the first successful `ToplevelResponse` from a non-webrepl port."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_show_in_switcher", "line_number": 330, "body": "def should_show_in_switcher(cls):\n        if cls.device_is_present_in_bootloader_mode():\n            return True\n\n        # Show only if it looks like we can connect using current configuration\n        port = get_workbench().get_option(cls.backend_name + \".port\")\n        if port == \"webrepl\":\n            return True\n        if port == \"auto\":\n            potential_ports = cls._detect_potential_ports()\n            return len(potential_ports) > 0\n        else:\n            for p in list_serial_ports():\n                if p.device == port:\n                    return True\n\n            return False", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Determines if a Bare Metal MicroPython device should appear in a UI switcher. It checks for device presence, WebREPL configuration, or viable serial port connections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_switcher_entries", "line_number": 349, "body": "def get_switcher_entries(cls):\n        if cls.should_show_in_switcher():\n            return [(cls.get_current_switcher_configuration(), cls.backend_description)]\n        else:\n            return []", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Provides relevant entries for a UI switcher, including the current configuration and backend description. It returns this information only if the class is designated to be shown in the switcher."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "has_custom_system_shell", "line_number": 355, "body": "def has_custom_system_shell(self):\n        return self._port and self._port != \"webrepl\"", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Determines if the BareMetalMicroPythonProxy is configured to use a custom system shell. It identifies if the connection is active and not the default 'webrepl' interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "open_custom_system_shell", "line_number": 358, "body": "def open_custom_system_shell(self):\n        from thonny import terminal\n\n        get_runner().send_command_and_wait(InlineCommand(\"prepare_disconnect\"), \"Disconnecting\")\n\n        self.disconnect()\n\n        terminal.run_in_terminal(\n            [\n                running.get_interpreter_for_subprocess(sys.executable),\n                \"-m\",\n                # \"serial.tools.miniterm\",\n                \"thonny.plugins.micropython.miniterm_wrapper\",\n                \"--exit-char\",\n                \"20\",\n                \"--menu-char\",\n                \"29\",\n                \"--filter\",\n                \"direct\",\n                \"--quiet\",\n                self._port,\n                \"115200\",\n            ],\n            cwd=get_workbench().get_local_cwd(),\n            keep_open=False,\n            title=self._port,\n        )", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Opens a dedicated terminal for direct serial communication with a connected MicroPython device. It bypasses the standard Thonny runner to provide a raw serial console experience."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_supported_features", "line_number": 386, "body": "def get_supported_features(self):\n        return {\"run\", \"run_in_terminal\"}", "is_method": true, "class_name": "BareMetalMicroPythonProxy", "function_description": "Provides a list of specific operations the BareMetalMicroPythonProxy can execute, such as running code directly or in a terminal."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_on_click_firmware_installer_link", "line_number": 479, "body": "def _on_click_firmware_installer_link(self, event=None):\n        self._open_flashing_dialog()\n        self._has_opened_firmware_flasher = True", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Opens the firmware installation dialog when a UI link is clicked. It also tracks that the firmware flasher has been activated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_intro_text", "line_number": 486, "body": "def _get_intro_text(self):\n        result = (\n            tr(\"Connect your device to the computer and select corresponding port below\")\n            + \"\\n\"\n            + \"(\"\n            + tr('look for your device name, \"USB Serial\" or \"UART\"')\n            + \").\\n\"\n            + tr(\"If you can't find it, you may need to install proper USB driver first.\")\n        )\n        if self.allow_webrepl:\n            result = (\n                (\"Connecting via USB cable:\")\n                + \"\\n\"\n                + result\n                + \"\\n\\n\"\n                + (\"Connecting via WebREPL (EXPERIMENTAL):\")\n                + \"\\n\"\n                + (\n                    \"If your device supports WebREPL, first connect via serial, make sure WebREPL is enabled\\n\"\n                    + \"(import webrepl_setup), connect your computer and device to same network and select\\n\"\n                    + \"< WebREPL > below\"\n                )\n            )\n\n        return result", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Generates an introductory text for the MicroPython configuration page, providing instructions on connecting a device via USB or, if enabled, WebREPL."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_webrepl_frame", "line_number": 512, "body": "def _get_webrepl_frame(self):\n\n        if self._webrepl_frame is not None:\n            return self._webrepl_frame\n\n        self._webrepl_frame = ttk.Frame(self)\n\n        self._webrepl_url_var = create_string_var(\n            get_workbench().get_option(self.backend_name + \".webrepl_url\")\n        )\n        url_label = ttk.Label(self._webrepl_frame, text=\"URL (eg. %s)\" % DEFAULT_WEBREPL_URL)\n        url_label.grid(row=0, column=0, sticky=\"nw\", pady=(10, 0))\n        url_entry = ttk.Entry(self._webrepl_frame, textvariable=self._webrepl_url_var, width=30)\n        url_entry.grid(row=1, column=0, sticky=\"nw\")\n\n        self._webrepl_password_var = create_string_var(\n            get_workbench().get_option(self.backend_name + \".webrepl_password\")\n        )\n        pw_label = ttk.Label(self._webrepl_frame, text=tr(\"Password\"))\n        pw_label.grid(row=0, column=1, sticky=\"nw\", pady=(10, 0), padx=(10, 0))\n        pw_entry = ttk.Entry(self._webrepl_frame, textvariable=self._webrepl_password_var, width=15)\n        pw_entry.grid(row=1, column=1, sticky=\"nw\", padx=(10, 0))\n\n        return self._webrepl_frame", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Constructs and provides the Tkinter frame containing user interface elements for configuring WebREPL URL and password settings, ensuring it's created only once."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_stored_port_desc", "line_number": 537, "body": "def get_stored_port_desc(self):\n        name = get_workbench().get_option(self.backend_name + \".port\")\n        for desc in self._ports_by_desc:\n            if self._ports_by_desc[desc] == name:\n                return desc\n\n        return \"\"", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Retrieves the human-readable description for the configured MicroPython communication port. It translates the stored port identifier into its display name for configuration pages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_selected_port_name", "line_number": 545, "body": "def get_selected_port_name(self):\n        port_desc = self._port_desc_variable.get()\n        if not port_desc:\n            return None\n        return self._ports_by_desc[port_desc]", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Retrieves the system's actual port name based on the user-selected descriptive label from the configuration interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "is_modified", "line_number": 551, "body": "def is_modified(self):\n        return (\n            self._port_desc_variable.modified\n            or self.webrepl_selected()\n            and self._webrepl_password_var.modified\n            or self.webrepl_selected()\n            and self._webrepl_url_var.modified\n        )", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "This method determines if any configuration setting on the MicroPython page has been modified by the user. It indicates whether changes are pending."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "webrepl_selected", "line_number": 560, "body": "def webrepl_selected(self):\n        return self.get_selected_port_name() == \"webrepl\"", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Determines if 'webrepl' is the currently selected port setting on the configuration page. This status is used to manage related UI or operational logic."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_restart", "line_number": 563, "body": "def should_restart(self):\n        return self.is_modified() or self._has_opened_firmware_flasher", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Identifies if the BareMetalMicroPython system requires a restart. It indicates a restart is needed when configuration settings are modified or the firmware flasher is accessed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "apply", "line_number": 566, "body": "def apply(self):\n        if not self.is_modified():\n            return\n\n        else:\n            port_name = self.get_selected_port_name()\n            get_workbench().set_option(self.backend_name + \".port\", port_name)\n            if self.webrepl_selected():\n                get_workbench().set_option(\n                    self.backend_name + \".webrepl_url\", self._webrepl_url_var.get()\n                )\n                get_workbench().set_option(\n                    self.backend_name + \".webrepl_password\", self._webrepl_password_var.get()\n                )", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Applies modified MicroPython configuration settings, saving the selected communication port and WebREPL credentials to the workbench options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_on_change_port", "line_number": 581, "body": "def _on_change_port(self, *args):\n        if self._port_desc_variable.get() == self._WEBREPL_OPTION_DESC:\n            self._get_webrepl_frame().grid(row=6, column=0, sticky=\"nwe\")\n        else:\n            if self._webrepl_frame and self._webrepl_frame.winfo_ismapped():\n                self._webrepl_frame.grid_forget()", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Dynamically adjusts the configuration page UI. It reveals the WebREPL settings section when the WebREPL port option is selected, and hides it otherwise."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_has_flashing_dialog", "line_number": 591, "body": "def _has_flashing_dialog(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Determines if a firmware flashing dialog should be presented on this configuration page. It indicates that no flashing dialog is associated with this page."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "allow_webrepl", "line_number": 598, "body": "def allow_webrepl(self):\n        return False", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "This method reports a configuration setting, indicating that WebREPL is explicitly disabled for the BareMetal MicroPython setup. It prevents remote web-based interaction with the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_known_usb_vids_pids", "line_number": 604, "body": "def get_known_usb_vids_pids(cls):\n        \"\"\"Return set of pairs of USB device (VID, PID)\"\"\"\n        return {\n            # Generic MicroPython Board, see http://pid.codes/org/MicroPython/\n            (0x1209, 0xADDA)\n        } | cls.get_uart_adapter_vids_pids()", "is_method": true, "class_name": "GenericBareMetalMicroPythonProxy", "function_description": "This class method provides a set of known USB Vendor and Product IDs for generic MicroPython boards and their associated UART adapters. It helps identify compatible hardware devices."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_vids_pids_to_avoid", "line_number": 612, "body": "def get_vids_pids_to_avoid(self):\n        return VIDS_PIDS_TO_AVOID_IN_GENERIC_BACKEND", "is_method": true, "class_name": "GenericBareMetalMicroPythonProxy", "function_description": "Retrieves a predefined list of Vendor IDs (VIDs) and Product IDs (PIDs) that should be avoided or excluded by the generic backend, typically for device filtering."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "allow_webrepl", "line_number": 618, "body": "def allow_webrepl(self):\n        return False", "is_method": true, "class_name": "GenericBareMetalMicroPythonConfigPage", "function_description": "Provides a configuration setting indicating that WebREPL access is disallowed for devices managed by this page."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_launcher_with_args", "line_number": 627, "body": "def _get_launcher_with_args(self):\n        import thonny.plugins.micropython.os_mp_backend\n\n        cmd = [\n            thonny.plugins.micropython.os_mp_backend.__file__,\n            repr(\n                {\n                    \"interpreter\": self._mp_executable,\n                    \"api_stubs_path\": self._get_api_stubs_path(),\n                    \"cwd\": self.get_cwd(),\n                }\n            ),\n        ]\n        return cmd", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Prepares the command and arguments needed to launch the MicroPython OS backend process. It configures the interpreter path, API stubs, and current working directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "interrupt", "line_number": 642, "body": "def interrupt(self):\n        # Don't interrupt local process, but direct it to the device\n        self._send_msg(ImmediateCommand(\"interrupt\"))", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Provides a mechanism to interrupt the execution on the connected MicroPython device, allowing external control."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "send_command", "line_number": 646, "body": "def send_command(self, cmd: CommandToBackend) -> Optional[str]:\n        if isinstance(cmd, EOFCommand):\n            get_shell().restart()  # Runner doesn't notice restart\n\n        return super().send_command(cmd)", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Provides a service to send commands to the MicroPython backend. It specifically restarts the shell upon receiving an EOF command."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_api_stubs_path", "line_number": 652, "body": "def _get_api_stubs_path(self):\n        import inspect\n\n        return os.path.join(os.path.dirname(inspect.getfile(self.__class__)), \"api_stubs\")", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Computes the local file path to the `api_stubs` directory. This path is used to locate and access MicroPython API definitions or stubs for the proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_initial_cwd", "line_number": 657, "body": "def _get_initial_cwd(self):\n        return get_workbench().get_local_cwd()", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Retrieves the initial current working directory from the local workbench environment. This provides the starting path for the MicroPython proxy."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_files", "line_number": 660, "body": "def supports_remote_files(self):\n        return False", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Indicates that the local MicroPython environment, represented by this proxy, does not support operations involving remote files. This method flags a capability limitation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "uses_local_filesystem", "line_number": 664, "body": "def uses_local_filesystem(self):\n        return True", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Indicates that this proxy object interacts with and utilizes a local filesystem, signaling its capability to perform local file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "ready_for_remote_file_operations", "line_number": 667, "body": "def ready_for_remote_file_operations(self):\n        return False", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "This method indicates that the LocalMicroPythonProxy instance is not configured or capable of performing remote file operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_directories", "line_number": 670, "body": "def supports_remote_directories(self):\n        return False", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "This method indicates that the `LocalMicroPythonProxy` does not support operations involving remote directories. It reports a specific capability of the proxy for external checks."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_trash", "line_number": 673, "body": "def supports_trash(self):\n        return True", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Indicates that the MicroPython environment managed by this proxy supports a 'trash' or 'recycle bin' feature for file deletion operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "is_connected", "line_number": 676, "body": "def is_connected(self):\n        return self._proc is not None", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Checks if the LocalMicroPythonProxy is currently connected to its underlying MicroPython environment or process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_show_error", "line_number": 679, "body": "def _show_error(self, text):\n        get_shell().print_error(\"\\n\" + text + \"\\n\")", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Displays a specified error message to the user via the shell interface. This provides a consistent way to report operational issues."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "disconnect", "line_number": 682, "body": "def disconnect(self):\n        self.destroy()", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Terminates the connection and releases resources associated with the local MicroPython proxy. This method provides a clean shutdown mechanism."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_node_label", "line_number": 685, "body": "def get_node_label(self):\n        return \"Local\"", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "This method returns the identifying label \"Local\" for the node or proxy it represents. It serves to uniquely identify local MicroPython connections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_full_label", "line_number": 688, "body": "def get_full_label(self):\n        return self._mp_executable", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "This method provides the full path or identifier for the MicroPython executable managed by this proxy. It allows other components to identify which MicroPython interpreter is being used."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_pip_gui_class", "line_number": 694, "body": "def get_pip_gui_class(self):\n        from thonny.plugins.micropython.pip_gui import LocalMicroPythonPipDialog\n\n        return LocalMicroPythonPipDialog", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Provides the graphical user interface class for managing MicroPython packages using pip."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_local_files", "line_number": 699, "body": "def can_run_local_files(self):\n        return True", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Serves as a flag indicating that this local MicroPython proxy possesses the capability to execute local files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_remote_files", "line_number": 702, "body": "def can_run_remote_files(self):\n        return False", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Indicates that this local MicroPython proxy cannot execute files located remotely."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_show_in_switcher", "line_number": 706, "body": "def should_show_in_switcher(cls):\n        # Show when the executable is configured and exists\n        executable = get_workbench().get_option(\"LocalMicroPython.executable\")\n        import shutil\n\n        return bool(executable) and (\n            os.path.isabs(executable) and os.path.exists(executable) or shutil.which(executable)\n        )", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Decides if the Local MicroPython option should appear in a switcher, based on whether its configured executable path is valid and exists."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_switcher_entries", "line_number": 716, "body": "def get_switcher_entries(cls):\n        if cls.should_show_in_switcher():\n            return [(cls.get_current_switcher_configuration(), cls.backend_description)]\n        else:\n            return []", "is_method": true, "class_name": "LocalMicroPythonProxy", "function_description": "Determines if this MicroPython backend should be displayed in a UI switcher. If so, it provides the necessary configuration and description for its entry."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_on_change", "line_number": 734, "body": "def _on_change(self):\n        self._changed = True", "is_method": true, "class_name": "LocalMicroPythonConfigPage", "function_description": "Marks the configuration page as modified. This internal flag signals that changes have occurred, often prompting subsequent actions like saving."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "apply", "line_number": 737, "body": "def apply(self):\n        get_workbench().set_option(\"LocalMicroPython.executable\", self._executable_var.get())", "is_method": true, "class_name": "LocalMicroPythonConfigPage", "function_description": "Updates the workbench's configuration to use the specified MicroPython executable path. This makes the new setting active for the application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_restart", "line_number": 740, "body": "def should_restart(self):\n        return self._changed", "is_method": true, "class_name": "LocalMicroPythonConfigPage", "function_description": "This method indicates if a system restart is required because configuration settings on the page have been modified."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_launcher_with_args", "line_number": 752, "body": "def _get_launcher_with_args(self):\n        import thonny.plugins.micropython.os_mp_backend\n\n        args = {\n            \"cwd\": get_workbench().get_option(\"SshMicroPython.cwd\") or \"\",\n            \"interpreter\": self._mp_executable,\n            \"api_stubs_path\": self._get_api_stubs_path(),\n            \"host\": self._host,\n            \"user\": self._user,\n            \"password\": get_ssh_password(\"SshMicroPython\"),\n        }\n\n        args.update(self._get_time_args())\n\n        cmd = [\n            thonny.plugins.micropython.os_mp_backend.__file__,\n            repr(args),\n        ]\n        return cmd", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Prepares the command and arguments for launching a remote MicroPython backend over SSH. It consolidates necessary configuration details for the proxy's operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "interrupt", "line_number": 772, "body": "def interrupt(self):\n        # Don't interrupt local process, but direct it to the device\n        self._send_msg(ImmediateCommand(\"interrupt\"))", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Sends an interrupt signal to the connected MicroPython device, stopping the currently executing program remotely."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "send_command", "line_number": 776, "body": "def send_command(self, cmd: CommandToBackend) -> Optional[str]:\n        if isinstance(cmd, EOFCommand):\n            get_shell().restart()  # Runner doesn't notice restart\n\n        return super().send_command(cmd)", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Sends a command to the MicroPython backend. If the command is an EOF, it first restarts the MicroPython shell before proceeding with the command transmission."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_api_stubs_path", "line_number": 782, "body": "def _get_api_stubs_path(self):\n        import inspect\n\n        return os.path.join(os.path.dirname(inspect.getfile(self.__class__)), \"api_stubs\")", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "This method determines the absolute file path to the \"api_stubs\" directory. It provides a way to locate API definition files relative to the class module for internal use."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_get_initial_cwd", "line_number": 787, "body": "def _get_initial_cwd(self):\n        return get_workbench().get_option(\"SshMicroPython.cwd\")", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Retrieves the initial current working directory configured for the SSH MicroPython environment. This provides the default path for SSH operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_publish_cwd", "line_number": 790, "body": "def _publish_cwd(self, cwd):\n        return get_workbench().set_option(\"SshMicroPython.cwd\", cwd)", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Publishes the current working directory to the workbench system for the SshMicroPython context. It ensures the SSH-based MicroPython environment uses the specified directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_files", "line_number": 793, "body": "def supports_remote_files(self):\n        return True", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Indicates that the SshMicroPythonProxy supports remote file operations on the connected MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "uses_local_filesystem", "line_number": 797, "body": "def uses_local_filesystem(self):\n        return False", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Reports that the SshMicroPythonProxy does not utilize the local filesystem of the host machine. This informs other components about file operation handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "ready_for_remote_file_operations", "line_number": 800, "body": "def ready_for_remote_file_operations(self):\n        return self.is_connected()", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Determines if the SSH MicroPython proxy is connected and prepared for remote file system operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_remote_directories", "line_number": 803, "body": "def supports_remote_directories(self):\n        return True", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Indicates that the SshMicroPythonProxy supports remote directory operations. This signals its capability to manage files and folders on the remote MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "supports_trash", "line_number": 806, "body": "def supports_trash(self):\n        return False", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Provides information on whether the connected MicroPython device supports a trash or recycle bin functionality for file deletions. It currently indicates that this feature is not supported."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "is_connected", "line_number": 809, "body": "def is_connected(self):\n        return self._proc is not None", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Verifies if the SSH proxy connection to the MicroPython device is currently active."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "_show_error", "line_number": 812, "body": "def _show_error(self, text):\n        get_shell().print_error(\"\\n\" + text + \"\\n\")", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "This internal method displays a specified error message to the user via the shell interface. It provides a standardized way to communicate operational issues to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "disconnect", "line_number": 815, "body": "def disconnect(self):\n        self.destroy()", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "This method disconnects the SSH MicroPython proxy, terminating its active connection and cleaning up associated resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_node_label", "line_number": 818, "body": "def get_node_label(self):\n        return self._host", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Provides the host identifier, acting as a label for the SSH-connected MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_full_label", "line_number": 821, "body": "def get_full_label(self):\n        return self._mp_executable + \" @ \" + self._host", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Generates a unique, descriptive label for the SSH MicroPython proxy, combining the executable name and host address for identification."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_local_files", "line_number": 827, "body": "def can_run_local_files(self):\n        return False", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Reports that the SSH MicroPython proxy does not support executing local files directly on the MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "can_run_remote_files", "line_number": 830, "body": "def can_run_remote_files(self):\n        return True", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Confirms that the SSH MicroPython proxy can execute files directly on the remote device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "should_show_in_switcher", "line_number": 834, "body": "def should_show_in_switcher(cls):\n        # Show when the executable, user and host are configured\n        return (\n            get_workbench().get_option(\"SshMicroPython.host\")\n            and get_workbench().get_option(\"SshMicroPython.user\")\n            and get_workbench().get_option(\"SshMicroPython.executable\")\n        )", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Determines if the SSH MicroPython proxy should be visible in a switcher. It checks if essential host, user, and executable settings are properly configured."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "get_switcher_entries", "line_number": 843, "body": "def get_switcher_entries(cls):\n        if cls.should_show_in_switcher():\n            return [(cls.get_current_switcher_configuration(), cls.backend_description)]\n        else:\n            return []", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "This class method provides an entry for a UI switcher component if the proxy backend should be displayed. It returns the current configuration and description for selection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "has_custom_system_shell", "line_number": 849, "body": "def has_custom_system_shell(self):\n        return True", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Indicates that the MicroPython device accessible through this proxy uses a custom system shell."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "open_custom_system_shell", "line_number": 852, "body": "def open_custom_system_shell(self):\n        if not shutil.which(\"ssh\"):\n            messagebox.showerror(\n                \"Command not found\", \"Command 'ssh' not found\", master=get_workbench()\n            )\n            return\n\n        from thonny import terminal\n\n        userhost = \"%s@%s\" % (self._user, self._host)\n        terminal.run_in_terminal(\n            [\"ssh\", userhost], cwd=get_workbench().get_local_cwd(), keep_open=False, title=userhost\n        )", "is_method": true, "class_name": "SshMicroPythonProxy", "function_description": "Opens a new system terminal window to establish an SSH connection to the remote MicroPython device. This allows users to directly interact with the remote system's shell."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "port_order", "line_number": 898, "body": "def port_order(p):\n        name = p.device\n        if name is None:\n            return \"\"\n        elif name.startswith(\"COM\") and len(name) == 4:\n            # Make one-digit COM ports go before COM10\n            return name.replace(\"COM\", \"COM0\")\n        else:\n            return name", "is_method": false, "function_description": "Returns a string key for device names, reformatting single-digit COM ports (e.g., COM1) to ensure proper numerical sorting order (e.g., before COM10)."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/__init__.py", "function": "port_order", "line_number": 430, "body": "def port_order(p):\n            _, name = p\n            if name is None:\n                return \"\"\n            elif name.startswith(\"COM\") and len(name) == 4:\n                # Make one-digit COM ports go before COM10\n                return name.replace(\"COM\", \"COM0\")\n            else:\n                return name", "is_method": true, "class_name": "BareMetalMicroPythonConfigPage", "function_description": "Generates a sortable key from a port name, ensuring correct numerical ordering for COM ports. This aids in consistently listing available serial connections."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/ssh_connection.py", "function": "write", "line_number": 28, "body": "def write(self, data, block_size=255, delay=0.01):\n        if isinstance(data, str):\n            data = data.encode(self.encoding)\n        self._stdin.write(data)\n        self._stdin.flush()\n        return len(data)", "is_method": true, "class_name": "SshProcessConnection", "function_description": "Sends provided data to the standard input of the remote process connected via SSH. It encodes string data and flushes the buffer for immediate delivery."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/ssh_connection.py", "function": "_listen_output", "line_number": 35, "body": "def _listen_output(self):\n        \"NB! works in background thread\"\n        try:\n            while not self._reader_stopped:\n                data = self._stdout.read(1)\n                if len(data) > 0:\n                    self._make_output_available(data)\n                else:\n                    self._error = \"EOF\"\n                    break\n\n        except Exception as e:\n            self._error = str(e)", "is_method": true, "class_name": "SshProcessConnection", "function_description": "Continuously monitors and captures standard output from an SSH process in a background thread. It makes the streamed output available for real-time consumption."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/ssh_connection.py", "function": "close", "line_number": 49, "body": "def close(self):\n        self._client.exec_command(\"kill -s SIGKILL %s\" % self._pid)\n        self._reading_thread.join()\n        self._client = None\n        self._reading_thread = None", "is_method": true, "class_name": "SshProcessConnection", "function_description": "Terminates the remote SSH process managed by this connection. It also cleans up the associated client and reading thread resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_report_internal_error", "line_number": 1376, "body": "def _report_internal_error(exception=None):\n    logger.exception(\"PROBLEM WITH THONNY'S BACK-END:\", exc_info=exception)", "is_method": false, "function_description": "Logs an internal error specific to Thonny's back-end, capturing full exception details. This function provides a centralized mechanism for reporting critical system problems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "parse_api_information", "line_number": 1380, "body": "def parse_api_information(file_path):\n    import tokenize\n\n    with tokenize.open(file_path) as fp:\n        source = fp.read()\n\n    tree = ast.parse(source)\n\n    defs = {}\n\n    # TODO: read also docstrings ?\n\n    for toplevel_item in tree.body:\n        if isinstance(toplevel_item, ast.ClassDef):\n            class_name = toplevel_item.name\n            member_names = []\n            for item in toplevel_item.body:\n                if isinstance(item, ast.FunctionDef):\n                    member_names.append(item.name)\n                elif isinstance(item, ast.Assign):\n                    # TODO: check Python 3.4\n                    \"TODO: item.targets[0].id\"\n\n            defs[class_name] = member_names\n\n    return defs", "is_method": false, "function_description": "Parses a Python source file to identify top-level classes and their defined methods. It returns a dictionary mapping class names to their method lists, useful for API introspection or documentation generation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "unix_dirname_basename", "line_number": 1408, "body": "def unix_dirname_basename(path):\n    if path == \"/\":\n        return (\"/\", \"\")\n\n    if \"/\" not in path:  # micro:bit\n        return \"\", path\n\n    path = path.rstrip(\"/\")\n    dir_, file_ = path.rsplit(\"/\", maxsplit=1)\n    if dir_ == \"\":\n        dir_ = \"/\"\n\n    return dir_, file_", "is_method": false, "function_description": "Separates a Unix-style file path into its parent directory and base name. Useful for parsing and manipulating file system paths."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "to_remote_path", "line_number": 1423, "body": "def to_remote_path(path):\n    return path.replace(\"\\\\\", \"/\")", "is_method": false, "function_description": "Converts a path string by replacing backslashes with forward slashes, making it suitable for remote systems or URLs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "ends_overlap", "line_number": 1427, "body": "def ends_overlap(left, right) -> int:\n    \"\"\"Returns the length of maximum overlap between end of the first and start of the second\"\"\"\n    max_overlap = min(len(left), len(right))\n    for i in range(max_overlap, 0, -1):\n        if left.endswith(right[:i]):\n            return i\n\n    return 0", "is_method": false, "function_description": "Calculates the maximum length of overlap where the end of the first input string matches the beginning of the second. Useful for smart string concatenation or finding common boundaries."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_prepare_after_soft_reboot", "line_number": 150, "body": "def _prepare_after_soft_reboot(self, clean):\n        self._report_time(\"bef preparing helpers\")\n        script = self._get_all_helpers()\n        self._check_perform_just_in_case_gc()\n        self._execute_without_output(script)\n        self._report_time(\"prepared helpers\")\n\n        self._update_cwd()\n        self._report_time(\"got cwd\")\n        self._sys_path = self._fetch_sys_path()\n\n        self._report_time(\"prepared\")\n        self._check_perform_just_in_case_gc()\n        logger.info(\"Prepared\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This MicroPythonBackend method prepares the MicroPython environment after a soft reboot. It deploys helper scripts and configures the current working directory and system path for proper operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_prepare_rtc", "line_number": 165, "body": "def _prepare_rtc(self):\n        if self._epoch_year is None:\n            self._epoch_year = self._fetch_epoch_year()\n\n        self._check_sync_time()\n        if self._args.get(\"validate_time\"):\n            self._validate_time()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Initializes the Real-Time Clock (RTC) for the MicroPython backend, ensuring the epoch year is set, time is synchronized, and optionally validated."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_check_perform_just_in_case_gc", "line_number": 173, "body": "def _check_perform_just_in_case_gc(self):\n        if self._connected_to_microbit():\n            # May fail to allocate memory without this\n            self._perform_gc()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method conditionally performs garbage collection if connected to a microbit. It prevents potential memory allocation failures by ensuring sufficient memory is available."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_check_sync_time", "line_number": 178, "body": "def _check_sync_time(self):\n        if self._args.get(\"sync_time\"):\n            self._sync_time()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Initiates time synchronization for the MicroPython device only if explicitly configured through its arguments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_perform_gc", "line_number": 182, "body": "def _perform_gc(self):\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n            import gc as __thonny_gc\n            __thonny_gc.collect()\n            del __thonny_gc\n        \"\"\"\n            )\n        )", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Initiates a garbage collection process on the MicroPython backend to free up memory. This clears unused objects, optimizing memory usage on the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_all_helpers", "line_number": 196, "body": "def _get_all_helpers(self):\n        # Can't import functions into class context:\n        # https://github.com/micropython/micropython/issues/6198\n        return (\n            dedent(\n                \"\"\"\n            class __thonny_helper:\n                try:\n                    import uos as os\n                except ImportError:\n                    import os\n                import sys\n                \n                # for object inspector\n                inspector_values = dict()\n                last_repl_values = []\n                @classmethod\n                def print_repl_value(cls, obj):\n                    if obj is not None:\n                        cls.last_repl_values.append(obj)\n                        cls.last_repl_values = cls.last_repl_values[-{num_values_to_keep}:]\n                        print({start_marker!r} % id(obj), repr(obj), {end_marker!r}, sep='')\n                \n                @staticmethod\n                def print_mgmt_value(obj):\n                    print({mgmt_start!r}, repr(obj), {mgmt_end!r}, sep='', end='')\n                    \n                @staticmethod\n                def repr(obj):\n                    try:\n                        s = repr(obj)\n                        if len(s) > 50:\n                            s = s[:50] + \"...\"\n                        return s\n                    except Exception as e:\n                        return \"<could not serialize: \" + str(e) + \">\"\n                    \n                @classmethod\n                def listdir(cls, x):\n                    if hasattr(cls.os, \"listdir\"):\n                        return cls.os.listdir(x)\n                    else:\n                        return [rec[0] for rec in cls.os.ilistdir(x) if rec[0] not in ('.', '..')]\n            \"\"\"\n            ).format(\n                num_values_to_keep=self._get_num_values_to_keep(),\n                start_marker=OBJECT_LINK_START,\n                end_marker=OBJECT_LINK_END,\n                mgmt_start=MGMT_VALUE_START.decode(ENCODING),\n                mgmt_end=MGMT_VALUE_END.decode(ENCODING),\n            )\n            + \"\\n\"\n            + textwrap.indent(self._get_custom_helpers(), \"    \")\n        )", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Generates a Python code string defining a helper class. This class provides essential utilities for Thonny IDE to manage, inspect, and interact with the MicroPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_num_values_to_keep", "line_number": 254, "body": "def _get_num_values_to_keep(self):\n        \"\"\"How many last evaluated REPL values and visited Object inspector values to keep\n        in internal lists for the purpose of retrieving them by id for Object inspector\"\"\"\n        return 5", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method specifies the maximum number of recently evaluated REPL values and inspected objects to retain. It helps manage the history size for retrieval by the Object Inspector."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_time_for_rtc", "line_number": 262, "body": "def _get_time_for_rtc(self):\n        if self._args[\"utc_clock\"]:\n            return datetime.datetime.now(tz=datetime.timezone.utc).timetuple()\n        else:\n            return datetime.datetime.now().timetuple()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides the current time, either UTC or local, formatted as a time tuple for a Real-Time Clock (RTC)."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_validate_time", "line_number": 268, "body": "def _validate_time(self):\n        this_computer = self._get_time_for_rtc()\n        remote = self._get_utc_timetuple_from_device()\n        if isinstance(remote, tuple):\n            # tweak the format if required\n            remote = remote[:8]\n            while len(remote) < 8:\n                remote += (0,)\n            remote += (-1,)  # unknown DST\n            diff = int(time.mktime(this_computer) - time.mktime(remote))\n            if abs(diff) > 10:\n                print(\"WARNING: Device's real-time clock seems to be off by %s seconds\" % diff)\n        else:\n            assert isinstance(remote, str)\n            print(\"WARNING: Could not validate time: \" + remote)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Compares the local computer's time with the remote MicroPython device's real-time clock. It warns if their time difference exceeds a threshold, ensuring time synchronization for the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_perform_idle_tasks", "line_number": 296, "body": "def _perform_idle_tasks(self):\n        self._forward_unexpected_output()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This internal method, executed during idle times, processes and forwards any unexpected output from the connected MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_handle_user_input", "line_number": 299, "body": "def _handle_user_input(self, msg: InputSubmission) -> None:\n        self._submit_input(msg.data)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Receives and processes incoming user input messages for the MicroPython backend. It extracts the message data and submits it to an internal handler for further processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_handle_immediate_command", "line_number": 305, "body": "def _handle_immediate_command(self, cmd: ImmediateCommand) -> None:\n        if cmd[\"name\"] == \"interrupt\":\n            # don't interrupt while command or input is being written\n            with self._interrupt_lock:\n                if self._current_command:\n                    self._current_command.interrupted = True\n                self._write(INTERRUPT_CMD)\n                time.sleep(0.1)\n                self._write(INTERRUPT_CMD)\n                time.sleep(0.1)\n                self._write(INTERRUPT_CMD)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Sends multiple interrupt signals to the MicroPython device in response to an immediate 'interrupt' command, avoiding disruption of currently written commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_handle_normal_command", "line_number": 317, "body": "def _handle_normal_command(self, cmd: CommandToBackend) -> None:\n        logger.info(\"Handling command '%s'\", cmd.name)\n        self._report_time(\"before \" + cmd.name)\n        assert isinstance(cmd, (ToplevelCommand, InlineCommand))\n\n        if \"local_cwd\" in cmd:\n            self._local_cwd = cmd[\"local_cwd\"]\n\n        def create_error_response(**kw):\n            if \"error\" not in kw:\n                kw[\"error\"] = traceback.format_exc()\n\n            if isinstance(cmd, ToplevelCommand):\n                return ToplevelResponse(command_name=cmd.name, **kw)\n            else:\n                return InlineResponse(command_name=cmd.name, **kw)\n\n        handler = getattr(self, \"_cmd_\" + cmd.name, None)\n\n        if handler is None:\n            response = create_error_response(error=\"Unknown command: \" + cmd.name)\n        else:\n            try:\n                response = handler(cmd)\n            except SystemExit as e:\n                # Must be caused by Thonny or plugins code\n                if isinstance(cmd, ToplevelCommand):\n                    logger.exception(\"Unexpected SystemExit\", exc_info=e)\n                response = create_error_response(SystemExit=True)\n            except UserError as e:\n                sys.stderr.write(str(e) + \"\\n\")\n                response = create_error_response()\n            except KeyboardInterrupt:\n                response = create_error_response(error=\"Interrupted\", interrupted=True)\n            except ConnectionClosedException as e:\n                self._on_connection_closed(e)\n            except ManagementError as e:\n                if \"KeyboardInterrupt\" in e.err:\n                    response = create_error_response(error=\"Interrupted\", interrupted=True)\n                else:\n                    self._send_output(\"THONNY FAILED TO EXECUTE COMMAND %s\\n\" % cmd.name, \"stderr\")\n                    # traceback.print_exc() # I'll know the trace from command\n                    self._show_error(\"\\n\")\n                    self._show_error(\"SCRIPT:\\n\" + e.script + \"\\n\")\n                    self._show_error(\"STDOUT:\\n\" + e.out + \"\\n\")\n                    self._show_error(\"STDERR:\\n\" + e.err + \"\\n\")\n\n                    response = create_error_response(error=\"ManagementError\")\n            except Exception as e:\n                _report_internal_error(e)\n                response = create_error_response(context_info=\"other unhandled exception\")\n\n        if response is None:\n            response = {}\n\n        if response is False:\n            # Command doesn't want to send any response\n            return\n\n        elif isinstance(response, dict):\n            if isinstance(cmd, ToplevelCommand):\n                response = ToplevelResponse(command_name=cmd.name, **response)\n            elif isinstance(cmd, InlineCommand):\n                response = InlineResponse(cmd.name, **response)\n\n        debug(\"cmd: \" + str(cmd) + \", respin: \" + str(response))\n        self.send_message(self._prepare_command_response(response, cmd))\n\n        self._check_perform_just_in_case_gc()\n\n        self._report_time(\"after \" + cmd.name)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method in `MicroPythonBackend` dispatches and executes various commands received from the frontend. It robustly handles execution errors and constructs appropriate responses to be sent back."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_should_keep_going", "line_number": 389, "body": "def _should_keep_going(self) -> bool:\n        return self._is_connected()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method determines if an operation within the MicroPython backend should continue. It signals that continuation is dependent on the backend's active connection status."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_connected_to_microbit", "line_number": 395, "body": "def _connected_to_microbit(self):\n        return \"micro:bit\" in self._welcome_text.lower()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Checks if the MicroPython backend is connected to a micro:bit device. It determines connection status by inspecting the device's welcome text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_connected_to_pyboard", "line_number": 398, "body": "def _connected_to_pyboard(self):\n        return \"pyb\" in self._welcome_text.lower() or \"pyb\" in self._builtin_modules", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This internal method verifies if the MicroPython backend is currently connected to a Pyboard device. It determines compatibility for Pyboard-specific operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_connected_to_circuitpython", "line_number": 401, "body": "def _connected_to_circuitpython(self):\n        return \"circuitpython\" in self._welcome_text.lower()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Checks if the connected MicroPython device is running CircuitPython, based on keywords in its welcome message. This helps in tailoring interactions specific to CircuitPython."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_connected_to_pycom", "line_number": 404, "body": "def _connected_to_pycom(self):\n        return \"pycom\" in self._welcome_text.lower()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Determines if the MicroPython backend is connected to a Pycom device based on the welcome message received upon connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_fetch_sys_path", "line_number": 413, "body": "def _fetch_sys_path(self):\n        if not self._supports_directories():\n            return []\n        else:\n            return self._evaluate(\"__thonny_helper.sys.path\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Retrieves the module search path (`sys.path`) from the MicroPython device. This capability helps understand where modules are located on the target system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_fetch_builtins_info", "line_number": 419, "body": "def _fetch_builtins_info(self):\n        result = {}\n\n        for name in [\"builtins.py\", \"builtins.pyi\"]:\n            path = os.path.join(self._api_stubs_path, name)\n            if os.path.exists(path):\n                result = parse_api_information(path)\n\n        return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Retrieves information about MicroPython's built-in functions and objects by parsing specific stub files. This populates a dictionary, providing the backend with API awareness."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_fetch_epoch_year", "line_number": 429, "body": "def _fetch_epoch_year(self):\n        if self._connected_to_microbit():\n            return None\n\n        # The proper solution would be to query time.gmtime, but most devices don't have this function.\n        # Luckily, time.localtime is good enough for deducing 1970 vs 2000 epoch.\n\n        # Most obvious solution would be to query for 0-time, but CP doesn't support anything below Y2000,\n        # so I'm querying this and adjusting later.\n        val = self._evaluate(\n            dedent(\n                \"\"\"\n            try:\n                from time import localtime as __thonny_localtime\n                __thonny_helper.print_mgmt_value(tuple(__thonny_localtime(%d)))\n                del __thonny_localtime\n            except Exception as e:\n                __thonny_helper.print_mgmt_value(str(e))\n        \"\"\"\n                % Y2000_EPOCH_OFFSET\n            )\n        )\n\n        if val[0] in (2000, 1999):\n            # when it gives 2000 (or end of 1999) for 2000-01-01 counted from Posix epoch, then it uses Posix epoch\n            # Used by Unix port, CP and Pycom\n            return 1970\n        elif val[0] in (2030, 2029):\n            # when it looks 30 years off, then it must be 2000 epoch\n            # Used by Pyboard and ESP-s\n            return 2000\n        else:\n            result = self._resolve_unknown_epoch()\n            if self._args.get(\"sync_time\") or self._args.get(\"validate_time\"):\n                print(\"WARNING: Could not determine epoch year (%s), assuming %s\" % (val, result))\n            return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method of `MicroPythonBackend` determines whether the connected MicroPython device uses a 1970 or 2000 epoch for its internal clock. This ensures correct interpretation and synchronization of timestamps."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_update_cwd", "line_number": 466, "body": "def _update_cwd(self):\n        if not self._connected_to_microbit():\n            self._cwd = self._evaluate(\"__thonny_helper.getcwd()\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Updates the internal current working directory property of the MicroPythonBackend. It queries the connected MicroPython device for its CWD under specific connection conditions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_send_ready_message", "line_number": 470, "body": "def _send_ready_message(self):\n        args = dict(cwd=self._cwd)\n        args[\"welcome_text\"] = self._welcome_text\n\n        self.send_message(ToplevelResponse(**args))", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Sends an initial \"ready\" message to the client. This message includes the current working directory and a welcome text, providing initial context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "send_message", "line_number": 482, "body": "def send_message(self, msg: MessageFromBackend) -> None:\n        if \"cwd\" not in msg:\n            msg[\"cwd\"] = self._cwd\n\n        if \"sys_path\" not in msg:\n            msg[\"sys_path\"] = self._sys_path\n\n        if \"lib_dirs\" not in msg:\n            msg[\"lib_dirs\"] = self._get_library_paths()\n\n        super().send_message(msg)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method prepares messages for the MicroPython backend by automatically adding default current working directory, system path, and library directories. It ensures all necessary contextual information is included before sending."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_send_error_message", "line_number": 494, "body": "def _send_error_message(self, msg):\n        self._send_output(\"\\n\" + msg + \"\\n\", \"stderr\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method sends a formatted error message to the standard error output stream, ensuring consistent error reporting within the MicroPython backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_execute", "line_number": 497, "body": "def _execute(self, script, capture_output=False) -> Tuple[str, str]:\n        if capture_output:\n            output_lists = {\"stdout\": [], \"stderr\": []}\n\n            def consume_output(data, stream_name):\n                assert isinstance(data, str)\n                output_lists[stream_name].append(data)\n\n            self._execute_with_consumer(script, consume_output)\n            result = [\"\".join(output_lists[name]) for name in [\"stdout\", \"stderr\"]]\n            return result[0], result[1]\n        else:\n            self._execute_with_consumer(script, self._send_output)\n            return \"\", \"\"", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Executes a MicroPython script on the backend, optionally capturing and returning its standard output and error streams. This enables programmatic analysis of script execution results."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_execute_without_output", "line_number": 529, "body": "def _execute_without_output(self, script):\n        \"\"\"Meant for management tasks.\"\"\"\n        out, err = self._execute(script, capture_output=True)\n        if out or err:\n            raise ManagementError(script, out, err)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Executes a MicroPython script for management tasks, ensuring it produces no output. Raises an error if the script generates any stdout or stderr."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_evaluate", "line_number": 535, "body": "def _evaluate(self, script):\n        \"\"\"Evaluate the output of the script or raise ManagementError, if anything looks wrong.\n\n        Adds printing code if the script contains single expression and doesn't\n        already contain printing code\"\"\"\n        try:\n            ast.parse(script, mode=\"eval\")\n            prefix = \"__thonny_helper.print_mgmt_value(\"\n            suffix = \")\"\n            if not script.strip().startswith(prefix):\n                script = prefix + script + suffix\n        except SyntaxError:\n            pass\n\n        out, err = self._execute(script, capture_output=True)\n        if (\n            err\n            or MGMT_VALUE_START.decode(ENCODING) not in out\n            or MGMT_VALUE_END.decode(ENCODING) not in out\n        ):\n            raise ManagementError(script, out, err)\n\n        start_token_pos = out.index(MGMT_VALUE_START.decode(ENCODING))\n        end_token_pos = out.index(MGMT_VALUE_END.decode(ENCODING))\n\n        # a thread or IRQ handler may have written something before or after mgmt value\n        prefix = out[:start_token_pos]\n        value_str = out[start_token_pos + len(MGMT_VALUE_START) : end_token_pos]\n        suffix = out[end_token_pos + len(MGMT_VALUE_END) :]\n\n        try:\n            value = ast.literal_eval(value_str)\n            self._send_output(prefix, \"stdout\")\n            self._send_output(suffix, \"stdout\")\n            return value\n        except SyntaxError:\n            raise ManagementError(script, out, err)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Evaluates a MicroPython script by executing it and extracting a specific management value from its output, ensuring the process completes successfully or raising a `ManagementError`."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_check_for_side_commands", "line_number": 577, "body": "def _check_for_side_commands(self):\n        # NB! EOFCommand gets different treatment depending whether it is read during processing a command\n        # (ie. here) or it gets read when REPL is idle (ie. in mainloop)\n\n        # most likely the queue is empty\n        if self._incoming_message_queue.empty():\n            return\n\n        postponed = []\n        while not self._incoming_message_queue.empty():\n            cmd = self._incoming_message_queue.get()\n            if isinstance(cmd, InputSubmission):\n                self._submit_input(cmd.data)\n            elif isinstance(cmd, EOFCommand):\n                # in this context it is not supposed to soft-reboot\n                self._write(b\"\\x04\")\n            else:\n                postponed.append(cmd)\n\n        # put back postponed commands\n        while postponed:\n            self._incoming_message_queue.put(postponed.pop(0))", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Processes incoming commands from a queue for the MicroPython backend, dispatching input submissions and EOF signals. It manages the queue by re-queuing unhandled commands for later processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_supports_directories", "line_number": 600, "body": "def _supports_directories(self):\n        # NB! make sure self._cwd is queried first\n        return bool(self._cwd)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Checks if the MicroPython backend supports file system directories. It returns true if a current working directory is established, indicating this capability."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_cd", "line_number": 604, "body": "def _cmd_cd(self, cmd):\n        if len(cmd.args) == 1:\n            if not self._supports_directories():\n                raise UserError(\"This device doesn't have directories\")\n\n            path = cmd.args[0]\n            self._execute(\"__thonny_helper.chdir(%r)\" % path)\n            self._update_cwd()\n            return {}\n        else:\n            raise UserError(\"%cd takes one parameter\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Allows changing the current working directory on the connected MicroPython device. It verifies device directory support and updates the backend's internal state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_execute_source", "line_number": 619, "body": "def _cmd_execute_source(self, cmd):\n        # TODO: clear last object inspector requests dictionary\n        if cmd.source:\n            source = self._add_expression_statement_handlers(cmd.source)\n            self._report_time(\"befexeccc\")\n            self._execute(source, capture_output=False)\n            self._check_prepare()\n            self._report_time(\"affexeccc\")\n        # TODO: assign last value to _\n        return {}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Executes MicroPython source code contained within a command object. This function enables the MicroPythonBackend to run user-submitted code in the target environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_get_globals", "line_number": 633, "body": "def _cmd_get_globals(self, cmd):\n        if cmd.module_name == \"__main__\":\n            globs = self._evaluate(\n                \"{name : (__thonny_helper.repr(value), id(value)) for (name, value) in globals().items() if not name.startswith('__')}\"\n            )\n        else:\n            globs = self._evaluate(\n                dedent(\n                    \"\"\"\n                import %s as __mod_for_globs\n                __thonny_helper.print_mgmt_value(\n                    {name : (__thonny_helper.repr(getattr(__mod_for_globs, name)), \n                             id(getattr(__mod_for_globs, name)))\n                        in dir(__mod_for_globs) \n                        if not name.startswith('__')}\n                )\n                del __mod_for_globs\n            \"\"\"\n                )\n            )\n\n        value_infos = {}\n        for name, pair in globs.items():\n            value_infos[name] = ValueInfo(pair[1], pair[0])\n\n        return {\"module_name\": cmd.module_name, \"globals\": value_infos}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Retrieves global variable names, their string representations, and memory IDs from the MicroPython environment. It provides a snapshot of the current or specified module's global scope."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_get_object_info", "line_number": 663, "body": "def _cmd_get_object_info(self, cmd):\n        context_id = cmd.get(\"context_id\", None)\n        basic_info = self._find_basic_object_info(cmd.object_id, context_id)\n        if basic_info is None:\n            return {\"id\": cmd.object_id, \"error\": \"object info not available\"}\n\n        type_name = basic_info[\"type\"].replace(\"<class '\", \"\").replace(\"'>\", \"\").strip()\n        info = {\n            \"id\": cmd.object_id,\n            \"repr\": basic_info[\"repr\"],\n            \"type\": basic_info[\"type\"],\n            \"full_type_name\": type_name,\n            \"attributes\": {},\n        }\n\n        info.update(self._get_object_info_extras(type_name))\n        if cmd.include_attributes:\n            info[\"attributes\"] = self._get_object_attributes(cmd.all_attributes)\n\n        # need to keep the reference corresponding to object_id so that it can be later found as next context object\n        # remove non-relevant items\n        # TODO: add back links\n        # relevant = set([cmd.object_id] + cmd.back_links + cmd.forward_links)\n        self._execute(\n            dedent(\n                \"\"\"\n                if id(__thonny_helper.object_info) not in __thonny_helper.inspector_values:\n                    __thonny_helper.inspector_values[id(__thonny_helper.object_info)] = __thonny_helper.object_info\n            \"\"\"\n            )\n        )\n\n        return {\"id\": cmd.object_id, \"info\": info}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides a service to retrieve comprehensive details for a given object ID, including its type, representation, and attributes. This supports object inspection and debugging in a MicroPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_find_basic_object_info", "line_number": 697, "body": "def _find_basic_object_info(self, object_id, context_id):\n        \"\"\"If object is found then returns basic info and leaves object reference\n        to __thonny_helper.object_info.\n\n        Can't leave it in a global object, because when querying globals(),\n        repr(globals()) would cause inifite recursion.\"\"\"\n\n        result = self._evaluate(\n            dedent(\n                \"\"\"\n                for __thonny_helper.object_info in (\n                        list(globals().values()) \n                        + __thonny_helper.last_repl_values\n                        + list(__thonny_helper.inspector_values.values())):\n                    if id(__thonny_helper.object_info) == %d:\n                        __thonny_helper.print_mgmt_value({\n                            \"repr\" : repr(__thonny_helper.object_info),\n                            \"type\": str(type(__thonny_helper.object_info))\n                        })\n                        break\n                else:\n                    __thonny_helper.object_info = None\n                    __thonny_helper.print_mgmt_value(None)\n            \"\"\"\n                % object_id\n            )\n        )\n\n        if result is not None:\n            return result\n        elif context_id is not None:\n            return self._evaluate(\n                dedent(\n                    \"\"\"\n                __thonny_helper.context_value = __thonny_helper.inspector_values.get(%d, None)\n                \n                if __thonny_helper.context_value is None:\n                    __thonny_helper.object_info = None\n                    __thonny_helper.print_mgmt_value(None)\n                else:\n                    __thonny_helper.context_children = [\n                         getattr(__thonny_helper.context_value, name)\n                         for name in dir(__thonny_helper.context_value)\n                    ]\n                    if isinstance(__thonny_helper.context_value, (set, tuple, list)):\n                        __thonny_helper.context_children += list(__thonny_helper.context_value)\n                    elif isinstance(__thonny_helper.context_value, dict):\n                        __thonny_helper.context_children += list(__thonny_helper.context_value.values())\n                    \n                    for __thonny_helper.object_info in __thonny_helper.context_children:\n                        if id(__thonny_helper.object_info) == %d:\n                            __thonny_helper.print_mgmt_value({\n                                \"repr\" : __thonny_helper.repr(__thonny_helper.object_info),\n                                \"type\": str(type(__thonny_helper.object_info))\n                            })\n                            break\n                    else:\n                        __thonny_helper.object_info = None\n                        \n                __thonny_helper.context_value = None\n                __thonny_helper.context_children = None\n            \"\"\"\n                    % (context_id, object_id)\n                )\n            )\n        else:\n            return None", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Locates a specific Python object by its ID within the remote MicroPython environment. It retrieves the object's string representation and type, supporting contextual searches within parent objects."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_object_attributes", "line_number": 765, "body": "def _get_object_attributes(self, all_attributes):\n        \"\"\"object is given in __thonny_helper.object_info \"\"\"\n        atts = self._evaluate(\n            \"{name : (\"\n            \"   id(getattr(__thonny_helper.object_info, name)),\"\n            \"    __thonny_helper.repr(getattr(__thonny_helper.object_info, name))\"\n            \") for name in dir(__thonny_helper.object_info)}\"\n        )\n        return {\n            name: ValueInfo(atts[name][0], atts[name][1])\n            for name in atts\n            if not name.startswith(\"__\") or all_attributes\n        }", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "It retrieves the names, IDs, and string representations of an object's attributes from the MicroPython backend. This enables remote object introspection and debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_object_info_extras", "line_number": 779, "body": "def _get_object_info_extras(self, type_name):\n        \"\"\"object is given in __thonny_helper.object_info \"\"\"\n        if type_name in (\"list\", \"tuple\", \"set\"):\n            items = self._evaluate(\n                \"[(id(x), __thonny_helper.repr(x)) for x in __thonny_helper.object_info]\"\n            )\n            return {\"elements\": [ValueInfo(x[0], x[1]) for x in items]}\n        elif type_name == \"dict\":\n            items = self._evaluate(\n                \"[((id(key), __thonny_helper.repr(key)), (id(__thonny_helper.object_info[key]), \"\n                \"__thonny_helper.repr(__thonny_helper.object_info[key]))) for key in __thonny_helper.object_info]\"\n            )\n            return {\n                \"entries\": [\n                    (ValueInfo(x[0][0], x[0][1]), ValueInfo(x[1][0], x[1][1])) for x in items\n                ]\n            }\n        else:\n            return {}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Retrieves detailed information about the elements of container types (list, tuple, set, dict) from an object on a MicroPython device for debugging or introspection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_delete", "line_number": 799, "body": "def _cmd_delete(self, cmd):\n        assert cmd.paths\n        self._delete_sorted_paths(sorted(cmd.paths, key=len, reverse=True))", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Processes a delete command to remove specified paths from the MicroPython device. It sorts the paths by length for robust deletion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_get_active_distributions", "line_number": 803, "body": "def _cmd_get_active_distributions(self, cmd):\n        try:\n            dists = {}\n            for path in self._get_library_paths():\n                children = self._get_dir_children_info(path)\n                if children is None:\n                    continue\n                for name, info in children.items():\n                    if info[\"kind\"] == \"dir\":\n                        key = name\n                    elif name.endswith(\".py\"):\n                        key = name[:-3]\n                    elif name.endswith(\".mpy\"):\n                        key = name[:-4]\n                    else:\n                        continue\n\n                    dists[key] = {\n                        \"project_name\": key,\n                        \"key\": key,\n                        \"guessed_pypi_name\": self._guess_package_pypi_name(key),\n                        \"location\": path,\n                        \"version\": \"n/a\",\n                    }\n\n            return dict(\n                distributions=dists,\n                usersitepackages=None,\n            )\n        except Exception:\n            return InlineResponse(\"get_active_distributions\", error=traceback.format_exc())", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides a catalog of active MicroPython libraries and modules. It identifies them by name, location, and attempts to guess their PyPI equivalent for system inventory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_get_module_info", "line_number": 835, "body": "def _cmd_get_module_info(self, cmd):\n        location = None\n        effective_items = []\n        shadowed_items = []\n\n        for lib_dir in self._get_library_paths():\n            dir_children = self._get_dir_children_info(lib_dir)\n            if not dir_children:\n                continue\n\n            # print(lib_dir, dir_children)\n\n            if cmd.module_name in dir_children and dir_children[cmd.module_name][\"kind\"] == \"dir\":\n                # dir takes precedence over .py and .mpy\n                # presence of __init__.py is not required\n                dir_full_path = lib_dir + \"/\" + cmd.module_name\n                descendants = self._get_dir_descendants_info(dir_full_path)\n                # print(\"desc\", dir_full_path, descendants)\n                desc_paths = list(sorted(descendants.keys()))\n\n                if not effective_items:  # ie. it's the first one found\n                    effective_items.append(dir_full_path)\n                    effective_items.extend(desc_paths)\n                    location = lib_dir\n                else:\n                    shadowed_items.extend(desc_paths)\n\n            for suffix in [\".py\", \".mpy\"]:\n                with_suffix = cmd.module_name + suffix\n                if with_suffix in dir_children and dir_children[with_suffix][\"kind\"] == \"file\":\n                    full_path = lib_dir + \"/\" + with_suffix\n                    if not effective_items:\n                        effective_items.append(full_path)\n                        location = lib_dir\n                    else:\n                        shadowed_items.append(full_path)\n\n        return {\n            \"location\": location,\n            \"effective_items\": effective_items,\n            \"shadowed_items\": shadowed_items,\n            \"module_name\": cmd.module_name,\n        }", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method resolves a MicroPython module's location by searching configured library paths. It identifies the effective module path and any other files or directories that would be shadowed."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_library_paths", "line_number": 879, "body": "def _get_library_paths(self) -> [str]:\n        \"\"\"Returns list of directories which are supposed to contain library code\"\"\"\n        if self._sys_path is None:\n            return None\n\n        return [path for path in self._sys_path if \"lib\" in path and path.startswith(\"/\")]", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Retrieves a filtered list of potential library directories from the backend's system path. It includes paths containing \"lib\" and starting with \"/\"."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_guess_package_pypi_name", "line_number": 886, "body": "def _guess_package_pypi_name(self, installed_name) -> str:\n        return \"micropython-\" + installed_name", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method guesses the PyPI package name for a MicroPython library. It prepends \"micropython-\" to an installed package's name."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_mkdir", "line_number": 889, "body": "def _mkdir(self, path: str) -> None:\n        # assumes part path exists and path doesn't\n        self._execute_without_output(\"__thonny_helper.os.mkdir(%r)\" % path)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method creates a new directory at the specified path on the connected MicroPython device. It serves as an internal utility for remote filesystem management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_delete_sorted_paths", "line_number": 893, "body": "def _delete_sorted_paths(self, paths):\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n            def __thonny_delete(path):\n                if __thonny_helper.os.stat(path)[0] & 0o170000 == 0o040000:\n                    for name in __thonny_helper.listdir(path):\n                        child_path = path + \"/\" + name\n                        __thonny_delete(child_path)\n                    __thonny_helper.rmdir(path)\n                else:\n                    __thonny_helper.os.remove(path)\n            \n            for __thonny_path in %r: \n                __thonny_delete(__thonny_path)\n                \n            del __thonny_path\n            del __thonny_delete\n            \n        \"\"\"\n            )\n            % paths\n        )", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Deletes specified files and recursively removes directories on the connected MicroPython device. This facilitates backend file system management and cleanup operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_stat", "line_number": 917, "body": "def _get_stat(\n        self, path: str\n    ) -> Optional[Tuple[int, int, int, int, int, int, int, int, int, int]]:\n        if not self._supports_directories():\n            func = \"size\"\n        else:\n            func = \"stat\"\n\n        stat = self._evaluate(\n            dedent(\n                \"\"\"\n            try:\n                __thonny_helper.print_mgmt_value(__thonny_helper.os.%s(%r))\n            except Exception:\n                __thonny_helper.print_mgmt_value(None)\n            \"\"\"\n            )\n            % (func, path)\n        )\n\n        if stat is None:\n            return None\n        elif isinstance(stat, int):\n            return (0b1000000000000000, 0, 0, 0, 0, 0, stat, 0, 0, 0)\n        else:\n            return stat", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Retrieves file system statistics or size for a given path on a MicroPython device. It adapts its retrieval method based on the device's directory support."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_mkdir", "line_number": 944, "body": "def _cmd_mkdir(self, cmd):\n        assert self._supports_directories()\n        assert cmd.path.startswith(\"/\")\n        assert not cmd.path.startswith(\"//\")\n        self._mkdir(cmd.path)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Handles a command to create a new directory on the MicroPython backend's filesystem. It ensures the backend supports directories and the provided path is valid before execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_editor_autocomplete", "line_number": 950, "body": "def _cmd_editor_autocomplete(self, cmd):\n        # template for the response\n        result = dict(source=cmd.source, row=cmd.row, column=cmd.column)\n\n        try:\n            from thonny import jedi_utils\n\n            completions = jedi_utils.get_script_completions(\n                cmd.source,\n                cmd.row,\n                cmd.column,\n                filename=cmd.filename,\n                sys_path=[self._api_stubs_path],\n            )\n            result[\"completions\"] = self._filter_completions(completions)\n        except Exception as e:\n            logger.exception(\"Problem with editor autocomplete\", exc_info=e)\n            result[\"error\"] = \"Autocomplete error\"\n\n        return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Generates code autocompletion suggestions for the editor. It uses Jedi to provide context-aware completions, including support for MicroPython API stubs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_filter_completions", "line_number": 971, "body": "def _filter_completions(self, completions):\n        # filter out completions not applicable to MicroPython\n        result = []\n        for completion in completions:\n            if completion.name.startswith(\"__\"):\n                continue\n\n            if completion.parent() and completion.full_name:\n                parent_name = completion.parent().name\n                name = completion.name\n                root = completion.full_name.split(\".\")[0]\n\n                # jedi proposes names from CPython builtins\n                if root in self._builtins_info and name not in self._builtins_info[root]:\n                    continue\n\n                if parent_name == \"builtins\" and name not in self._builtins_info:\n                    continue\n\n            result.append({\"name\": completion.name, \"complete\": completion.complete})\n\n        return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Filters code completion suggestions, removing those not applicable or available within the MicroPython environment. It ensures accurate and relevant completion options for MicroPython development."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_shell_autocomplete", "line_number": 994, "body": "def _cmd_shell_autocomplete(self, cmd):\n        source = cmd.source\n\n        # TODO: combine dynamic results and jedi results\n        if source.strip().startswith(\"import \") or source.strip().startswith(\"from \"):\n            # this needs the power of jedi\n            response = {\"source\": cmd.source}\n\n            try:\n                from thonny import jedi_utils\n\n                # at the moment I'm assuming source is the code before cursor, not whole input\n                lines = source.split(\"\\n\")\n                completions = jedi_utils.get_script_completions(\n                    source, len(lines), len(lines[-1]), \"<shell>\", sys_path=[self._api_stubs_path]\n                )\n                response[\"completions\"] = self._filter_completions(completions)\n            except Exception as e:\n                logger.exception(\"Problem with shell autocomplete\", exc_info=e)\n                response[\"error\"] = \"Autocomplete error\"\n\n            return response\n        else:\n            # use live data\n            match = re.search(\n                r\"(\\w+\\.)*(\\w+)?$\", source\n            )  # https://github.com/takluyver/ubit_kernel/blob/master/ubit_kernel/kernel.py\n            if match:\n                prefix = match.group()\n                if \".\" in prefix:\n                    obj, prefix = prefix.rsplit(\".\", 1)\n                    names = self._evaluate(\n                        \"dir({obj}) if '{obj}' in locals() or '{obj}' in globals() else []\".format(\n                            obj=obj\n                        )\n                    )\n                else:\n                    names = self._evaluate(\"dir()\")\n            else:\n                names = []\n                prefix = \"\"\n\n            completions = []\n\n            # prevent TypeError (iterating over None)\n            names = names if names else []\n\n            for name in names:\n                if name.startswith(prefix) and not name.startswith(\"__\"):\n                    completions.append({\"name\": name, \"complete\": name[len(prefix) :]})\n\n            return {\"completions\": completions, \"source\": source}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides intelligent autocompletion for the MicroPython shell by suggesting import statements using Jedi and dynamically completing available names from the live environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_cmd_dump_api_info", "line_number": 1047, "body": "def _cmd_dump_api_info(self, cmd):\n        \"For use during development of the plug-in\"\n\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n            def __get_object_atts(obj):\n                result = []\n                errors = []\n                for name in dir(obj):\n                    try:\n                        val = getattr(obj, name)\n                        result.append((name, repr(val), repr(type(val))))\n                    except BaseException as e:\n                        errors.append(\"Couldn't get attr '%s' from object '%r', Err: %r\" % (name, obj, e))\n                return (result, errors)\n        \"\"\"\n            )\n        )\n\n        for module_name in sorted(self._fetch_builtin_modules()):\n            if (\n                not module_name.startswith(\"_\")\n                and not module_name.startswith(\"adafruit\")\n                # and not module_name == \"builtins\"\n            ):\n                file_name = os.path.join(\n                    self._api_stubs_path, module_name.replace(\".\", \"/\") + \".py\"\n                )\n                self._dump_module_stubs(module_name, file_name)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "A development utility that generates API stub files for built-in MicroPython modules. This provides improved IDE autocompletion and type checking for plugin developers."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_dump_module_stubs", "line_number": 1078, "body": "def _dump_module_stubs(self, module_name, file_name):\n        self._execute_without_output(\"import {0}\".format(module_name))\n\n        os.makedirs(os.path.dirname(file_name), exist_ok=True)\n        with io.open(file_name, \"w\", encoding=\"utf-8\", newline=\"\\n\") as fp:\n            if module_name not in [\n                \"webrepl\",\n                \"_webrepl\",\n                \"gc\",\n                \"http_client\",\n                \"http_client_ssl\",\n                \"http_server\",\n                \"framebuf\",\n                \"example_pub_button\",\n                \"flashbdev\",\n            ]:\n                self._dump_object_stubs(fp, module_name, \"\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Generates stubs for a specified MicroPython module, writing its interface definitions to a file. This aids in providing type information and autocompletion for development environments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_dump_object_stubs", "line_number": 1096, "body": "def _dump_object_stubs(self, fp, object_expr, indent):\n        if object_expr in [\n            \"docs.conf\",\n            \"pulseio.PWMOut\",\n            \"adafruit_hid\",\n            \"upysh\",\n            # \"webrepl\",\n            # \"gc\",\n            # \"http_client\",\n            # \"http_server\",\n        ]:\n            print(\"SKIPPING problematic name:\", object_expr)\n            return\n\n        print(\"DUMPING\", indent, object_expr)\n        items, errors = self._evaluate(\"__get_object_atts({0})\".format(object_expr))\n\n        if errors:\n            print(\"ERRORS\", errors)\n\n        for name, rep, typ in sorted(items, key=lambda x: x[0]):\n            if name.startswith(\"__\"):\n                continue\n\n            print(\"DUMPING\", indent, object_expr, name)\n            print(\"  * \" + name + \" : \" + typ)\n\n            if typ in [\"<class 'function'>\", \"<class 'bound_method'>\"]:\n                fp.write(indent + \"def \" + name + \"():\\n\")\n                fp.write(indent + \"    pass\\n\\n\")\n            elif typ in [\"<class 'str'>\", \"<class 'int'>\", \"<class 'float'>\"]:\n                fp.write(indent + name + \" = \" + rep + \"\\n\")\n            elif typ == \"<class 'type'>\" and indent == \"\":\n                # full expansion only on toplevel\n                fp.write(\"\\n\")\n                fp.write(indent + \"class \" + name + \":\\n\")  # What about superclass?\n                fp.write(indent + \"    ''\\n\")\n                self._dump_object_stubs(fp, \"{0}.{1}\".format(object_expr, name), indent + \"    \")\n            else:\n                # keep only the name\n                fp.write(indent + name + \" = None\\n\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Generates Python stub code for a given MicroPython object, including its members. It recursively creates `def`, `class`, or variable definitions, primarily for static analysis and IDE autocompletion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_join_remote_path_parts", "line_number": 1138, "body": "def _join_remote_path_parts(self, left, right):\n        if left == \"\":  # micro:bit\n            assert not self._supports_directories()\n            return right.strip(\"/\")\n\n        return left.rstrip(\"/\") + \"/\" + right.strip(\"/\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This internal helper method joins two remote path segments for MicroPython devices. It correctly formats paths, specifically handling devices that lack a hierarchical directory structure."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_file_size", "line_number": 1145, "body": "def _get_file_size(self, path: str) -> int:\n        stat = self._get_stat(path)\n        if stat is None:\n            raise RuntimeError(\"Path '%s' does not exist\" % path)\n\n        return stat[STAT_SIZE_INDEX]", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Retrieves the size of a specified file within the MicroPython backend's file system. It provides essential file metadata."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_stat_mode", "line_number": 1152, "body": "def _get_stat_mode(self, path: str) -> Optional[int]:\n        stat = self._get_stat(path)\n        if stat is None:\n            return None\n        return stat[0]", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Retrieves the file mode (type and permissions) for a given path on the MicroPython backend, by extracting it from the full stat information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_path_info", "line_number": 1158, "body": "def _get_path_info(self, path: str) -> Optional[Dict]:\n        stat = self._get_stat(path)\n\n        if stat is None:\n            return None\n\n        _, basename = unix_dirname_basename(path)\n        return self._expand_stat(stat, basename)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Retrieves detailed information about a specified file or directory path within the MicroPython environment. It provides essential metadata for path-related operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_dir_children_info", "line_number": 1167, "body": "def _get_dir_children_info(\n        self, path: str, include_hidden: bool = False\n    ) -> Optional[Dict[str, Dict]]:\n        \"\"\"The key of the result dict is simple name\"\"\"\n        if self._supports_directories():\n            raw_data = self._evaluate(\n                dedent(\n                    \"\"\"\n                __thonny_result = {} \n                try:\n                    __thonny_names = __thonny_helper.listdir(%r)\n                except OSError:\n                    __thonny_helper.print_mgmt_value(None) \n                else:\n                    for __thonny_name in __thonny_names:\n                        if not __thonny_name.startswith(\".\") or %r:\n                            try:\n                                __thonny_result[__thonny_name] = __thonny_helper.os.stat(%r + __thonny_name)\n                            except OSError as e:\n                                __thonny_result[__thonny_name] = str(e)\n                    __thonny_helper.print_mgmt_value(__thonny_result)\n            \"\"\"\n                )\n                % (path, include_hidden, path.rstrip(\"/\") + \"/\")\n            )\n            if raw_data is None:\n                return None\n        elif path == \"\":\n            # used to represent all files in micro:bit\n            raw_data = self._evaluate(\n                \"{name : __thonny_helper.os.size(name) for name in __thonny_helper.os.listdir()}\"\n            )\n        else:\n            return None\n\n        return {name: self._expand_stat(raw_data[name], name) for name in raw_data}", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides a listing of files and subdirectories within a given path on the connected MicroPython device. It retrieves file system details for each entry, optionally including hidden items."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_on_connection_closed", "line_number": 1204, "body": "def _on_connection_closed(self, error=None):\n        self._forward_unexpected_output(\"stderr\")\n        message = \"Connection lost\"\n        if error:\n            message += \" (\" + str(error) + \")\"\n        self._send_output(\"\\n\" + message + \"\\n\", \"stderr\")\n        self._send_output(\"\\n\" + \"Use Stop/Restart to reconnect.\" + \"\\n\", \"stderr\")\n        sys.exit(EXPECTED_TERMINATION_CODE)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Manages the MicroPythonBackend's response to a lost connection. It notifies the user of the disconnection, provides reconnection instructions, and terminates the process."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_show_error", "line_number": 1213, "body": "def _show_error(self, msg):\n        self._send_output(msg + \"\\n\", \"stderr\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Displays an error message to the user by sending it to the standard error stream. It ensures consistent error reporting from the MicroPython backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_add_expression_statement_handlers", "line_number": 1216, "body": "def _add_expression_statement_handlers(self, source):\n        try:\n            root = ast.parse(source)\n\n            from thonny.ast_utils import mark_text_ranges\n\n            mark_text_ranges(root, source)\n\n            expr_stmts = []\n            for node in ast.walk(root):\n                if isinstance(node, ast.Expr):\n                    expr_stmts.append(node)\n\n            marker_prefix = \"__thonny_helper.print_repl_value(\"\n            marker_suffix = \")\"\n\n            lines = source.splitlines(keepends=True)\n            for node in reversed(expr_stmts):\n                lines[node.end_lineno - 1] = (\n                    lines[node.end_lineno - 1][: node.end_col_offset]\n                    + marker_suffix\n                    + lines[node.end_lineno - 1][node.end_col_offset :]\n                )\n\n                lines[node.lineno - 1] = (\n                    lines[node.lineno - 1][: node.col_offset]\n                    + marker_prefix\n                    + lines[node.lineno - 1][node.col_offset :]\n                )\n\n            new_source = \"\".join(lines)\n            # make sure it parses\n            ast.parse(new_source)\n            return new_source\n        except SyntaxError:\n            return source\n        except Exception as e:\n            logger.warning(\"Problem adding Expr handlers\", exc_info=e)\n            return source", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Transforms Python source code by wrapping expression statements with a print helper, enabling their values to be automatically displayed in an interactive REPL environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_avoid_printing_expression_statements", "line_number": 1256, "body": "def _avoid_printing_expression_statements(self, source):\n        # temporary solution for https://github.com/thonny/thonny/issues/1441\n        try:\n            root = ast.parse(source)\n\n            from thonny.ast_utils import mark_text_ranges\n\n            mark_text_ranges(root, source)\n\n            expr_stmts = []\n            for node in ast.walk(root):\n                if isinstance(node, ast.Expr):\n                    expr_stmts.append(node)\n\n            marker_prefix = \"\"\n            marker_suffix = \" and None or None\"\n\n            lines = source.splitlines(keepends=True)\n            for node in reversed(expr_stmts):\n                lines[node.end_lineno - 1] = (\n                    lines[node.end_lineno - 1][: node.end_col_offset]\n                    + marker_suffix\n                    + lines[node.end_lineno - 1][node.end_col_offset :]\n                )\n\n                lines[node.lineno - 1] = (\n                    lines[node.lineno - 1][: node.col_offset]\n                    + marker_prefix\n                    + lines[node.lineno - 1][node.col_offset :]\n                )\n\n            new_source = \"\".join(lines)\n            # make sure it parses\n            ast.parse(new_source)\n            return new_source\n        except SyntaxError:\n            return source\n        except Exception as e:\n            logger.warning(\"Problem adding Expr handlers\", exc_info=e)\n            return source", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Modifies Python source code to prevent implicit printing of expression statement results. This ensures cleaner output when executing code in an interactive MicroPython environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_system_time_to_posix_time", "line_number": 1302, "body": "def _system_time_to_posix_time(self, value: float) -> float:\n        result = value + self._get_epoch_offset()\n        if not self._args[\"utc_clock\"]:\n            # convert to UTC\n            result += time.timezone\n\n        return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "This method converts a MicroPython system time into a standard POSIX timestamp. It accounts for epoch offsets and ensures UTC conversion for universal compatibility."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_get_epoch_offset", "line_number": 1310, "body": "def _get_epoch_offset(self) -> int:\n        if self._epoch_year == 1970:\n            return 0\n        elif self._epoch_year == 2000:\n            return Y2000_EPOCH_OFFSET\n        else:\n            raise NotImplementedError()", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides the necessary time offset for converting between the Unix epoch and the backend's configured epoch year (1970 or 2000)."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_expand_stat", "line_number": 1318, "body": "def _expand_stat(self, stat: Union[Tuple, int, str], basename: str) -> Dict:\n        error = None\n        if isinstance(stat, int):\n            # file size is only info available for micro:bit files\n            size = stat\n            modified = None\n            kind = \"file\"\n        elif isinstance(stat, str):\n            kind = None\n            size = None\n            modified = None\n            error = stat\n        else:\n            assert isinstance(stat, tuple)\n            if stat[STAT_KIND_INDEX] & 0o170000 == 0o040000:\n                kind = \"dir\"\n                size = None\n            else:\n                kind = \"file\"\n                size = stat[STAT_SIZE_INDEX]\n\n            modified = self._system_time_to_posix_time(stat[STAT_MTIME_INDEX])\n\n        result = {\n            \"kind\": kind,\n            \"size\": size,\n            \"modified\": modified,\n            \"hidden\": basename.startswith(\".\"),\n        }\n        if error:\n            result[\"error\"] = error\n        return result", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Parses raw MicroPython file/directory stat information, normalizing various formats into a structured dictionary. It provides file type, size, modification time, and hidden status for backend consumption."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "_decode", "line_number": 1351, "body": "def _decode(self, data: bytes) -> str:\n        return data.decode(encoding=\"UTF-8\", errors=\"replace\")", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Converts byte data into a readable UTF-8 string, replacing decoding errors. This serves to interpret byte streams, typically from a MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "create_error_response", "line_number": 325, "body": "def create_error_response(**kw):\n            if \"error\" not in kw:\n                kw[\"error\"] = traceback.format_exc()\n\n            if isinstance(cmd, ToplevelCommand):\n                return ToplevelResponse(command_name=cmd.name, **kw)\n            else:\n                return InlineResponse(command_name=cmd.name, **kw)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Provides a standardized error response for MicroPython commands, capturing the traceback when an error occurs. It returns either a Toplevel or Inline response based on the command context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/backend.py", "function": "consume_output", "line_number": 501, "body": "def consume_output(data, stream_name):\n                assert isinstance(data, str)\n                output_lists[stream_name].append(data)", "is_method": true, "class_name": "MicroPythonBackend", "function_description": "Appends incoming string data to a specific output list, categorized by stream name. It organizes and buffers output from various sources within the MicroPython backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "starts_with_continuation_byte", "line_number": 1552, "body": "def starts_with_continuation_byte(data):\n    return data and is_continuation_byte(data[0])", "is_method": false, "function_description": "Checks if a data sequence starts with a continuation byte. This service is useful for validating or parsing multi-byte encodings where such bytes indicate subsequent parts of a character."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "is_continuation_byte", "line_number": 1556, "body": "def is_continuation_byte(byte):\n    return (byte & 0b11000000) == 0b10000000", "is_method": false, "function_description": "Determines if a byte is a UTF-8 continuation byte. This function is essential for correctly parsing and validating UTF-8 encoded data streams."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_check_prepare", "line_number": 157, "body": "def _check_prepare(self):\n        out, err = self._execute(\"print('__thonny_helper' in dir())\", capture_output=True)\n        if out.strip() == \"True\":\n            return\n\n        self._prepare_after_soft_reboot(False)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Verifies the presence of a specific Thonny helper module on the MicroPython device. If absent, it initiates the necessary preparation of the device environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_custom_helpers", "line_number": 164, "body": "def _get_custom_helpers(self):\n        if self._connected_to_microbit():\n            return \"\"\n\n        return dedent(\n            \"\"\"\n            @classmethod\n            def getcwd(cls):\n                if hasattr(cls, \"getcwd\"):\n                    return cls.os.getcwd()\n                else:\n                    # micro:bit\n                    return \"\"\n            \n            @classmethod\n            def chdir(cls, x):\n                return cls.os.chdir(x)\n            \n            @classmethod\n            def rmdir(cls, x):\n                return cls.os.rmdir(x)\n        \"\"\"\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Generates a string containing Python code for file system utilities (getcwd, chdir, rmdir) to augment the backend's capabilities when not connected to a micro:bit."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_process_until_initial_prompt", "line_number": 188, "body": "def _process_until_initial_prompt(self, clean):\n        logger.debug(\"_process_until_initial_prompt, clean=%s\", clean)\n        if clean:\n            self._interrupt_to_raw_prompt()\n            self._soft_reboot_in_raw_prompt_without_running_main()\n        else:\n            # Discard what's printed by now and order a prompt, so that we get to know\n            # if the REPL is already idle\n            discarded = self._connection.read_all()\n            self._write(RAW_MODE_CMD)\n            self._forward_output_until_active_prompt(self._send_output)\n\n        if self._submit_mode is None:\n            self._choose_submit_mode()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Prepares the MicroPython device to accept commands. It either performs a clean reboot or synchronizes with the device's current state to reach an active prompt."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_choose_submit_mode", "line_number": 203, "body": "def _choose_submit_mode(self):\n        if self._connected_over_webrepl():\n            logger.info(\"Choosing paste submit mode because of WebREPL\")\n            self._submit_mode = PASTE_SUBMIT_MODE\n            return\n\n        # at least sometimes, we end up at normal prompt, although we asked for raw prompt\n        self._ensure_raw_mode()\n        self._write(RAW_PASTE_COMMAND)\n        response = self._connection.soft_read(2)\n        assert len(response) == 2, \"Could not read response for raw paste command: \" + response\n        if response == RAW_PASTE_CONFIRMATION:\n            logger.info(\"Choosing raw paste submit mode\")\n            self._submit_mode = RAW_PASTE_SUBMIT_MODE\n            self._write(EOT)\n            discarding = self._connection.read_until(RAW_PROMPT)\n        else:\n            discarding = self._connection.read_until(RAW_PROMPT)\n            logger.info(\"Choosing raw submit mode (%r)\", response + discarding)\n            self._submit_mode = RAW_SUBMIT_MODE\n\n        discarding += self._connection.read_all()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method selects the most suitable command submission mode for the MicroPython device. It ensures reliable command execution by adapting to the connection type and device capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_fetch_welcome_text", "line_number": 226, "body": "def _fetch_welcome_text(self) -> str:\n        self._write(NORMAL_MODE_CMD)\n        out, err = self._capture_output_until_active_prompt()\n        welcome_text = out.strip(\"\\r\\n >\")\n        if os.name != \"nt\":\n            welcome_text = welcome_text.replace(\"\\r\\n\", \"\\n\")\n\n        return welcome_text", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Retrieves and cleans the initial welcome or banner text from a connected MicroPython device. It prepares the text for display or further processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_fetch_builtin_modules", "line_number": 235, "body": "def _fetch_builtin_modules(self):\n        script = \"help('modules')\"\n        out, err = self._execute(script, capture_output=True)\n        if err or not out:\n            self._send_error_message(\n                \"Could not query builtin modules. Code completion may not work properly.\"\n            )\n            return FALLBACK_BUILTIN_MODULES\n\n        modules_str_lines = out.strip().splitlines()\n\n        last_line = modules_str_lines[-1].strip()\n        if last_line.count(\" \") > 0 and \"  \" not in last_line and \"\\t\" not in last_line:\n            # probably something like \"plus any modules on the filesystem\"\n            # (can be in different languages)\n            modules_str_lines = modules_str_lines[:-1]\n\n        modules_str = (\n            \" \".join(modules_str_lines)\n            .replace(\"/__init__\", \"\")\n            .replace(\"__main__\", \"\")\n            .replace(\"/\", \".\")\n        )\n\n        return modules_str.split()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method queries the connected MicroPython device to retrieve a list of its builtin modules. It serves to enable features like code completion within a development environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_resolve_unknown_epoch", "line_number": 261, "body": "def _resolve_unknown_epoch(self) -> int:\n        if self._connected_to_circuitpython() or self._connected_to_pycom():\n            return 1970\n        else:\n            return 2000", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Determines the default epoch year for time calculations based on the connected MicroPython platform (CircuitPython/Pycom or other). It provides a base year when the actual epoch is unknown."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_sync_time", "line_number": 267, "body": "def _sync_time(self):\n        \"\"\"Sets the time to match the time on the host.\"\"\"\n\n        now = self._get_time_for_rtc()\n\n        if self._connected_to_microbit():\n            return\n        elif self._connected_to_circuitpython():\n            specific_script = dedent(\n                \"\"\"\n                from rtc import RTC as __thonny_RTC\n                __thonny_RTC().datetime = {ts}\n                del __thonny_RTC\n            \"\"\"\n            ).format(ts=tuple(now))\n        else:\n            specific_script = dedent(\n                \"\"\"\n                from machine import RTC as __thonny_RTC\n                try:\n                    __thonny_RTC().datetime({datetime_ts})\n                except:\n                    __thonny_RTC().init({init_ts})\n                del __thonny_RTC\n\n            \"\"\"\n            ).format(\n                datetime_ts=(\n                    now.tm_year,\n                    now.tm_mon,\n                    now.tm_mday,\n                    now.tm_wday + 1,\n                    now.tm_hour,\n                    now.tm_min,\n                    now.tm_sec,\n                    0,\n                ),\n                init_ts=tuple(now)[:6] + (0, 0),\n            )\n\n        script = (\n            dedent(\n                \"\"\"\n            try:\n            %s\n                __thonny_helper.print_mgmt_value(True)\n            except Exception as e:\n                __thonny_helper.print_mgmt_value(str(e))\n        \"\"\"\n            )\n            % indent(specific_script, \"    \")\n        )\n\n        val = self._evaluate(script)\n        if isinstance(val, str):\n            print(\"WARNING: Could not sync device's clock: \" + val)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "A method of `BareMetalMicroPythonBackend` that synchronizes the Real-Time Clock (RTC) of a connected MicroPython or CircuitPython device with the host computer's current time."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_utc_timetuple_from_device", "line_number": 324, "body": "def _get_utc_timetuple_from_device(self) -> Union[tuple, str]:\n        if self._connected_to_microbit():\n            return \"This device does not have a real-time clock\"\n        elif self._connected_to_circuitpython():\n            specific_script = dedent(\n                \"\"\"\n                from rtc import RTC as __thonny_RTC\n                __thonny_helper.print_mgmt_value(tuple(__thonny_RTC().datetime)[:6])\n                del __thonny_RTC\n                \"\"\"\n            )\n        else:\n            specific_script = dedent(\n                \"\"\"\n                from machine import RTC as __thonny_RTC\n                try:\n                    # now() on some devices also gives weekday, so prefer datetime\n                    __thonny_temp = tuple(__thonny_RTC().datetime())\n                    # remove weekday from index 3\n                    __thonny_helper.print_mgmt_value(__thonny_temp[0:3] + __thonny_temp[4:7])\n                    del __thonny_temp\n                except:\n                    __thonny_helper.print_mgmt_value(tuple(__thonny_RTC().now())[:6])\n                del __thonny_RTC\n                \"\"\"\n            )\n\n        script = (\n            dedent(\n                \"\"\"\n            try:\n            %s\n            except Exception as e:\n                __thonny_helper.print_mgmt_value(str(e))\n        \"\"\"\n            )\n            % indent(specific_script, \"    \")\n        )\n\n        val = self._evaluate(script)\n        return val", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Retrieves the current UTC date and time from the connected MicroPython or CircuitPython device. It queries the device's real-time clock, providing a time tuple for synchronization."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_actual_time_tuple_on_device", "line_number": 366, "body": "def _get_actual_time_tuple_on_device(self):\n        script = dedent(\n            \"\"\"\n            try:\n                try:\n                    from time import localtime as __thonny_localtime\n                    __thonny_helper.print_mgmt_value(tuple(__thonny_localtime()))\n                    del __thonny_localtime\n                except:\n                    # some CP boards\n                    from rtc import RTC as __thonny_RTC\n                    __thonny_helper.print_mgmt_value(tuple(__thonny_RTC().datetime))\n                    del __thonny_RTC\n            except Exception as e:\n                __thonny_helper.print_mgmt_value(str(e))\n        \"\"\"\n        )\n\n        return self._evaluate(script)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Retrieves the current time as a tuple directly from a connected MicroPython or CircuitPython device. It adapts its approach based on the device's available time access APIs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_update_cwd", "line_number": 386, "body": "def _update_cwd(self):\n        if self._connected_to_microbit():\n            self._cwd = \"\"\n        else:\n            super()._update_cwd()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Updates the backend's current working directory, setting it to an empty path when connected to a MicroPython device, or otherwise delegating to its parent class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_handle_eof_command", "line_number": 392, "body": "def _handle_eof_command(self, msg: EOFCommand) -> None:\n        self._soft_reboot_for_restarting_user_program()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Responds to an end-of-file command by performing a soft reboot. This action restarts the user's MicroPython program, preparing the system for new execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_interrupt_to_raw_prompt", "line_number": 395, "body": "def _interrupt_to_raw_prompt(self):\n        # NB! Sometimes disconnecting and reconnecting (on macOS?)\n        # too quickly causes anomalies. See CalliopeMiniProxy for more details\n        logger.debug(\"_interrupt_to_raw_prompt\")\n        discarded_bytes = b\"\"\n\n        for delay in [0.05, 0.5, 0.1, 1.0, 3.0, 5.0]:\n            # Interrupt several times, because with some drivers first interrupts seem to vanish\n            if delay >= 1:\n                self._show_error(\n                    \"Could not enter REPL. Trying again with %d second waiting time...\" % delay\n                )\n            self._connection.reset_output_buffer()  # cancels previous writes\n            self._write(INTERRUPT_CMD)\n            self._write(RAW_MODE_CMD)\n            time.sleep(delay)\n            self._capture_output_until_active_prompt()\n            if self._last_prompt in [FIRST_RAW_PROMPT, W600_FIRST_RAW_PROMPT]:\n                break\n        else:\n            max_tail_length = 500\n            if len(discarded_bytes) > max_tail_length:\n                discarded_bytes_str = (\n                    \"[skipping %d bytes] ...\" % (len(discarded_bytes) - max_tail_length)\n                ) + repr(discarded_bytes[:-max_tail_length])\n            else:\n                discarded_bytes_str = repr(discarded_bytes)\n            self._show_error(\n                \"Could not enter REPL. Giving up. Read bytes:\\n\"\n                + discarded_bytes_str\n                + \"\\n\\nYour options:\\n\\n\"\n                + \"  - check connection properties;\\n\"\n                + \"  - make sure the device has suitable firmware;\\n\"\n                + \"  - make sure the device is not in bootloader mode;\\n\"\n                + \"  - reset the device and try again;\\n\"\n                + \"  - try other serial clients (Putty, TeraTerm, screen, ...);\\n\"\n                + \"  - ask for help in Thonny's forum or issue tracker.\"\n            )\n            sys.exit()\n\n        logger.debug(\"Done _interrupt_to_raw_prompt\")", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method attempts to reliably enter the MicroPython raw REPL prompt on a bare metal device. It retries multiple times to establish the necessary communication state for programmatic interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_soft_reboot_in_raw_prompt_without_running_main", "line_number": 437, "body": "def _soft_reboot_in_raw_prompt_without_running_main(self):\n        logger.debug(\"_soft_reboot_in_raw_prompt_without_running_main\")\n        self._write(SOFT_REBOOT_CMD + INTERRUPT_CMD)\n        self._check_reconnect()\n        self._capture_output_until_active_prompt()\n\n        logger.debug(\"Done soft reboot in raw prompt\")", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Reboots the connected MicroPython device into a raw prompt state, preventing the `main.py` script from running. This enables direct command execution or debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_ensure_raw_mode", "line_number": 445, "body": "def _ensure_raw_mode(self):\n        if self._last_prompt in [\n            RAW_PROMPT,\n            EOT + RAW_PROMPT,\n            FIRST_RAW_PROMPT,\n            W600_FIRST_RAW_PROMPT,\n        ]:\n            return\n        logger.debug(\"requesting raw mode at %r\", self._last_prompt)\n\n        # assuming we are currently on a normal prompt\n        self._write(RAW_MODE_CMD)\n        out, err = self._capture_output_until_active_prompt()\n        if self._last_prompt == NORMAL_PROMPT:\n            # Don't know why this happens sometimes (eg. when interrupting a Ctrl+D or restarted\n            # program, which is outputting text on ESP32)\n            logger.info(\"Found normal prompt instead of expected raw prompt. Trying again.\")\n            self._write(RAW_MODE_CMD)\n            time.sleep(0.5)\n            out, err = self._capture_output_until_active_prompt()\n\n        if self._last_prompt not in [FIRST_RAW_PROMPT, W600_FIRST_RAW_PROMPT]:\n            raise AssertionError(\n                \"Could not enter raw prompt, got %r\"\n                % ((out + err).encode(ENCODING) + self._last_prompt)\n            )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Ensures the connected MicroPython device operates in raw mode, facilitating reliable programmatic command execution. It manages various prompt states to guarantee the correct operational environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_ensure_normal_mode", "line_number": 472, "body": "def _ensure_normal_mode(self):\n        if self._last_prompt == NORMAL_PROMPT:\n            return\n\n        logger.debug(\"requesting normal mode at %r\", self._last_prompt)\n        self._write(NORMAL_MODE_CMD)\n        self._capture_output_until_active_prompt()\n        assert self._last_prompt == NORMAL_PROMPT, (\n            \"Could not get normal prompt, got %s\" % self._last_prompt\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Ensures the connected MicroPython device is in its normal operating mode, issuing the necessary command and confirming the state. This is vital for stable and predictable device interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_soft_reboot_without_running_main", "line_number": 483, "body": "def _soft_reboot_without_running_main(self):\n        logger.debug(\"_soft_reboot_without_running_main\")\n        self._interrupt_to_raw_prompt()\n        self._soft_reboot_in_raw_prompt_without_running_main()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Initiates a soft reboot of the connected MicroPython device. This resets the interpreter without executing the main user script, enabling direct control or debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_soft_reboot_for_restarting_user_program", "line_number": 488, "body": "def _soft_reboot_for_restarting_user_program(self):\n        # Need to go to normal mode. MP doesn't run user code in raw mode\n        # (CP does, but it doesn't hurt to do it there as well)\n        self._ensure_normal_mode()\n        self._write(SOFT_REBOOT_CMD)\n        self._check_reconnect()\n        self._forward_output_until_active_prompt(self._send_output)\n        logger.debug(\"Restoring helpers\")\n        self._prepare_after_soft_reboot(False)\n        self.send_message(ToplevelResponse(cwd=self._cwd))", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Triggers a soft reboot on the connected MicroPython device to restart the user's program. It prepares the environment for subsequent execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_check_reconnect", "line_number": 499, "body": "def _check_reconnect(self):\n        if self._connected_over_webrepl():\n            time.sleep(1)\n            self._connection = self._connection.close_and_return_new_connection()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method reconnects to the MicroPython device if the current connection is via WebREPL, ensuring a fresh and stable link."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_connected_over_webrepl", "line_number": 504, "body": "def _connected_over_webrepl(self):\n        from thonny.plugins.micropython.webrepl_connection import WebReplConnection\n\n        return isinstance(self._connection, WebReplConnection)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Determines if the BareMetalMicroPythonBackend is currently connected using a WebREPL interface. This allows for specific WebREPL-dependent operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_transform_output", "line_number": 509, "body": "def _transform_output(self, data, stream_name):\n        # Any keypress wouldn't work\n        return data.replace(\n            \"Press any key to enter the REPL. Use CTRL-D to reload.\",\n            \"Press Ctrl-C to enter the REPL. Use CTRL-D to reload.\",\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Corrects REPL entry instructions within output data for the BareMetalMicroPythonBackend, ensuring users receive accurate guidance on how to access the REPL."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_write", "line_number": 516, "body": "def _write(self, data):\n        self._connection.write(data)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provides the fundamental mechanism for sending raw data bytes to the connected MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_submit_input", "line_number": 519, "body": "def _submit_input(self, cdata: str) -> None:\n        # TODO: what if there is a previous unused data waiting\n        assert self._connection.outgoing_is_empty()\n\n        assert cdata.endswith(\"\\n\")\n        if not cdata.endswith(\"\\r\\n\"):\n            # submission is done with CRLF\n            cdata = cdata[:-1] + \"\\r\\n\"\n\n        bdata = cdata.encode(ENCODING)\n        to_be_written = bdata\n        echo = b\"\"\n        with self._interrupt_lock:\n            while to_be_written:\n                block = self._extract_block_without_splitting_chars(to_be_written)\n                self._write(to_be_written)\n                # Try to consume the echo\n                echo += self._connection.soft_read(len(block), timeout=1)\n                to_be_written = to_be_written[len(block) :]\n\n        if echo != bdata:\n            # because of autoreload? timing problems? interruption?\n            # Leave it.\n            logging.warning(\"Unexpected echo. Expected %r, got %r\" % (bdata, echo))\n            self._connection.unread(echo)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method sends a string command or input to the connected MicroPython device, ensuring proper line endings and verifying the echoed data for reliable communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_submit_code", "line_number": 545, "body": "def _submit_code(self, script):\n        \"\"\"\n        Code is submitted via paste mode, because this provides echo, which can be used as flow control.\n\n        The echo of a written block must be read before next block is written.\n        Safe USB block size is 64 bytes (may be larger for some devices),\n        but we need to account for b\"=== \" added by the paste mode in the echo, so each block is sized such that\n        its echo doesn't exceed self._write_block_size (some devices may have problem with outputs bigger than that).\n        (OK, most likely the reading thread will eliminate the problem with output buffer, but just in case...)\n        \"\"\"\n        assert script\n\n        # assuming we are already at a prompt, but threads may have produced something\n        self._forward_unexpected_output()\n\n        to_be_sent = script.encode(\"UTF-8\")\n        logger.debug(\"Submitting via %s: %r\", self._submit_mode, to_be_sent[:50])\n        with self._interrupt_lock:\n            if self._submit_mode == PASTE_SUBMIT_MODE:\n                self._submit_code_via_paste_mode(to_be_sent)\n            elif self._submit_mode == RAW_PASTE_SUBMIT_MODE:\n                try:\n                    self._submit_code_via_raw_paste_mode(to_be_sent)\n                except RawPasteNotSupportedError:\n                    logger.info(\"WARNING: Could not use expected raw paste, falling back to raw\")\n                    self._submit_code_via_raw_mode(to_be_sent)\n            else:\n                self._submit_code_via_raw_mode(to_be_sent)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method transmits Python code to a bare-metal MicroPython device. It intelligently selects and uses the appropriate communication protocol (paste, raw paste, or raw mode) to ensure reliable script execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_submit_code_via_paste_mode", "line_number": 574, "body": "def _submit_code_via_paste_mode(self, script_bytes: bytes) -> None:\n        # Go to paste mode\n        self._ensure_normal_mode()\n        self._connection.write(PASTE_MODE_CMD)\n        self._connection.read_until(PASTE_MODE_LINE_PREFIX)\n\n        # Send script\n        while script_bytes:\n            block = script_bytes[: self._write_block_size]\n            script_bytes = script_bytes[self._write_block_size :]\n\n            # find proper block boundary\n            while True:\n                expected_echo = block.replace(b\"\\r\\n\", b\"\\r\\n\" + PASTE_MODE_LINE_PREFIX)\n                if (\n                    len(expected_echo) > self._write_block_size\n                    or block.endswith(b\"\\r\")\n                    or len(block) > 2\n                    and starts_with_continuation_byte(script_bytes)\n                ):\n                    # move last byte to the next block\n                    script_bytes = block[-1:] + script_bytes\n                    block = block[:-1]\n                    continue\n                else:\n                    break\n\n            self._write(block)\n            self._connection.read_all_expected(expected_echo, timeout=WAIT_OR_CRASH_TIMEOUT)\n\n        # push and read comfirmation\n        self._connection.write(EOT)\n        expected_confirmation = b\"\\r\\n\"\n        actual_confirmation = self._connection.read(\n            len(expected_confirmation), timeout=WAIT_OR_CRASH_TIMEOUT\n        )\n        assert actual_confirmation == expected_confirmation, \"Expected %r, got %r\" % (\n            expected_confirmation,\n            actual_confirmation,\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Submits a Python script to a MicroPython device using its paste mode protocol. This enables reliable remote code transfer for execution on the bare-metal board."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_submit_code_via_raw_mode", "line_number": 615, "body": "def _submit_code_via_raw_mode(self, script_bytes: bytes) -> None:\n        self._ensure_raw_mode()\n\n        to_be_written = script_bytes + EOT\n\n        while to_be_written:\n            block = self._extract_block_without_splitting_chars(to_be_written)\n            self._write(block)\n            to_be_written = to_be_written[len(block) :]\n            if to_be_written:\n                time.sleep(self._write_block_delay)\n\n        # fetch command confirmation\n        confirmation = self._connection.soft_read(2, timeout=WAIT_OR_CRASH_TIMEOUT)\n\n        if confirmation != OK:\n            data = confirmation + self._connection.read_all()\n            data += self._connection.read(1, timeout=1, timeout_is_soft=True)\n            data += self._connection.read_all()\n            raise AssertionError(\n                \"Could not read command confirmation. Got \"\n                + repr(data)\n                + \"\\n\\nSCRIPT:\\n\"\n                + repr(script_bytes)\n            )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provides reliable transmission of a Python script to the MicroPython device in raw mode. It sends data in blocks and verifies successful submission."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_submit_code_via_raw_paste_mode", "line_number": 641, "body": "def _submit_code_via_raw_paste_mode(self, script_bytes: bytes) -> None:\n        self._ensure_raw_mode()\n        self._connection.set_unicode_guard(False)\n        self._write(RAW_PASTE_COMMAND)\n        response = self._connection.soft_read(2, timeout=WAIT_OR_CRASH_TIMEOUT)\n        if response != RAW_PASTE_CONFIRMATION:\n            # Occasionally, the device initially supports raw paste but later doesn't allow it\n            # https://github.com/thonny/thonny/issues/1545\n            time.sleep(0.01)\n            response += self._connection.read_all()\n            if response == FIRST_RAW_PROMPT:\n                self._last_prompt = FIRST_RAW_PROMPT\n                raise RawPasteNotSupportedError()\n            else:\n                raise AssertionError(\"Got %r instead of raw-paste confirmation\" % response)\n\n        self._raw_paste_write(script_bytes)\n        self._connection.set_unicode_guard(True)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Submits Python code as bytes to a MicroPython device using its raw paste mode. This ensures reliable, low-level transmission of scripts over the established connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_raw_paste_write", "line_number": 660, "body": "def _raw_paste_write(self, command_bytes):\n        # Adapted from https://github.com/micropython/micropython/commit/a59282b9bfb6928cd68b696258c0dd2280244eb3#diff-cf10d3c1fe676599a983c0ec85b78c56c9a6f21b2d896c69b3e13f34d454153e\n\n        # Read initial header, with window size.\n        data = self._connection.soft_read(2, timeout=2)\n        assert len(data) == 2, \"Could not read initial header, got %r\" % (\n            data + self._connection.read_all()\n        )\n        window_size = data[0] | data[1] << 8\n        window_remain = window_size\n\n        # Write out the command_bytes data.\n        i = 0\n        while i < len(command_bytes):\n            while window_remain == 0 or not self._connection.incoming_is_empty():\n                data = self._connection.soft_read(1, timeout=WAIT_OR_CRASH_TIMEOUT)\n                if data == b\"\\x01\":\n                    # Device indicated that a new window of data can be sent.\n                    window_remain += window_size\n                elif data == b\"\\x04\":\n                    # Device indicated abrupt end, most likely a syntax error.\n                    # Acknowledge it and finish.\n                    self._connection.write(b\"\\x04\")\n                    logger.debug(\n                        \"Abrupt end of raw paste submit after submitting %s bytes out of %s\",\n                        i,\n                        len(command_bytes),\n                    )\n                    return\n                else:\n                    # Unexpected data from device.\n                    raise AssertionError(\"Unexpected read during raw paste: {}\".format(data))\n            # Send out as much data as possible that fits within the allowed window.\n            b = command_bytes[i : min(i + window_remain, len(command_bytes))]\n            self._write(b)\n            window_remain -= len(b)\n            i += len(b)\n\n        # Indicate end of data.\n        self._write(b\"\\x04\")\n\n        # Wait for device to acknowledge end of data.\n        data = self._connection.soft_read_until(b\"\\x04\", timeout=WAIT_OR_CRASH_TIMEOUT)\n        if not data.endswith(b\"\\x04\"):\n            raise AssertionError(\"could not complete raw paste: {}\".format(data))", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This internal method reliably transmits raw command bytes to a MicroPython device. It handles the specific flow-controlled raw paste protocol, managing data chunks and device acknowledgments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_execute_with_consumer", "line_number": 706, "body": "def _execute_with_consumer(self, script, output_consumer: Callable[[str, str], None]):\n        self._report_time(\"befsubcode\")\n        self._submit_code(script)\n        self._report_time(\"affsubcode\")\n        self._forward_output_until_active_prompt(output_consumer)\n        self._report_time(\"affforw\")", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method executes a MicroPython script on the bare-metal backend. It submits the code and directs all output from the execution to the provided consumer function."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_forward_output_until_active_prompt", "line_number": 713, "body": "def _forward_output_until_active_prompt(\n        self, output_consumer: Callable[[str, str], None], stream_name=\"stdout\"\n    ):\n        \"\"\"Meant for incrementally forwarding stdout from user statements,\n        scripts and soft-reboots. Also used for forwarding side-effect output from\n        expression evaluations and for capturing help(\"modules\") output.\n        In these cases it is expected to arrive to an EOT.\n\n        Also used for initial prompt searching or for recovering from a protocol error.\n        In this case it must work until active normal prompt or first raw prompt.\n\n        The code may have been submitted in any of the REPL modes or\n        automatically via (soft-)reset.\n\n        NB! The processing may end in normal mode even if the command was started\n        in raw mode (eg. when user presses reset during processing in some devices)!\n\n        The processing may also end in FIRST_RAW_REPL, when it was started in\n        normal REPL and Ctrl+A was issued during processing (ie. before Ctrl+C in\n        this example):\n\n            6\n            7\n            8\n            9\n            10\n            Traceback (most recent call last):\n              File \"main.py\", line 5, in <module>\n            KeyboardInterrupt:\n            MicroPython v1.11-624-g210d05328 on 2019-12-09; ESP32 module with ESP32\n            Type \"help()\" for more information.\n            >>>\n            raw REPL; CTRL-B to exit\n            >\n\n        (Preceding output does not contain EOT)\n        Note that this Ctrl+A may have been issued even before Thonny connected to\n        the device.\n\n        Note that interrupt does not affect the structure of the output -- it is\n        presented just like any other exception.\n\n        The method returns EOT, RAW_PROMPT or NORMAL_PROMPT, depending on which terminator\n        ended the processing.\n\n        The terminating EOT may be either the first EOT from normal raw-REPL\n        output or the starting EOT from Thonny expression (or, in principle, even\n        the second raw-REPL EOT or terminating Thonny expression EOT)\n        -- the caller will do the interpretation.\n\n        Because ot the special role of EOT and NORMAL_PROMT, we assume user code\n        will not output these. If it does, processing may break.\n        It may succeed if the prompt is followed by something (quickly enough)\n        -- that's why we look for *active* prompt, ie. prompt without following text.\n        TODO: Experiment with this!\n\n        Output produced by background threads (eg. in WiPy ESP32) cause even more difficulties,\n        because it becomes impossible to say whether we are at prompt and output\n        is from another thread or the main thread is still running.\n        For now I'm ignoring these problems and assume all output comes from the main thread.\n        \"\"\"\n\n        # Don't want to block on lone EOT (the first EOT), because finding the second EOT\n        # together with raw prompt marker is the most important.\n        INCREMENTAL_OUTPUT_BLOCK_CLOSERS = re.compile(\n            b\"|\".join(\n                map(\n                    re.escape,\n                    [NORMAL_PROMPT, LF, EOT + RAW_PROMPT, FIRST_RAW_PROMPT, W600_FIRST_RAW_PROMPT],\n                )\n            )\n        )\n\n        prompts = [EOT + RAW_PROMPT, NORMAL_PROMPT, FIRST_RAW_PROMPT, W600_FIRST_RAW_PROMPT]\n\n        pending = b\"\"\n        while True:\n            # There may be an input submission waiting\n            # and we can't progress without resolving it first\n            self._check_for_side_commands()\n\n            # Prefer whole lines, but allow also incremental output to single line\n            new_data = self._connection.soft_read_until(\n                INCREMENTAL_OUTPUT_BLOCK_CLOSERS, timeout=0.05\n            )\n\n            # Try to separate stderr from stdout in raw mode\n            eot_pos = new_data.find(EOT)\n            if (\n                eot_pos >= 0\n                and new_data[eot_pos : eot_pos + 2] != EOT + RAW_PROMPT\n                and stream_name == \"stdout\"\n            ):\n                # start of stderr in raw mode\n                out, err = new_data.split(EOT, maxsplit=1)\n                pending += out\n                output_consumer(self._decode(pending), stream_name)\n                pending = b\"\"\n                new_data = err\n                stream_name = \"stderr\"\n            elif self._submit_mode == PASTE_SUBMIT_MODE and TRACEBACK_MARKER in new_data:\n                # start of stderr in paste mode\n                stream_name = \"stderr\"\n\n            if not new_data:\n                # In case we are still waiting for the first bits after connecting ...\n                # TODO: this suggestion should be implemented in Shell\n                if (\n                    self._connection.num_bytes_received == 0\n                    and not self._interrupt_suggestion_given\n                    and time.time() - self._connection.startup_time > 2.5\n                ):\n                    self._show_error(\n                        \"\\n\"\n                        + \"Device is busy or does not respond. Your options:\\n\\n\"\n                        + \"  - wait until it completes current work;\\n\"\n                        + \"  - use Ctrl+C to interrupt current work;\\n\"\n                        + \"  - use Stop/Restart to interrupt more and enter REPL.\\n\"\n                    )\n                    self._interrupt_suggestion_given = True\n\n                if not pending:\n                    # nothing to parse\n                    continue\n\n            pending += new_data\n\n            for current_prompt in prompts:\n                if pending.endswith(current_prompt):\n                    break\n            else:\n                current_prompt = None\n\n            if current_prompt:\n                # This looks like prompt.\n                # Make sure it is not followed by anything.\n                follow_up = self._connection.soft_read(1, timeout=0.01)\n                if follow_up:\n                    # Nope, the prompt is not active.\n                    # (Actually it may be that a background thread has produced this follow up,\n                    # but this would be too hard to consider.)\n                    # Don't output yet, because the follow up may turn into another prompt\n                    # and they can be captured all together.\n                    self._connection.unread(follow_up)\n                    # read prompt must remain in pending\n                    continue\n                else:\n                    # let's hope it is an active prompt\n                    # Strip all trailing prompts\n                    while True:\n                        for potential_prompt in prompts:\n                            if pending.endswith(potential_prompt):\n                                pending = pending[: -len(potential_prompt)]\n                        else:\n                            break\n                    output_consumer(self._decode(pending), stream_name)\n                    self._last_prompt = current_prompt\n                    # logger.debug(\"Found prompt %r\", current_prompt)\n                    return current_prompt\n\n            if pending.endswith(LF):\n                # Maybe it's a penultimate char in a first raw repl?\n                if pending.endswith(FIRST_RAW_PROMPT[:-1]) or pending.endswith(\n                    W600_FIRST_RAW_PROMPT[:-1]\n                ):\n                    pending += self._connection.soft_read(1)\n                    self._connection.unread(pending)\n                    pending = b\"\"\n                else:\n                    output_consumer(self._decode(pending), stream_name)\n                    pending = b\"\"\n                continue\n\n            for potential_prompt in prompts:\n                if ends_overlap(pending, potential_prompt):\n                    # Maybe we have a prefix of the prompt and the rest is still coming?\n                    # (it's OK to wait a bit, as the user output usually ends with a newline, ie not\n                    # with a prompt prefix)\n                    follow_up = self._connection.soft_read(1, timeout=0.3)\n                    if not follow_up:\n                        # most likely not a Python prompt, let's forget about it\n                        output_consumer(self._decode(pending), stream_name)\n                        pending = b\"\"\n                        continue\n                    else:\n                        # Let's try the possible prefix again in the next iteration\n                        # (I'm unreading otherwise the read_until won't see the whole prompt\n                        # and needs to wait for the timeout)\n                        n = ends_overlap(pending, potential_prompt)\n\n                        try_again = pending[-n:]\n                        pending = pending[:-n]\n                        self._connection.unread(try_again + follow_up)\n                        continue\n\n            else:\n                # No prompt in sight.\n                # Output and keep working.\n                output_consumer(self._decode(pending), stream_name)\n                pending = b\"\"\n                continue", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Forwards and parses output from a MicroPython device's REPL, detecting active prompts or end-of-transmission. This ensures the backend synchronizes its state with the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_capture_output_until_active_prompt", "line_number": 915, "body": "def _capture_output_until_active_prompt(self):\n        output = {\"stdout\": \"\", \"stderr\": \"\"}\n\n        def collect_output(data, stream):\n            output[stream] += data\n\n        self._forward_output_until_active_prompt(collect_output)\n\n        return output[\"stdout\"], output[\"stderr\"]", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Gathers all stdout and stderr from the MicroPython device until an active prompt is reached. This provides a complete capture of command execution output."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_forward_unexpected_output", "line_number": 925, "body": "def _forward_unexpected_output(self, stream_name=\"stdout\"):\n        \"Invoked between commands\"\n        # TODO: This should be as careful as _forward_output_until_active_prompt\n        data = self._connection.read_all(check_error=False)\n        if data:\n            met_prompt = False\n            while data.endswith(NORMAL_PROMPT) or data.endswith(FIRST_RAW_PROMPT):\n                # looks like the device was resetted\n                if data.endswith(NORMAL_PROMPT):\n                    prompt = NORMAL_PROMPT\n                else:\n                    prompt = FIRST_RAW_PROMPT\n\n                if not met_prompt:\n                    met_prompt = True\n                    self._last_prompt = prompt\n\n                # hide the prompt from the output ...\n                data = data[: -len(prompt)]\n\n            self._send_output(data.decode(ENCODING, \"replace\"), stream_name)\n            if met_prompt:\n                self._check_prepare()\n                # ... and recreate Thonny prompt\n                self.send_message(ToplevelResponse())", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Processes and forwards any unexpected output from the MicroPython device received between commands. It cleans the output by removing prompts and signals the device's readiness for new input."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_Run", "line_number": 951, "body": "def _cmd_Run(self, cmd):\n        \"\"\"Only for %run $EDITOR_CONTENT. start runs will be handled differently.\"\"\"\n        if cmd.get(\"source\"):\n            self._soft_reboot_without_running_main()\n            if self._submit_mode == PASTE_SUBMIT_MODE:\n                source = self._avoid_printing_expression_statements(cmd.source)\n            else:\n                source = cmd.source\n\n            self._execute(source, capture_output=False)\n            self._prepare_after_soft_reboot(False)\n        return {}", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method executes user-provided Python source code on a bare metal MicroPython device. It performs a soft reboot to ensure a clean execution environment before running the submitted code."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_execute_system_command", "line_number": 964, "body": "def _cmd_execute_system_command(self, cmd):\n        # Can't use stdin, because a thread is draining it\n        returncode = execute_system_command(cmd, cwd=self._local_cwd, disconnect_stdin=True)\n        return {\"returncode\": returncode}", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Executes a system command on the bare-metal backend, returning its exit code. This enables interaction with the underlying system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_get_fs_info", "line_number": 969, "body": "def _cmd_get_fs_info(self, cmd):\n        result = self._evaluate(\n            dedent(\n                \"\"\"\n            try:\n                from os import statvfs as __thonny_statvfs\n                __thonny_stat = __thonny_statvfs(%r)\n                __thonny_total = __thonny_stat[2] * __thonny_stat[0]\n                __thonny_free = __thonny_stat[3] * __thonny_stat[0]\n                __thonny_used = __thonny_total - __thonny_free\n                __thonny_sizes = None\n                del __thonny_statvfs\n                del __thonny_stat \n            except ImportError:\n                __thonny_sizes = [__thonny_helper.os.size(name) for name in __thonny_helper.os.listdir()]\n                __thonny_used = None\n                __thonny_total = None\n                __thonny_free = None\n            \n            __thonny_helper.print_mgmt_value({\n                \"total\" : __thonny_total,\n                \"used\" : __thonny_used,\n                \"free\": __thonny_free,\n                \"sizes\": __thonny_sizes\n            })  \n                \n            del __thonny_total\n            del __thonny_free\n            del __thonny_used\n            del __thonny_sizes\n            \"\"\"\n            )\n            % cmd.path\n        )\n\n        if result[\"sizes\"] is not None:\n            if self._connected_to_microbit():\n                comment = \"Assuming around 30 kB of storage space for user files.\"\n            else:\n                comment = \"Don't know the size of storage space on this device.\"\n\n            files_total_size = sum(result[\"sizes\"])\n\n            # TODO: compute number of used blocks\n            if files_total_size > 0:\n                comment += \"\\n\\n\" + \"At least %s of it is used by %d file(s).\" % (\n                    sizeof_fmt(files_total_size),\n                    len(result[\"sizes\"]),\n                )\n\n            result[\"comment\"] = comment\n            del result[\"sizes\"]\n\n        return result", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provides file system usage statistics for a connected MicroPython device. It determines total, used, and free space, or provides individual file sizes based on device capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_upload", "line_number": 1024, "body": "def _cmd_upload(self, cmd):\n        self._check_sync_time()\n        return super(BareMetalMicroPythonBackend, self)._cmd_upload(cmd)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method prepares for and executes an upload command to the MicroPython device. It first performs a synchronization time check before delegating the core upload operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_write_file", "line_number": 1028, "body": "def _cmd_write_file(self, cmd):\n        self._check_sync_time()\n        return super(BareMetalMicroPythonBackend, self)._cmd_write_file(cmd)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method, for a bare-metal MicroPython backend, executes a file write command. It first ensures the system's synchronization time is checked before performing the write operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_cmd_prepare_disconnect", "line_number": 1032, "body": "def _cmd_prepare_disconnect(self, cmd):\n        logger.info(\"Preparing disconnect\")\n        # NB! Don't let the mainloop see the prompt and act on it\n        self._connection.stop_reader()\n        self._write(NORMAL_MODE_CMD)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Prepares the MicroPython backend for a clean disconnection. It stops the connection reader and sets the device to a safe, non-interactive state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_delete_sorted_paths", "line_number": 1038, "body": "def _delete_sorted_paths(self, paths):\n        if not self._supports_directories():\n            # micro:bit\n            self._execute_without_output(\n                dedent(\n                    \"\"\"\n                for __thonny_path in %r: \n                    __thonny_helper.os.remove(__thonny_path)\n                    \n                del __thonny_path\n                \n            \"\"\"\n                )\n                % paths\n            )\n        else:\n            try:\n                super()._delete_sorted_paths(paths)\n            except Exception as e:\n                if \"read-only\" in str(e).lower():\n                    self._delete_via_mount(paths)\n\n            self._sync_remote_filesystem()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Deletes specified files and directories on a bare-metal MicroPython device, adapting to device capabilities and handling read-only errors. It ensures the remote filesystem is synchronized after deletion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_internal_path_to_mounted_path", "line_number": 1062, "body": "def _internal_path_to_mounted_path(self, path):\n        mount_path = self._get_fs_mount()\n        if mount_path is None:\n            return None\n\n        flash_prefix = self._get_flash_prefix()\n        if not path.startswith(flash_prefix):\n            return None\n\n        path_suffix = path[len(flash_prefix) :]\n\n        return os.path.join(mount_path, os.path.normpath(path_suffix))", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Translates a bare-metal MicroPython internal flash path to its equivalent accessible path on the mounted filesystem. This service enables accessing device storage from an external host."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_stat_mode_for_upload", "line_number": 1075, "body": "def _get_stat_mode_for_upload(self, path: str) -> Optional[int]:\n        return self._get_stat_mode(path)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Retrieves the file system 'stat' mode (e.g., file type, permissions) for a given path. This information is specifically intended for use during a file upload operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_mkdir_for_upload", "line_number": 1078, "body": "def _mkdir_for_upload(self, path: str) -> None:\n        self._mkdir(path)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Ensures the specified directory exists on the bare-metal device's file system, preparing the path for a file upload operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_read_file", "line_number": 1081, "body": "def _read_file(\n        self, source_path: str, target_fp: BinaryIO, callback: Callable[[int, int], None]\n    ) -> None:\n        start_time = time.time()\n\n        if self._connected_over_webrepl():\n            size = self._read_file_via_webrepl_file_protocol(source_path, target_fp, callback)\n        else:\n            # TODO: Is it better to read from mount when possible? Is the mount up to date when the file\n            # is written via serial? Does the MP API give up to date bytes when the file is written via mount?\n            size = self._read_file_via_serial(source_path, target_fp, callback)\n\n        logger.info(\"Read %s in %.1f seconds\", source_path, time.time() - start_time)\n        return size", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Facilitates reading a file from a connected MicroPython device. This method provides the capability to transfer remote files from the device to the local system."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_read_file_via_serial", "line_number": 1096, "body": "def _read_file_via_serial(\n        self, source_path: str, target_fp: BinaryIO, callback: Callable[[int, int], None]\n    ) -> None:\n\n        hex_mode = self._should_hexlify(source_path)\n\n        self._execute_without_output(\"__thonny_fp = open(%r, 'rb')\" % source_path)\n        if hex_mode:\n            self._execute_without_output(\"from binascii import hexlify as __temp_hexlify\")\n\n        block_size = self._get_file_operation_block_size()\n        file_size = self._get_file_size(source_path)\n        num_bytes_read = 0\n        while True:\n            if self._current_command_is_interrupted():\n                raise KeyboardInterrupt()\n            callback(num_bytes_read, file_size)\n            if hex_mode:\n                block = binascii.unhexlify(\n                    self._evaluate(\"__temp_hexlify(__thonny_fp.read(%s))\" % block_size)\n                )\n            else:\n                block = self._evaluate(\"__thonny_fp.read(%s)\" % block_size)\n\n            if block:\n                target_fp.write(block)\n                num_bytes_read += len(block)\n\n            if len(block) < block_size:\n                break\n\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n            __thonny_fp.close()\n            del __thonny_fp\n            try:\n                del __temp_hexlify\n            except:\n                pass\n            \"\"\"\n            )\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Core utility method of `BareMetalMicroPythonBackend` that reads a file from the connected MicroPython device via serial, writing its contents to a local target, with support for progress reporting."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_read_file_via_webrepl_file_protocol", "line_number": 1140, "body": "def _read_file_via_webrepl_file_protocol(\n        self, source_path: str, target_fp: BinaryIO, callback: Callable[[int, int], None]\n    ):\n        \"\"\"\n        Adapted from https://github.com/micropython/webrepl/blob/master/webrepl_cli.py\n        \"\"\"\n        assert self._connected_over_webrepl()\n\n        file_size = self._get_file_size(source_path)\n\n        src_fname = source_path.encode(\"utf-8\")\n        rec = struct.pack(\n            WEBREPL_REQ_S, b\"WA\", WEBREPL_GET_FILE, 0, 0, 0, len(src_fname), src_fname\n        )\n        self._write(WebreplBinaryMsg(rec))\n        assert self._read_websocket_response() == 0\n\n        bytes_read = 0\n        callback(bytes_read, file_size)\n        while True:\n            # report ready\n            self._write(WebreplBinaryMsg(b\"\\0\"))\n\n            (block_size,) = struct.unpack(\"<H\", self._connection.read(2))\n            if block_size == 0:\n                break\n            while block_size:\n                buf = self._connection.read(block_size)\n                if not buf:\n                    raise OSError()\n                bytes_read += len(buf)\n                target_fp.write(buf)\n                block_size -= len(buf)\n                callback(bytes_read, file_size)\n\n        assert self._read_websocket_response() == 0", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method facilitates downloading a file from a remote MicroPython device to the local system. It utilizes the WebREPL file protocol and provides progress updates."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_write_file", "line_number": 1177, "body": "def _write_file(\n        self,\n        source_fp: BinaryIO,\n        target_path: str,\n        file_size: int,\n        callback: Callable[[int, int], None],\n    ) -> None:\n        start_time = time.time()\n\n        if self._connected_over_webrepl():\n            self._write_file_via_webrepl_file_protocol(source_fp, target_path, file_size, callback)\n        else:\n            try:\n                self._write_file_via_serial(source_fp, target_path, file_size, callback)\n            except ReadOnlyFilesystemError:\n                self._write_file_via_mount(source_fp, target_path, file_size, callback)\n\n        logger.info(\"Wrote %s in %.1f seconds\", target_path, time.time() - start_time)", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method transfers a file from the host system to a MicroPython device. It automatically selects the optimal transfer protocol based on the connection type and device filesystem capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_write_file_via_mount", "line_number": 1197, "body": "def _write_file_via_mount(\n        self,\n        source: BinaryIO,\n        target_path: str,\n        file_size: int,\n        callback: Callable[[int, int], None],\n    ) -> None:\n        mounted_target_path = self._internal_path_to_mounted_path(target_path)\n        with open(mounted_target_path, \"wb\") as f:\n            bytes_written = 0\n            block_size = 4 * 1024\n            while True:\n                callback(bytes_written, file_size)\n                block = source.read(block_size)\n                if block:\n                    bytes_written += f.write(block)\n                    f.flush()\n                    os.fsync(f)\n\n                if len(block) < block_size:\n                    break\n\n        assert bytes_written == file_size\n\n        return bytes_written", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Transfers binary data to a target path on the MicroPython device's mounted filesystem. It provides progress updates and ensures data integrity during the file write operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_write_file_via_serial", "line_number": 1223, "body": "def _write_file_via_serial(\n        self,\n        source_fp: BinaryIO,\n        target_path: str,\n        file_size: int,\n        callback: Callable[[int, int], None],\n    ) -> None:\n        out, err = self._execute(\n            dedent(\n                \"\"\"\n            try:\n                __thonny_path = '{path}'\n                __thonny_written = 0\n                __thonny_fp = open(__thonny_path, 'wb')\n            except Exception as e:\n                print(str(e))\n            \"\"\"\n            ).format(path=target_path),\n            capture_output=True,\n        )\n\n        if \"readonly\" in (out + err).replace(\"-\", \"\").lower():\n            raise ReadOnlyFilesystemError()\n        elif out + err:\n            raise RuntimeError(\n                \"Could not open file %s for writing, output:\\n%s\" % (target_path, out + err)\n            )\n\n        # Define function to allow shorter write commands\n        hex_mode = self._should_hexlify(target_path)\n        if hex_mode:\n            self._execute_without_output(\n                dedent(\n                    \"\"\"\n                from binascii import unhexlify as __thonny_unhex\n                def __W(x):\n                    global __thonny_written\n                    __thonny_written += __thonny_fp.write(__thonny_unhex(x))\n                    __thonny_fp.flush()\n                    if hasattr(__thonny_helper.os, \"sync\"):\n                        __thonny_helper.os.sync()\n            \"\"\"\n                )\n            )\n        elif self._connected_to_microbit():\n            # doesn't have neither BytesIO.flush, nor os.sync\n            self._execute_without_output(\n                dedent(\n                    \"\"\"\n                def __W(x):\n                    global __thonny_written\n                    __thonny_written += __thonny_fp.write(x)\n            \"\"\"\n                )\n            )\n        else:\n            self._execute_without_output(\n                dedent(\n                    \"\"\"\n                def __W(x):\n                    global __thonny_written\n                    __thonny_written += __thonny_fp.write(x)\n                    __thonny_fp.flush()\n                    if hasattr(__thonny_helper.os, \"sync\"):\n                        __thonny_helper.os.sync()\n            \"\"\"\n                )\n            )\n\n        bytes_sent = 0\n        block_size = self._get_file_operation_block_size()\n\n        while True:\n            callback(bytes_sent, file_size)\n            block = source_fp.read(block_size)\n\n            if block:\n                if hex_mode:\n                    script = \"__W(%r)\" % binascii.hexlify(block)\n                else:\n                    script = \"__W(%r)\" % block\n                out, err = self._execute(script, capture_output=True)\n                if out or err:\n                    self._show_error(\n                        \"\\nCould not write next block after having written %d bytes to %s\"\n                        % (bytes_sent, target_path)\n                    )\n                    if bytes_sent > 0:\n                        self._show_error(\n                            \"Make sure your device's filesystem has enough free space. \"\n                            + \"(When overwriting a file, the old content may occupy space \"\n                            \"until the end of the operation.)\\n\"\n                        )\n                    raise ManagementError(script, out, err)\n                bytes_sent += len(block)\n\n            if len(block) < block_size:\n                break\n\n        bytes_received = self._evaluate(\"__thonny_written\")\n\n        if bytes_received != bytes_sent:\n            raise UserError(\"Expected %d written bytes but wrote %d\" % (bytes_sent, bytes_received))\n\n        # clean up\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n                try:\n                    del __W\n                    del __thonny_written\n                    del __thonny_path\n                    __thonny_fp.close()\n                    del __thonny_fp\n                    del __thonny_result\n                    del __thonny_unhex\n                except:\n                    pass\n            \"\"\"\n            )\n        )\n\n        return bytes_sent", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method transfers a binary file from the local machine to a MicroPython device's filesystem over a serial connection. It handles data transfer block by block, ensuring integrity and reporting progress."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_write_file_via_webrepl_file_protocol", "line_number": 1347, "body": "def _write_file_via_webrepl_file_protocol(\n        self,\n        source: BinaryIO,\n        target_path: str,\n        file_size: int,\n        callback: Callable[[int, int], None],\n    ) -> None:\n        \"\"\"\n        Adapted from https://github.com/micropython/webrepl/blob/master/webrepl_cli.py\n        \"\"\"\n        assert self._connected_over_webrepl()\n\n        dest_fname = target_path.encode(\"utf-8\")\n        rec = struct.pack(\n            WEBREPL_REQ_S, b\"WA\", WEBREPL_PUT_FILE, 0, 0, file_size, len(dest_fname), dest_fname\n        )\n        self._write(WebreplBinaryMsg(rec[:10]))\n        self._write(WebreplBinaryMsg(rec[10:]))\n        assert self._read_websocket_response() == 0\n\n        bytes_sent = 0\n        callback(bytes_sent, file_size)\n        while True:\n            block = source.read(1024)\n            if not block:\n                break\n            self._write(WebreplBinaryMsg(block))\n            bytes_sent += len(block)\n            callback(bytes_sent, file_size)\n\n        assert self._read_websocket_response() == 0\n\n        return bytes_sent", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method uploads a file from a source to a specified path on a MicroPython device. It leverages the WebREPL file protocol for efficient data transfer."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_read_websocket_response", "line_number": 1381, "body": "def _read_websocket_response(self):\n        data = self._connection.read(4)\n        sig, code = struct.unpack(\"<2sH\", data)\n        assert sig == b\"WB\"\n        return code", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Extracts a protocol-specific response code from a received WebSocket message by reading and validating its initial bytes from the connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_sync_remote_filesystem", "line_number": 1387, "body": "def _sync_remote_filesystem(self):\n        self._execute_without_output(\n            dedent(\n                \"\"\"\n            if hasattr(__thonny_helper.os, \"sync\"):\n                __thonny_helper.os.sync()        \n        \"\"\"\n            )\n        )", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Synchronizes the remote MicroPython device's filesystem. It flushes pending data writes to ensure persistence on the target hardware."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_sync_local_filesystem", "line_number": 1397, "body": "def _sync_local_filesystem(self):\n        if hasattr(os, \"sync\"):\n            os.sync()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Ensures all buffered filesystem changes are written to persistent storage, crucial for data integrity on bare-metal MicroPython systems."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_mkdir", "line_number": 1401, "body": "def _mkdir(self, path):\n        if path == \"/\":\n            return\n\n        try:\n            super()._mkdir(path)\n        except ManagementError as e:\n            if \"read-only\" in e.err.lower():\n                self._makedirs_via_mount(path)\n\n        self._sync_remote_filesystem()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provides robust directory creation on the remote MicroPython device's filesystem. It handles read-only errors by attempting an alternative method, then synchronizes the remote state."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_makedirs_via_mount", "line_number": 1413, "body": "def _makedirs_via_mount(self, path):\n        mounted_path = self._internal_path_to_mounted_path(path)\n        assert mounted_path is not None, \"Couldn't find mounted path for \" + path\n        os.makedirs(mounted_path, exist_ok=True)\n        self._sync_local_filesystem()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provisions a specified directory path on the mounted backend filesystem. It ensures existence and synchronizes the local state afterwards."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_delete_via_mount", "line_number": 1419, "body": "def _delete_via_mount(self, paths):\n        for path in paths:\n            mounted_path = self._internal_path_to_mounted_path(path)\n            assert mounted_path is not None\n            if os.path.isdir(mounted_path):\n                import shutil\n\n                shutil.rmtree(mounted_path)\n            else:\n                os.remove(mounted_path)\n\n        self._sync_local_filesystem()", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Method of BareMetalMicroPythonBackend that deletes specified files and directories on the mounted MicroPython device's filesystem. It also synchronizes the local backend state after deletion."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_fs_mount_label", "line_number": 1432, "body": "def _get_fs_mount_label(self):\n        # This method is most likely required with CircuitPython,\n        # so try its approach first\n        # https://learn.adafruit.com/welcome-to-circuitpython/the-circuitpy-drive\n        result = self._evaluate(\n            dedent(\n                \"\"\"\n            try:\n                from storage import getmount as __thonny_getmount\n                try:\n                    __thonny_result = __thonny_getmount(\"/\").label\n                finally:\n                    del __thonny_getmount\n            except ImportError:\n                __thonny_result = None \n            except OSError:\n                __thonny_result = None \n            \n            __thonny_helper.print_mgmt_value(__thonny_result)\n            \n            del __thonny_result\n            \"\"\"\n            )\n        )\n\n        if result is not None:\n            return result\n\n        if self._welcome_text is None:\n            return None\n\n        \"\"\"\n        # following is not reliable and probably not needed \n        markers_by_name = {\"PYBFLASH\": {\"pyb\"}, \"CIRCUITPY\": {\"circuitpython\"}}\n\n        for name in markers_by_name:\n            for marker in markers_by_name[name]:\n                if marker.lower() in self._welcome_text.lower():\n                    return name\n        \"\"\"\n\n        return None", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Retrieves the filesystem mount label from a connected MicroPython or CircuitPython device. It helps identify the device's type or configuration for backend operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_flash_prefix", "line_number": 1475, "body": "def _get_flash_prefix(self):\n        if not self._supports_directories():\n            return \"\"\n        elif (\n            \"LoBo\" in self._welcome_text\n            or \"WiPy with ESP32\" in self._welcome_text\n            or \"PYBLITE\" in self._welcome_text\n            or \"PYBv\" in self._welcome_text\n            or \"PYBOARD\" in self._welcome_text.upper()\n        ):\n            return \"/flash/\"\n        else:\n            return \"/\"", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Determines the correct flash memory root path for file operations on a MicroPython device. It adapts the path based on device directory support and specific firmware versions."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_fs_mount", "line_number": 1489, "body": "def _get_fs_mount(self):\n        label = self._get_fs_mount_label()\n        if label is None:\n            return None\n        else:\n            candidates = find_volumes_by_name(\n                self._get_fs_mount_label(),\n                # querying A can be very slow\n                skip_letters=\"A\",\n            )\n            if len(candidates) == 0:\n                raise RuntimeError(\"Could not find volume \" + self._get_fs_mount_label())\n            elif len(candidates) > 1:\n                raise RuntimeError(\"Found several possible mount points: %s\" % candidates)\n            else:\n                return candidates[0]", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Locates and returns the unique file system mount point (volume) for the bare-metal MicroPython device, identified by its configured label. It ensures a singular, valid volume is found."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_should_hexlify", "line_number": 1506, "body": "def _should_hexlify(self, path):\n        if \"binascii\" not in self._builtin_modules and \"ubinascii\" not in self._builtin_modules:\n            return False\n\n        for ext in (\".py\", \".txt\", \".csv\"):\n            if path.lower().endswith(ext):\n                return False\n\n        return True", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This internal method determines if a file path should be converted to a hexadecimal string. It checks for available hexlification modules and excludes common text-based file types."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_is_connected", "line_number": 1516, "body": "def _is_connected(self):\n        return self._connection._error is None", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Checks if the backend's connection to the MicroPython device is currently active and error-free. It provides a simple status check for communication readiness."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_epoch_offset", "line_number": 1519, "body": "def _get_epoch_offset(self) -> int:\n        # https://docs.micropython.org/en/latest/library/utime.html\n        # NB! Some boards (eg Pycom) may use Posix epoch!\n        try:\n            return super()._get_epoch_offset()\n        except NotImplementedError:\n            return Y2000_EPOCH_OFFSET", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Provides the specific epoch offset for MicroPython's time calculations. It defaults to the Year 2000 epoch if not defined by a parent class."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_sep", "line_number": 1527, "body": "def _get_sep(self):\n        if self._supports_directories():\n            return \"/\"\n        else:\n            return \"\"", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Determines the file system path separator for the MicroPython backend. It returns '/' if directories are supported, otherwise an empty string."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_decode", "line_number": 1533, "body": "def _decode(self, data: bytes) -> str:\n        return data.decode(ENCODING, errors=\"replace\")", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This method decodes raw byte data received from a bare-metal MicroPython system into a string, replacing any undecodable characters. It provides a core utility for interpreting hardware communication or file data as text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_extract_block_without_splitting_chars", "line_number": 1536, "body": "def _extract_block_without_splitting_chars(self, source_bytes: bytes) -> bytes:\n        i = self._write_block_size\n        while i > 1 and i < len(source_bytes) and is_continuation_byte(source_bytes[i]):\n            i -= 1\n\n        return source_bytes[:i]", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "This internal method extracts a block of bytes from source data, ensuring the block ends at a valid boundary by not splitting multi-byte sequences. It provides robust data chunking for the MicroPython backend."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "_get_file_operation_block_size", "line_number": 1543, "body": "def _get_file_operation_block_size(self):\n        # don't forget that the size may be expanded up to 4x where converted to Python\n        # bytes literal\n        if self._connected_to_microbit():\n            return 512\n        else:\n            return 1024", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Determines the appropriate block size for file operations. It adapts the size based on whether the backend is connected to a MicroPython micro:bit device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/bare_metal_backend.py", "function": "collect_output", "line_number": 918, "body": "def collect_output(data, stream):\n            output[stream] += data", "is_method": true, "class_name": "BareMetalMicroPythonBackend", "function_description": "Gathers and accumulates data into a designated output stream. This method consolidates various outputs (e.g., stdout, stderr) from a bare-metal MicroPython execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/subprocess_connection.py", "function": "write", "line_number": 33, "body": "def write(self, data):\n        if isinstance(data, (bytes, bytearray)):\n            data = data.decode(self.encoding)\n        self._proc.write(data)\n        self._proc.flush()\n        return len(data)", "is_method": true, "class_name": "SubprocessConnection", "function_description": "Writes string data to the connected subprocess, handling byte decoding as needed. It ensures data is immediately flushed to the subprocess."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/subprocess_connection.py", "function": "_listen_output", "line_number": 40, "body": "def _listen_output(self):\n        \"NB! works in background thread\"\n        try:\n            while True:\n                chars = self._proc.read(1)\n                if len(chars) > 0:\n                    as_bytes = chars.encode(self.encoding)\n                    self._make_output_available(as_bytes)\n                else:\n                    self._error = \"EOF\"\n                    break\n\n        except Exception as e:\n            self._error = str(e)", "is_method": true, "class_name": "SubprocessConnection", "function_description": "This method continuously reads output from a managed subprocess in a background thread. It makes the received data available internally, handling end-of-file conditions and errors."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/subprocess_connection.py", "function": "close", "line_number": 55, "body": "def close(self):\n        if self._proc is not None:\n            self._proc.kill(signal.SIGKILL)\n            # self._reading_thread.join() # 0.2 secs!\n            self._proc = None\n            self._reading_thread = None", "is_method": true, "class_name": "SubprocessConnection", "function_description": "Terminates the managed subprocess and cleans up its associated resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/webrepl_connection.py", "function": "debug", "line_number": 160, "body": "def debug(*args):\n    if DEBUG:\n        print(*args, file=sys.stderr)", "is_method": false, "function_description": "Provides a conditional logging service that prints debug messages to standard error. Other functions can use this to output diagnostic information when debugging is enabled."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/webrepl_connection.py", "function": "_wrap_ws_main", "line_number": 49, "body": "def _wrap_ws_main(self):\n        import asyncio\n\n        loop = asyncio.new_event_loop()\n        loop.set_debug(DEBUG)\n        loop.run_until_complete(self._ws_main())", "is_method": true, "class_name": "WebReplConnection", "function_description": "This method initializes and runs the primary asynchronous WebSocket handling logic for the Web REPL connection within its own dedicated asyncio event loop."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/webrepl_connection.py", "function": "write", "line_number": 130, "body": "def write(self, data):\n        self._write_queue.put_nowait(data)\n        return self._write_responses.get()", "is_method": true, "class_name": "WebReplConnection", "function_description": "Sends data to the WebREPL connection and synchronously retrieves its response. This facilitates interactive command execution and result retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/webrepl_connection.py", "function": "close_and_return_new_connection", "line_number": 137, "body": "def close_and_return_new_connection(self):\n        self.close()\n        return WebReplConnection(self._url, self._password)", "is_method": true, "class_name": "WebReplConnection", "function_description": "This method closes the current WebRepl connection and then establishes and returns a new connection instance using the same credentials. It provides a way to refresh or re-establish a connection."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/webrepl_connection.py", "function": "__len__", "line_number": 156, "body": "def __len__(self):\n        return len(self.data)", "is_method": true, "class_name": "WebreplBinaryMsg", "function_description": "Enables the `len()` built-in function for WebreplBinaryMsg objects. It reports the size of the internal binary data, allowing its length to be queried."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_start_fetching_micropython_org_info", "line_number": 374, "body": "def _start_fetching_micropython_org_info(name, completion_handler):\n    import urllib.error\n    import urllib.parse\n\n    # Fetch info from PyPI\n    url = MICROPYTHON_ORG_JSON % urllib.parse.quote(name)\n\n    url_future = _fetch_url_future(url)\n\n    def poll_fetch_complete():\n        import json\n\n        if url_future.done():\n            try:\n                _, bin_data = url_future.result()\n                raw_data = bin_data.decode(\"UTF-8\")\n                completion_handler(name, json.loads(raw_data), None)\n            except urllib.error.HTTPError as e:\n                completion_handler(\n                    name, {\"info\": {\"name\": name}, \"error\": str(e), \"releases\": {}}, e.code\n                )\n        else:\n            tk._default_root.after(200, poll_fetch_complete)\n\n    poll_fetch_complete()", "is_method": false, "function_description": "Initiates an asynchronous request to `micropython.org` to fetch information for a given name. It uses a completion handler to process the fetched data or any errors when the operation finishes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_create_pip_process", "line_number": 33, "body": "def _create_pip_process(self, args):\n        return self._create_python_process([\"-m\", \"thonny.plugins.micropython.micropip\"] + args)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Provides a utility to initiate a Python process specifically for running MicroPython's package installer, `micropip`. It prepares the command with the given arguments."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_on_install_click", "line_number": 40, "body": "def _on_install_click(self):\n        if self.install_button[\"text\"] == self.get_install_button_text():\n            super()._on_install_click()\n        elif self.install_button[\"text\"] == self.get_search_button_text():\n            self.search_box.delete(0, \"end\")\n            self.search_box.insert(\n                0, \"micropython pycopy \" + self.current_package_data[\"info\"][\"name\"]\n            )\n            self._on_search(None)\n        else:\n            raise RuntimeError(\n                \"Unexpected text '%s' on install button\" % self.install_button[\"text\"]\n            )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "This method processes clicks on the 'install' button within the dialog. It dynamically either initiates a package installation or performs a specific search for the current package based on the button's displayed text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_on_uninstall_click", "line_number": 54, "body": "def _on_uninstall_click(self):\n        if self.uninstall_button[\"text\"] == self.get_uninstall_button_text():\n            super()._on_uninstall_click()\n        elif self.uninstall_button[\"text\"] == self.get_delete_selected_button_text():\n            self._delete_selected()\n        else:\n            raise RuntimeError(\n                \"Unexpected text '%s' on install button\" % self.install_button[\"text\"]\n            )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "This method handles the uninstall button click event, dynamically performing either a package uninstallation or deleting selected items. It adapts the button's action based on its current text within the MicroPython PIP dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_delete_selected", "line_number": 64, "body": "def _delete_selected(self):\n        paths = []\n        for cb in self._checkboxes:\n            if cb.variable.get():\n                paths.append(cb.full_path)\n\n        if paths:\n            self._delete_paths(paths)\n            self._start_update_list(self.current_package_data[\"info\"][\"name\"])", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Enables the deletion of all currently selected package components or files within the dialog. It then updates the displayed list to reflect the changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_delete_paths", "line_number": 74, "body": "def _delete_paths(self, paths):\n        get_runner().send_command_and_wait(\n            InlineCommand(\"delete\", paths=paths),\n            dialog_title=tr(\"Deleting\"),\n        )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Handles the deletion of specified paths on the MicroPython device. It sends the delete command via the runner and waits for completion, showing a progress dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_get_install_command", "line_number": 80, "body": "def _get_install_command(self):\n        return [\"install\", \"-p\", self._current_temp_dir]", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Provides the core command-line arguments to install MicroPython packages into a temporary directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_perform_pip_action", "line_number": 83, "body": "def _perform_pip_action(self, action: str) -> bool:\n        if self._perform_pip_action_without_refresh(action):\n            self._show_instructions()  # Make the old package go away as fast as possible\n\n            # don't know which module to show, therefore None arg\n            self._start_update_list(None)\n            get_workbench().event_generate(\"RemoteFilesChanged\")", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "This method performs a specified pip package management action on a MicroPython device. It then refreshes the dialog's package list and notifies the application of remote file changes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_perform_pip_action_without_refresh", "line_number": 91, "body": "def _perform_pip_action_without_refresh(self, action: str) -> bool:\n        assert action in [\"install\", \"advanced\"]\n\n        self._current_temp_dir = tempfile.mkdtemp()\n        try:\n            return super()._perform_pip_action_without_refresh(action)\n        finally:\n            shutil.rmtree(self._current_temp_dir, ignore_errors=True)\n            self._current_temp_dir = None", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Performs a MicroPython package management action, such as 'install', within a temporary environment. It ensures automatic cleanup of temporary resources after the operation completes."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_create_upload_command", "line_number": 101, "body": "def _create_upload_command(self) -> InlineCommand:\n        paths = []\n        for (dirpath, dirnames, filenames) in os.walk(self._current_temp_dir):\n            if dirpath != self._current_temp_dir:\n                paths.append(dirpath)\n\n            for filename in filenames:\n                source_path = os.path.join(dirpath, filename)\n                paths.append(source_path)\n\n        items = []\n        for path in paths:\n            for item in prepare_upload_items(\n                path, self._current_temp_dir, self._get_target_directory()\n            ):\n                if item not in items:\n                    items.append(item)\n\n        if not items:\n            raise RuntimeError(\"Could not find anything in temp directory. Was it a dummy package?\")\n\n        return InlineCommand(\"upload\", items=items)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Prepares an `InlineCommand` to upload all files and directories from a temporary package staging area. This command facilitates deployment to a MicroPython device."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_create_python_process", "line_number": 124, "body": "def _create_python_process(self, args):\n        proc = running.create_frontend_python_process(args, stderr=subprocess.STDOUT)\n        return proc, proc.cmd", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Initiates and returns a new Python subprocess, configured for frontend interaction and error capturing. It provides the capability to execute external Python commands required by the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_on_listbox_select_package", "line_number": 128, "body": "def _on_listbox_select_package(self, name):\n        self._start_show_module_info(name)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "This method handles the selection of a package in a listbox. It initiates the display of detailed information for the chosen package within the MicroPython package management dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_start_show_module_info", "line_number": 131, "body": "def _start_show_module_info(self, name):\n        self._clear_info_text()\n        self.command_frame.grid_remove()\n        self.title_label[\"text\"] = tr(\"Module\") + (\" '%s'\" % name)\n        self.title_label.grid()\n        self._set_state(\"fetching\")\n        self.advanced_button.grid_remove()\n\n        get_workbench().bind(\"get_module_info_response\", self._complete_display_module_info, True)\n        get_runner().send_command(InlineCommand(\"get_module_info\", module_name=name))", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Initiates fetching and displaying detailed information for a specified MicroPython module. It prepares the UI and sends a command to retrieve the module data asynchronously."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_complete_display_module_info", "line_number": 142, "body": "def _complete_display_module_info(self, msg):\n        self._set_state(\"idle\")\n        self.current_package_data = {\"info\": {\"name\": msg.module_name}}\n        get_workbench().unbind(\"get_module_info_response\", self._complete_display_module_info)\n\n        self._append_info_text(tr(\"Installed to:\") + \" \", (\"caption\",))\n        self._append_info_text(msg[\"location\"] + \"\\n\")\n\n        for cb in self._checkboxes:\n            cb.destroy()\n        self._checkboxes.clear()\n\n        for item in msg[\"effective_items\"]:\n            self._append_file_checkbox(item, msg[\"location\"])\n\n        if msg[\"shadowed_items\"]:\n            self._append_info_text(\"\\n\")\n            self._append_info_text(tr(\"Shadowed items (not importable):\") + \"\\n\", (\"caption\",))\n            for item in msg[\"shadowed_items\"]:\n                self._append_file_checkbox(item, None)\n\n        self.command_frame.grid()\n        self.uninstall_button.grid()\n        self.install_button[\"text\"] = self.get_search_button_text()\n        self.uninstall_button[\"text\"] = self.get_delete_selected_button_text()\n        self.uninstall_button[\"state\"] = \"normal\" if self._checkboxes else \"disabled\"\n        self._select_list_item(msg.module_name)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "This method completes the display of module details within the MicroPythonPipDialog. It presents installed and shadowed files with checkboxes and updates the dialog's UI element states."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_append_file_checkbox", "line_number": 170, "body": "def _append_file_checkbox(self, full_path, context_dir):\n        if context_dir:\n            text = full_path[len(context_dir) :].strip(\"/\")\n        else:\n            text = full_path\n\n        if self._can_delete(full_path):\n            cb = ttk.Checkbutton(self.info_text, text=text)\n            var = tk.IntVar(value=1)\n            cb.variable = var  # to avoid it being gc-d\n            cb[\"variable\"] = var\n            cb.full_path = full_path\n            self._checkboxes.append(cb)\n            self.info_text.window_create(\"end\", window=cb)\n        else:\n            self._append_info_text(\"\u2022 \" + text)\n\n        self._append_info_text(\"\\n\")", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Adds a file path to the dialog's display. It shows it as a selectable checkbox if the file is deletable, otherwise as plain text for information."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_show_package_info", "line_number": 189, "body": "def _show_package_info(self, name, data, error_code=None):\n        super(MicroPythonPipDialog, self)._show_package_info(name, data, error_code)\n\n        if name.lower().startswith(\"micropython-\"):\n            self._set_state(\"fetching\")\n            self._append_info_text(\"\\n\\n\")\n            self.info_text.mark_set(\"wait\", \"end-1c\")\n            self.info_text.mark_gravity(\"wait\", \"left\")\n            self._append_info_text(\"Querying micropython.org, please wait...\")\n            _start_fetching_micropython_org_info(name, self._add_micropython_org_info)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Extends package information display by asynchronously fetching and integrating specific details for MicroPython packages from micropython.org into the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_add_micropython_org_info", "line_number": 200, "body": "def _add_micropython_org_info(self, name, data, error_code=None):\n        self._set_state(\"idle\")\n        self.info_text.direct_delete(\"wait\", \"end\")\n        self.info_text.mark_unset(\"wait\")\n        self._append_info_text(\"\\n\")\n\n        if error_code == 404:\n            self._append_info_text(\n                tr(\n                    \"Package is not available at micropython.org. \"\n                    \"Version at PyPI will be installed.\"\n                )\n            )\n        elif error_code:\n            self._append_info_text(\"Error %s\\n\" % error_code)\n            self._append_info_text(data.get(\"error\", \"\") + \"\\n\")\n        else:\n            ver = data[\"info\"][\"version\"]\n            self._append_info_text(\n                tr(\n                    \"NB! micropython.org has published version %s of this package \"\n                    \"and this will be installed by default.\"\n                )\n                % ver\n                + \"\\n\",\n                (\"bold\",),\n            )\n            self._append_info_text(\n                \"If you want to install a version from PyPI, then use the advanced install button '...'. \"\n                \"Note that PyPI version may require a specific fork of MicroPython.\"\n            )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "This method updates the MicroPython package dialog's info text based on checks against `micropython.org`. It informs the user if a package is found there (and its version), not found (defaulting to PyPI), or if an error occurred."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_can_delete", "line_number": 232, "body": "def _can_delete(self, path):\n        return not path.startswith(\"/usr/lib\")", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Determines if a given file path is eligible for deletion. It prevents deletion of paths located under `/usr/lib`, serving as a safety mechanism for system files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_get_target_directory", "line_number": 235, "body": "def _get_target_directory(self):\n        target_dir = self._backend_proxy.get_pip_target_dir()\n        return target_dir", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Retrieves the designated target directory for MicroPython pip operations. It provides the essential path for package installation and management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_read_only", "line_number": 239, "body": "def _read_only(self):\n        return self._get_target_directory() is None", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Checks if the dialog is in a read-only state. It determines this by verifying if a target directory has been specified."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_show_instructions_about_existing_packages", "line_number": 242, "body": "def _show_instructions_about_existing_packages(self):\n        self._append_info_text(tr(\"Upgrade or uninstall\") + \"\\n\", (\"caption\",))\n        self.info_text.direct_insert(\n            \"end\", tr(\"For upgrading simply install the package again.\") + \"\\n\"\n        )\n        self.info_text.direct_insert(\n            \"end\", tr(\"For uninstalling delete corresponding files.\") + \"\\n\\n\"\n        )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Provides the MicroPython Pip dialog with instructions for users on how to upgrade or uninstall existing packages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_use_user_install", "line_number": 255, "body": "def _use_user_install(self):\n        return False", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Determines if pip packages should be installed at the user level. This method explicitly disables user-level installations within the dialog's context."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "does_support_update_deps_switch", "line_number": 258, "body": "def does_support_update_deps_switch(self):\n        return False", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Indicates that the MicroPythonPipDialog does not support an \"update dependencies\" feature or UI switch, preventing its use in related operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_show_instructions_about_target", "line_number": 261, "body": "def _show_instructions_about_target(self):\n        self._append_info_text(tr(\"Scope\") + \"\\n\", (\"caption\",))\n\n        if isinstance(self._backend_proxy, LocalMicroPythonProxy):\n            dir_tags = (\"url\",)\n        else:\n            dir_tags = ()\n\n        if len(self._backend_proxy.get_lib_dirs()) == 1:\n            self._append_info_text(self._get_target_directory(), dir_tags)\n            self._append_info_text(\"\\n\")\n        else:\n\n            self.info_text.direct_insert(\n                \"end\", tr(\"This dialog lists top-level modules from following directories:\\n\")\n            )\n\n            for path in self._backend_proxy.get_lib_dirs():\n                self._append_info_text(\"\u2022 \")\n                self._append_info_text(path, dir_tags)\n                self._append_info_text(\"\\n\")\n\n            self._append_info_text(\"\\n\")\n            self._append_info_text(tr(\"New packages will be installed to\") + \"\\n\")\n            self._append_info_text(\"\u2022 \")\n            self._append_info_text(self._get_target_directory(), dir_tags)\n            self._append_info_text(\"\\n\")", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Displays within the dialog the MicroPython library directories currently in use and the designated installation path for new packages."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_show_read_only_instructions", "line_number": 289, "body": "def _show_read_only_instructions(self):\n        self._append_info_text(tr(\"Not available\") + \"\\n\", (\"caption\",))\n        if not self._get_target_directory():\n            reason = \" (\" + tr(\"no absolute lib directory in sys.path\") + \")\"\n        else:\n            reason = \"\"\n        self.info_text.direct_insert(\n            \"end\",\n            get_not_supported_translation() + reason + \"\\n\\n\",\n        )", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Informs the user via the dialog that an operation is not available or supported. It explains the read-only state, potentially due to a missing target library directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_tweak_search_results", "line_number": 300, "body": "def _tweak_search_results(self, results, query):\n        if results is None:\n            return results\n        query = query.lower()\n\n        def get_order(item):\n            name = item[\"name\"].lower()\n            if name == query:\n                return 0\n            elif name == \"micropython-\" + query:\n                return 1\n            elif name == \"pycopy-\" + query:\n                return 2\n            elif \"micropython\" in name:\n                return 3\n            elif \"pycopy\" in name:\n                return 4\n            elif item.get(\"description\"):\n                description = item[\"description\"]\n                if \"micropython\" in description.lower() or \"pycopy\" in description.lower():\n                    return 5\n\n            return 6\n\n        return sorted(results, key=get_order)", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "The method reorders search results to prioritize items highly relevant to the query and MicroPython/Pycopy. It enhances search result presentation by placing more pertinent packages first."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_get_interpreter", "line_number": 326, "body": "def _get_interpreter(self):\n        return self._backend_proxy.get_full_label()", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Provides the full label identifying the MicroPython interpreter used by the dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_get_extra_switches", "line_number": 329, "body": "def _get_extra_switches(self):\n        return []", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Provides an empty list of additional command-line switches. This method serves as a customizable hook for subclasses to provide extra options."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_run_pip_with_dialog", "line_number": 332, "body": "def _run_pip_with_dialog(self, args, title) -> Tuple[int, str, str]:\n        args = [\"-m\", \"thonny.plugins.micropython.micropip\"] + args\n        proc = running.create_frontend_python_process(args, stderr=subprocess.STDOUT)\n        cmd = proc.cmd\n        dlg = InstallAndUploadDialog(\n            self,\n            proc,\n            back_cmd=self._create_upload_command,\n            title=\"micropip\",\n            instructions=title,\n            autostart=True,\n            output_prelude=subprocess.list2cmdline(cmd) + \"\\n\",\n        )\n        ui_utils.show_dialog(dlg)\n        assert dlg.returncode is not None\n        return dlg.returncode, dlg.stdout, dlg.stderr", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "Provides a user interface to execute `micropip` commands for MicroPython package management. It displays the command's progress and output in an interactive dialog."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_get_install_command", "line_number": 351, "body": "def _get_install_command(self):\n        return [\"install\", \"-p\", self._get_target_directory()]", "is_method": true, "class_name": "LocalMicroPythonPipDialog", "function_description": "Prepares the command-line arguments required to perform a package installation. It specifies the target directory for the local installation."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_delete_paths", "line_number": 357, "body": "def _delete_paths(self, paths):\n        # assuming all files are listed if their directory is listed\n        for path in sorted(paths, key=len, reverse=True):\n            if os.path.isfile(path):\n                os.remove(path)\n            else:\n                os.removedirs(path)", "is_method": true, "class_name": "LocalMicroPythonPipDialog", "function_description": "Deletes a list of specified files and their containing directories from the local filesystem. It handles nested path removal by processing files before their directories."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "_run_pip_with_dialog", "line_number": 365, "body": "def _run_pip_with_dialog(self, args, title) -> Tuple[int, str, str]:\n        args = [\"-m\", \"thonny.plugins.micropython.micropip\"] + args\n        proc = running.create_frontend_python_process(args, stderr=subprocess.STDOUT)\n        cmd = proc.cmd\n        dlg = SubprocessDialog(self, proc, \"micropip\", long_description=title, autostart=True)\n        ui_utils.show_dialog(dlg)\n        return dlg.returncode, dlg.stdout, dlg.stderr", "is_method": true, "class_name": "LocalMicroPythonPipDialog", "function_description": "This function runs `micropip` commands and displays their execution within a dedicated dialog window for user interaction and feedback. It provides a UI for MicroPython package management."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "poll_fetch_complete", "line_number": 383, "body": "def poll_fetch_complete():\n        import json\n\n        if url_future.done():\n            try:\n                _, bin_data = url_future.result()\n                raw_data = bin_data.decode(\"UTF-8\")\n                completion_handler(name, json.loads(raw_data), None)\n            except urllib.error.HTTPError as e:\n                completion_handler(\n                    name, {\"info\": {\"name\": name}, \"error\": str(e), \"releases\": {}}, e.code\n                )\n        else:\n            tk._default_root.after(200, poll_fetch_complete)", "is_method": false, "function_description": "This function asynchronously polls for the completion of a web request. It processes the fetched JSON data or handles errors, then invokes a completion handler to deliver the result within a GUI application."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "start_work", "line_number": 416, "body": "def start_work(self):\n        threading.Thread(target=self.work_in_thread, daemon=True).start()", "is_method": true, "class_name": "InstallAndUploadDialog", "function_description": "Starts the main processing work in a separate daemon thread. This prevents the UI from freezing during long-running operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "work_in_thread", "line_number": 419, "body": "def work_in_thread(self):\n        self.set_action_text(\"Installing to temp directory\")\n        self.append_text(\"Installing to temp directory\\n\")\n        while True:\n            line = self._proc.stdout.readline()\n            if not line:\n                break\n            self.append_text(line)\n            self.set_action_text_smart(line)\n        self.returncode = self._proc.wait()\n        if self.returncode:\n            self.set_action_text(\"Error\")\n            self.append_text(\"\\nmicropip returned with error code %s\\n\" % self.returncode)\n        else:\n            self.set_action_text(\"Copying to the device\")\n            self.append_text(\"Copying to the device\\n\")\n        self.report_done(self.returncode == 0)", "is_method": true, "class_name": "InstallAndUploadDialog", "function_description": "Executes and monitors an installation and copying process in a background thread. It updates the dialog's text and status, reporting success or failure to the user."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "on_done", "line_number": 437, "body": "def on_done(self, success):\n        if not success or self._stage == \"upload\":\n            super().on_done(success)\n            if self._stage == \"upload\":\n                # Returcode is required by the superclass\n                if success:\n                    self.returncode = 0\n                else:\n                    self.returncode = -1\n            return\n\n        assert self._stage == \"install\"\n        # only half of the work is done\n        self._stage = \"upload\"\n        super().send_command_to_backend()", "is_method": true, "class_name": "InstallAndUploadDialog", "function_description": "This method manages the multi-stage progression of the dialog. It advances from a successful installation to initiate an upload or finalizes the dialog if the upload completes or any stage fails."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/pip_gui.py", "function": "get_order", "line_number": 305, "body": "def get_order(item):\n            name = item[\"name\"].lower()\n            if name == query:\n                return 0\n            elif name == \"micropython-\" + query:\n                return 1\n            elif name == \"pycopy-\" + query:\n                return 2\n            elif \"micropython\" in name:\n                return 3\n            elif \"pycopy\" in name:\n                return 4\n            elif item.get(\"description\"):\n                description = item[\"description\"]\n                if \"micropython\" in description.lower() or \"pycopy\" in description.lower():\n                    return 5\n\n            return 6", "is_method": true, "class_name": "MicroPythonPipDialog", "function_description": "This method assigns a priority order to a package item. It ranks items based on how well their name or description matches a query and MicroPython relevance, useful for sorting search results."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/api_stubs/builtins.py", "function": "delattr", "line_number": 251, "body": "def delattr():\n    pass", "is_method": false, "function_description": "Removes a specified attribute from an object, providing a way to dynamically modify object properties."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/api_stubs/builtins.py", "function": "globals", "line_number": 356, "body": "def globals():\n    pass", "is_method": false, "function_description": "This function returns a dictionary representing the current global symbol table. It provides direct access to all global variables, functions, and classes defined in the current module."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/micropython/api_stubs/builtins.py", "function": "clear", "line_number": 258, "body": "def clear():\n        pass", "is_method": true, "class_name": "dict", "function_description": "Removes all key-value pairs from the dictionary, making it empty. This is useful for resetting a dictionary for reuse."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pylint/__init__.py", "function": "load_plugin", "line_number": 127, "body": "def load_plugin():\n    add_program_analyzer(PylintAnalyzer)\n    get_workbench().set_default(\"assistance.use_pylint\", True)", "is_method": false, "function_description": "This function loads and configures the Pylint code analyzer, integrating it into the system's program analysis capabilities and enabling its use by default."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pylint/__init__.py", "function": "is_enabled", "line_number": 14, "body": "def is_enabled(self):\n        return get_workbench().get_option(\"assistance.use_pylint\")", "is_method": true, "class_name": "PylintAnalyzer", "function_description": "Checks if Pylint assistance is currently enabled based on the workbench's configuration settings. This informs other components whether to activate Pylint-related features."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pylint/__init__.py", "function": "start_analysis", "line_number": 17, "body": "def start_analysis(self, main_file_path, imported_file_paths):\n        relevant_symbols = {\n            checks_by_id[key][\"msg_sym\"]\n            for key in checks_by_id\n            if checks_by_id[key][\"usage\"] == \"warning\"\n        }\n\n        if \"bad-python3-import\" in relevant_symbols:\n            # https://github.com/PyCQA/pylint/issues/2453\n            # TODO: allow if this is fixed in minimum version\n            relevant_symbols.remove(\"bad-python3-import\")\n\n        # remove user-disabled checks\n        relevant_symbols = relevant_symbols - set(\n            get_workbench().get_option(\"assistance.disabled_checks\")\n        )\n\n        ignored_modules = {\"turtle\"}  # has dynamically generated attributes\n\n        options = [\n            # \"--rcfile=None\", # TODO: make it ignore any rcfiles that can be somewhere\n            \"--persistent=n\",\n            # \"--confidence=HIGH\", # Leave empty to show all. Valid levels: HIGH, INFERENCE, INFERENCE_FAILURE, UNDEFINED\n            # \"--disable=missing-docstring,invalid-name,trailing-whitespace,trailing-newlines,missing-final-newline,locally-disabled,suppressed-message\",\n            \"--disable=all\",\n            \"--enable=\" + \",\".join(relevant_symbols),\n            \"--ignored-modules=\" + \",\".join(ignored_modules),\n            \"--max-line-length=120\",\n            \"--output-format=text\",\n            \"--reports=n\",\n            \"--msg-template={{'filename':{abspath!r}, 'lineno':{line}, 'col_offset':{column}, 'symbol':{symbol!r}, 'msg':{msg!r}, 'msg_id':{msg_id!r}, 'category' : {C!r} }}\",\n        ]\n\n        # disallow unused globals only in main script\n        \"\"\"\n        Not good idea, because unused * imports also count as unused global vars\n        from pylint.__pkginfo__ import numversion\n\n        if not imported_file_paths and numversion >= (1, 7):\n            # (unfortunately can't separate main script when user modules are present)\n            options.append(\"--allow-global-unused-variables=no\")\n        \"\"\"\n\n        self._proc = ui_utils.popen_with_ui_thread_callback(\n            [get_interpreter_for_subprocess(), \"-m\", \"pylint\"]\n            + options\n            + [main_file_path]\n            + list(imported_file_paths),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            universal_newlines=True,\n            on_completion=self._parse_and_output_warnings,\n        )", "is_method": true, "class_name": "PylintAnalyzer", "function_description": "Initiates and configures a Pylint static code analysis. It specifies relevant checks and output format, then runs Pylint as a subprocess on the given Python files."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/pylint/__init__.py", "function": "_parse_and_output_warnings", "line_number": 71, "body": "def _parse_and_output_warnings(self, pylint_proc, out_lines, err_lines):\n        # print(\"COMPL\", out, err)\n        # get rid of non-error\n        err = (\n            \"\".join(err_lines)\n            .replace(\"No config file found, using default configuration\", \"\")\n            .strip()\n        )\n\n        if err:\n            logger.error(\"Pylint: \" + err)\n\n        warnings = []\n        for line in out_lines:\n            if line.startswith(\"{\"):\n                try:\n                    atts = ast.literal_eval(line.strip())\n                except SyntaxError:\n                    logging.error(\"Can't parse Pylint line: \" + line)\n                    continue\n                else:\n                    check = checks_by_id[atts[\"msg_id\"]]\n                    if check.get(\"tho_xpln\"):\n                        explanation = check[\"tho_xpln\"]\n                    else:\n                        explanation = check[\"msg_xpln\"]\n\n                    if explanation.startswith(\"Used when an \"):\n                        explanation = \"It looks like the \" + explanation[(len(\"Used when an \")) :]\n                    elif explanation.startswith(\"Emitted when an \"):\n                        explanation = (\n                            \"It looks like the \" + explanation[(len(\"Emitted when an \")) :]\n                        )\n                    elif explanation.startswith(\"Used when a \"):\n                        explanation = \"It looks like the \" + explanation[(len(\"Used when a \")) :]\n                    elif explanation.startswith(\"Emitted when a \"):\n                        explanation = \"It looks like the \" + explanation[(len(\"Emitted when a \")) :]\n                    elif explanation.startswith(\"Used when \"):\n                        explanation = \"It looks like \" + explanation[(len(\"Used when \")) :]\n                    elif explanation.startswith(\"Emitted when \"):\n                        explanation = \"It looks like \" + explanation[(len(\"Emitted when \")) :]\n\n                    atts[\"explanation\"] = explanation\n\n                    if check.get(\"tho_xpln_rst\"):\n                        atts[\"explanation_rst\"] = check[\"tho_xpln_rst\"]\n\n                    if atts[\"category\"] in (\"I\", \"F\"):\n                        atts[\"msg\"] = \"INTERNAL ERROR when analyzing the code: \" + atts[\"msg\"]\n\n                    # atts[\"more_info_url\"] = \"http://pylint-messages.wikidot.com/messages:%s\" % atts[\"msg_id\"].lower()\n                    warnings.append(atts)\n\n        self.completion_handler(self, warnings)", "is_method": true, "class_name": "PylintAnalyzer", "function_description": "Parses raw Pylint output and error streams to extract and format code analysis warnings. It enriches these warnings with user-friendly explanations before passing them for further handling."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "_clear_screen", "line_number": 7, "body": "def _clear_screen():\n    if platform.system() == \"Windows\":\n        os.system(\"cls\")\n    else:\n        os.system(\"clear\")", "is_method": false, "function_description": "Clears the console screen, adapting the command used based on the operating system. This provides a clean interface for console-based applications."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "equivalent_realpath", "line_number": 14, "body": "def equivalent_realpath(p):\n    pdir = os.path.dirname(p)\n    if os.path.isfile(os.path.join(pdir, \"activate\")):\n        # it's a virtual environment\n        # can use realpath only if it doesn't move out of its dir\n        real = os.path.realpath(p)\n        if os.path.dirname(real) == pdir:\n            return real\n        try:\n            link = os.readlink(p)\n            if not os.path.isabs(link):\n                link = os.path.join(pdir, link)\n            link = os.path.normpath(link)\n            if os.path.dirname(link) == pdir:\n                return link\n            return p\n        except Exception:\n            return p\n    else:\n        return os.path.realpath(p)", "is_method": false, "function_description": "Computes the real, canonical path for a given file or directory. It specifically handles virtual environments, ensuring paths resolve within their directory or return the original if they point outside."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "is_virtual_exe", "line_number": 36, "body": "def is_virtual_exe(p):\n    pdir = os.path.dirname(p)\n    return os.path.exists(os.path.join(pdir, \"activate\")) or os.path.exists(\n        os.path.join(pdir, \"activate.bat\")\n    )", "is_method": false, "function_description": "Checks if an executable path resides within a Python virtual environment by checking for activation scripts. This identifies whether an executable belongs to an isolated Python setup."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "is_bundled_exe", "line_number": 43, "body": "def is_bundled_exe(p):\n    pdir = os.path.dirname(p)\n    return os.path.exists(os.path.join(pdir, \"thonny_python.ini\"))", "is_method": false, "function_description": "Determines if a given path belongs to a Thonny-bundled executable. It checks for the presence of a specific configuration file in its directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "list_commands", "line_number": 48, "body": "def list_commands(prefix, highlighted_reals, highlighted_dirs):\n    for suffix in [\"\", \"3\", \"3.5\", \"3.6\", \"3.7\", \"3.8\"]:\n        cmd = prefix + suffix\n        import shutil\n\n        target = shutil.which(cmd)\n        if target is not None:\n            target = os.path.abspath(target)\n            target = normpath_with_actual_case(target)\n            real = equivalent_realpath(target)\n\n            if target == real:\n                relation = \"==\"\n            else:\n                relation = \"->\"\n\n            line = \" - \" + cmd.ljust(9) + \" \" + relation + \" \" + real\n            if (\n                real in highlighted_reals\n                or os.path.dirname(real) in highlighted_dirs\n                or os.path.dirname(target) in highlight_dirs\n            ):\n                print(wrap_in_ansi_code(line, \"1\"))\n            else:\n                print(wrap_in_ansi_code(line, \"2\"))", "is_method": false, "function_description": "This function identifies and displays system commands based on a given prefix and common version suffixes. It highlights specific command paths or directories for user attention."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "wrap_in_ansi_code", "line_number": 75, "body": "def wrap_in_ansi_code(text, code):\n    if can_use_ansi_codes():\n        return \"\\033[\" + code + \"m\" + text + \"\\033[0m\"\n    else:\n        return text", "is_method": false, "function_description": "Applies ANSI escape codes to text for terminal display, conditionally adding styling like color or formatting if supported by the environment."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "can_use_ansi_codes", "line_number": 82, "body": "def can_use_ansi_codes():\n    if platform.system() == \"Windows\":\n        ver = platform.win32_ver()\n        try:\n            return int(ver[0]) >= 10\n        except Exception:\n            warnings.warn(\"Can't determine Windows version %s\" % (ver,))\n            return False\n    else:\n        return True", "is_method": false, "function_description": "Determines if the current operating system supports ANSI escape codes for terminal output. Useful for enabling or disabling colored and formatted console text."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/explain_environment.py", "function": "normpath_with_actual_case", "line_number": 94, "body": "def normpath_with_actual_case(name):\n    \"\"\"In Windows return the path with the case it is stored in the filesystem\"\"\"\n    # copied from thonny.common to make this script independent\n    assert os.path.isabs(name) or os.path.ismount(name), \"Not abs nor mount: \" + name\n    assert os.path.exists(name), \"Not exists: \" + name\n\n    if os.name == \"nt\":\n        # https://stackoverflow.com/questions/2113822/python-getting-filename-case-as-stored-in-windows/2114975\n        name = os.path.normpath(name)\n\n        from ctypes import create_unicode_buffer, windll\n\n        buf = create_unicode_buffer(512)\n        # GetLongPathNameW alone doesn't fix filename part\n        windll.kernel32.GetShortPathNameW(name, buf, 512)  # @UndefinedVariable\n        windll.kernel32.GetLongPathNameW(buf.value, buf, 512)  # @UndefinedVariable\n        result = buf.value\n\n        if result.casefold() != name.casefold():\n            # Sometimes GetShortPathNameW + GetLongPathNameW doesn't work\n            # see eg. https://github.com/thonny/thonny/issues/925\n            windll.kernel32.GetLongPathNameW(name, buf, 512)  # @UndefinedVariable\n            result = buf.value\n\n            if result.casefold() != name.casefold():\n                result = name\n\n        if result[1] == \":\":\n            # ensure drive letter is capital\n            return result[0].upper() + result[1:]\n        else:\n            return result\n    else:\n        # easy on Linux\n        # too difficult on mac\n        # https://stackoverflow.com/questions/14515073/in-python-on-osx-with-hfs-how-can-i-get-the-correct-case-of-an-existing-filenam\n        # Hopefully only correct case comes into Thonny (eg. via open dialog)\n        return os.path.normpath(name)", "is_method": false, "function_description": "Retrieves the canonical, actual case of a filesystem path. On Windows, it specifically corrects the path's case to match how it's stored on disk."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/__init__.py", "function": "_open_system_shell", "line_number": 13, "body": "def _open_system_shell():\n    \"\"\"Main task is to modify path and open terminal window.\n    Bonus (and most difficult) part is executing a script in this window\n    for recommending commands for running given python and related pip\"\"\"\n\n    cwd = get_workbench().get_local_cwd()\n\n    proxy = get_runner().get_backend_proxy()\n    if proxy and proxy.has_custom_system_shell():\n        proxy.open_custom_system_shell()\n        return\n    if proxy and proxy.get_local_executable():\n        target_executable = proxy.get_local_executable()\n    else:\n        target_executable = sys.executable\n\n    exe_dirs = get_exe_dirs()\n    if hasattr(proxy, \"get_exe_dirs\") and proxy.get_exe_dirs():\n        # use both backend and frontend exe dirs\n        exe_dirs = proxy.get_exe_dirs() + exe_dirs\n\n    env_overrides = get_environment_overrides_for_python_subprocess(target_executable)\n    env_overrides[\"PATH\"] = get_augmented_system_path(exe_dirs)\n\n    explainer = os.path.join(os.path.dirname(__file__), \"explain_environment.py\")\n    cmd = [target_executable, explainer]\n\n    activate = os.path.join(\n        os.path.dirname(target_executable),\n        \"activate.bat\" if platform.system() == \"Windows\" else \"activate\",\n    )\n\n    if os.path.isfile(activate):\n        del env_overrides[\"PATH\"]\n        if platform.system() == \"Windows\":\n            cmd = [activate, \"&\"] + cmd\n        else:\n            cmd = [\"source\", activate, \";\"] + cmd\n\n    return terminal.run_in_terminal(cmd, cwd, env_overrides, True)", "is_method": false, "function_description": "Opens a new system terminal with an augmented environment, including path modifications and virtual environment activation. It runs an explanatory script to suggest Python/pip commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/system_shell/__init__.py", "function": "load_plugin", "line_number": 55, "body": "def load_plugin() -> None:\n    get_workbench().add_command(\n        \"OpenSystemShell\",\n        \"tools\",\n        tr(\"Open system shell...\"),\n        _open_system_shell,\n        group=80,\n        image=\"terminal\",\n    )", "is_method": false, "function_description": "This function registers an \"Open System Shell\" command with the application's workbench. It provides users with a direct tool to access the system's command line interface."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/mypy/__init__.py", "function": "load_plugin", "line_number": 112, "body": "def load_plugin():\n    add_program_analyzer(MyPyAnalyzer)\n    get_workbench().set_default(\"assistance.use_mypy\", True)", "is_method": false, "function_description": "The function registers MyPy as a program analyzer, enabling its use as a default assistance feature within the application's workbench. This provides static type checking capabilities."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/mypy/__init__.py", "function": "is_enabled", "line_number": 16, "body": "def is_enabled(self):\n        return get_workbench().get_option(\"assistance.use_mypy\")", "is_method": true, "class_name": "MyPyAnalyzer", "function_description": "Determines if the MyPy analysis assistance feature is currently enabled based on the workbench configuration. This service allows other functions to conditionally activate MyPy-related operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/mypy/__init__.py", "function": "start_analysis", "line_number": 19, "body": "def start_analysis(self, main_file_path, imported_file_paths: Iterable[str]) -> None:\n\n        self.interesting_files = [main_file_path] + list(imported_file_paths)\n\n        args = [\n            get_interpreter_for_subprocess(),\n            \"-m\",\n            \"mypy\",\n            \"--ignore-missing-imports\",\n            \"--check-untyped-defs\",\n            \"--warn-redundant-casts\",\n            \"--warn-unused-ignores\",\n            \"--show-column-numbers\",\n            main_file_path,\n        ] + list(imported_file_paths)\n\n        # TODO: ignore \"... need type annotation\" messages\n\n        from mypy.version import __version__\n\n        try:\n            ver = tuple(map(int, __version__.split(\".\")))\n        except Exception:\n            ver = (0, 470)  # minimum required version\n\n        if ver >= (0, 520):\n            args.insert(3, \"--no-implicit-optional\")\n\n        if ver >= (0, 590):\n            args.insert(3, \"--python-executable\")\n            args.insert(4, get_runner().get_local_executable())\n\n        if ver >= (0, 730):\n            args.insert(3, \"--warn-unreachable\")\n            args.insert(3, \"--allow-redefinition\")\n            args.insert(3, \"--strict-equality\")\n            args.insert(3, \"--no-color-output\")\n            args.insert(3, \"--no-error-summary\")\n\n        env = os.environ.copy()\n        env[\"MYPYPATH\"] = os.path.join(os.path.dirname(__file__), \"typeshed_extras\")\n\n        self._proc = ui_utils.popen_with_ui_thread_callback(\n            args,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            universal_newlines=True,\n            env=env,\n            on_completion=self._parse_and_output_warnings,\n            # Specify a cwd which is not ancestor of user files.\n            # This gives absolute filenames in the output.\n            # Note that mypy doesn't accept when cwd is sys.prefix\n            # or dirname(sys.executable)\n            cwd=os.path.dirname(__file__),\n        )", "is_method": true, "class_name": "MyPyAnalyzer", "function_description": "Initiates a static type analysis for specified Python files using MyPy. It configures and runs MyPy as a subprocess, applying specific flags and custom type stubs."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/plugins/mypy/__init__.py", "function": "_parse_and_output_warnings", "line_number": 75, "body": "def _parse_and_output_warnings(self, pylint_proc, out_lines, err_lines):\n        if err_lines:\n            logger.warning(\"MyPy: \" + \"\".join(err_lines))\n\n        warnings = []\n        for line in out_lines:\n            m = re.match(r\"(.*?):(\\d+)(:(\\d+))?:(.*?):(.*)\", line.strip())\n            if m is not None:\n                message = m.group(6).strip()\n                if message == \"invalid syntax\":\n                    continue  # user will see this as Python error\n\n                filename = m.group(1)\n                if filename not in self.interesting_files:\n                    logger.warning(\"MyPy: \" + line)\n                    continue\n\n                atts = {\n                    \"filename\": filename,\n                    \"lineno\": int(m.group(2)),\n                    \"kind\": m.group(5).strip(),  # always \"error\" ?\n                    \"msg\": message,\n                    \"group\": \"warnings\",\n                }\n                if m.group(3):\n                    # https://github.com/thonny/thonny/issues/598\n                    atts[\"col_offset\"] = max(int(m.group(4)) - 1, 0)\n\n                # TODO: add better categorization and explanation\n                atts[\"symbol\"] = \"mypy-\" + atts[\"kind\"]\n                warnings.append(atts)\n            else:\n                logging.error(\"Can't parse MyPy line: \" + line.strip())\n\n        self.completion_handler(self, warnings)", "is_method": true, "class_name": "MyPyAnalyzer", "function_description": "Parses raw static analysis (MyPy) output into a structured list of warnings. It filters irrelevant messages and dispatches the formatted warnings to a completion handler for further processing or display."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/test/plugins/test_locals_marker.py", "function": "test_regular_closed", "line_number": 17, "body": "def test_regular_closed():\n\n    expected_local = {(\"5.4\", \"5.12\"), (\"6.10\", \"6.18\"), (\"6.21\", \"6.29\")}\n\n    text_widget = tkinter.Text()\n    text_widget.insert(\"end\", TEST_STR1)\n\n    highlighter = LocalsHighlighter(text_widget)\n\n    actual_local = highlighter.get_positions()\n\n    assert actual_local == expected_local\n    print(\"Passed.\")", "is_method": false, "function_description": "This function is a unit test that verifies the `LocalsHighlighter` class's ability to correctly identify and return specific text positions. It ensures the `get_positions` method works as expected for a 'regular closed' highlighting scenario."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/test/plugins/test_name_highlighter.py", "function": "test_all", "line_number": 81, "body": "def test_all():\n    if sys.version_info >= (3, 8):\n        warnings.warn(\"Skipping name matcher tests in Python above 3.7\")\n        return\n\n    import jedi\n\n    if (\n        jedi.__version__.startswith(\"0.13.\")\n        or jedi.__version__.startswith(\"0.14.\")\n        or jedi.__version__.startswith(\"0.15.\")\n        or jedi.__version__.startswith(\"0.16.\")\n    ):\n        warnings.warn(\"Skipping name matcher tests for Jedi \" + jedi.__version__)\n        return\n\n    for i, test in enumerate(TEST_GROUPS):\n        print(\"Running test group %d: \" % (i + 1))\n        _assert_returns_correct_indices(test[0], test[1], test[2])", "is_method": false, "function_description": "This function executes a suite of name matcher tests. It conditionally skips these tests based on the Python version (skips 3.8+) or specific incompatible Jedi library versions, ensuring stable test execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/thonny/test/plugins/test_name_highlighter.py", "function": "_assert_returns_correct_indices", "line_number": 102, "body": "def _assert_returns_correct_indices(insert_pos_groups, expected_indices, input_str):\n    text_widget = tkinter.Text()\n    text_widget.insert(\"end\", input_str)\n\n    nh = VariablesHighlighter(text_widget)\n    for i, group in enumerate(insert_pos_groups):\n        for insert_pos in group:\n            text_widget.mark_set(\"insert\", insert_pos)\n\n            actual = nh.get_positions()\n            expected = expected_indices[i]\n\n            assert actual == expected, (\n                \"\\nInsert position: %s\"\n                \"\\nExpected: %s\"\n                \"\\nGot: %s\" % (insert_pos, expected, actual)\n            )\n        print(\"\\rPassed %d of %d\" % (i + 1, len(insert_pos_groups)), end=\"\")\n    print()", "is_method": false, "function_description": "This internal helper function asserts that a `VariablesHighlighter` instance accurately retrieves expected indices from a Tkinter text widget at various insert positions for testing purposes."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp_paste_mode.py", "function": "forward_until", "line_number": 13, "body": "def forward_until(marker):\n    total = b\"\"\n    while not total.endswith(marker):\n        b = s.read(1)\n        total += b\n        print(b.decode(\"UTF-8\"), end=\"\")", "is_method": false, "function_description": "Reads and prints bytes from an assumed external stream, continuing until a specified `marker` byte sequence is found. This advances the stream's read position up to and including the marker."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/blocks_katse.py", "function": "down", "line_number": 7, "body": "def down(e):\n    pos[0] = e.x\n    pos[1] = e.y", "is_method": false, "function_description": "This function captures the X and Y coordinates from an event object. It stores these coordinates to mark an initial position, commonly for mouse interactions like clicks or drags."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/blocks_katse.py", "function": "drag", "line_number": 12, "body": "def drag(e):\n    dx = e.x - pos[0]\n    dy = e.y - pos[1]\n    c.move(\"pop\", dx, dy)\n    pos[0] = e.x\n    pos[1] = e.y", "is_method": false, "function_description": "This function enables a graphical item to be dragged on a canvas. It moves the specified item by the calculated mouse displacement, allowing for interactive repositioning."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/sockatse.py", "function": "become_client", "line_number": 7, "body": "def become_client():\n    s = socket.create_connection((\"localhost\", port), 0.1)", "is_method": false, "function_description": "Establishes a client connection to a local server. This function enables the program to interact with a service running on the same machine."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/sockatse.py", "function": "become_server", "line_number": 11, "body": "def become_server():\n    serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    serversocket.bind((\"localhost\", port))\n    serversocket.listen(5)\n    while True:\n        (clientsocket, address) = serversocket.accept()\n        print(\"got connection:\", clientsocket, address)", "is_method": false, "function_description": "This function initializes a network server, binding it to a local port. It then continuously listens for and accepts incoming client connections, providing a persistent communication endpoint."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "stdout_write_bytes", "line_number": 82, "body": "def stdout_write_bytes(b):\n    b = b.replace(b\"\\x04\", b\"\")\n    stdout.write(b)\n    stdout.flush()", "is_method": false, "function_description": "Writes a byte string to standard output. It first removes any End-of-Transmission (\\\\x04) characters before flushing the stream."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "execfile", "line_number": 469, "body": "def execfile(filename, device=\"/dev/ttyACM0\", baudrate=115200, user=\"micro\", password=\"python\"):\n    pyb = Pyboard(device, baudrate, user, password)\n    pyb.enter_raw_repl()\n    output = pyb.execfile(filename)\n    stdout_write_bytes(output)\n    pyb.exit_raw_repl()\n    pyb.close()", "is_method": false, "function_description": "This function connects to a MicroPython board and executes a Python script from a given file on it. It automates script deployment and execution on embedded devices, capturing the output."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "filesystem_command", "line_number": 478, "body": "def filesystem_command(pyb, args):\n    def fname_remote(src):\n        if src.startswith(\":\"):\n            src = src[1:]\n        return src\n\n    def fname_cp_dest(src, dest):\n        src = src.rsplit(\"/\", 1)[-1]\n        if dest is None or dest == \"\":\n            dest = src\n        elif dest == \".\":\n            dest = \"./\" + src\n        elif dest.endswith(\"/\"):\n            dest += src\n        return dest\n\n    cmd = args[0]\n    args = args[1:]\n    try:\n        if cmd == \"cp\":\n            srcs = args[:-1]\n            dest = args[-1]\n            if srcs[0].startswith(\"./\") or dest.startswith(\":\"):\n                op = pyb.fs_put\n                fmt = \"cp %s :%s\"\n                dest = fname_remote(dest)\n            else:\n                op = pyb.fs_get\n                fmt = \"cp :%s %s\"\n            for src in srcs:\n                src = fname_remote(src)\n                dest2 = fname_cp_dest(src, dest)\n                print(fmt % (src, dest2))\n                op(src, dest2)\n        else:\n            op = {\n                \"ls\": pyb.fs_ls,\n                \"cat\": pyb.fs_cat,\n                \"mkdir\": pyb.fs_mkdir,\n                \"rmdir\": pyb.fs_rmdir,\n                \"rm\": pyb.fs_rm,\n            }[cmd]\n            if cmd == \"ls\" and not args:\n                args = [\"\"]\n            for src in args:\n                src = fname_remote(src)\n                print(\"%s :%s\" % (cmd, src))\n                op(src)\n    except PyboardError as er:\n        print(str(er.args[2], \"ascii\"))\n        pyb.exit_raw_repl()\n        pyb.close()\n        sys.exit(1)", "is_method": false, "function_description": "This function provides a command-line interface to perform common file system operations like copy, list, cat, mkdir, and remove on a remote Pyboard device. It acts as a utility for remote file management."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "main", "line_number": 561, "body": "def main():\n    import argparse\n\n    cmd_parser = argparse.ArgumentParser(description=\"Run scripts on the pyboard.\")\n    cmd_parser.add_argument(\n        \"-d\",\n        \"--device\",\n        default=os.environ.get(\"PYBOARD_DEVICE\", \"/dev/ttyACM0\"),\n        help=\"the serial device or the IP address of the pyboard\",\n    )\n    cmd_parser.add_argument(\n        \"-b\",\n        \"--baudrate\",\n        default=os.environ.get(\"PYBOARD_BAUDRATE\", \"115200\"),\n        help=\"the baud rate of the serial device\",\n    )\n    cmd_parser.add_argument(\"-u\", \"--user\", default=\"micro\", help=\"the telnet login username\")\n    cmd_parser.add_argument(\"-p\", \"--password\", default=\"python\", help=\"the telnet login password\")\n    cmd_parser.add_argument(\"-c\", \"--command\", help=\"program passed in as string\")\n    cmd_parser.add_argument(\n        \"-w\",\n        \"--wait\",\n        default=0,\n        type=int,\n        help=\"seconds to wait for USB connected board to become available\",\n    )\n    group = cmd_parser.add_mutually_exclusive_group()\n    group.add_argument(\n        \"--follow\",\n        action=\"store_true\",\n        help=\"follow the output after running the scripts [default if no scripts given]\",\n    )\n    group.add_argument(\n        \"--no-follow\",\n        action=\"store_true\",\n        help=\"Do not follow the output after running the scripts.\",\n    )\n    cmd_parser.add_argument(\n        \"-f\", \"--filesystem\", action=\"store_true\", help=\"perform a filesystem action\"\n    )\n    cmd_parser.add_argument(\"files\", nargs=\"*\", help=\"input files\")\n    args = cmd_parser.parse_args()\n\n    # open the connection to the pyboard\n    try:\n        pyb = Pyboard(args.device, args.baudrate, args.user, args.password, args.wait)\n    except PyboardError as er:\n        print(er)\n        sys.exit(1)\n\n    # run any command or file(s)\n    if args.command is not None or args.filesystem or len(args.files):\n        # we must enter raw-REPL mode to execute commands\n        # this will do a soft-reset of the board\n        try:\n            pyb.enter_raw_repl()\n        except PyboardError as er:\n            print(er)\n            pyb.close()\n            sys.exit(1)\n\n        def execbuffer(buf):\n            try:\n                if args.no_follow:\n                    pyb.exec_raw_no_follow(buf)\n                    ret_err = None\n                else:\n                    ret, ret_err = pyb.exec_raw(\n                        buf, timeout=None, data_consumer=stdout_write_bytes\n                    )\n            except PyboardError as er:\n                print(er)\n                pyb.close()\n                sys.exit(1)\n            except KeyboardInterrupt:\n                sys.exit(1)\n            if ret_err:\n                pyb.exit_raw_repl()\n                pyb.close()\n                stdout_write_bytes(ret_err)\n                sys.exit(1)\n\n        # do filesystem commands, if given\n        if args.filesystem:\n            filesystem_command(pyb, args.files)\n            del args.files[:]\n\n        # run the command, if given\n        if args.command is not None:\n            execbuffer(args.command.encode(\"utf-8\"))\n\n        # run any files\n        for filename in args.files:\n            with open(filename, \"rb\") as f:\n                pyfile = f.read()\n                if filename.endswith(\".mpy\") and pyfile[0] == ord(\"M\"):\n                    pyb.exec_(\"_injected_buf=\" + repr(pyfile))\n                    pyfile = _injected_import_hook_code\n                execbuffer(pyfile)\n\n        # exiting raw-REPL just drops to friendly-REPL mode\n        pyb.exit_raw_repl()\n\n    # if asked explicitly, or no files given, then follow the output\n    if args.follow or (args.command is None and not args.filesystem and len(args.files) == 0):\n        try:\n            ret, ret_err = pyb.follow(timeout=None, data_consumer=stdout_write_bytes)\n        except PyboardError as er:\n            print(er)\n            sys.exit(1)\n        except KeyboardInterrupt:\n            sys.exit(1)\n        if ret_err:\n            pyb.close()\n            stdout_write_bytes(ret_err)\n            sys.exit(1)\n\n    # close the connection to the pyboard\n    pyb.close()", "is_method": false, "function_description": "This `main` function serves as a command-line interface for interacting with a Pyboard. It enables users to connect to the device, execute scripts or commands, and perform filesystem operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "__del__", "line_number": 118, "body": "def __del__(self):\n        self.close()", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Ensures the TelnetToSerial connection is properly closed when the object is deleted. This prevents resource leaks by releasing underlying connections."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "close", "line_number": 121, "body": "def close(self):\n        if self.tn:\n            self.tn.close()", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Closes the active Telnet connection associated with this Telnet-to-Serial bridge instance, releasing network resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "read", "line_number": 125, "body": "def read(self, size=1):\n        while len(self.fifo) < size:\n            timeout_count = 0\n            data = self.tn.read_eager()\n            if len(data):\n                self.fifo.extend(data)\n                timeout_count = 0\n            else:\n                time.sleep(0.25)\n                if self.read_timeout is not None and timeout_count > 4 * self.read_timeout:\n                    break\n                timeout_count += 1\n\n        data = b\"\"\n        while len(data) < size and len(self.fifo) > 0:\n            data += bytes([self.fifo.popleft()])\n        return data", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Mimics a serial port's read operation over a Telnet connection. It retrieves a specified number of bytes, buffering incoming data until the request is fulfilled or a timeout occurs."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "write", "line_number": 143, "body": "def write(self, data):\n        self.tn.write(data)\n        return len(data)", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Writes raw data bytes directly to the Telnet connection managed by the `TelnetToSerial` instance. It provides the capability to send output to the connected Telnet client."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "inWaiting", "line_number": 147, "body": "def inWaiting(self):\n        n_waiting = len(self.fifo)\n        if not n_waiting:\n            data = self.tn.read_eager()\n            self.fifo.extend(data)\n            return len(data)\n        else:\n            return n_waiting", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Returns the number of bytes available for reading from the Telnet-to-serial bridge. It checks the internal buffer and eagerly fetches new data if needed."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "close", "line_number": 186, "body": "def close(self):\n        import signal\n\n        os.killpg(os.getpgid(self.subp.pid), signal.SIGTERM)", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Shuts down the external process and its group managed by the `ProcessToSerial` instance. It sends a termination signal for a clean exit."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "read", "line_number": 191, "body": "def read(self, size=1):\n        data = b\"\"\n        while len(data) < size:\n            data += self.subp.stdout.read(size - len(data))\n        return data", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Reads a specific number of bytes from the standard output of an attached subprocess. It ensures the full requested byte count is returned."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "write", "line_number": 197, "body": "def write(self, data):\n        self.subp.stdin.write(data)\n        return len(data)", "is_method": true, "class_name": "ProcessToSerial", "function_description": "A method of `ProcessToSerial` that sends data to the standard input of its managed subprocess."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "inWaiting", "line_number": 201, "body": "def inWaiting(self):\n        # res = self.sel.select(0)\n        res = self.poll.poll(0)\n        if res:\n            return 1\n        return 0", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Reports whether data is immediately available for reading from the underlying communication channel without blocking. It returns 1 if data is present, otherwise 0."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "close", "line_number": 239, "body": "def close(self):\n        import signal\n\n        os.killpg(os.getpgid(self.subp.pid), signal.SIGTERM)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Gracefully terminates the managed pseudo-terminal subprocess. It sends a termination signal to its process group to ensure a clean shutdown."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "read", "line_number": 244, "body": "def read(self, size=1):\n        return self.ser.read(size)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Retrieves a specified number of bytes from the pseudo-terminal's output stream. It provides raw data from the managed process, facilitating its display or consumption."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "write", "line_number": 247, "body": "def write(self, data):\n        return self.ser.write(data)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Forwards raw data from the pseudo-terminal to the connected terminal's output stream. It acts as a direct conduit for sending terminal display content."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "inWaiting", "line_number": 250, "body": "def inWaiting(self):\n        return self.ser.inWaiting()", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Reports the number of bytes currently buffered and available for reading from the communication channel connected to the pseudo-terminal. This allows checking for incoming data without blocking."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "close", "line_number": 287, "body": "def close(self):\n        self.serial.close()", "is_method": true, "class_name": "Pyboard", "function_description": "Disconnects the Pyboard by closing its underlying serial communication link, terminating the connection for further operations."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "read_until", "line_number": 290, "body": "def read_until(self, min_num_bytes, ending, timeout=10, data_consumer=None):\n        # if data_consumer is used then data is not accumulated and the ending must be 1 byte long\n        assert data_consumer is None or len(ending) == 1\n\n        data = self.serial.read(min_num_bytes)\n        if data_consumer:\n            data_consumer(data)\n        timeout_count = 0\n        while True:\n            if data.endswith(ending):\n                break\n            elif self.serial.inWaiting() > 0:\n                new_data = self.serial.read(1)\n                if data_consumer:\n                    data_consumer(new_data)\n                    data = new_data\n                else:\n                    data = data + new_data\n                timeout_count = 0\n            else:\n                timeout_count += 1\n                if timeout is not None and timeout_count >= 100 * timeout:\n                    break\n                time.sleep(0.01)\n        return data", "is_method": true, "class_name": "Pyboard", "function_description": "This method reads data from the Pyboard's serial connection until a specified ending byte sequence is found or a timeout occurs. It can optionally process incoming data via a consumer without accumulating it."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "enter_raw_repl", "line_number": 316, "body": "def enter_raw_repl(self):\n        self.serial.write(b\"\\r\\x03\\x03\")  # ctrl-C twice: interrupt any running program\n\n        # flush input (without relying on serial.flushInput())\n        n = self.serial.inWaiting()\n        while n > 0:\n            self.serial.read(n)\n            n = self.serial.inWaiting()\n\n        self.serial.write(b\"\\r\\x01\")  # ctrl-A: enter raw REPL\n        data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n>\")\n        if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n>\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")\n\n        self.serial.write(b\"\\x04\")  # ctrl-D: soft reset\n        data = self.read_until(1, b\"soft reboot\\r\\n\")\n        if not data.endswith(b\"soft reboot\\r\\n\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")\n        # By splitting this into 2 reads, it allows boot.py to print stuff,\n        # which will show up after the soft reboot and before the raw REPL.\n        data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n\")\n        if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")", "is_method": true, "class_name": "Pyboard", "function_description": "Provides the service of switching the connected Pyboard into its raw REPL mode. This enables direct, programmatic command execution by interrupting current activity and performing a soft reset."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "exit_raw_repl", "line_number": 343, "body": "def exit_raw_repl(self):\n        self.serial.write(b\"\\r\\x02\")", "is_method": true, "class_name": "Pyboard", "function_description": "Sends the command to exit raw REPL mode on the connected Pyboard. This transitions the device back to its normal interactive prompt."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "follow", "line_number": 346, "body": "def follow(self, timeout, data_consumer=None):\n        # wait for normal output\n        data = self.read_until(1, b\"\\x04\", timeout=timeout, data_consumer=data_consumer)\n        if not data.endswith(b\"\\x04\"):\n            raise PyboardError(\"timeout waiting for first EOF reception\")\n        data = data[:-1]\n\n        # wait for error output\n        data_err = self.read_until(1, b\"\\x04\", timeout=timeout)\n        if not data_err.endswith(b\"\\x04\"):\n            raise PyboardError(\"timeout waiting for second EOF reception\")\n        data_err = data_err[:-1]\n\n        # return normal and error output\n        return data, data_err", "is_method": true, "class_name": "Pyboard", "function_description": "Captures standard and error output streams from the Pyboard by reading until specific end-of-transmission markers. It provides the complete result of an executed operation."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "exec_raw_no_follow", "line_number": 362, "body": "def exec_raw_no_follow(self, command):\n        if isinstance(command, bytes):\n            command_bytes = command\n        else:\n            command_bytes = bytes(command, encoding=\"utf8\")\n\n        # check we have a prompt\n        data = self.read_until(1, b\">\")\n        if not data.endswith(b\">\"):\n            raise PyboardError(\"could not enter raw repl\")\n\n        # write command\n        for i in range(0, len(command_bytes), 256):\n            self.serial.write(command_bytes[i : min(i + 256, len(command_bytes))])\n            time.sleep(0.01)\n        self.serial.write(b\"\\x04\")\n\n        # check if we could exec command\n        data = self.serial.read(2)\n        if data != b\"OK\":\n            raise PyboardError(\"could not exec command (response: %r)\" % data)", "is_method": true, "class_name": "Pyboard", "function_description": "Sends a raw MicroPython command to the Pyboard for execution, verifying its acceptance without reading the command's output."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "exec_raw", "line_number": 384, "body": "def exec_raw(self, command, timeout=10, data_consumer=None):\n        self.exec_raw_no_follow(command)\n        return self.follow(timeout, data_consumer)", "is_method": true, "class_name": "Pyboard", "function_description": "Executes a raw command on the Pyboard, then waits for and retrieves its output. This enables sending commands and receiving their results from the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "eval", "line_number": 388, "body": "def eval(self, expression):\n        ret = self.exec_(\"print({})\".format(expression))\n        ret = ret.strip()\n        return ret", "is_method": true, "class_name": "Pyboard", "function_description": "Remotely evaluates a given Python expression on the Pyboard device. It returns the string representation of the expression's result."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "exec_", "line_number": 393, "body": "def exec_(self, command, data_consumer=None):\n        ret, ret_err = self.exec_raw(command, data_consumer=data_consumer)\n        if ret_err:\n            raise PyboardError(\"exception\", ret, ret_err)\n        return ret", "is_method": true, "class_name": "Pyboard", "function_description": "Executes a command on the connected Pyboard device. It returns the command's output or raises a PyboardError if an exception occurs during execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "execfile", "line_number": 399, "body": "def execfile(self, filename):\n        with open(filename, \"rb\") as f:\n            pyfile = f.read()\n        return self.exec_(pyfile)", "is_method": true, "class_name": "Pyboard", "function_description": "Executes a local Python script on the connected Pyboard device. It reads the file content and sends it to the board for remote execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "get_time", "line_number": 404, "body": "def get_time(self):\n        t = str(self.eval(\"pyb.RTC().datetime()\"), encoding=\"utf8\")[1:-1].split(\", \")\n        return int(t[4]) * 3600 + int(t[5]) * 60 + int(t[6])", "is_method": true, "class_name": "Pyboard", "function_description": "Retrieves the current time from the Pyboard's Real-Time Clock. It returns the time as the total number of seconds elapsed since midnight."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_ls", "line_number": 408, "body": "def fs_ls(self, src):\n        cmd = (\n            \"import uos\\nfor f in uos.ilistdir(%s):\\n\"\n            \" print('{:12} {}{}'.format(f[3]if len(f)>3 else 0,f[0],'/'if f[1]&0x4000 else ''))\"\n            % ((\"'%s'\" % src) if src else \"\")\n        )\n        self.exec_(cmd, data_consumer=stdout_write_bytes)", "is_method": true, "class_name": "Pyboard", "function_description": "Lists files and directories on the connected Pyboard's file system, showing sizes and identifying directories. It enables remote file system inspection and management."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_cat", "line_number": 416, "body": "def fs_cat(self, src, chunk_size=256):\n        cmd = (\n            \"with open('%s') as f:\\n while 1:\\n\"\n            \"  b=f.read(%u)\\n  if not b:break\\n  print(b,end='')\" % (src, chunk_size)\n        )\n        self.exec_(cmd, data_consumer=stdout_write_bytes)", "is_method": true, "class_name": "Pyboard", "function_description": "This method reads a file from the Pyboard's filesystem. It provides a utility to retrieve and display the content of remote files on the device, similar to the `cat` command."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_get", "line_number": 423, "body": "def fs_get(self, src, dest, chunk_size=256):\n        self.exec_(\"f=open('%s','rb')\\nr=f.read\" % src)\n        with open(dest, \"wb\") as f:\n            while True:\n                data = bytearray()\n                self.exec_(\"print(r(%u))\" % chunk_size, data_consumer=lambda d: data.extend(d))\n                assert data.endswith(b\"\\r\\n\\x04\")\n                try:\n                    data = ast.literal_eval(str(data[:-3], \"ascii\"))\n                    if not isinstance(data, bytes):\n                        raise ValueError(\"Not bytes\")\n                except (UnicodeError, ValueError) as e:\n                    raise PyboardError(\"fs_get: Could not interpret received data: %s\" % str(e))\n                if not data:\n                    break\n                f.write(data)\n        self.exec_(\"f.close()\")", "is_method": true, "class_name": "Pyboard", "function_description": "Downloads a specified file from the connected Pyboard device to the local filesystem, enabling remote file retrieval."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_put", "line_number": 441, "body": "def fs_put(self, src, dest, chunk_size=256):\n        self.exec_(\"f=open('%s','wb')\\nw=f.write\" % dest)\n        with open(src, \"rb\") as f:\n            while True:\n                data = f.read(chunk_size)\n                if not data:\n                    break\n                if sys.version_info < (3,):\n                    self.exec_(\"w(b\" + repr(data) + \")\")\n                else:\n                    self.exec_(\"w(\" + repr(data) + \")\")\n        self.exec_(\"f.close()\")", "is_method": true, "class_name": "Pyboard", "function_description": "Transfers a local file to the connected Pyboard's filesystem. It streams the file content in chunks, writing it directly to the specified destination on the Pyboard."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_mkdir", "line_number": 454, "body": "def fs_mkdir(self, dir):\n        self.exec_(\"import uos\\nuos.mkdir('%s')\" % dir)", "is_method": true, "class_name": "Pyboard", "function_description": "Creates a new directory on the connected Pyboard's filesystem. It provides a way to remotely organize files and directories on the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_rmdir", "line_number": 457, "body": "def fs_rmdir(self, dir):\n        self.exec_(\"import uos\\nuos.rmdir('%s')\" % dir)", "is_method": true, "class_name": "Pyboard", "function_description": "As part of the Pyboard class, this method remotely removes a specified directory from the connected Pyboard device's file system."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fs_rm", "line_number": 460, "body": "def fs_rm(self, src):\n        self.exec_(\"import uos\\nuos.remove('%s')\" % src)", "is_method": true, "class_name": "Pyboard", "function_description": "Provides the capability to remotely delete a specified file from the Pyboard's filesystem."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fname_remote", "line_number": 479, "body": "def fname_remote(src):\n        if src.startswith(\":\"):\n            src = src[1:]\n        return src", "is_method": false, "function_description": "Normalizes a string by removing an optional leading colon. It prepares source identifiers for consistent processing."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "fname_cp_dest", "line_number": 484, "body": "def fname_cp_dest(src, dest):\n        src = src.rsplit(\"/\", 1)[-1]\n        if dest is None or dest == \"\":\n            dest = src\n        elif dest == \".\":\n            dest = \"./\" + src\n        elif dest.endswith(\"/\"):\n            dest += src\n        return dest", "is_method": false, "function_description": "This function determines the effective destination path for a file copy operation. It intelligently handles various target specifications, including renaming or placing the file within a specified directory."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/pyboard.py", "function": "execbuffer", "line_number": 622, "body": "def execbuffer(buf):\n            try:\n                if args.no_follow:\n                    pyb.exec_raw_no_follow(buf)\n                    ret_err = None\n                else:\n                    ret, ret_err = pyb.exec_raw(\n                        buf, timeout=None, data_consumer=stdout_write_bytes\n                    )\n            except PyboardError as er:\n                print(er)\n                pyb.close()\n                sys.exit(1)\n            except KeyboardInterrupt:\n                sys.exit(1)\n            if ret_err:\n                pyb.exit_raw_repl()\n                pyb.close()\n                stdout_write_bytes(ret_err)\n                sys.exit(1)", "is_method": false, "function_description": "Executes a buffer of code on a connected Pyboard (MicroPython device). It handles execution, redirects output, and manages errors to ensure robust remote code execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/docukatse.py", "function": "reet_role", "line_number": 18, "body": "def reet_role(role, rawtext, text, lineno, inliner, options={}, content=[]):\n    \"\"\"\"\"\"\n    # Once nested inline markup is implemented, this and other methods should\n    # recursively call inliner.nested_parse().\n    options[\"classes\"] = \"reet\"\n    return [nodes.inline(rawtext, docutils.utils.unescape(text), **options)], []", "is_method": false, "function_description": "Processes a custom reStructuredText inline role, wrapping the provided text in an inline node with the \"reet\" class. This enables specific styling or semantic tagging within generated documents."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/iterf.py", "function": "print_ast", "line_number": 13, "body": "def print_ast(node, level):\n    print(\" \" * level, node)\n    for name, child in ast.iter_fields(node):\n        if isinstance(child, ast.AST):\n            print(\" \" * level, name, \":\")\n            print_ast(child, level + 1)\n        elif isinstance(child, list):\n            print(\" \" * level, name, \":[\")\n            for elem in child:\n                print_ast(elem, level + 1)\n            print(\" \" * level, \"]\")\n        else:\n            pass", "is_method": false, "function_description": "This function recursively prints the hierarchical structure of a Python Abstract Syntax Tree (AST) node and its children. It visualizes the tree using indentation to show nesting levels."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/thre.py", "function": "inter", "line_number": 8, "body": "def inter():\n    print(\"interwait\")\n    sleep(1)\n    print(\"interrupting\")\n    #interrupt_main()\n    os.kill(os.getpid(), signal.SIGINT)\n    #os.raise_signal(signal.SIGINT)\n    print(\"interrupted\")", "is_method": false, "function_description": "Triggers a programmatic interruption of the running Python script. It sends an interrupt signal to its own process after a delay, simulating a Ctrl+C input."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/widget_wraps.py", "function": "string_width", "line_number": 9, "body": "def string_width(s):\n    temp_label = ttk.Label(root, text=s)\n    result = temp_label.winfo_reqwidth()\n    temp_label.destroy()\n    return result", "is_method": false, "function_description": "Calculates the rendering width of a given string in pixels, as it would appear in a Tkinter `ttk.Label`. This service enables dynamic UI layout and sizing based on text content."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/widget_wraps.py", "function": "publish", "line_number": 17, "body": "def publish(event):\n    global prev_width\n    global updating\n    \n    if updating:\n        return\n    \n    updating= True\n    \n    try:\n        available = root.winfo_width()\n        \n        if available < 10 or prev_width == available:\n            return\n        \n        \n        for child in root.winfo_children():\n            for grchild in child.winfo_children():\n                grchild.destroy()\n            child.destroy()\n        \n        line = tk.Frame(root, background=\"white\")\n        line.grid(row=0, column=0, sticky=\"nsew\")\n        used = 0\n        linecount = 1\n        colcount = 0\n        for i, part in enumerate(path.split(\"\\\\\")):\n            if i > 0:\n                label = ttk.Label(line, text=\"\\\\\")\n                label.grid(row=linecount, column=colcount, sticky=\"w\")\n                used += label.winfo_reqwidth()\n                colcount += 1\n                \n            \n            if used + string_width(part) > available:\n                print(\"new line\"\n                      #, line.winfo_reqwidth(), label.winfo_reqwidth(), available\n                      )\n                used = 0 \n                colcount = 0\n                line = tk.Frame(root, background=\"red\")\n                line.grid(row=linecount, column=0, sticky=\"nsew\")\n                linecount += 1\n                \n            label = ttk.Label(line, text=part)\n            \n            print(i, part, linecount, colcount)\n            label.grid(row=linecount, column=colcount, sticky=\"w\")\n            used += label.winfo_reqwidth()\n            colcount += 1\n        \n        #root.columnconfigure(1, weight=1)\n        root.update()\n        prev_width = root.winfo_width()\n    finally:\n        updating = False", "is_method": false, "function_description": "Responds to window width changes by redrawing a file path. It wraps path components onto new lines to fit the available space, ensuring a legible display."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/trace_katse.py", "function": "trace", "line_number": 4, "body": "def trace(frame, event, arg):\n    if \"trace_katse\" in frame.f_code.co_filename:\n        print(frame, event, sys.exc_info())\n    return trace", "is_method": false, "function_description": "This function serves as a custom system trace hook. It logs execution frames, events, and exception details specifically for code running in files whose names contain 'trace_katse'."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp_thread_exp.py", "function": "forward_until", "line_number": 13, "body": "def forward_until(marker, must_include=None):\n    total = b\"\"\n    while not total.endswith(marker):\n        b = s.read(1)\n        total += b\n        print(b.decode(\"UTF-8\"), end=\"\")\n\n    if must_include and must_include not in total:\n        raise RuntimeError(\"Did not find expected data in the output (%s)\"\n                           % (total + s.read_all()))", "is_method": false, "function_description": "Reads bytes from a stream until a specific marker is found, accumulating the data. It can optionally validate that required content was included before the marker."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp_thread_exp.py", "function": "run_in_paste_mode", "line_number": 25, "body": "def run_in_paste_mode(source):\n    # goto paste mode\n    s.write(PASTE_MODE_CMD)\n    forward_until(b\"=== \")\n\n    while source:\n        block = source[:BLOCK_SIZE]\n        s.write(block)\n        s.flush()\n        forward_until(block.replace(b\"\\r\", b\"\\r=== \"))\n        source = source[BLOCK_SIZE:]\n\n    s.write(EOT)\n    forward_until(b\">>> \")", "is_method": false, "function_description": "Transmits source data to a remote system using a 'paste mode' protocol. It chunks data and synchronizes the transfer for reliable multi-line input."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/punktid.py", "function": "arvuta", "line_number": 28, "body": "def arvuta(punktid):\n    momo()\n\n    def fafa(n):\n        pass\n\n    fafa(0)\n    kokku = len(punktid)\n    kaugused_ja_vastavad_punktid = {}\n    m = 0\n    n = 0\n    for punkt in punktid:\n        for i in range(len(punktid)):\n            n += 1\n            esim_punkti_nr = str(punktid.index(punkt) + 1)\n            teise_punkti_nr = str(i + 1)\n            # fafa(n)\n            if punktid.index(punkt) == i:\n                continue\n            firstx = punkt[0]\n            firsty = punkt[1]\n            secondx = punktid[i][0]\n            secondy = punktid[i][1]\n            kaugus = sqrt((secondx - firstx) ** 2 + (secondy - firsty) ** 2)\n            kaugused_ja_vastavad_punktid[kaugus] = esim_punkti_nr, \"ja\", teise_punkti_nr\n    v\u00e4him = min(kaugused_ja_vastavad_punktid)\n    v\u00e4hima_paari_nimi = kaugused_ja_vastavad_punktid[v\u00e4him]\n    return v\u00e4hima_paari_nimi", "is_method": false, "function_description": "Identifies the pair of input points with the minimum Euclidean distance between them. It returns the 1-based indices of these two closest points."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/fullscreen.py", "function": "toggle_fullscreen", "line_number": 23, "body": "def toggle_fullscreen(self, event=None):\n        self.state = not self.state  # Just toggling the boolean\n        self.tk.attributes(\"-fullscreen\", self.state)\n        return \"break\"", "is_method": true, "class_name": "Fullscreen_Window", "function_description": "The `Fullscreen_Window` method toggles the display mode of the window between fullscreen and normal, based on its current state. It provides a simple way to switch the window's presentation."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/fullscreen.py", "function": "end_fullscreen", "line_number": 28, "body": "def end_fullscreen(self, event=None):\n        self.state = False\n        self.tk.attributes(\"-fullscreen\", False)\n        return \"break\"", "is_method": true, "class_name": "Fullscreen_Window", "function_description": "Disables fullscreen mode for the window, updating its internal state. This method allows the application to transition back to a normal window view."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/kbd.py", "function": "check", "line_number": 9, "body": "def check(event):\n    print(\n        \"keycode:\",\n        event.keycode,\n        \"state:\",\n        event.state,\n        \"char:\",\n        repr(event.char),\n        \"keysym\",\n        event.keysym,\n        \"keysym_num\",\n        event.keysym_num,\n    )", "is_method": false, "function_description": "This function prints various attributes of an input event, such as keycode, state, and character, for diagnostic purposes. It helps in inspecting event data for debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp_repl_experiment.py", "function": "forward_until", "line_number": 39, "body": "def forward_until(marker, must_include=None):\n    total = b\"\"\n    while not total.endswith(marker):\n        b = s.read(1)\n        total += b\n        print(b.decode(\"UTF-8\"), end=\"\")\n\n    if must_include and must_include not in total:\n        raise RuntimeError(\"Did not find expected data in the output (%s)\"\n                           % (total + s.read_all()))", "is_method": false, "function_description": "This function reads from an input stream, accumulating data and printing it, until a specific `marker` byte sequence is encountered. It can also validate that a `must_include` sequence is present in the read data.\nThis function reads from an input stream, accumulating data and printing it, until a specific `marker` byte sequence is encountered. It can also validate that a `must_include` sequence is present in the read data."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp_repl_experiment.py", "function": "prepare", "line_number": 50, "body": "def prepare():\n    print(\"Interrupting...\")\n    s.write(b\"\\x03\")\n    s.write(b\"\\x03\")\n    print(\"Cleaning...\", s.read_all())\n    s.write(b\"\\x02\")\n    s.read_until(b\">>> \")\n    print(\"Got normal prompt\")", "is_method": false, "function_description": "Prepares an interactive interpreter connected via serial by sending interrupts and commands to clear its state. It ensures the interpreter reaches a normal prompt, providing a clean environment for further interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp_repl_experiment.py", "function": "start_raw_mode", "line_number": 60, "body": "def start_raw_mode():\n    s.write(b\"\\x01\")\n    forward_until(b\"exit\\r\\n>\")\n    print(\"Got raw prompt. Executing code...\")", "is_method": false, "function_description": "This function initiates a \"raw mode\" on a connected device or system. It waits for a specific prompt, signaling readiness for direct command execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp_repl_experiment.py", "function": "run_in_raw_mode", "line_number": 66, "body": "def run_in_raw_mode():\n    data = code.encode(\"UTF-8\")\n    while data:\n        s.write(data[:BLOCK_SIZE])\n        s.flush()\n        data = data[BLOCK_SIZE:]\n        if data:\n            time.sleep(0.01)\n\n    s.write(b\"\\x04\")\n    forward_until(b\"OK\")\n    # wait until completion\n    expected_output = (str(LENGTH_OF_STRING_LITERAL) + \" {'*'}\").encode(\"UTF-8\")\n    forward_until(b\">\", must_include=expected_output)", "is_method": false, "function_description": "Transmits encoded code in chunks over a connection to be executed remotely. It manages data flow and waits for specific responses to confirm successful execution."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp_repl_experiment.py", "function": "run_in_paste_mode", "line_number": 81, "body": "def run_in_paste_mode():\n    # goto paste mode\n    s.write(b\"\\x05\")\n    forward_until(b\"=== \")\n\n    for line in code.splitlines(keepends=True):\n        data = line.encode(\"UTF-8\").replace(b\"\\n\", b\"\\r\\n\")\n        while data:\n            block = data[:BLOCK_SIZE]\n            s.write(block)\n            s.flush()\n\n            forward_until(block)\n            #time.sleep(0.01)\n            data = data[BLOCK_SIZE:]\n\n    s.write(b\"\\x04\")\n    expected_output = (str(LENGTH_OF_STRING_LITERAL) + \" {'*'}\").encode(\"UTF-8\")\n    forward_until(b\">>> \", must_include=expected_output)", "is_method": false, "function_description": "This function sends a block of multi-line Python code to an external interpreter over a serial connection. It automates entering code into a remote device using a \"paste mode\" protocol."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/katse.py", "function": "doit", "line_number": 16, "body": "def doit(event):\n    print(event.state)", "is_method": false, "function_description": "Logs or displays the current `state` attribute of an incoming event object."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/can.py", "function": "on_move", "line_number": 15, "body": "def on_move(event):\n    if active_id is not None:\n        canvas.move(active_id, event.x, event.y)\n        print(\"Move\", event.x, event.y)", "is_method": false, "function_description": "This function serves as an event handler, updating the position of an actively selected graphical item on a canvas. It moves the item to the new coordinates provided by a motion event."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/can.py", "function": "on_click", "line_number": 21, "body": "def on_click(event):\n    stack = canvas.find_overlapping(event.x, event.y, event.x, event.y)\n    print(stack)\n    canvas.tag_raise(stack[-1])\n    global active_id\n    active_id = stack[-1]", "is_method": false, "function_description": "Provides interactive selection and layering control for canvas elements. It identifies and raises the topmost overlapping item clicked, setting it as the currently active item."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/log_utils/log_utils.py", "function": "parse_log_file", "line_number": 9, "body": "def parse_log_file(filename):\n    f = open(filename, encoding=\"UTF-8\")\n    events = []\n    for line in f:\n        events.append(parse_log_line(line))\n\n    f.close()\n    return events", "is_method": false, "function_description": "Reads a log file and parses each line into individual event objects. It provides a structured list of all events found within the log file."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/log_utils/log_utils.py", "function": "parse_log_line", "line_number": 19, "body": "def parse_log_line(line):\n    split_pos = line.rfind(\" at \")\n    assert split_pos > 0\n    left = line[0:split_pos]\n    right = line[split_pos + 4 :].strip()\n\n    tree = ast.parse(left, mode=\"eval\")\n    assert isinstance(tree, ast.Expression)\n    assert isinstance(tree.body, ast.Call)\n\n    attributes = {\n        \"event_kind\": tree.body.func.id,\n        \"event_time\": strptime(right, \"%Y-%m-%dT%H:%M:%S.%f\"),\n    }\n\n    for kw in tree.body.keywords:\n        attributes[kw.arg] = ast.literal_eval(kw.value)\n\n    return attributes", "is_method": false, "function_description": "Converts a specific log line format into a structured dictionary. It extracts event kind, timestamp, and associated attributes for programmatic access and analysis."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/log_utils/log_utils.py", "function": "get_log_file_time", "line_number": 40, "body": "def get_log_file_time(filename):\n    \"\"\"\n    Go from  2014-10-30_10-16-08\n    to       2014-10-30T10:16:08\n    \"\"\"\n\n    chars = list(filename[:19])\n    try:\n        assert chars[10] == \"_\" and chars[13] == \"-\" and chars[16] == \"-\"\n    except Exception:\n        print(filename)\n    chars[10] = \"T\"\n    chars[13] = \":\"\n    chars[16] = \":\"\n    return \"\".join(chars)", "is_method": false, "function_description": "Converts a timestamp string found in a filename from a log-specific format (YYYY-MM-DD_HH-MM-SS) to an ISO-like format (YYYY-MM-DDTHH:MM:SS), useful for timestamp standardization."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "stdout_write_bytes", "line_number": 82, "body": "def stdout_write_bytes(b):\n    b = b.replace(b\"\\x04\", b\"\")\n    stdout.write(b)\n    stdout.flush()", "is_method": false, "function_description": "Provides a service to write byte strings to standard output. It ensures immediate display and removes the End-of-Transmission character, useful for controlled binary data output."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "execfile", "line_number": 524, "body": "def execfile(filename, device=\"/dev/ttyACM0\", baudrate=115200, user=\"micro\", password=\"python\"):\n    pyb = Pyboard(device, baudrate, user, password)\n    pyb.enter_raw_repl()\n    output = pyb.execfile(filename)\n    stdout_write_bytes(output)\n    pyb.exit_raw_repl()\n    pyb.close()", "is_method": false, "function_description": "Executes a local Python script directly on a connected MicroPython board. It handles the communication, execution, and output retrieval from the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "filesystem_command", "line_number": 533, "body": "def filesystem_command(pyb, args):\n    def fname_remote(src):\n        if src.startswith(\":\"):\n            src = src[1:]\n        return src\n\n    def fname_cp_dest(src, dest):\n        src = src.rsplit(\"/\", 1)[-1]\n        if dest is None or dest == \"\":\n            dest = src\n        elif dest == \".\":\n            dest = \"./\" + src\n        elif dest.endswith(\"/\"):\n            dest += src\n        return dest\n\n    cmd = args[0]\n    args = args[1:]\n    try:\n        if cmd == \"cp\":\n            srcs = args[:-1]\n            dest = args[-1]\n            if srcs[0].startswith(\"./\") or dest.startswith(\":\"):\n                op = pyb.fs_put\n                fmt = \"cp %s :%s\"\n                dest = fname_remote(dest)\n            else:\n                op = pyb.fs_get\n                fmt = \"cp :%s %s\"\n            for src in srcs:\n                src = fname_remote(src)\n                dest2 = fname_cp_dest(src, dest)\n                print(fmt % (src, dest2))\n                op(src, dest2)\n        else:\n            op = {\n                \"ls\": pyb.fs_ls,\n                \"cat\": pyb.fs_cat,\n                \"mkdir\": pyb.fs_mkdir,\n                \"rmdir\": pyb.fs_rmdir,\n                \"rm\": pyb.fs_rm,\n            }[cmd]\n            if cmd == \"ls\" and not args:\n                args = [\"\"]\n            for src in args:\n                src = fname_remote(src)\n                print(\"%s :%s\" % (cmd, src))\n                op(src)\n    except PyboardError as er:\n        print(str(er.args[2], \"ascii\"))\n        pyb.exit_raw_repl()\n        pyb.close()\n        sys.exit(1)", "is_method": false, "function_description": "Provides a command-line interface to perform common filesystem operations (copy, list, view, create, remove) on a remote Pyboard device. It translates user commands into calls to the Pyboard's filesystem methods."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "main", "line_number": 616, "body": "def main():\n    import argparse\n\n    cmd_parser = argparse.ArgumentParser(description=\"Run scripts on the pyboard.\")\n    cmd_parser.add_argument(\n        \"-d\",\n        \"--device\",\n        default=os.environ.get(\"PYBOARD_DEVICE\", \"/dev/ttyACM0\"),\n        help=\"the serial device or the IP address of the pyboard\",\n    )\n    cmd_parser.add_argument(\n        \"-b\",\n        \"--baudrate\",\n        default=os.environ.get(\"PYBOARD_BAUDRATE\", \"115200\"),\n        help=\"the baud rate of the serial device\",\n    )\n    cmd_parser.add_argument(\"-u\", \"--user\", default=\"micro\", help=\"the telnet login username\")\n    cmd_parser.add_argument(\"-p\", \"--password\", default=\"python\", help=\"the telnet login password\")\n    cmd_parser.add_argument(\"-c\", \"--command\", help=\"program passed in as string\")\n    cmd_parser.add_argument(\n        \"-w\",\n        \"--wait\",\n        default=0,\n        type=int,\n        help=\"seconds to wait for USB connected board to become available\",\n    )\n    group = cmd_parser.add_mutually_exclusive_group()\n    group.add_argument(\n        \"--follow\",\n        action=\"store_true\",\n        help=\"follow the output after running the scripts [default if no scripts given]\",\n    )\n    group.add_argument(\n        \"--no-follow\",\n        action=\"store_true\",\n        help=\"Do not follow the output after running the scripts.\",\n    )\n    cmd_parser.add_argument(\n        \"-f\",\n        \"--filesystem\",\n        action=\"store_true\",\n        help=\"perform a filesystem action: \"\n        \"cp local :device | cp :device local | cat path | ls [path] | rm path | mkdir path | rmdir path\",\n    )\n    cmd_parser.add_argument(\"files\", nargs=\"*\", help=\"input files\")\n    args = cmd_parser.parse_args()\n\n    # open the connection to the pyboard\n    try:\n        pyb = Pyboard(args.device, args.baudrate, args.user, args.password, args.wait)\n    except PyboardError as er:\n        print(er)\n        sys.exit(1)\n\n    # run any command or file(s)\n    if args.command is not None or args.filesystem or len(args.files):\n        # we must enter raw-REPL mode to execute commands\n        # this will do a soft-reset of the board\n        try:\n            pyb.enter_raw_repl()\n        except PyboardError as er:\n            print(er)\n            pyb.close()\n            sys.exit(1)\n\n        def execbuffer(buf):\n            try:\n                if args.no_follow:\n                    pyb.exec_raw_no_follow(buf)\n                    ret_err = None\n                else:\n                    ret, ret_err = pyb.exec_raw(\n                        buf, timeout=None, data_consumer=stdout_write_bytes\n                    )\n            except PyboardError as er:\n                print(er)\n                pyb.close()\n                sys.exit(1)\n            except KeyboardInterrupt:\n                sys.exit(1)\n            if ret_err:\n                pyb.exit_raw_repl()\n                pyb.close()\n                stdout_write_bytes(ret_err)\n                sys.exit(1)\n\n        # do filesystem commands, if given\n        if args.filesystem:\n            filesystem_command(pyb, args.files)\n            del args.files[:]\n\n        # run the command, if given\n        if args.command is not None:\n            execbuffer(args.command.encode(\"utf-8\"))\n\n        # run any files\n        for filename in args.files:\n            with open(filename, \"rb\") as f:\n                pyfile = f.read()\n                if filename.endswith(\".mpy\") and pyfile[0] == ord(\"M\"):\n                    pyb.exec_(\"_injected_buf=\" + repr(pyfile))\n                    pyfile = _injected_import_hook_code\n                execbuffer(pyfile)\n\n        # exiting raw-REPL just drops to friendly-REPL mode\n        pyb.exit_raw_repl()\n\n    # if asked explicitly, or no files given, then follow the output\n    if args.follow or (args.command is None and not args.filesystem and len(args.files) == 0):\n        try:\n            ret, ret_err = pyb.follow(timeout=None, data_consumer=stdout_write_bytes)\n        except PyboardError as er:\n            print(er)\n            sys.exit(1)\n        except KeyboardInterrupt:\n            sys.exit(1)\n        if ret_err:\n            pyb.close()\n            stdout_write_bytes(ret_err)\n            sys.exit(1)\n\n    # close the connection to the pyboard\n    pyb.close()", "is_method": false, "function_description": "Initializes and manages a command-line interface for interacting with a MicroPython pyboard. It allows users to connect, run scripts/commands, and perform filesystem operations on the device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "__del__", "line_number": 118, "body": "def __del__(self):\n        self.close()", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Ensures proper cleanup and resource release, such as closing connections, when a TelnetToSerial object is destroyed."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "close", "line_number": 121, "body": "def close(self):\n        if self.tn:\n            self.tn.close()", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Closes the active Telnet connection managed by the TelnetToSerial instance, releasing associated resources."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "read", "line_number": 125, "body": "def read(self, size=1):\n        while len(self.fifo) < size:\n            timeout_count = 0\n            data = self.tn.read_eager()\n            if len(data):\n                self.fifo.extend(data)\n                timeout_count = 0\n            else:\n                time.sleep(0.25)\n                if self.read_timeout is not None and timeout_count > 4 * self.read_timeout:\n                    break\n                timeout_count += 1\n\n        data = b\"\"\n        while len(data) < size and len(self.fifo) > 0:\n            data += bytes([self.fifo.popleft()])\n        return data", "is_method": true, "class_name": "TelnetToSerial", "function_description": "This method reads a specified number of bytes from the Telnet connection, buffering incoming data. It provides a serial port-like read interface for the Telnet stream."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "write", "line_number": 143, "body": "def write(self, data):\n        self.tn.write(data)\n        return len(data)", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Sends data through the Telnet connection, effectively forwarding it to the bridged serial device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "inWaiting", "line_number": 147, "body": "def inWaiting(self):\n        n_waiting = len(self.fifo)\n        if not n_waiting:\n            data = self.tn.read_eager()\n            self.fifo.extend(data)\n            return len(data)\n        else:\n            return n_waiting", "is_method": true, "class_name": "TelnetToSerial", "function_description": "Reports the number of bytes currently available in the receive buffer of the Telnet-to-Serial connection, fetching new data if the buffer is empty."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "close", "line_number": 186, "body": "def close(self):\n        import signal\n\n        os.killpg(os.getpgid(self.subp.pid), signal.SIGTERM)", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Terminates the subprocess associated with this instance by sending a SIGTERM signal to its process group, ensuring graceful shutdown."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "read", "line_number": 191, "body": "def read(self, size=1):\n        data = b\"\"\n        while len(data) < size:\n            data += self.subp.stdout.read(size - len(data))\n        return data", "is_method": true, "class_name": "ProcessToSerial", "function_description": "This method reads a specified number of bytes from the subprocess's standard output. It ensures the full requested amount is reliably retrieved before returning the binary data."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "write", "line_number": 197, "body": "def write(self, data):\n        self.subp.stdin.write(data)\n        return len(data)", "is_method": true, "class_name": "ProcessToSerial", "function_description": "This method writes data directly to the standard input of the encapsulated subprocess, enabling the calling code to provide runtime input to the process."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "inWaiting", "line_number": 201, "body": "def inWaiting(self):\n        # res = self.sel.select(0)\n        res = self.poll.poll(0)\n        if res:\n            return 1\n        return 0", "is_method": true, "class_name": "ProcessToSerial", "function_description": "Checks if data is available for immediate reading from the serial process without blocking. It returns 1 if data is waiting, otherwise 0."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "close", "line_number": 239, "body": "def close(self):\n        import signal\n\n        os.killpg(os.getpgid(self.subp.pid), signal.SIGTERM)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Terminates the pseudo-terminal's subprocess and its entire process group. It sends a SIGTERM signal to ensure a clean shutdown."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "read", "line_number": 244, "body": "def read(self, size=1):\n        return self.ser.read(size)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Retrieves data from the connected pseudo-terminal, allowing the terminal to read output from the process."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "write", "line_number": 247, "body": "def write(self, data):\n        return self.ser.write(data)", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Writes incoming data from the pseudo-terminal directly to the connected physical or virtual terminal's output."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "inWaiting", "line_number": 250, "body": "def inWaiting(self):\n        return self.ser.inWaiting()", "is_method": true, "class_name": "ProcessPtyToTerminal", "function_description": "Returns the number of bytes currently in the input buffer of the underlying serial or pseudo-terminal connection, indicating available data to be read."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "close", "line_number": 288, "body": "def close(self):\n        self.serial.close()", "is_method": true, "class_name": "Pyboard", "function_description": "Terminates the serial connection to the Pyboard device. This releases the communication port, making it available for other processes."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "read_until", "line_number": 291, "body": "def read_until(self, min_num_bytes, ending, timeout=10, data_consumer=None):\n        # if data_consumer is used then data is not accumulated and the ending must be 1 byte long\n        assert data_consumer is None or len(ending) == 1\n\n        data = self.serial.read(min_num_bytes)\n        if data_consumer:\n            data_consumer(data)\n        timeout_count = 0\n        while True:\n            if data.endswith(ending):\n                break\n            elif self.serial.inWaiting() > 0:\n                new_data = self.serial.read(1)\n                if data_consumer:\n                    data_consumer(new_data)\n                    data = new_data\n                else:\n                    data = data + new_data\n                timeout_count = 0\n            else:\n                timeout_count += 1\n                if timeout is not None and timeout_count >= 100 * timeout:\n                    break\n                time.sleep(0.01)\n        return data", "is_method": true, "class_name": "Pyboard", "function_description": "This Pyboard method reads data from the serial connection until a specified ending byte sequence is found or a timeout occurs, enabling robust command-response communication."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "enter_raw_repl", "line_number": 317, "body": "def enter_raw_repl(self):\n        self.serial.write(b\"\\r\\x03\\x03\")  # ctrl-C twice: interrupt any running program\n\n        # flush input (without relying on serial.flushInput())\n        n = self.serial.inWaiting()\n        while n > 0:\n            self.serial.read(n)\n            n = self.serial.inWaiting()\n\n        self.serial.write(b\"\\r\\x01\")  # ctrl-A: enter raw REPL\n        data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n>\")\n        if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n>\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")\n\n        self.serial.write(b\"\\x04\")  # ctrl-D: soft reset\n        data = self.read_until(1, b\"soft reboot\\r\\n\")\n        if not data.endswith(b\"soft reboot\\r\\n\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")\n        # By splitting this into 2 reads, it allows boot.py to print stuff,\n        # which will show up after the soft reboot and before the raw REPL.\n        data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n\")\n        if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")", "is_method": true, "class_name": "Pyboard", "function_description": "Enables programmatic control over the Pyboard by safely entering the raw REPL mode. This prepares the device for automated command execution and data transfer."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "exit_raw_repl", "line_number": 344, "body": "def exit_raw_repl(self):\n        self.serial.write(b\"\\r\\x02\")", "is_method": true, "class_name": "Pyboard", "function_description": "This method programmatically exits the MicroPython raw REPL mode on the connected Pyboard. It allows the host application to regain control or switch back to standard REPL interaction."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "follow", "line_number": 347, "body": "def follow(self, timeout, data_consumer=None):\n        # wait for normal output\n        data = self.read_until(1, b\"\\x04\", timeout=timeout, data_consumer=data_consumer)\n        if not data.endswith(b\"\\x04\"):\n            raise PyboardError(\"timeout waiting for first EOF reception\")\n        data = data[:-1]\n\n        # wait for error output\n        data_err = self.read_until(1, b\"\\x04\", timeout=timeout)\n        if not data_err.endswith(b\"\\x04\"):\n            raise PyboardError(\"timeout waiting for second EOF reception\")\n        data_err = data_err[:-1]\n\n        # return normal and error output\n        return data, data_err", "is_method": true, "class_name": "Pyboard", "function_description": "The `follow` method reads and separates standard and error output from the Pyboard. It waits for specific end-of-transmission markers, providing a complete record of executed commands."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "raw_paste_write", "line_number": 363, "body": "def raw_paste_write(self, command_bytes):\n        # Read initial header, with window size.\n        data = self.serial.read(2)\n        window_size = data[0] | data[1] << 8\n        window_remain = window_size\n\n        # Write out the command_bytes data.\n        i = 0\n        while i < len(command_bytes):\n            while window_remain == 0 or self.serial.inWaiting():\n                data = self.serial.read(1)\n                if data == b\"\\x01\":\n                    # Device indicated that a new window of data can be sent.\n                    window_remain += window_size\n                elif data == b\"\\x04\":\n                    # Device indicated abrupt end.  Acknowledge it and finish.\n                    self.serial.write(b\"\\x04\")\n                    return\n                else:\n                    # Unexpected data from device.\n                    raise PyboardError(\"unexpected read during raw paste: {}\".format(data))\n            # Send out as much data as possible that fits within the allowed window.\n            b = command_bytes[i : min(i + window_remain, len(command_bytes))]\n            self.serial.write(b)\n            window_remain -= len(b)\n            i += len(b)\n\n        # Indicate end of data.\n        self.serial.write(b\"\\x04\")\n\n        # Wait for device to acknowledge end of data.\n        data = self.read_until(1, b\"\\x04\")\n        if not data.endswith(b\"\\x04\"):\n            raise PyboardError(\"could not complete raw paste: {}\".format(data))", "is_method": true, "class_name": "Pyboard", "function_description": "Provides a reliable mechanism to send a sequence of bytes (e.g., code) to the Pyboard. It uses a flow-controlled \"raw paste\" protocol for efficient and error-checked transmission."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "exec_raw_no_follow", "line_number": 398, "body": "def exec_raw_no_follow(self, command):\n        if isinstance(command, bytes):\n            command_bytes = command\n        else:\n            command_bytes = bytes(command, encoding=\"utf8\")\n\n        # check we have a prompt\n        data = self.read_until(1, b\">\")\n        if not data.endswith(b\">\"):\n            raise PyboardError(\"could not enter raw repl\")\n\n        if self.use_raw_paste:\n            # Try to enter raw-paste mode.\n            self.serial.write(b\"\\x05A\\x01\")\n            data = self.serial.read(2)\n            if data == b\"R\\x00\":\n                # Device understood raw-paste command but doesn't support it.\n                pass\n            elif data == b\"R\\x01\":\n                # Device supports raw-paste mode, write out the command using this mode.\n                return self.raw_paste_write(command_bytes)\n            else:\n                # Device doesn't support raw-paste, fall back to normal raw REPL.\n                data = self.read_until(1, b\"w REPL; CTRL-B to exit\\r\\n>\")\n                if not data.endswith(b\"w REPL; CTRL-B to exit\\r\\n>\"):\n                    print(data)\n                    raise PyboardError(\"could not enter raw repl\")\n            # Don't try to use raw-paste mode again for this connection.\n            self.use_raw_paste = False\n\n        # Write command using standard raw REPL, 256 bytes every 10ms.\n        for i in range(0, len(command_bytes), 256):\n            self.serial.write(command_bytes[i : min(i + 256, len(command_bytes))])\n            time.sleep(0.01)\n        self.serial.write(b\"\\x04\")\n\n        # check if we could exec command\n        data = self.serial.read(2)\n        if data != b\"OK\":\n            raise PyboardError(\"could not exec command (response: %r)\" % data)", "is_method": true, "class_name": "Pyboard", "function_description": "Executes a command on the Pyboard device in raw REPL mode. It sends the command and confirms its execution initiation, but does not read the command's output."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "exec_raw", "line_number": 439, "body": "def exec_raw(self, command, timeout=10, data_consumer=None):\n        self.exec_raw_no_follow(command)\n        return self.follow(timeout, data_consumer)", "is_method": true, "class_name": "Pyboard", "function_description": "Provides the capability to execute a raw command on the Pyboard and then retrieve all its subsequent output."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "eval", "line_number": 443, "body": "def eval(self, expression):\n        ret = self.exec_(\"print({})\".format(expression))\n        ret = ret.strip()\n        return ret", "is_method": true, "class_name": "Pyboard", "function_description": "Enables evaluating a Python expression on the connected Pyboard device. It returns the string representation of the expression's result, useful for remote value retrieval or debugging."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "exec_", "line_number": 448, "body": "def exec_(self, command, data_consumer=None):\n        ret, ret_err = self.exec_raw(command, data_consumer=data_consumer)\n        if ret_err:\n            raise PyboardError(\"exception\", ret, ret_err)\n        return ret", "is_method": true, "class_name": "Pyboard", "function_description": "Executes a command on the Pyboard device, robustly handling remote errors by raising a `PyboardError` upon an exception."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "execfile", "line_number": 454, "body": "def execfile(self, filename):\n        with open(filename, \"rb\") as f:\n            pyfile = f.read()\n        return self.exec_(pyfile)", "is_method": true, "class_name": "Pyboard", "function_description": "Executes a Python script from a given file directly on the connected Pyboard device."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "get_time", "line_number": 459, "body": "def get_time(self):\n        t = str(self.eval(\"pyb.RTC().datetime()\"), encoding=\"utf8\")[1:-1].split(\", \")\n        return int(t[4]) * 3600 + int(t[5]) * 60 + int(t[6])", "is_method": true, "class_name": "Pyboard", "function_description": "Retrieves the current time from the Pyboard's Real-Time Clock (RTC). It returns the time of day in seconds from midnight."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_ls", "line_number": 463, "body": "def fs_ls(self, src):\n        cmd = (\n            \"import uos\\nfor f in uos.ilistdir(%s):\\n\"\n            \" print('{:12} {}{}'.format(f[3]if len(f)>3 else 0,f[0],'/'if f[1]&0x4000 else ''))\"\n            % ((\"'%s'\" % src) if src else \"\")\n        )\n        self.exec_(cmd, data_consumer=stdout_write_bytes)", "is_method": true, "class_name": "Pyboard", "function_description": "Lists the contents of a specified directory on the Pyboard's filesystem. It displays file/directory names, sizes, and identifies directories, acting as a remote `ls` command."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_cat", "line_number": 471, "body": "def fs_cat(self, src, chunk_size=256):\n        cmd = (\n            \"with open('%s') as f:\\n while 1:\\n\"\n            \"  b=f.read(%u)\\n  if not b:break\\n  print(b,end='')\" % (src, chunk_size)\n        )\n        self.exec_(cmd, data_consumer=stdout_write_bytes)", "is_method": true, "class_name": "Pyboard", "function_description": "Reads the content of a specified file from the Pyboard's filesystem. It then prints this content to the host system's standard output."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_get", "line_number": 478, "body": "def fs_get(self, src, dest, chunk_size=256):\n        self.exec_(\"f=open('%s','rb')\\nr=f.read\" % src)\n        with open(dest, \"wb\") as f:\n            while True:\n                data = bytearray()\n                self.exec_(\"print(r(%u))\" % chunk_size, data_consumer=lambda d: data.extend(d))\n                assert data.endswith(b\"\\r\\n\\x04\")\n                try:\n                    data = ast.literal_eval(str(data[:-3], \"ascii\"))\n                    if not isinstance(data, bytes):\n                        raise ValueError(\"Not bytes\")\n                except (UnicodeError, ValueError) as e:\n                    raise PyboardError(\"fs_get: Could not interpret received data: %s\" % str(e))\n                if not data:\n                    break\n                f.write(data)\n        self.exec_(\"f.close()\")", "is_method": true, "class_name": "Pyboard", "function_description": "Downloads a file from the connected Pyboard device's filesystem to a specified path on the local machine."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_put", "line_number": 496, "body": "def fs_put(self, src, dest, chunk_size=256):\n        self.exec_(\"f=open('%s','wb')\\nw=f.write\" % dest)\n        with open(src, \"rb\") as f:\n            while True:\n                data = f.read(chunk_size)\n                if not data:\n                    break\n                if sys.version_info < (3,):\n                    self.exec_(\"w(b\" + repr(data) + \")\")\n                else:\n                    self.exec_(\"w(\" + repr(data) + \")\")\n        self.exec_(\"f.close()\")", "is_method": true, "class_name": "Pyboard", "function_description": "Transfers a file from the local machine to the Pyboard device, streaming data in chunks for efficient upload."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_mkdir", "line_number": 509, "body": "def fs_mkdir(self, dir):\n        self.exec_(\"import uos\\nuos.mkdir('%s')\" % dir)", "is_method": true, "class_name": "Pyboard", "function_description": "Creates a directory on the connected Pyboard device's file system. This method allows remote organization of files and project structures directly on the board."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_rmdir", "line_number": 512, "body": "def fs_rmdir(self, dir):\n        self.exec_(\"import uos\\nuos.rmdir('%s')\" % dir)", "is_method": true, "class_name": "Pyboard", "function_description": "This method removes a specified directory from the connected Pyboard device's filesystem. It provides a remote capability to manage directories on the Pyboard."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fs_rm", "line_number": 515, "body": "def fs_rm(self, src):\n        self.exec_(\"import uos\\nuos.remove('%s')\" % src)", "is_method": true, "class_name": "Pyboard", "function_description": "Removes a specified file from the Pyboard's file system. It executes a MicroPython `uos.remove` command on the connected board."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fname_remote", "line_number": 534, "body": "def fname_remote(src):\n        if src.startswith(\":\"):\n            src = src[1:]\n        return src", "is_method": false, "function_description": "Provides a string normalization service. It removes a leading colon from the input string if present, ensuring a consistent format."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "fname_cp_dest", "line_number": 539, "body": "def fname_cp_dest(src, dest):\n        src = src.rsplit(\"/\", 1)[-1]\n        if dest is None or dest == \"\":\n            dest = src\n        elif dest == \".\":\n            dest = \"./\" + src\n        elif dest.endswith(\"/\"):\n            dest += src\n        return dest", "is_method": false, "function_description": "Determines the final destination file path for a copy operation. It resolves various destination specifications, including directories or implicit current directory copies."}, {"file": "./dataset/RepoExec/test-apps/thonny/misc/mp/pyboard.py", "function": "execbuffer", "line_number": 681, "body": "def execbuffer(buf):\n            try:\n                if args.no_follow:\n                    pyb.exec_raw_no_follow(buf)\n                    ret_err = None\n                else:\n                    ret, ret_err = pyb.exec_raw(\n                        buf, timeout=None, data_consumer=stdout_write_bytes\n                    )\n            except PyboardError as er:\n                print(er)\n                pyb.close()\n                sys.exit(1)\n            except KeyboardInterrupt:\n                sys.exit(1)\n            if ret_err:\n                pyb.exit_raw_repl()\n                pyb.close()\n                stdout_write_bytes(ret_err)\n                sys.exit(1)", "is_method": false, "function_description": "Executes a buffer of commands or code on a Pyboard, handling execution errors and directing output. It provides a way to remotely control the device."}]