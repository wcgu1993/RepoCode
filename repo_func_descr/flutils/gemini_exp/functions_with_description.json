[{"file": "./dataset/RepoExec/test-apps/flutils/docs/conf.py", "function": "setup", "line_number": 258, "body": "def setup(app):\n    app.add_css_file('css/style.css')", "is_method": false, "function_description": "This function configures the application by registering its primary CSS stylesheet. It ensures the application's visual presentation is loaded correctly.\nThis function configures the application by registering its primary CSS stylesheet. It ensures the application's visual presentation is loaded correctly."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/packages.py", "function": "_each_version_part", "line_number": 53, "body": "def _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)", "is_method": false, "function_description": "Generates structured representations of each component within a StrictVersion object. It breaks down the version into major, minor, patch, and integrated prerelease details for granular access."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/packages.py", "function": "_build_version_info", "line_number": 98, "body": "def _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)", "is_method": false, "function_description": "Constructs a structured `_VersionInfo` object from a version string. It parses version components and identifies the pre-release part's position for detailed version handling."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/packages.py", "function": "_build_version_bump_position", "line_number": 112, "body": "def _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position", "is_method": false, "function_description": "Normalizes and validates a given integer position into a fixed non-negative index range. It ensures the position is suitable for targeting specific version components, mapping negative inputs to positive equivalents."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/packages.py", "function": "_build_version_bump_type", "line_number": 130, "body": "def _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )", "is_method": false, "function_description": "This function determines the precise type of version increment, such as major, minor, or pre-release, based on the version part being modified and any specified pre-release identifier."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/packages.py", "function": "bump_version", "line_number": 169, "body": "def bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n        version (str): The version number to be bumped.\n        position (int, optional): The position (starting with zero) of the\n            version number component to be increased.  Defaults to: ``2``\n        pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n            create or increase an alpha version number.  A value of ``b`` or\n            ``beta`` will create or increase a beta version number.\n\n    Raises:\n        ValueError: if the given ``version`` is an invalid version number.\n        ValueError: if the given ``position`` does not exist.\n        ValueError: if the given ``prerelease`` is not in:\n            ``a, alpha, b, beta``\n        ValueError: if trying to 'major' part, of a version number, to\n            a pre-release version.\n\n    :rtype:\n        :obj:`str`\n\n        * The increased version number.\n\n    Examples:\n        >>> from flutils.packages import bump_version\n        >>> bump_version('1.2.2')\n        '1.2.3'\n        >>> bump_version('1.2.3', position=1)\n        '1.3'\n        >>> bump_version('1.3.4', position=0)\n        '2.0'\n        >>> bump_version('1.2.3', prerelease='a')\n        '1.2.4a0'\n        >>> bump_version('1.2.4a0', pre_release='a')\n        '1.2.4a1'\n        >>> bump_version('1.2.4a1', pre_release='b')\n        '1.2.4b0'\n        >>> bump_version('1.2.4a1')\n        '1.2.4'\n        >>> bump_version('1.2.4b0')\n        '1.2.4'\n        >>> bump_version('2.1.3', position=1, pre_release='a')\n        '2.2a0'\n        >>> bump_version('1.2b0', position=2)\n        '1.2.1'\n\n    \"\"\"\n    ver_info = _build_version_info(version)\n    position = _build_version_bump_position(position)\n    bump_type = _build_version_bump_type(position, pre_release)\n    # noinspection PyUnusedLocal\n    hold: List[Union[int, str]] = []\n    if bump_type == _BUMP_VERSION_MAJOR:\n        hold = [ver_info.major.num + 1, 0]\n    elif bump_type in _BUMP_VERSION_MINORS:\n        if bump_type == _BUMP_VERSION_MINOR:\n            if ver_info.minor.pre_txt:\n                hold = [ver_info.major.num, ver_info.minor.num]\n            else:\n                hold = [ver_info.major.num, ver_info.minor.num + 1]\n        else:\n            if bump_type == _BUMP_VERSION_MINOR_ALPHA:\n                if ver_info.minor.pre_txt == 'a':\n                    part = '%sa%s' % (\n                        ver_info.minor.num,\n                        ver_info.minor.pre_num + 1\n                    )\n                else:\n                    part = '{}a0'.format(ver_info.minor.num + 1)\n            else:\n                if ver_info.minor.pre_txt == 'a':\n                    part = '{}b0'.format(ver_info.minor.num)\n                elif ver_info.minor.pre_txt == 'b':\n                    part = '%sb%s' % (\n                        ver_info.minor.num,\n                        ver_info.minor.pre_num + 1\n                    )\n                else:\n                    part = '{}b0'.format(ver_info.minor.num + 1)\n            hold = [ver_info.major.num, part]\n    else:\n        if bump_type == _BUMP_VERSION_PATCH:\n            if ver_info.patch.pre_txt:\n                hold = [\n                    ver_info.major.num,\n                    ver_info.minor.num,\n                    ver_info.patch.num\n                ]\n            else:\n                hold = [\n                    ver_info.major.num,\n                    ver_info.minor.num,\n                    ver_info.patch.num + 1\n                ]\n        else:\n            if bump_type == _BUMP_VERSION_PATCH_ALPHA:\n                if ver_info.patch.pre_txt == 'a':\n                    part = '%sa%s' % (\n                        ver_info.patch.num,\n                        ver_info.patch.pre_num + 1\n                    )\n                else:\n                    part = '{}a0'.format(ver_info.patch.num + 1)\n            else:\n                if ver_info.patch.pre_txt == 'a':\n                    part = '{}b0'.format(ver_info.patch.num)\n\n                elif ver_info.patch.pre_txt == 'b':\n                    part = '%sb%s' % (\n                        ver_info.patch.num,\n                        ver_info.patch.pre_num + 1\n                    )\n                else:\n                    part = '{}b0'.format(ver_info.patch.num + 1)\n            hold = [ver_info.major.num, ver_info.minor.num, part]\n    out = '.'.join(map(str, hold))\n    return out", "is_method": false, "function_description": "Increments a specified component (major, minor, patch, or pre-release) of a version number string. It provides automated version management for software releases."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "has_any_attrs", "line_number": 36, "body": "def has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False", "is_method": false, "function_description": "Determines if an object possesses at least one of the specified attributes. This is useful for checking an object's capabilities or available interface methods."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "has_any_callables", "line_number": 61, "body": "def has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False", "is_method": false, "function_description": "This utility function determines if an object possesses any of the specified attributes that are callable. It provides a way to quickly check for an object's available operations or methods."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "has_attrs", "line_number": 88, "body": "def has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True", "is_method": false, "function_description": "Determines if an object possesses all the specified attributes. This provides a quick way to validate an object's expected properties or interface."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "has_callables", "line_number": 116, "body": "def has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False", "is_method": false, "function_description": "Verifies if an object possesses all specified attributes and if each of them is callable. This is useful for dynamic capability checks."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "is_list_like", "line_number": 146, "body": "def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False", "is_method": false, "function_description": "Determines if an object is iterable and behaves like a list, returning True for sequence-like types such as lists, tuples, or sets. Useful for validating input or adapting processing based on collection type."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "is_subclass_of_any", "line_number": 206, "body": "def is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False", "is_method": false, "function_description": "Checks if the given object's class is a subclass of any of the provided classes. This enables flexible type validation for various inheritance scenarios."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/validators.py", "function": "validate_identifier", "line_number": 15, "body": "def validate_identifier(\n        identifier: Union[str, UserString],\n        allow_underscore: bool = True\n) -> None:\n    \"\"\"Validate the given string is a proper identifier.\n\n    This validator will also raise an error if the given identifier is a\n    keyword or a builtin identifier.\n\n    Args:\n        identifier (:obj:`str` or :obj:`UserString <collections.UserString>`):\n            The value to be tested.\n        allow_underscore (:obj:`bool`, optional): A value of :obj:`False`\n            will raise an error when the ``identifier`` has a value that starts\n            with an underscore ``_``. (Use :obj:`False` when validating\n            potential :obj:`namedtuple <collections.namedtuple>` keys)\n            Defaults to: :obj:`True`.\n\n    Raises:\n        SyntaxError: If the given identifier is invalid.\n        TypeError: If the given identifier is not a :obj:`str` or\n            :obj:`UserString <collections.UserString>`.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.validators import validate_identifier\n        >>> validate_identifier('123')\n        SyntaxError: The given 'identifier', '123', cannot start with a number\n    \"\"\"\n    if isinstance(identifier, UserString):\n        identifier = str(identifier)\n    if not isinstance(identifier, str):\n        raise TypeError(\n            \"The given 'identifier' must be a 'str'.  Got: %r\"\n            % type(identifier).__name__\n        )\n    identifier = identifier.strip()\n    if not identifier:\n        raise SyntaxError(\"The given 'identifier' cannot be empty\")\n\n    if allow_underscore is False and identifier[0:1] == '_':\n        raise SyntaxError(\n            f\"The given 'identifier', {identifier!r}, cannot start with an \"\n            \"underscore '_'\"\n        )\n\n    if identifier[0:1].isdigit():\n        raise SyntaxError(\n            f\"The given 'identifier', {identifier!r}, cannot start with a \"\n            \"number\"\n        )\n\n    if not identifier.isidentifier():\n        raise SyntaxError(\n            f\"The given 'identifier', {identifier!r}, is invalid.\"\n        )\n\n    if keyword.iskeyword(identifier):\n        raise SyntaxError(\n            f\"The given 'identifier', {identifier!r}, cannot be a keyword\"\n        )\n\n    if identifier in _BUILTIN_NAMES:\n        raise SyntaxError(\n            f\"The given 'identifier', {identifier!r}, cannot be a builtin name\"\n        )", "is_method": false, "function_description": "Validates if a given string is a proper identifier, ensuring it adheres to Python naming rules. It checks for valid format and prevents conflicts with keywords or built-in names."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "as_escaped_unicode_literal", "line_number": 13, "body": "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.\u2605 \ud83d\uded1'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out", "is_method": false, "function_description": "Generates a Python-style escaped Unicode hexadecimal literal string from the input text. This provides a precise, unambiguous representation of characters."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "as_escaped_utf8_literal", "line_number": 47, "body": "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.\u2605 \ud83d\uded1'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out", "is_method": false, "function_description": "Generates an escaped UTF-8 hexadecimal string representation of the input text. This utility helps visualize the byte-level content of a string."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "camel_to_underscore", "line_number": 81, "body": "def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()", "is_method": false, "function_description": "Converts a camel-cased string into a snake_case string with words separated by underscores. This utility is valuable for standardizing naming conventions in various contexts."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "convert_escaped_unicode_literal", "line_number": 100, "body": "def convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.\u2605 \ud83d\uded1'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.\u2605 \ud83d\uded1'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')", "is_method": false, "function_description": "Converts escaped Unicode hexadecimal literals (e.g., `\\\\x`, `\\\\u`, `\\\\U`) within a string into their corresponding characters."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "convert_escaped_utf8_literal", "line_number": 157, "body": "def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test\u00a9'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test\u00a9'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text", "is_method": false, "function_description": "Converts strings containing literal escaped UTF-8 hexadecimal sequences (e.g., `\\\\xc2\\\\xa9`) into their corresponding Unicode characters. This is useful for processing raw string inputs from sources like environment variables."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "underscore_to_camel", "line_number": 212, "body": "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out", "is_method": false, "function_description": "This utility function converts a string from underscore_case to camelCase. It allows optional lowercasing of the first character, useful for various naming convention transformations."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/cmdutils.py", "function": "_set_size", "line_number": 39, "body": "def _set_size(\n        fd: int,\n        columns: int = 80,\n        lines: int = 20\n) -> None:\n    \"\"\"Using the passed in file descriptor (of tty), set the terminal\n    size to that of the current terminal size.  If the current\n    terminal size cannot be found the given defaults will be used.\n    \"\"\"\n    # The following was adapted from: https://stackoverflow.com/a/6420070\n    size = struct.pack(\"HHHH\", lines, columns, 0, 0)\n    fcntl.ioctl(fd, termios.TIOCSWINSZ, size)", "is_method": false, "function_description": "Sets the terminal size for a given file descriptor using specified columns and lines. This provides programmatic control over terminal dimensions."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/cmdutils.py", "function": "run", "line_number": 53, "body": "def run(\n        command: Sequence,\n        stdout: Optional[IO] = None,\n        stderr: Optional[IO] = None,\n        columns: int = 80,\n        lines: int = 24,\n        force_dimensions: bool = False,\n        interactive: bool = False,\n        **kwargs: Any\n) -> int:\n    \"\"\"Run the given command line command and return the command's\n    return code.\n\n    When the given ``command`` is executed, the command's stdout and\n    stderr outputs are captured in a pseudo terminal.  The captured\n    outputs are then added to this function's ``stdout`` and ``stderr``\n    IO objects.\n\n    This function will capture any ANSI escape codes in the output of\n    the given command.  This even includes ANSI colors.\n\n    Args:\n        command (str, List[str], Tuple[str]): The command to execute.\n        stdout (:obj:`typing.IO`, optional):  An input/output stream\n            that will hold the command's ``stdout``.  Defaults to:\n            :obj:`sys.stdout <sys.stdout>`; which will output\n            the command's ``stdout`` to the terminal.\n        stderr (:obj:`typing.IO`, optional):  An input/output stream\n            that will hold the command's ``stderr``.  Defaults to:\n            :obj:`sys.stderr <sys.stderr>`; which will output\n            the command's ``stderr`` to the terminal.\n        columns (int, optional): The number of character columns the pseudo\n            terminal may use.  If ``force_dimensions`` is :obj:`False`, this\n            will be the fallback columns value when the the current terminal's\n            column size cannot be found.  If ``force_dimensions`` is\n            :obj:`True`, this will be actual character column value.\n            Defaults to: ``80``.\n        lines (int, optional): The number of character lines the pseudo\n            terminal may use.  If ``force_dimensions`` is :obj:`False`, this\n            will be the fallback lines value when the the current terminal's\n            line size cannot be found.  If ``force_dimensions`` is :obj:`True`,\n            this will be actual character lines value.  Defaults to: ``24``.\n        force_dimensions (bool, optional): This controls how the given\n            ``columns`` and ``lines`` values are to be used.  A value of\n            :obj:`False` will use the given ``columns`` and ``lines`` as\n            fallback values if the current terminal dimensions cannot be\n            successfully queried.  A value of :obj:`True` will resize the\n            pseudo terminal using the given ``columns`` and ``lines`` values.\n            Defaults to: :obj:`False`.\n        interactive (bool, optional): A value of :obj:`True` will\n            interactively run the given ``command``.  Defaults to:\n            :obj:`False`.\n        **kwargs: Any additional key-word-arguments used with\n            :obj:`Popen <subprocess.Popen>`.  ``stdout`` and ``stderr``\n            will not be used if given in ``**default_kwargs``.  Defaults to:\n            ``{}``.\n\n    Returns:\n        int: The return value from running the given ``command``\n\n    Raises:\n        RuntimeError: When using ``interactive=True`` and the ``bash``\n            executable cannot be located.\n        OSError: Any errors raised when trying to read the pseudo terminal.\n\n    Example:\n        An example using :obj:`~flutils.cmdutils.run` in code::\n\n            from flutils.cmdutils import run\n            from io import BytesIO\n            import sys\n            import os\n\n            home = os.path.expanduser('~')\n            with BytesIO() as stream:\n                return_code = run(\n                    'ls \"%s\"' % home,\n                    stdout=stream,\n                    stderr=stream\n                )\n                text = stream.getvalue()\n            text = text.decode(sys.getdefaultencoding())\n            if return_code == 0:\n                print(text)\n            else:\n                print('Error: %s' % text)\n    \"\"\"\n    # Handle bytes\n    if hasattr(command, 'decode'):\n        raise TypeError(\n            \"The given 'command' must be of type: str, List[str] or \"\n            \"Tuple[str].\"\n        )\n    # Handle str\n    cmd: List[str]\n    if hasattr(command, 'capitalize'):\n        command = cast(str, command)\n        cmd = list(shlex.split(command))\n    else:\n        cmd = list(command)\n\n    if interactive is True:\n        bash = shutil.which('bash')\n        if not bash:\n            raise RuntimeError(\n                \"Unable to run the command:  %r, in interactive mode \"\n                \"because 'bash' could NOT be found on the system.\"\n                % ' '.join(command)\n            )\n        cmd = [bash, '-i', '-c'] + cmd\n\n    if stdout is None:\n        stdout = sys.stdout\n    stdout = cast(IO, stdout)\n\n    if stderr is None:\n        stderr = sys.stderr\n    stderr = cast(IO, stderr)\n\n    if force_dimensions is False:\n        columns, lines = shutil.get_terminal_size(\n            fallback=(columns, lines)\n        )\n\n    # The following is adapted from: https://stackoverflow.com/a/31953436\n\n    masters, slaves = zip(pty.openpty(), pty.openpty())\n\n    try:\n        # Resize the pseudo terminals to the size of the current terminal\n        for fd in chain(masters, slaves):\n            _set_size(\n                fd,\n                columns=columns,\n                lines=lines\n            )\n\n        kwargs['stdout'] = slaves[0]\n        kwargs['stderr'] = slaves[1]\n\n        if 'stdin' not in kwargs.keys():\n            kwargs['stdin'] = slaves[0]\n\n        with Popen(cmd, **kwargs) as p:\n\n            for fd in slaves:\n                os.close(fd)  # no input\n            readable = {\n                masters[0]: stdout,\n                masters[1]: stderr,\n            }\n            while readable:\n                for fd in select(readable, [], [])[0]:\n                    try:\n                        data = os.read(fd, 1024)  # read available\n                    except OSError as e:\n                        if e.errno != errno.EIO:\n                            raise\n                        del readable[fd]  # EIO means EOF on some systems\n                    else:\n                        if not data:  # EOF\n                            del readable[fd]\n                        else:\n                            if hasattr(readable[fd], 'encoding'):\n                                obj = readable[fd]\n                                obj = cast(TextIO, obj)\n                                data_str = data.decode(\n                                    obj.encoding\n                                )\n                                readable[fd].write(data_str)\n                            else:\n                                readable[fd].write(data)\n                            readable[fd].flush()\n    finally:\n        for fd in chain(masters, slaves):\n            try:\n                os.close(fd)\n            except OSError:\n                pass\n    return p.returncode", "is_method": false, "function_description": "Provides a robust way to execute shell commands, capturing stdout and stderr via a pseudo-terminal. It manages terminal dimensions and preserves ANSI escape codes for accurate output."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/cmdutils.py", "function": "prep_cmd", "line_number": 235, "body": "def prep_cmd(cmd: Sequence) -> Tuple[str, ...]:\n    \"\"\"Convert a given command into a tuple for use by\n    :obj:`subprocess.Popen`.\n\n    Args:\n        cmd (:obj:`Sequence <typing.Sequence>`): The command to be converted.\n\n    This is for converting a command of type string or bytes to a tuple of\n    strings for use by :obj:`subprocess.Popen`.\n\n    Example:\n\n        >>> from flutils.cmdutils import prep_cmd\n        >>> prep_cmd('ls -Flap')\n        ('ls', '-Flap')\n    \"\"\"\n    if not hasattr(cmd, 'count') or not hasattr(cmd, 'index'):\n        raise TypeError(\n            \"The given 'cmd', %r, must be of type: str, bytes, list or \"\n            \"tuple.  Got: %r\" % (\n                cmd,\n                type(cmd).__name__\n            )\n        )\n    if hasattr(cmd, 'append'):\n        out = copy(cmd)\n    else:\n        out = cmd\n    if hasattr(out, 'decode'):\n        out = cast(bytes, out)\n        out = out.decode(get_encoding())\n    if hasattr(out, 'encode'):\n        out = cast(str, out)\n        out = shlex.split(out)\n    out = tuple(out)\n    out = cast(Tuple[str], out)\n    item: str\n    for x, item in enumerate(out):\n        if not isinstance(item, (str, UserString)):\n            raise TypeError(\n                \"Item %r of the given 'cmd' is not of type 'str'.  \"\n                \"Got: %r\" % (\n                    x,\n                    type(item).__name__\n                )\n            )\n    return out", "is_method": false, "function_description": "This function prepares shell commands for execution by `subprocess.Popen`. It converts various command formats into a standardized tuple of strings, ensuring proper argument splitting and compatibility."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/cmdutils.py", "function": "output_encoding", "line_number": 340, "body": "def output_encoding(self) -> str:\n        return get_encoding(self._output_encoding)", "is_method": true, "class_name": "RunCmd", "function_description": "This method retrieves the character encoding configured for the command's output. It enables correct interpretation of the command's results."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/cmdutils.py", "function": "__call__", "line_number": 343, "body": "def __call__(\n            self,\n            cmd: Sequence,\n            **kwargs: Any,\n    ) -> CompletedProcess:\n        \"\"\"Run the given command and return the result.\n\n        Args:\n             cmd (:obj:`Sequence <typing.Sequence>`): The command\n             **kwargs: Any default_kwargs to pass to :obj:`subprocess.run`.\n                These default_kwargs will override any ``default_kwargs``\n                set in the constructor.\n\n        Raises:\n            FileNotFoundError: If the given ``cmd`` cannot be found.\n            ChildProcessError: If ``raise_error=True`` was set in this\n                class' constructor; and, the process (from running the\n                given ``cmd``) returns a non-zero value.\n            ValueError: If the given ``**kwargs`` has invalid arguments.\n\n        Example:\n\n            >>> from flutils.cmdutils import RunCmd\n            >>> from subprocess import PIPE\n            >>> import os\n            >>> run_command = RunCmd(stdout=PIPE, stderr=PIPE)\n            >>> result = run_command('ls -flap %s' % os.getcwd())\n            >>> result.return_code\n            0\n            >>> result.stdout\n            ...\n            >>> result = run_command('ls -flap %s' % os.path.expanduser('~'))\n        \"\"\"\n        cmd = prep_cmd(cmd)\n        cmd = cast(Tuple[str, ...], cmd)\n        # noinspection PyProtectedMember\n        keyword_args = self.default_kwargs._asdict()\n        keyword_args.update(kwargs)\n        result = subprocess.run(cmd, **keyword_args)\n        cmd = shlex.join(cmd)\n        cmd = cast(str, cmd)\n        stdout = result.stdout.decode(self.output_encoding)\n        stderr = result.stderr.decode(self.output_encoding)\n        if self.raise_error is True:\n            if result.returncode != 0:\n                raise ChildProcessError(\n                    f'Unable to run the command {cmd!r}:\\n\\n {stdout} '\n                    f'{stderr} Return code: {result.returncode}'\n                )\n        return CompletedProcess(\n            return_code=result.returncode,\n            stdout=stdout,\n            stderr=stderr,\n            cmd=cmd,\n        )", "is_method": true, "class_name": "RunCmd", "function_description": "Executes a given shell command, capturing its standard output and error streams. It returns a `CompletedProcess` object, optionally raising an error for non-zero exit codes."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/namedtupleutils.py", "function": "to_namedtuple", "line_number": 32, "body": "def to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)", "is_method": false, "function_description": "This function converts various Python objects (like dictionaries, lists, and tuples) into `NamedTuple` instances, or recursively converts their contents. It provides a structured, attribute-accessible representation for diverse data."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/namedtupleutils.py", "function": "_", "line_number": 108, "body": "def _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out", "is_method": false, "function_description": "Converts a mapping into a `namedtuple` structure, filtering keys to include only valid Python identifiers. It recursively transforms nested mappings, enabling attribute-style access to the data."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/namedtupleutils.py", "function": "_", "line_number": 142, "body": "def _(\n        obj: Sequence,\n        _started: bool = False\n) -> Union[List[Any], Tuple[Any, ...], NamedTuple, str]:\n    if hasattr(obj, 'capitalize'):\n        obj = cast(str, obj)\n        if _started is False:\n            raise TypeError(\n                \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n                \"got: (%r) %s\" % (type(obj).__name__, obj)\n            )\n        return obj\n    if hasattr(obj, '_fields'):\n        fields: List[str] = list(obj._fields)\n        if fields:\n            obj = cast(NamedTuple, obj)\n            args = []\n            for attr in obj._fields:\n                val: Any = getattr(obj, attr)\n                val = _to_namedtuple(val, _started=True)\n                args.append(val)\n            if args:\n                # noinspection Mypy\n                make = namedtuple('NamedTuple', fields)  # type: ignore[misc]\n                # noinspection PyTypeChecker,PyArgumentList\n                out: NamedTuple = make(*args)\n                return out\n        return obj\n    # noinspection PyTypeChecker\n    out = []\n    for item in obj:\n        val = _to_namedtuple(item, _started=True)\n        out.append(val)\n    if not hasattr(obj, 'append'):\n        return tuple(out)\n    return out", "is_method": false, "function_description": "This function recursively processes nested sequences, rebuilding `NamedTuple` objects from their elements. It provides a deep transformation utility for complex data structures, preserving original list or tuple container types."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/decorators.py", "function": "__get__", "line_number": 61, "body": "def __get__(self, obj: Any, cls):\n        if obj is None:\n            return self\n\n        if asyncio.iscoroutinefunction(self.func):\n            return self._wrap_in_coroutine(obj)\n\n        value = obj.__dict__[self.func.__name__] = self.func(obj)\n        return value", "is_method": true, "class_name": "cached_property", "function_description": "For a `cached_property`, this method retrieves a property's value, caching it on first access for subsequent use. It supports both synchronous and asynchronous property functions."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/decorators.py", "function": "_wrap_in_coroutine", "line_number": 71, "body": "def _wrap_in_coroutine(self, obj):\n\n        @asyncio.coroutine\n        def wrapper():\n            future = asyncio.ensure_future(self.func(obj))\n            obj.__dict__[self.func.__name__] = future\n            return future\n\n        return wrapper()", "is_method": true, "class_name": "cached_property", "function_description": "Wraps the decorated asynchronous function into a coroutine. It immediately stores and returns a future representing the ongoing execution, enabling `cached_property` to cache the future result."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/decorators.py", "function": "wrapper", "line_number": 74, "body": "def wrapper():\n            future = asyncio.ensure_future(self.func(obj))\n            obj.__dict__[self.func.__name__] = future\n            return future", "is_method": true, "class_name": "cached_property", "function_description": "It initiates and caches an `asyncio.Future` for an asynchronous property's computation. This ensures the asynchronous operation runs only once, providing the future for subsequent accesses."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "_validate_attr_identifier", "line_number": 51, "body": "def _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier", "is_method": false, "function_description": "Verifies if a given string is a valid and safe Python attribute identifier. It checks against Python keywords, built-in names, and special dunder names, raising an error on invalidity."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "_expand_attr_map_item", "line_number": 100, "body": "def _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )", "is_method": false, "function_description": "Parses a specialized 'foreign-name' string into a structured attribute mapping. It extracts the target attribute name, module name, and module attribute, enabling selective module cherry-picking."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "_expand_attr_map", "line_number": 138, "body": "def _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping", "is_method": false, "function_description": "This generator expands a tuple of specially formatted \"foreign-name\" strings into unique `_AttrMapping` named tuples. It provides a de-duplicated, structured representation of attribute mappings for further processing."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "_parse_attr_map", "line_number": 174, "body": "def _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)", "is_method": false, "function_description": "Parses and validates a tuple of attribute mappings, transforming them into a structured map. This map prepares information for a 'cherry-picking' module to selectively import attributes."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "cherry_pick", "line_number": 380, "body": "def cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)", "is_method": false, "function_description": "Transforms a Python package into a \"cherry-picking module,\" enabling lazy loading of submodules and attributes. It postpones their execution until accessed, primarily to optimize application startup time."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "lazy_import_module", "line_number": 664, "body": "def lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module", "is_method": false, "function_description": "Lazily imports a Python module, deferring its actual loading and execution until an attribute is accessed. This helps reduce application startup time by only loading modules when needed."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "__getattribute__", "line_number": 220, "body": "def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)", "is_method": true, "class_name": "_CherryPickingModule", "function_description": "This method intercepts attribute access for lazy loading. It dynamically imports modules and populates marked attributes on demand when they are first accessed."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "create_module", "line_number": 252, "body": "def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod", "is_method": true, "class_name": "_CherryPickingLoader", "function_description": "This method of an import loader creates an uninitialized module object based on a module specification, providing the initial structure for Python's import system."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "exec_module", "line_number": 258, "body": "def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule", "is_method": true, "class_name": "_CherryPickingLoader", "function_description": "This method customizes a module during its loading. It prepares attributes for \"cherry-picking\" and injects additional ones, changing the module's class to enable custom attribute resolution and access."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "__repr__", "line_number": 325, "body": "def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)", "is_method": true, "class_name": "_CherryPickFinder", "function_description": "Provides a clear, unambiguous string representation of the `_CherryPickFinder` instance. Useful for debugging and introspection."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "load", "line_number": 329, "body": "def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj", "is_method": true, "class_name": "_CherryPickFinder", "function_description": "Ensures this import finder is the first active one in Python's module import search path. This guarantees it has priority in locating and loading modules, potentially for specialized import behavior."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "add", "line_number": 339, "body": "def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )", "is_method": true, "class_name": "_CherryPickFinder", "function_description": "Stores configuration data for a cherry-picking module into an internal cache. This includes its full name, origin, path, and attribute mapping for later use."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "find_spec", "line_number": 358, "body": "def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None", "is_method": true, "class_name": "_CherryPickFinder", "function_description": "This method of a custom import finder provides a module specification for \"cherry-picking\" modules. It enables selective module loading when pre-cached information for the module is available."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "__getattribute__", "line_number": 560, "body": "def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)", "is_method": true, "class_name": "_LazyModule", "function_description": "Triggers the full loading of a lazy module and transforms it into a regular module when an attribute is first accessed. This optimizes startup performance by deferring module imports."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "__delattr__", "line_number": 607, "body": "def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)", "is_method": true, "class_name": "_LazyModule", "function_description": "Handles attribute deletion for lazy-loaded modules. It ensures the underlying module is fully loaded before deleting the specified attribute, maintaining proper behavior during delayed initialization."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "__check_eager_loader", "line_number": 632, "body": "def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )", "is_method": true, "class_name": "_LazyLoader", "function_description": "Validates that a loader object provides the `exec_module` method. This ensures compatibility for executing modules, preventing runtime errors in the lazy loading process."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "create_module", "line_number": 643, "body": "def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)", "is_method": true, "class_name": "_LazyLoader", "function_description": "This method creates an uninitialized module object by delegating the task to its underlying loader. It's a key step in the lazy loading process, preparing modules for later execution."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "exec_module", "line_number": 647, "body": "def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule", "is_method": true, "class_name": "_LazyLoader", "function_description": "This method transforms a given module into a lazy-loading module. It defers the actual loading of the module's contents until its attributes are accessed, optimizing resource usage."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "len_without_ansi", "line_number": 25, "body": "def len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n         seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n             of strings.\n\n    :rtype:\n        :obj:`int`\n\n    Example:\n        >>> from flutils.txtutils import len_without_ansi\n        >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n        >>> len_without_ansi(text)\n        6\n    \"\"\"\n    if hasattr(seq, 'capitalize'):\n        _text: str = cast(str, seq)\n        seq = [c for c in _ANSI_RE.split(_text) if c]\n    seq = [c for c in chain(*map(_ANSI_RE.split, seq)) if c]\n    seq = cast(Sequence[str], seq)\n    out = 0\n    for text in seq:\n        if hasattr(text, 'capitalize'):\n            if text.startswith('\\x1b[') and text.endswith('m'):\n                continue\n            else:\n                out += len(text)\n    return out", "is_method": false, "function_description": "Calculates the character length of a string or sequence of strings, ignoring any ANSI escape codes. This provides an accurate visible length for formatted text, especially in terminal applications."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "initial_indent", "line_number": 214, "body": "def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "This method of `AnsiTextWrapper` retrieves the string used to indent the very first line of wrapped text. It specifies the starting horizontal spacing for text formatting."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "initial_indent", "line_number": 218, "body": "def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Sets the string used for indenting the very first line of wrapped text. It also automatically clears any cached length information related to this initial indentation."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "initial_indent_len", "line_number": 224, "body": "def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Calculates the effective visual length of the initial indentation string, ignoring ANSI escape codes. This ensures accurate width calculations for text wrapping."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "subsequent_indent", "line_number": 230, "body": "def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Retrieves the indentation string applied to all lines after the first in a wrapped text block. This string is used by the text wrapper for formatting."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "subsequent_indent", "line_number": 234, "body": "def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Sets the indentation string for all lines after the first line in wrapped text. This provides control over the visual formatting of text blocks."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "subsequent_indent_len", "line_number": 240, "body": "def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "This method provides the effective length of the indentation applied to wrapped lines after the first. It accounts for ANSI escape codes to ensure accurate text layout."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "placeholder", "line_number": 250, "body": "def placeholder(self, value: str) -> None:\n        self.__placeholder = value\n        if 'placeholder_len' in self.__dict__.keys():\n            del self.__dict__['placeholder_len']", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Provides a way to set the internal string placeholder used in text wrapping. It automatically invalidates the cached placeholder length, ensuring accuracy for subsequent operations."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "placeholder_len", "line_number": 256, "body": "def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Calculates the visual length of the `placeholder` string, disregarding any ANSI escape sequences. This ensures accurate width computations for text wrapping."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "_split", "line_number": 261, "body": "def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "This method splits text into segments, specifically handling ANSI escape codes as delimiters. It prepares the text for accurate wrapping by ensuring ANSI sequences do not interfere with line breaks."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "_wrap_chunks", "line_number": 273, "body": "def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "This private method wraps a list of text chunks into lines, respecting specified width, indentation, and ANSI escape codes. It handles line limits and adds a placeholder for truncated output."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "wrap", "line_number": 398, "body": "def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "This method wraps a single paragraph of text into lines no longer than the instance's configured width. It provides a service for formatting text, potentially with ANSI codes, for display."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "fill", "line_number": 414, "body": "def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "This method wraps a single paragraph of text, correctly handling ANSI escape codes for display in terminals. It ensures formatted text fits within specified line limits."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "chmod", "line_number": 51, "body": "def chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)", "is_method": false, "function_description": "Modifies file and directory permissions for a given path. It supports glob patterns for bulk operations and allows distinct modes for files and directories."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "chown", "line_number": 138, "body": "def chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)", "is_method": false, "function_description": "Provides a utility to change the user and group ownership of files and directories. It supports glob patterns for batch operations, including recursive changes, for flexible permission management."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "directory_present", "line_number": 219, "body": "def directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path", "is_method": false, "function_description": "Ensures a specified path exists and is a directory. It creates missing directories, including parents, and applies given mode, user, and group ownership."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "exists_as", "line_number": 336, "body": "def exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''", "is_method": false, "function_description": "Provides a precise classification of a file system path, returning its type (e.g., 'directory', 'file') if it exists. Useful for conditional file system operations or path validation."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "find_paths", "line_number": 387, "body": "def find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)", "is_method": false, "function_description": "This function finds all file system paths that match a given glob pattern. It normalizes the input path, allowing for flexible and robust file system searches."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "get_os_group", "line_number": 417, "body": "def get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )", "is_method": false, "function_description": "This function retrieves an operating system group object using its name or GID. It provides detailed information about the specified group, defaulting to the current user's primary group if no identifier is given."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "get_os_user", "line_number": 461, "body": "def get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )", "is_method": false, "function_description": "Provides detailed information about an operating system user, retrievable by login name or UID. This capability is useful for system administration and user management tasks."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "normalize_path", "line_number": 505, "body": "def normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user\u2019s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)", "is_method": false, "function_description": "Normalizes various input path formats into a consistent, absolute, and simplified `Path` object. It expands home directories, environment variables, and resolves relative references for canonical representation."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "_normalize_path_bytes", "line_number": 564, "body": "def _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)", "is_method": false, "function_description": "Decodes a byte-string path using the system's filesystem encoding and then normalizes it into a standard path object."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "_normalize_path_pathlib", "line_number": 570, "body": "def _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())", "is_method": false, "function_description": "Normalizes a `pathlib.Path` object by converting it to a POSIX string format before applying a general path normalization function. This ensures consistent path handling."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "path_absent", "line_number": 574, "body": "def path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)", "is_method": false, "function_description": "Provides a service to ensure a file or directory path is absent from the filesystem. It deletes the specified path and its contents if it exists, including recursive deletion for directories."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/raw_utf8_escape.py", "function": "_each_utf8_hex", "line_number": 16, "body": "def _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex", "is_method": false, "function_description": "Provides an escaped representation of a string, yielding printable ASCII characters directly. Non-printable or non-ASCII characters are converted to their UTF-8 byte equivalents, formatted as `\\xNN` hexadecimal escapes."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/raw_utf8_escape.py", "function": "encode", "line_number": 27, "body": "def encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)", "is_method": false, "function_description": "Converts a string, potentially containing escaped UTF-8 hexadecimal, into bytes of escaped UTF-8 hexadecimal. It validates the correctness of the referenced UTF-8 byte sequences."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/raw_utf8_escape.py", "function": "decode", "line_number": 91, "body": "def decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)", "is_method": false, "function_description": "Converts bytes representing escaped UTF-8 hexadecimal sequences into a standard string. It provides robust decoding with error handling."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/raw_utf8_escape.py", "function": "_get_codec_info", "line_number": 147, "body": "def _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None", "is_method": false, "function_description": "Provides a `CodecInfo` object for a specific custom codec, enabling its registration and use within Python's `codecs` module for custom encoding/decoding operations."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/raw_utf8_escape.py", "function": "register", "line_number": 158, "body": "def register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)", "is_method": false, "function_description": "Registers a custom text codec with Python's `codecs` module. It ensures the codec is available for encoding/decoding operations if not already present."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/__init__.py", "function": "register_codecs", "line_number": 17, "body": "def register_codecs() -> None:\n    \"\"\"Register additional codecs.\n\n    *New in version 0.4.*\n\n    :rtype: :obj:`None`\n\n    Examples:\n\n        >>> from flutils.codecs import register_codecs\n        >>> register_codecs()\n        >>> 'test\u00a9'.encode('raw_utf8_escape')\n        b'test\\\\\\\\xc2\\\\\\\\xa9'\n        >>> b'test\\\\\\\\xc2\\\\\\\\xa9'.decode('raw_utf8_escape')\n        'test\u00a9'\n        >>> 'dGVzdA=='.encode('b64')\n        b'test'\n        >>> b'test'.decode('b64')\n        'dGVzdA=='\n\n    \"\"\"\n    raw_utf8_escape.register()\n    b64.register()", "is_method": false, "function_description": "Registers additional encoding and decoding codecs for strings and bytes. This extends Python's built-in conversion capabilities, allowing custom formats to be used directly."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/__init__.py", "function": "get_encoding", "line_number": 46, "body": "def get_encoding(\n        name: Optional[str] = None,\n        default: Optional[str] = SYSTEM_ENCODING\n) -> str:\n    \"\"\"Validate and return the given encoding codec name.\n\n    Args:\n        name (str): The name of the encoding to validate.\n            if empty or invalid then the value of the given ``default``\n            will be returned.\n        default (str, optional): If set, this encoding name will be returned\n            if the given ``name`` is invalid. Defaults to:\n            :obj:`~flutils.codecs.SYSTEM_ENCODING`.  If set to :obj:`None`\n            which will raise a :obj:`LookupError` if the given ``name``\n            is not valid.\n\n    Raises:\n        LookupError: If the given ``name`` is not a valid encoding codec name\n            and the given ``default`` is set to :obj:`None` or an empty string.\n        LookupError: If the given ``default`` is not a valid encoding codec\n            name.\n\n    Returns:\n        str: The encoding codec name.\n\n    Example:\n\n        >>> from flutils.codecs import get_encoding\n        >>> get_encoding()\n        'utf-8'\n    \"\"\"\n    if name is None:\n        name = ''\n    if hasattr(name, 'encode') is False:\n        name = ''\n    name = cast(str, name)\n    name = name.strip()\n\n    if default is None:\n        default = ''\n    if hasattr(default, 'encode') is False:\n        default = ''\n    default = cast(str, default)\n    default = default.strip()\n\n    if default:\n        try:\n            codec = codecs.lookup(default)\n        except LookupError:\n            raise LookupError(\n                f\"The given 'default' of {default!r} is an invalid encoding \"\n                f\"codec name.\"\n            )\n        else:\n            default = codec.name\n\n    try:\n        codec = codecs.lookup(name)\n    except LookupError:\n        if default:\n            return default\n        raise LookupError(\n            f\"The given 'name' of {name!r} is an invalid encoding \"\n            f\"codec name.\"\n        )\n    else:\n        return codec.name", "is_method": false, "function_description": "Validates and returns a canonical encoding codec name. If the provided name is invalid, it falls back to a validated default, ensuring a usable encoding for operations."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/b64.py", "function": "encode", "line_number": 17, "body": "def encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)", "is_method": false, "function_description": "Decodes a base64 encoded string, stripping whitespace, into its original byte representation. It returns the decoded bytes and their length."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/b64.py", "function": "decode", "line_number": 66, "body": "def decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)", "is_method": false, "function_description": "Converts binary data into a base64-encoded string representation. It provides a text-safe way to handle binary information, returning the encoded string and original data length."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/b64.py", "function": "_get_codec_info", "line_number": 99, "body": "def _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None", "is_method": false, "function_description": "This function provides the `CodecInfo` (including encode and decode functions) for a specific custom text encoding when its name matches a predefined constant. It enables the registration and use of a custom codec."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/b64.py", "function": "register", "line_number": 110, "body": "def register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)", "is_method": false, "function_description": "Registers the 'b64' codec with Python's `codecs` module. This ensures the 'b64' codec is available system-wide for encoding and decoding base64 data."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "_each_setup_cfg_command_section", "line_number": 32, "body": "def _each_setup_cfg_command_section(\n        parser: ConfigParser\n) -> Generator[Tuple[str, str], None, None]:\n    for section in parser.sections():\n        section = cast(str, section)\n        section = section.strip()\n        if section.startswith('setup.command.'):\n            command_name = '.'.join(section.split('.')[2:])\n            if command_name:\n                yield section, command_name", "is_method": false, "function_description": "Iterates over a ConfigParser to find and yield sections representing 'setup.command.' entries. It extracts both the full section name and the corresponding command name for processing setup configurations."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "_each_setup_cfg_command", "line_number": 44, "body": "def _each_setup_cfg_command(\n        parser: ConfigParser,\n        format_kwargs: Dict[str, str]\n) -> Generator[SetupCfgCommandConfig, None, None]:\n    for section, command_name in _each_setup_cfg_command_section(parser):\n        commands: List[str] = []\n        options: List[str] = parser.options(section)\n        for option in ('command', 'commands'):\n            if option in options:\n                val: str = parser.get(section, option)\n                val = val.format(**format_kwargs)\n                commands += list(\n                    filter(len, map(lambda x: x.strip(), val.splitlines()))\n                )\n        if commands:\n            cmd_name = ''\n            if 'name' in options:\n                cmd_name = parser.get(section, 'name')\n            cmd_name = cmd_name or command_name\n            cmd_name = cmd_name.format(name=format_kwargs['name'])\n\n            description = ''\n            if 'description' in options:\n                description = parser.get(section, 'description')\n            description = description.format(**format_kwargs)\n\n            title = cmd_name.replace('.', '_')\n            title = title.replace('-', '_')\n\n            if title.isidentifier() is True:\n                yield SetupCfgCommandConfig(\n                    cmd_name,\n                    underscore_to_camel(title, lower_first=False),\n                    description,\n                    tuple(commands)\n                )", "is_method": false, "function_description": "Parses a `ConfigParser` object to extract and format command configurations. It yields structured `SetupCfgCommandConfig` objects for each valid command definition found."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "_get_name", "line_number": 82, "body": "def _get_name(\n        parser: ConfigParser,\n        setup_cfg_path: str,\n) -> str:\n    try:\n        out = parser.get('metadata', 'name')\n    except NoSectionError:\n        raise LookupError(\n            \"The config file, %r, is missing the 'metadata' section.\"\n            % setup_cfg_path\n        )\n    except NoOptionError:\n        raise LookupError(\n            \"The 'metadata', section is missing the 'name' option in \"\n            \"the config file, %r.\"\n            % setup_cfg_path\n        )\n    if not out:\n        raise LookupError(\n            \"The 'metadata', section's, 'name' option is not set in \"\n            \"the config file, %r.\"\n            % setup_cfg_path\n        )\n    return out", "is_method": false, "function_description": "Retrieves the project name from the 'metadata' section of a configuration file. It ensures the 'name' option is present and not empty, raising errors on validation failure."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "_validate_setup_dir", "line_number": 108, "body": "def _validate_setup_dir(setup_dir: str) -> None:\n    \"\"\"Validates the given ``setup_dir``.\"\"\"\n    if os.path.exists(setup_dir) is False:\n        raise FileNotFoundError(\n            \"The given 'setup_dir' of %r does NOT exist.\"\n            % setup_dir\n        )\n    if os.path.isdir(setup_dir) is False:\n        raise NotADirectoryError(\n            \"The given 'setup_dir' of %r is NOT a directory.\"\n            % setup_dir\n        )\n    path = os.path.join(setup_dir, 'setup.py')\n    if os.path.isfile(path) is False:\n        raise FileNotFoundError(\n            \"The given 'setup_dir' of %r does NOT contain a setup.py \"\n            \"file.\" % setup_dir\n        )\n    path = os.path.join(setup_dir, 'setup.cfg')\n    if os.path.isfile(path) is False:\n        raise FileNotFoundError(\n            \"The given 'setup_dir' of %r does NOT contain a setup.cfg \"\n            \"file.\" % setup_dir\n        )", "is_method": false, "function_description": "Validates if a given path is a valid Python project directory by ensuring it exists, is a directory, and contains both `setup.py` and `setup.cfg` files."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "_prep_setup_dir", "line_number": 134, "body": "def _prep_setup_dir(\n        setup_dir: Optional[Union[os.PathLike, str]] = None\n) -> str:\n    \"\"\"The path to the directory that contains the project's ``setup.py``\n    file.\n    \"\"\"\n    if setup_dir:\n        setup_dir = str(setup_dir)\n        _validate_setup_dir(setup_dir)\n        return os.path.realpath(setup_dir)\n\n    for fs in extract_stack():\n        fs = cast(FrameSummary, fs)\n        basename = os.path.basename(fs.filename)\n        if basename == 'setup.py':\n            setup_dir = str(os.path.dirname(fs.filename))\n            _validate_setup_dir(setup_dir)\n            return os.path.realpath(setup_dir)\n    raise FileNotFoundError(\n        \"Unable to find the directory that contains the 'setup.py' file.\"\n    )", "is_method": false, "function_description": "Provides the absolute path to the directory containing the project's `setup.py` file. It either validates a given path or searches the call stack to infer it."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "each_sub_command_config", "line_number": 157, "body": "def each_sub_command_config(\n        setup_dir: Optional[Union[os.PathLike, str]] = None\n) -> Generator[SetupCfgCommandConfig, None, None]:\n    format_kwargs: Dict[str, str] = {\n        'setup_dir': _prep_setup_dir(setup_dir),\n        'home': os.path.expanduser('~')\n    }\n    setup_cfg_path = os.path.join(format_kwargs['setup_dir'], 'setup.cfg')\n    parser = ConfigParser()\n    parser.read(setup_cfg_path)\n    format_kwargs['name'] = _get_name(parser, setup_cfg_path)\n    path = os.path.join(format_kwargs['setup_dir'], 'setup_commands.cfg')\n    if os.path.isfile(path):\n        parser = ConfigParser()\n        parser.read(path)\n    yield from _each_setup_cfg_command(parser, format_kwargs)", "is_method": false, "function_description": "Reads `setup.cfg` and optional `setup_commands.cfg` from a specified directory. It generates configured sub-command objects, providing specific configurations for various setup commands."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/__init__.py", "function": "add_setup_cfg_commands", "line_number": 14, "body": "def add_setup_cfg_commands(\n        setup_kwargs: Dict[str, Any],\n        setup_dir: Optional[Union[PathLike, str]] = None\n) -> None:\n    \"\"\"Add additional custom ``setup.py`` commands that are defined in\n    ``setup.cfg``.\n\n    Args:\n        setup_kwargs (dict): A dictionary holding the\n            `setuptools.setup keyword arguments <https://bit.ly/2Ju4Zad>`_.\n            (see example below).\n        setup_dir (:obj:`str` or :obj:`Path <pathlib.Path>`, optional): The\n            root directory of the project. (e.g. the directory that contains\n            the ``setup.py`` file).  Defaults to: ``None`` which will try to\n            determine the directory using the call stack.\n\n    :rtype: :obj:`None`\n\n    Example:\n        Use in ``setup.py`` like the following::\n\n            #!/usr/bin/env python\n\n            import os\n\n            from setuptools import setup\n\n            from flutils.setuputils import add_setup_cfg_commands\n\n            setup_kwargs = {}\n            setup_dir = os.path.dirname(os.path.realpath(__file__))\n            add_setup_cfg_commands(setup_kwargs, setup_dir=setup_dir)\n            setup(**setup_kwargs)\n\n    \"\"\"\n    for sub_command_cfg in each_sub_command_config(setup_dir):\n        klass = build_setup_cfg_command_class(sub_command_cfg)\n        if 'cmdclass' not in setup_kwargs.keys():\n            setup_kwargs['cmdclass'] = {}\n        setup_kwargs['cmdclass'][sub_command_cfg.name] = klass", "is_method": false, "function_description": "Adds custom `setup.py` commands, defined in `setup.cfg`, to the `setuptools.setup` keyword arguments. This allows extending project build automation directly from configuration."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cmd.py", "function": "_get_path", "line_number": 20, "body": "def _get_path(cmd: str) -> str:\n    if cmd.startswith(os.path.sep):\n        if os.path.isfile(cmd) is True:\n            out = cmd\n        else:\n            raise FileNotFoundError('Unable to find the file: %r' % cmd)\n    else:\n        out = ''\n        path = shutil.which(cmd)\n        if path is not None:\n            out = str(path)\n\n    if out:\n        if os.access(out, os.X_OK) is False:\n            raise PermissionError(\n                'You do not have execute permission to run the file: %r'\n                % out\n            )\n        return out\n    raise FileNotFoundError(\n        'Unable to find the file path for the command: %r'\n        % cmd\n    )", "is_method": false, "function_description": "Locates and validates the absolute, executable path for a given command or file, ensuring it exists and has execution permissions. It provides a reliable way to prepare commands for external execution."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cmd.py", "function": "_each_command", "line_number": 45, "body": "def _each_command(\n        commands: Union[List[str], Tuple[str, ...]]\n) -> Generator[Tuple[str, ...], None, None]:\n    for command in commands:\n        command = command.strip()\n        hold = []\n        for x, part in enumerate(shlex.split(command)):\n            if x == 0:\n                hold.append(_get_path(part))\n            else:\n                hold.append(part)\n        if hold:\n            yield tuple(hold)", "is_method": false, "function_description": "Parses a list of raw command strings, resolving the executable path of each. It yields a sequence of commands as argument tuples, ready for execution."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cmd.py", "function": "_show_command", "line_number": 63, "body": "def _show_command(\n        command: Tuple[str, ...],\n) -> None:\n    print(_DIVIDER)\n    for x, part in enumerate(command):\n        if x == 0:\n            print('{}\\n'.format(part))\n        else:\n            print('  {}\\n'.format(part))\n    print('\\n\\n')", "is_method": false, "function_description": "Displays a command, represented as a tuple of strings, to the console. It formats and indents the command's components for clear readability."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cmd.py", "function": "_run", "line_number": 86, "body": "def _run(self) -> None:\n    for command in _each_command(self.commands):\n        _show_command(command)\n        val = run(command)\n        if val != 0:\n            sys.exit(val)\n            return\n    sys.exit(0)", "is_method": false, "function_description": "Executes a sequence of commands sequentially. If any command returns a non-zero status, the program exits immediately with that status; otherwise, it exits successfully after all commands complete."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cmd.py", "function": "build_setup_cfg_command_class", "line_number": 99, "body": "def build_setup_cfg_command_class(\n        setup_command_cfg: SetupCfgCommandConfig\n) -> Type[Command]:\n    setup_klass = _type(\n        'SetupCfgCommand',\n        (object,),\n        {\n            '__annotations__': {\n                'name': ClassVar[str],\n                'root_path': ClassVar[str],\n                'description': ClassVar[str],\n                'user_options': ClassVar[List[str]],\n                'commands': ClassVar[Tuple[str, ...]],\n            },\n            '__module__': __name__,\n            '__doc__': None,\n            'name': setup_command_cfg.name,\n            'root_path': '',\n            'description': setup_command_cfg.description,\n            'user_options': [],\n            'commands': setup_command_cfg.commands,\n            'initialize_options': _initialize_options,\n            'finalize_options': _finalize_options,\n            'run': _run,\n        }\n    )\n    klass_name = '%sCommand' % setup_command_cfg.camel\n    klass = _type(klass_name, (setup_klass, Command), {})\n    return klass", "is_method": false, "function_description": "Dynamically constructs and returns a `Command` class for a setup or build system. It configures the class based on provided specifications for custom command execution."}]