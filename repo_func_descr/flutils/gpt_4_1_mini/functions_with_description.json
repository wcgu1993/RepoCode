[{"file": "./dataset/RepoExec/test-apps/flutils/docs/conf.py", "function": "setup", "line_number": 258, "body": "def setup(app):\n    app.add_css_file('css/style.css')", "is_method": false, "function_description": "Registers a CSS stylesheet with the given application instance to apply custom styles to its web interface. This function integrates styling resources into the app's rendering process."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/packages.py", "function": "_each_version_part", "line_number": 53, "body": "def _each_version_part(\n        ver_obj: StrictVersion,\n) -> Generator[_VersionPart, None, None]:\n    version: Tuple[int, int, int] = ver_obj.version\n    prerelease: Union[Tuple[str, int], None] = ver_obj.prerelease\n    prerelease_built = False\n    for pos, num in enumerate(version):\n        txt = '%s' % num\n        if pos == 2 and num == 0:\n            txt = ''\n        kwargs: Dict[str, Any] = {\n            'pos': pos,\n            'txt': txt,\n            'num': num,\n            'pre_txt': '',\n            'pre_num': -1,\n            'name': _BUMP_VERSION_POSITION_NAMES[pos]\n        }\n        if (prerelease_built is False and\n                pos > 0 and\n                prerelease is not None):\n            prerelease = cast(Tuple[str, int], prerelease)\n            should_add = True\n            if pos == 1 and version[2] != 0:\n                should_add = False\n            if should_add is True:\n                kwargs['txt'] = '%s%s%s' % (\n                    kwargs['txt'],\n                    prerelease[0],\n                    prerelease[1]\n                )\n                kwargs['pre_txt'] = prerelease[0]\n                kwargs['pre_num'] = prerelease[1]\n                prerelease_built = True\n        yield _VersionPart(**kwargs)", "is_method": false, "function_description": "Utility function that processes a StrictVersion object, yielding detailed components of its version parts including potential prerelease identifiers, facilitating version comparison or manipulation workflows."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/packages.py", "function": "_build_version_info", "line_number": 98, "body": "def _build_version_info(\n        version: str\n) -> _VersionInfo:\n    ver_obj = StrictVersion(version)\n    pre_pos = -1\n    args: List[Any] = [version]\n    for part in _each_version_part(ver_obj):\n        if part.pre_txt:\n            pre_pos = part.pos\n        args.append(part)\n    args.append(pre_pos)\n    return _VersionInfo(*args)", "is_method": false, "function_description": "Constructs and returns a detailed version information object from a version string, capturing version components and pre-release position for precise version handling and comparison."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/packages.py", "function": "_build_version_bump_position", "line_number": 112, "body": "def _build_version_bump_position(\n        position: int\n) -> int:\n    pos_min = -3\n    pos_max = 2\n\n    if (pos_min <= position <= pos_max) is False:\n        raise ValueError(\n            \"The given value for 'position', %r, must be an 'int' \"\n            \"between (%r) and (%r).\" % (position, pos_min, pos_max)\n        )\n    # Turn position into a positive number\n    if position < 0:\n        pos_max += 1\n        return pos_max + position\n    return position", "is_method": false, "function_description": "Converts a relative version bump position within a fixed range to a corresponding absolute index, validating input and supporting negative indexing for version management tasks."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/packages.py", "function": "_build_version_bump_type", "line_number": 130, "body": "def _build_version_bump_type(\n        position_positive: int,\n        pre_release: Union[str, None]\n) -> int:\n    if pre_release is None:\n        prerelease = ''\n    else:\n        pre_release = cast(str, pre_release)\n        prerelease = pre_release.strip().lower()\n\n    if prerelease == '':\n        if position_positive == 0:\n            return _BUMP_VERSION_MAJOR\n        if position_positive == 1:\n            return _BUMP_VERSION_MINOR\n        return _BUMP_VERSION_PATCH\n    if prerelease in ('a', 'alpha', 'b', 'beta'):\n        is_alpha = False\n        if prerelease in ('a', 'alpha'):\n            is_alpha = True\n\n        if position_positive == 0:\n            raise ValueError(\n                \"Only the 'minor' or 'patch' parts of the version number \"\n                \"can get a prerelease bump.\"\n            )\n        if position_positive == 1:\n            if is_alpha is True:\n                return _BUMP_VERSION_MINOR_ALPHA\n            return _BUMP_VERSION_MINOR_BETA\n        if is_alpha is True:\n            return _BUMP_VERSION_PATCH_ALPHA\n        return _BUMP_VERSION_PATCH_BETA\n    raise ValueError(\n        \"The given value for 'pre_release', %r, can only be one of: \"\n        \"'a', 'alpha', 'b', 'beta', None.\"\n    )", "is_method": false, "function_description": "Determines the type of semantic version bump based on version position and optional pre-release identifier. It categorizes version increment types like major, minor, patch, and their alpha/beta pre-release variants."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/packages.py", "function": "bump_version", "line_number": 169, "body": "def bump_version(\n        version: str,\n        position: int = 2,\n        pre_release: Optional[str] = None\n) -> str:\n    \"\"\"Increase the version number from a version number string.\n\n    *New in version 0.3*\n\n    Args:\n        version (str): The version number to be bumped.\n        position (int, optional): The position (starting with zero) of the\n            version number component to be increased.  Defaults to: ``2``\n        pre_release (str, Optional): A value of ``a`` or ``alpha`` will\n            create or increase an alpha version number.  A value of ``b`` or\n            ``beta`` will create or increase a beta version number.\n\n    Raises:\n        ValueError: if the given ``version`` is an invalid version number.\n        ValueError: if the given ``position`` does not exist.\n        ValueError: if the given ``prerelease`` is not in:\n            ``a, alpha, b, beta``\n        ValueError: if trying to 'major' part, of a version number, to\n            a pre-release version.\n\n    :rtype:\n        :obj:`str`\n\n        * The increased version number.\n\n    Examples:\n        >>> from flutils.packages import bump_version\n        >>> bump_version('1.2.2')\n        '1.2.3'\n        >>> bump_version('1.2.3', position=1)\n        '1.3'\n        >>> bump_version('1.3.4', position=0)\n        '2.0'\n        >>> bump_version('1.2.3', prerelease='a')\n        '1.2.4a0'\n        >>> bump_version('1.2.4a0', pre_release='a')\n        '1.2.4a1'\n        >>> bump_version('1.2.4a1', pre_release='b')\n        '1.2.4b0'\n        >>> bump_version('1.2.4a1')\n        '1.2.4'\n        >>> bump_version('1.2.4b0')\n        '1.2.4'\n        >>> bump_version('2.1.3', position=1, pre_release='a')\n        '2.2a0'\n        >>> bump_version('1.2b0', position=2)\n        '1.2.1'\n\n    \"\"\"\n    ver_info = _build_version_info(version)\n    position = _build_version_bump_position(position)\n    bump_type = _build_version_bump_type(position, pre_release)\n    # noinspection PyUnusedLocal\n    hold: List[Union[int, str]] = []\n    if bump_type == _BUMP_VERSION_MAJOR:\n        hold = [ver_info.major.num + 1, 0]\n    elif bump_type in _BUMP_VERSION_MINORS:\n        if bump_type == _BUMP_VERSION_MINOR:\n            if ver_info.minor.pre_txt:\n                hold = [ver_info.major.num, ver_info.minor.num]\n            else:\n                hold = [ver_info.major.num, ver_info.minor.num + 1]\n        else:\n            if bump_type == _BUMP_VERSION_MINOR_ALPHA:\n                if ver_info.minor.pre_txt == 'a':\n                    part = '%sa%s' % (\n                        ver_info.minor.num,\n                        ver_info.minor.pre_num + 1\n                    )\n                else:\n                    part = '{}a0'.format(ver_info.minor.num + 1)\n            else:\n                if ver_info.minor.pre_txt == 'a':\n                    part = '{}b0'.format(ver_info.minor.num)\n                elif ver_info.minor.pre_txt == 'b':\n                    part = '%sb%s' % (\n                        ver_info.minor.num,\n                        ver_info.minor.pre_num + 1\n                    )\n                else:\n                    part = '{}b0'.format(ver_info.minor.num + 1)\n            hold = [ver_info.major.num, part]\n    else:\n        if bump_type == _BUMP_VERSION_PATCH:\n            if ver_info.patch.pre_txt:\n                hold = [\n                    ver_info.major.num,\n                    ver_info.minor.num,\n                    ver_info.patch.num\n                ]\n            else:\n                hold = [\n                    ver_info.major.num,\n                    ver_info.minor.num,\n                    ver_info.patch.num + 1\n                ]\n        else:\n            if bump_type == _BUMP_VERSION_PATCH_ALPHA:\n                if ver_info.patch.pre_txt == 'a':\n                    part = '%sa%s' % (\n                        ver_info.patch.num,\n                        ver_info.patch.pre_num + 1\n                    )\n                else:\n                    part = '{}a0'.format(ver_info.patch.num + 1)\n            else:\n                if ver_info.patch.pre_txt == 'a':\n                    part = '{}b0'.format(ver_info.patch.num)\n\n                elif ver_info.patch.pre_txt == 'b':\n                    part = '%sb%s' % (\n                        ver_info.patch.num,\n                        ver_info.patch.pre_num + 1\n                    )\n                else:\n                    part = '{}b0'.format(ver_info.patch.num + 1)\n            hold = [ver_info.major.num, ver_info.minor.num, part]\n    out = '.'.join(map(str, hold))\n    return out", "is_method": false, "function_description": "Function that increments a specified component of a semantic version string, optionally managing pre-release identifiers like alpha or beta. It is useful for automated version management in software release workflows."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "has_any_attrs", "line_number": 36, "body": "def has_any_attrs(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if any of the given ``*attrs`` exist on the given\n          ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_attrs\n        >>> has_any_attrs(dict(),'get','keys','items','values','something')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is True:\n            return True\n    return False", "is_method": false, "function_description": "Utility function that checks if an object possesses at least one specified attribute, facilitating flexible attribute existence checks in dynamic or polymorphic contexts."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "has_any_callables", "line_number": 61, "body": "def has_any_callables(obj: _Any, *attrs: str) -> bool:\n    \"\"\"Check if the given ``obj`` has **ANY** of the given ``attrs`` and are\n    callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if ANY of the given ``*attrs`` exist on the given ``obj``\n          and ANY are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_any_callables\n        >>> has_any_callables(dict(),'get','keys','items','values','foo')\n        True\n    \"\"\"\n    if has_any_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is True:\n                return True\n    return False", "is_method": false, "function_description": "Utility function that determines if an object has any specified attributes which are callable, enabling dynamic checks for method presence and invocability on objects."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "has_attrs", "line_number": 88, "body": "def has_attrs(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``*attrs``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_attrs\n        >>> has_attrs(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    for attr in attrs:\n        if hasattr(obj, attr) is False:\n            return False\n    return True", "is_method": false, "function_description": "Utility function that checks if an object possesses all specified attributes. It helps validate object capabilities before accessing or invoking their properties."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "has_callables", "line_number": 116, "body": "def has_callables(\n        obj: _Any,\n        *attrs: str\n) -> bool:\n    \"\"\"Check if given ``obj`` has all the given ``attrs`` and are callable.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *attrs (:obj:`str`): The names of the attributes to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if all the given ``*attrs`` exist on the given ``obj``\n          and all are callable;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import has_callables\n        >>> has_callables(dict(),'get','keys','items','values')\n        True\n    \"\"\"\n    if has_attrs(obj, *attrs) is True:\n        for attr in attrs:\n            if callable(getattr(obj, attr)) is False:\n                return False\n        return True\n    return False", "is_method": false, "function_description": "Utility function that checks whether an object has all specified attributes and confirms each is callable, useful for verifying if an object implements required callable methods before usage."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "is_list_like", "line_number": 146, "body": "def is_list_like(\n        obj: _Any\n) -> bool:\n    \"\"\"Check that given ``obj`` acts like a list and is iterable.\n\n    List-like objects are instances of:\n\n    - :obj:`UserList <collections.UserList>`\n    - :obj:`Iterator <collections.abc.Iterator>`\n    - :obj:`KeysView <collections.abc.KeysView>`\n    - :obj:`ValuesView <collections.abc.ValuesView>`\n    - :obj:`deque <collections.deque>`\n    - :obj:`frozenset`\n    - :obj:`list`\n    - :obj:`set`\n    - :obj:`tuple`\n\n    List-like objects are **NOT** instances of:\n\n    - :obj:`None`\n    - :obj:`bool`\n    - :obj:`bytes`\n    - :obj:`ChainMap <collections.ChainMap>`\n    - :obj:`Counter <collections.Counter>`\n    - :obj:`OrderedDict <collections.OrderedDict>`\n    - :obj:`UserDict <collections.UserDict>`\n    - :obj:`UserString <collections.UserString>`\n    - :obj:`defaultdict <collections.defaultdict>`\n    - :obj:`Decimal <decimal.Decimal>`\n    - :obj:`dict`\n    - :obj:`float`\n    - :obj:`int`\n    - :obj:`str`\n    - etc...\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is list-like; :\n        * :obj:`False` otherwise.\n\n    Examples:\n        >>> from flutils.objutils import is_list_like\n        >>> is_list_like([1, 2, 3])\n        True\n        >>> is_list_like(reversed([1, 2, 4]))\n        True\n        >>> is_list_like('hello')\n        False\n        >>> is_list_like(sorted('hello'))\n        True\n    \"\"\"\n    if is_subclass_of_any(obj, *_LIST_LIKE):\n        return True\n    return False", "is_method": false, "function_description": "Function that determines whether an object behaves like a list by checking if it is one of several iterable, list-like types. It helps identify objects suitable for list-style iteration or processing in generic code."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/objutils.py", "function": "is_subclass_of_any", "line_number": 206, "body": "def is_subclass_of_any(obj: _Any, *classes: _Any) -> bool:\n    \"\"\"Check if the given ``obj`` is a subclass of any of the given\n    ``*classes``.\n\n    Args:\n        obj (:obj:`Any <typing.Any>`): The object to check.\n        *classes (:obj:`Any <typing.Any>`): The classes to check against.\n\n    :rtype:\n        :obj:`bool`\n\n        * :obj:`True` if the given ``obj`` is an instance of ANY given\n          ``*classes``;\n        * :obj:`False` otherwise.\n\n    Example:\n        >>> from flutils.objutils import is_subclass_of_any\n        >>> from collections import ValuesView, KeysView, UserList\n        >>> obj = dict(a=1, b=2)\n        >>> is_subclass_of_any(obj.keys(),ValuesView,KeysView,UserList)\n        True\n    \"\"\"\n    for cls in classes:\n        if issubclass(obj.__class__, cls):\n            return True\n    return False", "is_method": false, "function_description": "Function that checks whether an object's class is a subclass of any specified classes, facilitating flexible type or inheritance validation in diverse contexts."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/validators.py", "function": "validate_identifier", "line_number": 15, "body": "def validate_identifier(\n        identifier: Union[str, UserString],\n        allow_underscore: bool = True\n) -> None:\n    \"\"\"Validate the given string is a proper identifier.\n\n    This validator will also raise an error if the given identifier is a\n    keyword or a builtin identifier.\n\n    Args:\n        identifier (:obj:`str` or :obj:`UserString <collections.UserString>`):\n            The value to be tested.\n        allow_underscore (:obj:`bool`, optional): A value of :obj:`False`\n            will raise an error when the ``identifier`` has a value that starts\n            with an underscore ``_``. (Use :obj:`False` when validating\n            potential :obj:`namedtuple <collections.namedtuple>` keys)\n            Defaults to: :obj:`True`.\n\n    Raises:\n        SyntaxError: If the given identifier is invalid.\n        TypeError: If the given identifier is not a :obj:`str` or\n            :obj:`UserString <collections.UserString>`.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.validators import validate_identifier\n        >>> validate_identifier('123')\n        SyntaxError: The given 'identifier', '123', cannot start with a number\n    \"\"\"\n    if isinstance(identifier, UserString):\n        identifier = str(identifier)\n    if not isinstance(identifier, str):\n        raise TypeError(\n            \"The given 'identifier' must be a 'str'.  Got: %r\"\n            % type(identifier).__name__\n        )\n    identifier = identifier.strip()\n    if not identifier:\n        raise SyntaxError(\"The given 'identifier' cannot be empty\")\n\n    if allow_underscore is False and identifier[0:1] == '_':\n        raise SyntaxError(\n            f\"The given 'identifier', {identifier!r}, cannot start with an \"\n            \"underscore '_'\"\n        )\n\n    if identifier[0:1].isdigit():\n        raise SyntaxError(\n            f\"The given 'identifier', {identifier!r}, cannot start with a \"\n            \"number\"\n        )\n\n    if not identifier.isidentifier():\n        raise SyntaxError(\n            f\"The given 'identifier', {identifier!r}, is invalid.\"\n        )\n\n    if keyword.iskeyword(identifier):\n        raise SyntaxError(\n            f\"The given 'identifier', {identifier!r}, cannot be a keyword\"\n        )\n\n    if identifier in _BUILTIN_NAMES:\n        raise SyntaxError(\n            f\"The given 'identifier', {identifier!r}, cannot be a builtin name\"\n        )", "is_method": false, "function_description": "Function that validates whether a given string is a valid Python identifier, not conflicting with keywords or built-in names, and optionally disallowing leading underscores. It ensures identifier suitability for naming variables or keys in contexts like namedtuples."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "as_escaped_unicode_literal", "line_number": 13, "body": "def as_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert the given ``text``  into a string of escaped Unicode\n    hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped Python literal.\n\n    Example:\n        >>> from flutils.strutils import as_escaped_unicode_literal\n        >>> t = '1.\u2605 \ud83d\uded1'\n        >>> as_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n    \"\"\"\n    out = ''\n    for c in text:\n        c_hex = hex(ord(c))[2:]\n        c_len = len(c_hex)\n        if c_len in (1, 2):\n            out += '\\\\x{:0>2}'.format(c_hex)\n        elif c_len in (3, 4):\n            out += '\\\\u{:0>4}'.format(c_hex)\n        else:\n            out += '\\\\U{:0>8}'.format(c_hex)\n    return out", "is_method": false, "function_description": "Function that converts a string into its escaped Unicode hexadecimal representation, encoding each character as a Python-compatible escape sequence. Useful for visualizing or safely embedding Unicode text in source code or data streams."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "as_escaped_utf8_literal", "line_number": 47, "body": "def as_escaped_utf8_literal(\n        text: str,\n) -> str:\n    \"\"\"Convert the given ``text`` into a string of escaped UTF8 hexadecimal.\n\n    Args:\n         text (:obj:`str`): The string to convert.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each character of the given ``text`` converted\n            into an escaped UTF8 hexadecimal.\n\n    Example:\n        >>> from flutils.strutils import as_literal_utf8\n        >>> t = '1.\u2605 \ud83d\uded1'\n        >>> as_escaped_utf8_literal(t)\n        '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\xe2\\\\\\\\x98\\\\\\\\x85\\\\\\\\x20\\\\\\\\xf0\\\\\\\\x9f\\\\\\\\x9b\n        \\\\\\\\x91'\n    \"\"\"\n    out = ''\n    text_bytes = text.encode('utf8')\n    for c in text_bytes:\n        out += '\\\\%s' % hex(c)[1:]\n    return out", "is_method": false, "function_description": "Function that converts a string into its UTF-8 encoded form represented as escaped hexadecimal byte literals. Useful for safely encoding text for debugging, serialization, or transmission where escaped byte sequences are required."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "camel_to_underscore", "line_number": 81, "body": "def camel_to_underscore(\n        text: str\n) -> str:\n    \"\"\"Convert a camel-cased string to a string containing words separated\n    with underscores.\n\n    Args:\n        text (str): The camel-cased string to convert.\n\n    :rtype: :obj:`str`\n\n    Example:\n        >>> from flutils.strutils import camel_to_underscore\n        >>> camel_to_underscore('FooBar')\n        'foo_bar'\n    \"\"\"\n    return _CAMEL_TO_UNDERSCORE_RE.sub(r'_\\1', text).lower()", "is_method": false, "function_description": "Function that converts camel-cased strings into lowercase strings with words separated by underscores, facilitating consistent naming conventions and readability in code or data processing."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "convert_escaped_unicode_literal", "line_number": 100, "body": "def convert_escaped_unicode_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped Unicode literal hexadecimal character(s) to the\n    proper character(s).\n\n    This function will convert a string, that may contain escaped Unicode\n    literal hexadecimal characters, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped Unicode\n            hexadecimal.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped Unicode hexadecimal character converted\n            into the proper character.\n\n\n    The following Unicode literal formats are supported::\n\n        \\\\x31\n        \\\\u0031\n        \\\\U00000031\n\n    Examples:\n\n        Basic usage::\n\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.\u2605 \ud83d\uded1'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped Unicode literal characters that need to be\n        converted to proper characters::\n\n            $ export TEST='\\\\x31\\\\x2e\\\\u2605\\\\x20\\\\U0001f6d1'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_escaped_unicode_literal\n            >>> a = os.getenv('TEST')\n            >>> a\n            '\\\\\\\\x31\\\\\\\\x2e\\\\\\\\u2605\\\\\\\\x20\\\\\\\\U0001f6d1'\n            >>> convert_escaped_unicode_literal(a)\n            '1.\u2605 \ud83d\uded1'\n\n    \"\"\"\n    text_bytes = text.encode()\n    return text_bytes.decode('unicode_escape')", "is_method": false, "function_description": "Function that transforms strings containing escaped Unicode hexadecimal sequences into their actual Unicode characters, facilitating proper display or processing of such encoded text (e.g., from environment variables)."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "convert_escaped_utf8_literal", "line_number": 157, "body": "def convert_escaped_utf8_literal(\n        text: str\n) -> str:\n    \"\"\"Convert any escaped UTF-8 hexadecimal character bytes into the proper\n    string characters(s).\n\n    This function will convert a string, that may contain escaped UTF-8\n    literal hexadecimal bytes, into a string with the proper characters.\n\n    Args:\n        text (:obj:`str`): The string that may have escaped UTF8 hexadecimal.\n\n    Raises:\n         UnicodeDecodeError: if any of the escaped hexadecimal characters\n            are not proper UTF8 bytes.\n\n    :rtype:\n        :obj:`str`\n\n            A string with each escaped UTF8 hexadecimal character converted\n            into the proper character.\n\n    Examples:\n\n        Basic usage:\n\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = 'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test\u00a9'\n\n        This function is intended for cases when the value of an environment\n        variable contains escaped UTF-8 literal characters (bytes) that need\n        to be converted to proper characters::\n\n            $ export TEST='test\\\\\\\\xc2\\\\\\\\xa9'\n            $ python\n\n        ::\n\n            >>> import os\n            >>> from flutils.strutils import convert_raw_utf8_escape\n            >>> a = os.getenv('TEST')\n            >>> a\n            'test\\\\\\\\xc2\\\\\\\\xa9'\n            >>> convert_escaped_utf8_literal(a)\n            'test\u00a9'\n    \"\"\"\n    from flutils.codecs import register_codecs  # pylint:disable=C0415\n    register_codecs()\n    text_bytes = text.encode('utf-8')\n    text = text_bytes.decode('raw_utf8_escape')\n    return text", "is_method": false, "function_description": "Function that converts strings containing escaped UTF-8 hexadecimal byte sequences into their corresponding proper Unicode characters, useful for decoding environment variables or text with embedded escaped UTF-8 bytes."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/strutils.py", "function": "underscore_to_camel", "line_number": 212, "body": "def underscore_to_camel(\n        text: str,\n        lower_first: bool = True\n) -> str:\n    \"\"\"Convert a string with words separated by underscores to a camel-cased\n    string.\n\n    Args:\n        text (:obj:`str`): The camel-cased string to convert.\n        lower_first (:obj:`bool`, optional): Lowercase the first character.\n            Defaults to :obj:`True`.\n\n    :rtype: :obj:`str`\n\n    Examples:\n        >>> from flutils.strutils import underscore_to_camel\n        >>> underscore_to_camel('foo_bar')\n        'fooBar'\n        >>> underscore_to_camel('_one__two___',lower_first=False)\n        'OneTwo'\n    \"\"\"\n    out = ''.join([x.capitalize() or '' for x in text.split('_')])\n    if lower_first is True:\n        return out[:1].lower() + out[1:]\n    return out", "is_method": false, "function_description": "Function converting underscore-separated words into camelCase or PascalCase strings, supporting customizable capitalization of the first character. Useful for transforming identifiers to fit coding style conventions."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/cmdutils.py", "function": "_set_size", "line_number": 39, "body": "def _set_size(\n        fd: int,\n        columns: int = 80,\n        lines: int = 20\n) -> None:\n    \"\"\"Using the passed in file descriptor (of tty), set the terminal\n    size to that of the current terminal size.  If the current\n    terminal size cannot be found the given defaults will be used.\n    \"\"\"\n    # The following was adapted from: https://stackoverflow.com/a/6420070\n    size = struct.pack(\"HHHH\", lines, columns, 0, 0)\n    fcntl.ioctl(fd, termios.TIOCSWINSZ, size)", "is_method": false, "function_description": "Function to set the terminal window size using a given file descriptor, defaulting to specified dimensions if the current size cannot be determined. Useful for controlling terminal display layout programmatically."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/cmdutils.py", "function": "run", "line_number": 53, "body": "def run(\n        command: Sequence,\n        stdout: Optional[IO] = None,\n        stderr: Optional[IO] = None,\n        columns: int = 80,\n        lines: int = 24,\n        force_dimensions: bool = False,\n        interactive: bool = False,\n        **kwargs: Any\n) -> int:\n    \"\"\"Run the given command line command and return the command's\n    return code.\n\n    When the given ``command`` is executed, the command's stdout and\n    stderr outputs are captured in a pseudo terminal.  The captured\n    outputs are then added to this function's ``stdout`` and ``stderr``\n    IO objects.\n\n    This function will capture any ANSI escape codes in the output of\n    the given command.  This even includes ANSI colors.\n\n    Args:\n        command (str, List[str], Tuple[str]): The command to execute.\n        stdout (:obj:`typing.IO`, optional):  An input/output stream\n            that will hold the command's ``stdout``.  Defaults to:\n            :obj:`sys.stdout <sys.stdout>`; which will output\n            the command's ``stdout`` to the terminal.\n        stderr (:obj:`typing.IO`, optional):  An input/output stream\n            that will hold the command's ``stderr``.  Defaults to:\n            :obj:`sys.stderr <sys.stderr>`; which will output\n            the command's ``stderr`` to the terminal.\n        columns (int, optional): The number of character columns the pseudo\n            terminal may use.  If ``force_dimensions`` is :obj:`False`, this\n            will be the fallback columns value when the the current terminal's\n            column size cannot be found.  If ``force_dimensions`` is\n            :obj:`True`, this will be actual character column value.\n            Defaults to: ``80``.\n        lines (int, optional): The number of character lines the pseudo\n            terminal may use.  If ``force_dimensions`` is :obj:`False`, this\n            will be the fallback lines value when the the current terminal's\n            line size cannot be found.  If ``force_dimensions`` is :obj:`True`,\n            this will be actual character lines value.  Defaults to: ``24``.\n        force_dimensions (bool, optional): This controls how the given\n            ``columns`` and ``lines`` values are to be used.  A value of\n            :obj:`False` will use the given ``columns`` and ``lines`` as\n            fallback values if the current terminal dimensions cannot be\n            successfully queried.  A value of :obj:`True` will resize the\n            pseudo terminal using the given ``columns`` and ``lines`` values.\n            Defaults to: :obj:`False`.\n        interactive (bool, optional): A value of :obj:`True` will\n            interactively run the given ``command``.  Defaults to:\n            :obj:`False`.\n        **kwargs: Any additional key-word-arguments used with\n            :obj:`Popen <subprocess.Popen>`.  ``stdout`` and ``stderr``\n            will not be used if given in ``**default_kwargs``.  Defaults to:\n            ``{}``.\n\n    Returns:\n        int: The return value from running the given ``command``\n\n    Raises:\n        RuntimeError: When using ``interactive=True`` and the ``bash``\n            executable cannot be located.\n        OSError: Any errors raised when trying to read the pseudo terminal.\n\n    Example:\n        An example using :obj:`~flutils.cmdutils.run` in code::\n\n            from flutils.cmdutils import run\n            from io import BytesIO\n            import sys\n            import os\n\n            home = os.path.expanduser('~')\n            with BytesIO() as stream:\n                return_code = run(\n                    'ls \"%s\"' % home,\n                    stdout=stream,\n                    stderr=stream\n                )\n                text = stream.getvalue()\n            text = text.decode(sys.getdefaultencoding())\n            if return_code == 0:\n                print(text)\n            else:\n                print('Error: %s' % text)\n    \"\"\"\n    # Handle bytes\n    if hasattr(command, 'decode'):\n        raise TypeError(\n            \"The given 'command' must be of type: str, List[str] or \"\n            \"Tuple[str].\"\n        )\n    # Handle str\n    cmd: List[str]\n    if hasattr(command, 'capitalize'):\n        command = cast(str, command)\n        cmd = list(shlex.split(command))\n    else:\n        cmd = list(command)\n\n    if interactive is True:\n        bash = shutil.which('bash')\n        if not bash:\n            raise RuntimeError(\n                \"Unable to run the command:  %r, in interactive mode \"\n                \"because 'bash' could NOT be found on the system.\"\n                % ' '.join(command)\n            )\n        cmd = [bash, '-i', '-c'] + cmd\n\n    if stdout is None:\n        stdout = sys.stdout\n    stdout = cast(IO, stdout)\n\n    if stderr is None:\n        stderr = sys.stderr\n    stderr = cast(IO, stderr)\n\n    if force_dimensions is False:\n        columns, lines = shutil.get_terminal_size(\n            fallback=(columns, lines)\n        )\n\n    # The following is adapted from: https://stackoverflow.com/a/31953436\n\n    masters, slaves = zip(pty.openpty(), pty.openpty())\n\n    try:\n        # Resize the pseudo terminals to the size of the current terminal\n        for fd in chain(masters, slaves):\n            _set_size(\n                fd,\n                columns=columns,\n                lines=lines\n            )\n\n        kwargs['stdout'] = slaves[0]\n        kwargs['stderr'] = slaves[1]\n\n        if 'stdin' not in kwargs.keys():\n            kwargs['stdin'] = slaves[0]\n\n        with Popen(cmd, **kwargs) as p:\n\n            for fd in slaves:\n                os.close(fd)  # no input\n            readable = {\n                masters[0]: stdout,\n                masters[1]: stderr,\n            }\n            while readable:\n                for fd in select(readable, [], [])[0]:\n                    try:\n                        data = os.read(fd, 1024)  # read available\n                    except OSError as e:\n                        if e.errno != errno.EIO:\n                            raise\n                        del readable[fd]  # EIO means EOF on some systems\n                    else:\n                        if not data:  # EOF\n                            del readable[fd]\n                        else:\n                            if hasattr(readable[fd], 'encoding'):\n                                obj = readable[fd]\n                                obj = cast(TextIO, obj)\n                                data_str = data.decode(\n                                    obj.encoding\n                                )\n                                readable[fd].write(data_str)\n                            else:\n                                readable[fd].write(data)\n                            readable[fd].flush()\n    finally:\n        for fd in chain(masters, slaves):\n            try:\n                os.close(fd)\n            except OSError:\n                pass\n    return p.returncode", "is_method": false, "function_description": "Utility function that executes a command line command within a pseudo terminal, capturing and optionally streaming its stdout and stderr outputs with support for ANSI codes, terminal sizing, and interactive mode. Useful for running shell commands programmatically while managing output and terminal behaviors."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/cmdutils.py", "function": "prep_cmd", "line_number": 235, "body": "def prep_cmd(cmd: Sequence) -> Tuple[str, ...]:\n    \"\"\"Convert a given command into a tuple for use by\n    :obj:`subprocess.Popen`.\n\n    Args:\n        cmd (:obj:`Sequence <typing.Sequence>`): The command to be converted.\n\n    This is for converting a command of type string or bytes to a tuple of\n    strings for use by :obj:`subprocess.Popen`.\n\n    Example:\n\n        >>> from flutils.cmdutils import prep_cmd\n        >>> prep_cmd('ls -Flap')\n        ('ls', '-Flap')\n    \"\"\"\n    if not hasattr(cmd, 'count') or not hasattr(cmd, 'index'):\n        raise TypeError(\n            \"The given 'cmd', %r, must be of type: str, bytes, list or \"\n            \"tuple.  Got: %r\" % (\n                cmd,\n                type(cmd).__name__\n            )\n        )\n    if hasattr(cmd, 'append'):\n        out = copy(cmd)\n    else:\n        out = cmd\n    if hasattr(out, 'decode'):\n        out = cast(bytes, out)\n        out = out.decode(get_encoding())\n    if hasattr(out, 'encode'):\n        out = cast(str, out)\n        out = shlex.split(out)\n    out = tuple(out)\n    out = cast(Tuple[str], out)\n    item: str\n    for x, item in enumerate(out):\n        if not isinstance(item, (str, UserString)):\n            raise TypeError(\n                \"Item %r of the given 'cmd' is not of type 'str'.  \"\n                \"Got: %r\" % (\n                    x,\n                    type(item).__name__\n                )\n            )\n    return out", "is_method": false, "function_description": "Utility function that normalizes various command input types into a tuple of strings suitable for subprocess.Popen, ensuring consistent command formatting for reliable subprocess execution."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/cmdutils.py", "function": "output_encoding", "line_number": 340, "body": "def output_encoding(self) -> str:\n        return get_encoding(self._output_encoding)", "is_method": true, "class_name": "RunCmd", "function_description": "Returns the encoding used for command output, providing a standardized way to access the output text encoding setting."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/cmdutils.py", "function": "__call__", "line_number": 343, "body": "def __call__(\n            self,\n            cmd: Sequence,\n            **kwargs: Any,\n    ) -> CompletedProcess:\n        \"\"\"Run the given command and return the result.\n\n        Args:\n             cmd (:obj:`Sequence <typing.Sequence>`): The command\n             **kwargs: Any default_kwargs to pass to :obj:`subprocess.run`.\n                These default_kwargs will override any ``default_kwargs``\n                set in the constructor.\n\n        Raises:\n            FileNotFoundError: If the given ``cmd`` cannot be found.\n            ChildProcessError: If ``raise_error=True`` was set in this\n                class' constructor; and, the process (from running the\n                given ``cmd``) returns a non-zero value.\n            ValueError: If the given ``**kwargs`` has invalid arguments.\n\n        Example:\n\n            >>> from flutils.cmdutils import RunCmd\n            >>> from subprocess import PIPE\n            >>> import os\n            >>> run_command = RunCmd(stdout=PIPE, stderr=PIPE)\n            >>> result = run_command('ls -flap %s' % os.getcwd())\n            >>> result.return_code\n            0\n            >>> result.stdout\n            ...\n            >>> result = run_command('ls -flap %s' % os.path.expanduser('~'))\n        \"\"\"\n        cmd = prep_cmd(cmd)\n        cmd = cast(Tuple[str, ...], cmd)\n        # noinspection PyProtectedMember\n        keyword_args = self.default_kwargs._asdict()\n        keyword_args.update(kwargs)\n        result = subprocess.run(cmd, **keyword_args)\n        cmd = shlex.join(cmd)\n        cmd = cast(str, cmd)\n        stdout = result.stdout.decode(self.output_encoding)\n        stderr = result.stderr.decode(self.output_encoding)\n        if self.raise_error is True:\n            if result.returncode != 0:\n                raise ChildProcessError(\n                    f'Unable to run the command {cmd!r}:\\n\\n {stdout} '\n                    f'{stderr} Return code: {result.returncode}'\n                )\n        return CompletedProcess(\n            return_code=result.returncode,\n            stdout=stdout,\n            stderr=stderr,\n            cmd=cmd,\n        )", "is_method": true, "class_name": "RunCmd", "function_description": "Utility method of the RunCmd class that executes a given command with customizable options, returning detailed process results while optionally enforcing error handling on non-zero exit codes. It simplifies running shell commands and capturing their outputs programmatically."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/namedtupleutils.py", "function": "to_namedtuple", "line_number": 32, "body": "def to_namedtuple(obj: _AllowedTypes) -> Union[NamedTuple, Tuple, List]:\n    \"\"\"Convert particular objects into a namedtuple.\n\n    Args:\n        obj: The object to be converted (or have it's contents converted) to\n            a :obj:`NamedTuple <collections.namedtuple>`.\n\n    If the given type is of :obj:`list` or :obj:`tuple`, each item will be\n    recursively converted to a :obj:`NamedTuple <collections.namedtuple>`\n    provided the items can be converted. Items that cannot be converted\n    will still exist in the returned object.\n\n    If the given type is of :obj:`list` the return value will be a new\n    :obj:`list`.  This means the items are not changed in the given\n    ``obj``.\n\n    If the given type is of :obj:`Mapping <collections.abc.Mapping>`\n    (:obj:`dict`), keys that can be proper identifiers will become attributes\n    on the returned :obj:`NamedTuple <collections.namedtuple>`.  Additionally,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    are sorted alphabetically.\n\n    If the given type is of :obj:`OrderedDict <collections.OrderedDict>`,\n    the attributes of the returned :obj:`NamedTuple <collections.namedtuple>`\n    keep the same order as the given\n    :obj:`OrderedDict <collections.OrderedDict>` keys.\n\n    If the given type is of :obj:`SimpleNamespace <types.SimpleNamespace>`,\n    The attributes are sorted alphabetically in the returned\n    :obj:`NamedTuple <collections.NamedTuple>`.\n\n    Any identifier (key or attribute name) that starts with an underscore\n    cannot be used as a :obj:`NamedTuple <collections.namedtuple>` attribute.\n\n    All values are recursively converted.  This means a dictionary that\n    contains another dictionary, as one of it's values, will be converted\n    to a :obj:`NamedTuple <collections.namedtuple>` with the attribute's\n    value also converted to a :obj:`NamedTuple <collections.namedtuple>`.\n\n    :rtype:\n        :obj:`list`\n\n            A list with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`tuple`\n\n            A tuple with any of it's values converted to a\n            :obj:`NamedTuple <collections.namedtuple>`.\n\n        :obj:`NamedTuple <collections.namedtuple>`.\n\n    Example:\n        >>> from flutils.namedtupleutils import to_namedtuple\n        >>> dic = {'a': 1, 'b': 2}\n        >>> to_namedtuple(dic)\n        NamedTuple(a=1, b=2)\n    \"\"\"\n    return _to_namedtuple(obj)", "is_method": false, "function_description": "Function that converts various data structures into namedtuples, recursively transforming nested elements to enable attribute-style access while preserving order for OrderedDicts and lists. It facilitates structured, immutable representations of dictionaries, lists, tuples, and namespaces."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/namedtupleutils.py", "function": "_to_namedtuple", "line_number": 94, "body": "def _to_namedtuple(\n        obj: Any,\n        _started: bool = False\n) -> Any:\n    if _started is False:\n        raise TypeError(\n            \"Can convert only 'list', 'tuple', 'dict' to a NamedTuple; \"\n            \"got: (%r) %s\" % (type(obj).__name__, obj)\n        )\n    return obj", "is_method": false, "function_description": "Internal utility function that validates input types for conversion to a NamedTuple, raising an error if input is not a list, tuple, or dict."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/namedtupleutils.py", "function": "_", "line_number": 108, "body": "def _(\n        obj: Mapping,\n        _started: bool = False\n) -> Union[NamedTuple, Tuple]:\n    keys = []\n    for key in obj.keys():\n        if hasattr(key, 'capitalize'):\n            key = cast(str, key)\n            try:\n                validate_identifier(key, allow_underscore=False)\n            except SyntaxError:\n                continue\n            if key.isidentifier():\n                keys.append(key)\n    if not isinstance(obj, OrderedDict):\n        keys = tuple(sorted(keys))\n    args = []\n    for key in keys:\n        val: Any = obj[key]\n        val = _to_namedtuple(val, _started=True)\n        args.append(val)\n    if args:\n        # noinspection Mypy\n        make = namedtuple('NamedTuple', keys)  # type: ignore[misc]\n        # noinspection PyTypeChecker,PyArgumentList\n        out: NamedTuple = make(*args)\n        return out\n    make_empty = namedtuple('NamedTuple', '')\n    out = make_empty()\n    return out", "is_method": false, "function_description": "Converts a mapping's valid string keys and their values into a nested named tuple, preserving key order if an OrderedDict. Useful for converting dictionaries into immutable, attribute-accessible data structures."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/decorators.py", "function": "__get__", "line_number": 61, "body": "def __get__(self, obj: Any, cls):\n        if obj is None:\n            return self\n\n        if asyncio.iscoroutinefunction(self.func):\n            return self._wrap_in_coroutine(obj)\n\n        value = obj.__dict__[self.func.__name__] = self.func(obj)\n        return value", "is_method": true, "class_name": "cached_property", "function_description": "Core method of cached_property that computes and caches a property value on first access, supporting both synchronous and asynchronous functions to optimize repeated attribute retrieval."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/decorators.py", "function": "_wrap_in_coroutine", "line_number": 71, "body": "def _wrap_in_coroutine(self, obj):\n\n        @asyncio.coroutine\n        def wrapper():\n            future = asyncio.ensure_future(self.func(obj))\n            obj.__dict__[self.func.__name__] = future\n            return future\n\n        return wrapper()", "is_method": true, "class_name": "cached_property", "function_description": "Utility method in cached_property that wraps a synchronous function call into an asyncio coroutine, scheduling its execution and caching the resulting future on the object for asynchronous access."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/decorators.py", "function": "wrapper", "line_number": 74, "body": "def wrapper():\n            future = asyncio.ensure_future(self.func(obj))\n            obj.__dict__[self.func.__name__] = future\n            return future", "is_method": true, "class_name": "cached_property", "function_description": "As a method inside a cached_property class, this function wraps an asynchronous call to cache its future result on the instance to avoid redundant async executions. It provides an async caching mechanism for class properties."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "_validate_attr_identifier", "line_number": 51, "body": "def _validate_attr_identifier(\n        identifier: str,\n        line: str\n) -> str:\n    identifier = identifier.strip()\n    if identifier == '':\n        return identifier\n\n    error: str = ''\n    # Test if the given 'identifier' is valid to be\n    # used as an identifier.\n    is_valid: bool = identifier.isidentifier()\n\n    if is_valid is True and keyword.iskeyword(identifier):\n        is_valid = False\n        error = ' Cannot be a keyword.'\n\n    if is_valid is True and identifier in _BUILTIN_NAMES:\n        is_valid = False\n        error = ' Cannot be a builtin name.'\n\n    if is_valid is True and identifier in _DUNDERS:\n        is_valid = False\n        error = ' Cannot be a special dunder.'\n\n    if is_valid is False:\n        raise AttributeError(\n            f\"__attr_map__ contains an invalid item of: {line!r}. \"\n            f\"The identifier, {identifier!r}, is invalid.{error}\"\n        )\n    return identifier", "is_method": false, "function_description": "Validates whether a string qualifies as a valid, non-keyword, non-builtin, non-dunder attribute identifier, raising an error if it doesn't and returning the cleaned identifier if it does."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "_expand_attr_map_item", "line_number": 100, "body": "def _expand_attr_map_item(\n        foreign_name: str\n) -> _AttrMapping:\n    \"\"\"Used with map() to expand foreign-names into a named tuple.\n\n    See the :term:`foreign-name` documentation for the format of this string.\n\n    The tuple contains three parts:\n\n    - attr_name: If applicable, the attribute identifier that will be\n      set on the cherry-picking module.\n    - mod_name: The fullname of the module to be cherry-picked.\n    - mod_attr_name: If applicable the attribute identifier on the\n        cherry-picked module that will be bound to the ``attr_name``.\n        An empty str value indicates that the entire module will be used.\n    \"\"\"\n    if not isinstance(foreign_name, str):\n        raise AttributeError(\n            '__attr_map__ must be a tuple containing strings.'\n        )\n    mod, _, attr_name = foreign_name.partition(',')\n    mod_name, _, mod_attr_name = mod.strip().partition(':')\n    attr_name = _validate_attr_identifier(attr_name, foreign_name)\n    mod_name = mod_name.strip()\n    mod_attr_name = _validate_attr_identifier(mod_attr_name, foreign_name)\n    if attr_name == '':\n        if mod_attr_name != '':\n            attr_name = mod_attr_name\n        else:\n            attr_name = mod_name.split('.')[-1]\n    return _AttrMapping(\n        attr_name,\n        mod_name,\n        mod_attr_name,\n        foreign_name\n    )", "is_method": false, "function_description": "Utility function that parses a formatted string describing attribute mappings and converts it into a structured named tuple for use in module attribute cherry-picking. It standardizes and validates the components of the mapping for consistent internal use."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "_expand_attr_map", "line_number": 138, "body": "def _expand_attr_map(\n        attr_map: Tuple[str, ...]\n) -> Generator[_AttrMapping, None, None]:\n    \"\"\"Generator that expands the given attr_map and yields an _AttrMapping\n    named tuple.\n\n    An attr_map is a tuple with each row containing a :term:`foreign-name`\n    which is a specially formatted string.\n    \"\"\"\n    hold: Set = set()\n    for attr_mapping in map(_expand_attr_map_item, attr_map):\n        # Do not yield duplicates\n        if attr_mapping not in hold:\n            hold.add(attr_mapping)\n            yield attr_mapping", "is_method": false, "function_description": "Generates unique expanded attribute mappings from a given tuple of specially formatted foreign-name strings. It serves to produce distinct _AttrMapping items for use in attribute processing workflows."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "_parse_attr_map", "line_number": 174, "body": "def _parse_attr_map(\n        attr_map: Tuple[str, ...],\n        fullname: str\n) -> _CherryPickMap:\n    \"\"\"Parse the given tuple, with each row containing a :term:`foreign-name`\n    and return info needed for the cherry-picking-module.\n    \"\"\"\n    if not isinstance(attr_map, tuple):\n        raise CherryPickError(\n            fullname,\n            '__attr_map__ must be a tuple not %r'\n            % type(attr_map).__name__\n        )\n\n    modules: DefaultDict = defaultdict(list)\n    identifiers: Dict = dict()\n    # Catch any AttributeErrors (thrown in the generator) so that\n    # more information can be added to the error message.\n    try:\n        for attr_mapping in _expand_attr_map(attr_map):\n            modules[attr_mapping.mod_name].append(attr_mapping)\n            if attr_mapping.attr_name in identifiers:\n                raise CherryPickError(\n                    fullname,\n                    '__attr_map__ has the attribute %r defined multiple '\n                    'times' % attr_mapping.attr_name\n                )\n            identifiers[attr_mapping.attr_name] = attr_mapping.mod_name\n    except AttributeError as err:\n        raise CherryPickError(fullname, '%s' % err)\n\n    return _CherryPickMap(modules, identifiers)", "is_method": false, "function_description": "Parses a tuple of attribute mappings to organize and validate foreign attribute names for cherry-picking, returning a structured map of modules and identifiers for use in cherry-pick operations."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "cherry_pick", "line_number": 380, "body": "def cherry_pick(\n        namespace: dict\n) -> None:\n    \"\"\"Replace the calling :term:`cherry-pick-definition package module` with\n    a :term:`cherry-picking module`.\n\n    Use this function when there is a need to :term:`cherry-pick` modules.\n    This means the loading and executing, of a module, will be postponed\n    until an attribute is accessed.\n\n    Args:\n        namespace (:obj:`dict`): This should always be set to\n            :obj:`globals() <globals>`\n\n    :rtype: :obj:`None`\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential, the\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Example:\n        It is recommended to first build the root package (``__init__.py``)\n        as a normally desired root package. (Make sure that no functions\n        or classes are defined.  If needed, define these in a submodule).  For\n        example (``mymodule/__init__.py``)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from mymodule import mysubmoduleone\n            import mymodule.mysubmoduletwo as two\n            from mymodule.mysubmodulethree import afunction\n            from mymodule.mysubmodulethree import anotherfunction as anotherfuc\n\n            MYVAL = 123\n\n        To use the ``cherry_pick`` function, the root package module\n        (``__init__.py``) must be converted to a\n        :term:`cherry-pick-definition package module`. This example is the\n        result of rewriting the root package (above)::\n\n            \\\"\"\"This is the mymodule docstring.\\\"\"\"\n\n            from flutils.moduleutils import cherry_pick\n\n            MYVAL = 123\n\n            __attr_map__ = (\n                'mymodule.mysubmoduleone',\n                'mymodule.mysubmoduletwo,two',\n                'mymodule.mysubmodulethree:afunction',\n                'mymodule.mysubmodulethree:anotherfunction,anotherfuc'\n            )\n            __additional_attrs__ = dict(\n                MYVAL=MYVAL\n            )\n\n            cherry_pick(globals())\n\n        As you can see, the imports were each rewritten to a\n        :term:`foreign-name` and placed in the ``__attr_map__`` :obj:`tuple`.\n\n        Then, ``MYVAL`` was put in the ``__additional_attrs__`` dictionary.\n        Use this dictionary to pass any values to\n        :term:`cherry-picking module`.\n\n        And finally the ``cherry_pick`` function was called with\n        :obj:`globals() <globals>` as the only argument.\n\n        The result is the expected usage of ``mymodule``::\n\n            >> import mymodule\n            >> mymodule.anotherfunc()\n            foo bar\n\n        To test if a cherry-picked module has been loaded, or not::\n\n            >> import sys\n            >> sys.modules.get('mymodule.mysubmodulethree')\n\n        If you get nothing back, it means the cherry-picked module has not been\n        loaded.\n\n        Please be aware that there are some cases when all of the\n        cherry-picked modules will be loaded automatically. Using any\n        program that automatically inspects the cherry-picking module\n        will cause the all of the cherry-picked modules to be loaded.\n        Programs such as ipython and pycharm will do this.\n    \"\"\"\n    # Extract data from the namespace that will be cached and used in the\n    # creation of the cherry-picking module.\n    fullname = namespace.get('__name__')\n    fullname = cast(str, fullname)\n    origin = namespace.get('__file__', '')\n    origin = cast(str, origin)\n    path = namespace.get('__path__')\n    path = cast(List, path)\n\n    attr_map: Tuple[str, ...] = namespace.get('__attr_map__', tuple())\n    if not attr_map or not isinstance(attr_map, tuple):\n        raise ImportError(\n            '__attr_map__ must be defined as a tuple of strings in %r.'\n            % fullname\n        )\n\n    # variable to hold any additional attributes to be set on the\n    # cherry-picking module.\n    addtl_attrs = dict()\n\n    # Extract any relevant dunder values.  The most important value is 'loader'\n    # which must be passed through to 'module.__loader__' so that the\n    # 'pkg_resources' module can work as intended.  This is not to be confused\n    # with 'module.__spec__.loader' which is set to an instance of\n    # '_CherryPickingLoader' in the '_CherryPickFinder' class.\n    for key in _DUNDERS:\n        val: Any = namespace.get(key)\n        if val:\n            addtl_attrs[key] = val\n\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(f'Unable to find the spec for {fullname!r}')\n    addtl_attrs['__loader__'] = spec.loader\n\n    # Add any additional attributes to be passed to the cherry-picking module.\n    additional: Dict[str, Any] = namespace.get(\n        '__additional_attrs__',\n        dict()\n    )\n    if not isinstance(additional, dict):\n        raise ImportError(\n            '__additional_attrs__ must be a dict in %r'\n            % fullname\n        )\n    for key, val in additional.items():\n        if not isinstance(key, str):\n            raise ImportError(\n                '__additional_attrs__ keys must be strings. in %r'\n                % fullname\n            )\n        addtl_attrs[key] = val\n\n    # Add all of the extracted data to the _CherryPickFinder which will be\n    # used in the creation and execution of the cherry-picking module.\n    _CherryPickFinder.add(\n        fullname,\n        origin,\n        path,\n        attr_map,\n        **addtl_attrs\n    )\n\n    # Reload the module.\n    if fullname in sys.modules:\n        importlib.reload(sys.modules[fullname])\n    else:\n        importlib.import_module(fullname)", "is_method": false, "function_description": "Function that transforms a module into a cherry-picking module to defer loading and execution of its submodules or attributes until accessed, minimizing startup time by enabling lazy imports within a package namespace."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "lazy_import_module", "line_number": 664, "body": "def lazy_import_module(\n        name: str,\n        package: Optional[str] = None\n) -> ModuleType:\n    \"\"\"Lazy import a python module.\n\n    Args:\n        name (:obj:`str`): specifies what module to import in absolute or\n            relative terms (e.g. either ``pkg.mod`` or ``..mod``).\n        package (:obj:`str`, optional): If ``name`` is specified in relative\n            terms, then the ``package`` argument must be set to the name of the\n            package which is to act as the anchor for resolving the package\n            name.  Defaults to ``None``.\n\n    Raises:\n        ImportError: if the given ``name`` and ``package`` can not be loaded.\n\n    :rtype:\n        :obj:`Module <types.ModuleType>`\n\n        * The lazy imported module with the execution of it's loader postponed\n          until an attribute accessed.\n\n    .. Warning:: For projects where startup time is critical, this function\n        allows for potentially minimizing the cost of loading a module if it\n        is never used. For projects where startup time is not essential then\n        use of this function is heavily discouraged due to error messages\n        created during loading being postponed and thus occurring out of\n        context.\n\n    Examples:\n\n        >>> from flutils.moduleutils import lazy_import_module\n        >>> module = lazy_import_module('mymodule')\n\n        Relative import:\n\n        >>> module = lazy_import_module('.mysubmodule', package='mymodule')\n    \"\"\"\n    if isinstance(package, str) and package:\n        package = cast(str, package)\n        fullname = util.resolve_name(name, package=package)\n    else:\n        fullname = util.resolve_name(name, package='')\n\n    # Return the module if it's already been imported.\n    if fullname in sys.modules:\n        return sys.modules[fullname]\n\n    # Find the spec for the desired module\n    spec = util.find_spec(fullname)\n    if spec is None:\n        raise ImportError(\"name=%r package=%r\" % (name, package))\n\n    # Use the _LazyLoader to wrap the real loader. The _LazyLoader\n    # will only load and execute the module when an attribute is\n    # accessed.\n    loader = spec.loader\n    loader = cast(Loader, loader)\n    lazy_loader = _LazyLoader(loader)\n\n    # Within a Python import there is the process of module\n    # creation.  This is basically a two step process that\n    # is handled by the loaders <https://bit.ly/2Jz8E4C>:\n    #   1. Create a module namespace from a spec.\n    #      (see types.ModuleType <https://bit.ly/2qlJyyf>)\n    #   2. Execute the module in it's own namespace.\n    #\n    # All loaders SHOULD have a create_module(spec) which\n    # creates the namespace.  Additionally, all loaders\n    # should have the exec_module(module) which executes\n    # the module.\n    #\n    # In the case of any file loader the creation of a\n    # module namespace would require the loading of the.\n    # file.  Which would defeat the purpose of lazy loading.\n    # in this case the create_module(spec) method will\n    # return None.\n    #\n    # These two methods were added to the loaders\n    # in Python (version 3.4) and some of the loaders will\n    # not make use of these methods.  These loaders still\n    # use the load_module(fullname) method, which combines\n    # the two steps (mentioned above) into one method. In\n    # this case the create_module(spec) may not exist or\n    # will return None.\n\n    # Create a module namespace.\n    if hasattr(spec.loader, 'create_module'):\n        module = lazy_loader.create_module(spec)\n    else:\n        module = None\n\n    # If the loader doesn't make use of the create_module\n    # method, then create a very simple module namespace.\n    if module is None:\n        # create a dummy module to work with\n        module = ModuleType(fullname)\n\n    module.__spec__ = spec\n\n    # Have the _LazyLoader execute the module.  This\n    # preps the module namespace to be lazy loaded\n    # and makes the module a _LazyModule namespace.\n    lazy_loader.exec_module(module)\n\n    # Add the module to the python module map.\n    sys.modules[fullname] = module\n    return module", "is_method": false, "function_description": "Function that enables deferred loading of a Python module, postponing actual import execution until module attributes are accessed, which can reduce startup time by avoiding unnecessary immediate imports."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "__getattribute__", "line_number": 220, "body": "def __getattribute__(self, attr: str) -> Any:\n        _dict_ = object.__getattribute__(self, '__dict__')\n        _cherry_pick_map_: _CherryPickMap = _dict_.get(\n            '__cherry_pick_map__',\n            _EMPTY_CHERRY_PICK_MAP\n        )\n        if attr in _cherry_pick_map_.identifiers:\n            if _dict_[attr] == _CHERRY_PICK:\n                mod_name = _cherry_pick_map_.identifiers[attr]\n                module = importlib.import_module(mod_name)\n                for attr_mapping in _cherry_pick_map_.modules[mod_name]:\n                    if attr_mapping.mod_attr_name:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            getattr(module, attr_mapping.mod_attr_name)\n                        )\n                    else:\n                        object.__setattr__(\n                            self,\n                            attr_mapping.attr_name,\n                            module\n                        )\n        return object.__getattribute__(self, attr)", "is_method": true, "class_name": "_CherryPickingModule", "function_description": "Core method of _CherryPickingModule that dynamically imports and assigns module attributes on demand, enabling selective lazy loading of components to optimize resource usage during attribute access."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "create_module", "line_number": 252, "body": "def create_module(self, spec):\n        mod = ModuleType(spec.name)\n        mod.__spec__ = spec\n        return mod", "is_method": true, "class_name": "_CherryPickingLoader", "function_description": "Creates and returns a new module object based on the provided module specification, enabling dynamic module construction within the loader."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "exec_module", "line_number": 258, "body": "def exec_module(  # pylint: disable=no-self-use\n            self,\n            module: ModuleType\n    ) -> None:\n        \"\"\"Execute the given module in its own namespace.\"\"\"\n        spec = module.__spec__\n\n        # add the parsed attr_map info to the module.\n        module.__cherry_pick_map__ = _parse_attr_map(  # type: ignore\n            # The attr_map must be in spec.loader_state.\n            # It's okay for it to error here.  If it does\n            # error then _CherryPickFinder.add was not called.\n            spec.loader_state['attr_map'],  # type: ignore\n            module.__name__\n        )\n        # add the un-parsed attr_map to the module\n        module.__attr_map__ = spec.loader_state['attr_map']  # type: ignore\n\n        # This variable is used to set module.__all__\n        _all_ = list()\n\n        # loop through each attribute name to set the module\n        # attribute (of the same name) to a sentinel.\n        iden_keys = module.__cherry_pick_map__.identifiers.keys  # type: ignore\n        for attr in iden_keys():\n            _all_.append(attr)\n            setattr(module, attr, _CHERRY_PICK)\n\n        # loop through the additional attributes (set in cherry_pick())\n        # and set the module attribute (of the same name) to the value.\n        state_items = spec.loader_state['addtl_attrs'].items  # type: ignore\n        for key, val in state_items():\n            if not key.startswith('_'):\n                _all_.append(key)\n            setattr(module, key, val)\n\n        module.__all__ = list(sorted(_all_))  # type: ignore\n\n        # Change the module class so that __getattribute__ can be overridden.\n        module.__class__ = _CherryPickingModule", "is_method": true, "class_name": "_CherryPickingLoader", "function_description": "Executes a module by injecting attribute mappings and additional attributes, enabling selective attribute loading and customized attribute access within the module's namespace. It supports fine-grained control over module contents during import."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "__repr__", "line_number": 325, "body": "def __repr__(self):\n        return \"%s.%s\" % (__name__, self.__class__.__name__)", "is_method": true, "class_name": "_CherryPickFinder", "function_description": "Returns a string representation identifying the class and module name for instances of _CherryPickFinder."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "load", "line_number": 329, "body": "def load(cls):\n        \"\"\"Make sure this finder is at the top of sys.meta_path.\"\"\"\n        for obj in sys.meta_path:\n            if type(obj).__name__ == cls.__name__:\n                return obj\n        obj = cls()\n        sys.meta_path.insert(0, obj)\n        return obj", "is_method": true, "class_name": "_CherryPickFinder", "function_description": "Ensures an instance of _CherryPickFinder is the highest-priority import hook by placing it at the start of sys.meta_path, either by returning an existing one or creating and inserting a new instance."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "add", "line_number": 339, "body": "def add(\n            cls,\n            fullname: str,\n            origin: str,\n            path: Union[str, List],\n            attr_map: Tuple[str, ...],\n            **addtl_attrs: Any\n    ) -> None:\n        \"\"\"Add cherry-picking-module data to the cache.\"\"\"\n        obj = cls.load()\n        obj._cache[fullname] = dict(\n            fullname=fullname,\n            origin=origin,\n            path=path,\n            attr_map=attr_map,\n            addtl_attrs=addtl_attrs\n        )", "is_method": true, "class_name": "_CherryPickFinder", "function_description": "Adds metadata representing a cherry-picked module to a class-level cache for tracking and retrieval within the _CherryPickFinder class. This supports managing and referencing selectively imported modules and their attributes."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "find_spec", "line_number": 358, "body": "def find_spec(\n            self,\n            fullname: str,\n            path: str,  # pylint: disable=unused-argument\n            target: str = None  # pylint: disable=unused-argument\n    ) -> Union[ModuleSpec, None]:\n        \"\"\"Return a spec for a cherry-picking-module.\"\"\"\n        if fullname in self._cache:\n            loader_state = self._cache[fullname]\n            kwargs = dict(\n                origin=loader_state['origin'],\n                loader_state=loader_state,\n            )\n            loader = _CherryPickingLoader()\n            if loader_state['path']:\n                kwargs['is_package'] = True\n\n            # ModuleSpec docs: https://bit.ly/2Hlz1dv\n            return ModuleSpec(fullname, loader, **kwargs)\n        return None", "is_method": true, "class_name": "_CherryPickFinder", "function_description": "Provides a module specification for cherry-picking modules by retrieving cached loader information, enabling custom import behavior with package recognition when applicable. This supports selective module import within import system hooks."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "__getattribute__", "line_number": 560, "body": "def __getattribute__(self, attr: str) -> Any:\n        \"\"\"Trigger the load of the module and return the attribute.\"\"\"\n        # allow access to is_loaded without triggering the rest of this method.\n        if attr == 'is_loaded':\n            return object.__getattribute__(self, 'is_loaded')\n        # All module metadata must be garnered from __spec__ in order to avoid\n        # using mutated values.\n\n        # Stop triggering this method.\n        self.__class__ = ModuleType  # type: ignore\n\n        # Get the original name to make sure no object substitution occurred\n        # in sys.modules.\n        original_name = self.__spec__.name  # type: ignore\n\n        # Figure out exactly what attributes were mutated between the creation\n        # of the module and now.\n        attrs_then = self.__spec__.loader_state['__dict__']  # type: ignore\n        attrs_now = self.__dict__\n        attrs_updated = {}\n\n        for key, value in attrs_now.items():\n\n            # Code that set the attribute may have kept a reference to the\n            # assigned object, making identity more important than equality.\n            if key not in attrs_then:\n                attrs_updated[key] = value\n            elif id(attrs_now[key]) != id(attrs_then[key]):\n                attrs_updated[key] = value  # pragma: no cover\n        self.__spec__.loader.exec_module(self)  # type: ignore\n\n        # Indicate that the module is now loaded.\n        self.is_loaded = True\n\n        # If exec_module() was used directly there is no guarantee the module\n        # object was put into sys.modules.\n        if original_name in sys.modules:\n            if id(self) != id(sys.modules[original_name]):\n                raise ValueError(  # pragma: no cover\n                    f\"module object for {original_name!r} substituted in \"\n                    \"sys.modules during a lazy load\"\n                )\n        # Update after loading since that's what would happen in an eager\n        # loading situation.\n        self.__dict__.update(attrs_updated)\n        return getattr(self, attr)", "is_method": true, "class_name": "_LazyModule", "function_description": "Overrides attribute access to lazily load and initialize a module upon first access, ensuring correct module state and preventing recursive triggers. Useful for delaying module loading until actually needed, optimizing startup performance."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "__delattr__", "line_number": 607, "body": "def __delattr__(self, attr: str) -> None:\n        \"\"\"Trigger the load and then perform the deletion.\"\"\"\n        # To trigger the load and raise an exception if the attribute\n        # doesn't exist.\n        self.__getattribute__(attr)\n        delattr(self, attr)", "is_method": true, "class_name": "_LazyModule", "function_description": "Overrides attribute deletion to ensure the module is fully loaded before removing an attribute, preventing errors when deleting nonexistent attributes."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "__check_eager_loader", "line_number": 632, "body": "def __check_eager_loader(loader: Loader) -> None:\n        if not hasattr(loader, 'exec_module'):\n            raise TypeError(  # pragma: no cover\n                'loader must define exec_module()'\n            )", "is_method": true, "class_name": "_LazyLoader", "function_description": "Private utility method in _LazyLoader that validates a loader object to ensure it supports module execution by having an exec_module method, preventing incompatible loaders from being used."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "create_module", "line_number": 643, "body": "def create_module(self, spec: ModuleSpec) -> Optional[ModuleType]:\n        return self.loader.create_module(spec)", "is_method": true, "class_name": "_LazyLoader", "function_description": "Delegates module creation to the underlying loader, enabling lazy loading of modules when needed."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/moduleutils.py", "function": "exec_module", "line_number": 647, "body": "def exec_module(self, module: ModuleType):\n        \"\"\"Make the module load lazily.\"\"\"\n        module.__spec__.loader = self.loader  # type: ignore\n        module.__loader__ = self.loader\n\n        # Don't need to worry about deep-copying as trying to set an attribute\n        # on an object would have triggered the load,\n        # e.g. ``module.__spec__.loader = None`` would trigger a load from\n        # trying to access module.__spec__.\n        loader_state = dict()\n        loader_state['__dict__'] = module.__dict__.copy()\n        loader_state['__class__'] = module.__class__  # type: ignore\n        module.__spec__.loader_state = loader_state  # type: ignore\n        module.__class__ = _LazyModule", "is_method": true, "class_name": "_LazyLoader", "function_description": "Method of the _LazyLoader class that configures a module for lazy loading by adjusting its loader and replacing its class to defer execution until needed. This enables efficient module import management and reduced startup overhead."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "len_without_ansi", "line_number": 25, "body": "def len_without_ansi(seq: Sequence) -> int:\n    \"\"\"Return the character length of the given\n    :obj:`Sequence <typing.Sequence>` without counting any ANSI codes.\n\n    *New in version 0.6*\n\n    Args:\n         seq (:obj:`Sequence <typing.Sequence>`): A string or a list/tuple\n             of strings.\n\n    :rtype:\n        :obj:`int`\n\n    Example:\n        >>> from flutils.txtutils import len_without_ansi\n        >>> text = '\\\\x1b[38;5;209mfoobar\\\\x1b[0m'\n        >>> len_without_ansi(text)\n        6\n    \"\"\"\n    if hasattr(seq, 'capitalize'):\n        _text: str = cast(str, seq)\n        seq = [c for c in _ANSI_RE.split(_text) if c]\n    seq = [c for c in chain(*map(_ANSI_RE.split, seq)) if c]\n    seq = cast(Sequence[str], seq)\n    out = 0\n    for text in seq:\n        if hasattr(text, 'capitalize'):\n            if text.startswith('\\x1b[') and text.endswith('m'):\n                continue\n            else:\n                out += len(text)\n    return out", "is_method": false, "function_description": "Function that calculates the visible character length of a string or sequence of strings by excluding any ANSI escape codes. It is useful for measuring text length when colored or formatted console output is involved."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "initial_indent", "line_number": 214, "body": "def initial_indent(self) -> str:  # type: ignore\n        return self.__initial_indent", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Returns the initial indentation string used by AnsiTextWrapper for formatting wrapped text lines. This method provides access to the configured prefix applied at the start of wrapped text blocks."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "initial_indent", "line_number": 218, "body": "def initial_indent(self, value: str) -> None:\n        self.__initial_indent = value\n        if 'initial_indent_len' in self.__dict__.keys():\n            del self.__dict__['initial_indent_len']", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Setter method of AnsiTextWrapper that updates the initial indentation string and resets its cached length for consistent text formatting."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "initial_indent_len", "line_number": 224, "body": "def initial_indent_len(self) -> int:\n        if not self.initial_indent:\n            return 0\n        return len_without_ansi(self.initial_indent)", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Returns the length of the wrapper's initial indent string excluding ANSI escape codes, providing the visible character count for accurate text alignment."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "subsequent_indent", "line_number": 230, "body": "def subsequent_indent(self) -> str:  # type: ignore\n        return self.__subsequent_indent", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Returns the string used to indent all lines except the first in wrapped text. This enables consistent formatting for multiline text outputs."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "subsequent_indent", "line_number": 234, "body": "def subsequent_indent(self, value: str) -> None:\n        self.__subsequent_indent = value\n        if 'subsequent_indent_len' in self.__dict__.keys():\n            del self.__dict__['subsequent_indent_len']", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Sets the indentation string for lines after the first in wrapped text, updating internal state to reflect this change. It customizes how multiline text is visually indented in the AnsiTextWrapper class."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "subsequent_indent_len", "line_number": 240, "body": "def subsequent_indent_len(self) -> int:\n        if not self.subsequent_indent:\n            return 0\n        return len_without_ansi(self.subsequent_indent)", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Utility method of AnsiTextWrapper that returns the visible length of the subsequent line indent, excluding any ANSI escape sequences. It supports accurate text wrapping with colored or formatted strings."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "placeholder_len", "line_number": 256, "body": "def placeholder_len(self) -> int:\n        if not self.placeholder.lstrip():\n            return 0\n        return len_without_ansi(self.placeholder)", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Utility method of AnsiTextWrapper that returns the length of its placeholder text excluding ANSI escape codes, or zero if the placeholder is empty or whitespace-only."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "_split", "line_number": 261, "body": "def _split(self, text: str) -> List[str]:\n        \"\"\"Override to split on ANSI codes.\"\"\"\n        chunks = super()._split(text)\n        # The following code describes the following list comprehension:\n        #\n        # for chunk in chunks:\n        #     for c in _ANSI_RE.split(chunk):\n        #         if c:\n        #             out.append(c)\n        # return out\n        return [c for c in chain(*map(_ANSI_RE.split, chunks)) if c]", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Private method in AnsiTextWrapper that splits text by both whitespace and ANSI escape codes, facilitating accurate text wrapping that respects embedded ANSI formatting sequences."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "_wrap_chunks", "line_number": 273, "body": "def _wrap_chunks(self, chunks: List[str]) -> List[str]:\n\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            indent_len = len_without_ansi(indent)\n            _placeholder_len = len_without_ansi(self.placeholder.lstrip())\n            if indent_len + _placeholder_len > self.width:\n                raise ValueError('placeholder too large for max width')\n            del _placeholder_len\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            indent_len = len_without_ansi(indent)\n\n            # Maximum width for this line.\n            width = self.width - indent_len\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len_without_ansi(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n                    continue\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len_without_ansi(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len_without_ansi, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if (self.drop_whitespace and\n                    cur_line and\n                    cur_line[-1].strip() == ''):\n                cur_len -= len_without_ansi(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                        len(lines) + 1 < self.max_lines or\n                        (not chunks or\n                         self.drop_whitespace and\n                         len(chunks) == 1 and\n                         not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n\n                    # Add the placeholder to the current line if it fits.\n                    # If it does NOT fit, remove each chunk until it does.\n                    while cur_line:\n                        # If the current line's last chunk has a length\n                        # greater than zero; and, the length of the current\n                        # line plus the length of the placeholder is less\n                        # than or equal to the maximum length for this line...\n                        if (cur_line[-1].strip() and\n                                cur_len + self.placeholder_len <= width):\n                            # Add the placeholder to the current line's chunks\n                            cur_line.append(self.placeholder)\n                            # Concatenate the indent and the combined\n                            # current line's chunks into a single line.\n                            # Then add this line to the list of lines.\n                            lines.append(indent + ''.join(cur_line))\n                            break\n\n                        cur_len -= len_without_ansi(cur_line[-1])\n                        # delete the current line's last chunk\n                        del cur_line[-1]\n\n                    # Because the placeholder could NOT fit on the current\n                    # line, try to add the place holder on the previous line.\n                    else:\n                        if lines:\n                            # Get the previous line\n                            prev_line = lines[-1].rstrip()\n                            # Get the previous line length\n                            prev_line_len = len_without_ansi(prev_line)\n\n                            # If the previous line's length plus the\n                            # placeholder's length is less than the\n                            # allowed line width...\n                            if (prev_line_len + self.placeholder_len <=\n                                    self.width):\n                                # Add the placeholder at the end of the\n                                # previous line\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Core utility method of AnsiTextWrapper that breaks a list of string chunks into wrapped lines respecting width, indentation, max lines, and placeholders, facilitating formatted ANSI text output with controlled line length and overflow indication."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "wrap", "line_number": 398, "body": "def wrap(self, text: str) -> List[str]:\n        \"\"\"Wraps the single paragraph in the given ``text`` so every line is\n        at most ``width`` characters long. All wrapping options are taken\n        from instance attributes of the\n        :obj:`~flutils.txtutils.AnsiTextWrapper` instance.\n\n        Args:\n            text (str): The text to be wrapped.\n\n        Returns:\n            A ``List[str]`` of output lines, without final newlines.\n            If the wrapped output has no content, the returned list is\n            empty.\n        \"\"\"\n        return super().wrap(text)", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Provides line-wrapping of a single paragraph to fit within a specified width, respecting ANSI text attributes. It returns the wrapped lines as a list, facilitating formatted text display or processing."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/txtutils.py", "function": "fill", "line_number": 414, "body": "def fill(self, text: str) -> str:\n        \"\"\"Wraps a single paragraph.\n\n        Args:\n            text (str): The text to be wrapped.\n\n         Returns:\n              A single :obj:`str` containing the wrapped paragraph.\n        \"\"\"\n        return super().fill(text)", "is_method": true, "class_name": "AnsiTextWrapper", "function_description": "Method of AnsiTextWrapper that wraps a single paragraph of text, preserving ANSI escape sequences, to fit within a specified width. It provides formatted text output suitable for terminal display with color or style codes."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "chmod", "line_number": 51, "body": "def chmod(\n        path: _PATH,\n        mode_file: Optional[int] = None,\n        mode_dir: Optional[int] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change the mode of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    This function will **NOT** change the mode of:\n\n    - symlinks (symlink targets that are files or directories will be changed)\n    - sockets\n    - fifo\n    - block devices\n    - char devices\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory to have it's mode changed.  This\n            value can be a :term:`glob pattern`.\n        mode_file (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a file or a symlink target that is a file.\n            Defaults to ``0o600``.\n        mode_dir (:obj:`int`, optional): The mode applied to the given\n            ``path`` that is a directory or a symlink target that is a\n            directory. Defaults to ``0o700``.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True`` will\n            chmod the parent directory of the given ``path`` that contains a\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chmod\n        >>> chmod('~/tmp/flutils.tests.osutils.txt', 0o660)\n\n        Supports a :term:`glob pattern`.  So to recursively change the mode\n        of a directory just do:\n\n        >>> chmod('~/tmp/**', mode_file=0o644, mode_dir=0o770)\n\n        To change the mode of a directory's immediate contents:\n\n        >>> chmod('~/tmp/*')\n\n    \"\"\"\n\n    path = normalize_path(path)\n\n    if mode_file is None:\n        mode_file = 0o600\n\n    if mode_dir is None:\n        mode_dir = 0o700\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() is True:\n                    sub_path.chmod(mode_dir)\n                elif sub_path.is_file():\n                    sub_path.chmod(mode_file)\n\n        # Path().glob() returns an iterator that will\n        # raise NotImplementedError if there\n        # are no results from the glob pattern.\n        except NotImplementedError:\n            pass\n\n        else:\n            if include_parent is True:\n                parent = path.parent\n                if parent.is_dir():\n                    parent.chmod(mode_dir)\n    else:\n        if path.exists() is True:\n            if path.is_dir():\n                path.chmod(mode_dir)\n            elif path.is_file():\n                path.chmod(mode_file)", "is_method": false, "function_description": "Utility function that changes file or directory permissions for a given path or glob pattern, optionally including the parent directory, while excluding special file types like symlinks, sockets, and devices. It supports applying different modes to files and directories to manage access control."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "chown", "line_number": 138, "body": "def chown(\n        path: _PATH,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n        include_parent: bool = False\n) -> None:\n    \"\"\"Change ownership of a path.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does NOT exist, nothing will be done.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the file or directory that will have it's ownership\n            changed.  This value can be a :term:`glob pattern`.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to set\n            the owner of ``path``.  A value of ``'-1'`` will leave the\n            owner unchanged.  Defaults to the \"login name\" of the current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of ``path``.  A value of ``'-1'`` will leave the\n            group unchanged.  Defaults to the current user's group.\n        include_parent (:obj:`bool`, optional): A value of :obj:`True` will\n            chown the parent directory of the given ``path`` that contains\n            a :term:`glob pattern`.  Defaults to :obj:`False`.\n\n    Raises:\n        OSError: If the given :obj:`user` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given :obj:`group` does not exist as a \"group\n            name\" for this operating system.\n\n    :rtype: :obj:`None`\n\n    Examples:\n        >>> from flutils.pathutils import chown\n        >>> chown('~/tmp/flutils.tests.osutils.txt')\n\n        Supports a :term:`glob pattern`.  So to recursively change the\n        ownership of a directory just do:\n\n        >>> chown('~/tmp/**')\n\n\n        To change ownership of all the directory's immediate contents:\n\n        >>> chown('~/tmp/*', user='foo', group='bar')\n\n    \"\"\"\n    path = normalize_path(path)\n    if isinstance(user, str) and user == '-1':\n        uid = -1\n    else:\n        uid = get_os_user(user).pw_uid\n\n    if isinstance(user, str) and group == '-1':\n        gid = -1\n    else:\n        gid = get_os_group(group).gr_gid\n\n    if '*' in path.as_posix():\n        try:\n            for sub_path in Path().glob(path.as_posix()):\n                if sub_path.is_dir() or sub_path.is_file():\n                    os.chown(sub_path.as_posix(), uid, gid)\n        except NotImplementedError:\n            # Path().glob() returns an iterator that will\n            # raise NotImplementedError if there\n            # are no results from the glob pattern.\n            pass\n        else:\n            if include_parent is True:\n                path = path.parent\n                if path.is_dir() is True:\n                    os.chown(path.as_posix(), uid, gid)\n    else:\n        if path.exists() is True:\n            os.chown(path.as_posix(), uid, gid)", "is_method": false, "function_description": "Utility function that changes the ownership of files or directories matching a given path pattern, optionally including the parent directory. It supports user and group specification, recursive glob patterns, and safeguards non-existing paths."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "directory_present", "line_number": 219, "body": "def directory_present(\n        path: _PATH,\n        mode: Optional[int] = None,\n        user: Optional[str] = None,\n        group: Optional[str] = None,\n) -> Path:\n    \"\"\"Ensure the state of the given :obj:`path` is present and a directory.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    If the given ``path`` does **NOT** exist, it will be created as a\n    directory.\n\n    If the parent paths of the given ``path`` do not exist, they will also be\n    created with the ``mode``, ``user`` and ``group``.\n\n    If the given ``path`` does exist as a directory, the ``mode``, ``user``,\n    and :``group`` will be applied.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path of the directory.\n        mode (:obj:`int`, optional): The mode applied to the ``path``.\n            Defaults to ``0o700``.\n        user (:obj:`str` or :obj:`int`, optional): The \"login name\" used to\n            set the owner of the given ``path``.  A value of ``'-1'`` will\n            leave the owner unchanged.  Defaults to the \"login name\" of the\n            current user.\n        group (:obj:`str` or :obj:`int`, optional): The group name used to set\n            the group of the given ``path``.  A value of ``'-1'`` will leave\n            the group unchanged.  Defaults to the current user's group.\n\n    Raises:\n        ValueError: if the given ``path`` contains a glob pattern.\n        ValueError: if the given ``path`` is not an absolute path.\n        FileExistsError: if the given ``path`` exists and is not a directory.\n        FileExistsError: if a parent of the given ``path`` exists and is\n            not a directory.\n\n    :rtype: :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n        >>> from flutils.pathutils import directory_present\n        >>> directory_present('~/tmp/test_path')\n        PosixPath('/Users/len/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n\n    if '*' in path.as_posix():\n        raise ValueError(\n            'The path: %r must NOT contain any glob patterns.'\n            % path.as_posix()\n        )\n    if path.is_absolute() is False:\n        raise ValueError(\n            'The path: %r must be an absolute path.  A path is considered '\n            'absolute if it has both a root and (if the flavour allows) a '\n            'drive.'\n            % path.as_posix()\n        )\n\n    # Create a queue of paths to be created as directories.\n    paths: Deque = deque()\n\n    path_exists_as = exists_as(path)\n    if path_exists_as == '':\n        paths.append(path)\n    elif path_exists_as != 'directory':\n        raise FileExistsError(\n            'The path: %r can NOT be created as a directory because it '\n            'already exists as a %s.' % (path.as_posix(), path_exists_as)\n        )\n\n    parent = path.parent\n    child = path\n\n    # Traverse the path backwards and add any directories that\n    # do no exist to the path queue.\n    while child.as_posix() != parent.as_posix():\n        parent_exists_as = exists_as(parent)\n        if parent_exists_as == '':\n            paths.appendleft(parent)\n            child = parent\n            parent = parent.parent\n        elif parent_exists_as == 'directory':\n            break\n        else:\n            raise FileExistsError(\n                'Unable to create the directory: %r because the'\n                'parent path: %r exists as a %s.'\n                % (path.as_posix, parent.as_posix(), parent_exists_as)\n            )\n\n    if mode is None:\n        mode = 0o700\n\n    if paths:\n        for build_path in paths:\n            build_path.mkdir(mode=mode)\n            chown(build_path, user=user, group=group)\n    else:\n        # The given path already existed only need to do a chown.\n        chmod(path, mode_dir=mode)\n        chown(path, user=user, group=group)\n\n    return path", "is_method": false, "function_description": "Utility function that ensures a specified absolute path exists as a directory, creating the directory and any missing parent directories with given permissions and ownership if needed, or updating them if the directory already exists."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "exists_as", "line_number": 336, "body": "def exists_as(path: _PATH) -> str:\n    \"\"\"Return a string describing the file type if it exists.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to check for existence.\n\n    :rtype:\n        :obj:`str`\n\n        * ``''`` (empty string): if the given ``path`` does NOT exist; or,\n          is a broken symbolic link; or, other errors (such as permission\n          errors) are propagated.\n        * ``'directory'``: if the given ``path`` points to a directory or\n          is a symbolic link pointing to a directory.\n        * ``'file'``: if the given ``path`` points to a regular file or is a\n          symbolic link pointing to a regular file.\n        * ``'block device'``: if the given ``path`` points to a block device or\n          is a symbolic link pointing to a block device.\n        * ``'char device'``: if the given ``path`` points to a character device\n          or is a symbolic link pointing to a character device.\n        * ``'FIFO'``: if the given ``path`` points to a FIFO or is a symbolic\n          link pointing to a FIFO.\n        * ``'socket'``: if the given ``path`` points to a Unix socket or is a\n          symbolic link pointing to a Unix socket.\n\n    Example:\n        >>> from flutils.pathutils import exists_as\n        >>> exists_as('~/tmp')\n        'directory'\n    \"\"\"\n    path = normalize_path(path)\n\n    if path.is_dir():\n        return 'directory'\n    if path.is_file():\n        return 'file'\n    if path.is_block_device():\n        return 'block device'\n    if path.is_char_device():\n        return 'char device'\n    if path.is_fifo():\n        return 'FIFO'\n    if path.is_socket():\n        return 'socket'\n    return ''", "is_method": false, "function_description": "Utility function that checks if a given path exists and returns a string describing its file type (e.g., directory, file, socket), enabling programs to identify the nature of filesystem objects at specified locations."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "find_paths", "line_number": 387, "body": "def find_paths(\n        pattern: _PATH\n) -> Generator[Path, None, None]:\n    \"\"\"Find all paths that match the given :term:`glob pattern`.\n\n    This function pre-processes the given ``pattern`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        pattern (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to find; which may contain a :term:`glob pattern`.\n\n    :rtype:\n        :obj:`Generator <typing.Generator>`\n\n    Yields:\n        :obj:`pathlib.PosixPath` or :obj:`pathlib.WindowsPath`\n\n    Example:\n        >>> from flutils.pathutils import find_paths\n        >>> list(find_paths('~/tmp/*'))\n        [PosixPath('/home/test_user/tmp/file_one'),\n        PosixPath('/home/test_user/tmp/dir_one')]\n\n    \"\"\"\n    pattern = normalize_path(pattern)\n    search = pattern.as_posix()[len(pattern.anchor):]\n    yield from Path(pattern.anchor).glob(search)", "is_method": false, "function_description": "Function that generates all filesystem paths matching a specified glob pattern, handling path normalization to support flexible file and directory searching."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "get_os_group", "line_number": 417, "body": "def get_os_group(name: _STR_OR_INT_OR_NONE = None) -> grp.struct_group:\n    \"\"\"Get an operating system group object.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"group name\" or ``gid``.\n            Defaults to the current users's group.\n\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"group\n            name\" for this operating system.\n        OSError: If the given ``name`` is a ``gid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_group <grp>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_group\n        >>> get_os_group('bar')\n        grp.struct_group(gr_name='bar', gr_passwd='*', gr_gid=2001,\n        gr_mem=['foo'])\n    \"\"\"\n    if name is None:\n        name = get_os_user().pw_gid\n        name = cast(int, name)\n    if isinstance(name, int):\n        try:\n            return grp.getgrgid(name)\n        except KeyError:\n            raise OSError(\n                'The given gid: %r, is not a valid gid for this operating '\n                'system.' % name\n            )\n    try:\n        return grp.getgrnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"group name\" '\n            'for this operating system.' % name\n        )", "is_method": false, "function_description": "Utility function that returns detailed information about an OS group by group name or GID, defaulting to the current user\u2019s group. It provides a standardized OS group object useful for system and user group management tasks."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "get_os_user", "line_number": 461, "body": "def get_os_user(name: _STR_OR_INT_OR_NONE = None) -> pwd.struct_passwd:\n    \"\"\"Return an user object representing an operating system user.\n\n    Args:\n        name (:obj:`str` or :obj:`int`, optional): The \"login name\" or\n            ``uid``.  Defaults to the current user's \"login name\".\n    Raises:\n        OSError: If the given ``name`` does not exist as a \"login\n            name\" for this operating system.\n        OSError: If the given ``name`` is an ``uid`` and it does not\n            exist.\n\n    :rtype:\n        :obj:`struct_passwd <pwd>`\n\n        * A tuple like object.\n\n    Example:\n        >>> from flutils.pathutils import get_os_user\n        >>> get_os_user('foo')\n        pwd.struct_passwd(pw_name='foo', pw_passwd='********', pw_uid=1001,\n        pw_gid=2001, pw_gecos='Foo Bar', pw_dir='/home/foo',\n        pw_shell='/usr/local/bin/bash')\n    \"\"\"\n    if isinstance(name, int):\n        try:\n            return pwd.getpwuid(name)\n        except KeyError:\n            raise OSError(\n                'The given uid: %r, is not a valid uid for this operating '\n                'system.' % name\n            )\n    if name is None:\n        name = getpass.getuser()\n    try:\n        return pwd.getpwnam(name)\n    except KeyError:\n        raise OSError(\n            'The given name: %r, is not a valid \"login name\" '\n            'for this operating system.' % name\n        )", "is_method": false, "function_description": "Function that fetches detailed information about an operating system user by username or user ID, defaulting to the current user. It provides access to user account data for system-related operations."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "normalize_path", "line_number": 505, "body": "def normalize_path(path: _PATH) -> Path:\n    \"\"\"Normalize a given path.\n\n    The given ``path`` will be normalized in the following process.\n\n    #. :obj:`bytes` will be converted to a :obj:`str` using the encoding\n       given by :obj:`getfilesystemencoding() <sys.getfilesystemencoding>`.\n    #. :obj:`PosixPath <pathlib.PosixPath>` and\n       :obj:`WindowsPath <pathlib.WindowsPath>` will be converted\n       to a :obj:`str` using the :obj:`as_posix() <pathlib.PurePath.as_posix>`\n       method.\n    #. An initial component of ``~`` will be replaced by that user\u2019s\n       home directory.\n    #. Any environment variables will be expanded.\n    #. Non absolute paths will have the current working directory from\n       :obj:`os.getcwd() <os.cwd>`prepended.  If needed, use\n       :obj:`os.chdir() <os.chdir>` to change the current working directory\n       before calling this function.\n    #. Redundant separators and up-level references will be normalized, so\n       that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all become\n       ``A/B``.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to be normalized.\n\n    :rtype:\n        :obj:`Path <pathlib.Path>`\n\n        * :obj:`PosixPath <pathlib.PosixPath>` or\n          :obj:`WindowsPath <pathlib.WindowsPath>` depending on the system.\n\n        .. Note:: :obj:`Path <pathlib.Path>` objects are immutable. Therefore,\n           any given ``path`` of type :obj:`Path <pathlib.Path>` will not be\n           the same object returned.\n\n    Example:\n\n        >>> from flutils.pathutils import normalize_path\n        >>> normalize_path('~/tmp/foo/../bar')\n        PosixPath('/home/test_user/tmp/bar')\n\n    \"\"\"\n    path = cast(PathLike, path)\n    path = os.path.expanduser(path)\n    path = cast(PathLike, path)\n    path = os.path.expandvars(path)\n    path = cast(PathLike, path)\n    if os.path.isabs(path) is False:\n        path = os.path.join(os.getcwd(), path)\n    path = cast(PathLike, path)\n    path = os.path.normpath(path)\n    path = cast(PathLike, path)\n    path = os.path.normcase(path)\n    path = cast(PathLike, path)\n    return Path(path)", "is_method": false, "function_description": "Utility function that converts and normalizes any given filesystem path by expanding user/home directories, environment variables, resolving relative paths, and ensuring a consistent absolute Path object suitable for cross-platform file handling."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "_normalize_path_bytes", "line_number": 564, "body": "def _normalize_path_bytes(path: bytes) -> Path:\n    out: str = path.decode(sys.getfilesystemencoding())\n    return normalize_path(out)", "is_method": false, "function_description": "Helper function that converts a byte-formatted file path to a normalized Path object using the system's file system encoding."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "_normalize_path_pathlib", "line_number": 570, "body": "def _normalize_path_pathlib(path: Path) -> Path:\n    return normalize_path(path.as_posix())", "is_method": false, "function_description": "Helper function that converts a Path object to a normalized POSIX-style path string for consistent path representation and processing."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/pathutils.py", "function": "path_absent", "line_number": 574, "body": "def path_absent(\n        path: _PATH,\n) -> None:\n    \"\"\"Ensure the given ``path`` does **NOT** exist.\n\n    *New in version 0.4.*\n\n    If the given ``path`` does exist, it will be deleted.\n\n    If the given ``path`` is a directory, this function will\n    recursively delete all of the directory's contents.\n\n    This function processes the given ``path`` with\n    :obj:`~flutils.normalize_path`.\n\n    Args:\n        path (:obj:`str`, :obj:`bytes` or :obj:`Path <pathlib.Path>`):\n            The path to remove.\n\n    :rtype: :obj:`None`\n\n    Example:\n        >>> from flutils.pathutils import path_absent\n        >>> path_absent('~/tmp/test_path')\n\n    \"\"\"\n    path = normalize_path(path)\n    path = path.as_posix()\n    path = cast(str, path)\n    if os.path.exists(path):\n        if os.path.islink(path):\n            os.unlink(path)\n        elif os.path.isdir(path):\n            for root, dirs, files in os.walk(path, topdown=False):\n                for name in files:\n                    p = os.path.join(root, name)\n                    if os.path.isfile(p) or os.path.islink(p):\n                        os.unlink(p)\n                for name in dirs:\n                    p = os.path.join(root, name)\n                    if os.path.islink(p):\n                        os.unlink(p)\n                    else:\n                        os.rmdir(p)\n            if os.path.isdir(path):\n                os.rmdir(path)\n        else:\n            os.unlink(path)", "is_method": false, "function_description": "Utility function that ensures a specified file system path does not exist by deleting it if found; it handles files, symbolic links, and recursively removes directories and their contents."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/raw_utf8_escape.py", "function": "_each_utf8_hex", "line_number": 16, "body": "def _each_utf8_hex(text: _Str) -> Generator[str, None, None]:\n    for char in text:\n        if ord(char) < 128 and char.isprintable():\n            yield char\n            continue\n        utf8_bytes = char.encode('utf8')\n        for utf8_byte in utf8_bytes:\n            str_hex = '\\\\%s' % hex(utf8_byte)[1:]\n            yield str_hex", "is_method": false, "function_description": "Utility function that iterates through a string yielding printable ASCII characters as-is and encoding non-ASCII characters into their UTF-8 hexadecimal escape sequences. It enables consistent and readable representation of mixed character strings."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/raw_utf8_escape.py", "function": "encode", "line_number": 27, "body": "def encode(\n        text: _Str,\n        errors: _Str = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert a :obj:`str`, that may contain escaped utf8 hexadecimal, to\n    bytes of escaped utf8 hexadecimal.\n\n    Args:\n        text (str or :obj:`~UserString`): The string input.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        bytes: The given ``text`` converted into escaped utf8 bytes.\n        int: The number of given ``text`` characters consumed\n\n    Raises:\n         UnicodeEncodeError: if the given ``text`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n    \"\"\"\n\n    # Convert the given 'text', that are of type UserString into a str.\n    # if isinstance(text, UserString):\n    #     text_input = str(text)\n    # else:\n\n    text_input = str(text)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the string into utf-8 bytes\n    text_bytes_utf8 = text_input.encode('utf-8')\n    text_bytes_utf8 = cast(bytes, text_bytes_utf8)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = text_bytes_utf8.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        text_str = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeEncodeError(\n            'eutf8h',\n            str(text_input),\n            e.start,\n            e.end,\n            e.reason,\n        )\n\n    # Convert each character into a string of escaped utf8 hexadecimal.\n    out_str: str = reduce(lambda a, b: f'{a}{b}', _each_utf8_hex(text_str))\n\n    out_bytes = out_str.encode('utf-8')\n\n    return out_bytes, len(text)", "is_method": false, "function_description": "Function that converts a string which may include escaped UTF-8 hex codes into a bytes object representing escaped UTF-8 hexadecimal values, also returning the count of input characters processed. It enables handling of strings with embedded UTF-8 hex escapes for encoding purposes."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/raw_utf8_escape.py", "function": "decode", "line_number": 91, "body": "def decode(\n        data: _ByteString,\n        errors: _Str = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert a bytes type of escaped utf8 hexadecimal to a string.\n\n    Args:\n        data (bytes or bytearray or memoryview): The escaped utf8\n            hexadecimal bytes.\n        errors (str or :obj:`~UserString`): The error checking level.\n\n    Returns:\n        str: The given ``data`` (of escaped utf8 hexadecimal bytes)\n            converted into a :obj:`str`.\n        int: The number of the given ``data`` bytes consumed.\n\n    Raises:\n         UnicodeDecodeError: if the given ``data`` contains escaped\n            utf8 hexadecimal that references invalid utf8 bytes.\n\n\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Convert the given 'errors', that are of type UserString into a str.\n    errors_input = str(errors)\n\n    # Convert the utf8 bytes into a string of latin-1 characters.\n    # This basically maps the exact utf8 bytes to the string. Also,\n    # this converts any escaped hexadecimal sequences \\\\xHH into\n    # \\xHH bytes.\n    text_str_latin1 = data_bytes.decode('unicode_escape')\n\n    # Convert the string of latin-1 characters (which are actually\n    # utf8 characters) into bytes.\n    text_bytes_utf8 = text_str_latin1.encode('latin1')\n\n    # Convert the utf8 bytes into a string.\n    try:\n        out = text_bytes_utf8.decode('utf-8', errors=errors_input)\n    except UnicodeDecodeError as e:\n        raise UnicodeDecodeError(\n            'eutf8h',\n            data_bytes,\n            e.start,\n            e.end,\n            e.reason\n        )\n    return out, len(data)", "is_method": false, "function_description": "Function that decodes a byte sequence representing escaped UTF-8 hexadecimal bytes into a Unicode string, returning the decoded string and the number of bytes consumed. Useful for interpreting byte data with escaped hexadecimal UTF-8 encoding."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/raw_utf8_escape.py", "function": "_get_codec_info", "line_number": 147, "body": "def _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            encode=encode,  # type: ignore[arg-type]\n            decode=decode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None", "is_method": false, "function_description": "This function provides codec information for a specific encoding name, returning a CodecInfo object if the name matches a predefined value, enabling text encoding and decoding support for that codec."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/raw_utf8_escape.py", "function": "register", "line_number": 158, "body": "def register() -> None:\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)", "is_method": false, "function_description": "Registers a specific codec if it is not already available, ensuring that the codec can be used for encoding and decoding operations in the application."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/__init__.py", "function": "register_codecs", "line_number": 17, "body": "def register_codecs() -> None:\n    \"\"\"Register additional codecs.\n\n    *New in version 0.4.*\n\n    :rtype: :obj:`None`\n\n    Examples:\n\n        >>> from flutils.codecs import register_codecs\n        >>> register_codecs()\n        >>> 'test\u00a9'.encode('raw_utf8_escape')\n        b'test\\\\\\\\xc2\\\\\\\\xa9'\n        >>> b'test\\\\\\\\xc2\\\\\\\\xa9'.decode('raw_utf8_escape')\n        'test\u00a9'\n        >>> 'dGVzdA=='.encode('b64')\n        b'test'\n        >>> b'test'.decode('b64')\n        'dGVzdA=='\n\n    \"\"\"\n    raw_utf8_escape.register()\n    b64.register()", "is_method": false, "function_description": "Registers custom codecs to enable encoding and decoding using additional formats like raw UTF-8 escape and base64, extending Python's built-in codec capabilities."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/__init__.py", "function": "get_encoding", "line_number": 46, "body": "def get_encoding(\n        name: Optional[str] = None,\n        default: Optional[str] = SYSTEM_ENCODING\n) -> str:\n    \"\"\"Validate and return the given encoding codec name.\n\n    Args:\n        name (str): The name of the encoding to validate.\n            if empty or invalid then the value of the given ``default``\n            will be returned.\n        default (str, optional): If set, this encoding name will be returned\n            if the given ``name`` is invalid. Defaults to:\n            :obj:`~flutils.codecs.SYSTEM_ENCODING`.  If set to :obj:`None`\n            which will raise a :obj:`LookupError` if the given ``name``\n            is not valid.\n\n    Raises:\n        LookupError: If the given ``name`` is not a valid encoding codec name\n            and the given ``default`` is set to :obj:`None` or an empty string.\n        LookupError: If the given ``default`` is not a valid encoding codec\n            name.\n\n    Returns:\n        str: The encoding codec name.\n\n    Example:\n\n        >>> from flutils.codecs import get_encoding\n        >>> get_encoding()\n        'utf-8'\n    \"\"\"\n    if name is None:\n        name = ''\n    if hasattr(name, 'encode') is False:\n        name = ''\n    name = cast(str, name)\n    name = name.strip()\n\n    if default is None:\n        default = ''\n    if hasattr(default, 'encode') is False:\n        default = ''\n    default = cast(str, default)\n    default = default.strip()\n\n    if default:\n        try:\n            codec = codecs.lookup(default)\n        except LookupError:\n            raise LookupError(\n                f\"The given 'default' of {default!r} is an invalid encoding \"\n                f\"codec name.\"\n            )\n        else:\n            default = codec.name\n\n    try:\n        codec = codecs.lookup(name)\n    except LookupError:\n        if default:\n            return default\n        raise LookupError(\n            f\"The given 'name' of {name!r} is an invalid encoding \"\n            f\"codec name.\"\n        )\n    else:\n        return codec.name", "is_method": false, "function_description": "Utility function that validates an encoding name and returns it or a fallback default encoding if invalid, ensuring a valid codec name is always provided or raising an error if no valid encoding is found."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/b64.py", "function": "encode", "line_number": 17, "body": "def encode(\n        text: _STR,\n        errors: _STR = 'strict'\n) -> Tuple[bytes, int]:\n    \"\"\"Convert the given ``text`` of base64 characters into the base64\n    decoded bytes.\n\n    Args:\n        text (str): The string input.  The given string input can span\n            across many lines and be indented any number of spaces.\n        errors (str): Not used.  This argument exists to meet the\n            interface requirements.  Any value given to this argument\n            is ignored.\n\n    Returns:\n        bytes: The given ``text`` converted into base64 bytes.\n        int: The length of the returned bytes.\n    \"\"\"\n    # Convert the given 'text', that are of type UserString into a str.\n    text_input = str(text)\n\n    # Cleanup whitespace.\n    text_str = text_input.strip()\n    text_str = '\\n'.join(\n        filter(\n            lambda x: len(x) > 0,\n            map(lambda x: x.strip(), text_str.strip().splitlines())\n        )\n    )\n\n    # Convert the cleaned text into utf8 bytes\n    text_bytes = text_str.encode('utf-8')\n    try:\n        out = base64.decodebytes(text_bytes)\n    except Error as e:\n        raise UnicodeEncodeError(\n            'b64',\n            text_input,\n            0,\n            len(text),\n            (\n                f'{text_str!r} is not a proper bas64 character string: '\n                f'{e}'\n            )\n        )\n    return out, len(text)", "is_method": false, "function_description": "Function that decodes a base64-encoded string into its original byte representation, returning the decoded bytes and their length. It ensures input cleanup and validates the base64 format before decoding."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/b64.py", "function": "decode", "line_number": 66, "body": "def decode(\n        data: _ByteString,\n        errors: _STR = 'strict'\n) -> Tuple[str, int]:\n    \"\"\"Convert the given ``data`` into base64 Characters.\n\n    Args:\n        data (bytes or bytearray or memoryview): Bytes to be converted\n            to a string of base64 characters.\n        errors (str or :obj:`~UserString`): Not used.  This argument exists\n            to meet the interface requirements.  Any value given to this\n            argument is ignored.\n\n    Returns:\n        str: of base64 Characters\n        int: the number of the given ``data`` bytes consumed.\n    \"\"\"\n    # Convert memoryview and bytearray objects to bytes.\n    data_bytes = bytes(data)\n\n    # Encode the 'data_bytes' into base64 bytes.\n    encoded_bytes = base64.b64encode(data_bytes)\n\n    # Decode the 'base64_bytes' as utf8 into a string.\n    encoded_str = encoded_bytes.decode('utf-8')\n\n    return encoded_str, len(data)", "is_method": false, "function_description": "Function that converts binary data into a base64-encoded string and returns the encoded string along with the number of bytes processed. It facilitates encoding of byte-like objects for text-based transmission or storage."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/b64.py", "function": "_get_codec_info", "line_number": 99, "body": "def _get_codec_info(name: str) -> Optional[codecs.CodecInfo]:\n    if name == NAME:\n        obj = codecs.CodecInfo(  # type: ignore\n            name=NAME,\n            decode=decode,  # type: ignore[arg-type]\n            encode=encode,  # type: ignore[arg-type]\n        )\n        return obj\n    return None", "is_method": false, "function_description": "This function provides codec information for a specific codec name, returning its encode and decode methods if matched. It supports custom codec registration and lookup functionality for encoding/decoding operations."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/codecs/b64.py", "function": "register", "line_number": 110, "body": "def register() -> None:\n    \"\"\"Register the ``b64`` codec with Python.\"\"\"\n    try:\n        codecs.getdecoder(NAME)\n    except LookupError:\n        codecs.register(_get_codec_info)", "is_method": false, "function_description": "Registers the 'b64' codec in Python if it is not already available, enabling base64 encoding and decoding functionality."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "_each_setup_cfg_command_section", "line_number": 32, "body": "def _each_setup_cfg_command_section(\n        parser: ConfigParser\n) -> Generator[Tuple[str, str], None, None]:\n    for section in parser.sections():\n        section = cast(str, section)\n        section = section.strip()\n        if section.startswith('setup.command.'):\n            command_name = '.'.join(section.split('.')[2:])\n            if command_name:\n                yield section, command_name", "is_method": false, "function_description": "Generator function that iterates over configuration sections starting with 'setup.command.', yielding each full section name and its specific command identifier. Useful for extracting setup command configurations from parser objects."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "_each_setup_cfg_command", "line_number": 44, "body": "def _each_setup_cfg_command(\n        parser: ConfigParser,\n        format_kwargs: Dict[str, str]\n) -> Generator[SetupCfgCommandConfig, None, None]:\n    for section, command_name in _each_setup_cfg_command_section(parser):\n        commands: List[str] = []\n        options: List[str] = parser.options(section)\n        for option in ('command', 'commands'):\n            if option in options:\n                val: str = parser.get(section, option)\n                val = val.format(**format_kwargs)\n                commands += list(\n                    filter(len, map(lambda x: x.strip(), val.splitlines()))\n                )\n        if commands:\n            cmd_name = ''\n            if 'name' in options:\n                cmd_name = parser.get(section, 'name')\n            cmd_name = cmd_name or command_name\n            cmd_name = cmd_name.format(name=format_kwargs['name'])\n\n            description = ''\n            if 'description' in options:\n                description = parser.get(section, 'description')\n            description = description.format(**format_kwargs)\n\n            title = cmd_name.replace('.', '_')\n            title = title.replace('-', '_')\n\n            if title.isidentifier() is True:\n                yield SetupCfgCommandConfig(\n                    cmd_name,\n                    underscore_to_camel(title, lower_first=False),\n                    description,\n                    tuple(commands)\n                )", "is_method": false, "function_description": "Utility generator function that extracts and formats command configurations from a setup.cfg parser, yielding structured command details for packaging or build tooling customization."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "_get_name", "line_number": 82, "body": "def _get_name(\n        parser: ConfigParser,\n        setup_cfg_path: str,\n) -> str:\n    try:\n        out = parser.get('metadata', 'name')\n    except NoSectionError:\n        raise LookupError(\n            \"The config file, %r, is missing the 'metadata' section.\"\n            % setup_cfg_path\n        )\n    except NoOptionError:\n        raise LookupError(\n            \"The 'metadata', section is missing the 'name' option in \"\n            \"the config file, %r.\"\n            % setup_cfg_path\n        )\n    if not out:\n        raise LookupError(\n            \"The 'metadata', section's, 'name' option is not set in \"\n            \"the config file, %r.\"\n            % setup_cfg_path\n        )\n    return out", "is_method": false, "function_description": "Utility function that extracts the 'name' value from the 'metadata' section of a configuration file, ensuring its presence and raising clear errors if missing or empty."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "_validate_setup_dir", "line_number": 108, "body": "def _validate_setup_dir(setup_dir: str) -> None:\n    \"\"\"Validates the given ``setup_dir``.\"\"\"\n    if os.path.exists(setup_dir) is False:\n        raise FileNotFoundError(\n            \"The given 'setup_dir' of %r does NOT exist.\"\n            % setup_dir\n        )\n    if os.path.isdir(setup_dir) is False:\n        raise NotADirectoryError(\n            \"The given 'setup_dir' of %r is NOT a directory.\"\n            % setup_dir\n        )\n    path = os.path.join(setup_dir, 'setup.py')\n    if os.path.isfile(path) is False:\n        raise FileNotFoundError(\n            \"The given 'setup_dir' of %r does NOT contain a setup.py \"\n            \"file.\" % setup_dir\n        )\n    path = os.path.join(setup_dir, 'setup.cfg')\n    if os.path.isfile(path) is False:\n        raise FileNotFoundError(\n            \"The given 'setup_dir' of %r does NOT contain a setup.cfg \"\n            \"file.\" % setup_dir\n        )", "is_method": false, "function_description": "Utility function that ensures a given directory exists, is a directory, and contains required setup.py and setup.cfg files, validating it as a proper Python package setup directory."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "_prep_setup_dir", "line_number": 134, "body": "def _prep_setup_dir(\n        setup_dir: Optional[Union[os.PathLike, str]] = None\n) -> str:\n    \"\"\"The path to the directory that contains the project's ``setup.py``\n    file.\n    \"\"\"\n    if setup_dir:\n        setup_dir = str(setup_dir)\n        _validate_setup_dir(setup_dir)\n        return os.path.realpath(setup_dir)\n\n    for fs in extract_stack():\n        fs = cast(FrameSummary, fs)\n        basename = os.path.basename(fs.filename)\n        if basename == 'setup.py':\n            setup_dir = str(os.path.dirname(fs.filename))\n            _validate_setup_dir(setup_dir)\n            return os.path.realpath(setup_dir)\n    raise FileNotFoundError(\n        \"Unable to find the directory that contains the 'setup.py' file.\"\n    )", "is_method": false, "function_description": "Utility function that locates and validates the directory containing the 'setup.py' file, either from a provided path or by inspecting the call stack for its location."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cfg.py", "function": "each_sub_command_config", "line_number": 157, "body": "def each_sub_command_config(\n        setup_dir: Optional[Union[os.PathLike, str]] = None\n) -> Generator[SetupCfgCommandConfig, None, None]:\n    format_kwargs: Dict[str, str] = {\n        'setup_dir': _prep_setup_dir(setup_dir),\n        'home': os.path.expanduser('~')\n    }\n    setup_cfg_path = os.path.join(format_kwargs['setup_dir'], 'setup.cfg')\n    parser = ConfigParser()\n    parser.read(setup_cfg_path)\n    format_kwargs['name'] = _get_name(parser, setup_cfg_path)\n    path = os.path.join(format_kwargs['setup_dir'], 'setup_commands.cfg')\n    if os.path.isfile(path):\n        parser = ConfigParser()\n        parser.read(path)\n    yield from _each_setup_cfg_command(parser, format_kwargs)", "is_method": false, "function_description": "Provides a generator yielding configuration objects for each sub-command defined in setup-related config files, facilitating access to command-specific settings in a setup directory."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/__init__.py", "function": "add_setup_cfg_commands", "line_number": 14, "body": "def add_setup_cfg_commands(\n        setup_kwargs: Dict[str, Any],\n        setup_dir: Optional[Union[PathLike, str]] = None\n) -> None:\n    \"\"\"Add additional custom ``setup.py`` commands that are defined in\n    ``setup.cfg``.\n\n    Args:\n        setup_kwargs (dict): A dictionary holding the\n            `setuptools.setup keyword arguments <https://bit.ly/2Ju4Zad>`_.\n            (see example below).\n        setup_dir (:obj:`str` or :obj:`Path <pathlib.Path>`, optional): The\n            root directory of the project. (e.g. the directory that contains\n            the ``setup.py`` file).  Defaults to: ``None`` which will try to\n            determine the directory using the call stack.\n\n    :rtype: :obj:`None`\n\n    Example:\n        Use in ``setup.py`` like the following::\n\n            #!/usr/bin/env python\n\n            import os\n\n            from setuptools import setup\n\n            from flutils.setuputils import add_setup_cfg_commands\n\n            setup_kwargs = {}\n            setup_dir = os.path.dirname(os.path.realpath(__file__))\n            add_setup_cfg_commands(setup_kwargs, setup_dir=setup_dir)\n            setup(**setup_kwargs)\n\n    \"\"\"\n    for sub_command_cfg in each_sub_command_config(setup_dir):\n        klass = build_setup_cfg_command_class(sub_command_cfg)\n        if 'cmdclass' not in setup_kwargs.keys():\n            setup_kwargs['cmdclass'] = {}\n        setup_kwargs['cmdclass'][sub_command_cfg.name] = klass", "is_method": false, "function_description": "Function that enhances setuptools setup arguments by adding custom commands defined in a setup.cfg file, simplifying the integration of additional setup.py commands for project packaging."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cmd.py", "function": "_get_path", "line_number": 20, "body": "def _get_path(cmd: str) -> str:\n    if cmd.startswith(os.path.sep):\n        if os.path.isfile(cmd) is True:\n            out = cmd\n        else:\n            raise FileNotFoundError('Unable to find the file: %r' % cmd)\n    else:\n        out = ''\n        path = shutil.which(cmd)\n        if path is not None:\n            out = str(path)\n\n    if out:\n        if os.access(out, os.X_OK) is False:\n            raise PermissionError(\n                'You do not have execute permission to run the file: %r'\n                % out\n            )\n        return out\n    raise FileNotFoundError(\n        'Unable to find the file path for the command: %r'\n        % cmd\n    )", "is_method": false, "function_description": "Utility function that locates the executable file path for a given command, validating its existence and execution permissions to ensure it can be run."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cmd.py", "function": "_each_command", "line_number": 45, "body": "def _each_command(\n        commands: Union[List[str], Tuple[str, ...]]\n) -> Generator[Tuple[str, ...], None, None]:\n    for command in commands:\n        command = command.strip()\n        hold = []\n        for x, part in enumerate(shlex.split(command)):\n            if x == 0:\n                hold.append(_get_path(part))\n            else:\n                hold.append(part)\n        if hold:\n            yield tuple(hold)", "is_method": false, "function_description": "Function that processes a list or tuple of shell commands into tuples of command elements, normalizing their paths for use in command execution or parsing workflows."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cmd.py", "function": "_show_command", "line_number": 63, "body": "def _show_command(\n        command: Tuple[str, ...],\n) -> None:\n    print(_DIVIDER)\n    for x, part in enumerate(command):\n        if x == 0:\n            print('{}\\n'.format(part))\n        else:\n            print('  {}\\n'.format(part))\n    print('\\n\\n')", "is_method": false, "function_description": "Utility function that neatly prints each part of a command tuple with formatting, primarily for displaying structured command sequences in a readable way."}, {"file": "./dataset/RepoExec/test-apps/flutils/flutils/setuputils/cmd.py", "function": "build_setup_cfg_command_class", "line_number": 99, "body": "def build_setup_cfg_command_class(\n        setup_command_cfg: SetupCfgCommandConfig\n) -> Type[Command]:\n    setup_klass = _type(\n        'SetupCfgCommand',\n        (object,),\n        {\n            '__annotations__': {\n                'name': ClassVar[str],\n                'root_path': ClassVar[str],\n                'description': ClassVar[str],\n                'user_options': ClassVar[List[str]],\n                'commands': ClassVar[Tuple[str, ...]],\n            },\n            '__module__': __name__,\n            '__doc__': None,\n            'name': setup_command_cfg.name,\n            'root_path': '',\n            'description': setup_command_cfg.description,\n            'user_options': [],\n            'commands': setup_command_cfg.commands,\n            'initialize_options': _initialize_options,\n            'finalize_options': _finalize_options,\n            'run': _run,\n        }\n    )\n    klass_name = '%sCommand' % setup_command_cfg.camel\n    klass = _type(klass_name, (setup_klass, Command), {})\n    return klass", "is_method": false, "function_description": "Constructs and returns a custom Command subclass configured with attributes and behavior defined by a given setup command configuration. This enables dynamic creation of command classes for setup or build automation tasks."}]