[{"file": "./dataset/RepoExec/test-apps/sanic/setup.py", "function": "open_local", "line_number": 35, "body": "def open_local(paths, mode=\"r\", encoding=\"utf8\"):\n    path = os.path.join(os.path.abspath(os.path.dirname(__file__)), *paths)\n\n    return codecs.open(path, mode, encoding)", "is_method": false, "function_description": "Function that opens a local file by constructing its absolute path from given components and returns a file object with specified mode and encoding. It simplifies accessing files relative to the current script's directory."}, {"file": "./dataset/RepoExec/test-apps/sanic/setup.py", "function": "initialize_options", "line_number": 22, "body": "def initialize_options(self):\n        TestCommand.initialize_options(self)\n        self.pytest_args = \"\"", "is_method": true, "class_name": "PyTest", "function_description": "Initializes configuration options for the PyTest command, setting up default argument values. This prepares the testing environment before test execution."}, {"file": "./dataset/RepoExec/test-apps/sanic/setup.py", "function": "run_tests", "line_number": 26, "body": "def run_tests(self):\n        import shlex\n\n        import pytest\n\n        errno = pytest.main(shlex.split(self.pytest_args))\n        sys.exit(errno)", "is_method": true, "class_name": "PyTest", "function_description": "Utility method in PyTest that executes tests using pytest with specified arguments and exits the program based on test outcomes. It provides an easy interface to run test suites programmatically."}, {"file": "./dataset/RepoExec/test-apps/sanic/docs/conf.py", "function": "setup", "line_number": 167, "body": "def setup(app):\n    app.add_config_value(\n        \"recommonmark_config\",\n        {\n            \"enable_eval_rst\": True,\n            \"enable_auto_doc_ref\": False,\n        },\n        True,\n    )\n    app.add_transform(AutoStructify)", "is_method": false, "function_description": "Sets up configuration and transformations for a documentation app, enabling evaluation of reStructuredText and adding automatic structuring features during documentation build processes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "parse_multipart_form", "line_number": 712, "body": "def parse_multipart_form(body, boundary):\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    files = RequestParameters()\n    fields = RequestParameters()\n\n    form_parts = body.split(boundary)\n    for form_part in form_parts[1:-1]:\n        file_name = None\n        content_type = \"text/plain\"\n        content_charset = \"utf-8\"\n        field_name = None\n        line_index = 2\n        line_end_index = 0\n        while not line_end_index == -1:\n            line_end_index = form_part.find(b\"\\r\\n\", line_index)\n            form_line = form_part[line_index:line_end_index].decode(\"utf-8\")\n            line_index = line_end_index + 2\n\n            if not form_line:\n                break\n\n            colon_index = form_line.index(\":\")\n            form_header_field = form_line[0:colon_index].lower()\n            form_header_value, form_parameters = parse_content_header(\n                form_line[colon_index + 2 :]\n            )\n\n            if form_header_field == \"content-disposition\":\n                field_name = form_parameters.get(\"name\")\n                file_name = form_parameters.get(\"filename\")\n\n                # non-ASCII filenames in RFC2231, \"filename*\" format\n                if file_name is None and form_parameters.get(\"filename*\"):\n                    encoding, _, value = email.utils.decode_rfc2231(\n                        form_parameters[\"filename*\"]\n                    )\n                    file_name = unquote(value, encoding=encoding)\n            elif form_header_field == \"content-type\":\n                content_type = form_header_value\n                content_charset = form_parameters.get(\"charset\", \"utf-8\")\n\n        if field_name:\n            post_data = form_part[line_index:-4]\n            if file_name is None:\n                value = post_data.decode(content_charset)\n                if field_name in fields:\n                    fields[field_name].append(value)\n                else:\n                    fields[field_name] = [value]\n            else:\n                form_file = File(\n                    type=content_type, name=file_name, body=post_data\n                )\n                if field_name in files:\n                    files[field_name].append(form_file)\n                else:\n                    files[field_name] = [form_file]\n        else:\n            logger.debug(\n                \"Form-data field does not have a 'name' parameter \"\n                \"in the Content-Disposition header\"\n            )\n\n    return fields, files", "is_method": false, "function_description": "Parses multipart/form-data request bodies to extract and separate form fields and uploaded files. It returns these as structured parameters, enabling easy access to submitted form data and file uploads in web applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "get", "line_number": 60, "body": "def get(self, name: str, default: Optional[Any] = None) -> Optional[Any]:\n        \"\"\"Return the first value, either the default or actual\"\"\"\n        return super().get(name, [default])[0]", "is_method": true, "class_name": "RequestParameters", "function_description": "Returns the first value of a given parameter by name, or a default if the parameter is not present. Useful for retrieving single values from potentially multi-valued request parameters."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "getlist", "line_number": 64, "body": "def getlist(\n        self, name: str, default: Optional[Any] = None\n    ) -> Optional[Any]:\n        \"\"\"\n        Return the entire list\n        \"\"\"\n        return super().get(name, default)", "is_method": true, "class_name": "RequestParameters", "function_description": "Returns the full list of values associated with the given parameter name, or a default if the parameter is not present. Useful for accessing multi-valued request parameters in web request handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "__repr__", "line_number": 155, "body": "def __repr__(self):\n        class_name = self.__class__.__name__\n        return f\"<{class_name}: {self.method} {self.path}>\"", "is_method": true, "class_name": "Request", "function_description": "Provides a clear, concise string representation of a Request instance showing its HTTP method and request path for easier debugging and logging."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "generate_id", "line_number": 160, "body": "def generate_id(*_):\n        return uuid.uuid4()", "is_method": true, "class_name": "Request", "function_description": "Generates a unique identifier using UUID version 4. This function provides a simple way to create distinct IDs for requests or objects."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "name", "line_number": 207, "body": "def name(self):\n        if self._name:\n            return self._name\n        elif self.route:\n            return self.route.name\n        return None", "is_method": true, "class_name": "Request", "function_description": "Returns the name associated with the request, prioritizing an explicitly set name or falling back to the request route's name if available. This enables consistent identification of requests within routing contexts."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "endpoint", "line_number": 215, "body": "def endpoint(self):\n        return self.name", "is_method": true, "class_name": "Request", "function_description": "Returns the endpoint name associated with the request, providing a simple way to identify the target service or resource of the request."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "uri_template", "line_number": 219, "body": "def uri_template(self):\n        return f\"/{self.route.path}\"", "is_method": true, "class_name": "Request", "function_description": "Returns the URI path template of the request based on its defined route. This method provides a standardized way to access the request's endpoint path."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "protocol", "line_number": 223, "body": "def protocol(self):\n        if not self._protocol:\n            self._protocol = self.transport.get_protocol()\n        return self._protocol", "is_method": true, "class_name": "Request", "function_description": "Returns the protocol used by the request's transport, caching it for subsequent accesses to avoid redundant retrieval."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "raw_headers", "line_number": 229, "body": "def raw_headers(self):\n        _, headers = self.head.split(b\"\\r\\n\", 1)\n        return bytes(headers)", "is_method": true, "class_name": "Request", "function_description": "Returns the raw HTTP headers from the request's header block as bytes, enabling direct access to unprocessed header data for further handling or analysis."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "request_line", "line_number": 234, "body": "def request_line(self):\n        reqline, _ = self.head.split(b\"\\r\\n\", 1)\n        return bytes(reqline)", "is_method": true, "class_name": "Request", "function_description": "Returns the first line of the HTTP request header as bytes, typically containing the request method, path, and HTTP version. This is useful for parsing or inspecting the basic request information in HTTP processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "id", "line_number": 239, "body": "def id(self) -> Optional[Union[uuid.UUID, str, int]]:\n        \"\"\"\n        A request ID passed from the client, or generated from the backend.\n\n        By default, this will look in a request header defined at:\n        ``self.app.config.REQUEST_ID_HEADER``. It defaults to\n        ``X-Request-ID``. Sanic will try to cast the ID into a ``UUID`` or an\n        ``int``. If there is not a UUID from the client, then Sanic will try\n        to generate an ID by calling ``Request.generate_id()``. The default\n        behavior is to generate a ``UUID``. You can customize this behavior\n        by subclassing ``Request``.\n\n        .. code-block:: python\n\n            from sanic import Request, Sanic\n            from itertools import count\n\n            class IntRequest(Request):\n                counter = count()\n\n                def generate_id(self):\n                    return next(self.counter)\n\n            app = Sanic(\"MyApp\", request_class=IntRequest)\n        \"\"\"\n        if not self._id:\n            self._id = self.headers.get(\n                self.app.config.REQUEST_ID_HEADER,\n                self.__class__.generate_id(self),  # type: ignore\n            )\n\n            # Try casting to a UUID or an integer\n            if isinstance(self._id, str):\n                try:\n                    self._id = uuid.UUID(self._id)\n                except ValueError:\n                    try:\n                        self._id = int(self._id)  # type: ignore\n                    except ValueError:\n                        ...\n\n        return self._id", "is_method": true, "class_name": "Request", "function_description": "Provides a unique request identifier by extracting it from request headers or generating one if absent, supporting UUID or integer formats. This facilitates tracking and correlating client requests within the Request class."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "json", "line_number": 283, "body": "def json(self):\n        if self.parsed_json is None:\n            self.load_json()\n\n        return self.parsed_json", "is_method": true, "class_name": "Request", "function_description": "Returns the JSON-parsed content of the request, loading and caching it if not already done. It provides easy access to request data in JSON format for further processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "load_json", "line_number": 289, "body": "def load_json(self, loads=json_loads):\n        try:\n            self.parsed_json = loads(self.body)\n        except Exception:\n            if not self.body:\n                return None\n            raise InvalidUsage(\"Failed when parsing body as json\")\n\n        return self.parsed_json", "is_method": true, "class_name": "Request", "function_description": "Utility method of the Request class that parses the request body as JSON, returning the parsed content or raising an error if parsing fails and the body is non-empty. It aids in safely extracting JSON data from requests."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "token", "line_number": 300, "body": "def token(self):\n        \"\"\"Attempt to return the auth header token.\n\n        :return: token related to request\n        \"\"\"\n        prefixes = (\"Bearer\", \"Token\")\n        auth_header = self.headers.get(\"Authorization\")\n\n        if auth_header is not None:\n            for prefix in prefixes:\n                if prefix in auth_header:\n                    return auth_header.partition(prefix)[-1].strip()\n\n        return auth_header", "is_method": true, "class_name": "Request", "function_description": "Core method of the Request class that extracts and returns the authentication token from the Authorization header, supporting common token prefixes like \"Bearer\" and \"Token\". It facilitates easy access to auth credentials for request handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "form", "line_number": 316, "body": "def form(self):\n        if self.parsed_form is None:\n            self.parsed_form = RequestParameters()\n            self.parsed_files = RequestParameters()\n            content_type = self.headers.get(\n                \"Content-Type\", DEFAULT_HTTP_CONTENT_TYPE\n            )\n            content_type, parameters = parse_content_header(content_type)\n            try:\n                if content_type == \"application/x-www-form-urlencoded\":\n                    self.parsed_form = RequestParameters(\n                        parse_qs(self.body.decode(\"utf-8\"))\n                    )\n                elif content_type == \"multipart/form-data\":\n                    # TODO: Stream this instead of reading to/from memory\n                    boundary = parameters[\"boundary\"].encode(\"utf-8\")\n                    self.parsed_form, self.parsed_files = parse_multipart_form(\n                        self.body, boundary\n                    )\n            except Exception:\n                error_logger.exception(\"Failed when parsing form\")\n\n        return self.parsed_form", "is_method": true, "class_name": "Request", "function_description": "This method parses and returns form data from an HTTP request, handling both URL-encoded and multipart form data formats. It provides parsed form parameters for further request processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "files", "line_number": 341, "body": "def files(self):\n        if self.parsed_files is None:\n            self.form  # compute form to get files\n\n        return self.parsed_files", "is_method": true, "class_name": "Request", "function_description": "Provides access to the parsed files submitted with the request, initializing them if not already processed. This method enables easy retrieval of uploaded file data within a request context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "get_args", "line_number": 347, "body": "def get_args(\n        self,\n        keep_blank_values: bool = False,\n        strict_parsing: bool = False,\n        encoding: str = \"utf-8\",\n        errors: str = \"replace\",\n    ) -> RequestParameters:\n        \"\"\"\n        Method to parse `query_string` using `urllib.parse.parse_qs`.\n        This methods is used by `args` property.\n        Can be used directly if you need to change default parameters.\n\n        :param keep_blank_values:\n            flag indicating whether blank values in\n            percent-encoded queries should be treated as blank strings.\n            A true value indicates that blanks should be retained as blank\n            strings.  The default false value indicates that blank values\n            are to be ignored and treated as if they were  not included.\n        :type keep_blank_values: bool\n        :param strict_parsing:\n            flag indicating what to do with parsing errors.\n            If false (the default), errors are silently ignored. If true,\n            errors raise a ValueError exception.\n        :type strict_parsing: bool\n        :param encoding:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type encoding: str\n        :param errors:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type errors: str\n        :return: RequestParameters\n        \"\"\"\n        if not self.parsed_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]:\n            if self.query_string:\n                self.parsed_args[\n                    (keep_blank_values, strict_parsing, encoding, errors)\n                ] = RequestParameters(\n                    parse_qs(\n                        qs=self.query_string,\n                        keep_blank_values=keep_blank_values,\n                        strict_parsing=strict_parsing,\n                        encoding=encoding,\n                        errors=errors,\n                    )\n                )\n\n        return self.parsed_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]", "is_method": true, "class_name": "Request", "function_description": "Provides parsed query parameters from the request's query string with customizable parsing options such as handling blank values, strictness, and encoding. This enables flexible access to URL query arguments for processing client requests."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "get_query_args", "line_number": 403, "body": "def get_query_args(\n        self,\n        keep_blank_values: bool = False,\n        strict_parsing: bool = False,\n        encoding: str = \"utf-8\",\n        errors: str = \"replace\",\n    ) -> list:\n        \"\"\"\n        Method to parse `query_string` using `urllib.parse.parse_qsl`.\n        This methods is used by `query_args` property.\n        Can be used directly if you need to change default parameters.\n\n        :param keep_blank_values:\n            flag indicating whether blank values in\n            percent-encoded queries should be treated as blank strings.\n            A true value indicates that blanks should be retained as blank\n            strings.  The default false value indicates that blank values\n            are to be ignored and treated as if they were  not included.\n        :type keep_blank_values: bool\n        :param strict_parsing:\n            flag indicating what to do with parsing errors.\n            If false (the default), errors are silently ignored. If true,\n            errors raise a ValueError exception.\n        :type strict_parsing: bool\n        :param encoding:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type encoding: str\n        :param errors:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type errors: str\n        :return: list\n        \"\"\"\n        if not self.parsed_not_grouped_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]:\n            if self.query_string:\n                self.parsed_not_grouped_args[\n                    (keep_blank_values, strict_parsing, encoding, errors)\n                ] = parse_qsl(\n                    qs=self.query_string,\n                    keep_blank_values=keep_blank_values,\n                    strict_parsing=strict_parsing,\n                    encoding=encoding,\n                    errors=errors,\n                )\n        return self.parsed_not_grouped_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]", "is_method": true, "class_name": "Request", "function_description": "Utility method of the Request class that parses the query string into a list of key-value pairs, allowing customizable handling of blank values, parsing errors, and character encoding for flexible query parameter processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "cookies", "line_number": 461, "body": "def cookies(self) -> Dict[str, str]:\n        \"\"\"\n        :return: Incoming cookies on the request\n        :rtype: Dict[str, str]\n        \"\"\"\n\n        if self._cookies is None:\n            cookie = self.headers.get(\"Cookie\")\n            if cookie is not None:\n                cookies: SimpleCookie = SimpleCookie()\n                cookies.load(cookie)\n                self._cookies = {\n                    name: cookie.value for name, cookie in cookies.items()\n                }\n            else:\n                self._cookies = {}\n        return self._cookies", "is_method": true, "class_name": "Request", "function_description": "Provides a dictionary of cookie names and values from the incoming HTTP request, facilitating easy access to client-side cookies within the Request class."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "content_type", "line_number": 480, "body": "def content_type(self) -> str:\n        \"\"\"\n        :return: Content-Type header form the request\n        :rtype: str\n        \"\"\"\n        return self.headers.get(\"Content-Type\", DEFAULT_HTTP_CONTENT_TYPE)", "is_method": true, "class_name": "Request", "function_description": "Returns the Content-Type header from the request, providing the media type of the request body. This aids in processing the request based on its content format."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "match_info", "line_number": 488, "body": "def match_info(self):\n        \"\"\"\n        :return: matched info after resolving route\n        \"\"\"\n        return self._match_info", "is_method": true, "class_name": "Request", "function_description": "Returns the matched routing information of the current request after route resolution. This method provides access to routing details useful for request handling and processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "ip", "line_number": 497, "body": "def ip(self) -> str:\n        \"\"\"\n        :return: peer ip of the socket\n        :rtype: str\n        \"\"\"\n        return self.conn_info.client if self.conn_info else \"\"", "is_method": true, "class_name": "Request", "function_description": "Returns the IP address of the client connected to the request, providing the peer socket's IP for network identification or logging purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "port", "line_number": 505, "body": "def port(self) -> int:\n        \"\"\"\n        :return: peer port of the socket\n        :rtype: int\n        \"\"\"\n        return self.conn_info.client_port if self.conn_info else 0", "is_method": true, "class_name": "Request", "function_description": "Returns the port number of the connected peer socket, providing network connection details for use in communication or logging."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "socket", "line_number": 513, "body": "def socket(self):\n        return self.conn_info.peername if self.conn_info else (None, None)", "is_method": true, "class_name": "Request", "function_description": "Returns the network address of the peer connected to the request, or (None, None) if unavailable. This provides access to connection details for networking or logging purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "path", "line_number": 517, "body": "def path(self) -> str:\n        \"\"\"\n        :return: path of the local HTTP request\n        :rtype: str\n        \"\"\"\n        return self._parsed_url.path.decode(\"utf-8\")", "is_method": true, "class_name": "Request", "function_description": "Returns the URL path of the local HTTP request as a decoded string. This method provides the specific endpoint being accessed within the Request context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "forwarded", "line_number": 527, "body": "def forwarded(self) -> Options:\n        \"\"\"\n        Active proxy information obtained from request headers, as specified in\n        Sanic configuration.\n\n        Field names by, for, proto, host, port and path are normalized.\n        - for and by IPv6 addresses are bracketed\n        - port (int) is only set by port headers, not from host.\n        - path is url-unencoded\n\n        Additional values may be available from new style Forwarded headers.\n\n        :return: forwarded address info\n        :rtype: Dict[str, str]\n        \"\"\"\n        if self.parsed_forwarded is None:\n            self.parsed_forwarded = (\n                parse_forwarded(self.headers, self.app.config)\n                or parse_xforwarded(self.headers, self.app.config)\n                or {}\n            )\n        return self.parsed_forwarded", "is_method": true, "class_name": "Request", "function_description": "Provides normalized proxy forwarding information extracted from HTTP request headers, enabling accurate retrieval of client and proxy details for request processing or logging in web applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "remote_addr", "line_number": 551, "body": "def remote_addr(self) -> str:\n        \"\"\"\n        Client IP address, if available.\n        1. proxied remote address `self.forwarded['for']`\n        2. local remote address `self.ip`\n\n        :return: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        :rtype: str\n        \"\"\"\n        if not hasattr(self, \"_remote_addr\"):\n            self._remote_addr = str(\n                self.forwarded.get(\"for\", \"\")\n            )  # or self.ip\n        return self._remote_addr", "is_method": true, "class_name": "Request", "function_description": "Provides the client IP address for a request, prioritizing proxied addresses and falling back to the direct IP. Useful for identifying and logging the origin of a client connection."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "scheme", "line_number": 567, "body": "def scheme(self) -> str:\n        \"\"\"\n        Determine request scheme.\n        1. `config.SERVER_NAME` if in full URL format\n        2. proxied proto/scheme\n        3. local connection protocol\n\n        :return: http|https|ws|wss or arbitrary value given by the headers.\n        :rtype: str\n        \"\"\"\n        if \"//\" in self.app.config.get(\"SERVER_NAME\", \"\"):\n            return self.app.config.SERVER_NAME.split(\"//\")[0]\n        if \"proto\" in self.forwarded:\n            return str(self.forwarded[\"proto\"])\n\n        if (\n            self.app.websocket_enabled\n            and self.headers.get(\"upgrade\") == \"websocket\"\n        ):\n            scheme = \"ws\"\n        else:\n            scheme = \"http\"\n\n        if self.transport.get_extra_info(\"sslcontext\"):\n            scheme += \"s\"\n\n        return scheme", "is_method": true, "class_name": "Request", "function_description": "Determines the scheme (e.g., http, https, ws, wss) of an incoming request based on server configuration, proxy headers, and connection security. Useful for correctly identifying request protocols in web and websocket contexts."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "host", "line_number": 596, "body": "def host(self) -> str:\n        \"\"\"\n        The currently effective server 'host' (hostname or hostname:port).\n        1. `config.SERVER_NAME` overrides any client headers\n        2. proxied host of original request\n        3. request host header\n        hostname and port may be separated by\n        `sanic.headers.parse_host(request.host)`.\n\n        :return: the first matching host found, or empty string\n        :rtype: str\n        \"\"\"\n        server_name = self.app.config.get(\"SERVER_NAME\")\n        if server_name:\n            return server_name.split(\"//\", 1)[-1].split(\"/\", 1)[0]\n        return str(self.forwarded.get(\"host\") or self.headers.get(\"host\", \"\"))", "is_method": true, "class_name": "Request", "function_description": "Returns the effective server host for the current request, prioritizing configured server name, then forwarded host, and finally the request's host header. Useful for resolving the accurate hostname or hostname:port in server or proxy setups."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "server_name", "line_number": 614, "body": "def server_name(self) -> str:\n        \"\"\"\n        :return: hostname the client connected to, by ``request.host``\n        :rtype: str\n        \"\"\"\n        return parse_host(self.host)[0] or \"\"", "is_method": true, "class_name": "Request", "function_description": "Returns the hostname the client connected to, derived from the request's host attribute. Useful for identifying the server endpoint handling the current request."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "server_port", "line_number": 622, "body": "def server_port(self) -> int:\n        \"\"\"\n        The port the client connected to, by forwarded ``port`` or\n        ``request.host``.\n\n        Default port is returned as 80 and 443 based on ``request.scheme``.\n\n        :return: port number\n        :rtype: int\n        \"\"\"\n        port = self.forwarded.get(\"port\") or parse_host(self.host)[1]\n        return int(port or (80 if self.scheme in (\"http\", \"ws\") else 443))", "is_method": true, "class_name": "Request", "function_description": "Provides the network port number the client used to connect, considering forwarded headers or host information, with sensible defaults based on the request scheme. This enables identifying the connection endpoint in server requests."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "server_path", "line_number": 636, "body": "def server_path(self) -> str:\n        \"\"\"\n        :return: full path of current URL; uses proxied or local path\n        :rtype: str\n        \"\"\"\n        return str(self.forwarded.get(\"path\") or self.path)", "is_method": true, "class_name": "Request", "function_description": "Returns the full URL path of the current request, prioritizing a proxied path if available; useful for services needing accurate request routing or URL handling behind proxies."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "query_string", "line_number": 644, "body": "def query_string(self) -> str:\n        \"\"\"\n        :return: representation of the requested query\n        :rtype: str\n        \"\"\"\n        if self._parsed_url.query:\n            return self._parsed_url.query.decode(\"utf-8\")\n        else:\n            return \"\"", "is_method": true, "class_name": "Request", "function_description": "Returns the query string component of the request's URL as a decoded string. This enables easy access to URL parameters for processing or routing in web request handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "url", "line_number": 655, "body": "def url(self) -> str:\n        \"\"\"\n        :return: the URL\n        :rtype: str\n        \"\"\"\n        return urlunparse(\n            (self.scheme, self.host, self.path, None, self.query_string, None)\n        )", "is_method": true, "class_name": "Request", "function_description": "Returns the full URL string constructed from the Request object's components, providing a standardized way to access the request's complete URL."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "url_for", "line_number": 664, "body": "def url_for(self, view_name: str, **kwargs) -> str:\n        \"\"\"\n        Same as :func:`sanic.Sanic.url_for`, but automatically determine\n        `scheme` and `netloc` base on the request. Since this method is aiming\n        to generate correct schema & netloc, `_external` is implied.\n\n        :param kwargs: takes same parameters as in :func:`sanic.Sanic.url_for`\n        :return: an absolute url to the given view\n        :rtype: str\n        \"\"\"\n        # Full URL SERVER_NAME can only be handled in app.url_for\n        try:\n            if \"//\" in self.app.config.SERVER_NAME:\n                return self.app.url_for(view_name, _external=True, **kwargs)\n        except AttributeError:\n            pass\n\n        scheme = self.scheme\n        host = self.server_name\n        port = self.server_port\n\n        if (scheme.lower() in (\"http\", \"ws\") and port == 80) or (\n            scheme.lower() in (\"https\", \"wss\") and port == 443\n        ):\n            netloc = host\n        else:\n            netloc = f\"{host}:{port}\"\n\n        return self.app.url_for(\n            view_name, _external=True, _scheme=scheme, _server=netloc, **kwargs\n        )", "is_method": true, "class_name": "Request", "function_description": "Generates an absolute URL for a given view name, automatically determining the scheme and network location based on the current request context. This aids in creating fully qualified URLs within request handling workflows."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/reloader_helpers.py", "function": "_iter_module_files", "line_number": 9, "body": "def _iter_module_files():\n    \"\"\"This iterates over all relevant Python files.\n\n    It goes through all\n    loaded files from modules, all files in folders of already loaded modules\n    as well as all files reachable through a package.\n    \"\"\"\n    # The list call is necessary on Python 3 in case the module\n    # dictionary modifies during iteration.\n    for module in list(sys.modules.values()):\n        if module is None:\n            continue\n        filename = getattr(module, \"__file__\", None)\n        if filename:\n            old = None\n            while not os.path.isfile(filename):\n                old = filename\n                filename = os.path.dirname(filename)\n                if filename == old:\n                    break\n            else:\n                if filename[-4:] in (\".pyc\", \".pyo\"):\n                    filename = filename[:-1]\n                yield filename", "is_method": false, "function_description": "Utility function that iterates over the file paths of all Python source files associated with currently loaded modules, including their package and folder files, enabling systematic access to relevant module files in the runtime environment."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/reloader_helpers.py", "function": "_get_args_for_reloading", "line_number": 35, "body": "def _get_args_for_reloading():\n    \"\"\"Returns the executable.\"\"\"\n    main_module = sys.modules[\"__main__\"]\n    mod_spec = getattr(main_module, \"__spec__\", None)\n    if sys.argv[0] in (\"\", \"-c\"):\n        raise RuntimeError(\n            f\"Autoreloader cannot work with argv[0]={sys.argv[0]!r}\"\n        )\n    if mod_spec:\n        # Parent exe was launched as a module rather than a script\n        return [sys.executable, \"-m\", mod_spec.name] + sys.argv[1:]\n    return [sys.executable] + sys.argv", "is_method": false, "function_description": "Provides the command-line arguments needed to restart the current Python execution environment, handling module-based and script-based launches for autoreloading purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/reloader_helpers.py", "function": "restart_with_reloader", "line_number": 49, "body": "def restart_with_reloader():\n    \"\"\"Create a new process and a subprocess in it with the same arguments as\n    this one.\n    \"\"\"\n    return subprocess.Popen(\n        _get_args_for_reloading(),\n        env={**os.environ, \"SANIC_SERVER_RUNNING\": \"true\"},\n    )", "is_method": false, "function_description": "Function that restarts the current process by spawning a new subprocess with identical arguments, enabling automatic reloading typically used in development servers."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/reloader_helpers.py", "function": "watchdog", "line_number": 59, "body": "def watchdog(sleep_interval):\n    \"\"\"Watch project files, restart worker process if a change happened.\n\n    :param sleep_interval: interval in second.\n    :return: Nothing\n    \"\"\"\n\n    def interrupt_self(*args):\n        raise KeyboardInterrupt\n\n    mtimes = {}\n    signal.signal(signal.SIGTERM, interrupt_self)\n    if os.name == \"nt\":\n        signal.signal(signal.SIGBREAK, interrupt_self)\n\n    worker_process = restart_with_reloader()\n\n    try:\n        while True:\n            need_reload = False\n\n            for filename in _iter_module_files():\n                try:\n                    mtime = os.stat(filename).st_mtime\n                except OSError:\n                    continue\n\n                old_time = mtimes.get(filename)\n                if old_time is None:\n                    mtimes[filename] = mtime\n                elif mtime > old_time:\n                    mtimes[filename] = mtime\n                    need_reload = True\n\n            if need_reload:\n                worker_process.terminate()\n                worker_process.wait()\n                worker_process = restart_with_reloader()\n\n            sleep(sleep_interval)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        worker_process.terminate()\n        worker_process.wait()", "is_method": false, "function_description": "Monitors project files for changes and automatically restarts a worker process to apply updates. Useful for development environments requiring live code reloading without manual restarts."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/reloader_helpers.py", "function": "interrupt_self", "line_number": 66, "body": "def interrupt_self(*args):\n        raise KeyboardInterrupt", "is_method": false, "function_description": "This function immediately raises a KeyboardInterrupt exception, simulating an interrupt signal that can be used to halt execution or trigger interruption handling in other code."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/compat.py", "function": "ctrlc_workaround_for_windows", "line_number": 55, "body": "def ctrlc_workaround_for_windows(app):\n    async def stay_active(app):\n        \"\"\"Asyncio wakeups to allow receiving SIGINT in Python\"\"\"\n        while not die:\n            # If someone else stopped the app, just exit\n            if app.is_stopping:\n                return\n            # Windows Python blocks signal handlers while the event loop is\n            # waiting for I/O. Frequent wakeups keep interrupts flowing.\n            await asyncio.sleep(0.1)\n        # Can't be called from signal handler, so call it from here\n        app.stop()\n\n    def ctrlc_handler(sig, frame):\n        nonlocal die\n        if die:\n            raise KeyboardInterrupt(\"Non-graceful Ctrl+C\")\n        die = True\n\n    die = False\n    signal.signal(signal.SIGINT, ctrlc_handler)\n    app.add_task(stay_active)", "is_method": false, "function_description": "Provides a workaround for Windows to ensure the application properly handles Ctrl+C (SIGINT) signals by keeping the event loop frequently active, enabling graceful shutdown on user interrupt."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/compat.py", "function": "get_all", "line_number": 28, "body": "def get_all(self, key: str):\n        \"\"\"\n        Convenience method mapped to ``getall()``.\n        \"\"\"\n        return self.getall(key, default=[])", "is_method": true, "class_name": "Header", "function_description": "Utility method in Header class that retrieves all values associated with a specified key, returning an empty list if the key is not present."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/compat.py", "function": "stat_async", "line_number": 40, "body": "def stat_async(path):\n        return trio.Path(path).stat()", "is_method": false, "function_description": "Returns file or directory metadata asynchronously using the Trio library, enabling non-blocking retrieval of filesystem information."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/compat.py", "function": "ctrlc_handler", "line_number": 68, "body": "def ctrlc_handler(sig, frame):\n        nonlocal die\n        if die:\n            raise KeyboardInterrupt(\"Non-graceful Ctrl+C\")\n        die = True", "is_method": false, "function_description": "Function that manages Ctrl+C interrupts, allowing a graceful shutdown on first press and raising an exception on subsequent presses to force termination."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "init_process", "line_number": 45, "body": "def init_process(self):\n        # create new event_loop after fork\n        asyncio.get_event_loop().close()\n\n        self.loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self.loop)\n\n        super().init_process()", "is_method": true, "class_name": "GunicornWorker", "function_description": "Initializes the worker process by setting up a new asyncio event loop after process forking to ensure asynchronous operations function correctly within the GunicornWorker."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "run", "line_number": 54, "body": "def run(self):\n        is_debug = self.log.loglevel == logging.DEBUG\n        protocol = (\n            self.websocket_protocol\n            if self.app.callable.websocket_enabled\n            else self.http_protocol\n        )\n\n        self._server_settings = self.app.callable._helper(\n            loop=self.loop,\n            debug=is_debug,\n            protocol=protocol,\n            ssl=self.ssl_context,\n            run_async=True,\n        )\n        self._server_settings[\"signal\"] = self.signal\n        self._server_settings.pop(\"sock\")\n        trigger_events(\n            self._server_settings.get(\"before_start\", []), self.loop\n        )\n        self._server_settings[\"before_start\"] = ()\n\n        main_start = self._server_settings.pop(\"main_start\", None)\n        main_stop = self._server_settings.pop(\"main_stop\", None)\n\n        if main_start or main_stop:  # noqa\n            logger.warning(\n                \"Listener events for the main process are not available \"\n                \"with GunicornWorker\"\n            )\n\n        self._runner = asyncio.ensure_future(self._run(), loop=self.loop)\n        try:\n            self.loop.run_until_complete(self._runner)\n            self.app.callable.is_running = True\n            trigger_events(\n                self._server_settings.get(\"after_start\", []), self.loop\n            )\n            self.loop.run_until_complete(self._check_alive())\n            trigger_events(\n                self._server_settings.get(\"before_stop\", []), self.loop\n            )\n            self.loop.run_until_complete(self.close())\n        except BaseException:\n            traceback.print_exc()\n        finally:\n            try:\n                trigger_events(\n                    self._server_settings.get(\"after_stop\", []), self.loop\n                )\n            except BaseException:\n                traceback.print_exc()\n            finally:\n                self.loop.close()\n\n        sys.exit(self.exit_code)", "is_method": true, "class_name": "GunicornWorker", "function_description": "Runs the GunicornWorker's asynchronous server lifecycle, managing startup, event triggering, graceful shutdown, and cleanup within an asyncio event loop. It coordinates protocol selection and server settings for handling HTTP or WebSocket connections."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "_create_ssl_context", "line_number": 186, "body": "def _create_ssl_context(cfg):\n        \"\"\"Creates SSLContext instance for usage in asyncio.create_server.\n        See ssl.SSLSocket.__init__ for more details.\n        \"\"\"\n        ctx = ssl.SSLContext(cfg.ssl_version)\n        ctx.load_cert_chain(cfg.certfile, cfg.keyfile)\n        ctx.verify_mode = cfg.cert_reqs\n        if cfg.ca_certs:\n            ctx.load_verify_locations(cfg.ca_certs)\n        if cfg.ciphers:\n            ctx.set_ciphers(cfg.ciphers)\n        return ctx", "is_method": true, "class_name": "GunicornWorker", "function_description": "Creates and configures an SSLContext object based on provided settings, enabling secure SSL/TLS communication for servers using asyncio. This function is essential for setting up encrypted connections with specified certificates and security options."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "init_signals", "line_number": 199, "body": "def init_signals(self):\n        # Set up signals through the event loop API.\n\n        self.loop.add_signal_handler(\n            signal.SIGQUIT, self.handle_quit, signal.SIGQUIT, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGTERM, self.handle_exit, signal.SIGTERM, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGINT, self.handle_quit, signal.SIGINT, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGWINCH, self.handle_winch, signal.SIGWINCH, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGUSR1, self.handle_usr1, signal.SIGUSR1, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGABRT, self.handle_abort, signal.SIGABRT, None\n        )\n\n        # Don't let SIGTERM and SIGUSR1 disturb active requests\n        # by interrupting system calls\n        signal.siginterrupt(signal.SIGTERM, False)\n        signal.siginterrupt(signal.SIGUSR1, False)", "is_method": true, "class_name": "GunicornWorker", "function_description": "Sets up asynchronous signal handlers within the worker's event loop to manage process termination, interruption, and custom signals, ensuring graceful handling of system signals without disrupting active requests."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "handle_quit", "line_number": 231, "body": "def handle_quit(self, sig, frame):\n        self.alive = False\n        self.app.callable.is_running = False\n        self.cfg.worker_int(self)", "is_method": true, "class_name": "GunicornWorker", "function_description": "Handles the worker shutdown process by marking it as inactive and invoking the configured interrupt callback to gracefully stop the running application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "handle_abort", "line_number": 236, "body": "def handle_abort(self, sig, frame):\n        self.alive = False\n        self.exit_code = 1\n        self.cfg.worker_abort(self)\n        sys.exit(1)", "is_method": true, "class_name": "GunicornWorker", "function_description": "Handles worker abort signals by performing cleanup, marking the worker as inactive, and terminating the process with an exit code. It ensures proper shutdown within the GunicornWorker lifecycle upon receiving an abort signal."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "empty", "line_number": 239, "body": "def empty(\n    status=204, headers: Optional[Dict[str, str]] = None\n) -> HTTPResponse:\n    \"\"\"\n    Returns an empty response to the client.\n\n    :param status Response code.\n    :param headers Custom Headers.\n    \"\"\"\n    return HTTPResponse(body=b\"\", status=status, headers=headers)", "is_method": false, "function_description": "Function that generates an empty HTTP response with customizable status code and headers, useful for signaling successful requests without content."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "json", "line_number": 251, "body": "def json(\n    body: Any,\n    status: int = 200,\n    headers: Optional[Dict[str, str]] = None,\n    content_type: str = \"application/json\",\n    dumps: Optional[Callable[..., str]] = None,\n    **kwargs,\n) -> HTTPResponse:\n    \"\"\"\n    Returns response object with body in json format.\n\n    :param body: Response data to be serialized.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    :param kwargs: Remaining arguments that are passed to the json encoder.\n    \"\"\"\n    if not dumps:\n        dumps = BaseHTTPResponse._dumps\n    return HTTPResponse(\n        dumps(body, **kwargs),\n        headers=headers,\n        status=status,\n        content_type=content_type,\n    )", "is_method": false, "function_description": "This function creates an HTTP response with a JSON-formatted body, status code, and optional headers. It simplifies returning JSON responses in web applications or APIs, supporting custom serialization and content types."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "text", "line_number": 277, "body": "def text(\n    body: str,\n    status: int = 200,\n    headers: Optional[Dict[str, str]] = None,\n    content_type: str = \"text/plain; charset=utf-8\",\n) -> HTTPResponse:\n    \"\"\"\n    Returns response object with body in text format.\n\n    :param body: Response data to be encoded.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    :param content_type: the content type (string) of the response\n    \"\"\"\n    if not isinstance(body, str):\n        raise TypeError(\n            f\"Bad body type. Expected str, got {type(body).__name__})\"\n        )\n\n    return HTTPResponse(\n        body, status=status, headers=headers, content_type=content_type\n    )", "is_method": false, "function_description": "Function that creates an HTTP response object containing a plain text body, customizable status code, headers, and content type for use in web responses."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "raw", "line_number": 301, "body": "def raw(\n    body: Optional[AnyStr],\n    status: int = 200,\n    headers: Optional[Dict[str, str]] = None,\n    content_type: str = DEFAULT_HTTP_CONTENT_TYPE,\n) -> HTTPResponse:\n    \"\"\"\n    Returns response object without encoding the body.\n\n    :param body: Response data.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    :param content_type: the content type (string) of the response.\n    \"\"\"\n    return HTTPResponse(\n        body=body,\n        status=status,\n        headers=headers,\n        content_type=content_type,\n    )", "is_method": false, "function_description": "Function that creates an HTTP response object with a raw body, allowing custom status, headers, and content type without any body encoding. Useful for returning predefined or pre-encoded response content directly."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "html", "line_number": 323, "body": "def html(\n    body: Union[str, bytes, HTMLProtocol],\n    status: int = 200,\n    headers: Optional[Dict[str, str]] = None,\n) -> HTTPResponse:\n    \"\"\"\n    Returns response object with body in html format.\n\n    :param body: str or bytes-ish, or an object with __html__ or _repr_html_.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    \"\"\"\n    if not isinstance(body, (str, bytes)):\n        if hasattr(body, \"__html__\"):\n            body = body.__html__()\n        elif hasattr(body, \"_repr_html_\"):\n            body = body._repr_html_()\n\n    return HTTPResponse(  # type: ignore\n        body,\n        status=status,\n        headers=headers,\n        content_type=\"text/html; charset=utf-8\",\n    )", "is_method": false, "function_description": "Function that creates an HTTP response with an HTML-formatted body, supporting strings, bytes, or objects with HTML representation methods. It enables customizing status codes and headers for web response handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "stream", "line_number": 459, "body": "def stream(\n    streaming_fn: StreamingFunction,\n    status: int = 200,\n    headers: Optional[Dict[str, str]] = None,\n    content_type: str = \"text/plain; charset=utf-8\",\n    chunked=\"deprecated\",\n):\n    \"\"\"Accepts an coroutine `streaming_fn` which can be used to\n    write chunks to a streaming response. Returns a `StreamingHTTPResponse`.\n\n    Example usage::\n\n        @app.route(\"/\")\n        async def index(request):\n            async def streaming_fn(response):\n                await response.write('foo')\n                await response.write('bar')\n\n            return stream(streaming_fn, content_type='text/plain')\n\n    :param streaming_fn: A coroutine accepts a response and\n        writes content to that response.\n    :param mime_type: Specific mime_type.\n    :param headers: Custom Headers.\n    :param chunked: Deprecated\n    \"\"\"\n    if chunked != \"deprecated\":\n        warn(\n            \"The chunked argument has been deprecated and will be \"\n            \"removed in v21.6\"\n        )\n\n    return StreamingHTTPResponse(\n        streaming_fn,\n        headers=headers,\n        content_type=content_type,\n        status=status,\n    )", "is_method": false, "function_description": "Utility function that wraps an asynchronous coroutine to create and return a streaming HTTP response with optional status, headers, and content type for sending chunked content to clients."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "redirect", "line_number": 499, "body": "def redirect(\n    to: str,\n    headers: Optional[Dict[str, str]] = None,\n    status: int = 302,\n    content_type: str = \"text/html; charset=utf-8\",\n) -> HTTPResponse:\n    \"\"\"\n    Abort execution and cause a 302 redirect (by default) by setting a\n    Location header.\n\n    :param to: path or fully qualified URL to redirect to\n    :param headers: optional dict of headers to include in the new request\n    :param status: status code (int) of the new request, defaults to 302\n    :param content_type: the content type (string) of the response\n    \"\"\"\n    headers = headers or {}\n\n    # URL Quote the URL before redirecting\n    safe_to = quote_plus(to, safe=\":/%#?&=@[]!$&'()*+,;\")\n\n    # According to RFC 7231, a relative URI is now permitted.\n    headers[\"Location\"] = safe_to\n\n    return HTTPResponse(\n        status=status, headers=headers, content_type=content_type\n    )", "is_method": false, "function_description": "Function providing an HTTP redirect response by setting the Location header to a specified URL or path, with customizable status code, headers, and content type. Useful for web applications to direct clients to different resources or URLs."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "_encode_body", "line_number": 53, "body": "def _encode_body(self, data: Optional[AnyStr]):\n        if data is None:\n            return b\"\"\n        return (\n            data.encode() if hasattr(data, \"encode\") else data  # type: ignore\n        )", "is_method": true, "class_name": "BaseHTTPResponse", "function_description": "Internal helper of BaseHTTPResponse that converts body data to bytes, supporting both string encoding and raw byte input for HTTP response handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "cookies", "line_number": 61, "body": "def cookies(self) -> CookieJar:\n        \"\"\"\n        The response cookies. Cookies should be set and written as follows:\n\n        .. code-block:: python\n\n                response.cookies[\"test\"] = \"It worked!\"\n                response.cookies[\"test\"][\"domain\"] = \".yummy-yummy-cookie.com\"\n                response.cookies[\"test\"][\"httponly\"] = True\n\n        `See user guide re: cookies\n        <https://sanicframework.org/guide/basics/cookies.html>`__\n\n        :return: the cookie jar\n        :rtype: CookieJar\n        \"\"\"\n        if self._cookies is None:\n            self._cookies = CookieJar(self.headers)\n        return self._cookies", "is_method": true, "class_name": "BaseHTTPResponse", "function_description": "Provides access to the response's cookie container, allowing other functions to set, retrieve, and manage HTTP cookies associated with the response."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "processed_headers", "line_number": 82, "body": "def processed_headers(self) -> Iterator[Tuple[bytes, bytes]]:\n        \"\"\"\n        Obtain a list of header tuples encoded in bytes for sending.\n\n        Add and remove headers based on status and content_type.\n\n        :return: response headers\n        :rtype: Tuple[Tuple[bytes, bytes], ...]\n        \"\"\"\n        # TODO: Make a blacklist set of header names and then filter with that\n        if self.status in (304, 412):  # Not Modified, Precondition Failed\n            self.headers = remove_entity_headers(self.headers)\n        if has_message_body(self.status):\n            self.headers.setdefault(\"content-type\", self.content_type)\n        # Encode headers into bytes\n        return (\n            (name.encode(\"ascii\"), f\"{value}\".encode(errors=\"surrogateescape\"))\n            for name, value in self.headers.items()\n        )", "is_method": true, "class_name": "BaseHTTPResponse", "function_description": "Generates the HTTP response headers as byte-encoded tuples, adjusting them based on status and content type for accurate transmission. Useful for preparing headers in network communication within HTTP responses."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "escape", "line_number": 329, "body": "def escape(text):\n    \"\"\"\n    Minimal HTML escaping, not for attribute values (unlike html.escape).\n    \"\"\"\n    return f\"{text}\".replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\")", "is_method": false, "function_description": "Function that performs minimal escaping of HTML text to replace ampersands and less-than signs, useful for safely displaying text content while avoiding attribute value escaping."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "exception_response", "line_number": 349, "body": "def exception_response(\n    request: Request,\n    exception: Exception,\n    debug: bool,\n    renderer: t.Type[t.Optional[BaseRenderer]] = None,\n) -> HTTPResponse:\n    \"\"\"\n    Render a response for the default FALLBACK exception handler.\n    \"\"\"\n\n    if not renderer:\n        renderer = HTMLRenderer\n\n        if request:\n            if request.app.config.FALLBACK_ERROR_FORMAT == \"auto\":\n                try:\n                    renderer = JSONRenderer if request.json else HTMLRenderer\n                except InvalidUsage:\n                    renderer = HTMLRenderer\n\n                content_type, *_ = request.headers.get(\n                    \"content-type\", \"\"\n                ).split(\";\")\n                renderer = RENDERERS_BY_CONTENT_TYPE.get(\n                    content_type, renderer\n                )\n            else:\n                render_format = request.app.config.FALLBACK_ERROR_FORMAT\n                renderer = RENDERERS_BY_CONFIG.get(render_format, renderer)\n\n    renderer = t.cast(t.Type[BaseRenderer], renderer)\n    return renderer(request, exception, debug).render()", "is_method": false, "function_description": "Provides a standardized HTTP response for exceptions using a configurable renderer based on request format and app settings, supporting customizable error output in web applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "headers", "line_number": 54, "body": "def headers(self):\n        if isinstance(self.exception, SanicException):\n            return getattr(self.exception, \"headers\", {})\n        return {}", "is_method": true, "class_name": "BaseRenderer", "function_description": "Utility method in BaseRenderer that returns HTTP headers from a SanicException if present, supporting consistent error response handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "status", "line_number": 60, "body": "def status(self):\n        if isinstance(self.exception, SanicException):\n            return getattr(self.exception, \"status_code\", FALLBACK_STATUS)\n        return FALLBACK_STATUS", "is_method": true, "class_name": "BaseRenderer", "function_description": "Provides the HTTP status code from a stored exception if it is a SanicException; otherwise, returns a default fallback status code. This supports consistent error response handling in rendering processes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "text", "line_number": 66, "body": "def text(self):\n        if self.debug or isinstance(self.exception, SanicException):\n            return str(self.exception)\n        return FALLBACK_TEXT", "is_method": true, "class_name": "BaseRenderer", "function_description": "Core method of the BaseRenderer class that returns the string representation of an exception when debugging or handling known exceptions, otherwise providing a default fallback message."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "title", "line_number": 72, "body": "def title(self):\n        status_text = STATUS_CODES.get(self.status, b\"Error Occurred\").decode()\n        return f\"{self.status} \u2014 {status_text}\"", "is_method": true, "class_name": "BaseRenderer", "function_description": "Returns a formatted string combining the status code and its corresponding text description, useful for clearly presenting response statuses in the BaseRenderer context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "render", "line_number": 76, "body": "def render(self) -> HTTPResponse:\n        \"\"\"\n        Outputs the exception as a :class:`HTTPResponse`.\n\n        :return: The formatted exception\n        :rtype: str\n        \"\"\"\n        output = (\n            self.full\n            if self.debug and not getattr(self.exception, \"quiet\", False)\n            else self.minimal\n        )\n        return output()", "is_method": true, "class_name": "BaseRenderer", "function_description": "Core method of the BaseRenderer class that generates an HTTP response representing an exception, delivering either a detailed or minimal formatted output based on debug settings and exception properties."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "full", "line_number": 149, "body": "def full(self) -> HTTPResponse:\n        return html(\n            self.OUTPUT_HTML.format(\n                title=self.title,\n                text=self.text,\n                style=self.TRACEBACK_STYLE,\n                body=self._generate_body(),\n            ),\n            status=self.status,\n        )", "is_method": true, "class_name": "HTMLRenderer", "function_description": "Method of HTMLRenderer that generates a complete HTTP response with a formatted HTML page including title, text, style, and body content, suitable for rendering full HTML outputs with proper status codes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "minimal", "line_number": 160, "body": "def minimal(self) -> HTTPResponse:\n        return html(\n            self.OUTPUT_HTML.format(\n                title=self.title,\n                text=self.text,\n                style=self.TRACEBACK_STYLE,\n                body=\"\",\n            ),\n            status=self.status,\n            headers=self.headers,\n        )", "is_method": true, "class_name": "HTMLRenderer", "function_description": "Returns a minimal HTTP response with empty body content, applying predefined HTML formatting and styles. Useful for generating simple, styled error or status pages in web applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "text", "line_number": 173, "body": "def text(self):\n        return escape(super().text)", "is_method": true, "class_name": "HTMLRenderer", "function_description": "Returns the HTML-escaped version of the text content, ensuring safe rendering by preventing HTML injection or parsing errors."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "title", "line_number": 177, "body": "def title(self):\n        return escape(f\"\u26a0\ufe0f {super().title}\")", "is_method": true, "class_name": "HTMLRenderer", "function_description": "Returns the HTML title string with a warning emoji prepended, providing a customized and escaped title for display in rendered HTML pages."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "_generate_body", "line_number": 180, "body": "def _generate_body(self):\n        _, exc_value, __ = sys.exc_info()\n        exceptions = []\n        while exc_value:\n            exceptions.append(self._format_exc(exc_value))\n            exc_value = exc_value.__cause__\n\n        traceback_html = self.TRACEBACK_BORDER.join(reversed(exceptions))\n        appname = escape(self.request.app.name)\n        name = escape(self.exception.__class__.__name__)\n        value = escape(self.exception)\n        path = escape(self.request.path)\n        lines = [\n            f\"<h2>Traceback of {appname} (most recent call last):</h2>\",\n            f\"{traceback_html}\",\n            \"<div class=summary><p>\",\n            f\"<b>{name}: {value}</b> while handling path <code>{path}</code>\",\n            \"</div>\",\n        ]\n        return \"\\n\".join(lines)", "is_method": true, "class_name": "HTMLRenderer", "function_description": "Generates an HTML-formatted detailed traceback of the current exception, including its causes and request context, for displaying error information in a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "_format_exc", "line_number": 201, "body": "def _format_exc(self, exc):\n        frames = extract_tb(exc.__traceback__)\n        frame_html = \"\".join(\n            self.TRACEBACK_LINE_HTML.format(frame) for frame in frames\n        )\n        return self.TRACEBACK_WRAPPER_HTML.format(\n            exc_name=escape(exc.__class__.__name__),\n            exc_value=escape(exc),\n            frame_html=frame_html,\n        )", "is_method": true, "class_name": "HTMLRenderer", "function_description": "Internal HTMLRenderer method that formats an exception and its traceback into an HTML representation for displaying detailed error information in web contexts."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "full", "line_number": 221, "body": "def full(self) -> HTTPResponse:\n        return text(\n            self.OUTPUT_TEXT.format(\n                title=self.title,\n                text=self.text,\n                bar=(\"=\" * len(self.title)),\n                body=self._generate_body(),\n            ),\n            status=self.status,\n        )", "is_method": true, "class_name": "TextRenderer", "function_description": "Returns a complete HTTP response containing a formatted text representation with title, body, and status, enabling consistent text-based output rendering in web applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "minimal", "line_number": 232, "body": "def minimal(self) -> HTTPResponse:\n        return text(\n            self.OUTPUT_TEXT.format(\n                title=self.title,\n                text=self.text,\n                bar=(\"=\" * len(self.title)),\n                body=\"\",\n            ),\n            status=self.status,\n            headers=self.headers,\n        )", "is_method": true, "class_name": "TextRenderer", "function_description": "Returns a simple HTTP response containing a formatted plain-text message with a title and status, suitable for minimal text-based output in web applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "title", "line_number": 245, "body": "def title(self):\n        return f\"\u26a0\ufe0f {super().title}\"", "is_method": true, "class_name": "TextRenderer", "function_description": "Overrides the title property to prepend a warning emoji, providing a visually distinctive title for rendered text. This can be used to highlight important or cautionary messages in the rendered output."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "_generate_body", "line_number": 248, "body": "def _generate_body(self):\n        _, exc_value, __ = sys.exc_info()\n        exceptions = []\n\n        lines = [\n            f\"{self.exception.__class__.__name__}: {self.exception} while \"\n            f\"handling path {self.request.path}\",\n            f\"Traceback of {self.request.app.name} (most recent call last):\\n\",\n        ]\n\n        while exc_value:\n            exceptions.append(self._format_exc(exc_value))\n            exc_value = exc_value.__cause__\n\n        return \"\\n\".join(lines + exceptions[::-1])", "is_method": true, "class_name": "TextRenderer", "function_description": "Generates a detailed error message body including the exception type, message, request path, and traceback chain for displaying error information in the TextRenderer context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "_format_exc", "line_number": 264, "body": "def _format_exc(self, exc):\n        frames = \"\\n\\n\".join(\n            [\n                f\"{self.SPACER * 2}File {frame.filename}, \"\n                f\"line {frame.lineno}, in \"\n                f\"{frame.name}\\n{self.SPACER * 2}{frame.line}\"\n                for frame in extract_tb(exc.__traceback__)\n            ]\n        )\n        return f\"{self.SPACER}{exc.__class__.__name__}: {exc}\\n{frames}\"", "is_method": true, "class_name": "TextRenderer", "function_description": "Utility method in TextRenderer that formats an exception's traceback into a readable string showing detailed frame information for improved error reporting or logging."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "full", "line_number": 281, "body": "def full(self) -> HTTPResponse:\n        output = self._generate_output(full=True)\n        return json(output, status=self.status, dumps=dumps)", "is_method": true, "class_name": "JSONRenderer", "function_description": "Utility method of JSONRenderer that generates and returns a complete JSON HTTP response, encapsulating the full content output with appropriate status and serialization settings."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "minimal", "line_number": 285, "body": "def minimal(self) -> HTTPResponse:\n        output = self._generate_output(full=False)\n        return json(output, status=self.status, dumps=dumps)", "is_method": true, "class_name": "JSONRenderer", "function_description": "Utility method of the JSONRenderer class that generates and returns a simplified JSON HTTP response, excluding detailed data to provide a minimal output representation."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "_generate_output", "line_number": 289, "body": "def _generate_output(self, *, full):\n        output = {\n            \"description\": self.title,\n            \"status\": self.status,\n            \"message\": self.text,\n        }\n\n        if full:\n            _, exc_value, __ = sys.exc_info()\n            exceptions = []\n\n            while exc_value:\n                exceptions.append(\n                    {\n                        \"type\": exc_value.__class__.__name__,\n                        \"exception\": str(exc_value),\n                        \"frames\": [\n                            {\n                                \"file\": frame.filename,\n                                \"line\": frame.lineno,\n                                \"name\": frame.name,\n                                \"src\": frame.line,\n                            }\n                            for frame in extract_tb(exc_value.__traceback__)\n                        ],\n                    }\n                )\n                exc_value = exc_value.__cause__\n\n            output[\"path\"] = self.request.path\n            output[\"args\"] = self.request.args\n            output[\"exceptions\"] = exceptions[::-1]\n\n        return output", "is_method": true, "class_name": "JSONRenderer", "function_description": "Core method of the JSONRenderer class that generates a structured output dictionary summarizing the response status, message, and optionally detailed request and exception trace information. It supports enhanced debugging by including full error context when requested."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "title", "line_number": 325, "body": "def title(self):\n        return STATUS_CODES.get(self.status, b\"Error Occurred\").decode()", "is_method": true, "class_name": "JSONRenderer", "function_description": "Returns the HTTP status message matching the response status code, providing a readable title for the JSON response in the JSONRenderer class."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "trigger_events", "line_number": 343, "body": "def trigger_events(events: Optional[Iterable[Callable[..., Any]]], loop):\n    \"\"\"\n    Trigger event callbacks (functions or async)\n\n    :param events: one or more sync or async functions to execute\n    :param loop: event loop\n    \"\"\"\n    if events:\n        for event in events:\n            result = event(loop)\n            if isawaitable(result):\n                loop.run_until_complete(result)", "is_method": false, "function_description": "Function that executes a list of synchronous or asynchronous event callbacks within a specified event loop, ensuring all events are properly triggered and awaited if necessary. Useful for managing and running multiple event handlers in asynchronous applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "serve", "line_number": 457, "body": "def serve(\n    host,\n    port,\n    app,\n    before_start: Optional[Iterable[ListenerType]] = None,\n    after_start: Optional[Iterable[ListenerType]] = None,\n    before_stop: Optional[Iterable[ListenerType]] = None,\n    after_stop: Optional[Iterable[ListenerType]] = None,\n    ssl: Optional[SSLContext] = None,\n    sock: Optional[socket.socket] = None,\n    unix: Optional[str] = None,\n    reuse_port: bool = False,\n    loop=None,\n    protocol: Type[asyncio.Protocol] = HttpProtocol,\n    backlog: int = 100,\n    register_sys_signals: bool = True,\n    run_multiple: bool = False,\n    run_async: bool = False,\n    connections=None,\n    signal=Signal(),\n    state=None,\n    asyncio_server_kwargs=None,\n):\n    \"\"\"Start asynchronous HTTP Server on an individual process.\n\n    :param host: Address to host on\n    :param port: Port to host on\n    :param before_start: function to be executed before the server starts\n                         listening. Takes arguments `app` instance and `loop`\n    :param after_start: function to be executed after the server starts\n                        listening. Takes  arguments `app` instance and `loop`\n    :param before_stop: function to be executed when a stop signal is\n                        received before it is respected. Takes arguments\n                        `app` instance and `loop`\n    :param after_stop: function to be executed when a stop signal is\n                       received after it is respected. Takes arguments\n                       `app` instance and `loop`\n    :param ssl: SSLContext\n    :param sock: Socket for the server to accept connections from\n    :param unix: Unix socket to listen on instead of TCP port\n    :param reuse_port: `True` for multiple workers\n    :param loop: asyncio compatible event loop\n    :param run_async: bool: Do not create a new event loop for the server,\n                      and return an AsyncServer object rather than running it\n    :param asyncio_server_kwargs: key-value args for asyncio/uvloop\n                                  create_server method\n    :return: Nothing\n    \"\"\"\n    if not run_async and not loop:\n        # create new event_loop after fork\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n    if app.debug:\n        loop.set_debug(app.debug)\n\n    app.asgi = False\n\n    connections = connections if connections is not None else set()\n    protocol_kwargs = _build_protocol_kwargs(protocol, app.config)\n    server = partial(\n        protocol,\n        loop=loop,\n        connections=connections,\n        signal=signal,\n        app=app,\n        state=state,\n        unix=unix,\n        **protocol_kwargs,\n    )\n    asyncio_server_kwargs = (\n        asyncio_server_kwargs if asyncio_server_kwargs else {}\n    )\n    # UNIX sockets are always bound by us (to preserve semantics between modes)\n    if unix:\n        sock = bind_unix_socket(unix, backlog=backlog)\n    server_coroutine = loop.create_server(\n        server,\n        None if sock else host,\n        None if sock else port,\n        ssl=ssl,\n        reuse_port=reuse_port,\n        sock=sock,\n        backlog=backlog,\n        **asyncio_server_kwargs,\n    )\n\n    if run_async:\n        return AsyncioServer(\n            loop=loop,\n            serve_coro=server_coroutine,\n            connections=connections,\n            after_start=after_start,\n            before_stop=before_stop,\n            after_stop=after_stop,\n        )\n\n    trigger_events(before_start, loop)\n\n    try:\n        http_server = loop.run_until_complete(server_coroutine)\n    except BaseException:\n        logger.exception(\"Unable to start server\")\n        return\n\n    trigger_events(after_start, loop)\n\n    # Ignore SIGINT when run_multiple\n    if run_multiple:\n        signal_func(SIGINT, SIG_IGN)\n\n    # Register signals for graceful termination\n    if register_sys_signals:\n        if OS_IS_WINDOWS:\n            ctrlc_workaround_for_windows(app)\n        else:\n            for _signal in [SIGTERM] if run_multiple else [SIGINT, SIGTERM]:\n                loop.add_signal_handler(_signal, app.stop)\n    pid = os.getpid()\n    try:\n        logger.info(\"Starting worker [%s]\", pid)\n        loop.run_forever()\n    finally:\n        logger.info(\"Stopping worker [%s]\", pid)\n\n        # Run the on_stop function if provided\n        trigger_events(before_stop, loop)\n\n        # Wait for event loop to finish and all connections to drain\n        http_server.close()\n        loop.run_until_complete(http_server.wait_closed())\n\n        # Complete all tasks on the loop\n        signal.stopped = True\n        for connection in connections:\n            connection.close_if_idle()\n\n        # Gracefully shutdown timeout.\n        # We should provide graceful_shutdown_timeout,\n        # instead of letting connection hangs forever.\n        # Let's roughly calcucate time.\n        graceful = app.config.GRACEFUL_SHUTDOWN_TIMEOUT\n        start_shutdown: float = 0\n        while connections and (start_shutdown < graceful):\n            loop.run_until_complete(asyncio.sleep(0.1))\n            start_shutdown = start_shutdown + 0.1\n\n        # Force close non-idle connection after waiting for\n        # graceful_shutdown_timeout\n        coros = []\n        for conn in connections:\n            if hasattr(conn, \"websocket\") and conn.websocket:\n                coros.append(conn.websocket.close_connection())\n            else:\n                conn.close()\n\n        _shutdown = asyncio.gather(*coros)\n        loop.run_until_complete(_shutdown)\n\n        trigger_events(after_stop, loop)\n\n        remove_unix_socket(unix)", "is_method": false, "function_description": "Function that starts and manages an asynchronous HTTP server with customizable lifecycle event hooks, SSL support, and connection handling. It enables running the server in various modes including synchronous, asynchronous, and multi-worker setups."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "_build_protocol_kwargs", "line_number": 621, "body": "def _build_protocol_kwargs(\n    protocol: Type[asyncio.Protocol], config: Config\n) -> Dict[str, Union[int, float]]:\n    if hasattr(protocol, \"websocket_handshake\"):\n        return {\n            \"websocket_max_size\": config.WEBSOCKET_MAX_SIZE,\n            \"websocket_max_queue\": config.WEBSOCKET_MAX_QUEUE,\n            \"websocket_read_limit\": config.WEBSOCKET_READ_LIMIT,\n            \"websocket_write_limit\": config.WEBSOCKET_WRITE_LIMIT,\n            \"websocket_ping_timeout\": config.WEBSOCKET_PING_TIMEOUT,\n            \"websocket_ping_interval\": config.WEBSOCKET_PING_INTERVAL,\n        }\n    return {}", "is_method": false, "function_description": "Utility function that prepares and returns WebSocket-related configuration parameters if the given protocol supports WebSocket handshake, enabling consistent WebSocket settings for asyncio protocols."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "bind_socket", "line_number": 636, "body": "def bind_socket(host: str, port: int, *, backlog=100) -> socket.socket:\n    \"\"\"Create TCP server socket.\n    :param host: IPv4, IPv6 or hostname may be specified\n    :param port: TCP port number\n    :param backlog: Maximum number of connections to queue\n    :return: socket.socket object\n    \"\"\"\n    try:  # IP address: family must be specified for IPv6 at least\n        ip = ip_address(host)\n        host = str(ip)\n        sock = socket.socket(\n            socket.AF_INET6 if ip.version == 6 else socket.AF_INET\n        )\n    except ValueError:  # Hostname, may become AF_INET or AF_INET6\n        sock = socket.socket()\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.bind((host, port))\n    sock.listen(backlog)\n    return sock", "is_method": false, "function_description": "Utility function that creates and configures a TCP server socket bound to the specified host and port, supporting both IPv4 and IPv6, with customizable connection backlog for handling incoming client connections."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "bind_unix_socket", "line_number": 657, "body": "def bind_unix_socket(path: str, *, mode=0o666, backlog=100) -> socket.socket:\n    \"\"\"Create unix socket.\n    :param path: filesystem path\n    :param backlog: Maximum number of connections to queue\n    :return: socket.socket object\n    \"\"\"\n    \"\"\"Open or atomically replace existing socket with zero downtime.\"\"\"\n    # Sanitise and pre-verify socket path\n    path = os.path.abspath(path)\n    folder = os.path.dirname(path)\n    if not os.path.isdir(folder):\n        raise FileNotFoundError(f\"Socket folder does not exist: {folder}\")\n    try:\n        if not stat.S_ISSOCK(os.stat(path, follow_symlinks=False).st_mode):\n            raise FileExistsError(f\"Existing file is not a socket: {path}\")\n    except FileNotFoundError:\n        pass\n    # Create new socket with a random temporary name\n    tmp_path = f\"{path}.{secrets.token_urlsafe()}\"\n    sock = socket.socket(socket.AF_UNIX)\n    try:\n        # Critical section begins (filename races)\n        sock.bind(tmp_path)\n        try:\n            os.chmod(tmp_path, mode)\n            # Start listening before rename to avoid connection failures\n            sock.listen(backlog)\n            os.rename(tmp_path, path)\n        except:  # noqa: E722\n            try:\n                os.unlink(tmp_path)\n            finally:\n                raise\n    except:  # noqa: E722\n        try:\n            sock.close()\n        finally:\n            raise\n    return sock", "is_method": false, "function_description": "Function that creates and binds a UNIX domain socket at a specified filesystem path, ensuring atomic replacement and zero downtime by safely swapping the socket file. It\u2019s useful for setting up reliable inter-process communication endpoints."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "remove_unix_socket", "line_number": 698, "body": "def remove_unix_socket(path: Optional[str]) -> None:\n    \"\"\"Remove dead unix socket during server exit.\"\"\"\n    if not path:\n        return\n    try:\n        if stat.S_ISSOCK(os.stat(path, follow_symlinks=False).st_mode):\n            # Is it actually dead (doesn't belong to a new server instance)?\n            with socket.socket(socket.AF_UNIX) as testsock:\n                try:\n                    testsock.connect(path)\n                except ConnectionRefusedError:\n                    os.unlink(path)\n    except FileNotFoundError:\n        pass", "is_method": false, "function_description": "Function removing a stale Unix socket file if it exists and is unresponsive, typically used during server shutdown to clean up resources and prevent socket conflicts on restart."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "serve_single", "line_number": 714, "body": "def serve_single(server_settings):\n    main_start = server_settings.pop(\"main_start\", None)\n    main_stop = server_settings.pop(\"main_stop\", None)\n\n    if not server_settings.get(\"run_async\"):\n        # create new event_loop after fork\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        server_settings[\"loop\"] = loop\n\n    trigger_events(main_start, server_settings[\"loop\"])\n    serve(**server_settings)\n    trigger_events(main_stop, server_settings[\"loop\"])\n\n    server_settings[\"loop\"].close()", "is_method": false, "function_description": "Function that manages server lifecycle by setting up async event loop, triggering start/stop events, and running the server with specified settings for synchronous or asynchronous execution."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "serve_multiple", "line_number": 731, "body": "def serve_multiple(server_settings, workers):\n    \"\"\"Start multiple server processes simultaneously.  Stop on interrupt\n    and terminate signals, and drain connections when complete.\n\n    :param server_settings: kw arguments to be passed to the serve function\n    :param workers: number of workers to launch\n    :param stop_event: if provided, is used as a stop signal\n    :return:\n    \"\"\"\n    server_settings[\"reuse_port\"] = True\n    server_settings[\"run_multiple\"] = True\n\n    main_start = server_settings.pop(\"main_start\", None)\n    main_stop = server_settings.pop(\"main_stop\", None)\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n\n    trigger_events(main_start, loop)\n\n    # Create a listening socket or use the one in settings\n    sock = server_settings.get(\"sock\")\n    unix = server_settings[\"unix\"]\n    backlog = server_settings[\"backlog\"]\n    if unix:\n        sock = bind_unix_socket(unix, backlog=backlog)\n        server_settings[\"unix\"] = unix\n    if sock is None:\n        sock = bind_socket(\n            server_settings[\"host\"], server_settings[\"port\"], backlog=backlog\n        )\n        sock.set_inheritable(True)\n        server_settings[\"sock\"] = sock\n        server_settings[\"host\"] = None\n        server_settings[\"port\"] = None\n\n    processes = []\n\n    def sig_handler(signal, frame):\n        logger.info(\"Received signal %s. Shutting down.\", Signals(signal).name)\n        for process in processes:\n            os.kill(process.pid, SIGTERM)\n\n    signal_func(SIGINT, lambda s, f: sig_handler(s, f))\n    signal_func(SIGTERM, lambda s, f: sig_handler(s, f))\n    mp = multiprocessing.get_context(\"fork\")\n\n    for _ in range(workers):\n        process = mp.Process(target=serve, kwargs=server_settings)\n        process.daemon = True\n        process.start()\n        processes.append(process)\n\n    for process in processes:\n        process.join()\n\n    # the above processes will block this until they're stopped\n    for process in processes:\n        process.terminate()\n\n    trigger_events(main_stop, loop)\n\n    sock.close()\n    loop.close()\n    remove_unix_socket(unix)", "is_method": false, "function_description": "Starts and manages multiple server worker processes with shared socket and graceful shutdown on interrupt signals, supporting concurrent request handling and lifecycle event triggers. Useful for scalable, multi-process server deployment."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "_setup_connection", "line_number": 184, "body": "def _setup_connection(self):\n        self._http = Http(self)\n        self._time = current_time()\n        self.check_timeouts()", "is_method": true, "class_name": "HttpProtocol", "function_description": "Initializes HTTP connection parameters, sets the current time, and performs timeout checks to prepare the HttpProtocol instance for communication."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "check_timeouts", "line_number": 225, "body": "def check_timeouts(self):\n        \"\"\"\n        Runs itself periodically to enforce any expired timeouts.\n        \"\"\"\n        try:\n            if not self._task:\n                return\n            duration = current_time() - self._time\n            stage = self._http.stage\n            if stage is Stage.IDLE and duration > self.keep_alive_timeout:\n                logger.debug(\"KeepAlive Timeout. Closing connection.\")\n            elif stage is Stage.REQUEST and duration > self.request_timeout:\n                logger.debug(\"Request Timeout. Closing connection.\")\n                self._http.exception = RequestTimeout(\"Request Timeout\")\n            elif stage is Stage.HANDLER and self._http.upgrade_websocket:\n                logger.debug(\"Handling websocket. Timeouts disabled.\")\n                return\n            elif (\n                stage in (Stage.HANDLER, Stage.RESPONSE, Stage.FAILED)\n                and duration > self.response_timeout\n            ):\n                logger.debug(\"Response Timeout. Closing connection.\")\n                self._http.exception = ServiceUnavailable(\"Response Timeout\")\n            else:\n                interval = (\n                    min(\n                        self.keep_alive_timeout,\n                        self.request_timeout,\n                        self.response_timeout,\n                    )\n                    / 2\n                )\n                self.loop.call_later(max(0.1, interval), self.check_timeouts)\n                return\n            self._task.cancel()\n        except Exception:\n            logger.exception(\"protocol.check_timeouts\")", "is_method": true, "class_name": "HttpProtocol", "function_description": "Monitors connection stages to detect and enforce timeout limits, closing or canceling connections when idle, requests, or responses exceed specified durations to maintain protocol responsiveness and resource management."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "close_if_idle", "line_number": 273, "body": "def close_if_idle(self) -> bool:\n        \"\"\"\n        Close the connection if a request is not being sent or received\n\n        :return: boolean - True if closed, false if staying open\n        \"\"\"\n        if self._http is None or self._http.stage is Stage.IDLE:\n            self.close()\n            return True\n        return False", "is_method": true, "class_name": "HttpProtocol", "function_description": "Utility method of the HttpProtocol class that closes the connection when it is idle, helping manage resource usage by freeing unused HTTP connections automatically."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "close", "line_number": 284, "body": "def close(self):\n        \"\"\"\n        Force close the connection.\n        \"\"\"\n        # Cause a call to connection_lost where further cleanup occurs\n        if self.transport:\n            self.transport.close()\n            self.transport = None", "is_method": true, "class_name": "HttpProtocol", "function_description": "Provides a method to forcibly close an active HTTP connection, ensuring proper cleanup of associated resources within the HttpProtocol context. Useful for terminating connections reliably in network communication handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "connection_made", "line_number": 297, "body": "def connection_made(self, transport):\n        try:\n            # TODO: Benchmark to find suitable write buffer limits\n            transport.set_write_buffer_limits(low=16384, high=65536)\n            self.connections.add(self)\n            self.transport = transport\n            self._task = self.loop.create_task(self.connection_task())\n            self.recv_buffer = bytearray()\n            self.conn_info = ConnInfo(self.transport, unix=self._unix)\n        except Exception:\n            logger.exception(\"protocol.connect_made\")", "is_method": true, "class_name": "HttpProtocol", "function_description": "Initial connection setup handler in HttpProtocol that registers the new connection, initializes transport parameters, and starts the corresponding connection task for managing data transfer."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "connection_lost", "line_number": 309, "body": "def connection_lost(self, exc):\n        try:\n            self.connections.discard(self)\n            self.resume_writing()\n            if self._task:\n                self._task.cancel()\n        except Exception:\n            logger.exception(\"protocol.connection_lost\")", "is_method": true, "class_name": "HttpProtocol", "function_description": "Handles cleanup actions when a connection is lost, removing the connection, resuming writes, and canceling associated tasks to maintain protocol stability."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "pause_writing", "line_number": 318, "body": "def pause_writing(self):\n        self._can_write.clear()", "is_method": true, "class_name": "HttpProtocol", "function_description": "Method of the HttpProtocol class that temporarily halts outgoing data transmission by disabling the writing capability, useful for managing flow control or backpressure in HTTP connections."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "resume_writing", "line_number": 321, "body": "def resume_writing(self):\n        self._can_write.set()", "is_method": true, "class_name": "HttpProtocol", "function_description": "Method of HttpProtocol that resumes or enables the continuation of writing operations by setting the internal writable state. It is useful for controlling flow in asynchronous or paused HTTP communication."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "data_received", "line_number": 324, "body": "def data_received(self, data: bytes):\n        try:\n            self._time = current_time()\n            if not data:\n                return self.close()\n            self.recv_buffer += data\n\n            if (\n                len(self.recv_buffer) > self.app.config.REQUEST_BUFFER_SIZE\n                and self.transport\n            ):\n                self.transport.pause_reading()\n\n            if self._data_received:\n                self._data_received.set()\n        except Exception:\n            logger.exception(\"protocol.data_received\")", "is_method": true, "class_name": "HttpProtocol", "function_description": "Handles incoming byte data by buffering it, managing flow control based on buffer size, and signaling data reception, facilitating efficient and controlled network data processing in an HTTP protocol context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "after_start", "line_number": 392, "body": "def after_start(self):\n        \"\"\"\n        Trigger \"after_server_start\" events\n        \"\"\"\n        trigger_events(self._after_start, self.loop)", "is_method": true, "class_name": "AsyncioServer", "function_description": "Triggers post-startup events for the server to perform any necessary actions immediately after the server begins running. This enables flexible extension of server behavior upon startup completion."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "before_stop", "line_number": 398, "body": "def before_stop(self):\n        \"\"\"\n        Trigger \"before_server_stop\" events\n        \"\"\"\n        trigger_events(self._before_stop, self.loop)", "is_method": true, "class_name": "AsyncioServer", "function_description": "Triggers all registered \"before_server_stop\" events just before the server stops, allowing cleanup or finalization tasks to run asynchronously within the event loop."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "after_stop", "line_number": 404, "body": "def after_stop(self):\n        \"\"\"\n        Trigger \"after_server_stop\" events\n        \"\"\"\n        trigger_events(self._after_stop, self.loop)", "is_method": true, "class_name": "AsyncioServer", "function_description": "Utility method of AsyncioServer that triggers all registered \"after_server_stop\" events, enabling cleanup or follow-up actions immediately after the server stops."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "is_serving", "line_number": 410, "body": "def is_serving(self) -> bool:\n        if self.server:\n            return self.server.is_serving()\n        return False", "is_method": true, "class_name": "AsyncioServer", "function_description": "This method checks whether the AsyncioServer is currently running and able to serve requests, providing a simple status check for server availability."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "wait_closed", "line_number": 415, "body": "def wait_closed(self):\n        if self.server:\n            return self.server.wait_closed()", "is_method": true, "class_name": "AsyncioServer", "function_description": "Method of AsyncioServer that waits for the underlying server to close, enabling asynchronous coordination of server shutdown processes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "close", "line_number": 419, "body": "def close(self):\n        if self.server:\n            self.server.close()\n            coro = self.wait_closed()\n            task = asyncio.ensure_future(coro, loop=self.loop)\n            return task", "is_method": true, "class_name": "AsyncioServer", "function_description": "Service method in AsyncioServer that initiates closing the server and returns an asynchronous task to wait until the server has fully shut down. It enables graceful shutdown handling in asynchronous event loops."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "start_serving", "line_number": 426, "body": "def start_serving(self):\n        if self.server:\n            try:\n                return self.server.start_serving()\n            except AttributeError:\n                raise NotImplementedError(\n                    \"server.start_serving not available in this version \"\n                    \"of asyncio or uvloop.\"\n                )", "is_method": true, "class_name": "AsyncioServer", "function_description": "Starts the asynchronous server to begin handling incoming connections, providing an interface to initiate server operation within the AsyncioServer context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "serve_forever", "line_number": 436, "body": "def serve_forever(self):\n        if self.server:\n            try:\n                return self.server.serve_forever()\n            except AttributeError:\n                raise NotImplementedError(\n                    \"server.serve_forever not available in this version \"\n                    \"of asyncio or uvloop.\"\n                )", "is_method": true, "class_name": "AsyncioServer", "function_description": "Provides a continuous serving loop for the AsyncioServer, keeping the server running indefinitely. It enables persistent asynchronous network service until externally stopped."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "__await__", "line_number": 446, "body": "def __await__(self):\n        \"\"\"\n        Starts the asyncio server, returns AsyncServerCoro\n        \"\"\"\n        task = asyncio.ensure_future(self.serve_coro)\n        while not task.done():\n            yield\n        self.server = task.result()\n        return self", "is_method": true, "class_name": "AsyncioServer", "function_description": "Starts and runs the asyncio server coroutine, yielding control until the server is fully running, then returns the server instance. Enables asynchronous server startup within an awaitable context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "sig_handler", "line_number": 768, "body": "def sig_handler(signal, frame):\n        logger.info(\"Received signal %s. Shutting down.\", Signals(signal).name)\n        for process in processes:\n            os.kill(process.pid, SIGTERM)", "is_method": false, "function_description": "Function that handles termination signals by logging the event and gracefully shutting down related subprocesses to ensure a clean application exit."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "_quote", "line_number": 25, "body": "def _quote(str):\n    r\"\"\"Quote a string for use in a cookie header.\n    If the string does not need to be double-quoted, then just return the\n    string.  Otherwise, surround the string in doublequotes and quote\n    (with a \\) special characters.\n    \"\"\"\n    if str is None or _is_legal_key(str):\n        return str\n    else:\n        return '\"' + str.translate(_Translator) + '\"'", "is_method": false, "function_description": "Utility function that prepares a string for use in a cookie header by quoting it only when necessary, ensuring special characters are properly escaped to comply with cookie formatting rules."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "__setitem__", "line_number": 57, "body": "def __setitem__(self, key, value):\n        # If this cookie doesn't exist, add it to the header keys\n        if not self.cookie_headers.get(key):\n            cookie = Cookie(key, value)\n            cookie[\"path\"] = \"/\"\n            self.cookie_headers[key] = self.header_key\n            self.headers.add(self.header_key, cookie)\n            return super().__setitem__(key, cookie)\n        else:\n            self[key].value = value", "is_method": true, "class_name": "CookieJar", "function_description": "Provides a way to add or update cookies in the CookieJar, managing both internal storage and HTTP headers to maintain cookie state consistently."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "__delitem__", "line_number": 68, "body": "def __delitem__(self, key):\n        if key not in self.cookie_headers:\n            self[key] = \"\"\n            self[key][\"max-age\"] = 0\n        else:\n            cookie_header = self.cookie_headers[key]\n            # remove it from header\n            cookies = self.headers.popall(cookie_header)\n            for cookie in cookies:\n                if cookie.key != key:\n                    self.headers.add(cookie_header, cookie)\n            del self.cookie_headers[key]\n            return super().__delitem__(key)", "is_method": true, "class_name": "CookieJar", "function_description": "Method of CookieJar that removes a cookie by key, ensuring it is properly deleted from both internal headers and cookie tracking structures, effectively managing cookie expiration and cleanup."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "__setitem__", "line_number": 108, "body": "def __setitem__(self, key, value):\n        if key not in self._keys:\n            raise KeyError(\"Unknown cookie property\")\n        if value is not False:\n            if key.lower() == \"max-age\":\n                if not str(value).isdigit():\n                    raise ValueError(\"Cookie max-age must be an integer\")\n            elif key.lower() == \"expires\":\n                if not isinstance(value, datetime):\n                    raise TypeError(\n                        \"Cookie 'expires' property must be a datetime\"\n                    )\n            return super().__setitem__(key, value)", "is_method": true, "class_name": "Cookie", "function_description": "Validates and sets cookie properties ensuring only recognized keys with correct value types are assigned, preventing invalid cookie attribute configurations."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "encode", "line_number": 122, "body": "def encode(self, encoding):\n        \"\"\"\n        Encode the cookie content in a specific type of encoding instructed\n        by the developer. Leverages the :func:`str.encode` method provided\n        by python.\n\n        This method can be used to encode and embed ``utf-8`` content into\n        the cookies.\n\n        :param encoding: Encoding to be used with the cookie\n        :return: Cookie encoded in a codec of choosing.\n        :except: UnicodeEncodeError\n        \"\"\"\n        return str(self).encode(encoding)", "is_method": true, "class_name": "Cookie", "function_description": "Encodes the cookie's content into the specified character encoding, enabling storage or transmission in various formats such as UTF-8. This aids in handling cookie data across different encoding requirements."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "__str__", "line_number": 137, "body": "def __str__(self):\n        \"\"\"Format as a Set-Cookie header value.\"\"\"\n        output = [\"%s=%s\" % (self.key, _quote(self.value))]\n        for key, value in self.items():\n            if key == \"max-age\":\n                try:\n                    output.append(\"%s=%d\" % (self._keys[key], value))\n                except TypeError:\n                    output.append(\"%s=%s\" % (self._keys[key], value))\n            elif key == \"expires\":\n                output.append(\n                    \"%s=%s\"\n                    % (self._keys[key], value.strftime(\"%a, %d-%b-%Y %T GMT\"))\n                )\n            elif key in self._flags and self[key]:\n                output.append(self._keys[key])\n            else:\n                output.append(\"%s=%s\" % (self._keys[key], value))\n\n        return \"; \".join(output)", "is_method": true, "class_name": "Cookie", "function_description": "Formats the Cookie object as a valid Set-Cookie HTTP header string for use in HTTP responses. This enables seamless conversion of cookie attributes into the correct header format for client-server communication."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "parse_content_header", "line_number": 33, "body": "def parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    value = _firefox_quote_escape.sub(\"%22\", value)\n    pos = value.find(\";\")\n    if pos == -1:\n        options: Dict[str, Union[int, str]] = {}\n    else:\n        options = {\n            m.group(1).lower(): m.group(2) or m.group(3).replace(\"%22\", '\"')\n            for m in _param.finditer(value[pos:])\n        }\n        value = value[:pos]\n    return value.strip().lower(), options", "is_method": false, "function_description": "Utility function that parses HTTP content-type or content-disposition headers into their main value and a dictionary of associated parameters, improving parsing speed and handling of special characters compared to standard libraries."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "parse_forwarded", "line_number": 63, "body": "def parse_forwarded(headers, config) -> Optional[Options]:\n    \"\"\"Parse RFC 7239 Forwarded headers.\n    The value of `by` or `secret` must match `config.FORWARDED_SECRET`\n    :return: dict with keys and values, or None if nothing matched\n    \"\"\"\n    header = headers.getall(\"forwarded\", None)\n    secret = config.FORWARDED_SECRET\n    if header is None or not secret:\n        return None\n    header = \",\".join(header)  # Join multiple header lines\n    if secret not in header:\n        return None\n    # Loop over <separator><key>=<value> elements from right to left\n    sep = pos = None\n    options: List[Tuple[str, str]] = []\n    found = False\n    for m in _rparam.finditer(header[::-1]):\n        # Start of new element? (on parser skips and non-semicolon right sep)\n        if m.start() != pos or sep != \";\":\n            # Was the previous element (from right) what we wanted?\n            if found:\n                break\n            # Clear values and parse as new element\n            del options[:]\n        pos = m.end()\n        val_token, val_quoted, key, sep = m.groups()\n        key = key.lower()[::-1]\n        val = (val_token or val_quoted.replace('\"\\\\', '\"'))[::-1]\n        options.append((key, val))\n        if key in (\"secret\", \"by\") and val == secret:\n            found = True\n        # Check if we would return on next round, to avoid useless parse\n        if found and sep != \";\":\n            break\n    # If secret was found, return the matching options in left-to-right order\n    return fwd_normalize(reversed(options)) if found else None", "is_method": false, "function_description": "Function that parses RFC 7239 Forwarded headers to extract parameters matching a configured secret, returning the relevant forwarding options if a valid secret or 'by' value is found in the headers. Useful for securely identifying trusted proxy information."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "parse_xforwarded", "line_number": 101, "body": "def parse_xforwarded(headers, config) -> Optional[Options]:\n    \"\"\"Parse traditional proxy headers.\"\"\"\n    real_ip_header = config.REAL_IP_HEADER\n    proxies_count = config.PROXIES_COUNT\n    addr = real_ip_header and headers.get(real_ip_header)\n    if not addr and proxies_count:\n        assert proxies_count > 0\n        try:\n            # Combine, split and filter multiple headers' entries\n            forwarded_for = headers.getall(config.FORWARDED_FOR_HEADER)\n            proxies = [\n                p\n                for p in (\n                    p.strip() for h in forwarded_for for p in h.split(\",\")\n                )\n                if p\n            ]\n            addr = proxies[-proxies_count]\n        except (KeyError, IndexError):\n            pass\n    # No processing of other headers if no address is found\n    if not addr:\n        return None\n\n    def options():\n        yield \"for\", addr\n        for key, header in (\n            (\"proto\", \"x-scheme\"),\n            (\"proto\", \"x-forwarded-proto\"),  # Overrides X-Scheme if present\n            (\"host\", \"x-forwarded-host\"),\n            (\"port\", \"x-forwarded-port\"),\n            (\"path\", \"x-forwarded-path\"),\n        ):\n            yield key, headers.get(header)\n\n    return fwd_normalize(options())", "is_method": false, "function_description": "Parses traditional proxy-related headers to extract the client's original IP address and forwarding details. It supports configurable proxy counts and header names, providing normalized forwarding options for request processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "fwd_normalize", "line_number": 139, "body": "def fwd_normalize(fwd: OptionsIterable) -> Options:\n    \"\"\"Normalize and convert values extracted from forwarded headers.\"\"\"\n    ret: Dict[str, Union[int, str]] = {}\n    for key, val in fwd:\n        if val is not None:\n            try:\n                if key in (\"by\", \"for\"):\n                    ret[key] = fwd_normalize_address(val)\n                elif key in (\"host\", \"proto\"):\n                    ret[key] = val.lower()\n                elif key == \"port\":\n                    ret[key] = int(val)\n                elif key == \"path\":\n                    ret[key] = unquote(val)\n                else:\n                    ret[key] = val\n            except ValueError:\n                pass\n    return ret", "is_method": false, "function_description": "Utility function that normalizes and converts values from forwarded headers by processing keys like addresses, host, protocol, port, and path into a standardized dictionary for easier downstream use."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "fwd_normalize_address", "line_number": 160, "body": "def fwd_normalize_address(addr: str) -> str:\n    \"\"\"Normalize address fields of proxy headers.\"\"\"\n    if addr == \"unknown\":\n        raise ValueError()  # omit unknown value identifiers\n    if addr.startswith(\"_\"):\n        return addr  # do not lower-case obfuscated strings\n    if _ipv6_re.fullmatch(addr):\n        addr = f\"[{addr}]\"  # bracket IPv6\n    return addr.lower()", "is_method": false, "function_description": "Function that normalizes address strings from proxy headers by lowercasing them, handling IPv6 formatting, and excluding unknown or obfuscated addresses. It ensures consistent address representation for network or logging processes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "parse_host", "line_number": 171, "body": "def parse_host(host: str) -> Tuple[Optional[str], Optional[int]]:\n    \"\"\"Split host:port into hostname and port.\n    :return: None in place of missing elements\n    \"\"\"\n    m = _host_re.fullmatch(host)\n    if not m:\n        return None, None\n    host, port = m.groups()\n    return host.lower(), int(port) if port is not None else None", "is_method": false, "function_description": "Function that extracts and returns the hostname and port from a host string, returning None for any missing parts. It enables standardized parsing of host:port inputs for network-related utilities."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "format_http1_response", "line_number": 188, "body": "def format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    # Note: benchmarks show that here bytes concat is faster than bytearray,\n    # b\"\".join() or %-formatting. %timeit any changes you make.\n    ret = _HTTP1_STATUSLINES[status]\n    for h in headers:\n        ret += b\"%b: %b\\r\\n\" % h\n    ret += b\"\\r\\n\"\n    return ret", "is_method": false, "function_description": "Utility function that constructs a raw HTTP/1.1 response header from a status code and iterable of headers, returning the properly formatted bytes for network transmission."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "__bool__", "line_number": 108, "body": "def __bool__(self):\n        \"\"\"Test if request handling is in progress\"\"\"\n        return self.stage in (Stage.HANDLER, Stage.RESPONSE)", "is_method": true, "class_name": "Http", "function_description": "Utility method of the Http class that indicates whether the request handling process is currently active by checking if the request is in the handling or response stage. It enables easy status checking of request processing progress."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "head_response_ignored", "line_number": 332, "body": "def head_response_ignored(self, data: bytes, end_stream: bool) -> None:\n        \"\"\"\n        HEAD response: body data silently ignored.\n        \"\"\"\n        if end_stream:\n            self.response_func = None\n            self.stage = Stage.IDLE", "is_method": true, "class_name": "Http", "function_description": "Handles HTTP HEAD responses by silently ignoring any body data and resetting the response state when the response stream ends."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "create_empty_request", "line_number": 401, "body": "def create_empty_request(self) -> None:\n        \"\"\"\n        Current error handling code needs a request object that won't exist\n        if an error occurred during before a request was received. Create a\n        bogus response for error handling use.\n        \"\"\"\n\n        # FIXME: Avoid this by refactoring error handling and response code\n        self.request = self.protocol.request_class(\n            url_bytes=self.url.encode() if self.url else b\"*\",\n            headers=Header({}),\n            version=\"1.1\",\n            method=\"NONE\",\n            transport=self.protocol.transport,\n            app=self.protocol.app,\n        )\n        self.request.stream = self", "is_method": true, "class_name": "Http", "function_description": "Provides a placeholder HTTP request object for error handling when no real request exists, enabling consistent processing of errors occurring before request reception."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "log_response", "line_number": 419, "body": "def log_response(self) -> None:\n        \"\"\"\n        Helper method provided to enable the logging of responses in case if\n        the :attr:`HttpProtocol.access_log` is enabled.\n        \"\"\"\n        req, res = self.request, self.response\n        extra = {\n            \"status\": getattr(res, \"status\", 0),\n            \"byte\": getattr(self, \"response_bytes_left\", -1),\n            \"host\": \"UNKNOWN\",\n            \"request\": \"nil\",\n        }\n        if req is not None:\n            if req.ip:\n                extra[\"host\"] = f\"{req.ip}:{req.port}\"\n            extra[\"request\"] = f\"{req.method} {req.url}\"\n        access_logger.info(\"\", extra=extra)", "is_method": true, "class_name": "Http", "function_description": "Provides logging of HTTP request and response details when access logging is enabled, supporting monitoring and debugging of HTTP interactions within the Http class."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "respond", "line_number": 520, "body": "def respond(self, response: BaseHTTPResponse) -> BaseHTTPResponse:\n        \"\"\"\n        Initiate new streaming response.\n\n        Nothing is sent until the first send() call on the returned object, and\n        calling this function multiple times will just alter the response to be\n        given.\n        \"\"\"\n        if self.stage is not Stage.HANDLER:\n            self.stage = Stage.FAILED\n            raise RuntimeError(\"Response already started\")\n\n        self.response, response.stream = response, self\n        return response", "is_method": true, "class_name": "Http", "function_description": "Provides a controlled way to start or replace an HTTP streaming response, ensuring only one response is active at a time and delaying data transmission until explicitly sent."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "send", "line_number": 536, "body": "def send(self):\n        return self.response_func", "is_method": true, "class_name": "Http", "function_description": "Returns the HTTP response handler associated with the current Http instance, allowing other components to access or invoke the response functionality."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/signals.py", "function": "get_handler", "line_number": 23, "body": "def get_handler(self, raw_path, method, _):\n        method = method or self.router.DEFAULT_METHOD\n        raw_path = raw_path.lstrip(self.router.delimiter)\n        try:\n            return self.handlers[raw_path][method]\n        except (IndexError, KeyError):\n            raise self.router.method_handler_exception(\n                f\"Method '{method}' not found on {self}\",\n                method=method,\n                allowed_methods=set(self.methods[raw_path]),\n            )", "is_method": true, "class_name": "Signal", "function_description": "Service method of the Signal class that retrieves the request handler for a given path and HTTP method, raising a specific exception if the method is not supported for that path. It supports routing and method validation in request handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/signals.py", "function": "get", "line_number": 45, "body": "def get(  # type: ignore\n        self,\n        event: str,\n        condition: Optional[Dict[str, str]] = None,\n    ):\n        extra = condition or {}\n        try:\n            return self.resolve(f\".{event}\", extra=extra)\n        except NotFound:\n            message = \"Could not find signal %s\"\n            terms: List[Union[str, Optional[Dict[str, str]]]] = [event]\n            if extra:\n                message += \" with %s\"\n                terms.append(extra)\n            raise NotFound(message % tuple(terms))", "is_method": true, "class_name": "SignalRouter", "function_description": "Provides a mechanism to retrieve a signal handler by event name, optionally filtered by conditions. Raises an error if no matching signal is found, supporting dynamic event-driven routing based on event and condition criteria."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/signals.py", "function": "add", "line_number": 100, "body": "def add(  # type: ignore\n        self,\n        handler: SignalHandler,\n        event: str,\n        condition: Optional[Dict[str, Any]] = None,\n    ) -> Signal:\n        parts = self._build_event_parts(event)\n        if parts[2].startswith(\"<\"):\n            name = \".\".join([*parts[:-1], \"*\"])\n        else:\n            name = event\n\n        handler.__requirements__ = condition  # type: ignore\n\n        return super().add(\n            event,\n            handler,\n            requirements=condition,\n            name=name,\n            overwrite=True,\n        )", "is_method": true, "class_name": "SignalRouter", "function_description": "Adds a signal handler for a specified event with optional conditions, enabling customized event-driven behavior and flexible routing based on event patterns within the SignalRouter class."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/signals.py", "function": "finalize", "line_number": 122, "body": "def finalize(self, do_compile: bool = True):\n        try:\n            self.ctx.loop = asyncio.get_running_loop()\n        except RuntimeError:\n            raise RuntimeError(\"Cannot finalize signals outside of event loop\")\n\n        for signal in self.routes.values():\n            signal.ctx.event = asyncio.Event()\n\n        return super().finalize(do_compile=do_compile)", "is_method": true, "class_name": "SignalRouter", "function_description": "Finalizes the signal routing setup by ensuring it runs within an active event loop and initializing asynchronous events for each signal, preparing the system for asynchronous signal handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/signals.py", "function": "_build_event_parts", "line_number": 133, "body": "def _build_event_parts(self, event: str) -> Tuple[str, str, str]:\n        parts = path_to_parts(event, self.delimiter)\n        if (\n            len(parts) != 3\n            or parts[0].startswith(\"<\")\n            or parts[1].startswith(\"<\")\n        ):\n            raise InvalidSignal(\"Invalid signal event: %s\" % event)\n\n        if parts[0] in RESERVED_NAMESPACES:\n            raise InvalidSignal(\n                \"Cannot declare reserved signal event: %s\" % event\n            )\n        return parts", "is_method": true, "class_name": "SignalRouter", "function_description": "Core utility method of SignalRouter that validates and parses a signal event string into three parts, enforcing naming rules and reserved namespace restrictions for consistent event handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/utils.py", "function": "str_to_bool", "line_number": 13, "body": "def str_to_bool(val: str) -> bool:\n    \"\"\"Takes string and tries to turn it into bool as human would do.\n\n    If val is in case insensitive (\n        \"y\", \"yes\", \"yep\", \"yup\", \"t\",\n        \"true\", \"on\", \"enable\", \"enabled\", \"1\"\n    ) returns True.\n    If val is in case insensitive (\n        \"n\", \"no\", \"f\", \"false\", \"off\", \"disable\", \"disabled\", \"0\"\n    ) returns False.\n    Else Raise ValueError.\"\"\"\n\n    val = val.lower()\n    if val in {\n        \"y\",\n        \"yes\",\n        \"yep\",\n        \"yup\",\n        \"t\",\n        \"true\",\n        \"on\",\n        \"enable\",\n        \"enabled\",\n        \"1\",\n    }:\n        return True\n    elif val in {\"n\", \"no\", \"f\", \"false\", \"off\", \"disable\", \"disabled\", \"0\"}:\n        return False\n    else:\n        raise ValueError(f\"Invalid truth value {val}\")", "is_method": false, "function_description": "Utility function that converts common human-readable string representations of truth values into boolean True or False, raising an error for unrecognized inputs. It supports flexible, case-insensitive interpretation of affirmative and negative expressions."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/utils.py", "function": "load_module_from_file_location", "line_number": 45, "body": "def load_module_from_file_location(\n    location: Union[bytes, str, Path], encoding: str = \"utf8\", *args, **kwargs\n):  # noqa\n    \"\"\"Returns loaded module provided as a file path.\n\n    :param args:\n        Coresponds to importlib.util.spec_from_file_location location\n        parameters,but with this differences:\n        - It has to be of a string or bytes type.\n        - You can also use here environment variables\n          in format ${some_env_var}.\n          Mark that $some_env_var will not be resolved as environment variable.\n    :encoding:\n        If location parameter is of a bytes type, then use this encoding\n        to decode it into string.\n    :param args:\n        Coresponds to the rest of importlib.util.spec_from_file_location\n        parameters.\n    :param kwargs:\n        Coresponds to the rest of importlib.util.spec_from_file_location\n        parameters.\n\n    For example You can:\n\n        some_module = load_module_from_file_location(\n            \"some_module_name\",\n            \"/some/path/${some_env_var}\"\n        )\n    \"\"\"\n    if isinstance(location, bytes):\n        location = location.decode(encoding)\n\n    if isinstance(location, Path) or \"/\" in location or \"$\" in location:\n\n        if not isinstance(location, Path):\n            # A) Check if location contains any environment variables\n            #    in format ${some_env_var}.\n            env_vars_in_location = set(re_findall(r\"\\${(.+?)}\", location))\n\n            # B) Check these variables exists in environment.\n            not_defined_env_vars = env_vars_in_location.difference(\n                os_environ.keys()\n            )\n            if not_defined_env_vars:\n                raise LoadFileException(\n                    \"The following environment variables are not set: \"\n                    f\"{', '.join(not_defined_env_vars)}\"\n                )\n\n            # C) Substitute them in location.\n            for env_var in env_vars_in_location:\n                location = location.replace(\n                    \"${\" + env_var + \"}\", os_environ[env_var]\n                )\n\n        location = str(location)\n        if \".py\" in location:\n            name = location.split(\"/\")[-1].split(\".\")[\n                0\n            ]  # get just the file name without path and .py extension\n            _mod_spec = spec_from_file_location(\n                name, location, *args, **kwargs\n            )\n            module = module_from_spec(_mod_spec)\n            _mod_spec.loader.exec_module(module)  # type: ignore\n\n        else:\n            module = types.ModuleType(\"config\")\n            module.__file__ = str(location)\n            try:\n                with open(location) as config_file:\n                    exec(  # nosec\n                        compile(config_file.read(), location, \"exec\"),\n                        module.__dict__,\n                    )\n            except IOError as e:\n                e.strerror = \"Unable to load configuration file (e.strerror)\"\n                raise\n            except Exception as e:\n                raise PyFileError(location) from e\n\n        return module\n    else:\n        try:\n            return import_string(location)\n        except ValueError:\n            raise IOError(\"Unable to load configuration %s\" % str(location))", "is_method": false, "function_description": "Function that loads and returns a Python module from a given file path or string, supporting environment variable substitution in paths and handling both .py files and other config files. It enables dynamic module loading for configuration or code integration purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "__repr__", "line_number": 96, "body": "def __repr__(self) -> str:\n        args = \", \".join(\n            [\n                f'{attr}=\"{getattr(self, attr)}\"'\n                if isinstance(getattr(self, attr), str)\n                else f\"{attr}={getattr(self, attr)}\"\n                for attr in (\n                    \"name\",\n                    \"url_prefix\",\n                    \"host\",\n                    \"version\",\n                    \"strict_slashes\",\n                )\n            ]\n        )\n        return f\"Blueprint({args})\"", "is_method": true, "class_name": "Blueprint", "function_description": "Provides a readable string representation of a Blueprint instance, summarizing its key attributes for easier debugging and logging."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "apps", "line_number": 114, "body": "def apps(self):\n        if not self._apps:\n            raise SanicException(\n                f\"{self} has not yet been registered to an app\"\n            )\n        return self._apps", "is_method": true, "class_name": "Blueprint", "function_description": "Returns the list of applications associated with the Blueprint, ensuring it has been registered before access. This provides a way to check and retrieve apps linked to the Blueprint instance."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "route", "line_number": 121, "body": "def route(self, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().route(*args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "Overrides a routing method to disable automatic application of the route, allowing manual control over route setup within the Blueprint context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "static", "line_number": 125, "body": "def static(self, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().static(*args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "Method of the Blueprint class that invokes its superclass's static method without applying additional processing, allowing direct retrieval or usage of static resources or configurations."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "middleware", "line_number": 129, "body": "def middleware(self, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().middleware(*args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "Overrides and customizes middleware behavior by disabling middleware application in the Blueprint class, affecting how requests or processing steps are handled in a web or application framework."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "listener", "line_number": 133, "body": "def listener(self, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().listener(*args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "Overrides the listener method to modify behavior by setting 'apply' to False before delegating to the parent class. This enables customized event handling without automatic application of changes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "exception", "line_number": 137, "body": "def exception(self, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().exception(*args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "Overrides the superclass exception method to modify its behavior by setting apply to False. This customization adjusts how exceptions are handled within the Blueprint class context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "signal", "line_number": 141, "body": "def signal(self, event: str, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().signal(event, *args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "Overrides the signal method to dispatch events without applying associated handlers immediately, allowing deferred or customized event processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "group", "line_number": 146, "body": "def group(*blueprints, url_prefix=\"\", version=None, strict_slashes=None):\n        \"\"\"\n        Create a list of blueprints, optionally grouping them under a\n        general URL prefix.\n\n        :param blueprints: blueprints to be registered as a group\n        :param url_prefix: URL route to be prepended to all sub-prefixes\n        :param version: API Version to be used for Blueprint group\n        :param strict_slashes: Indicate strict slash termination behavior\n            for URL\n        \"\"\"\n\n        def chain(nested) -> Iterable[Blueprint]:\n            \"\"\"itertools.chain() but leaves strings untouched\"\"\"\n            for i in nested:\n                if isinstance(i, (list, tuple)):\n                    yield from chain(i)\n                elif isinstance(i, BlueprintGroup):\n                    yield from i.blueprints\n                else:\n                    yield i\n\n        bps = BlueprintGroup(\n            url_prefix=url_prefix,\n            version=version,\n            strict_slashes=strict_slashes,\n        )\n        for bp in chain(blueprints):\n            bps.append(bp)\n        return bps", "is_method": true, "class_name": "Blueprint", "function_description": "Creates and returns a grouped collection of blueprints optionally prefixed by a URL segment and version, simplifying organization and registration of related route blueprints in a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "register", "line_number": 177, "body": "def register(self, app, options):\n        \"\"\"\n        Register the blueprint to the sanic app.\n\n        :param app: Instance of :class:`sanic.app.Sanic` class\n        :param options: Options to be used while registering the\n            blueprint into the app.\n            *url_prefix* - URL Prefix to override the blueprint prefix\n        \"\"\"\n\n        self._apps.add(app)\n        url_prefix = options.get(\"url_prefix\", self.url_prefix)\n\n        routes = []\n        middleware = []\n        exception_handlers = []\n        listeners = defaultdict(list)\n\n        # Routes\n        for future in self._future_routes:\n            # attach the blueprint name to the handler so that it can be\n            # prefixed properly in the router\n            future.handler.__blueprintname__ = self.name\n            # Prepend the blueprint URI prefix if available\n            uri = url_prefix + future.uri if url_prefix else future.uri\n\n            strict_slashes = (\n                self.strict_slashes\n                if future.strict_slashes is None\n                and self.strict_slashes is not None\n                else future.strict_slashes\n            )\n            name = app._generate_name(future.name)\n\n            apply_route = FutureRoute(\n                future.handler,\n                uri[1:] if uri.startswith(\"//\") else uri,\n                future.methods,\n                future.host or self.host,\n                strict_slashes,\n                future.stream,\n                future.version or self.version,\n                name,\n                future.ignore_body,\n                future.websocket,\n                future.subprotocols,\n                future.unquote,\n                future.static,\n            )\n\n            route = app._apply_route(apply_route)\n            operation = (\n                routes.extend if isinstance(route, list) else routes.append\n            )\n            operation(route)\n\n        # Static Files\n        for future in self._future_statics:\n            # Prepend the blueprint URI prefix if available\n            uri = url_prefix + future.uri if url_prefix else future.uri\n            apply_route = FutureStatic(uri, *future[1:])\n            route = app._apply_static(apply_route)\n            routes.append(route)\n\n        route_names = [route.name for route in routes if route]\n\n        # Middleware\n        if route_names:\n            for future in self._future_middleware:\n                middleware.append(app._apply_middleware(future, route_names))\n\n        # Exceptions\n        for future in self._future_exceptions:\n            exception_handlers.append(app._apply_exception_handler(future))\n\n        # Event listeners\n        for listener in self._future_listeners:\n            listeners[listener.event].append(app._apply_listener(listener))\n\n        for signal in self._future_signals:\n            signal.condition.update({\"blueprint\": self.name})\n            app._apply_signal(signal)\n\n        self.routes = [route for route in routes if isinstance(route, Route)]\n\n        # Deprecate these in 21.6\n        self.websocket_routes = [\n            route for route in self.routes if route.ctx.websocket\n        ]\n        self.middlewares = middleware\n        self.exceptions = exception_handlers\n        self.listeners = dict(listeners)", "is_method": true, "class_name": "Blueprint", "function_description": "Registers all accumulated routes, middleware, exception handlers, event listeners, and static files of the Blueprint to a Sanic app, applying configuration options such as URL prefixes to integrate the blueprint's functionality into the application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "event", "line_number": 278, "body": "def event(self, event: str, timeout: Optional[Union[int, float]] = None):\n        events = set()\n        for app in self.apps:\n            signal = app.signal_router.name_index.get(event)\n            if not signal:\n                raise NotFound(\"Could not find signal %s\" % event)\n            events.add(signal.ctx.event)\n\n        return asyncio.wait(\n            [event.wait() for event in events],\n            return_when=asyncio.FIRST_COMPLETED,\n            timeout=timeout,\n        )", "is_method": true, "class_name": "Blueprint", "function_description": "Provides a way for the Blueprint class to wait asynchronously until a specified event occurs in any associated app, supporting optional timeout control for concurrent event handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "chain", "line_number": 158, "body": "def chain(nested) -> Iterable[Blueprint]:\n            \"\"\"itertools.chain() but leaves strings untouched\"\"\"\n            for i in nested:\n                if isinstance(i, (list, tuple)):\n                    yield from chain(i)\n                elif isinstance(i, BlueprintGroup):\n                    yield from i.blueprints\n                else:\n                    yield i", "is_method": true, "class_name": "Blueprint", "function_description": "Utility method in the Blueprint class that recursively flattens nested lists, tuples, or BlueprintGroups into an iterable sequence of Blueprints without splitting strings. It simplifies access to all Blueprint instances within complex nested structures."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "loop", "line_number": 188, "body": "def loop(self):\n        \"\"\"\n        Synonymous with asyncio.get_event_loop().\n\n        .. note::\n\n            Only supported when using the `app.run` method.\n        \"\"\"\n        if not self.is_running and self.asgi is False:\n            raise SanicException(\n                \"Loop can only be retrieved after the app has started \"\n                \"running. Not supported with `create_server` function\"\n            )\n        return get_event_loop()", "is_method": true, "class_name": "Sanic", "function_description": "Returns the asyncio event loop associated with the running Sanic app, enforcing that it can only be accessed after the app has started via app.run. This enables integration with the app\u2019s asynchronous operations."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "add_task", "line_number": 207, "body": "def add_task(self, task) -> None:\n        \"\"\"\n        Schedule a task to run later, after the loop has started.\n        Different from asyncio.ensure_future in that it does not\n        also return a future, and the actual ensure_future call\n        is delayed until before server start.\n\n        `See user guide re: background tasks\n        <https://sanicframework.org/guide/basics/tasks.html#background-tasks>`__\n\n        :param task: future, couroutine or awaitable\n        \"\"\"\n        try:\n            loop = self.loop  # Will raise SanicError if loop is not started\n            self._loop_add_task(task, self, loop)\n        except SanicException:\n            self.listener(\"before_server_start\")(\n                partial(self._loop_add_task, task)\n            )", "is_method": true, "class_name": "Sanic", "function_description": "Schedules a task to run asynchronously after the server's event loop starts, enabling background task execution without immediately creating a future. This supports deferred task management within a Sanic web server lifecycle."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "register_listener", "line_number": 227, "body": "def register_listener(self, listener: Callable, event: str) -> Any:\n        \"\"\"\n        Register the listener for a given event.\n\n        :param listener: callable i.e. setup_db(app, loop)\n        :param event: when to register listener i.e. 'before_server_start'\n        :return: listener\n        \"\"\"\n\n        try:\n            _event = ListenerEvent(event)\n        except ValueError:\n            valid = \", \".join(ListenerEvent.__members__.values())\n            raise InvalidUsage(f\"Invalid event: {event}. Use one of: {valid}\")\n\n        self.listeners[_event].append(listener)\n        return listener", "is_method": true, "class_name": "Sanic", "function_description": "Registers a callable listener function to be triggered on a specified Sanic server event, enabling custom actions during the server lifecycle such as startup or shutdown."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "register_middleware", "line_number": 245, "body": "def register_middleware(self, middleware, attach_to: str = \"request\"):\n        \"\"\"\n        Register an application level middleware that will be attached\n        to all the API URLs registered under this application.\n\n        This method is internally invoked by the :func:`middleware`\n        decorator provided at the app level.\n\n        :param middleware: Callback method to be attached to the\n            middleware\n        :param attach_to: The state at which the middleware needs to be\n            invoked in the lifecycle of an *HTTP Request*.\n            **request** - Invoke before the request is processed\n            **response** - Invoke before the response is returned back\n        :return: decorated method\n        \"\"\"\n        if attach_to == \"request\":\n            if middleware not in self.request_middleware:\n                self.request_middleware.append(middleware)\n        if attach_to == \"response\":\n            if middleware not in self.response_middleware:\n                self.response_middleware.appendleft(middleware)\n        return middleware", "is_method": true, "class_name": "Sanic", "function_description": "Registers a middleware function to be executed during the request or response phase of all API calls within the application, enabling centralized processing or modification of HTTP requests and responses."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "register_named_middleware", "line_number": 269, "body": "def register_named_middleware(\n        self,\n        middleware,\n        route_names: Iterable[str],\n        attach_to: str = \"request\",\n    ):\n        \"\"\"\n        Method for attaching middleware to specific routes. This is mainly an\n        internal tool for use by Blueprints to attach middleware to only its\n        specfic routes. But, it could be used in a more generalized fashion.\n\n        :param middleware: the middleware to execute\n        :param route_names: a list of the names of the endpoints\n        :type route_names: Iterable[str]\n        :param attach_to: whether to attach to request or response,\n            defaults to \"request\"\n        :type attach_to: str, optional\n        \"\"\"\n        if attach_to == \"request\":\n            for _rn in route_names:\n                if _rn not in self.named_request_middleware:\n                    self.named_request_middleware[_rn] = deque()\n                if middleware not in self.named_request_middleware[_rn]:\n                    self.named_request_middleware[_rn].append(middleware)\n        if attach_to == \"response\":\n            for _rn in route_names:\n                if _rn not in self.named_response_middleware:\n                    self.named_response_middleware[_rn] = deque()\n                if middleware not in self.named_response_middleware[_rn]:\n                    self.named_response_middleware[_rn].appendleft(middleware)\n        return middleware", "is_method": true, "class_name": "Sanic", "function_description": "Utility method of the Sanic class that attaches middleware functions to specific named routes for either request or response processing, enabling targeted middleware execution within the application's routing system."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_apply_exception_handler", "line_number": 301, "body": "def _apply_exception_handler(self, handler: FutureException):\n        \"\"\"Decorate a function to be registered as a handler for exceptions\n\n        :param exceptions: exceptions\n        :return: decorated function\n        \"\"\"\n\n        for exception in handler.exceptions:\n            if isinstance(exception, (tuple, list)):\n                for e in exception:\n                    self.error_handler.add(e, handler.handler)\n            else:\n                self.error_handler.add(exception, handler.handler)\n        return handler.handler", "is_method": true, "class_name": "Sanic", "function_description": "Provides internal functionality to register a given exception handler for multiple exception types, enabling the Sanic app to handle specified exceptions with the associated handler function."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_apply_listener", "line_number": 316, "body": "def _apply_listener(self, listener: FutureListener):\n        return self.register_listener(listener.listener, listener.event)", "is_method": true, "class_name": "Sanic", "function_description": "Private method of the Sanic class that registers an event listener to respond to a specific event, facilitating asynchronous event handling within the application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_apply_route", "line_number": 319, "body": "def _apply_route(self, route: FutureRoute) -> List[Route]:\n        params = route._asdict()\n        websocket = params.pop(\"websocket\", False)\n        subprotocols = params.pop(\"subprotocols\", None)\n\n        if websocket:\n            self.enable_websocket()\n            websocket_handler = partial(\n                self._websocket_handler,\n                route.handler,\n                subprotocols=subprotocols,\n            )\n            websocket_handler.__name__ = route.handler.__name__  # type: ignore\n            websocket_handler.is_websocket = True  # type: ignore\n            params[\"handler\"] = websocket_handler\n\n        routes = self.router.add(**params)\n        if isinstance(routes, Route):\n            routes = [routes]\n        for r in routes:\n            r.ctx.websocket = websocket\n            r.ctx.static = params.get(\"static\", False)\n\n        return routes", "is_method": true, "class_name": "Sanic", "function_description": "Handles route registration by configuring and adding HTTP or WebSocket routes, enabling WebSocket support when needed, and returning the created route objects for further use within the Sanic web framework."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_apply_static", "line_number": 344, "body": "def _apply_static(self, static: FutureStatic) -> Route:\n        return self._register_static(static)", "is_method": true, "class_name": "Sanic", "function_description": "Internal method of the Sanic class that registers and applies a static route for serving static files. It supports routing setup by encapsulating static resource handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_apply_middleware", "line_number": 347, "body": "def _apply_middleware(\n        self,\n        middleware: FutureMiddleware,\n        route_names: Optional[List[str]] = None,\n    ):\n        if route_names:\n            return self.register_named_middleware(\n                middleware.middleware, route_names, middleware.attach_to\n            )\n        else:\n            return self.register_middleware(\n                middleware.middleware, middleware.attach_to\n            )", "is_method": true, "class_name": "Sanic", "function_description": "Core method in Sanic that applies middleware either globally or to specific named routes, enabling flexible request/response processing customization."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_apply_signal", "line_number": 361, "body": "def _apply_signal(self, signal: FutureSignal) -> Signal:\n        return self.signal_router.add(*signal)", "is_method": true, "class_name": "Sanic", "function_description": "Internal method of the Sanic class that forwards a FutureSignal to the signal router for registration, enabling asynchronous signal handling within the application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "dispatch", "line_number": 364, "body": "def dispatch(\n        self,\n        event: str,\n        *,\n        condition: Optional[Dict[str, str]] = None,\n        context: Optional[Dict[str, Any]] = None,\n    ) -> Coroutine[Any, Any, Awaitable[Any]]:\n        return self.signal_router.dispatch(\n            event,\n            context=context,\n            condition=condition,\n        )", "is_method": true, "class_name": "Sanic", "function_description": "Core method of the Sanic class that asynchronously dispatches events with optional filtering conditions and contextual data, enabling event-driven communication and handling within the application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "event", "line_number": 377, "body": "def event(self, event: str, timeout: Optional[Union[int, float]] = None):\n        signal = self.signal_router.name_index.get(event)\n        if not signal:\n            raise NotFound(\"Could not find signal %s\" % event)\n        return wait_for(signal.ctx.event.wait(), timeout=timeout)", "is_method": true, "class_name": "Sanic", "function_description": "Provides a mechanism to wait asynchronously for a specific named event signal within the Sanic framework, with an optional timeout to limit the wait duration. This supports event-driven workflows by enabling consumers to synchronize on predefined signals."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "enable_websocket", "line_number": 383, "body": "def enable_websocket(self, enable=True):\n        \"\"\"Enable or disable the support for websocket.\n\n        Websocket is enabled automatically if websocket routes are\n        added to the application.\n        \"\"\"\n        if not self.websocket_enabled:\n            # if the server is stopped, we want to cancel any ongoing\n            # websocket tasks, to allow the server to exit promptly\n            self.listener(\"before_server_stop\")(self._cancel_websocket_tasks)\n\n        self.websocket_enabled = enable", "is_method": true, "class_name": "Sanic", "function_description": "Method of the Sanic class that toggles websocket support, enabling or disabling websocket capabilities for the application based on configuration or presence of websocket routes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "blueprint", "line_number": 396, "body": "def blueprint(self, blueprint, **options):\n        \"\"\"Register a blueprint on the application.\n\n        :param blueprint: Blueprint object or (list, tuple) thereof\n        :param options: option dictionary with blueprint defaults\n        :return: Nothing\n        \"\"\"\n        if isinstance(blueprint, (list, tuple, BlueprintGroup)):\n            for item in blueprint:\n                self.blueprint(item, **options)\n            return\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                'A blueprint with the name \"%s\" is already registered.  '\n                \"Blueprint names must be unique.\" % (blueprint.name,)\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n\n        if (\n            self.strict_slashes is not None\n            and blueprint.strict_slashes is None\n        ):\n            blueprint.strict_slashes = self.strict_slashes\n        blueprint.register(self, options)", "is_method": true, "class_name": "Sanic", "function_description": "Method of the Sanic class that registers one or multiple route blueprints, ensuring unique names and applying default options, to modularly organize the application's routing structure."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "url_for", "line_number": 423, "body": "def url_for(self, view_name: str, **kwargs):\n        \"\"\"Build a URL based on a view name and the values provided.\n\n        In order to build a URL, all request parameters must be supplied as\n        keyword arguments, and each parameter must pass the test for the\n        specified parameter type. If these conditions are not met, a\n        `URLBuildError` will be thrown.\n\n        Keyword arguments that are not request parameters will be included in\n        the output URL's query string.\n\n        There are several _special_ keyword arguments that will alter how the\n        URL will be returned:\n\n        1. **_anchor**: ``str`` - Adds an ``#anchor`` to the end\n        2. **_scheme**: ``str`` - Should be either ``\"http\"`` or ``\"https\"``,\n           default is ``\"http\"``\n        3. **_external**: ``bool`` - Whether to return the path or a full URL\n           with scheme and host\n        4. **_host**: ``str`` - Used when one or more hosts are defined for a\n           route to tell Sanic which to use\n           (only applies with ``_external=True``)\n        5. **_server**: ``str`` - If not using ``_host``, this will be used\n           for defining the hostname of the URL\n           (only applies with ``_external=True``),\n           defaults to ``app.config.SERVER_NAME``\n\n        If you want the PORT to appear in your URL, you should set it in:\n\n        .. code-block::\n\n            app.config.SERVER_NAME = \"myserver:7777\"\n\n        `See user guide re: routing\n        <https://sanicframework.org/guide/basics/routing.html#generating-a-url>`__\n\n        :param view_name: string referencing the view name\n        :param kwargs: keys and values that are used to build request\n            parameters and query string arguments.\n\n        :return: the built URL\n\n        Raises:\n            URLBuildError\n        \"\"\"\n        # find the route by the supplied view name\n        kw: Dict[str, str] = {}\n        # special static files url_for\n\n        if \".\" not in view_name:\n            view_name = f\"{self.name}.{view_name}\"\n\n        if view_name.endswith(\".static\"):\n            name = kwargs.pop(\"name\", None)\n            if name:\n                view_name = view_name.replace(\"static\", name)\n            kw.update(name=view_name)\n\n        route = self.router.find_route_by_view_name(view_name, **kw)\n        if not route:\n            raise URLBuildError(\n                f\"Endpoint with name `{view_name}` was not found\"\n            )\n\n        uri = route.path\n\n        if getattr(route.ctx, \"static\", None):\n            filename = kwargs.pop(\"filename\", \"\")\n            # it's static folder\n            if \"__file_uri__\" in uri:\n                folder_ = uri.split(\"<__file_uri__:\", 1)[0]\n                if folder_.endswith(\"/\"):\n                    folder_ = folder_[:-1]\n\n                if filename.startswith(\"/\"):\n                    filename = filename[1:]\n\n                kwargs[\"__file_uri__\"] = filename\n\n        if (\n            uri != \"/\"\n            and uri.endswith(\"/\")\n            and not route.strict\n            and not route.raw_path[:-1]\n        ):\n            uri = uri[:-1]\n\n        if not uri.startswith(\"/\"):\n            uri = f\"/{uri}\"\n\n        out = uri\n\n        # _method is only a placeholder now, don't know how to support it\n        kwargs.pop(\"_method\", None)\n        anchor = kwargs.pop(\"_anchor\", \"\")\n        # _external need SERVER_NAME in config or pass _server arg\n        host = kwargs.pop(\"_host\", None)\n        external = kwargs.pop(\"_external\", False) or bool(host)\n        scheme = kwargs.pop(\"_scheme\", \"\")\n        if route.ctx.hosts and external:\n            if not host and len(route.ctx.hosts) > 1:\n                raise ValueError(\n                    f\"Host is ambiguous: {', '.join(route.ctx.hosts)}\"\n                )\n            elif host and host not in route.ctx.hosts:\n                raise ValueError(\n                    f\"Requested host ({host}) is not available for this \"\n                    f\"route: {route.ctx.hosts}\"\n                )\n            elif not host:\n                host = list(route.ctx.hosts)[0]\n\n        if scheme and not external:\n            raise ValueError(\"When specifying _scheme, _external must be True\")\n\n        netloc = kwargs.pop(\"_server\", None)\n        if netloc is None and external:\n            netloc = host or self.config.get(\"SERVER_NAME\", \"\")\n\n        if external:\n            if not scheme:\n                if \":\" in netloc[:8]:\n                    scheme = netloc[:8].split(\":\", 1)[0]\n                else:\n                    scheme = \"http\"\n\n            if \"://\" in netloc[:8]:\n                netloc = netloc.split(\"://\", 1)[-1]\n\n        # find all the parameters we will need to build in the URL\n        # matched_params = re.findall(self.router.parameter_pattern, uri)\n        route.finalize()\n        for param_info in route.params.values():\n            # name, _type, pattern = self.router.parse_parameter_string(match)\n            # we only want to match against each individual parameter\n\n            try:\n                supplied_param = str(kwargs.pop(param_info.name))\n            except KeyError:\n                raise URLBuildError(\n                    f\"Required parameter `{param_info.name}` was not \"\n                    \"passed to url_for\"\n                )\n\n            # determine if the parameter supplied by the caller\n            # passes the test in the URL\n            if param_info.pattern:\n                passes_pattern = param_info.pattern.match(supplied_param)\n                if not passes_pattern:\n                    if param_info.cast != str:\n                        msg = (\n                            f'Value \"{supplied_param}\" '\n                            f\"for parameter `{param_info.name}` does \"\n                            \"not match pattern for type \"\n                            f\"`{param_info.cast.__name__}`: \"\n                            f\"{param_info.pattern.pattern}\"\n                        )\n                    else:\n                        msg = (\n                            f'Value \"{supplied_param}\" for parameter '\n                            f\"`{param_info.name}` does not satisfy \"\n                            f\"pattern {param_info.pattern.pattern}\"\n                        )\n                    raise URLBuildError(msg)\n\n            # replace the parameter in the URL with the supplied value\n            replacement_regex = f\"(<{param_info.name}.*?>)\"\n            out = re.sub(replacement_regex, supplied_param, out)\n\n        # parse the remainder of the keyword arguments into a querystring\n        query_string = urlencode(kwargs, doseq=True) if kwargs else \"\"\n        # scheme://netloc/path;parameters?query#fragment\n        out = urlunparse((scheme, netloc, out, \"\", query_string, anchor))\n\n        return out", "is_method": true, "class_name": "Sanic", "function_description": "Utility method of the Sanic class that generates a URL for a given view name by substituting required parameters and appending optional query strings or fragments. It supports building relative or absolute URLs with customizable schemes, hosts, and anchors."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "test_client", "line_number": 789, "body": "def test_client(self):  # noqa\n        if self._test_client:\n            return self._test_client\n        elif self._test_manager:\n            return self._test_manager.test_client\n        from sanic_testing.testing import SanicTestClient  # type: ignore\n\n        self._test_client = SanicTestClient(self)\n        return self._test_client", "is_method": true, "class_name": "Sanic", "function_description": "Provides a reusable test client instance for the Sanic app, facilitating HTTP request simulation in testing scenarios with automatic initialization if needed."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "asgi_client", "line_number": 800, "body": "def asgi_client(self):  # noqa\n        \"\"\"\n        A testing client that uses ASGI to reach into the application to\n        execute hanlers.\n\n        :return: testing client\n        :rtype: :class:`SanicASGITestClient`\n        \"\"\"\n        if self._asgi_client:\n            return self._asgi_client\n        elif self._test_manager:\n            return self._test_manager.asgi_client\n        from sanic_testing.testing import SanicASGITestClient  # type: ignore\n\n        self._asgi_client = SanicASGITestClient(self)\n        return self._asgi_client", "is_method": true, "class_name": "Sanic", "function_description": "Provides a testing client that uses ASGI to directly interact with the Sanic application\u2019s handlers. This enables efficient execution and testing of routes without running the full server."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "run", "line_number": 821, "body": "def run(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        *,\n        debug: bool = False,\n        auto_reload: Optional[bool] = None,\n        ssl: Union[dict, SSLContext, None] = None,\n        sock: Optional[socket] = None,\n        workers: int = 1,\n        protocol: Optional[Type[Protocol]] = None,\n        backlog: int = 100,\n        register_sys_signals: bool = True,\n        access_log: Optional[bool] = None,\n        unix: Optional[str] = None,\n        loop: None = None,\n    ) -> None:\n        \"\"\"\n        Run the HTTP Server and listen until keyboard interrupt or term\n        signal. On termination, drain connections before closing.\n\n        :param host: Address to host on\n        :type host: str\n        :param port: Port to host on\n        :type port: int\n        :param debug: Enables debug output (slows server)\n        :type debug: bool\n        :param auto_reload: Reload app whenever its source code is changed.\n                            Enabled by default in debug mode.\n        :type auto_relaod: bool\n        :param ssl: SSLContext, or location of certificate and key\n                    for SSL encryption of worker(s)\n        :type ssl: SSLContext or dict\n        :param sock: Socket for the server to accept connections from\n        :type sock: socket\n        :param workers: Number of processes received before it is respected\n        :type workers: int\n        :param protocol: Subclass of asyncio Protocol class\n        :type protocol: type[Protocol]\n        :param backlog: a number of unaccepted connections that the system\n                        will allow before refusing new connections\n        :type backlog: int\n        :param register_sys_signals: Register SIG* events\n        :type register_sys_signals: bool\n        :param access_log: Enables writing access logs (slows server)\n        :type access_log: bool\n        :param unix: Unix socket to listen on instead of TCP port\n        :type unix: str\n        :return: Nothing\n        \"\"\"\n        if loop is not None:\n            raise TypeError(\n                \"loop is not a valid argument. To use an existing loop, \"\n                \"change to create_server().\\nSee more: \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/deploying.html\"\n                \"#asynchronous-support\"\n            )\n\n        if auto_reload or auto_reload is None and debug:\n            if os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\":\n                return reloader_helpers.watchdog(1.0)\n\n        if sock is None:\n            host, port = host or \"127.0.0.1\", port or 8000\n\n        if protocol is None:\n            protocol = (\n                WebSocketProtocol if self.websocket_enabled else HttpProtocol\n            )\n        # if access_log is passed explicitly change config.ACCESS_LOG\n        if access_log is not None:\n            self.config.ACCESS_LOG = access_log\n\n        server_settings = self._helper(\n            host=host,\n            port=port,\n            debug=debug,\n            ssl=ssl,\n            sock=sock,\n            unix=unix,\n            workers=workers,\n            protocol=protocol,\n            backlog=backlog,\n            register_sys_signals=register_sys_signals,\n            auto_reload=auto_reload,\n        )\n\n        try:\n            self.is_running = True\n            self.is_stopping = False\n            if workers > 1 and os.name != \"posix\":\n                logger.warn(\n                    f\"Multiprocessing is currently not supported on {os.name},\"\n                    \" using workers=1 instead\"\n                )\n                workers = 1\n            if workers == 1:\n                serve_single(server_settings)\n            else:\n                serve_multiple(server_settings, workers)\n        except BaseException:\n            error_logger.exception(\n                \"Experienced exception while trying to serve\"\n            )\n            raise\n        finally:\n            self.is_running = False\n        logger.info(\"Server Stopped\")", "is_method": true, "class_name": "Sanic", "function_description": "Starts and manages the Sanic HTTP server, handling multiple configuration options such as host, port, SSL, workers, and logging, then runs until interrupted while gracefully closing connections on shutdown."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "stop", "line_number": 930, "body": "def stop(self):\n        \"\"\"\n        This kills the Sanic\n        \"\"\"\n        if not self.is_stopping:\n            self.is_stopping = True\n            get_event_loop().stop()", "is_method": true, "class_name": "Sanic", "function_description": "Method of the Sanic class that stops the running event loop and marks the server as stopping, effectively terminating the Sanic application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_helper", "line_number": 1082, "body": "def _helper(\n        self,\n        host=None,\n        port=None,\n        debug=False,\n        ssl=None,\n        sock=None,\n        unix=None,\n        workers=1,\n        loop=None,\n        protocol=HttpProtocol,\n        backlog=100,\n        register_sys_signals=True,\n        run_async=False,\n        auto_reload=False,\n    ):\n        \"\"\"Helper function used by `run` and `create_server`.\"\"\"\n\n        self.listeners[\"before_server_start\"] = [\n            self.finalize\n        ] + self.listeners[\"before_server_start\"]\n\n        if isinstance(ssl, dict):\n            # try common aliaseses\n            cert = ssl.get(\"cert\") or ssl.get(\"certificate\")\n            key = ssl.get(\"key\") or ssl.get(\"keyfile\")\n            if cert is None or key is None:\n                raise ValueError(\"SSLContext or certificate and key required.\")\n            context = create_default_context(purpose=Purpose.CLIENT_AUTH)\n            context.load_cert_chain(cert, keyfile=key)\n            ssl = context\n        if self.config.PROXIES_COUNT and self.config.PROXIES_COUNT < 0:\n            raise ValueError(\n                \"PROXIES_COUNT cannot be negative. \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/config.html\"\n                \"#proxy-configuration\"\n            )\n\n        self.error_handler.debug = debug\n        self.debug = debug\n\n        server_settings = {\n            \"protocol\": protocol,\n            \"host\": host,\n            \"port\": port,\n            \"sock\": sock,\n            \"unix\": unix,\n            \"ssl\": ssl,\n            \"app\": self,\n            \"signal\": ServerSignal(),\n            \"loop\": loop,\n            \"register_sys_signals\": register_sys_signals,\n            \"backlog\": backlog,\n        }\n\n        # Register start/stop events\n\n        for event_name, settings_name, reverse in (\n            (\"before_server_start\", \"before_start\", False),\n            (\"after_server_start\", \"after_start\", False),\n            (\"before_server_stop\", \"before_stop\", True),\n            (\"after_server_stop\", \"after_stop\", True),\n            (\"main_process_start\", \"main_start\", False),\n            (\"main_process_stop\", \"main_stop\", True),\n        ):\n            listeners = self.listeners[event_name].copy()\n            if reverse:\n                listeners.reverse()\n            # Prepend sanic to the arguments when listeners are triggered\n            listeners = [partial(listener, self) for listener in listeners]\n            server_settings[settings_name] = listeners\n\n        if self.configure_logging and debug:\n            logger.setLevel(logging.DEBUG)\n\n        if (\n            self.config.LOGO\n            and os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\"\n        ):\n            logger.debug(\n                self.config.LOGO\n                if isinstance(self.config.LOGO, str)\n                else BASE_LOGO\n            )\n\n        if run_async:\n            server_settings[\"run_async\"] = True\n\n        # Serve\n        if host and port:\n            proto = \"http\"\n            if ssl is not None:\n                proto = \"https\"\n            if unix:\n                logger.info(f\"Goin' Fast @ {unix} {proto}://...\")\n            else:\n                logger.info(f\"Goin' Fast @ {proto}://{host}:{port}\")\n\n        return server_settings", "is_method": true, "class_name": "Sanic", "function_description": "Internal helper method of the Sanic class that prepares and configures server settings for starting or creating the server, including SSL handling, event listener registration, and logging setup."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_build_endpoint_name", "line_number": 1182, "body": "def _build_endpoint_name(self, *parts):\n        parts = [self.name, *parts]\n        return \".\".join(parts)", "is_method": true, "class_name": "Sanic", "function_description": "Constructs a dot-separated endpoint name by combining the Sanic instance's name with additional string parts, providing a consistent naming convention for routes or handlers."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_loop_add_task", "line_number": 1187, "body": "def _loop_add_task(cls, task, app, loop):\n        if callable(task):\n            try:\n                loop.create_task(task(app))\n            except TypeError:\n                loop.create_task(task())\n        else:\n            loop.create_task(task)", "is_method": true, "class_name": "Sanic", "function_description": "Internal utility method of the Sanic class that schedules a given task or coroutine to run on an event loop, handling both callable tasks with or without arguments and already created task objects."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_cancel_websocket_tasks", "line_number": 1197, "body": "def _cancel_websocket_tasks(cls, app, loop):\n        for task in app.websocket_tasks:\n            task.cancel()", "is_method": true, "class_name": "Sanic", "function_description": "Internal utility method in the Sanic class that cancels all ongoing websocket tasks for a given app, aiding in resource cleanup or shutdown processes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "update_config", "line_number": 1222, "body": "def update_config(self, config: Union[bytes, str, dict, Any]):\n        \"\"\"\n        Update app.config. Full implementation can be found in the user guide.\n\n        `See user guide re: configuration\n        <https://sanicframework.org/guide/deployment/configuration.html#basics>`__\n        \"\"\"\n\n        self.config.update_config(config)", "is_method": true, "class_name": "Sanic", "function_description": "Method of the Sanic class that updates the application's configuration using various input types, allowing dynamic adjustment of settings during runtime."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "register_app", "line_number": 1237, "body": "def register_app(cls, app: \"Sanic\") -> None:\n        \"\"\"\n        Register a Sanic instance\n        \"\"\"\n        if not isinstance(app, cls):\n            raise SanicException(\"Registered app must be an instance of Sanic\")\n\n        name = app.name\n        if name in cls._app_registry and not cls.test_mode:\n            raise SanicException(f'Sanic app name \"{name}\" already in use.')\n\n        cls._app_registry[name] = app", "is_method": true, "class_name": "Sanic", "function_description": "Registers a Sanic application instance by adding it to a class-wide registry, ensuring unique app names and type safety. Useful for managing multiple Sanic app instances within the framework."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "get_app", "line_number": 1251, "body": "def get_app(\n        cls, name: Optional[str] = None, *, force_create: bool = False\n    ) -> \"Sanic\":\n        \"\"\"\n        Retrieve an instantiated Sanic instance\n        \"\"\"\n        if name is None:\n            if len(cls._app_registry) > 1:\n                raise SanicException(\n                    'Multiple Sanic apps found, use Sanic.get_app(\"app_name\")'\n                )\n            elif len(cls._app_registry) == 0:\n                raise SanicException(\"No Sanic apps have been registered.\")\n            else:\n                return list(cls._app_registry.values())[0]\n        try:\n            return cls._app_registry[name]\n        except KeyError:\n            if force_create:\n                return cls(name)\n            raise SanicException(f'Sanic app name \"{name}\" not found.')", "is_method": true, "class_name": "Sanic", "function_description": "Provides a way to retrieve a named or default Sanic app instance from the registry, optionally creating it if missing. This facilitates managing multiple Sanic applications within the same environment."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/asgi.py", "function": "respond", "line_number": 178, "body": "def respond(self, response):\n        response.stream, self.response = self, response\n        return response", "is_method": true, "class_name": "ASGIApp", "function_description": "Returns the given response object while associating the current ASGIApp instance as its stream handler, enabling response streaming functionality within the ASGI application context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/exceptions.py", "function": "add_status_code", "line_number": 9, "body": "def add_status_code(code, quiet=None):\n    \"\"\"\n    Decorator used for adding exceptions to :class:`SanicException`.\n    \"\"\"\n\n    def class_decorator(cls):\n        cls.status_code = code\n        if quiet or quiet is None and code != 500:\n            cls.quiet = True\n        _sanic_exceptions[code] = cls\n        return cls\n\n    return class_decorator", "is_method": false, "function_description": "Decorator function that assigns an HTTP status code and optional silence flag to exception classes, registering them for use within SanicException handling. It simplifies defining and mapping custom HTTP exceptions."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/exceptions.py", "function": "abort", "line_number": 234, "body": "def abort(status_code: int, message: Optional[Union[str, bytes]] = None):\n    \"\"\"\n    Raise an exception based on SanicException. Returns the HTTP response\n    message appropriate for the given status code, unless provided.\n\n    STATUS_CODES from sanic.helpers for the given status code.\n\n    :param status_code: The HTTP status code to return.\n    :param message: The HTTP response body. Defaults to the messages in\n    \"\"\"\n    if message is None:\n        msg: bytes = STATUS_CODES[status_code]\n        # These are stored as bytes in the STATUS_CODES dict\n        message = msg.decode(\"utf8\")\n    sanic_exception = _sanic_exceptions.get(status_code, SanicException)\n    raise sanic_exception(message=message, status_code=status_code)", "is_method": false, "function_description": "Function that raises an HTTP exception with a specified status code and optional custom message, providing appropriate HTTP response handling in Sanic web applications. It simplifies generating standard or customized error responses."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/base.py", "function": "__str__", "line_number": 24, "body": "def __str__(self) -> str:\n        return f\"<{self.__class__.__name__} {self.name}>\"", "is_method": true, "class_name": "BaseSanic", "function_description": "Provides a readable string representation of the BaseSanic instance, showing its class name and specific name attribute for easy identification during debugging or logging."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/base.py", "function": "__repr__", "line_number": 27, "body": "def __repr__(self) -> str:\n        return f'{self.__class__.__name__}(name=\"{self.name}\")'", "is_method": true, "class_name": "BaseSanic", "function_description": "Provides a string representation of the BaseSanic instance showing its class name and the value of its name attribute for clearer identification during debugging and logging."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/base.py", "function": "__setattr__", "line_number": 30, "body": "def __setattr__(self, name: str, value: Any) -> None:\n        # This is a temporary compat layer so we can raise a warning until\n        # setting attributes on the app instance can be removed and deprecated\n        # with a proper implementation of __slots__\n        if name not in self.__fake_slots__:\n            warn(\n                f\"Setting variables on {self.__class__.__name__} instances is \"\n                \"deprecated and will be removed in version 21.9. You should \"\n                f\"change your {self.__class__.__name__} instance to use \"\n                f\"instance.ctx.{name} instead.\"\n            )\n        super().__setattr__(name, value)", "is_method": true, "class_name": "BaseSanic", "function_description": "Overrides attribute assignment to warn about deprecated direct setting on the BaseSanic instance, guiding users to use `instance.ctx` for storing attributes instead."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/__main__.py", "function": "main", "line_number": 24, "body": "def main():\n    parser = SanicArgumentParser(\n        prog=\"sanic\",\n        description=BASE_LOGO,\n        formatter_class=RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        \"-H\",\n        \"--host\",\n        dest=\"host\",\n        type=str,\n        default=\"127.0.0.1\",\n        help=\"host address [default 127.0.0.1]\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--port\",\n        dest=\"port\",\n        type=int,\n        default=8000,\n        help=\"port to serve on [default 8000]\",\n    )\n    parser.add_argument(\n        \"-u\",\n        \"--unix\",\n        dest=\"unix\",\n        type=str,\n        default=\"\",\n        help=\"location of unix socket\",\n    )\n    parser.add_argument(\n        \"--cert\", dest=\"cert\", type=str, help=\"location of certificate for SSL\"\n    )\n    parser.add_argument(\n        \"--key\", dest=\"key\", type=str, help=\"location of keyfile for SSL.\"\n    )\n    parser.add_argument(\n        \"-w\",\n        \"--workers\",\n        dest=\"workers\",\n        type=int,\n        default=1,\n        help=\"number of worker processes [default 1]\",\n    )\n    parser.add_argument(\"--debug\", dest=\"debug\", action=\"store_true\")\n    parser.add_bool_arguments(\n        \"--access-logs\", dest=\"access_log\", help=\"display access logs\"\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--version\",\n        action=\"version\",\n        version=f\"Sanic {__version__}\",\n    )\n    parser.add_argument(\n        \"module\", help=\"path to your Sanic app. Example: path.to.server:app\"\n    )\n    args = parser.parse_args()\n\n    try:\n        module_path = os.path.abspath(os.getcwd())\n        if module_path not in sys.path:\n            sys.path.append(module_path)\n\n        if \":\" in args.module:\n            module_name, app_name = args.module.rsplit(\":\", 1)\n        else:\n            module_parts = args.module.split(\".\")\n            module_name = \".\".join(module_parts[:-1])\n            app_name = module_parts[-1]\n\n        module = import_module(module_name)\n        app = getattr(module, app_name, None)\n        app_name = type(app).__name__\n\n        if not isinstance(app, Sanic):\n            raise ValueError(\n                f\"Module is not a Sanic app, it is a {app_name}.  \"\n                f\"Perhaps you meant {args.module}.app?\"\n            )\n        if args.cert is not None or args.key is not None:\n            ssl = {\n                \"cert\": args.cert,\n                \"key\": args.key,\n            }  # type: Optional[Dict[str, Any]]\n        else:\n            ssl = None\n\n        app.run(\n            host=args.host,\n            port=args.port,\n            unix=args.unix,\n            workers=args.workers,\n            debug=args.debug,\n            access_log=args.access_log,\n            ssl=ssl,\n        )\n    except ImportError as e:\n        logger.error(\n            f\"No module named {e.name} found.\\n\"\n            f\"  Example File: project/sanic_server.py -> app\\n\"\n            f\"  Example Module: project.sanic_server.app\"\n        )\n    except ValueError:\n        logger.exception(\"Failed to run app\")", "is_method": false, "function_description": "Entrypoint function that parses command-line arguments, loads a specified Sanic app module, configures SSL if needed, and runs the Sanic server with the provided options."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/__main__.py", "function": "add_bool_arguments", "line_number": 15, "body": "def add_bool_arguments(self, *args, **kwargs):\n        group = self.add_mutually_exclusive_group()\n        group.add_argument(*args, action=\"store_true\", **kwargs)\n        kwargs[\"help\"] = \"no \" + kwargs[\"help\"]\n        group.add_argument(\n            \"--no-\" + args[0][2:], *args[1:], action=\"store_false\", **kwargs\n        )", "is_method": true, "class_name": "SanicArgumentParser", "function_description": "Utility method in SanicArgumentParser that adds paired boolean command-line options with mutually exclusive positive and negative flags, simplifying the handling of boolean arguments for CLI tools."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "stream", "line_number": 69, "body": "def stream(func):\n    func.is_stream = True\n    return func", "is_method": false, "function_description": "Utility decorator that marks a function as a streaming-capable function by adding an attribute, enabling other components to recognize and handle streaming behavior accordingly."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "dispatch_request", "line_number": 43, "body": "def dispatch_request(self, request, *args, **kwargs):\n        handler = getattr(self, request.method.lower(), None)\n        return handler(request, *args, **kwargs)", "is_method": true, "class_name": "HTTPMethodView", "function_description": "Core function of HTTPMethodView that directs an incoming HTTP request to the appropriate method handler based on the request's HTTP verb, facilitating organized handling of different HTTP methods in a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "as_view", "line_number": 48, "body": "def as_view(cls, *class_args, **class_kwargs):\n        \"\"\"Return view function for use with the routing system, that\n        dispatches request to appropriate handler method.\n        \"\"\"\n\n        def view(*args, **kwargs):\n            self = view.view_class(*class_args, **class_kwargs)\n            return self.dispatch_request(*args, **kwargs)\n\n        if cls.decorators:\n            view.__module__ = cls.__module__\n            for decorator in cls.decorators:\n                view = decorator(view)\n\n        view.view_class = cls\n        view.__doc__ = cls.__doc__\n        view.__module__ = cls.__module__\n        view.__name__ = cls.__name__\n        return view", "is_method": true, "class_name": "HTTPMethodView", "function_description": "Creates a view function that routes HTTP requests to the appropriate handler method of a given HTTPMethodView subclass, optionally applying decorators. It enables class-based views to integrate seamlessly with a routing system."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "__name__", "line_number": 95, "body": "def __name__(self):\n        return self.name", "is_method": true, "class_name": "CompositionView", "function_description": "Returns the name attribute of the CompositionView instance. This provides a simple way to access the object's identifier or label."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "add", "line_number": 98, "body": "def add(self, methods, handler, stream=False):\n        if stream:\n            handler.is_stream = stream\n        for method in methods:\n            if method not in HTTP_METHODS:\n                raise InvalidUsage(f\"{method} is not a valid HTTP method.\")\n\n            if method in self.handlers:\n                raise InvalidUsage(f\"Method {method} is already registered.\")\n            self.handlers[method] = handler", "is_method": true, "class_name": "CompositionView", "function_description": "Adds HTTP method handlers to the CompositionView, ensuring each method is valid and unique while optionally marking the handler for streaming responses. This supports dynamic assignment of request handlers within the view."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "__call__", "line_number": 109, "body": "def __call__(self, request, *args, **kwargs):\n        handler = self.handlers[request.method.upper()]\n        return handler(request, *args, **kwargs)", "is_method": true, "class_name": "CompositionView", "function_description": "Core method of CompositionView that dispatches an incoming request to the appropriate handler based on the HTTP method, enabling dynamic request processing for different operations."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/handlers.py", "function": "add", "line_number": 35, "body": "def add(self, exception, handler):\n        \"\"\"\n        Add a new exception handler to an already existing handler object.\n\n        :param exception: Type of exception that need to be handled\n        :param handler: Reference to the method that will handle the exception\n\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n        :type handler: ``function``\n\n        :return: None\n        \"\"\"\n        self.handlers.append((exception, handler))", "is_method": true, "class_name": "ErrorHandler", "function_description": "Adds a new exception handler function for a specified exception type, extending the ErrorHandler's capability to process different errors during execution. It allows dynamic association of exceptions with handling routines."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/handlers.py", "function": "lookup", "line_number": 50, "body": "def lookup(self, exception):\n        \"\"\"\n        Lookup the existing instance of :class:`ErrorHandler` and fetch the\n        registered handler for a specific type of exception.\n\n        This method leverages a dict lookup to speedup the retrieval process.\n\n        :param exception: Type of exception\n\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n\n        :return: Registered function if found ``None`` otherwise\n        \"\"\"\n        handler = self.cached_handlers.get(type(exception), self._missing)\n        if handler is self._missing:\n            for exception_class, handler in self.handlers:\n                if isinstance(exception, exception_class):\n                    self.cached_handlers[type(exception)] = handler\n                    return handler\n            self.cached_handlers[type(exception)] = None\n            handler = None\n        return handler", "is_method": true, "class_name": "ErrorHandler", "function_description": "Core method of the ErrorHandler class that retrieves the registered handler function for a given exception type, enabling efficient exception-to-handler mapping with caching for faster future lookups."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/handlers.py", "function": "response", "line_number": 74, "body": "def response(self, request, exception):\n        \"\"\"Fetches and executes an exception handler and returns a response\n        object\n\n        :param request: Instance of :class:`sanic.request.Request`\n        :param exception: Exception to handle\n\n        :type request: :class:`sanic.request.Request`\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n\n        :return: Wrap the return value obtained from :func:`default`\n            or registered handler for that type of exception.\n        \"\"\"\n        handler = self.lookup(exception)\n        response = None\n        try:\n            if handler:\n                response = handler(request, exception)\n            if response is None:\n                response = self.default(request, exception)\n        except Exception:\n            self.log(format_exc())\n            try:\n                url = repr(request.url)\n            except AttributeError:\n                url = \"unknown\"\n            response_message = (\n                \"Exception raised in exception handler \" '\"%s\" for uri: %s'\n            )\n            logger.exception(response_message, handler.__name__, url)\n\n            if self.debug:\n                return text(response_message % (handler.__name__, url), 500)\n            else:\n                return text(\"An error occurred while handling an error\", 500)\n        return response", "is_method": true, "class_name": "ErrorHandler", "function_description": "Handles exceptions by finding and executing the appropriate registered handler or a default one, then returns the resulting HTTP response. It ensures robust error handling and consistent responses within the ErrorHandler context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/handlers.py", "function": "default", "line_number": 117, "body": "def default(self, request, exception):\n        \"\"\"\n        Provide a default behavior for the objects of :class:`ErrorHandler`.\n        If a developer chooses to extent the :class:`ErrorHandler` they can\n        provide a custom implementation for this method to behave in a way\n        they see fit.\n\n        :param request: Incoming request\n        :param exception: Exception object\n\n        :type request: :class:`sanic.request.Request`\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n        :return:\n        \"\"\"\n        quiet = getattr(exception, \"quiet\", False)\n        if quiet is False:\n            try:\n                url = repr(request.url)\n            except AttributeError:\n                url = \"unknown\"\n\n            self.log(format_exc())\n            logger.exception(\"Exception occurred while handling uri: %s\", url)\n\n        return exception_response(request, exception, self.debug)", "is_method": true, "class_name": "ErrorHandler", "function_description": "Handles exceptions by logging error details (unless marked quiet) and returning an appropriate error response for incoming requests, providing a customizable default error handling mechanism."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/handlers.py", "function": "__bool__", "line_number": 212, "body": "def __bool__(self):\n        return self.size > 0", "is_method": true, "class_name": "ContentRangeHandler", "function_description": "Boolean conversion method for ContentRangeHandler that indicates whether the content range contains any data by checking if its size is greater than zero."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/config.py", "function": "__getattr__", "line_number": 57, "body": "def __getattr__(self, attr):\n        try:\n            return self[attr]\n        except KeyError as ke:\n            raise AttributeError(f\"Config has no '{ke.args[0]}'\")", "is_method": true, "class_name": "Config", "function_description": "Allows access to configuration values as attributes, raising an AttributeError if the requested key is missing. This enables convenient and intuitive retrieval of configuration settings within the Config class."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/config.py", "function": "__setattr__", "line_number": 63, "body": "def __setattr__(self, attr, value):\n        self[attr] = value", "is_method": true, "class_name": "Config", "function_description": "Overrides attribute assignment to store values in the Config object like dictionary entries, enabling attribute-style access for configuration settings."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/config.py", "function": "load_environment_vars", "line_number": 66, "body": "def load_environment_vars(self, prefix=SANIC_PREFIX):\n        \"\"\"\n        Looks for prefixed environment variables and applies\n        them to the configuration if present. This is called automatically when\n        Sanic starts up to load environment variables into config.\n\n        It will automatically hyrdate the following types:\n\n        - ``int``\n        - ``float``\n        - ``bool``\n\n        Anything else will be imported as a ``str``.\n        \"\"\"\n        for k, v in environ.items():\n            if k.startswith(prefix):\n                _, config_key = k.split(prefix, 1)\n                try:\n                    self[config_key] = int(v)\n                except ValueError:\n                    try:\n                        self[config_key] = float(v)\n                    except ValueError:\n                        try:\n                            self[config_key] = str_to_bool(v)\n                        except ValueError:\n                            self[config_key] = v", "is_method": true, "class_name": "Config", "function_description": "Core method of the Config class that loads and applies environment variables with a specific prefix, automatically converting them to appropriate types for application configuration at startup."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/config.py", "function": "update_config", "line_number": 94, "body": "def update_config(self, config: Union[bytes, str, dict, Any]):\n        \"\"\"\n        Update app.config.\n\n        .. note::\n\n            Only upper case settings are considered\n\n        You can upload app config by providing path to py file\n        holding settings.\n\n        .. code-block:: python\n\n            # /some/py/file\n            A = 1\n            B = 2\n\n        .. code-block:: python\n\n            config.update_config(\"${some}/py/file\")\n\n        Yes you can put environment variable here, but they must be provided\n        in format: ``${some_env_var}``, and mark that ``$some_env_var`` is\n        treated as plain string.\n\n        You can upload app config by providing dict holding settings.\n\n        .. code-block:: python\n\n            d = {\"A\": 1, \"B\": 2}\n            config.update_config(d)\n\n        You can upload app config by providing any object holding settings,\n        but in such case config.__dict__ will be used as dict holding settings.\n\n        .. code-block:: python\n\n            class C:\n                A = 1\n                B = 2\n\n            config.update_config(C)\n\n        `See user guide re: config\n        <https://sanicframework.org/guide/deployment/configuration.html>`__\n        \"\"\"\n\n        if isinstance(config, (bytes, str, Path)):\n            config = load_module_from_file_location(location=config)\n\n        if not isinstance(config, dict):\n            cfg = {}\n            if not isclass(config):\n                cfg.update(\n                    {\n                        key: getattr(config, key)\n                        for key in config.__class__.__dict__.keys()\n                    }\n                )\n\n            config = dict(config.__dict__)\n            config.update(cfg)\n\n        config = dict(filter(lambda i: i[0].isupper(), config.items()))\n\n        self.update(config)", "is_method": true, "class_name": "Config", "function_description": "Core method of the Config class that updates configuration settings from diverse sources like files, dictionaries, or objects, considering only uppercase keys for application configuration. It supports flexible input formats and environment variable substitution."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/helpers.py", "function": "has_message_body", "line_number": 103, "body": "def has_message_body(status):\n    \"\"\"\n    According to the following RFC message body and length SHOULD NOT\n    be included in responses status 1XX, 204 and 304.\n    https://tools.ietf.org/html/rfc2616#section-4.4\n    https://tools.ietf.org/html/rfc2616#section-4.3\n    \"\"\"\n    return status not in (204, 304) and not (100 <= status < 200)", "is_method": false, "function_description": "Determines if an HTTP response status code allows a message body based on RFC standards, aiding in correct handling of response content in HTTP communications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/helpers.py", "function": "is_entity_header", "line_number": 113, "body": "def is_entity_header(header):\n    \"\"\"Checks if the given header is an Entity Header\"\"\"\n    return header.lower() in _ENTITY_HEADERS", "is_method": false, "function_description": "Checks if a given header string corresponds to a predefined set of entity headers, enabling identification of entity-specific sections in data processing contexts."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/helpers.py", "function": "is_hop_by_hop_header", "line_number": 118, "body": "def is_hop_by_hop_header(header):\n    \"\"\"Checks if the given header is a Hop By Hop header\"\"\"\n    return header.lower() in _HOP_BY_HOP_HEADERS", "is_method": false, "function_description": "Utility function that determines whether a given HTTP header is classified as a Hop-By-Hop header, which affects how headers are handled in HTTP message forwarding."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/helpers.py", "function": "remove_entity_headers", "line_number": 123, "body": "def remove_entity_headers(headers, allowed=(\"content-location\", \"expires\")):\n    \"\"\"\n    Removes all the entity headers present in the headers given.\n    According to RFC 2616 Section 10.3.5,\n    Content-Location and Expires are allowed as for the\n    \"strong cache validator\".\n    https://tools.ietf.org/html/rfc2616#section-10.3.5\n\n    returns the headers without the entity headers\n    \"\"\"\n    allowed = set([h.lower() for h in allowed])\n    headers = {\n        header: value\n        for header, value in headers.items()\n        if not is_entity_header(header) or header.lower() in allowed\n    }\n    return headers", "is_method": false, "function_description": "Function that filters out entity headers from a headers dictionary, preserving only those allowed (e.g., Content-Location, Expires) to comply with HTTP caching rules. Useful for managing headers in HTTP responses or requests."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/helpers.py", "function": "import_string", "line_number": 142, "body": "def import_string(module_name, package=None):\n    \"\"\"\n    import a module or class by string path.\n\n    :module_name: str with path of module or path to import and\n    instanciate a class\n    :returns: a module object or one instance from class if\n    module_name is a valid path to class\n\n    \"\"\"\n    module, klass = module_name.rsplit(\".\", 1)\n    module = import_module(module, package=package)\n    obj = getattr(module, klass)\n    if ismodule(obj):\n        return obj\n    return obj()", "is_method": false, "function_description": "Function that dynamically imports a module or instantiates a class using its string path, enabling flexible, runtime access to modules or class instances based on their dotted path names."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "_get", "line_number": 29, "body": "def _get(\n        self, path: str, method: str, host: Optional[str]\n    ) -> Tuple[Route, RouteHandler, Dict[str, Any]]:\n        try:\n            return self.resolve(\n                path=path,\n                method=method,\n                extra={\"host\": host},\n            )\n        except RoutingNotFound as e:\n            raise NotFound(\"Requested URL {} not found\".format(e.path))\n        except NoMethod as e:\n            raise MethodNotSupported(\n                \"Method {} not allowed for URL {}\".format(method, path),\n                method=method,\n                allowed_methods=e.allowed_methods,\n            )", "is_method": true, "class_name": "Router", "function_description": "Core method of the Router class that resolves a request by path, method, and optional host, returning the matching route and handler or raising appropriate errors if no match or method is unsupported."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "get", "line_number": 48, "body": "def get(  # type: ignore\n        self, path: str, method: str, host: Optional[str]\n    ) -> Tuple[Route, RouteHandler, Dict[str, Any]]:\n        \"\"\"\n        Retrieve a `Route` object containg the details about how to handle\n        a response for a given request\n\n        :param request: the incoming request object\n        :type request: Request\n        :return: details needed for handling the request and returning the\n            correct response\n        :rtype: Tuple[ Route, RouteHandler, Dict[str, Any]]\n        \"\"\"\n        return self._get(path, method, host)", "is_method": true, "class_name": "Router", "function_description": "Core method of the Router class that retrieves routing details, including the matched route, handler, and related metadata, for a given request path, HTTP method, and optional host. It enables request dispatching based on URL and method."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "add", "line_number": 63, "body": "def add(  # type: ignore\n        self,\n        uri: str,\n        methods: Iterable[str],\n        handler: RouteHandler,\n        host: Optional[Union[str, Iterable[str]]] = None,\n        strict_slashes: bool = False,\n        stream: bool = False,\n        ignore_body: bool = False,\n        version: Union[str, float, int] = None,\n        name: Optional[str] = None,\n        unquote: bool = False,\n        static: bool = False,\n    ) -> Union[Route, List[Route]]:\n        \"\"\"\n        Add a handler to the router\n\n        :param uri: the path of the route\n        :type uri: str\n        :param methods: the types of HTTP methods that should be attached,\n            example: ``[\"GET\", \"POST\", \"OPTIONS\"]``\n        :type methods: Iterable[str]\n        :param handler: the sync or async function to be executed\n        :type handler: RouteHandler\n        :param host: host that the route should be on, defaults to None\n        :type host: Optional[str], optional\n        :param strict_slashes: whether to apply strict slashes, defaults\n            to False\n        :type strict_slashes: bool, optional\n        :param stream: whether to stream the response, defaults to False\n        :type stream: bool, optional\n        :param ignore_body: whether the incoming request body should be read,\n            defaults to False\n        :type ignore_body: bool, optional\n        :param version: a version modifier for the uri, defaults to None\n        :type version: Union[str, float, int], optional\n        :param name: an identifying name of the route, defaults to None\n        :type name: Optional[str], optional\n        :return: the route object\n        :rtype: Route\n        \"\"\"\n        if version is not None:\n            version = str(version).strip(\"/\").lstrip(\"v\")\n            uri = \"/\".join([f\"/v{version}\", uri.lstrip(\"/\")])\n\n        params = dict(\n            path=uri,\n            handler=handler,\n            methods=methods,\n            name=name,\n            strict=strict_slashes,\n            unquote=unquote,\n        )\n\n        if isinstance(host, str):\n            hosts = [host]\n        else:\n            hosts = host or [None]  # type: ignore\n\n        routes = []\n\n        for host in hosts:\n            if host:\n                params.update({\"requirements\": {\"host\": host}})\n\n            route = super().add(**params)  # type: ignore\n            route.ctx.ignore_body = ignore_body\n            route.ctx.stream = stream\n            route.ctx.hosts = hosts\n            route.ctx.static = static\n\n            routes.append(route)\n\n        if len(routes) == 1:\n            return routes[0]\n        return routes", "is_method": true, "class_name": "Router", "function_description": "Adds one or multiple HTTP routes with specified methods and handlers to the Router, supporting options like host restrictions, versioning, streaming, and request body handling. It returns the created route(s) for request routing and handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "find_route_by_view_name", "line_number": 141, "body": "def find_route_by_view_name(self, view_name, name=None):\n        \"\"\"\n        Find a route in the router based on the specified view name.\n\n        :param view_name: string of view name to search by\n        :param kwargs: additional params, usually for static files\n        :return: tuple containing (uri, Route)\n        \"\"\"\n        if not view_name:\n            return None\n\n        route = self.name_index.get(view_name)\n        if not route:\n            full_name = self.ctx.app._generate_name(view_name)\n            route = self.name_index.get(full_name)\n\n        if not route:\n            return None\n\n        return route", "is_method": true, "class_name": "Router", "function_description": "Core function of the Router class that locates and returns a route by its view name, supporting flexible lookup with generated naming conventions to assist in URL routing and handling within an application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "routes_all", "line_number": 163, "body": "def routes_all(self):\n        return self.routes", "is_method": true, "class_name": "Router", "function_description": "Returns all routing configurations managed by the Router instance, providing access to the complete set of registered routes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "routes_static", "line_number": 167, "body": "def routes_static(self):\n        return self.static_routes", "is_method": true, "class_name": "Router", "function_description": "Returns the static routes managed by the Router. This function provides access to predefined routes for request handling or navigation purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "routes_dynamic", "line_number": 171, "body": "def routes_dynamic(self):\n        return self.dynamic_routes", "is_method": true, "class_name": "Router", "function_description": "Returns the current set of dynamic routes managed by the Router. This function provides access to runtime-configured routing rules for flexible request handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "routes_regex", "line_number": 175, "body": "def routes_regex(self):\n        return self.regex_routes", "is_method": true, "class_name": "Router", "function_description": "Returns the stored regular expression patterns used for routing within the Router class. This method provides access to the underlying route matching rules."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "finalize", "line_number": 178, "body": "def finalize(self, *args, **kwargs):\n        super().finalize(*args, **kwargs)\n\n        for route in self.dynamic_routes.values():\n            if any(\n                label.startswith(\"__\") and label not in ALLOWED_LABELS\n                for label in route.labels\n            ):\n                raise SanicException(\n                    f\"Invalid route: {route}. Parameter names cannot use '__'.\"\n                )", "is_method": true, "class_name": "Router", "function_description": "Validates and finalizes dynamic routes by ensuring parameter names do not start with disallowed double underscores, raising exceptions for invalid routes to maintain proper route integrity."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "request_timeout_callback", "line_number": 54, "body": "def request_timeout_callback(self):\n        if self.websocket is None:\n            super().request_timeout_callback()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Calls a timeout handler if the WebSocket connection is not established, delegating to the parent class for processing in such cases. This method manages timeout events related to WebSocket connections."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "response_timeout_callback", "line_number": 58, "body": "def response_timeout_callback(self):\n        if self.websocket is None:\n            super().response_timeout_callback()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "This method handles response timeouts by invoking the superclass's timeout behavior only if the WebSocket connection is not established. It ensures proper timeout management conditional on WebSocket state."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "keep_alive_timeout_callback", "line_number": 62, "body": "def keep_alive_timeout_callback(self):\n        if self.websocket is None:\n            super().keep_alive_timeout_callback()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Callback method in WebSocketProtocol that handles keep-alive timeout by delegating to the parent implementation when no active websocket connection exists."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "connection_lost", "line_number": 66, "body": "def connection_lost(self, exc):\n        if self.websocket is not None:\n            self.websocket.connection_lost(exc)\n        super().connection_lost(exc)", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Handles the WebSocket connection loss event by notifying the associated WebSocket instance and performing any additional cleanup defined in the parent class. It ensures proper resource release and state update when a connection is interrupted."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "data_received", "line_number": 71, "body": "def data_received(self, data):\n        if self.websocket is not None:\n            # pass the data to the websocket protocol\n            self.websocket.data_received(data)\n        else:\n            try:\n                super().data_received(data)\n            except HttpParserUpgrade:\n                # this is okay, it just indicates we've got an upgrade request\n                pass", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Handles incoming data by forwarding it to the active WebSocket protocol or processing it as a standard HTTP message, supporting HTTP upgrade requests seamlessly for transitioning to WebSocket communication."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "write_response", "line_number": 82, "body": "def write_response(self, response):\n        if self.websocket is not None:\n            # websocket requests do not write a response\n            self.transport.close()\n        else:\n            super().write_response(response)", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Handles sending a response for the WebSocketProtocol, closing the connection if a WebSocket exists; otherwise, it forwards the response using the standard method."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "url_prefix", "line_number": 74, "body": "def url_prefix(self) -> str:\n        \"\"\"\n        Retrieve the URL prefix being used for the Current Blueprint Group\n\n        :return: string with url prefix\n        \"\"\"\n        return self._url_prefix", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Returns the URL prefix associated with the current BlueprintGroup, providing a way to identify the group's routing base for URL construction or matching."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "blueprints", "line_number": 83, "body": "def blueprints(self) -> List[\"sanic.Blueprint\"]:\n        \"\"\"\n        Retrieve a list of all the available blueprints under this group.\n\n        :return: List of Blueprint instance\n        \"\"\"\n        return self._blueprints", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Returns all blueprint instances contained within the BlueprintGroup, providing access to the group's collection of route blueprints for use in web application routing and organization."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "version", "line_number": 92, "body": "def version(self) -> Optional[Union[str, int, float]]:\n        \"\"\"\n        API Version for the Blueprint Group. This will be applied only in case\n        if the Blueprint doesn't already have a version specified\n\n        :return: Version information\n        \"\"\"\n        return self._version", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Returns the version information for the BlueprintGroup, serving as a default version if individual blueprints lack their own specified version. This helps manage API versioning within the blueprint group context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "strict_slashes", "line_number": 102, "body": "def strict_slashes(self) -> Optional[bool]:\n        \"\"\"\n        URL Slash termination behavior configuration\n\n        :return: bool\n        \"\"\"\n        return self._strict_slashes", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Method of BlueprintGroup that provides the URL slash termination behavior configuration, indicating whether strict slash matching is enforced in URL routing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "__iter__", "line_number": 110, "body": "def __iter__(self):\n        \"\"\"\n        Tun the class Blueprint Group into an Iterable item\n        \"\"\"\n        return iter(self._blueprints)", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Enables iteration over the BlueprintGroup instance by returning an iterator for its contained blueprints, facilitating easy traversal in loops and comprehensions."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "__getitem__", "line_number": 116, "body": "def __getitem__(self, item):\n        \"\"\"\n        This method returns a blueprint inside the group specified by\n        an index value. This will enable indexing, splice and slicing\n        of the blueprint group like we can do with regular list/tuple.\n\n        This method is provided to ensure backward compatibility with\n        any of the pre-existing usage that might break.\n\n        :param item: Index of the Blueprint item in the group\n        :return: Blueprint object\n        \"\"\"\n        return self._blueprints[item]", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Enables access to individual blueprints within a BlueprintGroup using indexing, slicing, or splicing, supporting list-like behavior for ease of use and backward compatibility."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "__setitem__", "line_number": 130, "body": "def __setitem__(self, index, item) -> None:\n        \"\"\"\n        Abstract method implemented to turn the `BlueprintGroup` class\n        into a list like object to support all the existing behavior.\n\n        This method is used to perform the list's indexed setter operation.\n\n        :param index: Index to use for inserting a new Blueprint item\n        :param item: New `Blueprint` object.\n        :return: None\n        \"\"\"\n        self._blueprints[index] = item", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Provides list-like indexed assignment for BlueprintGroup, allowing replacement of a Blueprint object at a specified position within the group's internal collection."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "__delitem__", "line_number": 143, "body": "def __delitem__(self, index) -> None:\n        \"\"\"\n        Abstract method implemented to turn the `BlueprintGroup` class\n        into a list like object to support all the existing behavior.\n\n        This method is used to delete an item from the list of blueprint\n        groups like it can be done on a regular list with index.\n\n        :param index: Index to use for removing a new Blueprint item\n        :return: None\n        \"\"\"\n        del self._blueprints[index]", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Enables deletion of a blueprint from the BlueprintGroup by index, allowing BlueprintGroup instances to behave like list objects for managing their contained blueprints."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "__len__", "line_number": 156, "body": "def __len__(self) -> int:\n        \"\"\"\n        Get the Length of the blueprint group object.\n\n        :return: Length of Blueprint group object\n        \"\"\"\n        return len(self._blueprints)", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Returns the number of blueprints contained in the BlueprintGroup, providing a quick way to assess its size or count of elements it manages."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "_sanitize_blueprint", "line_number": 164, "body": "def _sanitize_blueprint(self, bp: \"sanic.Blueprint\") -> \"sanic.Blueprint\":\n        \"\"\"\n        Sanitize the Blueprint Entity to override the Version and strict slash\n        behaviors as required.\n\n        :param bp: Sanic Blueprint entity Object\n        :return: Modified Blueprint\n        \"\"\"\n        if self._url_prefix:\n            merged_prefix = \"/\".join(\n                u.strip(\"/\") for u in [self._url_prefix, bp.url_prefix or \"\"]\n            ).rstrip(\"/\")\n            bp.url_prefix = f\"/{merged_prefix}\"\n        for _attr in [\"version\", \"strict_slashes\"]:\n            if getattr(bp, _attr) is None:\n                setattr(bp, _attr, getattr(self, _attr))\n        return bp", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Utility method of BlueprintGroup that adjusts a Sanic Blueprint\u2019s URL prefix, version, and strict slash settings to ensure consistent routing behavior within the group\u2019s context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "append", "line_number": 182, "body": "def append(self, value: \"sanic.Blueprint\") -> None:\n        \"\"\"\n        The Abstract class `MutableSequence` leverages this append method to\n        perform the `BlueprintGroup.append` operation.\n        :param value: New `Blueprint` object.\n        :return: None\n        \"\"\"\n        self._blueprints.append(self._sanitize_blueprint(bp=value))", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Service method of BlueprintGroup that adds a new Blueprint object to its internal collection, ensuring the blueprint is validated or sanitized before inclusion. It enables dynamic extension of BlueprintGroup with additional Blueprints."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "insert", "line_number": 191, "body": "def insert(self, index: int, item: \"sanic.Blueprint\") -> None:\n        \"\"\"\n        The Abstract class `MutableSequence` leverages this insert method to\n        perform the `BlueprintGroup.append` operation.\n\n        :param index: Index to use for removing a new Blueprint item\n        :param item: New `Blueprint` object.\n        :return: None\n        \"\"\"\n        self._blueprints.insert(index, self._sanitize_blueprint(item))", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Adds a sanitized Blueprint to the BlueprintGroup at a specified position, supporting ordered management of Blueprint instances within the group."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "middleware", "line_number": 202, "body": "def middleware(self, *args, **kwargs):\n        \"\"\"\n        A decorator that can be used to implement a Middleware plugin to\n        all of the Blueprints that belongs to this specific Blueprint Group.\n\n        In case of nested Blueprint Groups, the same middleware is applied\n        across each of the Blueprints recursively.\n\n        :param args: Optional positional Parameters to be use middleware\n        :param kwargs: Optional Keyword arg to use with Middleware\n        :return: Partial function to apply the middleware\n        \"\"\"\n\n        def register_middleware_for_blueprints(fn):\n            for blueprint in self.blueprints:\n                blueprint.middleware(fn, *args, **kwargs)\n\n        if args and callable(args[0]):\n            fn = args[0]\n            args = list(args)[1:]\n            return register_middleware_for_blueprints(fn)\n        return register_middleware_for_blueprints", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Provides a decorator to apply a middleware function to all Blueprints within a BlueprintGroup, recursively including nested groups. This enables centralized middleware management across multiple related Blueprints."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "register_middleware_for_blueprints", "line_number": 215, "body": "def register_middleware_for_blueprints(fn):\n            for blueprint in self.blueprints:\n                blueprint.middleware(fn, *args, **kwargs)", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Registers a given middleware function across all blueprints in the BlueprintGroup, enabling consistent processing or handling of requests within multiple blueprint components."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/protocol_types.py", "function": "get_extra_info", "line_number": 23, "body": "def get_extra_info(self, info: str) -> Union[str, bool, None]:\n            ...", "is_method": true, "class_name": "TransportProtocol", "function_description": "Returns additional protocol-specific information identified by the given key, supporting transport-related metadata retrieval for enhanced connection handling or diagnostics."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/protocol_types.py", "function": "__html__", "line_number": 27, "body": "def __html__(self) -> AnyStr:\n            ...", "is_method": true, "class_name": "HTMLProtocol", "function_description": "Special method of HTMLProtocol that returns the HTML representation of an object, enabling integration with tools or frameworks that render content as HTML."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "pause_writing", "line_number": 22, "body": "def pause_writing(self) -> None:\n        self._not_paused.clear()", "is_method": true, "class_name": "MockProtocol", "function_description": "This method of MockProtocol changes the internal state to indicate that writing is paused. It provides control over the writing process flow within the protocol's operation."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "resume_writing", "line_number": 25, "body": "def resume_writing(self) -> None:\n        self._not_paused.set()", "is_method": true, "class_name": "MockProtocol", "function_description": "Resumes a paused writing process within the MockProtocol by clearing its paused state, allowing operations to continue. This is useful for controlling flow in simulated protocol interactions."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "is_complete", "line_number": 35, "body": "def is_complete(self) -> bool:\n        return self._complete.is_set()", "is_method": true, "class_name": "MockProtocol", "function_description": "Indicates whether the mock protocol process has finished by checking its completion status flag. This is useful for controlling flow based on process completion in testing or simulation scenarios."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "get_protocol", "line_number": 60, "body": "def get_protocol(self) -> MockProtocol:\n        if not self._protocol:\n            self._protocol = MockProtocol(self, self.loop)\n        return self._protocol", "is_method": true, "class_name": "MockTransport", "function_description": "Provides access to a MockProtocol instance associated with the transport, creating it if necessary, facilitating communication protocol handling within the MockTransport class."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "get_extra_info", "line_number": 65, "body": "def get_extra_info(self, info: str) -> Union[str, bool, None]:\n        if info == \"peername\":\n            return self.scope.get(\"client\")\n        elif info == \"sslcontext\":\n            return self.scope.get(\"scheme\") in [\"https\", \"wss\"]\n        return None", "is_method": true, "class_name": "MockTransport", "function_description": "Utility method of the MockTransport class that provides connection-related details like peer address or SSL presence based on the requested info type. It supports network context retrieval for testing or mocking transport behavior."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "get_websocket_connection", "line_number": 72, "body": "def get_websocket_connection(self) -> WebSocketConnection:\n        try:\n            return self._websocket_connection\n        except AttributeError:\n            raise InvalidUsage(\"Improper websocket connection.\")", "is_method": true, "class_name": "MockTransport", "function_description": "Returns the existing websocket connection managed by MockTransport, ensuring it is available and valid for communication purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "create_websocket_connection", "line_number": 78, "body": "def create_websocket_connection(\n        self, send: ASGISend, receive: ASGIReceive\n    ) -> WebSocketConnection:\n        self._websocket_connection = WebSocketConnection(\n            send, receive, self.scope.get(\"subprotocols\", [])\n        )\n        return self._websocket_connection", "is_method": true, "class_name": "MockTransport", "function_description": "Creates and returns a WebSocketConnection using provided ASGI send and receive callables, supporting specified subprotocols. This enables management of WebSocket communications within an ASGI application context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/middleware.py", "function": "middleware", "line_number": 14, "body": "def middleware(\n        self, middleware_or_request, attach_to=\"request\", apply=True\n    ):\n        \"\"\"\n        Decorate and register middleware to be called before a request.\n        Can either be called as *@app.middleware* or\n        *@app.middleware('request')*\n\n        `See user guide re: middleware\n        <https://sanicframework.org/guide/basics/middleware.html>`__\n\n        :param: middleware_or_request: Optional parameter to use for\n            identifying which type of middleware is being registered.\n        \"\"\"\n\n        def register_middleware(middleware, attach_to=\"request\"):\n            nonlocal apply\n\n            future_middleware = FutureMiddleware(middleware, attach_to)\n            self._future_middleware.append(future_middleware)\n            if apply:\n                self._apply_middleware(future_middleware)\n            return middleware\n\n        # Detect which way this was called, @middleware or @middleware('AT')\n        if callable(middleware_or_request):\n            return register_middleware(\n                middleware_or_request, attach_to=attach_to\n            )\n        else:\n            return partial(\n                register_middleware, attach_to=middleware_or_request\n            )", "is_method": true, "class_name": "MiddlewareMixin", "function_description": "Registers a middleware function to be invoked before processing a request, supporting flexible attachment points. It enables dynamic middleware decoration and management within the MiddlewareMixin class."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/middleware.py", "function": "on_request", "line_number": 48, "body": "def on_request(self, middleware=None):\n        if callable(middleware):\n            return self.middleware(middleware, \"request\")\n        else:\n            return partial(self.middleware, attach_to=\"request\")", "is_method": true, "class_name": "MiddlewareMixin", "function_description": "Utility method in MiddlewareMixin that attaches or prepares middleware functions to handle incoming requests, enabling flexible middleware integration in request-processing pipelines."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/middleware.py", "function": "on_response", "line_number": 54, "body": "def on_response(self, middleware=None):\n        if callable(middleware):\n            return self.middleware(middleware, \"response\")\n        else:\n            return partial(self.middleware, attach_to=\"response\")", "is_method": true, "class_name": "MiddlewareMixin", "function_description": "Utility method in MiddlewareMixin that attaches or configures a middleware function to be executed during the response phase of request processing. It supports both direct and deferred middleware binding for flexible middleware management."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/middleware.py", "function": "register_middleware", "line_number": 29, "body": "def register_middleware(middleware, attach_to=\"request\"):\n            nonlocal apply\n\n            future_middleware = FutureMiddleware(middleware, attach_to)\n            self._future_middleware.append(future_middleware)\n            if apply:\n                self._apply_middleware(future_middleware)\n            return middleware", "is_method": true, "class_name": "MiddlewareMixin", "function_description": "Utility method of MiddlewareMixin that registers middleware functions to be applied on requests or other events, enabling dynamic extension of processing behavior in a middleware pipeline."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "_generate_next_value_", "line_number": 9, "body": "def _generate_next_value_(name: str, *args) -> str:  # type: ignore\n        return name.lower()", "is_method": true, "class_name": "ListenerEvent", "function_description": "Generates the next enumeration value by converting the given name to lowercase. This method standardizes enum values to lowercase strings for consistent event naming."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "listener", "line_number": 27, "body": "def listener(\n        self,\n        listener_or_event: Union[\n            Callable[..., Coroutine[Any, Any, None]], str\n        ],\n        event_or_none: Optional[str] = None,\n        apply: bool = True,\n    ):\n        \"\"\"\n        Create a listener from a decorated function.\n\n        To be used as a deocrator:\n\n        .. code-block:: python\n\n            @bp.listener(\"before_server_start\")\n            async def before_server_start(app, loop):\n                ...\n\n        `See user guide re: listeners\n        <https://sanicframework.org/guide/basics/listeners.html#listeners>`__\n\n        :param event: event to listen to\n        \"\"\"\n\n        def register_listener(listener, event):\n            nonlocal apply\n\n            future_listener = FutureListener(listener, event)\n            self._future_listeners.append(future_listener)\n            if apply:\n                self._apply_listener(future_listener)\n            return listener\n\n        if callable(listener_or_event):\n            return register_listener(listener_or_event, event_or_none)\n        else:\n            return partial(register_listener, event=listener_or_event)", "is_method": true, "class_name": "ListenerMixin", "function_description": "Provides a decorator to register asynchronous event listeners, enabling automatic setup of callbacks for specified events within a class that manages event-driven behavior."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "main_process_start", "line_number": 66, "body": "def main_process_start(self, listener):\n        return self.listener(listener, \"main_process_start\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Core utility method of ListenerMixin that invokes a generic listener callback signaling the start of the main process, allowing other components to react or hook into this event."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "main_process_stop", "line_number": 69, "body": "def main_process_stop(self, listener):\n        return self.listener(listener, \"main_process_stop\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Utility method in ListenerMixin that triggers the listener with a \"main_process_stop\" event, facilitating coordinated shutdown or cleanup procedures in processes observing this event."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "before_server_start", "line_number": 72, "body": "def before_server_start(self, listener):\n        return self.listener(listener, \"before_server_start\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Utility method in ListenerMixin that invokes a specific listener event named \"before_server_start,\" facilitating hook-based customization before the server starts."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "after_server_start", "line_number": 75, "body": "def after_server_start(self, listener):\n        return self.listener(listener, \"after_server_start\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Utility method in ListenerMixin that invokes a specified listener event named \"after_server_start,\" enabling post-server-start actions or hooks to be triggered."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "before_server_stop", "line_number": 78, "body": "def before_server_stop(self, listener):\n        return self.listener(listener, \"before_server_stop\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Utility method in ListenerMixin that triggers the 'before_server_stop' event on a listener, allowing actions to be performed just before the server stops."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "after_server_stop", "line_number": 81, "body": "def after_server_stop(self, listener):\n        return self.listener(listener, \"after_server_stop\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Method in ListenerMixin that triggers a specified listener callback indicating the server has stopped, enabling post-shutdown event handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "register_listener", "line_number": 52, "body": "def register_listener(listener, event):\n            nonlocal apply\n\n            future_listener = FutureListener(listener, event)\n            self._future_listeners.append(future_listener)\n            if apply:\n                self._apply_listener(future_listener)\n            return listener", "is_method": true, "class_name": "ListenerMixin", "function_description": "Utility method of ListenerMixin that registers an event listener, optionally applying it immediately, and tracks it for future event handling. It enables dynamic binding of handlers to events within an asynchronous or event-driven system."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/signals.py", "function": "__hash__", "line_number": 9, "body": "def __hash__(self):\n        return hash(tuple(sorted(self.items())))", "is_method": true, "class_name": "HashableDict", "function_description": "Overrides the hash behavior to enable consistent hashing of a dictionary based on its sorted key-value pairs. This allows HashableDict instances to be used as hashable keys in sets or other dictionaries."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/signals.py", "function": "signal", "line_number": 20, "body": "def signal(\n        self,\n        event: str,\n        *,\n        apply: bool = True,\n        condition: Dict[str, Any] = None,\n    ) -> Callable[[SignalHandler], FutureSignal]:\n        \"\"\"\n        For creating a signal handler, used similar to a route handler:\n\n        .. code-block:: python\n\n            @app.signal(\"foo.bar.<thing>\")\n            async def signal_handler(thing, **kwargs):\n                print(f\"[signal_handler] {thing=}\", kwargs)\n\n        :param event: Representation of the event in ``one.two.three`` form\n        :type event: str\n        :param apply: For lazy evaluation, defaults to True\n        :type apply: bool, optional\n        :param condition: For use with the ``condition`` argument in dispatch\n            filtering, defaults to None\n        :type condition: Dict[str, Any], optional\n        \"\"\"\n\n        def decorator(handler: SignalHandler):\n            nonlocal event\n            nonlocal apply\n\n            future_signal = FutureSignal(\n                handler, event, HashableDict(condition or {})\n            )\n            self._future_signals.add(future_signal)\n\n            if apply:\n                self._apply_signal(future_signal)\n\n            return future_signal\n\n        return decorator", "is_method": true, "class_name": "SignalMixin", "function_description": "Provides a decorator to register asynchronous signal handlers for specific event patterns, optionally using lazy evaluation and conditional dispatch filtering. Enables modular, event-driven extensions within classes using SignalMixin."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/signals.py", "function": "add_signal", "line_number": 61, "body": "def add_signal(\n        self,\n        handler,\n        event: str,\n        condition: Dict[str, Any] = None,\n    ):\n        self.signal(event=event, condition=condition)(handler)\n        return handler", "is_method": true, "class_name": "SignalMixin", "function_description": "Utility method in SignalMixin that registers an event handler with an optional condition, enabling conditional signal processing for specified event types."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/signals.py", "function": "decorator", "line_number": 45, "body": "def decorator(handler: SignalHandler):\n            nonlocal event\n            nonlocal apply\n\n            future_signal = FutureSignal(\n                handler, event, HashableDict(condition or {})\n            )\n            self._future_signals.add(future_signal)\n\n            if apply:\n                self._apply_signal(future_signal)\n\n            return future_signal", "is_method": true, "class_name": "SignalMixin", "function_description": "Core method in SignalMixin that registers a signal handler with optional conditions, optionally applying it immediately, and returns a future signal representing the deferred or active signal subscription."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/exceptions.py", "function": "exception", "line_number": 13, "body": "def exception(self, *exceptions, apply=True):\n        \"\"\"\n        This method enables the process of creating a global exception\n        handler for the current blueprint under question.\n\n        :param args: List of Python exceptions to be caught by the handler\n        :param kwargs: Additional optional arguments to be passed to the\n            exception handler\n\n        :return a decorated method to handle global exceptions for any\n            route registered under this blueprint.\n        \"\"\"\n\n        def decorator(handler):\n            nonlocal apply\n            nonlocal exceptions\n\n            if isinstance(exceptions[0], list):\n                exceptions = tuple(*exceptions)\n\n            future_exception = FutureException(handler, exceptions)\n            self._future_exceptions.add(future_exception)\n            if apply:\n                self._apply_exception_handler(future_exception)\n            return handler\n\n        return decorator", "is_method": true, "class_name": "ExceptionMixin", "function_description": "Creates a decorator to register a global exception handler for specified exceptions within a blueprint, applying it automatically if desired. This supports centralized error handling for all routes under that blueprint."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "route", "line_number": 41, "body": "def route(\n        self,\n        uri: str,\n        methods: Optional[Iterable[str]] = None,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        stream: bool = False,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = False,\n        apply: bool = True,\n        subprotocols: Optional[List[str]] = None,\n        websocket: bool = False,\n        unquote: bool = False,\n        static: bool = False,\n    ):\n        \"\"\"\n        Decorate a function to be registered as a route\n\n        :param uri: path of the URL\n        :param methods: list or tuple of methods allowed\n        :param host: the host, if required\n        :param strict_slashes: whether to apply strict slashes to the route\n        :param stream: whether to allow the request to stream its body\n        :param version: route specific versioning\n        :param name: user defined route name for url_for\n        :param ignore_body: whether the handler should ignore request\n            body (eg. GET requests)\n        :return: tuple of routes, decorated function\n        \"\"\"\n\n        # Fix case where the user did not prefix the URL with a /\n        # and will probably get confused as to why it's not working\n        if not uri.startswith(\"/\") and (uri or hasattr(self, \"router\")):\n            uri = \"/\" + uri\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        if not methods and not websocket:\n            methods = frozenset({\"GET\"})\n\n        def decorator(handler):\n            nonlocal uri\n            nonlocal methods\n            nonlocal host\n            nonlocal strict_slashes\n            nonlocal stream\n            nonlocal version\n            nonlocal name\n            nonlocal ignore_body\n            nonlocal subprotocols\n            nonlocal websocket\n            nonlocal static\n\n            if isinstance(handler, tuple):\n                # if a handler fn is already wrapped in a route, the handler\n                # variable will be a tuple of (existing routes, handler fn)\n                _, handler = handler\n\n            name = self._generate_name(name, handler)\n\n            if isinstance(host, str):\n                host = frozenset([host])\n            elif host and not isinstance(host, frozenset):\n                try:\n                    host = frozenset(host)\n                except TypeError:\n                    raise ValueError(\n                        \"Expected either string or Iterable of host strings, \"\n                        \"not %s\" % host\n                    )\n\n            if isinstance(subprotocols, (list, tuple, set)):\n                subprotocols = frozenset(subprotocols)\n\n            route = FutureRoute(\n                handler,\n                uri,\n                None if websocket else frozenset([x.upper() for x in methods]),\n                host,\n                strict_slashes,\n                stream,\n                version,\n                name,\n                ignore_body,\n                websocket,\n                subprotocols,\n                unquote,\n                static,\n            )\n\n            self._future_routes.add(route)\n\n            args = list(signature(handler).parameters.keys())\n            if websocket and len(args) < 2:\n                handler_name = handler.__name__\n\n                raise ValueError(\n                    f\"Required parameter `request` and/or `ws` missing \"\n                    f\"in the {handler_name}() route?\"\n                )\n            elif not args:\n                handler_name = handler.__name__\n\n                raise ValueError(\n                    f\"Required parameter `request` missing \"\n                    f\"in the {handler_name}() route?\"\n                )\n\n            if not websocket and stream:\n                handler.is_stream = stream\n\n            if apply:\n                self._apply_route(route)\n\n            return route, handler\n\n        return decorator", "is_method": true, "class_name": "RouteMixin", "function_description": "Utility method in RouteMixin that provides a decorator to register functions as HTTP or WebSocket routes with customizable URL patterns, methods, and behavior, facilitating web request handling and routing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "add_route", "line_number": 161, "body": "def add_route(\n        self,\n        handler,\n        uri: str,\n        methods: Iterable[str] = frozenset({\"GET\"}),\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        stream: bool = False,\n    ):\n        \"\"\"A helper method to register class instance or\n        functions as a handler to the application url\n        routes.\n\n        :param handler: function or class instance\n        :param uri: path of the URL\n        :param methods: list or tuple of methods allowed, these are overridden\n                        if using a HTTPMethodView\n        :param host:\n        :param strict_slashes:\n        :param version:\n        :param name: user defined route name for url_for\n        :param stream: boolean specifying if the handler is a stream handler\n        :return: function or class instance\n        \"\"\"\n        # Handle HTTPMethodView differently\n        if hasattr(handler, \"view_class\"):\n            methods = set()\n\n            for method in HTTP_METHODS:\n                _handler = getattr(handler.view_class, method.lower(), None)\n                if _handler:\n                    methods.add(method)\n                    if hasattr(_handler, \"is_stream\"):\n                        stream = True\n\n        # handle composition view differently\n        if isinstance(handler, CompositionView):\n            methods = handler.handlers.keys()\n            for _handler in handler.handlers.values():\n                if hasattr(_handler, \"is_stream\"):\n                    stream = True\n                    break\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        self.route(\n            uri=uri,\n            methods=methods,\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )(handler)\n        return handler", "is_method": true, "class_name": "RouteMixin", "function_description": "Utility method in RouteMixin that registers a handler to a URL route with specified HTTP methods and options, supporting class-based, function, and streaming handlers for flexible web request routing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "get", "line_number": 221, "body": "def get(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = True,\n    ):\n        \"\"\"\n        Add an API URL under the **GET** *HTTP* method\n\n        :param uri: URL to be tagged to **GET** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"GET\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            ignore_body=ignore_body,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Utility method of the RouteMixin class that registers a URL route for handling HTTP GET requests with optional host, versioning, and routing behavior parameters. It simplifies defining GET endpoints in web applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "post", "line_number": 251, "body": "def post(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        stream: bool = False,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n    ):\n        \"\"\"\n        Add an API URL under the **POST** *HTTP* method\n\n        :param uri: URL to be tagged to **POST** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"POST\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Provides a convenient way to register a URL route that handles HTTP POST requests with optional host, versioning, and routing parameters within a web application framework."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "put", "line_number": 281, "body": "def put(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        stream: bool = False,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n    ):\n        \"\"\"\n        Add an API URL under the **PUT** *HTTP* method\n\n        :param uri: URL to be tagged to **PUT** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PUT\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Provides a means to register an API endpoint for HTTP PUT requests with optional routing parameters like host, version, and naming, enabling structured route definition within the RouteMixin class."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "head", "line_number": 311, "body": "def head(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = True,\n    ):\n        \"\"\"\n        Add an API URL under the **HEAD** *HTTP* method\n\n        :param uri: URL to be tagged to **HEAD** method of *HTTP*\n        :type uri: str\n        :param host: Host IP or FQDN for the service to use\n        :type host: Optional[str], optional\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :type strict_slashes: Optional[bool], optional\n        :param version: API Version\n        :type version: Optional[str], optional\n        :param name: Unique name that can be used to identify the Route\n        :type name: Optional[str], optional\n        :param ignore_body: whether the handler should ignore request\n            body (eg. GET requests), defaults to True\n        :type ignore_body: bool, optional\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"HEAD\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            ignore_body=ignore_body,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Provides a decorator method to register an HTTP HEAD route with specified URI and optional parameters, enabling API endpoint definition for checking resource headers without a message body."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "options", "line_number": 349, "body": "def options(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = True,\n    ):\n        \"\"\"\n        Add an API URL under the **OPTIONS** *HTTP* method\n\n        :param uri: URL to be tagged to **OPTIONS** method of *HTTP*\n        :type uri: str\n        :param host: Host IP or FQDN for the service to use\n        :type host: Optional[str], optional\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :type strict_slashes: Optional[bool], optional\n        :param version: API Version\n        :type version: Optional[str], optional\n        :param name: Unique name that can be used to identify the Route\n        :type name: Optional[str], optional\n        :param ignore_body: whether the handler should ignore request\n            body (eg. GET requests), defaults to True\n        :type ignore_body: bool, optional\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"OPTIONS\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            ignore_body=ignore_body,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Provides a convenient way to register an API endpoint that handles HTTP OPTIONS requests with customizable routing parameters like URI, host, and version. This supports defining OPTIONS routes for CORS and preflight request handling in a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "patch", "line_number": 387, "body": "def patch(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        stream=False,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n    ):\n        \"\"\"\n        Add an API URL under the **PATCH** *HTTP* method\n\n        :param uri: URL to be tagged to **PATCH** method of *HTTP*\n        :type uri: str\n        :param host: Host IP or FQDN for the service to use\n        :type host: Optional[str], optional\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :type strict_slashes: Optional[bool], optional\n        :param stream: whether to allow the request to stream its body\n        :type stream: Optional[bool], optional\n        :param version: API Version\n        :type version: Optional[str], optional\n        :param name: Unique name that can be used to identify the Route\n        :type name: Optional[str], optional\n        :param ignore_body: whether the handler should ignore request\n            body (eg. GET requests), defaults to True\n        :type ignore_body: bool, optional\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PATCH\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Defines a route with the HTTP PATCH method for the API, allowing configuration of URL, host, versioning, and other request handling options within the RouteMixin class. It streamlines adding PATCH endpoints to a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "delete", "line_number": 427, "body": "def delete(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = True,\n    ):\n        \"\"\"\n        Add an API URL under the **DELETE** *HTTP* method\n\n        :param uri: URL to be tagged to **DELETE** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"DELETE\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            ignore_body=ignore_body,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers a URL route that handles HTTP DELETE requests with optional host, versioning, and strict slash matching to define API endpoints in web applications. This enables easy setup of DELETE method routes in the RouteMixin context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "websocket", "line_number": 457, "body": "def websocket(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        subprotocols: Optional[List[str]] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        apply: bool = True,\n    ):\n        \"\"\"\n        Decorate a function to be registered as a websocket route\n\n        :param uri: path of the URL\n        :param host: Host IP or FQDN details\n        :param strict_slashes: If the API endpoint needs to terminate\n                               with a \"/\" or not\n        :param subprotocols: optional list of str with supported subprotocols\n        :param name: A unique name assigned to the URL so that it can\n                     be used with :func:`url_for`\n        :return: tuple of routes, decorated function\n        \"\"\"\n        return self.route(\n            uri=uri,\n            host=host,\n            methods=None,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            apply=apply,\n            subprotocols=subprotocols,\n            websocket=True,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Provides a decorator to register a function as a websocket route with optional configuration like URI, host, subprotocols, and naming, facilitating websocket endpoint setup in a web routing system."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "add_websocket_route", "line_number": 491, "body": "def add_websocket_route(\n        self,\n        handler,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        subprotocols=None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n    ):\n        \"\"\"\n        A helper method to register a function as a websocket route.\n\n        :param handler: a callable function or instance of a class\n                        that can handle the websocket request\n        :param host: Host IP or FQDN details\n        :param uri: URL path that will be mapped to the websocket\n                    handler\n                    handler\n        :param strict_slashes: If the API endpoint needs to terminate\n                with a \"/\" or not\n        :param subprotocols: Subprotocols to be used with websocket\n                handshake\n        :param name: A unique name assigned to the URL so that it can\n                be used with :func:`url_for`\n        :return: Objected decorated by :func:`websocket`\n        \"\"\"\n        return self.websocket(\n            uri=uri,\n            host=host,\n            strict_slashes=strict_slashes,\n            subprotocols=subprotocols,\n            version=version,\n            name=name,\n        )(handler)", "is_method": true, "class_name": "RouteMixin", "function_description": "Adds and registers a callable as a websocket route handler with optional URI, host, and protocol settings, enabling websocket connection management within a routing context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "static", "line_number": 527, "body": "def static(\n        self,\n        uri,\n        file_or_directory: Union[str, bytes, PurePath],\n        pattern=r\"/?.+\",\n        use_modified_since=True,\n        use_content_range=False,\n        stream_large_files=False,\n        name=\"static\",\n        host=None,\n        strict_slashes=None,\n        content_type=None,\n        apply=True,\n    ):\n        \"\"\"\n        Register a root to serve files from. The input can either be a\n        file or a directory. This method will enable an easy and simple way\n        to setup the :class:`Route` necessary to serve the static files.\n\n        :param uri: URL path to be used for serving static content\n        :param file_or_directory: Path for the Static file/directory with\n            static files\n        :param pattern: Regex Pattern identifying the valid static files\n        :param use_modified_since: If true, send file modified time, and return\n            not modified if the browser's matches the server's\n        :param use_content_range: If true, process header for range requests\n            and sends the file part that is requested\n        :param stream_large_files: If true, use the\n            :func:`StreamingHTTPResponse.file_stream` handler rather\n            than the :func:`HTTPResponse.file` handler to send the file.\n            If this is an integer, this represents the threshold size to\n            switch to :func:`StreamingHTTPResponse.file_stream`\n        :param name: user defined name used for url_for\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param content_type: user defined content type for header\n        :return: routes registered on the router\n        :rtype: List[sanic.router.Route]\n        \"\"\"\n\n        name = self._generate_name(name)\n\n        if strict_slashes is None and self.strict_slashes is not None:\n            strict_slashes = self.strict_slashes\n\n        if not isinstance(file_or_directory, (str, bytes, PurePath)):\n            raise ValueError(\n                f\"Static route must be a valid path, not {file_or_directory}\"\n            )\n\n        static = FutureStatic(\n            uri,\n            file_or_directory,\n            pattern,\n            use_modified_since,\n            use_content_range,\n            stream_large_files,\n            name,\n            host,\n            strict_slashes,\n            content_type,\n        )\n        self._future_statics.add(static)\n\n        if apply:\n            self._apply_static(static)", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers a static file or directory route to serve static content via the specified URL path, supporting caching, range requests, and streaming options. It simplifies static file serving setup within a web routing context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "_generate_name", "line_number": 595, "body": "def _generate_name(self, *objects) -> str:\n        name = None\n\n        for obj in objects:\n            if obj:\n                if isinstance(obj, str):\n                    name = obj\n                    break\n\n                try:\n                    name = obj.name\n                except AttributeError:\n                    try:\n                        name = obj.__name__\n                    except AttributeError:\n                        continue\n                else:\n                    break\n\n        if not name:  # noqa\n            raise ValueError(\"Could not generate a name for handler\")\n\n        if not name.startswith(f\"{self.name}.\"):\n            name = f\"{self.name}.{name}\"\n\n        return name", "is_method": true, "class_name": "RouteMixin", "function_description": "Generates a qualified name string for handler objects by extracting their name attributes or identifiers, prefixing it with the instance's name for consistent naming in routing or dispatch contexts."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "_register_static", "line_number": 732, "body": "def _register_static(\n        self,\n        static: FutureStatic,\n    ):\n        # TODO: Though sanic is not a file server, I feel like we should\n        # at least make a good effort here.  Modified-since is nice, but\n        # we could also look into etags, expires, and caching\n        \"\"\"\n        Register a static directory handler with Sanic by adding a route to the\n        router and registering a handler.\n\n        :param app: Sanic\n        :param file_or_directory: File or directory path to serve from\n        :type file_or_directory: Union[str,bytes,Path]\n        :param uri: URL to serve from\n        :type uri: str\n        :param pattern: regular expression used to match files in the URL\n        :param use_modified_since: If true, send file modified time, and return\n                                not modified if the browser's matches the\n                                server's\n        :param use_content_range: If true, process header for range requests\n                                and sends the file part that is requested\n        :param stream_large_files: If true, use the file_stream() handler\n                                rather than the file() handler to send the file\n                                If this is an integer, this represents the\n                                threshold size to switch to file_stream()\n        :param name: user defined name used for url_for\n        :type name: str\n        :param content_type: user defined content type for header\n        :return: registered static routes\n        :rtype: List[sanic.router.Route]\n        \"\"\"\n\n        if isinstance(static.file_or_directory, bytes):\n            file_or_directory = static.file_or_directory.decode(\"utf-8\")\n        elif isinstance(static.file_or_directory, PurePath):\n            file_or_directory = str(static.file_or_directory)\n        elif not isinstance(static.file_or_directory, str):\n            raise ValueError(\"Invalid file path string.\")\n        else:\n            file_or_directory = static.file_or_directory\n\n        uri = static.uri\n        name = static.name\n        # If we're not trying to match a file directly,\n        # serve from the folder\n        if not path.isfile(file_or_directory):\n            uri += \"/<__file_uri__:path>\"\n\n        # special prefix for static files\n        # if not static.name.startswith(\"_static_\"):\n        #     name = f\"_static_{static.name}\"\n\n        _handler = wraps(self._static_request_handler)(\n            partial(\n                self._static_request_handler,\n                file_or_directory,\n                static.use_modified_since,\n                static.use_content_range,\n                static.stream_large_files,\n                content_type=static.content_type,\n            )\n        )\n\n        route, _ = self.route(\n            uri=uri,\n            methods=[\"GET\", \"HEAD\"],\n            name=name,\n            host=static.host,\n            strict_slashes=static.strict_slashes,\n            static=True,\n        )(_handler)\n\n        return route", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers a static file or directory route in a Sanic web app, enabling efficient serving of static content with optional HTTP features like modified-since checks and range requests."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "decorator", "line_number": 83, "body": "def decorator(handler):\n            nonlocal uri\n            nonlocal methods\n            nonlocal host\n            nonlocal strict_slashes\n            nonlocal stream\n            nonlocal version\n            nonlocal name\n            nonlocal ignore_body\n            nonlocal subprotocols\n            nonlocal websocket\n            nonlocal static\n\n            if isinstance(handler, tuple):\n                # if a handler fn is already wrapped in a route, the handler\n                # variable will be a tuple of (existing routes, handler fn)\n                _, handler = handler\n\n            name = self._generate_name(name, handler)\n\n            if isinstance(host, str):\n                host = frozenset([host])\n            elif host and not isinstance(host, frozenset):\n                try:\n                    host = frozenset(host)\n                except TypeError:\n                    raise ValueError(\n                        \"Expected either string or Iterable of host strings, \"\n                        \"not %s\" % host\n                    )\n\n            if isinstance(subprotocols, (list, tuple, set)):\n                subprotocols = frozenset(subprotocols)\n\n            route = FutureRoute(\n                handler,\n                uri,\n                None if websocket else frozenset([x.upper() for x in methods]),\n                host,\n                strict_slashes,\n                stream,\n                version,\n                name,\n                ignore_body,\n                websocket,\n                subprotocols,\n                unquote,\n                static,\n            )\n\n            self._future_routes.add(route)\n\n            args = list(signature(handler).parameters.keys())\n            if websocket and len(args) < 2:\n                handler_name = handler.__name__\n\n                raise ValueError(\n                    f\"Required parameter `request` and/or `ws` missing \"\n                    f\"in the {handler_name}() route?\"\n                )\n            elif not args:\n                handler_name = handler.__name__\n\n                raise ValueError(\n                    f\"Required parameter `request` missing \"\n                    f\"in the {handler_name}() route?\"\n                )\n\n            if not websocket and stream:\n                handler.is_stream = stream\n\n            if apply:\n                self._apply_route(route)\n\n            return route, handler", "is_method": true, "class_name": "RouteMixin", "function_description": "Provides a decorator to register a request handler as a route with specified HTTP parameters, managing route properties, validation, and integration into the routing system. It supports web, websocket, and streaming handlers with configurable matching criteria."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/redirect_example.py", "function": "handle_request", "line_number": 8, "body": "def handle_request(request):\n    return response.redirect('/redirect')", "is_method": false, "function_description": "The function simply redirects any incoming request to a fixed URL path '/redirect'. It serves as a basic HTTP request handler for redirecting clients to a specific location."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/raygun_example.py", "function": "default", "line_number": 19, "body": "def default(self, request, exception):\n        self.sender.send_exception(exception=exception)\n        return super().default(request, exception)", "is_method": true, "class_name": "RaygunExceptionReporter", "function_description": "Handles exceptions by reporting them through a sender before proceeding with the default exception processing flow. This method integrates exception reporting seamlessly into the error handling pipeline."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/request_timeout.py", "function": "timeout", "line_number": 18, "body": "def timeout(request, exception):\n    return response.text('RequestTimeout from error_handler.', 408)", "is_method": false, "function_description": "Returns an HTTP 408 Request Timeout response with a fixed message when a timeout exception occurs during a request. This function provides a standardized error response for timeout events in a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/logdna_example.py", "function": "get_my_ip_address", "line_number": 17, "body": "def get_my_ip_address(remote_server=\"google.com\"):\n    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:\n        s.connect((remote_server, 80))\n        return s.getsockname()[0]", "is_method": false, "function_description": "Function that determines the local machine\u2019s IP address by connecting to a specified remote server. Useful for identifying the outbound IP address used for network communication."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/logdna_example.py", "function": "get_mac_address", "line_number": 23, "body": "def get_mac_address():\n    h = iter(hex(get_mac())[2:].zfill(12))\n    return \":\".join(i + next(h) for i in h)", "is_method": false, "function_description": "Function that retrieves the device's MAC address and returns it as a colon-separated hexadecimal string commonly used for network hardware identification."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/logdna_example.py", "function": "log_request", "line_number": 46, "body": "def log_request(request: Request):\n    logdna.info(\"I was Here with a new Request to URL: {}\".format(request.url))", "is_method": false, "function_description": "Utility function that logs incoming request URLs for monitoring or debugging purposes. It helps track and record access to web service endpoints."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/logdna_example.py", "function": "default", "line_number": 51, "body": "def default(request):\n    return json({\n        \"response\": \"I was here\"\n    })", "is_method": false, "function_description": "Simple handler function that returns a fixed JSON response indicating presence, useful as a basic endpoint or test response in web applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/override_logging.py", "function": "test", "line_number": 18, "body": "def test(request):\n    log.info(\"received request; responding with 'hey'\")\n    return text(\"hey\")", "is_method": false, "function_description": "Returns a simple textual response \"hey\" upon receiving a request, primarily serving as a basic test or placeholder endpoint for request handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/simple_async_view.py", "function": "get", "line_number": 10, "body": "def get(self, request):\n        return text('I am get method')", "is_method": true, "class_name": "SimpleView", "function_description": "Handles GET requests by returning a simple text response indicating the method type, serving as a basic HTTP GET handler in a web view context."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/simple_async_view.py", "function": "post", "line_number": 13, "body": "def post(self, request):\n        return text('I am post method')", "is_method": true, "class_name": "SimpleView", "function_description": "Handles HTTP POST requests by returning a simple text response, serving as a basic example or placeholder method in a web view context."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/simple_async_view.py", "function": "put", "line_number": 16, "body": "def put(self, request):\n        return text('I am put method')", "is_method": true, "class_name": "SimpleView", "function_description": "SimpleView class method that responds to PUT HTTP requests with a fixed text message, primarily serving as a placeholder or basic response handler."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/simple_async_view.py", "function": "patch", "line_number": 19, "body": "def patch(self, request):\n        return text('I am patch method')", "is_method": true, "class_name": "SimpleView", "function_description": "Handles HTTP PATCH requests by returning a fixed text response, providing a simple placeholder service within the SimpleView class."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/simple_async_view.py", "function": "delete", "line_number": 22, "body": "def delete(self, request):\n        return text('I am delete method')", "is_method": true, "class_name": "SimpleView", "function_description": "Returns a simple text response indicating that the delete method was called. This placeholder can be used for handling delete requests in a SimpleView context."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/blueprint_middlware_execution_order.py", "function": "pop_handler", "line_number": 38, "body": "def pop_handler(request):\n    return text('hello world')", "is_method": false, "function_description": "Returns a simple text response saying \"hello world\" to a given request. This function can be used as a basic handler in a web or API context for testing or placeholder purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/modify_header_example.py", "function": "handle_request", "line_number": 12, "body": "def handle_request(request):\n    return response.json(\n        {'message': 'Hello world!'},\n        headers={'X-Served-By': 'sanic'},\n        status=200\n    )", "is_method": false, "function_description": "Utility function that handles an incoming request by returning a JSON response with a greeting message and custom headers, serving as a simple HTTP response handler."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/modify_header_example.py", "function": "handle_request", "line_number": 21, "body": "def handle_request(request):\n    return response.json(\n        {'message': 'You are not authorized'},\n        headers={'X-Served-By': 'sanic'},\n        status=404\n    )", "is_method": false, "function_description": "Returns a 404 JSON response indicating unauthorized access, including a custom header. It serves as a simple HTTP error handler for unauthorized requests."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/authorized_sanic.py", "function": "check_request_for_authorization_status", "line_number": 10, "body": "def check_request_for_authorization_status(request):\n    # Note: Define your check, for instance cookie, session.\n    flag = True\n    return flag", "is_method": false, "function_description": "Returns a boolean indicating whether a request meets authorization criteria, serving as a basic placeholder for access control checks in request handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/authorized_sanic.py", "function": "authorized", "line_number": 16, "body": "def authorized(f):\n    @wraps(f)\n    async def decorated_function(request, *args, **kwargs):\n        # run some method that checks the request\n        # for the client's authorization status\n        is_authorized = check_request_for_authorization_status(request)\n\n        if is_authorized:\n            # the user is authorized.\n            # run the handler method and return the response\n            response = await f(request, *args, **kwargs)\n            return response\n        else:\n            # the user is not authorized.\n            return json({'status': 'not_authorized'}, 403)\n    return decorated_function", "is_method": false, "function_description": "Decorator that checks a client's authorization status before executing an asynchronous request handler, returning a 403 response if unauthorized. It ensures access control for protected API endpoints or web resources."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/run_asgi.py", "function": "handler_text", "line_number": 18, "body": "def handler_text(request):\n    return response.text(\"Hello\")", "is_method": false, "function_description": "Simple request handler that returns a plain text greeting response, useful as a basic endpoint to confirm service availability or for testing purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/run_asgi.py", "function": "handler_json", "line_number": 23, "body": "def handler_json(request):\n    return response.json({\"foo\": \"bar\"})", "is_method": false, "function_description": "This function handles an incoming request and responds with a static JSON object containing {\"foo\": \"bar\"}. It serves as a basic API endpoint returning fixed JSON data."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/rollbar_example.py", "function": "default", "line_number": 13, "body": "def default(self, request, exception):\n        rollbar.report_message(str(exception))\n        return super().default(request, exception)", "is_method": true, "class_name": "RollbarExceptionHandler", "function_description": "Handles exceptions by reporting them to Rollbar and then delegating to the standard exception handler for further processing. It enables centralized error tracking and logging in applications using Rollbar."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "test_sync", "line_number": 17, "body": "def test_sync(request):\n    return response.json({\"test\": True})", "is_method": false, "function_description": "Returns a JSON response confirming the sync test status as successful. This function serves as a simple endpoint to verify connectivity or service availability."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "test_params", "line_number": 22, "body": "def test_params(request, name, i):\n    return response.text(\"yeehaww {} {}\".format(name, i))", "is_method": false, "function_description": "Returns a simple text response combining a name and an index, typically used for testing parameter passing in request handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "post_json", "line_number": 64, "body": "def post_json(request):\n    return response.json({\"received\": True, \"message\": request.json})", "is_method": false, "function_description": "Function that processes a JSON HTTP request and responds with a JSON object confirming receipt along with the original message content. Useful for handling and acknowledging JSON-based client-server communication."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "post_form_json", "line_number": 69, "body": "def post_form_json(request):\n    return response.json({\"received\": True, \"form_data\": request.form, \"test\": request.form.get('test')})", "is_method": false, "function_description": "Function that processes a web request's form data and returns a JSON response confirming receipt along with the submitted form content and a specific 'test' field value. It facilitates handling and responding to form submissions in web applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "query_string", "line_number": 74, "body": "def query_string(request):\n    return response.json({\"parsed\": True, \"args\": request.args, \"url\": request.url,\n                          \"query_string\": request.query_string})", "is_method": false, "function_description": "Function that processes a web request to extract and return its URL, query string, and arguments in a standardized JSON response format for further use in request handling or debugging."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "before_stop", "line_number": 94, "body": "def before_stop(app, loop):\n    log.info(\"SERVER STOPPING\")", "is_method": false, "function_description": "Logs a message indicating the server is stopping, useful for tracking application shutdown events."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/exception_monitoring.py", "function": "default", "line_number": 20, "body": "def default(self, request, exception):\n        # Here, we have access to the exception object\n        # and can do anything with it (log, send to external service, etc)\n\n        # Some exceptions are trivial and built into Sanic (404s, etc)\n        if not isinstance(exception, SanicException):\n            print(exception)\n\n        # Then, we must finish handling the exception by returning\n        # our response to the client\n        # For this we can just call the super class' default handler\n        return super().default(request, exception)", "is_method": true, "class_name": "CustomHandler", "function_description": "CustomHandler method that processes exceptions by optionally logging non-trivial errors before delegating response generation to the parent handler, providing customizable error handling in web request processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/pytest_xdist.py", "function": "test_port", "line_number": 23, "body": "def test_port(worker_id):\n    m = re.search(r\"[0-9]+\", worker_id)\n    if m:\n        num_id = m.group(0)\n    else:\n        num_id = 0\n    port = PORT_BASE + int(num_id)\n    return port", "is_method": false, "function_description": "Function that extracts a numeric ID from a worker identifier and computes a corresponding port number by adding it to a base port value. Useful for dynamically assigning ports based on worker IDs."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/pytest_xdist.py", "function": "app", "line_number": 34, "body": "def app():\n    app = Sanic()\n\n    @app.route(\"/\")\n    async def index(request):\n        return text(\"OK\")\n\n    return app", "is_method": false, "function_description": "Creates and configures a basic Sanic web application with a root endpoint that returns a simple \"OK\" text response. Useful for quickly setting up a minimal web server for health checks or basic testing."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/pytest_xdist.py", "function": "client", "line_number": 45, "body": "def client(app, test_port):\n    return SanicTestClient(app, test_port)", "is_method": false, "function_description": "Utility function that creates and returns a test client for a Sanic application, enabling HTTP request simulation on a specified test port for application testing purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/pytest_xdist.py", "function": "test_index", "line_number": 50, "body": "def test_index(client, run_id):\n    request, response = client._sanic_endpoint_test(\"get\", \"/\")\n    assert response.status == 200\n    assert response.text == \"OK\"", "is_method": false, "function_description": "This function tests the root endpoint of a web service client by verifying that it responds with a 200 status and the text \"OK\". It is useful for validating that the service is up and running correctly."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/log_request_id.py", "function": "setup", "line_number": 70, "body": "def setup(app, loop):\n    loop.set_task_factory(context.task_factory)", "is_method": false, "function_description": "Assigns a custom task factory to the event loop for managing asynchronous task creation within the application. This setup function configures task handling behavior for asynchronous execution environments."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/log_request_id.py", "function": "filter", "line_number": 12, "body": "def filter(self, record):\n        try:\n            record.request_id = context.get(\"X-Request-ID\")\n        except ValueError:\n            record.request_id = \"n/a\"\n        return True", "is_method": true, "class_name": "RequestIdFilter", "function_description": "Adds a request ID from the context to a log record, tagging logs with request identifiers for tracing; defaults to \"n/a\" if unavailable."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/http_redirect.py", "function": "bar", "line_number": 19, "body": "def bar(request):\n    return text(\"bar\")", "is_method": false, "function_description": "Returns a simple text response containing the string \"bar\"."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/http_redirect.py", "function": "proxy", "line_number": 24, "body": "def proxy(request, path):\n    url = request.app.url_for(\n        \"proxy\",\n        path=path,\n        _server=https.config.SERVER_NAME,\n        _external=True,\n        _scheme=\"http\",\n    )\n    return response.redirect(url)", "is_method": false, "function_description": "This function generates and redirects to a full external URL based on a given path and server configuration, enabling proxying of requests through the application."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/amending_request_object.py", "function": "append_request", "line_number": 9, "body": "def append_request(request):\n    # Add new key with random value\n    request['num'] = randint(0, 100)", "is_method": false, "function_description": "Adds a random integer between 0 and 100 to the given request dictionary under the key 'num'. This function modifies the request by appending a new numeric value."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/amending_request_object.py", "function": "pop_handler", "line_number": 15, "body": "def pop_handler(request):\n    # Pop key from request object\n    num = request.pop('num')\n    return text(num)", "is_method": false, "function_description": "This function extracts and removes the 'num' key from a request object, then processes its value through a text transformation. It provides a way to handle and convert specific request data for further use."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/amending_request_object.py", "function": "key_exist_handler", "line_number": 22, "body": "def key_exist_handler(request):\n    # Check the key is exist or not\n    if 'num' in request:\n        return text('num exist in request')\n\n    return text('num does not exist in reqeust')", "is_method": false, "function_description": "Function that checks whether the key 'num' is present in a request and returns a corresponding confirmation message. It provides a simple utility to verify request contents for conditional processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/limit_concurrency.py", "function": "init", "line_number": 13, "body": "def init(sanic, loop):\n    global sem\n    concurrency_per_worker = 4\n    sem = asyncio.Semaphore(concurrency_per_worker, loop=loop)", "is_method": false, "function_description": "Initializes a global semaphore to limit concurrent asynchronous operations in the application, controlling parallelism for resource management."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_run_shell_command", "line_number": 73, "body": "def _run_shell_command(command: list):\n    try:\n        process = Popen(\n            command, stderr=PIPE, stdout=PIPE, stdin=PIPE, shell=True\n        )\n        output, error = process.communicate()\n        return_code = process.returncode\n        return output.decode(\"utf-8\"), error, return_code\n    except:\n        return None, None, -1", "is_method": false, "function_description": "Function that executes a shell command from a list of arguments and returns its output, error message, and exit code. Useful for running external programs and capturing their results within Python."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_fetch_default_calendar_release_version", "line_number": 85, "body": "def _fetch_default_calendar_release_version():\n    return datetime.now().strftime(\"%y.%m.0\")", "is_method": false, "function_description": "Generates a default calendar release version string based on the current date in \"YY.MM.0\" format. This function standardizes versioning for calendar-related releases."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_fetch_current_version", "line_number": 89, "body": "def _fetch_current_version(config_file: str) -> str:\n    if path.isfile(config_file):\n        config_parser = RawConfigParser()\n        with open(config_file) as cfg:\n            config_parser.read_file(cfg)\n            return (\n                config_parser.get(\"version\", \"current_version\")\n                or _fetch_default_calendar_release_version()\n            )\n    else:\n        return _fetch_default_calendar_release_version()", "is_method": false, "function_description": "Utility function that obtains the current version string from a configuration file, falling back to a default calendar release version if the file or version entry is unavailable."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_change_micro_version", "line_number": 102, "body": "def _change_micro_version(current_version: str):\n    version_string = current_version.split(\".\")\n    version_string[-1] = str((int(version_string[-1]) + 1))\n    return \".\".join(version_string)", "is_method": false, "function_description": "Private utility function that increments the micro (patch) version number in a semantic version string, facilitating automated version updates within version management workflows."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_get_new_version", "line_number": 108, "body": "def _get_new_version(\n    config_file: str = \"./setup.cfg\",\n    current_version: str = None,\n    micro_release: bool = False,\n):\n    if micro_release:\n        if current_version:\n            return _change_micro_version(current_version)\n        elif config_file:\n            return _change_micro_version(_fetch_current_version(config_file))\n        else:\n            return _fetch_default_calendar_release_version()\n    else:\n        return _fetch_default_calendar_release_version()", "is_method": false, "function_description": "Helper function that determines the next software version based on the current version or configuration, supporting micro releases and default calendar-based versioning."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_get_current_tag", "line_number": 124, "body": "def _get_current_tag(git_command_name=\"get_tag\"):\n    global GIT_COMMANDS\n    command = GIT_COMMANDS.get(git_command_name)\n    out, err, ret = _run_shell_command(command)\n    if str(out):\n        return str(out).split(\"\\n\")[0]\n    else:\n        return None", "is_method": false, "function_description": "Utility function that executes a Git-related shell command to fetch the current tag name, returning the first line of the command output or None if unavailable."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_update_release_version_for_sanic", "line_number": 134, "body": "def _update_release_version_for_sanic(\n    current_version, new_version, config_file, generate_changelog\n):\n    config_parser = RawConfigParser()\n    with open(config_file) as cfg:\n        config_parser.read_file(cfg)\n    config_parser.set(\"version\", \"current_version\", new_version)\n\n    version_files = config_parser.get(\"version\", \"files\")\n    current_version_line = config_parser.get(\n        \"version\", \"current_version_pattern\"\n    ).format(current_version=current_version)\n    new_version_line = config_parser.get(\n        \"version\", \"new_version_pattern\"\n    ).format(new_version=new_version)\n\n    for version_file in version_files.split(\",\"):\n        with open(version_file) as init_file:\n            data = init_file.read()\n\n        new_data = data.replace(current_version_line, new_version_line)\n        with open(version_file, \"w\") as init_file:\n            init_file.write(new_data)\n\n    with open(config_file, \"w\") as config:\n        config_parser.write(config)\n\n    if generate_changelog:\n        towncrier.__main(\n            draft=False,\n            directory=path.dirname(path.abspath(__file__)),\n            project_name=None,\n            project_version=new_version,\n            project_date=None,\n            answer_yes=True,\n        )\n\n    command = GIT_COMMANDS.get(\"commit_version_change\")\n    command[0] = command[0].format(\n        new_version=new_version, current_version=current_version\n    )\n    _, err, ret = _run_shell_command(command)\n    if int(ret) != 0:\n        print(\n            \"Failed to Commit Version upgrade changes to Sanic: {}\".format(\n                err.decode(\"utf-8\")\n            )\n        )\n        sys.exit(1)", "is_method": false, "function_description": "Updates Sanic project version references across configuration and version files, optionally generates a changelog, and commits the changes to version control for releasing a new software version."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_generate_change_log", "line_number": 185, "body": "def _generate_change_log(current_version: str = None):\n    global GIT_COMMANDS\n    command = GIT_COMMANDS.get(\"get_change_log\")\n    command[0] = command[0].format(current_version=current_version)\n    output, error, ret = _run_shell_command(command=command)\n    if not str(output):\n        print(\"Unable to Fetch Change log details to update the Release Note\")\n        sys.exit(1)\n\n    commit_details = OrderedDict()\n    commit_details[\"authors\"] = {}\n    commit_details[\"commits\"] = []\n\n    for line in str(output).split(\"\\n\"):\n        commit, author, description = line.split(\":::\")\n        if \"GitHub\" not in author:\n            commit_details[\"authors\"][author] = 1\n        commit_details[\"commits\"].append(\" - \".join([commit, description]))\n\n    return commit_details", "is_method": false, "function_description": "Generates a change log by retrieving commit details since a specified version from Git, organizing authors and commit messages for release note updates."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_generate_markdown_document", "line_number": 207, "body": "def _generate_markdown_document(\n    milestone, release_name, current_version, release_version\n):\n    global JINJA_RELEASE_NOTE_TEMPLATE\n    release_name = release_name or release_version\n    change_log = _generate_change_log(current_version=current_version)\n    return JINJA_RELEASE_NOTE_TEMPLATE.render(\n        release_name=release_name,\n        milestone=milestone,\n        changelogs=change_log[\"commits\"],\n        authors=change_log[\"authors\"].keys(),\n    )", "is_method": false, "function_description": "Generates a markdown-formatted release note document using release details and the changelog, providing a formatted summary of commits and authors for a given milestone."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_tag_release", "line_number": 221, "body": "def _tag_release(new_version, current_version, milestone, release_name, token):\n    global GIT_COMMANDS\n    global RELEASE_NOTE_UPDATE_URL\n    for command_name in [\"create_new_tag\", \"push_tag\"]:\n        command = GIT_COMMANDS.get(command_name)\n        command[0] = command[0].format(\n            new_version=new_version, current_version=current_version\n        )\n        out, error, ret = _run_shell_command(command=command)\n        if int(ret) != 0:\n            print(\"Failed to execute the command: {}\".format(command[0]))\n            sys.exit(1)\n\n    change_log = _generate_markdown_document(\n        milestone, release_name, current_version, new_version\n    )\n\n    body = {\"name\": release_name or new_version, \"body\": change_log}\n\n    headers = {\"content-type\": \"application/json\"}\n\n    response = patch(\n        RELEASE_NOTE_UPDATE_URL.format(new_version=new_version, token=token),\n        data=dumps(body),\n        headers=headers,\n    )\n    response.raise_for_status()", "is_method": false, "function_description": "Function that automates Git tag creation and pushing for a new release, generates a markdown changelog, and updates the associated release notes via a remote API. It ensures version management and release documentation are synchronized."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "release", "line_number": 250, "body": "def release(args: Namespace):\n    current_tag = _get_current_tag()\n    current_version = _fetch_current_version(args.config)\n    if current_tag and current_version not in current_tag:\n        print(\n            \"Tag mismatch between what's in git and what was provided by \"\n            \"--current-version. Existing: {}, Give: {}\".format(\n                current_tag, current_version\n            )\n        )\n        sys.exit(1)\n    new_version = args.release_version or _get_new_version(\n        args.config, current_version, args.micro_release\n    )\n    _update_release_version_for_sanic(\n        current_version=current_version,\n        new_version=new_version,\n        config_file=args.config,\n        generate_changelog=args.generate_changelog,\n    )\n    if args.tag_release:\n        _tag_release(\n            current_version=current_version,\n            new_version=new_version,\n            milestone=args.milestone,\n            release_name=args.release_name,\n            token=args.token,\n        )", "is_method": false, "function_description": "Function to manage and automate the release process by verifying version tags, determining the new release version, updating configuration and changelog, and optionally tagging the release in version control."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "__enter__", "line_number": 66, "body": "def __enter__(self):\n        chdir(self._new_path)", "is_method": true, "class_name": "Directory", "function_description": "Enables changing the current working directory to a new path when entering a context, supporting the use of the Directory class in a with-statement for temporary directory changes."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "__exit__", "line_number": 69, "body": "def __exit__(self, exc_type, exc_val, exc_tb):\n        chdir(self._old_path)", "is_method": true, "class_name": "Directory", "function_description": "Restores the previous working directory upon exiting a context managed by the Directory class, ensuring the original directory state is maintained after directory changes within the context."}]