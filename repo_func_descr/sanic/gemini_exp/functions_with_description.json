[{"file": "./dataset/RepoExec/test-apps/sanic/setup.py", "function": "open_local", "line_number": 35, "body": "def open_local(paths, mode=\"r\", encoding=\"utf8\"):\n    path = os.path.join(os.path.abspath(os.path.dirname(__file__)), *paths)\n\n    return codecs.open(path, mode, encoding)", "is_method": false, "function_description": "Opens a file located relative to the current script's directory, using specified mode and encoding. This simplifies accessing local data or configuration files bundled with the application."}, {"file": "./dataset/RepoExec/test-apps/sanic/setup.py", "function": "initialize_options", "line_number": 22, "body": "def initialize_options(self):\n        TestCommand.initialize_options(self)\n        self.pytest_args = \"\"", "is_method": true, "class_name": "PyTest", "function_description": "Prepares the PyTest command instance by initializing inherited options and setting up a clear state for `pytest` command-line arguments."}, {"file": "./dataset/RepoExec/test-apps/sanic/setup.py", "function": "run_tests", "line_number": 26, "body": "def run_tests(self):\n        import shlex\n\n        import pytest\n\n        errno = pytest.main(shlex.split(self.pytest_args))\n        sys.exit(errno)", "is_method": true, "class_name": "PyTest", "function_description": "Executes pytest tests using predefined arguments and exits the program with the test run's error code. This provides a programmatic way to run a test suite."}, {"file": "./dataset/RepoExec/test-apps/sanic/docs/conf.py", "function": "setup", "line_number": 167, "body": "def setup(app):\n    app.add_config_value(\n        \"recommonmark_config\",\n        {\n            \"enable_eval_rst\": True,\n            \"enable_auto_doc_ref\": False,\n        },\n        True,\n    )\n    app.add_transform(AutoStructify)", "is_method": false, "function_description": "Configures the application by adding 'recommonmark_config' options and registering an `AutoStructify` transform. This enables advanced Markdown processing, including reStructuredText evaluation within content."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "parse_multipart_form", "line_number": 712, "body": "def parse_multipart_form(body, boundary):\n    \"\"\"\n    Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    files = RequestParameters()\n    fields = RequestParameters()\n\n    form_parts = body.split(boundary)\n    for form_part in form_parts[1:-1]:\n        file_name = None\n        content_type = \"text/plain\"\n        content_charset = \"utf-8\"\n        field_name = None\n        line_index = 2\n        line_end_index = 0\n        while not line_end_index == -1:\n            line_end_index = form_part.find(b\"\\r\\n\", line_index)\n            form_line = form_part[line_index:line_end_index].decode(\"utf-8\")\n            line_index = line_end_index + 2\n\n            if not form_line:\n                break\n\n            colon_index = form_line.index(\":\")\n            form_header_field = form_line[0:colon_index].lower()\n            form_header_value, form_parameters = parse_content_header(\n                form_line[colon_index + 2 :]\n            )\n\n            if form_header_field == \"content-disposition\":\n                field_name = form_parameters.get(\"name\")\n                file_name = form_parameters.get(\"filename\")\n\n                # non-ASCII filenames in RFC2231, \"filename*\" format\n                if file_name is None and form_parameters.get(\"filename*\"):\n                    encoding, _, value = email.utils.decode_rfc2231(\n                        form_parameters[\"filename*\"]\n                    )\n                    file_name = unquote(value, encoding=encoding)\n            elif form_header_field == \"content-type\":\n                content_type = form_header_value\n                content_charset = form_parameters.get(\"charset\", \"utf-8\")\n\n        if field_name:\n            post_data = form_part[line_index:-4]\n            if file_name is None:\n                value = post_data.decode(content_charset)\n                if field_name in fields:\n                    fields[field_name].append(value)\n                else:\n                    fields[field_name] = [value]\n            else:\n                form_file = File(\n                    type=content_type, name=file_name, body=post_data\n                )\n                if field_name in files:\n                    files[field_name].append(form_file)\n                else:\n                    files[field_name] = [form_file]\n        else:\n            logger.debug(\n                \"Form-data field does not have a 'name' parameter \"\n                \"in the Content-Disposition header\"\n            )\n\n    return fields, files", "is_method": false, "function_description": "This function parses an HTTP multipart/form-data request body. It extracts regular form fields and uploaded files, providing a structured representation of the submitted data."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "get", "line_number": 60, "body": "def get(self, name: str, default: Optional[Any] = None) -> Optional[Any]:\n        \"\"\"Return the first value, either the default or actual\"\"\"\n        return super().get(name, [default])[0]", "is_method": true, "class_name": "RequestParameters", "function_description": "This method of the RequestParameters class retrieves the first value associated with a given parameter name. It provides a specified default value if the parameter is not found."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "__repr__", "line_number": 155, "body": "def __repr__(self):\n        class_name = self.__class__.__name__\n        return f\"<{class_name}: {self.method} {self.path}>\"", "is_method": true, "class_name": "Request", "function_description": "Provides a concise string representation of the Request object. It includes the class name, HTTP method, and request path for debugging and logging purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "generate_id", "line_number": 160, "body": "def generate_id(*_):\n        return uuid.uuid4()", "is_method": true, "class_name": "Request", "function_description": "Generates a universally unique identifier (UUID) for a request, suitable for unique identification and tracking."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "name", "line_number": 207, "body": "def name(self):\n        if self._name:\n            return self._name\n        elif self.route:\n            return self.route.name\n        return None", "is_method": true, "class_name": "Request", "function_description": "Retrieves a descriptive name for the request. It first checks for an internal name, then falls back to the name from an associated route object."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "endpoint", "line_number": 215, "body": "def endpoint(self):\n        return self.name", "is_method": true, "class_name": "Request", "function_description": "This method provides the name of the request, typically indicating the specific API endpoint it targets."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "uri_template", "line_number": 219, "body": "def uri_template(self):\n        return f\"/{self.route.path}\"", "is_method": true, "class_name": "Request", "function_description": "Constructs the URI template string for the request, based on its associated route path, useful for endpoint definition or matching."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "protocol", "line_number": 223, "body": "def protocol(self):\n        if not self._protocol:\n            self._protocol = self.transport.get_protocol()\n        return self._protocol", "is_method": true, "class_name": "Request", "function_description": "Provides the communication protocol used by the request, retrieving it from the underlying transport if not already set."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "raw_headers", "line_number": 229, "body": "def raw_headers(self):\n        _, headers = self.head.split(b\"\\r\\n\", 1)\n        return bytes(headers)", "is_method": true, "class_name": "Request", "function_description": "Provides the raw byte representation of a request's HTTP headers, excluding the request line. Useful for low-level header processing or inspection."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "request_line", "line_number": 234, "body": "def request_line(self):\n        reqline, _ = self.head.split(b\"\\r\\n\", 1)\n        return bytes(reqline)", "is_method": true, "class_name": "Request", "function_description": "Extracts and returns the initial request line from an HTTP request's raw header bytes. This line typically specifies the method, path, and protocol version."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "id", "line_number": 239, "body": "def id(self) -> Optional[Union[uuid.UUID, str, int]]:\n        \"\"\"\n        A request ID passed from the client, or generated from the backend.\n\n        By default, this will look in a request header defined at:\n        ``self.app.config.REQUEST_ID_HEADER``. It defaults to\n        ``X-Request-ID``. Sanic will try to cast the ID into a ``UUID`` or an\n        ``int``. If there is not a UUID from the client, then Sanic will try\n        to generate an ID by calling ``Request.generate_id()``. The default\n        behavior is to generate a ``UUID``. You can customize this behavior\n        by subclassing ``Request``.\n\n        .. code-block:: python\n\n            from sanic import Request, Sanic\n            from itertools import count\n\n            class IntRequest(Request):\n                counter = count()\n\n                def generate_id(self):\n                    return next(self.counter)\n\n            app = Sanic(\"MyApp\", request_class=IntRequest)\n        \"\"\"\n        if not self._id:\n            self._id = self.headers.get(\n                self.app.config.REQUEST_ID_HEADER,\n                self.__class__.generate_id(self),  # type: ignore\n            )\n\n            # Try casting to a UUID or an integer\n            if isinstance(self._id, str):\n                try:\n                    self._id = uuid.UUID(self._id)\n                except ValueError:\n                    try:\n                        self._id = int(self._id)  # type: ignore\n                    except ValueError:\n                        ...\n\n        return self._id", "is_method": true, "class_name": "Request", "function_description": "Retrieves or generates a unique identifier for the current request, prioritizing client-provided IDs from headers. It ensures a consistent ID for request tracking and correlation."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "json", "line_number": 283, "body": "def json(self):\n        if self.parsed_json is None:\n            self.load_json()\n\n        return self.parsed_json", "is_method": true, "class_name": "Request", "function_description": "This method provides the JSON body of the HTTP request. It parses and loads the JSON content on demand, ensuring efficient access."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "load_json", "line_number": 289, "body": "def load_json(self, loads=json_loads):\n        try:\n            self.parsed_json = loads(self.body)\n        except Exception:\n            if not self.body:\n                return None\n            raise InvalidUsage(\"Failed when parsing body as json\")\n\n        return self.parsed_json", "is_method": true, "class_name": "Request", "function_description": "Provides the capability to parse the request's body as JSON, making the data accessible. It handles parsing errors and empty bodies gracefully."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "token", "line_number": 300, "body": "def token(self):\n        \"\"\"Attempt to return the auth header token.\n\n        :return: token related to request\n        \"\"\"\n        prefixes = (\"Bearer\", \"Token\")\n        auth_header = self.headers.get(\"Authorization\")\n\n        if auth_header is not None:\n            for prefix in prefixes:\n                if prefix in auth_header:\n                    return auth_header.partition(prefix)[-1].strip()\n\n        return auth_header", "is_method": true, "class_name": "Request", "function_description": "Extracts the authentication token from the request's 'Authorization' header. It supports common 'Bearer' and 'Token' prefixes for retrieving the client's access credential."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "form", "line_number": 316, "body": "def form(self):\n        if self.parsed_form is None:\n            self.parsed_form = RequestParameters()\n            self.parsed_files = RequestParameters()\n            content_type = self.headers.get(\n                \"Content-Type\", DEFAULT_HTTP_CONTENT_TYPE\n            )\n            content_type, parameters = parse_content_header(content_type)\n            try:\n                if content_type == \"application/x-www-form-urlencoded\":\n                    self.parsed_form = RequestParameters(\n                        parse_qs(self.body.decode(\"utf-8\"))\n                    )\n                elif content_type == \"multipart/form-data\":\n                    # TODO: Stream this instead of reading to/from memory\n                    boundary = parameters[\"boundary\"].encode(\"utf-8\")\n                    self.parsed_form, self.parsed_files = parse_multipart_form(\n                        self.body, boundary\n                    )\n            except Exception:\n                error_logger.exception(\"Failed when parsing form\")\n\n        return self.parsed_form", "is_method": true, "class_name": "Request", "function_description": "Parses the HTTP request body to extract and return form data. It supports `application/x-www-form-urlencoded` and `multipart/form-data` content types, caching the parsed result for efficiency."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "files", "line_number": 341, "body": "def files(self):\n        if self.parsed_files is None:\n            self.form  # compute form to get files\n\n        return self.parsed_files", "is_method": true, "class_name": "Request", "function_description": "Provides access to files uploaded with the request. It parses them on demand, ensuring they are available for processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "get_args", "line_number": 347, "body": "def get_args(\n        self,\n        keep_blank_values: bool = False,\n        strict_parsing: bool = False,\n        encoding: str = \"utf-8\",\n        errors: str = \"replace\",\n    ) -> RequestParameters:\n        \"\"\"\n        Method to parse `query_string` using `urllib.parse.parse_qs`.\n        This methods is used by `args` property.\n        Can be used directly if you need to change default parameters.\n\n        :param keep_blank_values:\n            flag indicating whether blank values in\n            percent-encoded queries should be treated as blank strings.\n            A true value indicates that blanks should be retained as blank\n            strings.  The default false value indicates that blank values\n            are to be ignored and treated as if they were  not included.\n        :type keep_blank_values: bool\n        :param strict_parsing:\n            flag indicating what to do with parsing errors.\n            If false (the default), errors are silently ignored. If true,\n            errors raise a ValueError exception.\n        :type strict_parsing: bool\n        :param encoding:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type encoding: str\n        :param errors:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type errors: str\n        :return: RequestParameters\n        \"\"\"\n        if not self.parsed_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]:\n            if self.query_string:\n                self.parsed_args[\n                    (keep_blank_values, strict_parsing, encoding, errors)\n                ] = RequestParameters(\n                    parse_qs(\n                        qs=self.query_string,\n                        keep_blank_values=keep_blank_values,\n                        strict_parsing=strict_parsing,\n                        encoding=encoding,\n                        errors=errors,\n                    )\n                )\n\n        return self.parsed_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]", "is_method": true, "class_name": "Request", "function_description": "The `get_args` method parses the request's URL query string into structured parameters. It offers configurable options for handling blank values, parsing errors, and character encoding, providing access to request arguments."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "get_query_args", "line_number": 403, "body": "def get_query_args(\n        self,\n        keep_blank_values: bool = False,\n        strict_parsing: bool = False,\n        encoding: str = \"utf-8\",\n        errors: str = \"replace\",\n    ) -> list:\n        \"\"\"\n        Method to parse `query_string` using `urllib.parse.parse_qsl`.\n        This methods is used by `query_args` property.\n        Can be used directly if you need to change default parameters.\n\n        :param keep_blank_values:\n            flag indicating whether blank values in\n            percent-encoded queries should be treated as blank strings.\n            A true value indicates that blanks should be retained as blank\n            strings.  The default false value indicates that blank values\n            are to be ignored and treated as if they were  not included.\n        :type keep_blank_values: bool\n        :param strict_parsing:\n            flag indicating what to do with parsing errors.\n            If false (the default), errors are silently ignored. If true,\n            errors raise a ValueError exception.\n        :type strict_parsing: bool\n        :param encoding:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type encoding: str\n        :param errors:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type errors: str\n        :return: list\n        \"\"\"\n        if not self.parsed_not_grouped_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]:\n            if self.query_string:\n                self.parsed_not_grouped_args[\n                    (keep_blank_values, strict_parsing, encoding, errors)\n                ] = parse_qsl(\n                    qs=self.query_string,\n                    keep_blank_values=keep_blank_values,\n                    strict_parsing=strict_parsing,\n                    encoding=encoding,\n                    errors=errors,\n                )\n        return self.parsed_not_grouped_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]", "is_method": true, "class_name": "Request", "function_description": "This method parses the request's URL query string into key-value pairs. It offers flexible control over parsing, decoding, and error handling, caching results for efficient parameter retrieval."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "cookies", "line_number": 461, "body": "def cookies(self) -> Dict[str, str]:\n        \"\"\"\n        :return: Incoming cookies on the request\n        :rtype: Dict[str, str]\n        \"\"\"\n\n        if self._cookies is None:\n            cookie = self.headers.get(\"Cookie\")\n            if cookie is not None:\n                cookies: SimpleCookie = SimpleCookie()\n                cookies.load(cookie)\n                self._cookies = {\n                    name: cookie.value for name, cookie in cookies.items()\n                }\n            else:\n                self._cookies = {}\n        return self._cookies", "is_method": true, "class_name": "Request", "function_description": "This method retrieves and parses the incoming HTTP cookies from the request headers, providing convenient access to client-side data as a dictionary."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "content_type", "line_number": 480, "body": "def content_type(self) -> str:\n        \"\"\"\n        :return: Content-Type header form the request\n        :rtype: str\n        \"\"\"\n        return self.headers.get(\"Content-Type\", DEFAULT_HTTP_CONTENT_TYPE)", "is_method": true, "class_name": "Request", "function_description": "This method retrieves the Content-Type header from an HTTP request, indicating the format of the request body."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "match_info", "line_number": 488, "body": "def match_info(self):\n        \"\"\"\n        :return: matched info after resolving route\n        \"\"\"\n        return self._match_info", "is_method": true, "class_name": "Request", "function_description": "Retrieves the routing information matched for the current request, providing details about the resolved route."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "ip", "line_number": 497, "body": "def ip(self) -> str:\n        \"\"\"\n        :return: peer ip of the socket\n        :rtype: str\n        \"\"\"\n        return self.conn_info.client if self.conn_info else \"\"", "is_method": true, "class_name": "Request", "function_description": "Provides the IP address of the client associated with the network request. This capability is crucial for logging, security analysis, or tracking connection sources."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "port", "line_number": 505, "body": "def port(self) -> int:\n        \"\"\"\n        :return: peer port of the socket\n        :rtype: int\n        \"\"\"\n        return self.conn_info.client_port if self.conn_info else 0", "is_method": true, "class_name": "Request", "function_description": "Provides the peer port number of the client's connection for the current request. It helps identify the origin of the network request."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "socket", "line_number": 513, "body": "def socket(self):\n        return self.conn_info.peername if self.conn_info else (None, None)", "is_method": true, "class_name": "Request", "function_description": "Provides the network address (IP and port) of the connected peer for this request. This identifies the client initiating the communication."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "path", "line_number": 517, "body": "def path(self) -> str:\n        \"\"\"\n        :return: path of the local HTTP request\n        :rtype: str\n        \"\"\"\n        return self._parsed_url.path.decode(\"utf-8\")", "is_method": true, "class_name": "Request", "function_description": "The Request class method provides the specific path component of the incoming HTTP request's URL."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "forwarded", "line_number": 527, "body": "def forwarded(self) -> Options:\n        \"\"\"\n        Active proxy information obtained from request headers, as specified in\n        Sanic configuration.\n\n        Field names by, for, proto, host, port and path are normalized.\n        - for and by IPv6 addresses are bracketed\n        - port (int) is only set by port headers, not from host.\n        - path is url-unencoded\n\n        Additional values may be available from new style Forwarded headers.\n\n        :return: forwarded address info\n        :rtype: Dict[str, str]\n        \"\"\"\n        if self.parsed_forwarded is None:\n            self.parsed_forwarded = (\n                parse_forwarded(self.headers, self.app.config)\n                or parse_xforwarded(self.headers, self.app.config)\n                or {}\n            )\n        return self.parsed_forwarded", "is_method": true, "class_name": "Request", "function_description": "Retrieves and normalizes active proxy information from HTTP Forwarded or X-Forwarded headers. It provides the original client's connection details for requests passing through proxies."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "remote_addr", "line_number": 551, "body": "def remote_addr(self) -> str:\n        \"\"\"\n        Client IP address, if available.\n        1. proxied remote address `self.forwarded['for']`\n        2. local remote address `self.ip`\n\n        :return: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        :rtype: str\n        \"\"\"\n        if not hasattr(self, \"_remote_addr\"):\n            self._remote_addr = str(\n                self.forwarded.get(\"for\", \"\")\n            )  # or self.ip\n        return self._remote_addr", "is_method": true, "class_name": "Request", "function_description": "Provides the client's IP address for the request. It attempts to retrieve the true IP, even when the request originates from behind a proxy."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "scheme", "line_number": 567, "body": "def scheme(self) -> str:\n        \"\"\"\n        Determine request scheme.\n        1. `config.SERVER_NAME` if in full URL format\n        2. proxied proto/scheme\n        3. local connection protocol\n\n        :return: http|https|ws|wss or arbitrary value given by the headers.\n        :rtype: str\n        \"\"\"\n        if \"//\" in self.app.config.get(\"SERVER_NAME\", \"\"):\n            return self.app.config.SERVER_NAME.split(\"//\")[0]\n        if \"proto\" in self.forwarded:\n            return str(self.forwarded[\"proto\"])\n\n        if (\n            self.app.websocket_enabled\n            and self.headers.get(\"upgrade\") == \"websocket\"\n        ):\n            scheme = \"ws\"\n        else:\n            scheme = \"http\"\n\n        if self.transport.get_extra_info(\"sslcontext\"):\n            scheme += \"s\"\n\n        return scheme", "is_method": true, "class_name": "Request", "function_description": "This method determines the protocol scheme (e.g., \"http\", \"https\", \"ws\", \"wss\") for the current incoming request. It consolidates scheme information from application configuration, forwarded headers, and transport security."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "host", "line_number": 596, "body": "def host(self) -> str:\n        \"\"\"\n        The currently effective server 'host' (hostname or hostname:port).\n        1. `config.SERVER_NAME` overrides any client headers\n        2. proxied host of original request\n        3. request host header\n        hostname and port may be separated by\n        `sanic.headers.parse_host(request.host)`.\n\n        :return: the first matching host found, or empty string\n        :rtype: str\n        \"\"\"\n        server_name = self.app.config.get(\"SERVER_NAME\")\n        if server_name:\n            return server_name.split(\"//\", 1)[-1].split(\"/\", 1)[0]\n        return str(self.forwarded.get(\"host\") or self.headers.get(\"host\", \"\"))", "is_method": true, "class_name": "Request", "function_description": "Provides the effective server host for the current request, resolving it from the application configuration, proxied headers, or the request's host header in that priority order."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "server_name", "line_number": 614, "body": "def server_name(self) -> str:\n        \"\"\"\n        :return: hostname the client connected to, by ``request.host``\n        :rtype: str\n        \"\"\"\n        return parse_host(self.host)[0] or \"\"", "is_method": true, "class_name": "Request", "function_description": "Provides the hostname that the client connected to for the current request. This is useful for various request handling and routing decisions."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "server_port", "line_number": 622, "body": "def server_port(self) -> int:\n        \"\"\"\n        The port the client connected to, by forwarded ``port`` or\n        ``request.host``.\n\n        Default port is returned as 80 and 443 based on ``request.scheme``.\n\n        :return: port number\n        :rtype: int\n        \"\"\"\n        port = self.forwarded.get(\"port\") or parse_host(self.host)[1]\n        return int(port or (80 if self.scheme in (\"http\", \"ws\") else 443))", "is_method": true, "class_name": "Request", "function_description": "Provides the server port number that the client connected to for the current request. It intelligently resolves the port from forwarded headers or the host, defaulting to standard HTTP/HTTPS ports."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "server_path", "line_number": 636, "body": "def server_path(self) -> str:\n        \"\"\"\n        :return: full path of current URL; uses proxied or local path\n        :rtype: str\n        \"\"\"\n        return str(self.forwarded.get(\"path\") or self.path)", "is_method": true, "class_name": "Request", "function_description": "Provides the full URL path for the current request. It correctly determines the path, accounting for proxy forwarding or direct access."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "query_string", "line_number": 644, "body": "def query_string(self) -> str:\n        \"\"\"\n        :return: representation of the requested query\n        :rtype: str\n        \"\"\"\n        if self._parsed_url.query:\n            return self._parsed_url.query.decode(\"utf-8\")\n        else:\n            return \"\"", "is_method": true, "class_name": "Request", "function_description": "Provides the raw query string from the request's URL. This string represents unparsed parameters, essential for processing request data or routing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "url", "line_number": 655, "body": "def url(self) -> str:\n        \"\"\"\n        :return: the URL\n        :rtype: str\n        \"\"\"\n        return urlunparse(\n            (self.scheme, self.host, self.path, None, self.query_string, None)\n        )", "is_method": true, "class_name": "Request", "function_description": "This method provides the complete URL string for the Request object, assembled from its various components. It allows other functions to easily obtain the full URL."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/request.py", "function": "url_for", "line_number": 664, "body": "def url_for(self, view_name: str, **kwargs) -> str:\n        \"\"\"\n        Same as :func:`sanic.Sanic.url_for`, but automatically determine\n        `scheme` and `netloc` base on the request. Since this method is aiming\n        to generate correct schema & netloc, `_external` is implied.\n\n        :param kwargs: takes same parameters as in :func:`sanic.Sanic.url_for`\n        :return: an absolute url to the given view\n        :rtype: str\n        \"\"\"\n        # Full URL SERVER_NAME can only be handled in app.url_for\n        try:\n            if \"//\" in self.app.config.SERVER_NAME:\n                return self.app.url_for(view_name, _external=True, **kwargs)\n        except AttributeError:\n            pass\n\n        scheme = self.scheme\n        host = self.server_name\n        port = self.server_port\n\n        if (scheme.lower() in (\"http\", \"ws\") and port == 80) or (\n            scheme.lower() in (\"https\", \"wss\") and port == 443\n        ):\n            netloc = host\n        else:\n            netloc = f\"{host}:{port}\"\n\n        return self.app.url_for(\n            view_name, _external=True, _scheme=scheme, _server=netloc, **kwargs\n        )", "is_method": true, "class_name": "Request", "function_description": "Generates a complete, absolute URL for a specified view name. It automatically determines the scheme and host based on the current request context for accurate link generation."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/reloader_helpers.py", "function": "_iter_module_files", "line_number": 9, "body": "def _iter_module_files():\n    \"\"\"This iterates over all relevant Python files.\n\n    It goes through all\n    loaded files from modules, all files in folders of already loaded modules\n    as well as all files reachable through a package.\n    \"\"\"\n    # The list call is necessary on Python 3 in case the module\n    # dictionary modifies during iteration.\n    for module in list(sys.modules.values()):\n        if module is None:\n            continue\n        filename = getattr(module, \"__file__\", None)\n        if filename:\n            old = None\n            while not os.path.isfile(filename):\n                old = filename\n                filename = os.path.dirname(filename)\n                if filename == old:\n                    break\n            else:\n                if filename[-4:] in (\".pyc\", \".pyo\"):\n                    filename = filename[:-1]\n                yield filename", "is_method": false, "function_description": "Generates file paths for all Python source files related to currently loaded modules and their packages, including those in module folders. This service helps discover all relevant source code files at runtime."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/reloader_helpers.py", "function": "_get_args_for_reloading", "line_number": 35, "body": "def _get_args_for_reloading():\n    \"\"\"Returns the executable.\"\"\"\n    main_module = sys.modules[\"__main__\"]\n    mod_spec = getattr(main_module, \"__spec__\", None)\n    if sys.argv[0] in (\"\", \"-c\"):\n        raise RuntimeError(\n            f\"Autoreloader cannot work with argv[0]={sys.argv[0]!r}\"\n        )\n    if mod_spec:\n        # Parent exe was launched as a module rather than a script\n        return [sys.executable, \"-m\", mod_spec.name] + sys.argv[1:]\n    return [sys.executable] + sys.argv", "is_method": false, "function_description": "Prepares the command-line arguments to re-execute the current Python script or module. This function supports autoreloading mechanisms by providing the necessary command to restart the application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/reloader_helpers.py", "function": "restart_with_reloader", "line_number": 49, "body": "def restart_with_reloader():\n    \"\"\"Create a new process and a subprocess in it with the same arguments as\n    this one.\n    \"\"\"\n    return subprocess.Popen(\n        _get_args_for_reloading(),\n        env={**os.environ, \"SANIC_SERVER_RUNNING\": \"true\"},\n    )", "is_method": false, "function_description": "Spawns a new process that re-executes the current application with its original arguments and environment. This enables capabilities like hot-reloading a server."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/reloader_helpers.py", "function": "watchdog", "line_number": 59, "body": "def watchdog(sleep_interval):\n    \"\"\"Watch project files, restart worker process if a change happened.\n\n    :param sleep_interval: interval in second.\n    :return: Nothing\n    \"\"\"\n\n    def interrupt_self(*args):\n        raise KeyboardInterrupt\n\n    mtimes = {}\n    signal.signal(signal.SIGTERM, interrupt_self)\n    if os.name == \"nt\":\n        signal.signal(signal.SIGBREAK, interrupt_self)\n\n    worker_process = restart_with_reloader()\n\n    try:\n        while True:\n            need_reload = False\n\n            for filename in _iter_module_files():\n                try:\n                    mtime = os.stat(filename).st_mtime\n                except OSError:\n                    continue\n\n                old_time = mtimes.get(filename)\n                if old_time is None:\n                    mtimes[filename] = mtime\n                elif mtime > old_time:\n                    mtimes[filename] = mtime\n                    need_reload = True\n\n            if need_reload:\n                worker_process.terminate()\n                worker_process.wait()\n                worker_process = restart_with_reloader()\n\n            sleep(sleep_interval)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        worker_process.terminate()\n        worker_process.wait()", "is_method": false, "function_description": "Continuously monitors project files for changes. If modifications are detected, it automatically restarts a designated worker process to apply updates."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/reloader_helpers.py", "function": "interrupt_self", "line_number": 66, "body": "def interrupt_self(*args):\n        raise KeyboardInterrupt", "is_method": false, "function_description": "This function programmatically raises a KeyboardInterrupt exception. It can be used to simulate user interruption or test error handling mechanisms."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/compat.py", "function": "ctrlc_workaround_for_windows", "line_number": 55, "body": "def ctrlc_workaround_for_windows(app):\n    async def stay_active(app):\n        \"\"\"Asyncio wakeups to allow receiving SIGINT in Python\"\"\"\n        while not die:\n            # If someone else stopped the app, just exit\n            if app.is_stopping:\n                return\n            # Windows Python blocks signal handlers while the event loop is\n            # waiting for I/O. Frequent wakeups keep interrupts flowing.\n            await asyncio.sleep(0.1)\n        # Can't be called from signal handler, so call it from here\n        app.stop()\n\n    def ctrlc_handler(sig, frame):\n        nonlocal die\n        if die:\n            raise KeyboardInterrupt(\"Non-graceful Ctrl+C\")\n        die = True\n\n    die = False\n    signal.signal(signal.SIGINT, ctrlc_handler)\n    app.add_task(stay_active)", "is_method": false, "function_description": "Configures an asyncio application on Windows to reliably detect and handle Ctrl+C (SIGINT). It ensures graceful termination by preventing the event loop from blocking signal handlers."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/compat.py", "function": "get_all", "line_number": 28, "body": "def get_all(self, key: str):\n        \"\"\"\n        Convenience method mapped to ``getall()``.\n        \"\"\"\n        return self.getall(key, default=[])", "is_method": true, "class_name": "Header", "function_description": "Retrieves all values for a header key, returning an empty list if none exist."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/compat.py", "function": "stat_async", "line_number": 40, "body": "def stat_async(path):\n        return trio.Path(path).stat()", "is_method": false, "function_description": "Asynchronously retrieves file system status information for a given path, such as file size, modification time, and permissions. This is useful for non-blocking file system checks."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/compat.py", "function": "ctrlc_handler", "line_number": 68, "body": "def ctrlc_handler(sig, frame):\n        nonlocal die\n        if die:\n            raise KeyboardInterrupt(\"Non-graceful Ctrl+C\")\n        die = True", "is_method": false, "function_description": "This function handles Ctrl+C signals, enabling a two-stage shutdown. The first Ctrl+C prompts a graceful exit attempt, while a second forces a non-graceful termination."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "init_process", "line_number": 45, "body": "def init_process(self):\n        # create new event_loop after fork\n        asyncio.get_event_loop().close()\n\n        self.loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self.loop)\n\n        super().init_process()", "is_method": true, "class_name": "GunicornWorker", "function_description": "Ensures each Gunicorn worker process has a distinct, properly initialized asyncio event loop after being forked, enabling independent asynchronous operations."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "run", "line_number": 54, "body": "def run(self):\n        is_debug = self.log.loglevel == logging.DEBUG\n        protocol = (\n            self.websocket_protocol\n            if self.app.callable.websocket_enabled\n            else self.http_protocol\n        )\n\n        self._server_settings = self.app.callable._helper(\n            loop=self.loop,\n            debug=is_debug,\n            protocol=protocol,\n            ssl=self.ssl_context,\n            run_async=True,\n        )\n        self._server_settings[\"signal\"] = self.signal\n        self._server_settings.pop(\"sock\")\n        trigger_events(\n            self._server_settings.get(\"before_start\", []), self.loop\n        )\n        self._server_settings[\"before_start\"] = ()\n\n        main_start = self._server_settings.pop(\"main_start\", None)\n        main_stop = self._server_settings.pop(\"main_stop\", None)\n\n        if main_start or main_stop:  # noqa\n            logger.warning(\n                \"Listener events for the main process are not available \"\n                \"with GunicornWorker\"\n            )\n\n        self._runner = asyncio.ensure_future(self._run(), loop=self.loop)\n        try:\n            self.loop.run_until_complete(self._runner)\n            self.app.callable.is_running = True\n            trigger_events(\n                self._server_settings.get(\"after_start\", []), self.loop\n            )\n            self.loop.run_until_complete(self._check_alive())\n            trigger_events(\n                self._server_settings.get(\"before_stop\", []), self.loop\n            )\n            self.loop.run_until_complete(self.close())\n        except BaseException:\n            traceback.print_exc()\n        finally:\n            try:\n                trigger_events(\n                    self._server_settings.get(\"after_stop\", []), self.loop\n                )\n            except BaseException:\n                traceback.print_exc()\n            finally:\n                self.loop.close()\n\n        sys.exit(self.exit_code)", "is_method": true, "class_name": "GunicornWorker", "function_description": "This method starts and manages the full lifecycle of the Gunicorn worker's asynchronous server. It handles server setup, runs the main event loop, and orchestrates shutdown processes including event triggering."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "_create_ssl_context", "line_number": 186, "body": "def _create_ssl_context(cfg):\n        \"\"\"Creates SSLContext instance for usage in asyncio.create_server.\n        See ssl.SSLSocket.__init__ for more details.\n        \"\"\"\n        ctx = ssl.SSLContext(cfg.ssl_version)\n        ctx.load_cert_chain(cfg.certfile, cfg.keyfile)\n        ctx.verify_mode = cfg.cert_reqs\n        if cfg.ca_certs:\n            ctx.load_verify_locations(cfg.ca_certs)\n        if cfg.ciphers:\n            ctx.set_ciphers(cfg.ciphers)\n        return ctx", "is_method": true, "class_name": "GunicornWorker", "function_description": "Configures an SSL context from provided settings, enabling secure network communication. It loads certificates, keys, and defines verification rules for secure connections."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "init_signals", "line_number": 199, "body": "def init_signals(self):\n        # Set up signals through the event loop API.\n\n        self.loop.add_signal_handler(\n            signal.SIGQUIT, self.handle_quit, signal.SIGQUIT, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGTERM, self.handle_exit, signal.SIGTERM, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGINT, self.handle_quit, signal.SIGINT, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGWINCH, self.handle_winch, signal.SIGWINCH, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGUSR1, self.handle_usr1, signal.SIGUSR1, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGABRT, self.handle_abort, signal.SIGABRT, None\n        )\n\n        # Don't let SIGTERM and SIGUSR1 disturb active requests\n        # by interrupting system calls\n        signal.siginterrupt(signal.SIGTERM, False)\n        signal.siginterrupt(signal.SIGUSR1, False)", "is_method": true, "class_name": "GunicornWorker", "function_description": "Establishes signal handlers for the Gunicorn worker, defining its behavior when receiving various operating system signals for robust process management and graceful shutdowns."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "handle_quit", "line_number": 231, "body": "def handle_quit(self, sig, frame):\n        self.alive = False\n        self.app.callable.is_running = False\n        self.cfg.worker_int(self)", "is_method": true, "class_name": "GunicornWorker", "function_description": "This method gracefully shuts down a Gunicorn worker process upon receiving a quit signal. It updates the worker's status, notifies the application, and executes a configured worker interruption hook."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/worker.py", "function": "handle_abort", "line_number": 236, "body": "def handle_abort(self, sig, frame):\n        self.alive = False\n        self.exit_code = 1\n        self.cfg.worker_abort(self)\n        sys.exit(1)", "is_method": true, "class_name": "GunicornWorker", "function_description": "This method handles an abort signal for a Gunicorn worker, marking it inactive, setting an error exit code, and terminating the process."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "empty", "line_number": 239, "body": "def empty(\n    status=204, headers: Optional[Dict[str, str]] = None\n) -> HTTPResponse:\n    \"\"\"\n    Returns an empty response to the client.\n\n    :param status Response code.\n    :param headers Custom Headers.\n    \"\"\"\n    return HTTPResponse(body=b\"\", status=status, headers=headers)", "is_method": false, "function_description": "This function provides the capability to send an empty HTTP response to a client. It allows specifying the HTTP status code and custom headers, useful for operations that return no content."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "json", "line_number": 251, "body": "def json(\n    body: Any,\n    status: int = 200,\n    headers: Optional[Dict[str, str]] = None,\n    content_type: str = \"application/json\",\n    dumps: Optional[Callable[..., str]] = None,\n    **kwargs,\n) -> HTTPResponse:\n    \"\"\"\n    Returns response object with body in json format.\n\n    :param body: Response data to be serialized.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    :param kwargs: Remaining arguments that are passed to the json encoder.\n    \"\"\"\n    if not dumps:\n        dumps = BaseHTTPResponse._dumps\n    return HTTPResponse(\n        dumps(body, **kwargs),\n        headers=headers,\n        status=status,\n        content_type=content_type,\n    )", "is_method": false, "function_description": "Generates an HTTP response with the provided data serialized into JSON format. It simplifies sending structured data back to clients in web applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "text", "line_number": 277, "body": "def text(\n    body: str,\n    status: int = 200,\n    headers: Optional[Dict[str, str]] = None,\n    content_type: str = \"text/plain; charset=utf-8\",\n) -> HTTPResponse:\n    \"\"\"\n    Returns response object with body in text format.\n\n    :param body: Response data to be encoded.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    :param content_type: the content type (string) of the response\n    \"\"\"\n    if not isinstance(body, str):\n        raise TypeError(\n            f\"Bad body type. Expected str, got {type(body).__name__})\"\n        )\n\n    return HTTPResponse(\n        body, status=status, headers=headers, content_type=content_type\n    )", "is_method": false, "function_description": "Generates an HTTP response object with a string body, configured as plain text content. It allows setting custom status, headers, and content type."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "raw", "line_number": 301, "body": "def raw(\n    body: Optional[AnyStr],\n    status: int = 200,\n    headers: Optional[Dict[str, str]] = None,\n    content_type: str = DEFAULT_HTTP_CONTENT_TYPE,\n) -> HTTPResponse:\n    \"\"\"\n    Returns response object without encoding the body.\n\n    :param body: Response data.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    :param content_type: the content type (string) of the response.\n    \"\"\"\n    return HTTPResponse(\n        body=body,\n        status=status,\n        headers=headers,\n        content_type=content_type,\n    )", "is_method": false, "function_description": "Creates an HTTPResponse object directly using the provided raw body data, status, and headers. This function is useful for sending responses where the body is already in its final desired format."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "html", "line_number": 323, "body": "def html(\n    body: Union[str, bytes, HTMLProtocol],\n    status: int = 200,\n    headers: Optional[Dict[str, str]] = None,\n) -> HTTPResponse:\n    \"\"\"\n    Returns response object with body in html format.\n\n    :param body: str or bytes-ish, or an object with __html__ or _repr_html_.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    \"\"\"\n    if not isinstance(body, (str, bytes)):\n        if hasattr(body, \"__html__\"):\n            body = body.__html__()\n        elif hasattr(body, \"_repr_html_\"):\n            body = body._repr_html_()\n\n    return HTTPResponse(  # type: ignore\n        body,\n        status=status,\n        headers=headers,\n        content_type=\"text/html; charset=utf-8\",\n    )", "is_method": false, "function_description": "Generates an HTTP response object, ensuring the provided body content is correctly formatted and served as HTML. It handles various input types for the HTML body."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "stream", "line_number": 459, "body": "def stream(\n    streaming_fn: StreamingFunction,\n    status: int = 200,\n    headers: Optional[Dict[str, str]] = None,\n    content_type: str = \"text/plain; charset=utf-8\",\n    chunked=\"deprecated\",\n):\n    \"\"\"Accepts an coroutine `streaming_fn` which can be used to\n    write chunks to a streaming response. Returns a `StreamingHTTPResponse`.\n\n    Example usage::\n\n        @app.route(\"/\")\n        async def index(request):\n            async def streaming_fn(response):\n                await response.write('foo')\n                await response.write('bar')\n\n            return stream(streaming_fn, content_type='text/plain')\n\n    :param streaming_fn: A coroutine accepts a response and\n        writes content to that response.\n    :param mime_type: Specific mime_type.\n    :param headers: Custom Headers.\n    :param chunked: Deprecated\n    \"\"\"\n    if chunked != \"deprecated\":\n        warn(\n            \"The chunked argument has been deprecated and will be \"\n            \"removed in v21.6\"\n        )\n\n    return StreamingHTTPResponse(\n        streaming_fn,\n        headers=headers,\n        content_type=content_type,\n        status=status,\n    )", "is_method": false, "function_description": "Facilitates creating an HTTP streaming response. It accepts an asynchronous function that writes content chunks, returning a `StreamingHTTPResponse` for web applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "redirect", "line_number": 499, "body": "def redirect(\n    to: str,\n    headers: Optional[Dict[str, str]] = None,\n    status: int = 302,\n    content_type: str = \"text/html; charset=utf-8\",\n) -> HTTPResponse:\n    \"\"\"\n    Abort execution and cause a 302 redirect (by default) by setting a\n    Location header.\n\n    :param to: path or fully qualified URL to redirect to\n    :param headers: optional dict of headers to include in the new request\n    :param status: status code (int) of the new request, defaults to 302\n    :param content_type: the content type (string) of the response\n    \"\"\"\n    headers = headers or {}\n\n    # URL Quote the URL before redirecting\n    safe_to = quote_plus(to, safe=\":/%#?&=@[]!$&'()*+,;\")\n\n    # According to RFC 7231, a relative URI is now permitted.\n    headers[\"Location\"] = safe_to\n\n    return HTTPResponse(\n        status=status, headers=headers, content_type=content_type\n    )", "is_method": false, "function_description": "This function generates an HTTP response that instructs a client to redirect to a specified URL. It enables control over the redirect destination, HTTP status code, and response headers."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "_encode_body", "line_number": 53, "body": "def _encode_body(self, data: Optional[AnyStr]):\n        if data is None:\n            return b\"\"\n        return (\n            data.encode() if hasattr(data, \"encode\") else data  # type: ignore\n        )", "is_method": true, "class_name": "BaseHTTPResponse", "function_description": "Prepares the HTTP response body by converting it to bytes. It encodes string data and returns an empty byte string for None."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "cookies", "line_number": 61, "body": "def cookies(self) -> CookieJar:\n        \"\"\"\n        The response cookies. Cookies should be set and written as follows:\n\n        .. code-block:: python\n\n                response.cookies[\"test\"] = \"It worked!\"\n                response.cookies[\"test\"][\"domain\"] = \".yummy-yummy-cookie.com\"\n                response.cookies[\"test\"][\"httponly\"] = True\n\n        `See user guide re: cookies\n        <https://sanicframework.org/guide/basics/cookies.html>`__\n\n        :return: the cookie jar\n        :rtype: CookieJar\n        \"\"\"\n        if self._cookies is None:\n            self._cookies = CookieJar(self.headers)\n        return self._cookies", "is_method": true, "class_name": "BaseHTTPResponse", "function_description": "Provides access to the HTTP cookies associated with this response. It enables manipulation and management of cookies sent back to the client."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/response.py", "function": "processed_headers", "line_number": 82, "body": "def processed_headers(self) -> Iterator[Tuple[bytes, bytes]]:\n        \"\"\"\n        Obtain a list of header tuples encoded in bytes for sending.\n\n        Add and remove headers based on status and content_type.\n\n        :return: response headers\n        :rtype: Tuple[Tuple[bytes, bytes], ...]\n        \"\"\"\n        # TODO: Make a blacklist set of header names and then filter with that\n        if self.status in (304, 412):  # Not Modified, Precondition Failed\n            self.headers = remove_entity_headers(self.headers)\n        if has_message_body(self.status):\n            self.headers.setdefault(\"content-type\", self.content_type)\n        # Encode headers into bytes\n        return (\n            (name.encode(\"ascii\"), f\"{value}\".encode(errors=\"surrogateescape\"))\n            for name, value in self.headers.items()\n        )", "is_method": true, "class_name": "BaseHTTPResponse", "function_description": "Ensures HTTP response headers are correctly formatted and encoded for network transmission, applying necessary modifications based on status and content type."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "escape", "line_number": 329, "body": "def escape(text):\n    \"\"\"\n    Minimal HTML escaping, not for attribute values (unlike html.escape).\n    \"\"\"\n    return f\"{text}\".replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\")", "is_method": false, "function_description": "This function performs basic HTML escaping, converting ampersands and less-than signs into their HTML entities. It prepares text for safe display directly within HTML page content."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "exception_response", "line_number": 349, "body": "def exception_response(\n    request: Request,\n    exception: Exception,\n    debug: bool,\n    renderer: t.Type[t.Optional[BaseRenderer]] = None,\n) -> HTTPResponse:\n    \"\"\"\n    Render a response for the default FALLBACK exception handler.\n    \"\"\"\n\n    if not renderer:\n        renderer = HTMLRenderer\n\n        if request:\n            if request.app.config.FALLBACK_ERROR_FORMAT == \"auto\":\n                try:\n                    renderer = JSONRenderer if request.json else HTMLRenderer\n                except InvalidUsage:\n                    renderer = HTMLRenderer\n\n                content_type, *_ = request.headers.get(\n                    \"content-type\", \"\"\n                ).split(\";\")\n                renderer = RENDERERS_BY_CONTENT_TYPE.get(\n                    content_type, renderer\n                )\n            else:\n                render_format = request.app.config.FALLBACK_ERROR_FORMAT\n                renderer = RENDERERS_BY_CONFIG.get(render_format, renderer)\n\n    renderer = t.cast(t.Type[BaseRenderer], renderer)\n    return renderer(request, exception, debug).render()", "is_method": false, "function_description": "Generates an HTTP error response for a fallback exception handler, dynamically selecting the appropriate format (e.g., HTML, JSON) based on the request or application configuration."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "headers", "line_number": 54, "body": "def headers(self):\n        if isinstance(self.exception, SanicException):\n            return getattr(self.exception, \"headers\", {})\n        return {}", "is_method": true, "class_name": "BaseRenderer", "function_description": "Retrieves HTTP headers from the renderer's exception, if it is a SanicException. This allows custom headers to be included in error responses."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "status", "line_number": 60, "body": "def status(self):\n        if isinstance(self.exception, SanicException):\n            return getattr(self.exception, \"status_code\", FALLBACK_STATUS)\n        return FALLBACK_STATUS", "is_method": true, "class_name": "BaseRenderer", "function_description": "Provides the HTTP status code for rendering a response, deriving it from an encountered SanicException or returning a fallback status."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "text", "line_number": 66, "body": "def text(self):\n        if self.debug or isinstance(self.exception, SanicException):\n            return str(self.exception)\n        return FALLBACK_TEXT", "is_method": true, "class_name": "BaseRenderer", "function_description": "Generates a textual representation of an exception for debugging or specific Sanic errors. Otherwise, it returns a generic fallback message for display."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "title", "line_number": 72, "body": "def title(self):\n        status_text = STATUS_CODES.get(self.status, b\"Error Occurred\").decode()\n        return f\"{self.status} \u2014 {status_text}\"", "is_method": true, "class_name": "BaseRenderer", "function_description": "Generates a human-readable title string based on the renderer's current HTTP status code. This title typically describes the response status for display purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "render", "line_number": 76, "body": "def render(self) -> HTTPResponse:\n        \"\"\"\n        Outputs the exception as a :class:`HTTPResponse`.\n\n        :return: The formatted exception\n        :rtype: str\n        \"\"\"\n        output = (\n            self.full\n            if self.debug and not getattr(self.exception, \"quiet\", False)\n            else self.minimal\n        )\n        return output()", "is_method": true, "class_name": "BaseRenderer", "function_description": "The `BaseRenderer`'s `render` method outputs a formatted exception as an HTTPResponse. It provides a detailed or minimal representation based on debug settings for web clients."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "full", "line_number": 149, "body": "def full(self) -> HTTPResponse:\n        return html(\n            self.OUTPUT_HTML.format(\n                title=self.title,\n                text=self.text,\n                style=self.TRACEBACK_STYLE,\n                body=self._generate_body(),\n            ),\n            status=self.status,\n        )", "is_method": true, "class_name": "HTMLRenderer", "function_description": "Assembles and returns a complete HTML page as an HTTP response, incorporating title, text, and styled body content."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "minimal", "line_number": 160, "body": "def minimal(self) -> HTTPResponse:\n        return html(\n            self.OUTPUT_HTML.format(\n                title=self.title,\n                text=self.text,\n                style=self.TRACEBACK_STYLE,\n                body=\"\",\n            ),\n            status=self.status,\n            headers=self.headers,\n        )", "is_method": true, "class_name": "HTMLRenderer", "function_description": "Provides a basic HTML HTTP response with a title and text. It formats a predefined template, suitable for simple pages or error displays."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "text", "line_number": 173, "body": "def text(self):\n        return escape(super().text)", "is_method": true, "class_name": "HTMLRenderer", "function_description": "Escapes the raw text content for safe inclusion within HTML. This prevents rendering issues and cross-site scripting (XSS) vulnerabilities."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "title", "line_number": 177, "body": "def title(self):\n        return escape(f\"\u26a0\ufe0f {super().title}\")", "is_method": true, "class_name": "HTMLRenderer", "function_description": "Provides an HTML-escaped title for rendered output. It prepends a warning emoji to the base title from the parent class, signaling a special status."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "_generate_body", "line_number": 180, "body": "def _generate_body(self):\n        _, exc_value, __ = sys.exc_info()\n        exceptions = []\n        while exc_value:\n            exceptions.append(self._format_exc(exc_value))\n            exc_value = exc_value.__cause__\n\n        traceback_html = self.TRACEBACK_BORDER.join(reversed(exceptions))\n        appname = escape(self.request.app.name)\n        name = escape(self.exception.__class__.__name__)\n        value = escape(self.exception)\n        path = escape(self.request.path)\n        lines = [\n            f\"<h2>Traceback of {appname} (most recent call last):</h2>\",\n            f\"{traceback_html}\",\n            \"<div class=summary><p>\",\n            f\"<b>{name}: {value}</b> while handling path <code>{path}</code>\",\n            \"</div>\",\n        ]\n        return \"\\n\".join(lines)", "is_method": true, "class_name": "HTMLRenderer", "function_description": "Generates the HTML body for an error page by formatting a comprehensive exception traceback. It includes chained exceptions and relevant application and request details."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "_format_exc", "line_number": 201, "body": "def _format_exc(self, exc):\n        frames = extract_tb(exc.__traceback__)\n        frame_html = \"\".join(\n            self.TRACEBACK_LINE_HTML.format(frame) for frame in frames\n        )\n        return self.TRACEBACK_WRAPPER_HTML.format(\n            exc_name=escape(exc.__class__.__name__),\n            exc_value=escape(exc),\n            frame_html=frame_html,\n        )", "is_method": true, "class_name": "HTMLRenderer", "function_description": "This method formats a Python exception object and its traceback into a structured HTML string. It provides a service for rendering detailed error information for web display.\nThis method formats a Python exception object and its traceback into a structured HTML string. It provides a service for rendering detailed error information for web display."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "full", "line_number": 221, "body": "def full(self) -> HTTPResponse:\n        return text(\n            self.OUTPUT_TEXT.format(\n                title=self.title,\n                text=self.text,\n                bar=(\"=\" * len(self.title)),\n                body=self._generate_body(),\n            ),\n            status=self.status,\n        )", "is_method": true, "class_name": "TextRenderer", "function_description": "Generates a full text-based HTTP response by formatting a template with the class's title, text, and dynamically generated body, setting the specified status."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "minimal", "line_number": 232, "body": "def minimal(self) -> HTTPResponse:\n        return text(\n            self.OUTPUT_TEXT.format(\n                title=self.title,\n                text=self.text,\n                bar=(\"=\" * len(self.title)),\n                body=\"\",\n            ),\n            status=self.status,\n            headers=self.headers,\n        )", "is_method": true, "class_name": "TextRenderer", "function_description": "Generates a minimal text-based HTTP response. It formats a predefined template using the renderer's title and text, suitable for basic, unstyled output."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "title", "line_number": 245, "body": "def title(self):\n        return f\"\u26a0\ufe0f {super().title}\"", "is_method": true, "class_name": "TextRenderer", "function_description": "Generates a formatted title string by prepending a warning emoji to the title inherited from the parent class. It provides a visually distinct title for rendering."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "_generate_body", "line_number": 248, "body": "def _generate_body(self):\n        _, exc_value, __ = sys.exc_info()\n        exceptions = []\n\n        lines = [\n            f\"{self.exception.__class__.__name__}: {self.exception} while \"\n            f\"handling path {self.request.path}\",\n            f\"Traceback of {self.request.app.name} (most recent call last):\\n\",\n        ]\n\n        while exc_value:\n            exceptions.append(self._format_exc(exc_value))\n            exc_value = exc_value.__cause__\n\n        return \"\\n\".join(lines + exceptions[::-1])", "is_method": true, "class_name": "TextRenderer", "function_description": "Provides a formatted text body for an exception, detailing its type, message, associated path, and a traceback including chained causes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "_format_exc", "line_number": 264, "body": "def _format_exc(self, exc):\n        frames = \"\\n\\n\".join(\n            [\n                f\"{self.SPACER * 2}File {frame.filename}, \"\n                f\"line {frame.lineno}, in \"\n                f\"{frame.name}\\n{self.SPACER * 2}{frame.line}\"\n                for frame in extract_tb(exc.__traceback__)\n            ]\n        )\n        return f\"{self.SPACER}{exc.__class__.__name__}: {exc}\\n{frames}\"", "is_method": true, "class_name": "TextRenderer", "function_description": "Formats a Python exception object and its traceback into a structured, human-readable string. This method is used by the TextRenderer to present detailed error information."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "full", "line_number": 281, "body": "def full(self) -> HTTPResponse:\n        output = self._generate_output(full=True)\n        return json(output, status=self.status, dumps=dumps)", "is_method": true, "class_name": "JSONRenderer", "function_description": "Renders the complete data as a JSON HTTP response. This method provides a full representation of the resource for API consumption."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "minimal", "line_number": 285, "body": "def minimal(self) -> HTTPResponse:\n        output = self._generate_output(full=False)\n        return json(output, status=self.status, dumps=dumps)", "is_method": true, "class_name": "JSONRenderer", "function_description": "Renders a minimal JSON representation of the object managed by the `JSONRenderer`. It provides a concise HTTP JSON response for scenarios requiring less detailed data."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "_generate_output", "line_number": 289, "body": "def _generate_output(self, *, full):\n        output = {\n            \"description\": self.title,\n            \"status\": self.status,\n            \"message\": self.text,\n        }\n\n        if full:\n            _, exc_value, __ = sys.exc_info()\n            exceptions = []\n\n            while exc_value:\n                exceptions.append(\n                    {\n                        \"type\": exc_value.__class__.__name__,\n                        \"exception\": str(exc_value),\n                        \"frames\": [\n                            {\n                                \"file\": frame.filename,\n                                \"line\": frame.lineno,\n                                \"name\": frame.name,\n                                \"src\": frame.line,\n                            }\n                            for frame in extract_tb(exc_value.__traceback__)\n                        ],\n                    }\n                )\n                exc_value = exc_value.__cause__\n\n            output[\"path\"] = self.request.path\n            output[\"args\"] = self.request.args\n            output[\"exceptions\"] = exceptions[::-1]\n\n        return output", "is_method": true, "class_name": "JSONRenderer", "function_description": "Generates a structured dictionary representation for JSON output. It includes basic status and message, optionally providing full request details and comprehensive exception tracebacks for robust error reporting."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/errorpages.py", "function": "title", "line_number": 325, "body": "def title(self):\n        return STATUS_CODES.get(self.status, b\"Error Occurred\").decode()", "is_method": true, "class_name": "JSONRenderer", "function_description": "Provides a human-readable title corresponding to the renderer's status code. It defaults to 'Error Occurred' if the status is unknown."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "trigger_events", "line_number": 343, "body": "def trigger_events(events: Optional[Iterable[Callable[..., Any]]], loop):\n    \"\"\"\n    Trigger event callbacks (functions or async)\n\n    :param events: one or more sync or async functions to execute\n    :param loop: event loop\n    \"\"\"\n    if events:\n        for event in events:\n            result = event(loop)\n            if isawaitable(result):\n                loop.run_until_complete(result)", "is_method": false, "function_description": "This function triggers a collection of event callbacks. It executes both synchronous and asynchronous functions on the given event loop."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "serve", "line_number": 457, "body": "def serve(\n    host,\n    port,\n    app,\n    before_start: Optional[Iterable[ListenerType]] = None,\n    after_start: Optional[Iterable[ListenerType]] = None,\n    before_stop: Optional[Iterable[ListenerType]] = None,\n    after_stop: Optional[Iterable[ListenerType]] = None,\n    ssl: Optional[SSLContext] = None,\n    sock: Optional[socket.socket] = None,\n    unix: Optional[str] = None,\n    reuse_port: bool = False,\n    loop=None,\n    protocol: Type[asyncio.Protocol] = HttpProtocol,\n    backlog: int = 100,\n    register_sys_signals: bool = True,\n    run_multiple: bool = False,\n    run_async: bool = False,\n    connections=None,\n    signal=Signal(),\n    state=None,\n    asyncio_server_kwargs=None,\n):\n    \"\"\"Start asynchronous HTTP Server on an individual process.\n\n    :param host: Address to host on\n    :param port: Port to host on\n    :param before_start: function to be executed before the server starts\n                         listening. Takes arguments `app` instance and `loop`\n    :param after_start: function to be executed after the server starts\n                        listening. Takes  arguments `app` instance and `loop`\n    :param before_stop: function to be executed when a stop signal is\n                        received before it is respected. Takes arguments\n                        `app` instance and `loop`\n    :param after_stop: function to be executed when a stop signal is\n                       received after it is respected. Takes arguments\n                       `app` instance and `loop`\n    :param ssl: SSLContext\n    :param sock: Socket for the server to accept connections from\n    :param unix: Unix socket to listen on instead of TCP port\n    :param reuse_port: `True` for multiple workers\n    :param loop: asyncio compatible event loop\n    :param run_async: bool: Do not create a new event loop for the server,\n                      and return an AsyncServer object rather than running it\n    :param asyncio_server_kwargs: key-value args for asyncio/uvloop\n                                  create_server method\n    :return: Nothing\n    \"\"\"\n    if not run_async and not loop:\n        # create new event_loop after fork\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n    if app.debug:\n        loop.set_debug(app.debug)\n\n    app.asgi = False\n\n    connections = connections if connections is not None else set()\n    protocol_kwargs = _build_protocol_kwargs(protocol, app.config)\n    server = partial(\n        protocol,\n        loop=loop,\n        connections=connections,\n        signal=signal,\n        app=app,\n        state=state,\n        unix=unix,\n        **protocol_kwargs,\n    )\n    asyncio_server_kwargs = (\n        asyncio_server_kwargs if asyncio_server_kwargs else {}\n    )\n    # UNIX sockets are always bound by us (to preserve semantics between modes)\n    if unix:\n        sock = bind_unix_socket(unix, backlog=backlog)\n    server_coroutine = loop.create_server(\n        server,\n        None if sock else host,\n        None if sock else port,\n        ssl=ssl,\n        reuse_port=reuse_port,\n        sock=sock,\n        backlog=backlog,\n        **asyncio_server_kwargs,\n    )\n\n    if run_async:\n        return AsyncioServer(\n            loop=loop,\n            serve_coro=server_coroutine,\n            connections=connections,\n            after_start=after_start,\n            before_stop=before_stop,\n            after_stop=after_stop,\n        )\n\n    trigger_events(before_start, loop)\n\n    try:\n        http_server = loop.run_until_complete(server_coroutine)\n    except BaseException:\n        logger.exception(\"Unable to start server\")\n        return\n\n    trigger_events(after_start, loop)\n\n    # Ignore SIGINT when run_multiple\n    if run_multiple:\n        signal_func(SIGINT, SIG_IGN)\n\n    # Register signals for graceful termination\n    if register_sys_signals:\n        if OS_IS_WINDOWS:\n            ctrlc_workaround_for_windows(app)\n        else:\n            for _signal in [SIGTERM] if run_multiple else [SIGINT, SIGTERM]:\n                loop.add_signal_handler(_signal, app.stop)\n    pid = os.getpid()\n    try:\n        logger.info(\"Starting worker [%s]\", pid)\n        loop.run_forever()\n    finally:\n        logger.info(\"Stopping worker [%s]\", pid)\n\n        # Run the on_stop function if provided\n        trigger_events(before_stop, loop)\n\n        # Wait for event loop to finish and all connections to drain\n        http_server.close()\n        loop.run_until_complete(http_server.wait_closed())\n\n        # Complete all tasks on the loop\n        signal.stopped = True\n        for connection in connections:\n            connection.close_if_idle()\n\n        # Gracefully shutdown timeout.\n        # We should provide graceful_shutdown_timeout,\n        # instead of letting connection hangs forever.\n        # Let's roughly calcucate time.\n        graceful = app.config.GRACEFUL_SHUTDOWN_TIMEOUT\n        start_shutdown: float = 0\n        while connections and (start_shutdown < graceful):\n            loop.run_until_complete(asyncio.sleep(0.1))\n            start_shutdown = start_shutdown + 0.1\n\n        # Force close non-idle connection after waiting for\n        # graceful_shutdown_timeout\n        coros = []\n        for conn in connections:\n            if hasattr(conn, \"websocket\") and conn.websocket:\n                coros.append(conn.websocket.close_connection())\n            else:\n                conn.close()\n\n        _shutdown = asyncio.gather(*coros)\n        loop.run_until_complete(_shutdown)\n\n        trigger_events(after_stop, loop)\n\n        remove_unix_socket(unix)", "is_method": false, "function_description": "Launches an asynchronous HTTP server for a web application. It manages the server's lifecycle, including network setup, event hooks, and graceful shutdown."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "_build_protocol_kwargs", "line_number": 621, "body": "def _build_protocol_kwargs(\n    protocol: Type[asyncio.Protocol], config: Config\n) -> Dict[str, Union[int, float]]:\n    if hasattr(protocol, \"websocket_handshake\"):\n        return {\n            \"websocket_max_size\": config.WEBSOCKET_MAX_SIZE,\n            \"websocket_max_queue\": config.WEBSOCKET_MAX_QUEUE,\n            \"websocket_read_limit\": config.WEBSOCKET_READ_LIMIT,\n            \"websocket_write_limit\": config.WEBSOCKET_WRITE_LIMIT,\n            \"websocket_ping_timeout\": config.WEBSOCKET_PING_TIMEOUT,\n            \"websocket_ping_interval\": config.WEBSOCKET_PING_INTERVAL,\n        }\n    return {}", "is_method": false, "function_description": "Generates a dictionary of WebSocket configuration parameters if the given protocol type handles WebSocket handshakes. It provides essential settings for WebSocket protocol instantiation."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "bind_socket", "line_number": 636, "body": "def bind_socket(host: str, port: int, *, backlog=100) -> socket.socket:\n    \"\"\"Create TCP server socket.\n    :param host: IPv4, IPv6 or hostname may be specified\n    :param port: TCP port number\n    :param backlog: Maximum number of connections to queue\n    :return: socket.socket object\n    \"\"\"\n    try:  # IP address: family must be specified for IPv6 at least\n        ip = ip_address(host)\n        host = str(ip)\n        sock = socket.socket(\n            socket.AF_INET6 if ip.version == 6 else socket.AF_INET\n        )\n    except ValueError:  # Hostname, may become AF_INET or AF_INET6\n        sock = socket.socket()\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.bind((host, port))\n    sock.listen(backlog)\n    return sock", "is_method": false, "function_description": "Establishes and prepares a TCP server socket, binding it to a specified host and port for listening to incoming network connections. It provides a ready-to-use socket for server applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "bind_unix_socket", "line_number": 657, "body": "def bind_unix_socket(path: str, *, mode=0o666, backlog=100) -> socket.socket:\n    \"\"\"Create unix socket.\n    :param path: filesystem path\n    :param backlog: Maximum number of connections to queue\n    :return: socket.socket object\n    \"\"\"\n    \"\"\"Open or atomically replace existing socket with zero downtime.\"\"\"\n    # Sanitise and pre-verify socket path\n    path = os.path.abspath(path)\n    folder = os.path.dirname(path)\n    if not os.path.isdir(folder):\n        raise FileNotFoundError(f\"Socket folder does not exist: {folder}\")\n    try:\n        if not stat.S_ISSOCK(os.stat(path, follow_symlinks=False).st_mode):\n            raise FileExistsError(f\"Existing file is not a socket: {path}\")\n    except FileNotFoundError:\n        pass\n    # Create new socket with a random temporary name\n    tmp_path = f\"{path}.{secrets.token_urlsafe()}\"\n    sock = socket.socket(socket.AF_UNIX)\n    try:\n        # Critical section begins (filename races)\n        sock.bind(tmp_path)\n        try:\n            os.chmod(tmp_path, mode)\n            # Start listening before rename to avoid connection failures\n            sock.listen(backlog)\n            os.rename(tmp_path, path)\n        except:  # noqa: E722\n            try:\n                os.unlink(tmp_path)\n            finally:\n                raise\n    except:  # noqa: E722\n        try:\n            sock.close()\n        finally:\n            raise\n    return sock", "is_method": false, "function_description": "This function creates and binds a Unix domain socket at a specified path. It atomically replaces an existing socket to ensure zero-downtime server reloads."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "remove_unix_socket", "line_number": 698, "body": "def remove_unix_socket(path: Optional[str]) -> None:\n    \"\"\"Remove dead unix socket during server exit.\"\"\"\n    if not path:\n        return\n    try:\n        if stat.S_ISSOCK(os.stat(path, follow_symlinks=False).st_mode):\n            # Is it actually dead (doesn't belong to a new server instance)?\n            with socket.socket(socket.AF_UNIX) as testsock:\n                try:\n                    testsock.connect(path)\n                except ConnectionRefusedError:\n                    os.unlink(path)\n    except FileNotFoundError:\n        pass", "is_method": false, "function_description": "Removes a Unix socket file only if its associated server is no longer active. This prevents stale socket files from persisting after a server shutdown."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "serve_single", "line_number": 714, "body": "def serve_single(server_settings):\n    main_start = server_settings.pop(\"main_start\", None)\n    main_stop = server_settings.pop(\"main_stop\", None)\n\n    if not server_settings.get(\"run_async\"):\n        # create new event_loop after fork\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        server_settings[\"loop\"] = loop\n\n    trigger_events(main_start, server_settings[\"loop\"])\n    serve(**server_settings)\n    trigger_events(main_stop, server_settings[\"loop\"])\n\n    server_settings[\"loop\"].close()", "is_method": false, "function_description": "This function orchestrates the complete lifecycle of a single server instance. It sets up the asyncio event loop, triggers specified start and stop events, and initiates the server operation."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "serve_multiple", "line_number": 731, "body": "def serve_multiple(server_settings, workers):\n    \"\"\"Start multiple server processes simultaneously.  Stop on interrupt\n    and terminate signals, and drain connections when complete.\n\n    :param server_settings: kw arguments to be passed to the serve function\n    :param workers: number of workers to launch\n    :param stop_event: if provided, is used as a stop signal\n    :return:\n    \"\"\"\n    server_settings[\"reuse_port\"] = True\n    server_settings[\"run_multiple\"] = True\n\n    main_start = server_settings.pop(\"main_start\", None)\n    main_stop = server_settings.pop(\"main_stop\", None)\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n\n    trigger_events(main_start, loop)\n\n    # Create a listening socket or use the one in settings\n    sock = server_settings.get(\"sock\")\n    unix = server_settings[\"unix\"]\n    backlog = server_settings[\"backlog\"]\n    if unix:\n        sock = bind_unix_socket(unix, backlog=backlog)\n        server_settings[\"unix\"] = unix\n    if sock is None:\n        sock = bind_socket(\n            server_settings[\"host\"], server_settings[\"port\"], backlog=backlog\n        )\n        sock.set_inheritable(True)\n        server_settings[\"sock\"] = sock\n        server_settings[\"host\"] = None\n        server_settings[\"port\"] = None\n\n    processes = []\n\n    def sig_handler(signal, frame):\n        logger.info(\"Received signal %s. Shutting down.\", Signals(signal).name)\n        for process in processes:\n            os.kill(process.pid, SIGTERM)\n\n    signal_func(SIGINT, lambda s, f: sig_handler(s, f))\n    signal_func(SIGTERM, lambda s, f: sig_handler(s, f))\n    mp = multiprocessing.get_context(\"fork\")\n\n    for _ in range(workers):\n        process = mp.Process(target=serve, kwargs=server_settings)\n        process.daemon = True\n        process.start()\n        processes.append(process)\n\n    for process in processes:\n        process.join()\n\n    # the above processes will block this until they're stopped\n    for process in processes:\n        process.terminate()\n\n    trigger_events(main_stop, loop)\n\n    sock.close()\n    loop.close()\n    remove_unix_socket(unix)", "is_method": false, "function_description": "This function launches and manages multiple server processes to provide concurrent service. It handles graceful shutdown upon interrupt or termination signals, ensuring proper resource cleanup."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "_setup_connection", "line_number": 184, "body": "def _setup_connection(self):\n        self._http = Http(self)\n        self._time = current_time()\n        self.check_timeouts()", "is_method": true, "class_name": "HttpProtocol", "function_description": "Sets up the HTTP protocol connection by initializing core HTTP handling and recording the connection start time. It also triggers an immediate timeout check."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "check_timeouts", "line_number": 225, "body": "def check_timeouts(self):\n        \"\"\"\n        Runs itself periodically to enforce any expired timeouts.\n        \"\"\"\n        try:\n            if not self._task:\n                return\n            duration = current_time() - self._time\n            stage = self._http.stage\n            if stage is Stage.IDLE and duration > self.keep_alive_timeout:\n                logger.debug(\"KeepAlive Timeout. Closing connection.\")\n            elif stage is Stage.REQUEST and duration > self.request_timeout:\n                logger.debug(\"Request Timeout. Closing connection.\")\n                self._http.exception = RequestTimeout(\"Request Timeout\")\n            elif stage is Stage.HANDLER and self._http.upgrade_websocket:\n                logger.debug(\"Handling websocket. Timeouts disabled.\")\n                return\n            elif (\n                stage in (Stage.HANDLER, Stage.RESPONSE, Stage.FAILED)\n                and duration > self.response_timeout\n            ):\n                logger.debug(\"Response Timeout. Closing connection.\")\n                self._http.exception = ServiceUnavailable(\"Response Timeout\")\n            else:\n                interval = (\n                    min(\n                        self.keep_alive_timeout,\n                        self.request_timeout,\n                        self.response_timeout,\n                    )\n                    / 2\n                )\n                self.loop.call_later(max(0.1, interval), self.check_timeouts)\n                return\n            self._task.cancel()\n        except Exception:\n            logger.exception(\"protocol.check_timeouts\")", "is_method": true, "class_name": "HttpProtocol", "function_description": "Monitors HTTP connection stages to enforce configured timeouts. It automatically closes connections or raises exceptions when time limits are exceeded, ensuring resource efficiency."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "close_if_idle", "line_number": 273, "body": "def close_if_idle(self) -> bool:\n        \"\"\"\n        Close the connection if a request is not being sent or received\n\n        :return: boolean - True if closed, false if staying open\n        \"\"\"\n        if self._http is None or self._http.stage is Stage.IDLE:\n            self.close()\n            return True\n        return False", "is_method": true, "class_name": "HttpProtocol", "function_description": "This HttpProtocol method closes the underlying HTTP connection if it's currently idle. It helps manage resources by ensuring inactive connections are terminated."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "close", "line_number": 284, "body": "def close(self):\n        \"\"\"\n        Force close the connection.\n        \"\"\"\n        # Cause a call to connection_lost where further cleanup occurs\n        if self.transport:\n            self.transport.close()\n            self.transport = None", "is_method": true, "class_name": "HttpProtocol", "function_description": "Immediately closes the underlying HTTP connection, releasing associated resources."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "connection_made", "line_number": 297, "body": "def connection_made(self, transport):\n        try:\n            # TODO: Benchmark to find suitable write buffer limits\n            transport.set_write_buffer_limits(low=16384, high=65536)\n            self.connections.add(self)\n            self.transport = transport\n            self._task = self.loop.create_task(self.connection_task())\n            self.recv_buffer = bytearray()\n            self.conn_info = ConnInfo(self.transport, unix=self._unix)\n        except Exception:\n            logger.exception(\"protocol.connect_made\")", "is_method": true, "class_name": "HttpProtocol", "function_description": "This method initializes the HttpProtocol instance for a newly established client connection. It sets up transport buffers, registers the connection, and starts a dedicated task to manage its communication."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "connection_lost", "line_number": 309, "body": "def connection_lost(self, exc):\n        try:\n            self.connections.discard(self)\n            self.resume_writing()\n            if self._task:\n                self._task.cancel()\n        except Exception:\n            logger.exception(\"protocol.connection_lost\")", "is_method": true, "class_name": "HttpProtocol", "function_description": "Manages the graceful shutdown and resource cleanup for a lost HTTP connection. It removes the protocol from active connections and cancels any associated tasks."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "pause_writing", "line_number": 318, "body": "def pause_writing(self):\n        self._can_write.clear()", "is_method": true, "class_name": "HttpProtocol", "function_description": "Pauses the HTTP protocol's ability to write data. This stops further outbound data transmission for the connection."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "resume_writing", "line_number": 321, "body": "def resume_writing(self):\n        self._can_write.set()", "is_method": true, "class_name": "HttpProtocol", "function_description": "Signals that the HTTP protocol is ready to resume sending data. This unblocks any pending write operations for the connection."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "data_received", "line_number": 324, "body": "def data_received(self, data: bytes):\n        try:\n            self._time = current_time()\n            if not data:\n                return self.close()\n            self.recv_buffer += data\n\n            if (\n                len(self.recv_buffer) > self.app.config.REQUEST_BUFFER_SIZE\n                and self.transport\n            ):\n                self.transport.pause_reading()\n\n            if self._data_received:\n                self._data_received.set()\n        except Exception:\n            logger.exception(\"protocol.data_received\")", "is_method": true, "class_name": "HttpProtocol", "function_description": "Handles the reception of raw network data for the HTTP protocol. It appends data to an internal buffer, pausing reading if the buffer exceeds a configured limit."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "after_start", "line_number": 392, "body": "def after_start(self):\n        \"\"\"\n        Trigger \"after_server_start\" events\n        \"\"\"\n        trigger_events(self._after_start, self.loop)", "is_method": true, "class_name": "AsyncioServer", "function_description": "Triggers configured events after the AsyncioServer has successfully started, allowing post-startup initialization or actions."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "before_stop", "line_number": 398, "body": "def before_stop(self):\n        \"\"\"\n        Trigger \"before_server_stop\" events\n        \"\"\"\n        trigger_events(self._before_stop, self.loop)", "is_method": true, "class_name": "AsyncioServer", "function_description": "Triggers pre-shutdown events for the server. It allows connected components to perform necessary cleanup or final actions before full server termination."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "after_stop", "line_number": 404, "body": "def after_stop(self):\n        \"\"\"\n        Trigger \"after_server_stop\" events\n        \"\"\"\n        trigger_events(self._after_stop, self.loop)", "is_method": true, "class_name": "AsyncioServer", "function_description": "Triggers registered 'after_server_stop' events for the AsyncioServer. It ensures that necessary post-shutdown actions are executed."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "is_serving", "line_number": 410, "body": "def is_serving(self) -> bool:\n        if self.server:\n            return self.server.is_serving()\n        return False", "is_method": true, "class_name": "AsyncioServer", "function_description": "Determines if the `AsyncioServer` instance is actively serving incoming connections. It provides the current operational status of the asynchronous server."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "wait_closed", "line_number": 415, "body": "def wait_closed(self):\n        if self.server:\n            return self.server.wait_closed()", "is_method": true, "class_name": "AsyncioServer", "function_description": "Ensures the underlying `asyncio` server has completely shut down and all its connections are closed, allowing for graceful termination."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "close", "line_number": 419, "body": "def close(self):\n        if self.server:\n            self.server.close()\n            coro = self.wait_closed()\n            task = asyncio.ensure_future(coro, loop=self.loop)\n            return task", "is_method": true, "class_name": "AsyncioServer", "function_description": "Initiates the graceful shutdown of the asynchronous server. It returns an awaitable task that completes when the server is fully closed."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "start_serving", "line_number": 426, "body": "def start_serving(self):\n        if self.server:\n            try:\n                return self.server.start_serving()\n            except AttributeError:\n                raise NotImplementedError(\n                    \"server.start_serving not available in this version \"\n                    \"of asyncio or uvloop.\"\n                )", "is_method": true, "class_name": "AsyncioServer", "function_description": "Initiates the asynchronous server's operation by delegating the `start_serving` call to its internal server instance. It handles potential compatibility issues with `asyncio` or `uvloop` versions."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "serve_forever", "line_number": 436, "body": "def serve_forever(self):\n        if self.server:\n            try:\n                return self.server.serve_forever()\n            except AttributeError:\n                raise NotImplementedError(\n                    \"server.serve_forever not available in this version \"\n                    \"of asyncio or uvloop.\"\n                )", "is_method": true, "class_name": "AsyncioServer", "function_description": "Initiates and maintains the asynchronous server's main loop, allowing it to continuously handle client connections and requests."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "__await__", "line_number": 446, "body": "def __await__(self):\n        \"\"\"\n        Starts the asyncio server, returns AsyncServerCoro\n        \"\"\"\n        task = asyncio.ensure_future(self.serve_coro)\n        while not task.done():\n            yield\n        self.server = task.result()\n        return self", "is_method": true, "class_name": "AsyncioServer", "function_description": "This special method makes the `AsyncioServer` instance awaitable. Awaiting it starts the underlying asynchronous server and waits for its full initialization."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/server.py", "function": "sig_handler", "line_number": 768, "body": "def sig_handler(signal, frame):\n        logger.info(\"Received signal %s. Shutting down.\", Signals(signal).name)\n        for process in processes:\n            os.kill(process.pid, SIGTERM)", "is_method": false, "function_description": "This function handles system signals to initiate a graceful shutdown. It logs the received signal and terminates all tracked child processes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "_quote", "line_number": 25, "body": "def _quote(str):\n    r\"\"\"Quote a string for use in a cookie header.\n    If the string does not need to be double-quoted, then just return the\n    string.  Otherwise, surround the string in doublequotes and quote\n    (with a \\) special characters.\n    \"\"\"\n    if str is None or _is_legal_key(str):\n        return str\n    else:\n        return '\"' + str.translate(_Translator) + '\"'", "is_method": false, "function_description": "Quotes a string, adding double quotes and escaping special characters, for safe and compliant inclusion in an HTTP cookie header. This ensures the string adheres to HTTP standards for cookie values."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "__setitem__", "line_number": 57, "body": "def __setitem__(self, key, value):\n        # If this cookie doesn't exist, add it to the header keys\n        if not self.cookie_headers.get(key):\n            cookie = Cookie(key, value)\n            cookie[\"path\"] = \"/\"\n            self.cookie_headers[key] = self.header_key\n            self.headers.add(self.header_key, cookie)\n            return super().__setitem__(key, cookie)\n        else:\n            self[key].value = value", "is_method": true, "class_name": "CookieJar", "function_description": "Provides the capability to add new HTTP cookies or update existing ones within the cookie jar. This method ensures proper management of cookies for a web response."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "__delitem__", "line_number": 68, "body": "def __delitem__(self, key):\n        if key not in self.cookie_headers:\n            self[key] = \"\"\n            self[key][\"max-age\"] = 0\n        else:\n            cookie_header = self.cookie_headers[key]\n            # remove it from header\n            cookies = self.headers.popall(cookie_header)\n            for cookie in cookies:\n                if cookie.key != key:\n                    self.headers.add(cookie_header, cookie)\n            del self.cookie_headers[key]\n            return super().__delitem__(key)", "is_method": true, "class_name": "CookieJar", "function_description": "Removes a specific cookie by its key from the cookie jar. It either sends a directive to expire the cookie on the client or removes it from relevant HTTP headers and internal tracking."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "__setitem__", "line_number": 108, "body": "def __setitem__(self, key, value):\n        if key not in self._keys:\n            raise KeyError(\"Unknown cookie property\")\n        if value is not False:\n            if key.lower() == \"max-age\":\n                if not str(value).isdigit():\n                    raise ValueError(\"Cookie max-age must be an integer\")\n            elif key.lower() == \"expires\":\n                if not isinstance(value, datetime):\n                    raise TypeError(\n                        \"Cookie 'expires' property must be a datetime\"\n                    )\n            return super().__setitem__(key, value)", "is_method": true, "class_name": "Cookie", "function_description": "This method provides controlled assignment for `Cookie` properties, validating common attributes like `max-age` and `expires` for correct type and format. It ensures only valid cookie attributes are set."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "encode", "line_number": 122, "body": "def encode(self, encoding):\n        \"\"\"\n        Encode the cookie content in a specific type of encoding instructed\n        by the developer. Leverages the :func:`str.encode` method provided\n        by python.\n\n        This method can be used to encode and embed ``utf-8`` content into\n        the cookies.\n\n        :param encoding: Encoding to be used with the cookie\n        :return: Cookie encoded in a codec of choosing.\n        :except: UnicodeEncodeError\n        \"\"\"\n        return str(self).encode(encoding)", "is_method": true, "class_name": "Cookie", "function_description": "Provides the capability to encode the cookie's string content into a specified byte encoding. This is essential for handling various character sets, such as UTF-8, for storage or transmission."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/cookies.py", "function": "__str__", "line_number": 137, "body": "def __str__(self):\n        \"\"\"Format as a Set-Cookie header value.\"\"\"\n        output = [\"%s=%s\" % (self.key, _quote(self.value))]\n        for key, value in self.items():\n            if key == \"max-age\":\n                try:\n                    output.append(\"%s=%d\" % (self._keys[key], value))\n                except TypeError:\n                    output.append(\"%s=%s\" % (self._keys[key], value))\n            elif key == \"expires\":\n                output.append(\n                    \"%s=%s\"\n                    % (self._keys[key], value.strftime(\"%a, %d-%b-%Y %T GMT\"))\n                )\n            elif key in self._flags and self[key]:\n                output.append(self._keys[key])\n            else:\n                output.append(\"%s=%s\" % (self._keys[key], value))\n\n        return \"; \".join(output)", "is_method": true, "class_name": "Cookie", "function_description": "Converts the Cookie object into a properly formatted `Set-Cookie` header string, used for sending cookies in HTTP responses."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "parse_content_header", "line_number": 33, "body": "def parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    value = _firefox_quote_escape.sub(\"%22\", value)\n    pos = value.find(\";\")\n    if pos == -1:\n        options: Dict[str, Union[int, str]] = {}\n    else:\n        options = {\n            m.group(1).lower(): m.group(2) or m.group(3).replace(\"%22\", '\"')\n            for m in _param.finditer(value[pos:])\n        }\n        value = value[:pos]\n    return value.strip().lower(), options", "is_method": false, "function_description": "Parses HTTP content-type and content-disposition header strings. It extracts the main value and a dictionary of associated parameters."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "parse_forwarded", "line_number": 63, "body": "def parse_forwarded(headers, config) -> Optional[Options]:\n    \"\"\"Parse RFC 7239 Forwarded headers.\n    The value of `by` or `secret` must match `config.FORWARDED_SECRET`\n    :return: dict with keys and values, or None if nothing matched\n    \"\"\"\n    header = headers.getall(\"forwarded\", None)\n    secret = config.FORWARDED_SECRET\n    if header is None or not secret:\n        return None\n    header = \",\".join(header)  # Join multiple header lines\n    if secret not in header:\n        return None\n    # Loop over <separator><key>=<value> elements from right to left\n    sep = pos = None\n    options: List[Tuple[str, str]] = []\n    found = False\n    for m in _rparam.finditer(header[::-1]):\n        # Start of new element? (on parser skips and non-semicolon right sep)\n        if m.start() != pos or sep != \";\":\n            # Was the previous element (from right) what we wanted?\n            if found:\n                break\n            # Clear values and parse as new element\n            del options[:]\n        pos = m.end()\n        val_token, val_quoted, key, sep = m.groups()\n        key = key.lower()[::-1]\n        val = (val_token or val_quoted.replace('\"\\\\', '\"'))[::-1]\n        options.append((key, val))\n        if key in (\"secret\", \"by\") and val == secret:\n            found = True\n        # Check if we would return on next round, to avoid useless parse\n        if found and sep != \";\":\n            break\n    # If secret was found, return the matching options in left-to-right order\n    return fwd_normalize(reversed(options)) if found else None", "is_method": false, "function_description": "Parses RFC 7239 `Forwarded` HTTP headers, validating them against a configured secret. It extracts proxy information if the secret matches, providing secure client context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "parse_xforwarded", "line_number": 101, "body": "def parse_xforwarded(headers, config) -> Optional[Options]:\n    \"\"\"Parse traditional proxy headers.\"\"\"\n    real_ip_header = config.REAL_IP_HEADER\n    proxies_count = config.PROXIES_COUNT\n    addr = real_ip_header and headers.get(real_ip_header)\n    if not addr and proxies_count:\n        assert proxies_count > 0\n        try:\n            # Combine, split and filter multiple headers' entries\n            forwarded_for = headers.getall(config.FORWARDED_FOR_HEADER)\n            proxies = [\n                p\n                for p in (\n                    p.strip() for h in forwarded_for for p in h.split(\",\")\n                )\n                if p\n            ]\n            addr = proxies[-proxies_count]\n        except (KeyError, IndexError):\n            pass\n    # No processing of other headers if no address is found\n    if not addr:\n        return None\n\n    def options():\n        yield \"for\", addr\n        for key, header in (\n            (\"proto\", \"x-scheme\"),\n            (\"proto\", \"x-forwarded-proto\"),  # Overrides X-Scheme if present\n            (\"host\", \"x-forwarded-host\"),\n            (\"port\", \"x-forwarded-port\"),\n            (\"path\", \"x-forwarded-path\"),\n        ):\n            yield key, headers.get(header)\n\n    return fwd_normalize(options())", "is_method": false, "function_description": "Extracts and normalizes original client connection details (IP, protocol, host, port) from HTTP proxy headers. This provides crucial information for applications behind reverse proxies or load balancers."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "fwd_normalize", "line_number": 139, "body": "def fwd_normalize(fwd: OptionsIterable) -> Options:\n    \"\"\"Normalize and convert values extracted from forwarded headers.\"\"\"\n    ret: Dict[str, Union[int, str]] = {}\n    for key, val in fwd:\n        if val is not None:\n            try:\n                if key in (\"by\", \"for\"):\n                    ret[key] = fwd_normalize_address(val)\n                elif key in (\"host\", \"proto\"):\n                    ret[key] = val.lower()\n                elif key == \"port\":\n                    ret[key] = int(val)\n                elif key == \"path\":\n                    ret[key] = unquote(val)\n                else:\n                    ret[key] = val\n            except ValueError:\n                pass\n    return ret", "is_method": false, "function_description": "This function normalizes and converts values extracted from proxy-forwarded request headers. It standardizes common fields like host, port, and path for consistent application processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "fwd_normalize_address", "line_number": 160, "body": "def fwd_normalize_address(addr: str) -> str:\n    \"\"\"Normalize address fields of proxy headers.\"\"\"\n    if addr == \"unknown\":\n        raise ValueError()  # omit unknown value identifiers\n    if addr.startswith(\"_\"):\n        return addr  # do not lower-case obfuscated strings\n    if _ipv6_re.fullmatch(addr):\n        addr = f\"[{addr}]\"  # bracket IPv6\n    return addr.lower()", "is_method": false, "function_description": "Provides a utility to normalize address strings found in proxy headers. It standardizes formatting by handling IPv6 addresses, skipping obfuscated values, and ensuring a consistent lowercase output."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "parse_host", "line_number": 171, "body": "def parse_host(host: str) -> Tuple[Optional[str], Optional[int]]:\n    \"\"\"Split host:port into hostname and port.\n    :return: None in place of missing elements\n    \"\"\"\n    m = _host_re.fullmatch(host)\n    if not m:\n        return None, None\n    host, port = m.groups()\n    return host.lower(), int(port) if port is not None else None", "is_method": false, "function_description": "Extracts the hostname and optional port from a combined host string, returning them as a tuple. It provides `None` for missing components."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/headers.py", "function": "format_http1_response", "line_number": 188, "body": "def format_http1_response(status: int, headers: HeaderBytesIterable) -> bytes:\n    \"\"\"Format a HTTP/1.1 response header.\"\"\"\n    # Note: benchmarks show that here bytes concat is faster than bytearray,\n    # b\"\".join() or %-formatting. %timeit any changes you make.\n    ret = _HTTP1_STATUSLINES[status]\n    for h in headers:\n        ret += b\"%b: %b\\r\\n\" % h\n    ret += b\"\\r\\n\"\n    return ret", "is_method": false, "function_description": "Formats an HTTP/1.1 response by assembling a status code and headers into a complete byte string. This function is critical for constructing raw HTTP response headers."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "__bool__", "line_number": 108, "body": "def __bool__(self):\n        \"\"\"Test if request handling is in progress\"\"\"\n        return self.stage in (Stage.HANDLER, Stage.RESPONSE)", "is_method": true, "class_name": "Http", "function_description": "Enables boolean evaluation of an Http object to determine if request handling is actively in progress or responding."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "head_response_ignored", "line_number": 332, "body": "def head_response_ignored(self, data: bytes, end_stream: bool) -> None:\n        \"\"\"\n        HEAD response: body data silently ignored.\n        \"\"\"\n        if end_stream:\n            self.response_func = None\n            self.stage = Stage.IDLE", "is_method": true, "class_name": "Http", "function_description": "For an HTTP HEAD response, this method silently discards any received body data. It resets the connection state when the response stream concludes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "create_empty_request", "line_number": 401, "body": "def create_empty_request(self) -> None:\n        \"\"\"\n        Current error handling code needs a request object that won't exist\n        if an error occurred during before a request was received. Create a\n        bogus response for error handling use.\n        \"\"\"\n\n        # FIXME: Avoid this by refactoring error handling and response code\n        self.request = self.protocol.request_class(\n            url_bytes=self.url.encode() if self.url else b\"*\",\n            headers=Header({}),\n            version=\"1.1\",\n            method=\"NONE\",\n            transport=self.protocol.transport,\n            app=self.protocol.app,\n        )\n        self.request.stream = self", "is_method": true, "class_name": "Http", "function_description": "Creates a dummy request object for internal error handling. This enables the system to process errors that occur before a real request is received."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "log_response", "line_number": 419, "body": "def log_response(self) -> None:\n        \"\"\"\n        Helper method provided to enable the logging of responses in case if\n        the :attr:`HttpProtocol.access_log` is enabled.\n        \"\"\"\n        req, res = self.request, self.response\n        extra = {\n            \"status\": getattr(res, \"status\", 0),\n            \"byte\": getattr(self, \"response_bytes_left\", -1),\n            \"host\": \"UNKNOWN\",\n            \"request\": \"nil\",\n        }\n        if req is not None:\n            if req.ip:\n                extra[\"host\"] = f\"{req.ip}:{req.port}\"\n            extra[\"request\"] = f\"{req.method} {req.url}\"\n        access_logger.info(\"\", extra=extra)", "is_method": true, "class_name": "Http", "function_description": "Logs comprehensive details of an HTTP response, such as status, host, and request information, to the access logger. This facilitates monitoring and auditing of HTTP traffic."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "respond", "line_number": 520, "body": "def respond(self, response: BaseHTTPResponse) -> BaseHTTPResponse:\n        \"\"\"\n        Initiate new streaming response.\n\n        Nothing is sent until the first send() call on the returned object, and\n        calling this function multiple times will just alter the response to be\n        given.\n        \"\"\"\n        if self.stage is not Stage.HANDLER:\n            self.stage = Stage.FAILED\n            raise RuntimeError(\"Response already started\")\n\n        self.response, response.stream = response, self\n        return response", "is_method": true, "class_name": "Http", "function_description": "Initiates a new streaming HTTP response, preparing the response object for subsequent data transmission. This sets up the connection to send streamable content back to the client."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/http.py", "function": "send", "line_number": 536, "body": "def send(self):\n        return self.response_func", "is_method": true, "class_name": "Http", "function_description": "Retrieves the callable function that is responsible for sending the HTTP response."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/signals.py", "function": "get_handler", "line_number": 23, "body": "def get_handler(self, raw_path, method, _):\n        method = method or self.router.DEFAULT_METHOD\n        raw_path = raw_path.lstrip(self.router.delimiter)\n        try:\n            return self.handlers[raw_path][method]\n        except (IndexError, KeyError):\n            raise self.router.method_handler_exception(\n                f\"Method '{method}' not found on {self}\",\n                method=method,\n                allowed_methods=set(self.methods[raw_path]),\n            )", "is_method": true, "class_name": "Signal", "function_description": "Retrieves the specific handler function responsible for a given path and method, enabling request dispatching within the routing system."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/signals.py", "function": "get", "line_number": 45, "body": "def get(  # type: ignore\n        self,\n        event: str,\n        condition: Optional[Dict[str, str]] = None,\n    ):\n        extra = condition or {}\n        try:\n            return self.resolve(f\".{event}\", extra=extra)\n        except NotFound:\n            message = \"Could not find signal %s\"\n            terms: List[Union[str, Optional[Dict[str, str]]]] = [event]\n            if extra:\n                message += \" with %s\"\n                terms.append(extra)\n            raise NotFound(message % tuple(terms))", "is_method": true, "class_name": "SignalRouter", "function_description": "Retrieves a specific signal using an event name and optional conditions. This method serves as a lookup mechanism within the SignalRouter for event-driven logic."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/signals.py", "function": "add", "line_number": 100, "body": "def add(  # type: ignore\n        self,\n        handler: SignalHandler,\n        event: str,\n        condition: Optional[Dict[str, Any]] = None,\n    ) -> Signal:\n        parts = self._build_event_parts(event)\n        if parts[2].startswith(\"<\"):\n            name = \".\".join([*parts[:-1], \"*\"])\n        else:\n            name = event\n\n        handler.__requirements__ = condition  # type: ignore\n\n        return super().add(\n            event,\n            handler,\n            requirements=condition,\n            name=name,\n            overwrite=True,\n        )", "is_method": true, "class_name": "SignalRouter", "function_description": "Adds a signal handler to the router, associating it with a specific event and optional conditions. This enables the configuration of how the system processes incoming events."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/signals.py", "function": "finalize", "line_number": 122, "body": "def finalize(self, do_compile: bool = True):\n        try:\n            self.ctx.loop = asyncio.get_running_loop()\n        except RuntimeError:\n            raise RuntimeError(\"Cannot finalize signals outside of event loop\")\n\n        for signal in self.routes.values():\n            signal.ctx.event = asyncio.Event()\n\n        return super().finalize(do_compile=do_compile)", "is_method": true, "class_name": "SignalRouter", "function_description": "This method finalizes the `SignalRouter`'s setup, connecting it to the asyncio event loop. It prepares all registered signals for asynchronous event handling within that loop."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/signals.py", "function": "_build_event_parts", "line_number": 133, "body": "def _build_event_parts(self, event: str) -> Tuple[str, str, str]:\n        parts = path_to_parts(event, self.delimiter)\n        if (\n            len(parts) != 3\n            or parts[0].startswith(\"<\")\n            or parts[1].startswith(\"<\")\n        ):\n            raise InvalidSignal(\"Invalid signal event: %s\" % event)\n\n        if parts[0] in RESERVED_NAMESPACES:\n            raise InvalidSignal(\n                \"Cannot declare reserved signal event: %s\" % event\n            )\n        return parts", "is_method": true, "class_name": "SignalRouter", "function_description": "Parses and validates an event string, splitting it into a three-part tuple. It ensures the event conforms to the `SignalRouter`'s required format for signal processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/utils.py", "function": "str_to_bool", "line_number": 13, "body": "def str_to_bool(val: str) -> bool:\n    \"\"\"Takes string and tries to turn it into bool as human would do.\n\n    If val is in case insensitive (\n        \"y\", \"yes\", \"yep\", \"yup\", \"t\",\n        \"true\", \"on\", \"enable\", \"enabled\", \"1\"\n    ) returns True.\n    If val is in case insensitive (\n        \"n\", \"no\", \"f\", \"false\", \"off\", \"disable\", \"disabled\", \"0\"\n    ) returns False.\n    Else Raise ValueError.\"\"\"\n\n    val = val.lower()\n    if val in {\n        \"y\",\n        \"yes\",\n        \"yep\",\n        \"yup\",\n        \"t\",\n        \"true\",\n        \"on\",\n        \"enable\",\n        \"enabled\",\n        \"1\",\n    }:\n        return True\n    elif val in {\"n\", \"no\", \"f\", \"false\", \"off\", \"disable\", \"disabled\", \"0\"}:\n        return False\n    else:\n        raise ValueError(f\"Invalid truth value {val}\")", "is_method": false, "function_description": "Converts a string to a boolean value, interpreting common \"truthy\" and \"falsy\" representations robustly. It provides a flexible way to parse user input or configuration settings into boolean logic."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/utils.py", "function": "load_module_from_file_location", "line_number": 45, "body": "def load_module_from_file_location(\n    location: Union[bytes, str, Path], encoding: str = \"utf8\", *args, **kwargs\n):  # noqa\n    \"\"\"Returns loaded module provided as a file path.\n\n    :param args:\n        Coresponds to importlib.util.spec_from_file_location location\n        parameters,but with this differences:\n        - It has to be of a string or bytes type.\n        - You can also use here environment variables\n          in format ${some_env_var}.\n          Mark that $some_env_var will not be resolved as environment variable.\n    :encoding:\n        If location parameter is of a bytes type, then use this encoding\n        to decode it into string.\n    :param args:\n        Coresponds to the rest of importlib.util.spec_from_file_location\n        parameters.\n    :param kwargs:\n        Coresponds to the rest of importlib.util.spec_from_file_location\n        parameters.\n\n    For example You can:\n\n        some_module = load_module_from_file_location(\n            \"some_module_name\",\n            \"/some/path/${some_env_var}\"\n        )\n    \"\"\"\n    if isinstance(location, bytes):\n        location = location.decode(encoding)\n\n    if isinstance(location, Path) or \"/\" in location or \"$\" in location:\n\n        if not isinstance(location, Path):\n            # A) Check if location contains any environment variables\n            #    in format ${some_env_var}.\n            env_vars_in_location = set(re_findall(r\"\\${(.+?)}\", location))\n\n            # B) Check these variables exists in environment.\n            not_defined_env_vars = env_vars_in_location.difference(\n                os_environ.keys()\n            )\n            if not_defined_env_vars:\n                raise LoadFileException(\n                    \"The following environment variables are not set: \"\n                    f\"{', '.join(not_defined_env_vars)}\"\n                )\n\n            # C) Substitute them in location.\n            for env_var in env_vars_in_location:\n                location = location.replace(\n                    \"${\" + env_var + \"}\", os_environ[env_var]\n                )\n\n        location = str(location)\n        if \".py\" in location:\n            name = location.split(\"/\")[-1].split(\".\")[\n                0\n            ]  # get just the file name without path and .py extension\n            _mod_spec = spec_from_file_location(\n                name, location, *args, **kwargs\n            )\n            module = module_from_spec(_mod_spec)\n            _mod_spec.loader.exec_module(module)  # type: ignore\n\n        else:\n            module = types.ModuleType(\"config\")\n            module.__file__ = str(location)\n            try:\n                with open(location) as config_file:\n                    exec(  # nosec\n                        compile(config_file.read(), location, \"exec\"),\n                        module.__dict__,\n                    )\n            except IOError as e:\n                e.strerror = \"Unable to load configuration file (e.strerror)\"\n                raise\n            except Exception as e:\n                raise PyFileError(location) from e\n\n        return module\n    else:\n        try:\n            return import_string(location)\n        except ValueError:\n            raise IOError(\"Unable to load configuration %s\" % str(location))", "is_method": false, "function_description": "Dynamically loads a Python module or configuration from a specified file path. It supports resolving environment variables within the path and can also import modules by string name."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "__repr__", "line_number": 96, "body": "def __repr__(self) -> str:\n        args = \", \".join(\n            [\n                f'{attr}=\"{getattr(self, attr)}\"'\n                if isinstance(getattr(self, attr), str)\n                else f\"{attr}={getattr(self, attr)}\"\n                for attr in (\n                    \"name\",\n                    \"url_prefix\",\n                    \"host\",\n                    \"version\",\n                    \"strict_slashes\",\n                )\n            ]\n        )\n        return f\"Blueprint({args})\"", "is_method": true, "class_name": "Blueprint", "function_description": "Provides a detailed, unambiguous string representation of the Blueprint object, displaying key configuration attributes like name, URL prefix, and version for debugging."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "apps", "line_number": 114, "body": "def apps(self):\n        if not self._apps:\n            raise SanicException(\n                f\"{self} has not yet been registered to an app\"\n            )\n        return self._apps", "is_method": true, "class_name": "Blueprint", "function_description": "Provides access to the Sanic application instances this Blueprint is registered with. It raises an error if the Blueprint has not yet been registered."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "route", "line_number": 121, "body": "def route(self, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().route(*args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "Registers a route with the blueprint, preventing its immediate application to the main app. Routes are applied when the blueprint is registered."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "static", "line_number": 125, "body": "def static(self, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().static(*args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "Registers static resources for the blueprint, overriding the parent's default static registration by setting the 'apply' parameter to false."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "middleware", "line_number": 129, "body": "def middleware(self, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().middleware(*args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "This method provides a specialized middleware invocation for Blueprints, ensuring the 'apply' flag is always `False`. This prevents the immediate application of certain superclass middleware logic."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "listener", "line_number": 133, "body": "def listener(self, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().listener(*args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "This method overrides the parent's listener, ensuring the 'apply' parameter is always false. It enables registering actions or events without immediate execution, deferring their application within the Blueprint."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "exception", "line_number": 137, "body": "def exception(self, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().exception(*args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "Provides a mechanism to register an exception handler specific to this Blueprint, preventing its automatic application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "signal", "line_number": 141, "body": "def signal(self, event: str, *args, **kwargs):\n        kwargs[\"apply\"] = False\n        return super().signal(event, *args, **kwargs)", "is_method": true, "class_name": "Blueprint", "function_description": "This method dispatches an event signal for the Blueprint. It ensures the 'apply' flag is explicitly set to false when forwarding the signal to its parent."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "group", "line_number": 146, "body": "def group(*blueprints, url_prefix=\"\", version=None, strict_slashes=None):\n        \"\"\"\n        Create a list of blueprints, optionally grouping them under a\n        general URL prefix.\n\n        :param blueprints: blueprints to be registered as a group\n        :param url_prefix: URL route to be prepended to all sub-prefixes\n        :param version: API Version to be used for Blueprint group\n        :param strict_slashes: Indicate strict slash termination behavior\n            for URL\n        \"\"\"\n\n        def chain(nested) -> Iterable[Blueprint]:\n            \"\"\"itertools.chain() but leaves strings untouched\"\"\"\n            for i in nested:\n                if isinstance(i, (list, tuple)):\n                    yield from chain(i)\n                elif isinstance(i, BlueprintGroup):\n                    yield from i.blueprints\n                else:\n                    yield i\n\n        bps = BlueprintGroup(\n            url_prefix=url_prefix,\n            version=version,\n            strict_slashes=strict_slashes,\n        )\n        for bp in chain(blueprints):\n            bps.append(bp)\n        return bps", "is_method": true, "class_name": "Blueprint", "function_description": "Creates a BlueprintGroup from multiple blueprints, applying a common URL prefix, API version, and strict slash behavior. It provides structured organization for web application routes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "register", "line_number": 177, "body": "def register(self, app, options):\n        \"\"\"\n        Register the blueprint to the sanic app.\n\n        :param app: Instance of :class:`sanic.app.Sanic` class\n        :param options: Options to be used while registering the\n            blueprint into the app.\n            *url_prefix* - URL Prefix to override the blueprint prefix\n        \"\"\"\n\n        self._apps.add(app)\n        url_prefix = options.get(\"url_prefix\", self.url_prefix)\n\n        routes = []\n        middleware = []\n        exception_handlers = []\n        listeners = defaultdict(list)\n\n        # Routes\n        for future in self._future_routes:\n            # attach the blueprint name to the handler so that it can be\n            # prefixed properly in the router\n            future.handler.__blueprintname__ = self.name\n            # Prepend the blueprint URI prefix if available\n            uri = url_prefix + future.uri if url_prefix else future.uri\n\n            strict_slashes = (\n                self.strict_slashes\n                if future.strict_slashes is None\n                and self.strict_slashes is not None\n                else future.strict_slashes\n            )\n            name = app._generate_name(future.name)\n\n            apply_route = FutureRoute(\n                future.handler,\n                uri[1:] if uri.startswith(\"//\") else uri,\n                future.methods,\n                future.host or self.host,\n                strict_slashes,\n                future.stream,\n                future.version or self.version,\n                name,\n                future.ignore_body,\n                future.websocket,\n                future.subprotocols,\n                future.unquote,\n                future.static,\n            )\n\n            route = app._apply_route(apply_route)\n            operation = (\n                routes.extend if isinstance(route, list) else routes.append\n            )\n            operation(route)\n\n        # Static Files\n        for future in self._future_statics:\n            # Prepend the blueprint URI prefix if available\n            uri = url_prefix + future.uri if url_prefix else future.uri\n            apply_route = FutureStatic(uri, *future[1:])\n            route = app._apply_static(apply_route)\n            routes.append(route)\n\n        route_names = [route.name for route in routes if route]\n\n        # Middleware\n        if route_names:\n            for future in self._future_middleware:\n                middleware.append(app._apply_middleware(future, route_names))\n\n        # Exceptions\n        for future in self._future_exceptions:\n            exception_handlers.append(app._apply_exception_handler(future))\n\n        # Event listeners\n        for listener in self._future_listeners:\n            listeners[listener.event].append(app._apply_listener(listener))\n\n        for signal in self._future_signals:\n            signal.condition.update({\"blueprint\": self.name})\n            app._apply_signal(signal)\n\n        self.routes = [route for route in routes if isinstance(route, Route)]\n\n        # Deprecate these in 21.6\n        self.websocket_routes = [\n            route for route in self.routes if route.ctx.websocket\n        ]\n        self.middlewares = middleware\n        self.exceptions = exception_handlers\n        self.listeners = dict(listeners)", "is_method": true, "class_name": "Blueprint", "function_description": "Integrates the blueprint's defined routes, static files, middleware, and other components into a Sanic application. It enables modular organization and registration of application logic."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "event", "line_number": 278, "body": "def event(self, event: str, timeout: Optional[Union[int, float]] = None):\n        events = set()\n        for app in self.apps:\n            signal = app.signal_router.name_index.get(event)\n            if not signal:\n                raise NotFound(\"Could not find signal %s\" % event)\n            events.add(signal.ctx.event)\n\n        return asyncio.wait(\n            [event.wait() for event in events],\n            return_when=asyncio.FIRST_COMPLETED,\n            timeout=timeout,\n        )", "is_method": true, "class_name": "Blueprint", "function_description": "The Blueprint's `event` method listens for a named asynchronous event to complete across its registered applications, returning the first one that finishes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprints.py", "function": "chain", "line_number": 158, "body": "def chain(nested) -> Iterable[Blueprint]:\n            \"\"\"itertools.chain() but leaves strings untouched\"\"\"\n            for i in nested:\n                if isinstance(i, (list, tuple)):\n                    yield from chain(i)\n                elif isinstance(i, BlueprintGroup):\n                    yield from i.blueprints\n                else:\n                    yield i", "is_method": true, "class_name": "Blueprint", "function_description": "Flattens a nested iterable of Blueprint objects and BlueprintGroups into a single sequence. It extracts blueprints from groups and keeps strings intact."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "loop", "line_number": 188, "body": "def loop(self):\n        \"\"\"\n        Synonymous with asyncio.get_event_loop().\n\n        .. note::\n\n            Only supported when using the `app.run` method.\n        \"\"\"\n        if not self.is_running and self.asgi is False:\n            raise SanicException(\n                \"Loop can only be retrieved after the app has started \"\n                \"running. Not supported with `create_server` function\"\n            )\n        return get_event_loop()", "is_method": true, "class_name": "Sanic", "function_description": "This method provides access to the underlying `asyncio` event loop used by the Sanic application. It allows interaction with asynchronous operations once the app is running."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "add_task", "line_number": 207, "body": "def add_task(self, task) -> None:\n        \"\"\"\n        Schedule a task to run later, after the loop has started.\n        Different from asyncio.ensure_future in that it does not\n        also return a future, and the actual ensure_future call\n        is delayed until before server start.\n\n        `See user guide re: background tasks\n        <https://sanicframework.org/guide/basics/tasks.html#background-tasks>`__\n\n        :param task: future, couroutine or awaitable\n        \"\"\"\n        try:\n            loop = self.loop  # Will raise SanicError if loop is not started\n            self._loop_add_task(task, self, loop)\n        except SanicException:\n            self.listener(\"before_server_start\")(\n                partial(self._loop_add_task, task)\n            )", "is_method": true, "class_name": "Sanic", "function_description": "Schedules an asynchronous task to run in the background after the Sanic server's event loop has started, without immediately returning a future."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "register_listener", "line_number": 227, "body": "def register_listener(self, listener: Callable, event: str) -> Any:\n        \"\"\"\n        Register the listener for a given event.\n\n        :param listener: callable i.e. setup_db(app, loop)\n        :param event: when to register listener i.e. 'before_server_start'\n        :return: listener\n        \"\"\"\n\n        try:\n            _event = ListenerEvent(event)\n        except ValueError:\n            valid = \", \".join(ListenerEvent.__members__.values())\n            raise InvalidUsage(f\"Invalid event: {event}. Use one of: {valid}\")\n\n        self.listeners[_event].append(listener)\n        return listener", "is_method": true, "class_name": "Sanic", "function_description": "This method registers a callable function to be invoked when a specific Sanic server event occurs. It enables developers to customize server behavior by hooking into its lifecycle."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "register_middleware", "line_number": 245, "body": "def register_middleware(self, middleware, attach_to: str = \"request\"):\n        \"\"\"\n        Register an application level middleware that will be attached\n        to all the API URLs registered under this application.\n\n        This method is internally invoked by the :func:`middleware`\n        decorator provided at the app level.\n\n        :param middleware: Callback method to be attached to the\n            middleware\n        :param attach_to: The state at which the middleware needs to be\n            invoked in the lifecycle of an *HTTP Request*.\n            **request** - Invoke before the request is processed\n            **response** - Invoke before the response is returned back\n        :return: decorated method\n        \"\"\"\n        if attach_to == \"request\":\n            if middleware not in self.request_middleware:\n                self.request_middleware.append(middleware)\n        if attach_to == \"response\":\n            if middleware not in self.response_middleware:\n                self.response_middleware.appendleft(middleware)\n        return middleware", "is_method": true, "class_name": "Sanic", "function_description": "Registers application-level middleware to execute automatically during the HTTP request or response lifecycle. This allows custom logic to be applied across all API URLs."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "register_named_middleware", "line_number": 269, "body": "def register_named_middleware(\n        self,\n        middleware,\n        route_names: Iterable[str],\n        attach_to: str = \"request\",\n    ):\n        \"\"\"\n        Method for attaching middleware to specific routes. This is mainly an\n        internal tool for use by Blueprints to attach middleware to only its\n        specfic routes. But, it could be used in a more generalized fashion.\n\n        :param middleware: the middleware to execute\n        :param route_names: a list of the names of the endpoints\n        :type route_names: Iterable[str]\n        :param attach_to: whether to attach to request or response,\n            defaults to \"request\"\n        :type attach_to: str, optional\n        \"\"\"\n        if attach_to == \"request\":\n            for _rn in route_names:\n                if _rn not in self.named_request_middleware:\n                    self.named_request_middleware[_rn] = deque()\n                if middleware not in self.named_request_middleware[_rn]:\n                    self.named_request_middleware[_rn].append(middleware)\n        if attach_to == \"response\":\n            for _rn in route_names:\n                if _rn not in self.named_response_middleware:\n                    self.named_response_middleware[_rn] = deque()\n                if middleware not in self.named_response_middleware[_rn]:\n                    self.named_response_middleware[_rn].appendleft(middleware)\n        return middleware", "is_method": true, "class_name": "Sanic", "function_description": "Registers a middleware function to execute for specific named routes. It allows attaching the middleware to either the request or response phase for targeted processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_apply_exception_handler", "line_number": 301, "body": "def _apply_exception_handler(self, handler: FutureException):\n        \"\"\"Decorate a function to be registered as a handler for exceptions\n\n        :param exceptions: exceptions\n        :return: decorated function\n        \"\"\"\n\n        for exception in handler.exceptions:\n            if isinstance(exception, (tuple, list)):\n                for e in exception:\n                    self.error_handler.add(e, handler.handler)\n            else:\n                self.error_handler.add(exception, handler.handler)\n        return handler.handler", "is_method": true, "class_name": "Sanic", "function_description": "Registers a function to handle specified exceptions within the Sanic application, enabling custom error processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_apply_listener", "line_number": 316, "body": "def _apply_listener(self, listener: FutureListener):\n        return self.register_listener(listener.listener, listener.event)", "is_method": true, "class_name": "Sanic", "function_description": "Integrates a pre-defined FutureListener object into the Sanic application's event handling system by registering its listener function for a specific event."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_apply_route", "line_number": 319, "body": "def _apply_route(self, route: FutureRoute) -> List[Route]:\n        params = route._asdict()\n        websocket = params.pop(\"websocket\", False)\n        subprotocols = params.pop(\"subprotocols\", None)\n\n        if websocket:\n            self.enable_websocket()\n            websocket_handler = partial(\n                self._websocket_handler,\n                route.handler,\n                subprotocols=subprotocols,\n            )\n            websocket_handler.__name__ = route.handler.__name__  # type: ignore\n            websocket_handler.is_websocket = True  # type: ignore\n            params[\"handler\"] = websocket_handler\n\n        routes = self.router.add(**params)\n        if isinstance(routes, Route):\n            routes = [routes]\n        for r in routes:\n            r.ctx.websocket = websocket\n            r.ctx.static = params.get(\"static\", False)\n\n        return routes", "is_method": true, "class_name": "Sanic", "function_description": "Processes a future route definition and adds it to the Sanic application's router. It configures and applies websocket routes, setting their context."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_apply_middleware", "line_number": 347, "body": "def _apply_middleware(\n        self,\n        middleware: FutureMiddleware,\n        route_names: Optional[List[str]] = None,\n    ):\n        if route_names:\n            return self.register_named_middleware(\n                middleware.middleware, route_names, middleware.attach_to\n            )\n        else:\n            return self.register_middleware(\n                middleware.middleware, middleware.attach_to\n            )", "is_method": true, "class_name": "Sanic", "function_description": "This internal method provides the capability to integrate custom processing logic into the Sanic application. It registers a given middleware either globally or for specific named routes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_apply_signal", "line_number": 361, "body": "def _apply_signal(self, signal: FutureSignal) -> Signal:\n        return self.signal_router.add(*signal)", "is_method": true, "class_name": "Sanic", "function_description": "Registers a pending signal with the application's internal signal router for event handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "dispatch", "line_number": 364, "body": "def dispatch(\n        self,\n        event: str,\n        *,\n        condition: Optional[Dict[str, str]] = None,\n        context: Optional[Dict[str, Any]] = None,\n    ) -> Coroutine[Any, Any, Awaitable[Any]]:\n        return self.signal_router.dispatch(\n            event,\n            context=context,\n            condition=condition,\n        )", "is_method": true, "class_name": "Sanic", "function_description": "Dispatches a specified event throughout the Sanic application, including optional conditions and context. It provides a centralized way to broadcast internal signals."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "event", "line_number": 377, "body": "def event(self, event: str, timeout: Optional[Union[int, float]] = None):\n        signal = self.signal_router.name_index.get(event)\n        if not signal:\n            raise NotFound(\"Could not find signal %s\" % event)\n        return wait_for(signal.ctx.event.wait(), timeout=timeout)", "is_method": true, "class_name": "Sanic", "function_description": "Allows the application to asynchronously wait for a specific named internal event to be triggered. It provides an optional timeout for the waiting period."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "enable_websocket", "line_number": 383, "body": "def enable_websocket(self, enable=True):\n        \"\"\"Enable or disable the support for websocket.\n\n        Websocket is enabled automatically if websocket routes are\n        added to the application.\n        \"\"\"\n        if not self.websocket_enabled:\n            # if the server is stopped, we want to cancel any ongoing\n            # websocket tasks, to allow the server to exit promptly\n            self.listener(\"before_server_stop\")(self._cancel_websocket_tasks)\n\n        self.websocket_enabled = enable", "is_method": true, "class_name": "Sanic", "function_description": "Configures the Sanic application to enable or disable WebSocket support. This ensures proper handling and graceful shutdown of WebSocket connections."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "blueprint", "line_number": 396, "body": "def blueprint(self, blueprint, **options):\n        \"\"\"Register a blueprint on the application.\n\n        :param blueprint: Blueprint object or (list, tuple) thereof\n        :param options: option dictionary with blueprint defaults\n        :return: Nothing\n        \"\"\"\n        if isinstance(blueprint, (list, tuple, BlueprintGroup)):\n            for item in blueprint:\n                self.blueprint(item, **options)\n            return\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                'A blueprint with the name \"%s\" is already registered.  '\n                \"Blueprint names must be unique.\" % (blueprint.name,)\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n\n        if (\n            self.strict_slashes is not None\n            and blueprint.strict_slashes is None\n        ):\n            blueprint.strict_slashes = self.strict_slashes\n        blueprint.register(self, options)", "is_method": true, "class_name": "Sanic", "function_description": "Registers one or more blueprints with the Sanic application. It integrates their routes and functionalities into the main application structure for modularity.\nRegisters one or more blueprints with the Sanic application. It integrates their routes and functionalities into the main application structure for modularity."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "url_for", "line_number": 423, "body": "def url_for(self, view_name: str, **kwargs):\n        \"\"\"Build a URL based on a view name and the values provided.\n\n        In order to build a URL, all request parameters must be supplied as\n        keyword arguments, and each parameter must pass the test for the\n        specified parameter type. If these conditions are not met, a\n        `URLBuildError` will be thrown.\n\n        Keyword arguments that are not request parameters will be included in\n        the output URL's query string.\n\n        There are several _special_ keyword arguments that will alter how the\n        URL will be returned:\n\n        1. **_anchor**: ``str`` - Adds an ``#anchor`` to the end\n        2. **_scheme**: ``str`` - Should be either ``\"http\"`` or ``\"https\"``,\n           default is ``\"http\"``\n        3. **_external**: ``bool`` - Whether to return the path or a full URL\n           with scheme and host\n        4. **_host**: ``str`` - Used when one or more hosts are defined for a\n           route to tell Sanic which to use\n           (only applies with ``_external=True``)\n        5. **_server**: ``str`` - If not using ``_host``, this will be used\n           for defining the hostname of the URL\n           (only applies with ``_external=True``),\n           defaults to ``app.config.SERVER_NAME``\n\n        If you want the PORT to appear in your URL, you should set it in:\n\n        .. code-block::\n\n            app.config.SERVER_NAME = \"myserver:7777\"\n\n        `See user guide re: routing\n        <https://sanicframework.org/guide/basics/routing.html#generating-a-url>`__\n\n        :param view_name: string referencing the view name\n        :param kwargs: keys and values that are used to build request\n            parameters and query string arguments.\n\n        :return: the built URL\n\n        Raises:\n            URLBuildError\n        \"\"\"\n        # find the route by the supplied view name\n        kw: Dict[str, str] = {}\n        # special static files url_for\n\n        if \".\" not in view_name:\n            view_name = f\"{self.name}.{view_name}\"\n\n        if view_name.endswith(\".static\"):\n            name = kwargs.pop(\"name\", None)\n            if name:\n                view_name = view_name.replace(\"static\", name)\n            kw.update(name=view_name)\n\n        route = self.router.find_route_by_view_name(view_name, **kw)\n        if not route:\n            raise URLBuildError(\n                f\"Endpoint with name `{view_name}` was not found\"\n            )\n\n        uri = route.path\n\n        if getattr(route.ctx, \"static\", None):\n            filename = kwargs.pop(\"filename\", \"\")\n            # it's static folder\n            if \"__file_uri__\" in uri:\n                folder_ = uri.split(\"<__file_uri__:\", 1)[0]\n                if folder_.endswith(\"/\"):\n                    folder_ = folder_[:-1]\n\n                if filename.startswith(\"/\"):\n                    filename = filename[1:]\n\n                kwargs[\"__file_uri__\"] = filename\n\n        if (\n            uri != \"/\"\n            and uri.endswith(\"/\")\n            and not route.strict\n            and not route.raw_path[:-1]\n        ):\n            uri = uri[:-1]\n\n        if not uri.startswith(\"/\"):\n            uri = f\"/{uri}\"\n\n        out = uri\n\n        # _method is only a placeholder now, don't know how to support it\n        kwargs.pop(\"_method\", None)\n        anchor = kwargs.pop(\"_anchor\", \"\")\n        # _external need SERVER_NAME in config or pass _server arg\n        host = kwargs.pop(\"_host\", None)\n        external = kwargs.pop(\"_external\", False) or bool(host)\n        scheme = kwargs.pop(\"_scheme\", \"\")\n        if route.ctx.hosts and external:\n            if not host and len(route.ctx.hosts) > 1:\n                raise ValueError(\n                    f\"Host is ambiguous: {', '.join(route.ctx.hosts)}\"\n                )\n            elif host and host not in route.ctx.hosts:\n                raise ValueError(\n                    f\"Requested host ({host}) is not available for this \"\n                    f\"route: {route.ctx.hosts}\"\n                )\n            elif not host:\n                host = list(route.ctx.hosts)[0]\n\n        if scheme and not external:\n            raise ValueError(\"When specifying _scheme, _external must be True\")\n\n        netloc = kwargs.pop(\"_server\", None)\n        if netloc is None and external:\n            netloc = host or self.config.get(\"SERVER_NAME\", \"\")\n\n        if external:\n            if not scheme:\n                if \":\" in netloc[:8]:\n                    scheme = netloc[:8].split(\":\", 1)[0]\n                else:\n                    scheme = \"http\"\n\n            if \"://\" in netloc[:8]:\n                netloc = netloc.split(\"://\", 1)[-1]\n\n        # find all the parameters we will need to build in the URL\n        # matched_params = re.findall(self.router.parameter_pattern, uri)\n        route.finalize()\n        for param_info in route.params.values():\n            # name, _type, pattern = self.router.parse_parameter_string(match)\n            # we only want to match against each individual parameter\n\n            try:\n                supplied_param = str(kwargs.pop(param_info.name))\n            except KeyError:\n                raise URLBuildError(\n                    f\"Required parameter `{param_info.name}` was not \"\n                    \"passed to url_for\"\n                )\n\n            # determine if the parameter supplied by the caller\n            # passes the test in the URL\n            if param_info.pattern:\n                passes_pattern = param_info.pattern.match(supplied_param)\n                if not passes_pattern:\n                    if param_info.cast != str:\n                        msg = (\n                            f'Value \"{supplied_param}\" '\n                            f\"for parameter `{param_info.name}` does \"\n                            \"not match pattern for type \"\n                            f\"`{param_info.cast.__name__}`: \"\n                            f\"{param_info.pattern.pattern}\"\n                        )\n                    else:\n                        msg = (\n                            f'Value \"{supplied_param}\" for parameter '\n                            f\"`{param_info.name}` does not satisfy \"\n                            f\"pattern {param_info.pattern.pattern}\"\n                        )\n                    raise URLBuildError(msg)\n\n            # replace the parameter in the URL with the supplied value\n            replacement_regex = f\"(<{param_info.name}.*?>)\"\n            out = re.sub(replacement_regex, supplied_param, out)\n\n        # parse the remainder of the keyword arguments into a querystring\n        query_string = urlencode(kwargs, doseq=True) if kwargs else \"\"\n        # scheme://netloc/path;parameters?query#fragment\n        out = urlunparse((scheme, netloc, out, \"\", query_string, anchor))\n\n        return out", "is_method": true, "class_name": "Sanic", "function_description": "This method generates a URL for a specified view name, dynamically inserting parameters and query strings. It creates both internal paths and full external URLs, simplifying link creation and maintenance within a Sanic application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "test_client", "line_number": 789, "body": "def test_client(self):  # noqa\n        if self._test_client:\n            return self._test_client\n        elif self._test_manager:\n            return self._test_manager.test_client\n        from sanic_testing.testing import SanicTestClient  # type: ignore\n\n        self._test_client = SanicTestClient(self)\n        return self._test_client", "is_method": true, "class_name": "Sanic", "function_description": "This method provides a test client for the Sanic application, facilitating programmatic testing by creating or retrieving a `SanicTestClient` instance for interaction."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "asgi_client", "line_number": 800, "body": "def asgi_client(self):  # noqa\n        \"\"\"\n        A testing client that uses ASGI to reach into the application to\n        execute hanlers.\n\n        :return: testing client\n        :rtype: :class:`SanicASGITestClient`\n        \"\"\"\n        if self._asgi_client:\n            return self._asgi_client\n        elif self._test_manager:\n            return self._test_manager.asgi_client\n        from sanic_testing.testing import SanicASGITestClient  # type: ignore\n\n        self._asgi_client = SanicASGITestClient(self)\n        return self._asgi_client", "is_method": true, "class_name": "Sanic", "function_description": "Provides an ASGI-based testing client for the Sanic application, enabling direct execution of handlers for testing purposes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "run", "line_number": 821, "body": "def run(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        *,\n        debug: bool = False,\n        auto_reload: Optional[bool] = None,\n        ssl: Union[dict, SSLContext, None] = None,\n        sock: Optional[socket] = None,\n        workers: int = 1,\n        protocol: Optional[Type[Protocol]] = None,\n        backlog: int = 100,\n        register_sys_signals: bool = True,\n        access_log: Optional[bool] = None,\n        unix: Optional[str] = None,\n        loop: None = None,\n    ) -> None:\n        \"\"\"\n        Run the HTTP Server and listen until keyboard interrupt or term\n        signal. On termination, drain connections before closing.\n\n        :param host: Address to host on\n        :type host: str\n        :param port: Port to host on\n        :type port: int\n        :param debug: Enables debug output (slows server)\n        :type debug: bool\n        :param auto_reload: Reload app whenever its source code is changed.\n                            Enabled by default in debug mode.\n        :type auto_relaod: bool\n        :param ssl: SSLContext, or location of certificate and key\n                    for SSL encryption of worker(s)\n        :type ssl: SSLContext or dict\n        :param sock: Socket for the server to accept connections from\n        :type sock: socket\n        :param workers: Number of processes received before it is respected\n        :type workers: int\n        :param protocol: Subclass of asyncio Protocol class\n        :type protocol: type[Protocol]\n        :param backlog: a number of unaccepted connections that the system\n                        will allow before refusing new connections\n        :type backlog: int\n        :param register_sys_signals: Register SIG* events\n        :type register_sys_signals: bool\n        :param access_log: Enables writing access logs (slows server)\n        :type access_log: bool\n        :param unix: Unix socket to listen on instead of TCP port\n        :type unix: str\n        :return: Nothing\n        \"\"\"\n        if loop is not None:\n            raise TypeError(\n                \"loop is not a valid argument. To use an existing loop, \"\n                \"change to create_server().\\nSee more: \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/deploying.html\"\n                \"#asynchronous-support\"\n            )\n\n        if auto_reload or auto_reload is None and debug:\n            if os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\":\n                return reloader_helpers.watchdog(1.0)\n\n        if sock is None:\n            host, port = host or \"127.0.0.1\", port or 8000\n\n        if protocol is None:\n            protocol = (\n                WebSocketProtocol if self.websocket_enabled else HttpProtocol\n            )\n        # if access_log is passed explicitly change config.ACCESS_LOG\n        if access_log is not None:\n            self.config.ACCESS_LOG = access_log\n\n        server_settings = self._helper(\n            host=host,\n            port=port,\n            debug=debug,\n            ssl=ssl,\n            sock=sock,\n            unix=unix,\n            workers=workers,\n            protocol=protocol,\n            backlog=backlog,\n            register_sys_signals=register_sys_signals,\n            auto_reload=auto_reload,\n        )\n\n        try:\n            self.is_running = True\n            self.is_stopping = False\n            if workers > 1 and os.name != \"posix\":\n                logger.warn(\n                    f\"Multiprocessing is currently not supported on {os.name},\"\n                    \" using workers=1 instead\"\n                )\n                workers = 1\n            if workers == 1:\n                serve_single(server_settings)\n            else:\n                serve_multiple(server_settings, workers)\n        except BaseException:\n            error_logger.exception(\n                \"Experienced exception while trying to serve\"\n            )\n            raise\n        finally:\n            self.is_running = False\n        logger.info(\"Server Stopped\")", "is_method": true, "class_name": "Sanic", "function_description": "This method starts the Sanic HTTP server, making the application available on a specified host and port. It manages server lifecycle, supports various configurations like SSL, multiple workers, and auto-reloading for development."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "stop", "line_number": 930, "body": "def stop(self):\n        \"\"\"\n        This kills the Sanic\n        \"\"\"\n        if not self.is_stopping:\n            self.is_stopping = True\n            get_event_loop().stop()", "is_method": true, "class_name": "Sanic", "function_description": "This method stops the Sanic application by halting its underlying event loop. It provides a clean shutdown mechanism for the running server instance."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_helper", "line_number": 1082, "body": "def _helper(\n        self,\n        host=None,\n        port=None,\n        debug=False,\n        ssl=None,\n        sock=None,\n        unix=None,\n        workers=1,\n        loop=None,\n        protocol=HttpProtocol,\n        backlog=100,\n        register_sys_signals=True,\n        run_async=False,\n        auto_reload=False,\n    ):\n        \"\"\"Helper function used by `run` and `create_server`.\"\"\"\n\n        self.listeners[\"before_server_start\"] = [\n            self.finalize\n        ] + self.listeners[\"before_server_start\"]\n\n        if isinstance(ssl, dict):\n            # try common aliaseses\n            cert = ssl.get(\"cert\") or ssl.get(\"certificate\")\n            key = ssl.get(\"key\") or ssl.get(\"keyfile\")\n            if cert is None or key is None:\n                raise ValueError(\"SSLContext or certificate and key required.\")\n            context = create_default_context(purpose=Purpose.CLIENT_AUTH)\n            context.load_cert_chain(cert, keyfile=key)\n            ssl = context\n        if self.config.PROXIES_COUNT and self.config.PROXIES_COUNT < 0:\n            raise ValueError(\n                \"PROXIES_COUNT cannot be negative. \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/config.html\"\n                \"#proxy-configuration\"\n            )\n\n        self.error_handler.debug = debug\n        self.debug = debug\n\n        server_settings = {\n            \"protocol\": protocol,\n            \"host\": host,\n            \"port\": port,\n            \"sock\": sock,\n            \"unix\": unix,\n            \"ssl\": ssl,\n            \"app\": self,\n            \"signal\": ServerSignal(),\n            \"loop\": loop,\n            \"register_sys_signals\": register_sys_signals,\n            \"backlog\": backlog,\n        }\n\n        # Register start/stop events\n\n        for event_name, settings_name, reverse in (\n            (\"before_server_start\", \"before_start\", False),\n            (\"after_server_start\", \"after_start\", False),\n            (\"before_server_stop\", \"before_stop\", True),\n            (\"after_server_stop\", \"after_stop\", True),\n            (\"main_process_start\", \"main_start\", False),\n            (\"main_process_stop\", \"main_stop\", True),\n        ):\n            listeners = self.listeners[event_name].copy()\n            if reverse:\n                listeners.reverse()\n            # Prepend sanic to the arguments when listeners are triggered\n            listeners = [partial(listener, self) for listener in listeners]\n            server_settings[settings_name] = listeners\n\n        if self.configure_logging and debug:\n            logger.setLevel(logging.DEBUG)\n\n        if (\n            self.config.LOGO\n            and os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\"\n        ):\n            logger.debug(\n                self.config.LOGO\n                if isinstance(self.config.LOGO, str)\n                else BASE_LOGO\n            )\n\n        if run_async:\n            server_settings[\"run_async\"] = True\n\n        # Serve\n        if host and port:\n            proto = \"http\"\n            if ssl is not None:\n                proto = \"https\"\n            if unix:\n                logger.info(f\"Goin' Fast @ {unix} {proto}://...\")\n            else:\n                logger.info(f\"Goin' Fast @ {proto}://{host}:{port}\")\n\n        return server_settings", "is_method": true, "class_name": "Sanic", "function_description": "This helper method of the Sanic class prepares and configures all necessary server settings for a Sanic application. It centralizes setup logic, including SSL, debugging, and event listeners, before the server is initiated."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_build_endpoint_name", "line_number": 1182, "body": "def _build_endpoint_name(self, *parts):\n        parts = [self.name, *parts]\n        return \".\".join(parts)", "is_method": true, "class_name": "Sanic", "function_description": "Generates a standardized, dot-separated endpoint name. It combines the instance's base name with provided parts, useful for internal route or blueprint identification."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_loop_add_task", "line_number": 1187, "body": "def _loop_add_task(cls, task, app, loop):\n        if callable(task):\n            try:\n                loop.create_task(task(app))\n            except TypeError:\n                loop.create_task(task())\n        else:\n            loop.create_task(task)", "is_method": true, "class_name": "Sanic", "function_description": "This internal Sanic utility schedules a given task onto the event loop. It intelligently handles callable tasks by executing them, potentially with the application instance, before creating the asyncio task."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "_cancel_websocket_tasks", "line_number": 1197, "body": "def _cancel_websocket_tasks(cls, app, loop):\n        for task in app.websocket_tasks:\n            task.cancel()", "is_method": true, "class_name": "Sanic", "function_description": "Cancels all active websocket tasks associated with a Sanic application. This ensures proper cleanup of ongoing connections, typically during shutdown."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "update_config", "line_number": 1222, "body": "def update_config(self, config: Union[bytes, str, dict, Any]):\n        \"\"\"\n        Update app.config. Full implementation can be found in the user guide.\n\n        `See user guide re: configuration\n        <https://sanicframework.org/guide/deployment/configuration.html#basics>`__\n        \"\"\"\n\n        self.config.update_config(config)", "is_method": true, "class_name": "Sanic", "function_description": "Provides the capability to update the Sanic application's configuration settings. It allows external sources to dynamically modify or extend the app's operational parameters."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "register_app", "line_number": 1237, "body": "def register_app(cls, app: \"Sanic\") -> None:\n        \"\"\"\n        Register a Sanic instance\n        \"\"\"\n        if not isinstance(app, cls):\n            raise SanicException(\"Registered app must be an instance of Sanic\")\n\n        name = app.name\n        if name in cls._app_registry and not cls.test_mode:\n            raise SanicException(f'Sanic app name \"{name}\" already in use.')\n\n        cls._app_registry[name] = app", "is_method": true, "class_name": "Sanic", "function_description": "Registers a Sanic application instance by its name into a class-level registry. This ensures unique naming and facilitates the management of multiple Sanic applications."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/app.py", "function": "get_app", "line_number": 1251, "body": "def get_app(\n        cls, name: Optional[str] = None, *, force_create: bool = False\n    ) -> \"Sanic\":\n        \"\"\"\n        Retrieve an instantiated Sanic instance\n        \"\"\"\n        if name is None:\n            if len(cls._app_registry) > 1:\n                raise SanicException(\n                    'Multiple Sanic apps found, use Sanic.get_app(\"app_name\")'\n                )\n            elif len(cls._app_registry) == 0:\n                raise SanicException(\"No Sanic apps have been registered.\")\n            else:\n                return list(cls._app_registry.values())[0]\n        try:\n            return cls._app_registry[name]\n        except KeyError:\n            if force_create:\n                return cls(name)\n            raise SanicException(f'Sanic app name \"{name}\" not found.')", "is_method": true, "class_name": "Sanic", "function_description": "Retrieves an existing Sanic application instance by name from the registry. It can optionally create a new application if not found and `force_create` is enabled."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/asgi.py", "function": "respond", "line_number": 178, "body": "def respond(self, response):\n        response.stream, self.response = self, response\n        return response", "is_method": true, "class_name": "ASGIApp", "function_description": "Configures the provided response object for streaming. It assigns the ASGI application instance as the source for the response body."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/exceptions.py", "function": "add_status_code", "line_number": 9, "body": "def add_status_code(code, quiet=None):\n    \"\"\"\n    Decorator used for adding exceptions to :class:`SanicException`.\n    \"\"\"\n\n    def class_decorator(cls):\n        cls.status_code = code\n        if quiet or quiet is None and code != 500:\n            cls.quiet = True\n        _sanic_exceptions[code] = cls\n        return cls\n\n    return class_decorator", "is_method": false, "function_description": "This decorator assigns an HTTP status code to a custom exception class, registering it within the Sanic framework. It enables the framework to map specific HTTP error codes directly to custom exception types."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/exceptions.py", "function": "abort", "line_number": 234, "body": "def abort(status_code: int, message: Optional[Union[str, bytes]] = None):\n    \"\"\"\n    Raise an exception based on SanicException. Returns the HTTP response\n    message appropriate for the given status code, unless provided.\n\n    STATUS_CODES from sanic.helpers for the given status code.\n\n    :param status_code: The HTTP status code to return.\n    :param message: The HTTP response body. Defaults to the messages in\n    \"\"\"\n    if message is None:\n        msg: bytes = STATUS_CODES[status_code]\n        # These are stored as bytes in the STATUS_CODES dict\n        message = msg.decode(\"utf8\")\n    sanic_exception = _sanic_exceptions.get(status_code, SanicException)\n    raise sanic_exception(message=message, status_code=status_code)", "is_method": false, "function_description": "Raises an HTTP exception with a specified status code and message, effectively aborting the current request processing. It provides a structured way to signal errors in a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/exceptions.py", "function": "class_decorator", "line_number": 14, "body": "def class_decorator(cls):\n        cls.status_code = code\n        if quiet or quiet is None and code != 500:\n            cls.quiet = True\n        _sanic_exceptions[code] = cls\n        return cls", "is_method": false, "function_description": "This function serves as a class decorator to register a custom exception class with an HTTP status code. It assigns the status code and an optional quiet flag to the decorated class for internal framework handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/base.py", "function": "__str__", "line_number": 24, "body": "def __str__(self) -> str:\n        return f\"<{self.__class__.__name__} {self.name}>\"", "is_method": true, "class_name": "BaseSanic", "function_description": "Provides a human-readable string representation of the `BaseSanic` object. It includes the object's class name and its configured name for clear identification, useful for logging or debugging."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/base.py", "function": "__repr__", "line_number": 27, "body": "def __repr__(self) -> str:\n        return f'{self.__class__.__name__}(name=\"{self.name}\")'", "is_method": true, "class_name": "BaseSanic", "function_description": "Provides a developer-friendly string representation of the BaseSanic object. It includes the class name and the instance's 'name' attribute for clear identification."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/base.py", "function": "__setattr__", "line_number": 30, "body": "def __setattr__(self, name: str, value: Any) -> None:\n        # This is a temporary compat layer so we can raise a warning until\n        # setting attributes on the app instance can be removed and deprecated\n        # with a proper implementation of __slots__\n        if name not in self.__fake_slots__:\n            warn(\n                f\"Setting variables on {self.__class__.__name__} instances is \"\n                \"deprecated and will be removed in version 21.9. You should \"\n                f\"change your {self.__class__.__name__} instance to use \"\n                f\"instance.ctx.{name} instead.\"\n            )\n        super().__setattr__(name, value)", "is_method": true, "class_name": "BaseSanic", "function_description": "Manages attribute assignments on `BaseSanic` instances by issuing a deprecation warning for direct assignments. It encourages users to store custom data via `instance.ctx` for future compatibility."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/__main__.py", "function": "main", "line_number": 24, "body": "def main():\n    parser = SanicArgumentParser(\n        prog=\"sanic\",\n        description=BASE_LOGO,\n        formatter_class=RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        \"-H\",\n        \"--host\",\n        dest=\"host\",\n        type=str,\n        default=\"127.0.0.1\",\n        help=\"host address [default 127.0.0.1]\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--port\",\n        dest=\"port\",\n        type=int,\n        default=8000,\n        help=\"port to serve on [default 8000]\",\n    )\n    parser.add_argument(\n        \"-u\",\n        \"--unix\",\n        dest=\"unix\",\n        type=str,\n        default=\"\",\n        help=\"location of unix socket\",\n    )\n    parser.add_argument(\n        \"--cert\", dest=\"cert\", type=str, help=\"location of certificate for SSL\"\n    )\n    parser.add_argument(\n        \"--key\", dest=\"key\", type=str, help=\"location of keyfile for SSL.\"\n    )\n    parser.add_argument(\n        \"-w\",\n        \"--workers\",\n        dest=\"workers\",\n        type=int,\n        default=1,\n        help=\"number of worker processes [default 1]\",\n    )\n    parser.add_argument(\"--debug\", dest=\"debug\", action=\"store_true\")\n    parser.add_bool_arguments(\n        \"--access-logs\", dest=\"access_log\", help=\"display access logs\"\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--version\",\n        action=\"version\",\n        version=f\"Sanic {__version__}\",\n    )\n    parser.add_argument(\n        \"module\", help=\"path to your Sanic app. Example: path.to.server:app\"\n    )\n    args = parser.parse_args()\n\n    try:\n        module_path = os.path.abspath(os.getcwd())\n        if module_path not in sys.path:\n            sys.path.append(module_path)\n\n        if \":\" in args.module:\n            module_name, app_name = args.module.rsplit(\":\", 1)\n        else:\n            module_parts = args.module.split(\".\")\n            module_name = \".\".join(module_parts[:-1])\n            app_name = module_parts[-1]\n\n        module = import_module(module_name)\n        app = getattr(module, app_name, None)\n        app_name = type(app).__name__\n\n        if not isinstance(app, Sanic):\n            raise ValueError(\n                f\"Module is not a Sanic app, it is a {app_name}.  \"\n                f\"Perhaps you meant {args.module}.app?\"\n            )\n        if args.cert is not None or args.key is not None:\n            ssl = {\n                \"cert\": args.cert,\n                \"key\": args.key,\n            }  # type: Optional[Dict[str, Any]]\n        else:\n            ssl = None\n\n        app.run(\n            host=args.host,\n            port=args.port,\n            unix=args.unix,\n            workers=args.workers,\n            debug=args.debug,\n            access_log=args.access_log,\n            ssl=ssl,\n        )\n    except ImportError as e:\n        logger.error(\n            f\"No module named {e.name} found.\\n\"\n            f\"  Example File: project/sanic_server.py -> app\\n\"\n            f\"  Example Module: project.sanic_server.app\"\n        )\n    except ValueError:\n        logger.exception(\"Failed to run app\")", "is_method": false, "function_description": "This `main` function serves as the command-line entry point for a Sanic application. It parses server configuration arguments like host and port, then dynamically loads and runs the specified Sanic app."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/__main__.py", "function": "add_bool_arguments", "line_number": 15, "body": "def add_bool_arguments(self, *args, **kwargs):\n        group = self.add_mutually_exclusive_group()\n        group.add_argument(*args, action=\"store_true\", **kwargs)\n        kwargs[\"help\"] = \"no \" + kwargs[\"help\"]\n        group.add_argument(\n            \"--no-\" + args[0][2:], *args[1:], action=\"store_false\", **kwargs\n        )", "is_method": true, "class_name": "SanicArgumentParser", "function_description": "Simplifies adding boolean command-line arguments by creating mutually exclusive `--flag` and `--no-flag` options. It streamlines argument parsing for on/off features."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "stream", "line_number": 69, "body": "def stream(func):\n    func.is_stream = True\n    return func", "is_method": false, "function_description": "A decorator that designates a function as streamable. It enables other parts of a system to recognize and process the function's output as a stream."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "dispatch_request", "line_number": 43, "body": "def dispatch_request(self, request, *args, **kwargs):\n        handler = getattr(self, request.method.lower(), None)\n        return handler(request, *args, **kwargs)", "is_method": true, "class_name": "HTTPMethodView", "function_description": "Routes incoming HTTP requests to the corresponding method handler (e.g., get(), post()) within the view. This enables method-specific request processing for a single URL endpoint."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "as_view", "line_number": 48, "body": "def as_view(cls, *class_args, **class_kwargs):\n        \"\"\"Return view function for use with the routing system, that\n        dispatches request to appropriate handler method.\n        \"\"\"\n\n        def view(*args, **kwargs):\n            self = view.view_class(*class_args, **class_kwargs)\n            return self.dispatch_request(*args, **kwargs)\n\n        if cls.decorators:\n            view.__module__ = cls.__module__\n            for decorator in cls.decorators:\n                view = decorator(view)\n\n        view.view_class = cls\n        view.__doc__ = cls.__doc__\n        view.__module__ = cls.__module__\n        view.__name__ = cls.__name__\n        return view", "is_method": true, "class_name": "HTTPMethodView", "function_description": "Transforms a class-based view into a callable function suitable for web routing systems. It dynamically dispatches incoming requests to the appropriate handler method within the view class instance."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "__name__", "line_number": 95, "body": "def __name__(self):\n        return self.name", "is_method": true, "class_name": "CompositionView", "function_description": "Provides the identifying name of the CompositionView object."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "add", "line_number": 98, "body": "def add(self, methods, handler, stream=False):\n        if stream:\n            handler.is_stream = stream\n        for method in methods:\n            if method not in HTTP_METHODS:\n                raise InvalidUsage(f\"{method} is not a valid HTTP method.\")\n\n            if method in self.handlers:\n                raise InvalidUsage(f\"Method {method} is already registered.\")\n            self.handlers[method] = handler", "is_method": true, "class_name": "CompositionView", "function_description": "Registers a request handler to respond to specified HTTP methods within the view. It ensures method validity and uniqueness, optionally marking handlers for streaming."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "__call__", "line_number": 109, "body": "def __call__(self, request, *args, **kwargs):\n        handler = self.handlers[request.method.upper()]\n        return handler(request, *args, **kwargs)", "is_method": true, "class_name": "CompositionView", "function_description": "Routes an incoming request to the specific handler associated with its HTTP method. It enables CompositionView instances to act as callable dispatchers."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/views.py", "function": "view", "line_number": 53, "body": "def view(*args, **kwargs):\n            self = view.view_class(*class_args, **class_kwargs)\n            return self.dispatch_request(*args, **kwargs)", "is_method": true, "class_name": "HTTPMethodView", "function_description": "This method instantiates the view class and dispatches the incoming web request to its `dispatch_request` method. It serves as the primary entry point for handling requests in a class-based view system."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/handlers.py", "function": "add", "line_number": 35, "body": "def add(self, exception, handler):\n        \"\"\"\n        Add a new exception handler to an already existing handler object.\n\n        :param exception: Type of exception that need to be handled\n        :param handler: Reference to the method that will handle the exception\n\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n        :type handler: ``function``\n\n        :return: None\n        \"\"\"\n        self.handlers.append((exception, handler))", "is_method": true, "class_name": "ErrorHandler", "function_description": "The `add` method allows registering a specific function to handle a given exception type. This extends the error handler's ability to customize responses for various runtime errors."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/handlers.py", "function": "lookup", "line_number": 50, "body": "def lookup(self, exception):\n        \"\"\"\n        Lookup the existing instance of :class:`ErrorHandler` and fetch the\n        registered handler for a specific type of exception.\n\n        This method leverages a dict lookup to speedup the retrieval process.\n\n        :param exception: Type of exception\n\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n\n        :return: Registered function if found ``None`` otherwise\n        \"\"\"\n        handler = self.cached_handlers.get(type(exception), self._missing)\n        if handler is self._missing:\n            for exception_class, handler in self.handlers:\n                if isinstance(exception, exception_class):\n                    self.cached_handlers[type(exception)] = handler\n                    return handler\n            self.cached_handlers[type(exception)] = None\n            handler = None\n        return handler", "is_method": true, "class_name": "ErrorHandler", "function_description": "This method retrieves the specific handler function registered for a given exception type. It leverages a cache to speed up subsequent lookups for the same exception."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/handlers.py", "function": "response", "line_number": 74, "body": "def response(self, request, exception):\n        \"\"\"Fetches and executes an exception handler and returns a response\n        object\n\n        :param request: Instance of :class:`sanic.request.Request`\n        :param exception: Exception to handle\n\n        :type request: :class:`sanic.request.Request`\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n\n        :return: Wrap the return value obtained from :func:`default`\n            or registered handler for that type of exception.\n        \"\"\"\n        handler = self.lookup(exception)\n        response = None\n        try:\n            if handler:\n                response = handler(request, exception)\n            if response is None:\n                response = self.default(request, exception)\n        except Exception:\n            self.log(format_exc())\n            try:\n                url = repr(request.url)\n            except AttributeError:\n                url = \"unknown\"\n            response_message = (\n                \"Exception raised in exception handler \" '\"%s\" for uri: %s'\n            )\n            logger.exception(response_message, handler.__name__, url)\n\n            if self.debug:\n                return text(response_message % (handler.__name__, url), 500)\n            else:\n                return text(\"An error occurred while handling an error\", 500)\n        return response", "is_method": true, "class_name": "ErrorHandler", "function_description": "Manages web request exceptions by dispatching to a specific or default handler, returning an appropriate HTTP response. It also gracefully handles errors encountered during the error handling process."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/handlers.py", "function": "default", "line_number": 117, "body": "def default(self, request, exception):\n        \"\"\"\n        Provide a default behavior for the objects of :class:`ErrorHandler`.\n        If a developer chooses to extent the :class:`ErrorHandler` they can\n        provide a custom implementation for this method to behave in a way\n        they see fit.\n\n        :param request: Incoming request\n        :param exception: Exception object\n\n        :type request: :class:`sanic.request.Request`\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n        :return:\n        \"\"\"\n        quiet = getattr(exception, \"quiet\", False)\n        if quiet is False:\n            try:\n                url = repr(request.url)\n            except AttributeError:\n                url = \"unknown\"\n\n            self.log(format_exc())\n            logger.exception(\"Exception occurred while handling uri: %s\", url)\n\n        return exception_response(request, exception, self.debug)", "is_method": true, "class_name": "ErrorHandler", "function_description": "Serves as the default error handling mechanism for the `ErrorHandler` class. It logs exceptions during web requests and generates a suitable error response."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/handlers.py", "function": "__bool__", "line_number": 212, "body": "def __bool__(self):\n        return self.size > 0", "is_method": true, "class_name": "ContentRangeHandler", "function_description": "Defines the boolean evaluation for `ContentRangeHandler` objects. It indicates if the content range has a size greater than zero, signifying a non-empty range."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/config.py", "function": "__getattr__", "line_number": 57, "body": "def __getattr__(self, attr):\n        try:\n            return self[attr]\n        except KeyError as ke:\n            raise AttributeError(f\"Config has no '{ke.args[0]}'\")", "is_method": true, "class_name": "Config", "function_description": "Allows configuration values to be accessed using object attribute notation (e.g., `config.setting_name`). It translates missing key errors into standard `AttributeError` for better usability."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/config.py", "function": "__setattr__", "line_number": 63, "body": "def __setattr__(self, attr, value):\n        self[attr] = value", "is_method": true, "class_name": "Config", "function_description": "This method customizes attribute assignment for the Config class, allowing values to be set using dot notation (e.g., `config.key = value`) while storing them as dictionary entries."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/config.py", "function": "load_environment_vars", "line_number": 66, "body": "def load_environment_vars(self, prefix=SANIC_PREFIX):\n        \"\"\"\n        Looks for prefixed environment variables and applies\n        them to the configuration if present. This is called automatically when\n        Sanic starts up to load environment variables into config.\n\n        It will automatically hyrdate the following types:\n\n        - ``int``\n        - ``float``\n        - ``bool``\n\n        Anything else will be imported as a ``str``.\n        \"\"\"\n        for k, v in environ.items():\n            if k.startswith(prefix):\n                _, config_key = k.split(prefix, 1)\n                try:\n                    self[config_key] = int(v)\n                except ValueError:\n                    try:\n                        self[config_key] = float(v)\n                    except ValueError:\n                        try:\n                            self[config_key] = str_to_bool(v)\n                        except ValueError:\n                            self[config_key] = v", "is_method": true, "class_name": "Config", "function_description": "This method populates the configuration object with prefixed environment variables, automatically converting values to integers, floats, or booleans where possible."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/config.py", "function": "update_config", "line_number": 94, "body": "def update_config(self, config: Union[bytes, str, dict, Any]):\n        \"\"\"\n        Update app.config.\n\n        .. note::\n\n            Only upper case settings are considered\n\n        You can upload app config by providing path to py file\n        holding settings.\n\n        .. code-block:: python\n\n            # /some/py/file\n            A = 1\n            B = 2\n\n        .. code-block:: python\n\n            config.update_config(\"${some}/py/file\")\n\n        Yes you can put environment variable here, but they must be provided\n        in format: ``${some_env_var}``, and mark that ``$some_env_var`` is\n        treated as plain string.\n\n        You can upload app config by providing dict holding settings.\n\n        .. code-block:: python\n\n            d = {\"A\": 1, \"B\": 2}\n            config.update_config(d)\n\n        You can upload app config by providing any object holding settings,\n        but in such case config.__dict__ will be used as dict holding settings.\n\n        .. code-block:: python\n\n            class C:\n                A = 1\n                B = 2\n\n            config.update_config(C)\n\n        `See user guide re: config\n        <https://sanicframework.org/guide/deployment/configuration.html>`__\n        \"\"\"\n\n        if isinstance(config, (bytes, str, Path)):\n            config = load_module_from_file_location(location=config)\n\n        if not isinstance(config, dict):\n            cfg = {}\n            if not isclass(config):\n                cfg.update(\n                    {\n                        key: getattr(config, key)\n                        for key in config.__class__.__dict__.keys()\n                    }\n                )\n\n            config = dict(config.__dict__)\n            config.update(cfg)\n\n        config = dict(filter(lambda i: i[0].isupper(), config.items()))\n\n        self.update(config)", "is_method": true, "class_name": "Config", "function_description": "Updates the application's configuration by flexibly loading settings from file paths, dictionaries, or objects. It applies only uppercase keys to the config."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/helpers.py", "function": "has_message_body", "line_number": 103, "body": "def has_message_body(status):\n    \"\"\"\n    According to the following RFC message body and length SHOULD NOT\n    be included in responses status 1XX, 204 and 304.\n    https://tools.ietf.org/html/rfc2616#section-4.4\n    https://tools.ietf.org/html/rfc2616#section-4.3\n    \"\"\"\n    return status not in (204, 304) and not (100 <= status < 200)", "is_method": false, "function_description": "Determines if an HTTP response with the given status code is expected to contain a message body, based on RFC specifications. Useful for validating or constructing HTTP messages."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/helpers.py", "function": "is_entity_header", "line_number": 113, "body": "def is_entity_header(header):\n    \"\"\"Checks if the given header is an Entity Header\"\"\"\n    return header.lower() in _ENTITY_HEADERS", "is_method": false, "function_description": "Determines if a given string represents an entity-specific header, useful for classifying and processing various header types."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/helpers.py", "function": "is_hop_by_hop_header", "line_number": 118, "body": "def is_hop_by_hop_header(header):\n    \"\"\"Checks if the given header is a Hop By Hop header\"\"\"\n    return header.lower() in _HOP_BY_HOP_HEADERS", "is_method": false, "function_description": "This function checks if a given HTTP header is a \"Hop-by-Hop\" type. It helps network intermediaries like proxies correctly process or remove connection-specific headers."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/helpers.py", "function": "remove_entity_headers", "line_number": 123, "body": "def remove_entity_headers(headers, allowed=(\"content-location\", \"expires\")):\n    \"\"\"\n    Removes all the entity headers present in the headers given.\n    According to RFC 2616 Section 10.3.5,\n    Content-Location and Expires are allowed as for the\n    \"strong cache validator\".\n    https://tools.ietf.org/html/rfc2616#section-10.3.5\n\n    returns the headers without the entity headers\n    \"\"\"\n    allowed = set([h.lower() for h in allowed])\n    headers = {\n        header: value\n        for header, value in headers.items()\n        if not is_entity_header(header) or header.lower() in allowed\n    }\n    return headers", "is_method": false, "function_description": "Removes most HTTP entity headers from a given set, retaining only \"Content-Location\" and \"Expires\" as allowed for strong cache validation according to RFC 2616."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/helpers.py", "function": "import_string", "line_number": 142, "body": "def import_string(module_name, package=None):\n    \"\"\"\n    import a module or class by string path.\n\n    :module_name: str with path of module or path to import and\n    instanciate a class\n    :returns: a module object or one instance from class if\n    module_name is a valid path to class\n\n    \"\"\"\n    module, klass = module_name.rsplit(\".\", 1)\n    module = import_module(module, package=package)\n    obj = getattr(module, klass)\n    if ismodule(obj):\n        return obj\n    return obj()", "is_method": false, "function_description": "This function dynamically imports a Python module or retrieves/instantiates a class from its full string path. It enables loading code or creating objects based on textual configurations."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "_get", "line_number": 29, "body": "def _get(\n        self, path: str, method: str, host: Optional[str]\n    ) -> Tuple[Route, RouteHandler, Dict[str, Any]]:\n        try:\n            return self.resolve(\n                path=path,\n                method=method,\n                extra={\"host\": host},\n            )\n        except RoutingNotFound as e:\n            raise NotFound(\"Requested URL {} not found\".format(e.path))\n        except NoMethod as e:\n            raise MethodNotSupported(\n                \"Method {} not allowed for URL {}\".format(method, path),\n                method=method,\n                allowed_methods=e.allowed_methods,\n            )", "is_method": true, "class_name": "Router", "function_description": "This internal method of the Router class resolves an incoming request's path, method, and host to a specific route. It translates internal routing failures into appropriate HTTP-like exceptions for the client."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "get", "line_number": 48, "body": "def get(  # type: ignore\n        self, path: str, method: str, host: Optional[str]\n    ) -> Tuple[Route, RouteHandler, Dict[str, Any]]:\n        \"\"\"\n        Retrieve a `Route` object containg the details about how to handle\n        a response for a given request\n\n        :param request: the incoming request object\n        :type request: Request\n        :return: details needed for handling the request and returning the\n            correct response\n        :rtype: Tuple[ Route, RouteHandler, Dict[str, Any]]\n        \"\"\"\n        return self._get(path, method, host)", "is_method": true, "class_name": "Router", "function_description": "This method retrieves the route, handler, and parameters necessary to process an incoming web request based on its path, method, and host. It maps the request to the appropriate logic for handling."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "add", "line_number": 63, "body": "def add(  # type: ignore\n        self,\n        uri: str,\n        methods: Iterable[str],\n        handler: RouteHandler,\n        host: Optional[Union[str, Iterable[str]]] = None,\n        strict_slashes: bool = False,\n        stream: bool = False,\n        ignore_body: bool = False,\n        version: Union[str, float, int] = None,\n        name: Optional[str] = None,\n        unquote: bool = False,\n        static: bool = False,\n    ) -> Union[Route, List[Route]]:\n        \"\"\"\n        Add a handler to the router\n\n        :param uri: the path of the route\n        :type uri: str\n        :param methods: the types of HTTP methods that should be attached,\n            example: ``[\"GET\", \"POST\", \"OPTIONS\"]``\n        :type methods: Iterable[str]\n        :param handler: the sync or async function to be executed\n        :type handler: RouteHandler\n        :param host: host that the route should be on, defaults to None\n        :type host: Optional[str], optional\n        :param strict_slashes: whether to apply strict slashes, defaults\n            to False\n        :type strict_slashes: bool, optional\n        :param stream: whether to stream the response, defaults to False\n        :type stream: bool, optional\n        :param ignore_body: whether the incoming request body should be read,\n            defaults to False\n        :type ignore_body: bool, optional\n        :param version: a version modifier for the uri, defaults to None\n        :type version: Union[str, float, int], optional\n        :param name: an identifying name of the route, defaults to None\n        :type name: Optional[str], optional\n        :return: the route object\n        :rtype: Route\n        \"\"\"\n        if version is not None:\n            version = str(version).strip(\"/\").lstrip(\"v\")\n            uri = \"/\".join([f\"/v{version}\", uri.lstrip(\"/\")])\n\n        params = dict(\n            path=uri,\n            handler=handler,\n            methods=methods,\n            name=name,\n            strict=strict_slashes,\n            unquote=unquote,\n        )\n\n        if isinstance(host, str):\n            hosts = [host]\n        else:\n            hosts = host or [None]  # type: ignore\n\n        routes = []\n\n        for host in hosts:\n            if host:\n                params.update({\"requirements\": {\"host\": host}})\n\n            route = super().add(**params)  # type: ignore\n            route.ctx.ignore_body = ignore_body\n            route.ctx.stream = stream\n            route.ctx.hosts = hosts\n            route.ctx.static = static\n\n            routes.append(route)\n\n        if len(routes) == 1:\n            return routes[0]\n        return routes", "is_method": true, "class_name": "Router", "function_description": "Provides the core capability to register new web routes or API endpoints within the router. It maps a URI, HTTP methods, and a handler, supporting detailed behavioral configuration."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "find_route_by_view_name", "line_number": 141, "body": "def find_route_by_view_name(self, view_name, name=None):\n        \"\"\"\n        Find a route in the router based on the specified view name.\n\n        :param view_name: string of view name to search by\n        :param kwargs: additional params, usually for static files\n        :return: tuple containing (uri, Route)\n        \"\"\"\n        if not view_name:\n            return None\n\n        route = self.name_index.get(view_name)\n        if not route:\n            full_name = self.ctx.app._generate_name(view_name)\n            route = self.name_index.get(full_name)\n\n        if not route:\n            return None\n\n        return route", "is_method": true, "class_name": "Router", "function_description": "This `Router` method retrieves a specific route configuration using its assigned view name. It provides a programmatic way to locate routes for URL generation or navigation within an application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "routes_all", "line_number": 163, "body": "def routes_all(self):\n        return self.routes", "is_method": true, "class_name": "Router", "function_description": "Provides access to all registered routes managed by the router instance."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "routes_static", "line_number": 167, "body": "def routes_static(self):\n        return self.static_routes", "is_method": true, "class_name": "Router", "function_description": "Retrieves the collection of static routes configured within the Router. This capability allows other parts of the application to access and utilize these routes for serving static content."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "routes_dynamic", "line_number": 171, "body": "def routes_dynamic(self):\n        return self.dynamic_routes", "is_method": true, "class_name": "Router", "function_description": "Returns the collection of dynamically configured routes managed by the router instance. This provides access to routes that can change during runtime."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "routes_regex", "line_number": 175, "body": "def routes_regex(self):\n        return self.regex_routes", "is_method": true, "class_name": "Router", "function_description": "Provides access to the collection of regular expression routes configured within the router. This enables other components to utilize or inspect the defined routing patterns."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/router.py", "function": "finalize", "line_number": 178, "body": "def finalize(self, *args, **kwargs):\n        super().finalize(*args, **kwargs)\n\n        for route in self.dynamic_routes.values():\n            if any(\n                label.startswith(\"__\") and label not in ALLOWED_LABELS\n                for label in route.labels\n            ):\n                raise SanicException(\n                    f\"Invalid route: {route}. Parameter names cannot use '__'.\"\n                )", "is_method": true, "class_name": "Router", "function_description": "Finalizes the router's setup by validating dynamic route labels. It enforces naming conventions to prevent the use of invalid or reserved parameter names."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "request_timeout_callback", "line_number": 54, "body": "def request_timeout_callback(self):\n        if self.websocket is None:\n            super().request_timeout_callback()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Manages request timeouts for the WebSocket protocol. It delegates to the parent class's handler only if no WebSocket connection is present."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "response_timeout_callback", "line_number": 58, "body": "def response_timeout_callback(self):\n        if self.websocket is None:\n            super().response_timeout_callback()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Conditionally handles response timeouts. It invokes the superclass's timeout callback if no WebSocket connection exists, otherwise it takes no action."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "keep_alive_timeout_callback", "line_number": 62, "body": "def keep_alive_timeout_callback(self):\n        if self.websocket is None:\n            super().keep_alive_timeout_callback()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Handles keep-alive timeouts for the WebSocketProtocol. It delegates to the superclass's timeout handler only when no active WebSocket connection exists."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "connection_lost", "line_number": 66, "body": "def connection_lost(self, exc):\n        if self.websocket is not None:\n            self.websocket.connection_lost(exc)\n        super().connection_lost(exc)", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Notifies both the managed websocket and the base protocol handler that the connection has been lost, ensuring proper event propagation and state management."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "data_received", "line_number": 71, "body": "def data_received(self, data):\n        if self.websocket is not None:\n            # pass the data to the websocket protocol\n            self.websocket.data_received(data)\n        else:\n            try:\n                super().data_received(data)\n            except HttpParserUpgrade:\n                # this is okay, it just indicates we've got an upgrade request\n                pass", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "This method receives incoming data for the protocol. It forwards the data to the active WebSocket if established, or handles it as an initial HTTP request for upgrade."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/websocket.py", "function": "write_response", "line_number": 82, "body": "def write_response(self, response):\n        if self.websocket is not None:\n            # websocket requests do not write a response\n            self.transport.close()\n        else:\n            super().write_response(response)", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "It manages sending responses, specifically closing the transport for WebSocket connections as they don't write traditional responses. For non-WebSocket requests, it delegates response writing to the superclass."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "url_prefix", "line_number": 74, "body": "def url_prefix(self) -> str:\n        \"\"\"\n        Retrieve the URL prefix being used for the Current Blueprint Group\n\n        :return: string with url prefix\n        \"\"\"\n        return self._url_prefix", "is_method": true, "class_name": "BlueprintGroup", "function_description": "This method retrieves the URL prefix configured for the current BlueprintGroup. It provides the base path for all routes associated with this group."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "blueprints", "line_number": 83, "body": "def blueprints(self) -> List[\"sanic.Blueprint\"]:\n        \"\"\"\n        Retrieve a list of all the available blueprints under this group.\n\n        :return: List of Blueprint instance\n        \"\"\"\n        return self._blueprints", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Retrieves a list of all Sanic blueprints managed by this BlueprintGroup instance."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "version", "line_number": 92, "body": "def version(self) -> Optional[Union[str, int, float]]:\n        \"\"\"\n        API Version for the Blueprint Group. This will be applied only in case\n        if the Blueprint doesn't already have a version specified\n\n        :return: Version information\n        \"\"\"\n        return self._version", "is_method": true, "class_name": "BlueprintGroup", "function_description": "This method retrieves the API version for the Blueprint Group. It serves as a default version for individual blueprints that do not specify their own."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "strict_slashes", "line_number": 102, "body": "def strict_slashes(self) -> Optional[bool]:\n        \"\"\"\n        URL Slash termination behavior configuration\n\n        :return: bool\n        \"\"\"\n        return self._strict_slashes", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Provides the current configuration for strict URL slash enforcement within the blueprint group. This determines if routes require or ignore trailing slashes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "__iter__", "line_number": 110, "body": "def __iter__(self):\n        \"\"\"\n        Tun the class Blueprint Group into an Iterable item\n        \"\"\"\n        return iter(self._blueprints)", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Allows iteration over the blueprints stored within this BlueprintGroup, enabling direct use in loops or other iterable contexts."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "__getitem__", "line_number": 116, "body": "def __getitem__(self, item):\n        \"\"\"\n        This method returns a blueprint inside the group specified by\n        an index value. This will enable indexing, splice and slicing\n        of the blueprint group like we can do with regular list/tuple.\n\n        This method is provided to ensure backward compatibility with\n        any of the pre-existing usage that might break.\n\n        :param item: Index of the Blueprint item in the group\n        :return: Blueprint object\n        \"\"\"\n        return self._blueprints[item]", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Enables accessing individual Blueprint objects within the group using standard Python indexing and slicing. This allows treating the BlueprintGroup as a sequence."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "__setitem__", "line_number": 130, "body": "def __setitem__(self, index, item) -> None:\n        \"\"\"\n        Abstract method implemented to turn the `BlueprintGroup` class\n        into a list like object to support all the existing behavior.\n\n        This method is used to perform the list's indexed setter operation.\n\n        :param index: Index to use for inserting a new Blueprint item\n        :param item: New `Blueprint` object.\n        :return: None\n        \"\"\"\n        self._blueprints[index] = item", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Enables assigning a Blueprint object to a specific index within the BlueprintGroup. This allows for list-like modification of the group's collection of blueprints."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "__delitem__", "line_number": 143, "body": "def __delitem__(self, index) -> None:\n        \"\"\"\n        Abstract method implemented to turn the `BlueprintGroup` class\n        into a list like object to support all the existing behavior.\n\n        This method is used to delete an item from the list of blueprint\n        groups like it can be done on a regular list with index.\n\n        :param index: Index to use for removing a new Blueprint item\n        :return: None\n        \"\"\"\n        del self._blueprints[index]", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Enables deletion of a specific blueprint by index, allowing BlueprintGroup instances to function like Python lists."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "__len__", "line_number": 156, "body": "def __len__(self) -> int:\n        \"\"\"\n        Get the Length of the blueprint group object.\n\n        :return: Length of Blueprint group object\n        \"\"\"\n        return len(self._blueprints)", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Enables determining the total number of blueprints within the group. It provides the group's size, allowing it to be used with the `len()` function."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "_sanitize_blueprint", "line_number": 164, "body": "def _sanitize_blueprint(self, bp: \"sanic.Blueprint\") -> \"sanic.Blueprint\":\n        \"\"\"\n        Sanitize the Blueprint Entity to override the Version and strict slash\n        behaviors as required.\n\n        :param bp: Sanic Blueprint entity Object\n        :return: Modified Blueprint\n        \"\"\"\n        if self._url_prefix:\n            merged_prefix = \"/\".join(\n                u.strip(\"/\") for u in [self._url_prefix, bp.url_prefix or \"\"]\n            ).rstrip(\"/\")\n            bp.url_prefix = f\"/{merged_prefix}\"\n        for _attr in [\"version\", \"strict_slashes\"]:\n            if getattr(bp, _attr) is None:\n                setattr(bp, _attr, getattr(self, _attr))\n        return bp", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Adjusts a Sanic blueprint's URL prefix, version, and strict slashes to align with the BlueprintGroup's configuration. Ensures consistency for blueprints managed by the group."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "append", "line_number": 182, "body": "def append(self, value: \"sanic.Blueprint\") -> None:\n        \"\"\"\n        The Abstract class `MutableSequence` leverages this append method to\n        perform the `BlueprintGroup.append` operation.\n        :param value: New `Blueprint` object.\n        :return: None\n        \"\"\"\n        self._blueprints.append(self._sanitize_blueprint(bp=value))", "is_method": true, "class_name": "BlueprintGroup", "function_description": "This method extends the BlueprintGroup by adding a new Sanic Blueprint to its collection. It sanitizes the blueprint before appending it to the group."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "insert", "line_number": 191, "body": "def insert(self, index: int, item: \"sanic.Blueprint\") -> None:\n        \"\"\"\n        The Abstract class `MutableSequence` leverages this insert method to\n        perform the `BlueprintGroup.append` operation.\n\n        :param index: Index to use for removing a new Blueprint item\n        :param item: New `Blueprint` object.\n        :return: None\n        \"\"\"\n        self._blueprints.insert(index, self._sanitize_blueprint(item))", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Adds a Sanic Blueprint object to the group's collection at a specific index. This enables precise control over the order of registered blueprints."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "middleware", "line_number": 202, "body": "def middleware(self, *args, **kwargs):\n        \"\"\"\n        A decorator that can be used to implement a Middleware plugin to\n        all of the Blueprints that belongs to this specific Blueprint Group.\n\n        In case of nested Blueprint Groups, the same middleware is applied\n        across each of the Blueprints recursively.\n\n        :param args: Optional positional Parameters to be use middleware\n        :param kwargs: Optional Keyword arg to use with Middleware\n        :return: Partial function to apply the middleware\n        \"\"\"\n\n        def register_middleware_for_blueprints(fn):\n            for blueprint in self.blueprints:\n                blueprint.middleware(fn, *args, **kwargs)\n\n        if args and callable(args[0]):\n            fn = args[0]\n            args = list(args)[1:]\n            return register_middleware_for_blueprints(fn)\n        return register_middleware_for_blueprints", "is_method": true, "class_name": "BlueprintGroup", "function_description": "This decorator applies a specified middleware to all blueprints within the group, including those in nested blueprint groups. It simplifies the centralized management of common functionalities across a collection of web application blueprints."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/blueprint_group.py", "function": "register_middleware_for_blueprints", "line_number": 215, "body": "def register_middleware_for_blueprints(fn):\n            for blueprint in self.blueprints:\n                blueprint.middleware(fn, *args, **kwargs)", "is_method": true, "class_name": "BlueprintGroup", "function_description": "Registers a given middleware function across all blueprints managed by the group. This centralizes the application of common functionalities like authentication or logging to multiple related API routes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "pause_writing", "line_number": 22, "body": "def pause_writing(self) -> None:\n        self._not_paused.clear()", "is_method": true, "class_name": "MockProtocol", "function_description": "Pauses the writing operations within this mock protocol instance, effectively halting data transmission or similar activities."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "resume_writing", "line_number": 25, "body": "def resume_writing(self) -> None:\n        self._not_paused.set()", "is_method": true, "class_name": "MockProtocol", "function_description": "For a `MockProtocol`, this method signals that writing operations can proceed. It releases any components that were paused, allowing them to resume."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "is_complete", "line_number": 35, "body": "def is_complete(self) -> bool:\n        return self._complete.is_set()", "is_method": true, "class_name": "MockProtocol", "function_description": "Indicates whether the mock protocol's operation or state has been completed."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "get_protocol", "line_number": 60, "body": "def get_protocol(self) -> MockProtocol:\n        if not self._protocol:\n            self._protocol = MockProtocol(self, self.loop)\n        return self._protocol", "is_method": true, "class_name": "MockTransport", "function_description": "Retrieves or lazily initializes the `MockTransport`'s associated protocol object. This ensures a consistent `MockProtocol` instance for handling mock communication interactions."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "get_extra_info", "line_number": 65, "body": "def get_extra_info(self, info: str) -> Union[str, bool, None]:\n        if info == \"peername\":\n            return self.scope.get(\"client\")\n        elif info == \"sslcontext\":\n            return self.scope.get(\"scheme\") in [\"https\", \"wss\"]\n        return None", "is_method": true, "class_name": "MockTransport", "function_description": "This method of `MockTransport` provides specific connection details like the client's peername or whether an SSL context is active. It's useful for simulating transport information in tests."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "get_websocket_connection", "line_number": 72, "body": "def get_websocket_connection(self) -> WebSocketConnection:\n        try:\n            return self._websocket_connection\n        except AttributeError:\n            raise InvalidUsage(\"Improper websocket connection.\")", "is_method": true, "class_name": "MockTransport", "function_description": "Retrieves the established WebSocket connection object from the transport. It raises an error if the connection is not properly set up."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/models/asgi.py", "function": "create_websocket_connection", "line_number": 78, "body": "def create_websocket_connection(\n        self, send: ASGISend, receive: ASGIReceive\n    ) -> WebSocketConnection:\n        self._websocket_connection = WebSocketConnection(\n            send, receive, self.scope.get(\"subprotocols\", [])\n        )\n        return self._websocket_connection", "is_method": true, "class_name": "MockTransport", "function_description": "For testing purposes, this `MockTransport` method creates and returns a simulated WebSocket connection object. It utilizes ASGI communication channels for the mock connection."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/middleware.py", "function": "middleware", "line_number": 14, "body": "def middleware(\n        self, middleware_or_request, attach_to=\"request\", apply=True\n    ):\n        \"\"\"\n        Decorate and register middleware to be called before a request.\n        Can either be called as *@app.middleware* or\n        *@app.middleware('request')*\n\n        `See user guide re: middleware\n        <https://sanicframework.org/guide/basics/middleware.html>`__\n\n        :param: middleware_or_request: Optional parameter to use for\n            identifying which type of middleware is being registered.\n        \"\"\"\n\n        def register_middleware(middleware, attach_to=\"request\"):\n            nonlocal apply\n\n            future_middleware = FutureMiddleware(middleware, attach_to)\n            self._future_middleware.append(future_middleware)\n            if apply:\n                self._apply_middleware(future_middleware)\n            return middleware\n\n        # Detect which way this was called, @middleware or @middleware('AT')\n        if callable(middleware_or_request):\n            return register_middleware(\n                middleware_or_request, attach_to=attach_to\n            )\n        else:\n            return partial(\n                register_middleware, attach_to=middleware_or_request\n            )", "is_method": true, "class_name": "MiddlewareMixin", "function_description": "Registers and applies middleware functions as decorators, which execute before requests to extend web application processing logic."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/middleware.py", "function": "on_request", "line_number": 48, "body": "def on_request(self, middleware=None):\n        if callable(middleware):\n            return self.middleware(middleware, \"request\")\n        else:\n            return partial(self.middleware, attach_to=\"request\")", "is_method": true, "class_name": "MiddlewareMixin", "function_description": "Provides a flexible mechanism to register callable middleware specifically for processing incoming requests. It allows direct attachment or returns a partial function for decorator-style use."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/middleware.py", "function": "on_response", "line_number": 54, "body": "def on_response(self, middleware=None):\n        if callable(middleware):\n            return self.middleware(middleware, \"response\")\n        else:\n            return partial(self.middleware, attach_to=\"response\")", "is_method": true, "class_name": "MiddlewareMixin", "function_description": "Registers a middleware function to execute during the response phase, or returns a decorator for later registration. This allows custom logic to modify responses."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/middleware.py", "function": "register_middleware", "line_number": 29, "body": "def register_middleware(middleware, attach_to=\"request\"):\n            nonlocal apply\n\n            future_middleware = FutureMiddleware(middleware, attach_to)\n            self._future_middleware.append(future_middleware)\n            if apply:\n                self._apply_middleware(future_middleware)\n            return middleware", "is_method": true, "class_name": "MiddlewareMixin", "function_description": "Registers a new middleware component, specifying its attachment point. It queues the middleware for future application or applies it instantly."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "_generate_next_value_", "line_number": 9, "body": "def _generate_next_value_(name: str, *args) -> str:  # type: ignore\n        return name.lower()", "is_method": true, "class_name": "ListenerEvent", "function_description": "Provides a lowercase, standardized string for a given name. This is likely used by `ListenerEvent` to ensure consistent handling and lookup of event types."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "listener", "line_number": 27, "body": "def listener(\n        self,\n        listener_or_event: Union[\n            Callable[..., Coroutine[Any, Any, None]], str\n        ],\n        event_or_none: Optional[str] = None,\n        apply: bool = True,\n    ):\n        \"\"\"\n        Create a listener from a decorated function.\n\n        To be used as a deocrator:\n\n        .. code-block:: python\n\n            @bp.listener(\"before_server_start\")\n            async def before_server_start(app, loop):\n                ...\n\n        `See user guide re: listeners\n        <https://sanicframework.org/guide/basics/listeners.html#listeners>`__\n\n        :param event: event to listen to\n        \"\"\"\n\n        def register_listener(listener, event):\n            nonlocal apply\n\n            future_listener = FutureListener(listener, event)\n            self._future_listeners.append(future_listener)\n            if apply:\n                self._apply_listener(future_listener)\n            return listener\n\n        if callable(listener_or_event):\n            return register_listener(listener_or_event, event_or_none)\n        else:\n            return partial(register_listener, event=listener_or_event)", "is_method": true, "class_name": "ListenerMixin", "function_description": "Registers a function as an event listener for specific application events. It's designed for use as a decorator to easily attach event handlers."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "main_process_start", "line_number": 66, "body": "def main_process_start(self, listener):\n        return self.listener(listener, \"main_process_start\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Notifies a given listener about the start of the main process. It acts as a specific event trigger within the listener mechanism."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "main_process_stop", "line_number": 69, "body": "def main_process_stop(self, listener):\n        return self.listener(listener, \"main_process_stop\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Notifies the registered listener that the main process has stopped. This dispatches a specific event to handle the process termination."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "before_server_start", "line_number": 72, "body": "def before_server_start(self, listener):\n        return self.listener(listener, \"before_server_start\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Invokes the mixin's generic listener mechanism for the 'before_server_start' event. This allows registered components to execute setup actions prior to server startup."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "after_server_start", "line_number": 75, "body": "def after_server_start(self, listener):\n        return self.listener(listener, \"after_server_start\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Notifies a specified listener that the server has completed its startup process."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "before_server_stop", "line_number": 78, "body": "def before_server_stop(self, listener):\n        return self.listener(listener, \"before_server_stop\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Notifies a specified listener object that the server is about to stop, utilizing the mixin's generic event dispatching mechanism."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "after_server_stop", "line_number": 81, "body": "def after_server_stop(self, listener):\n        return self.listener(listener, \"after_server_stop\")", "is_method": true, "class_name": "ListenerMixin", "function_description": "Enables registering a callback or listener to be invoked once the server has successfully stopped."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/listeners.py", "function": "register_listener", "line_number": 52, "body": "def register_listener(listener, event):\n            nonlocal apply\n\n            future_listener = FutureListener(listener, event)\n            self._future_listeners.append(future_listener)\n            if apply:\n                self._apply_listener(future_listener)\n            return listener", "is_method": true, "class_name": "ListenerMixin", "function_description": "Registers a listener for a specific event, either immediately applying it or queuing it for later activation. This allows components to be notified when events occur."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/signals.py", "function": "__hash__", "line_number": 9, "body": "def __hash__(self):\n        return hash(tuple(sorted(self.items())))", "is_method": true, "class_name": "HashableDict", "function_description": "Provides a hash value for `HashableDict` instances. This enables `HashableDict` objects to be used as dictionary keys or elements in sets."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/signals.py", "function": "signal", "line_number": 20, "body": "def signal(\n        self,\n        event: str,\n        *,\n        apply: bool = True,\n        condition: Dict[str, Any] = None,\n    ) -> Callable[[SignalHandler], FutureSignal]:\n        \"\"\"\n        For creating a signal handler, used similar to a route handler:\n\n        .. code-block:: python\n\n            @app.signal(\"foo.bar.<thing>\")\n            async def signal_handler(thing, **kwargs):\n                print(f\"[signal_handler] {thing=}\", kwargs)\n\n        :param event: Representation of the event in ``one.two.three`` form\n        :type event: str\n        :param apply: For lazy evaluation, defaults to True\n        :type apply: bool, optional\n        :param condition: For use with the ``condition`` argument in dispatch\n            filtering, defaults to None\n        :type condition: Dict[str, Any], optional\n        \"\"\"\n\n        def decorator(handler: SignalHandler):\n            nonlocal event\n            nonlocal apply\n\n            future_signal = FutureSignal(\n                handler, event, HashableDict(condition or {})\n            )\n            self._future_signals.add(future_signal)\n\n            if apply:\n                self._apply_signal(future_signal)\n\n            return future_signal\n\n        return decorator", "is_method": true, "class_name": "SignalMixin", "function_description": "This method creates and registers a decorator that links a callable function to a specific event pattern. It enables defining event-driven signal handlers that execute when a matching event is dispatched."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/signals.py", "function": "add_signal", "line_number": 61, "body": "def add_signal(\n        self,\n        handler,\n        event: str,\n        condition: Dict[str, Any] = None,\n    ):\n        self.signal(event=event, condition=condition)(handler)\n        return handler", "is_method": true, "class_name": "SignalMixin", "function_description": "Registers a handler function to execute when a specified event occurs, optionally subject to given conditions. This enables event-driven behavior by associating callbacks with system events."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/signals.py", "function": "decorator", "line_number": 45, "body": "def decorator(handler: SignalHandler):\n            nonlocal event\n            nonlocal apply\n\n            future_signal = FutureSignal(\n                handler, event, HashableDict(condition or {})\n            )\n            self._future_signals.add(future_signal)\n\n            if apply:\n                self._apply_signal(future_signal)\n\n            return future_signal", "is_method": true, "class_name": "SignalMixin", "function_description": "Registers a signal handler for a specific event and condition, creating a pending signal object. It stores this signal and can optionally activate it immediately."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/exceptions.py", "function": "exception", "line_number": 13, "body": "def exception(self, *exceptions, apply=True):\n        \"\"\"\n        This method enables the process of creating a global exception\n        handler for the current blueprint under question.\n\n        :param args: List of Python exceptions to be caught by the handler\n        :param kwargs: Additional optional arguments to be passed to the\n            exception handler\n\n        :return a decorated method to handle global exceptions for any\n            route registered under this blueprint.\n        \"\"\"\n\n        def decorator(handler):\n            nonlocal apply\n            nonlocal exceptions\n\n            if isinstance(exceptions[0], list):\n                exceptions = tuple(*exceptions)\n\n            future_exception = FutureException(handler, exceptions)\n            self._future_exceptions.add(future_exception)\n            if apply:\n                self._apply_exception_handler(future_exception)\n            return handler\n\n        return decorator", "is_method": true, "class_name": "ExceptionMixin", "function_description": "Returns a decorator to define and register global exception handlers for a blueprint. This allows specific functions to catch and process defined exceptions across routes."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/exceptions.py", "function": "decorator", "line_number": 26, "body": "def decorator(handler):\n            nonlocal apply\n            nonlocal exceptions\n\n            if isinstance(exceptions[0], list):\n                exceptions = tuple(*exceptions)\n\n            future_exception = FutureException(handler, exceptions)\n            self._future_exceptions.add(future_exception)\n            if apply:\n                self._apply_exception_handler(future_exception)\n            return handler", "is_method": true, "class_name": "ExceptionMixin", "function_description": "Registers an exception handler for specified exceptions. This decorator stores the handler for later application or applies it immediately, enabling flexible exception management."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "route", "line_number": 41, "body": "def route(\n        self,\n        uri: str,\n        methods: Optional[Iterable[str]] = None,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        stream: bool = False,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = False,\n        apply: bool = True,\n        subprotocols: Optional[List[str]] = None,\n        websocket: bool = False,\n        unquote: bool = False,\n        static: bool = False,\n    ):\n        \"\"\"\n        Decorate a function to be registered as a route\n\n        :param uri: path of the URL\n        :param methods: list or tuple of methods allowed\n        :param host: the host, if required\n        :param strict_slashes: whether to apply strict slashes to the route\n        :param stream: whether to allow the request to stream its body\n        :param version: route specific versioning\n        :param name: user defined route name for url_for\n        :param ignore_body: whether the handler should ignore request\n            body (eg. GET requests)\n        :return: tuple of routes, decorated function\n        \"\"\"\n\n        # Fix case where the user did not prefix the URL with a /\n        # and will probably get confused as to why it's not working\n        if not uri.startswith(\"/\") and (uri or hasattr(self, \"router\")):\n            uri = \"/\" + uri\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        if not methods and not websocket:\n            methods = frozenset({\"GET\"})\n\n        def decorator(handler):\n            nonlocal uri\n            nonlocal methods\n            nonlocal host\n            nonlocal strict_slashes\n            nonlocal stream\n            nonlocal version\n            nonlocal name\n            nonlocal ignore_body\n            nonlocal subprotocols\n            nonlocal websocket\n            nonlocal static\n\n            if isinstance(handler, tuple):\n                # if a handler fn is already wrapped in a route, the handler\n                # variable will be a tuple of (existing routes, handler fn)\n                _, handler = handler\n\n            name = self._generate_name(name, handler)\n\n            if isinstance(host, str):\n                host = frozenset([host])\n            elif host and not isinstance(host, frozenset):\n                try:\n                    host = frozenset(host)\n                except TypeError:\n                    raise ValueError(\n                        \"Expected either string or Iterable of host strings, \"\n                        \"not %s\" % host\n                    )\n\n            if isinstance(subprotocols, (list, tuple, set)):\n                subprotocols = frozenset(subprotocols)\n\n            route = FutureRoute(\n                handler,\n                uri,\n                None if websocket else frozenset([x.upper() for x in methods]),\n                host,\n                strict_slashes,\n                stream,\n                version,\n                name,\n                ignore_body,\n                websocket,\n                subprotocols,\n                unquote,\n                static,\n            )\n\n            self._future_routes.add(route)\n\n            args = list(signature(handler).parameters.keys())\n            if websocket and len(args) < 2:\n                handler_name = handler.__name__\n\n                raise ValueError(\n                    f\"Required parameter `request` and/or `ws` missing \"\n                    f\"in the {handler_name}() route?\"\n                )\n            elif not args:\n                handler_name = handler.__name__\n\n                raise ValueError(\n                    f\"Required parameter `request` missing \"\n                    f\"in the {handler_name}() route?\"\n                )\n\n            if not websocket and stream:\n                handler.is_stream = stream\n\n            if apply:\n                self._apply_route(route)\n\n            return route, handler\n\n        return decorator", "is_method": true, "class_name": "RouteMixin", "function_description": "Provides a decorator to register a Python function as a web route. It configures the URI, HTTP methods, and other parameters for the route within a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "add_route", "line_number": 161, "body": "def add_route(\n        self,\n        handler,\n        uri: str,\n        methods: Iterable[str] = frozenset({\"GET\"}),\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        stream: bool = False,\n    ):\n        \"\"\"A helper method to register class instance or\n        functions as a handler to the application url\n        routes.\n\n        :param handler: function or class instance\n        :param uri: path of the URL\n        :param methods: list or tuple of methods allowed, these are overridden\n                        if using a HTTPMethodView\n        :param host:\n        :param strict_slashes:\n        :param version:\n        :param name: user defined route name for url_for\n        :param stream: boolean specifying if the handler is a stream handler\n        :return: function or class instance\n        \"\"\"\n        # Handle HTTPMethodView differently\n        if hasattr(handler, \"view_class\"):\n            methods = set()\n\n            for method in HTTP_METHODS:\n                _handler = getattr(handler.view_class, method.lower(), None)\n                if _handler:\n                    methods.add(method)\n                    if hasattr(_handler, \"is_stream\"):\n                        stream = True\n\n        # handle composition view differently\n        if isinstance(handler, CompositionView):\n            methods = handler.handlers.keys()\n            for _handler in handler.handlers.values():\n                if hasattr(_handler, \"is_stream\"):\n                    stream = True\n                    break\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        self.route(\n            uri=uri,\n            methods=methods,\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )(handler)\n        return handler", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers a given handler (function or class instance) to a specific application URL, defining a new route. It supports associating the handler with particular HTTP methods and routing configurations.\nRegisters a given handler (function or class instance) to a specific application URL, defining a new route. It supports associating the handler with particular HTTP methods and routing configurations."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "get", "line_number": 221, "body": "def get(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = True,\n    ):\n        \"\"\"\n        Add an API URL under the **GET** *HTTP* method\n\n        :param uri: URL to be tagged to **GET** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"GET\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            ignore_body=ignore_body,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers a new API route that specifically handles HTTP GET requests. It allows associating a given URI with a function to retrieve resources."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "post", "line_number": 251, "body": "def post(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        stream: bool = False,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n    ):\n        \"\"\"\n        Add an API URL under the **POST** *HTTP* method\n\n        :param uri: URL to be tagged to **POST** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"POST\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers an API URL endpoint to specifically handle HTTP POST requests. It allows configuring various routing parameters such as host, version, and name for the route."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "put", "line_number": 281, "body": "def put(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        stream: bool = False,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n    ):\n        \"\"\"\n        Add an API URL under the **PUT** *HTTP* method\n\n        :param uri: URL to be tagged to **PUT** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PUT\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Adds an API route for handling HTTP PUT requests. It registers a function to respond to a specific URI and other routing parameters."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "head", "line_number": 311, "body": "def head(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = True,\n    ):\n        \"\"\"\n        Add an API URL under the **HEAD** *HTTP* method\n\n        :param uri: URL to be tagged to **HEAD** method of *HTTP*\n        :type uri: str\n        :param host: Host IP or FQDN for the service to use\n        :type host: Optional[str], optional\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :type strict_slashes: Optional[bool], optional\n        :param version: API Version\n        :type version: Optional[str], optional\n        :param name: Unique name that can be used to identify the Route\n        :type name: Optional[str], optional\n        :param ignore_body: whether the handler should ignore request\n            body (eg. GET requests), defaults to True\n        :type ignore_body: bool, optional\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"HEAD\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            ignore_body=ignore_body,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers an API endpoint that specifically responds to HTTP HEAD requests. This utility method simplifies defining HEAD routes within a web application framework."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "options", "line_number": 349, "body": "def options(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = True,\n    ):\n        \"\"\"\n        Add an API URL under the **OPTIONS** *HTTP* method\n\n        :param uri: URL to be tagged to **OPTIONS** method of *HTTP*\n        :type uri: str\n        :param host: Host IP or FQDN for the service to use\n        :type host: Optional[str], optional\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :type strict_slashes: Optional[bool], optional\n        :param version: API Version\n        :type version: Optional[str], optional\n        :param name: Unique name that can be used to identify the Route\n        :type name: Optional[str], optional\n        :param ignore_body: whether the handler should ignore request\n            body (eg. GET requests), defaults to True\n        :type ignore_body: bool, optional\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"OPTIONS\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            ignore_body=ignore_body,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers an API route specifically designed to respond to HTTP OPTIONS requests. This simplifies defining endpoints for preflight checks or resource capability queries."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "patch", "line_number": 387, "body": "def patch(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        stream=False,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n    ):\n        \"\"\"\n        Add an API URL under the **PATCH** *HTTP* method\n\n        :param uri: URL to be tagged to **PATCH** method of *HTTP*\n        :type uri: str\n        :param host: Host IP or FQDN for the service to use\n        :type host: Optional[str], optional\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :type strict_slashes: Optional[bool], optional\n        :param stream: whether to allow the request to stream its body\n        :type stream: Optional[bool], optional\n        :param version: API Version\n        :type version: Optional[str], optional\n        :param name: Unique name that can be used to identify the Route\n        :type name: Optional[str], optional\n        :param ignore_body: whether the handler should ignore request\n            body (eg. GET requests), defaults to True\n        :type ignore_body: bool, optional\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PATCH\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Adds an API route to handle HTTP PATCH requests for a specified URI. It provides a convenient way to define endpoints for partial resource updates in a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "delete", "line_number": 427, "body": "def delete(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        ignore_body: bool = True,\n    ):\n        \"\"\"\n        Add an API URL under the **DELETE** *HTTP* method\n\n        :param uri: URL to be tagged to **DELETE** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"DELETE\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            ignore_body=ignore_body,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers an API endpoint specifically for the HTTP DELETE method. It allows you to define routes for resource deletion within a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "websocket", "line_number": 457, "body": "def websocket(\n        self,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        subprotocols: Optional[List[str]] = None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n        apply: bool = True,\n    ):\n        \"\"\"\n        Decorate a function to be registered as a websocket route\n\n        :param uri: path of the URL\n        :param host: Host IP or FQDN details\n        :param strict_slashes: If the API endpoint needs to terminate\n                               with a \"/\" or not\n        :param subprotocols: optional list of str with supported subprotocols\n        :param name: A unique name assigned to the URL so that it can\n                     be used with :func:`url_for`\n        :return: tuple of routes, decorated function\n        \"\"\"\n        return self.route(\n            uri=uri,\n            host=host,\n            methods=None,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n            apply=apply,\n            subprotocols=subprotocols,\n            websocket=True,\n        )", "is_method": true, "class_name": "RouteMixin", "function_description": "This method registers a Python function as a websocket route, allowing it to handle real-time, bidirectional communication within a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "add_websocket_route", "line_number": 491, "body": "def add_websocket_route(\n        self,\n        handler,\n        uri: str,\n        host: Optional[str] = None,\n        strict_slashes: Optional[bool] = None,\n        subprotocols=None,\n        version: Optional[int] = None,\n        name: Optional[str] = None,\n    ):\n        \"\"\"\n        A helper method to register a function as a websocket route.\n\n        :param handler: a callable function or instance of a class\n                        that can handle the websocket request\n        :param host: Host IP or FQDN details\n        :param uri: URL path that will be mapped to the websocket\n                    handler\n                    handler\n        :param strict_slashes: If the API endpoint needs to terminate\n                with a \"/\" or not\n        :param subprotocols: Subprotocols to be used with websocket\n                handshake\n        :param name: A unique name assigned to the URL so that it can\n                be used with :func:`url_for`\n        :return: Objected decorated by :func:`websocket`\n        \"\"\"\n        return self.websocket(\n            uri=uri,\n            host=host,\n            strict_slashes=strict_slashes,\n            subprotocols=subprotocols,\n            version=version,\n            name=name,\n        )(handler)", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers a given handler function or class to serve websocket connections at a specified URI. It simplifies defining new websocket endpoints within a web application framework."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "static", "line_number": 527, "body": "def static(\n        self,\n        uri,\n        file_or_directory: Union[str, bytes, PurePath],\n        pattern=r\"/?.+\",\n        use_modified_since=True,\n        use_content_range=False,\n        stream_large_files=False,\n        name=\"static\",\n        host=None,\n        strict_slashes=None,\n        content_type=None,\n        apply=True,\n    ):\n        \"\"\"\n        Register a root to serve files from. The input can either be a\n        file or a directory. This method will enable an easy and simple way\n        to setup the :class:`Route` necessary to serve the static files.\n\n        :param uri: URL path to be used for serving static content\n        :param file_or_directory: Path for the Static file/directory with\n            static files\n        :param pattern: Regex Pattern identifying the valid static files\n        :param use_modified_since: If true, send file modified time, and return\n            not modified if the browser's matches the server's\n        :param use_content_range: If true, process header for range requests\n            and sends the file part that is requested\n        :param stream_large_files: If true, use the\n            :func:`StreamingHTTPResponse.file_stream` handler rather\n            than the :func:`HTTPResponse.file` handler to send the file.\n            If this is an integer, this represents the threshold size to\n            switch to :func:`StreamingHTTPResponse.file_stream`\n        :param name: user defined name used for url_for\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param content_type: user defined content type for header\n        :return: routes registered on the router\n        :rtype: List[sanic.router.Route]\n        \"\"\"\n\n        name = self._generate_name(name)\n\n        if strict_slashes is None and self.strict_slashes is not None:\n            strict_slashes = self.strict_slashes\n\n        if not isinstance(file_or_directory, (str, bytes, PurePath)):\n            raise ValueError(\n                f\"Static route must be a valid path, not {file_or_directory}\"\n            )\n\n        static = FutureStatic(\n            uri,\n            file_or_directory,\n            pattern,\n            use_modified_since,\n            use_content_range,\n            stream_large_files,\n            name,\n            host,\n            strict_slashes,\n            content_type,\n        )\n        self._future_statics.add(static)\n\n        if apply:\n            self._apply_static(static)", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers a URL route to serve static files or directories from a specified local path. It provides options for efficient content delivery and caching."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "_generate_name", "line_number": 595, "body": "def _generate_name(self, *objects) -> str:\n        name = None\n\n        for obj in objects:\n            if obj:\n                if isinstance(obj, str):\n                    name = obj\n                    break\n\n                try:\n                    name = obj.name\n                except AttributeError:\n                    try:\n                        name = obj.__name__\n                    except AttributeError:\n                        continue\n                else:\n                    break\n\n        if not name:  # noqa\n            raise ValueError(\"Could not generate a name for handler\")\n\n        if not name.startswith(f\"{self.name}.\"):\n            name = f\"{self.name}.{name}\"\n\n        return name", "is_method": true, "class_name": "RouteMixin", "function_description": "Provides a utility to derive a unique, hierarchical name for a given object. It prefixes the determined name with the routing context, ensuring proper identification within the system."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "_register_static", "line_number": 732, "body": "def _register_static(\n        self,\n        static: FutureStatic,\n    ):\n        # TODO: Though sanic is not a file server, I feel like we should\n        # at least make a good effort here.  Modified-since is nice, but\n        # we could also look into etags, expires, and caching\n        \"\"\"\n        Register a static directory handler with Sanic by adding a route to the\n        router and registering a handler.\n\n        :param app: Sanic\n        :param file_or_directory: File or directory path to serve from\n        :type file_or_directory: Union[str,bytes,Path]\n        :param uri: URL to serve from\n        :type uri: str\n        :param pattern: regular expression used to match files in the URL\n        :param use_modified_since: If true, send file modified time, and return\n                                not modified if the browser's matches the\n                                server's\n        :param use_content_range: If true, process header for range requests\n                                and sends the file part that is requested\n        :param stream_large_files: If true, use the file_stream() handler\n                                rather than the file() handler to send the file\n                                If this is an integer, this represents the\n                                threshold size to switch to file_stream()\n        :param name: user defined name used for url_for\n        :type name: str\n        :param content_type: user defined content type for header\n        :return: registered static routes\n        :rtype: List[sanic.router.Route]\n        \"\"\"\n\n        if isinstance(static.file_or_directory, bytes):\n            file_or_directory = static.file_or_directory.decode(\"utf-8\")\n        elif isinstance(static.file_or_directory, PurePath):\n            file_or_directory = str(static.file_or_directory)\n        elif not isinstance(static.file_or_directory, str):\n            raise ValueError(\"Invalid file path string.\")\n        else:\n            file_or_directory = static.file_or_directory\n\n        uri = static.uri\n        name = static.name\n        # If we're not trying to match a file directly,\n        # serve from the folder\n        if not path.isfile(file_or_directory):\n            uri += \"/<__file_uri__:path>\"\n\n        # special prefix for static files\n        # if not static.name.startswith(\"_static_\"):\n        #     name = f\"_static_{static.name}\"\n\n        _handler = wraps(self._static_request_handler)(\n            partial(\n                self._static_request_handler,\n                file_or_directory,\n                static.use_modified_since,\n                static.use_content_range,\n                static.stream_large_files,\n                content_type=static.content_type,\n            )\n        )\n\n        route, _ = self.route(\n            uri=uri,\n            methods=[\"GET\", \"HEAD\"],\n            name=name,\n            host=static.host,\n            strict_slashes=static.strict_slashes,\n            static=True,\n        )(_handler)\n\n        return route", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers a web route to serve static files or directories for the Sanic application. It configures efficient handling, including modified-since and content range support."}, {"file": "./dataset/RepoExec/test-apps/sanic/sanic/mixins/routes.py", "function": "decorator", "line_number": 83, "body": "def decorator(handler):\n            nonlocal uri\n            nonlocal methods\n            nonlocal host\n            nonlocal strict_slashes\n            nonlocal stream\n            nonlocal version\n            nonlocal name\n            nonlocal ignore_body\n            nonlocal subprotocols\n            nonlocal websocket\n            nonlocal static\n\n            if isinstance(handler, tuple):\n                # if a handler fn is already wrapped in a route, the handler\n                # variable will be a tuple of (existing routes, handler fn)\n                _, handler = handler\n\n            name = self._generate_name(name, handler)\n\n            if isinstance(host, str):\n                host = frozenset([host])\n            elif host and not isinstance(host, frozenset):\n                try:\n                    host = frozenset(host)\n                except TypeError:\n                    raise ValueError(\n                        \"Expected either string or Iterable of host strings, \"\n                        \"not %s\" % host\n                    )\n\n            if isinstance(subprotocols, (list, tuple, set)):\n                subprotocols = frozenset(subprotocols)\n\n            route = FutureRoute(\n                handler,\n                uri,\n                None if websocket else frozenset([x.upper() for x in methods]),\n                host,\n                strict_slashes,\n                stream,\n                version,\n                name,\n                ignore_body,\n                websocket,\n                subprotocols,\n                unquote,\n                static,\n            )\n\n            self._future_routes.add(route)\n\n            args = list(signature(handler).parameters.keys())\n            if websocket and len(args) < 2:\n                handler_name = handler.__name__\n\n                raise ValueError(\n                    f\"Required parameter `request` and/or `ws` missing \"\n                    f\"in the {handler_name}() route?\"\n                )\n            elif not args:\n                handler_name = handler.__name__\n\n                raise ValueError(\n                    f\"Required parameter `request` missing \"\n                    f\"in the {handler_name}() route?\"\n                )\n\n            if not websocket and stream:\n                handler.is_stream = stream\n\n            if apply:\n                self._apply_route(route)\n\n            return route, handler", "is_method": true, "class_name": "RouteMixin", "function_description": "Registers a handler function as a new web route, associating it with URI, methods, and host configurations. It prepares the route for future application by the routing system."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/redirect_example.py", "function": "handle_request", "line_number": 8, "body": "def handle_request(request):\n    return response.redirect('/redirect')", "is_method": false, "function_description": "This function handles an incoming request by immediately issuing an HTTP redirect to the '/redirect' path. It serves to forward the client to a different URL."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/raygun_example.py", "function": "default", "line_number": 19, "body": "def default(self, request, exception):\n        self.sender.send_exception(exception=exception)\n        return super().default(request, exception)", "is_method": true, "class_name": "RaygunExceptionReporter", "function_description": "This method reports the given exception to the Raygun service. It also delegates to the parent class's default exception handling behavior."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/request_timeout.py", "function": "timeout", "line_number": 18, "body": "def timeout(request, exception):\n    return response.text('RequestTimeout from error_handler.', 408)", "is_method": false, "function_description": "This function generates an HTTP 408 Request Timeout response. It serves as an error handler to inform clients of timed-out requests."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/logdna_example.py", "function": "get_my_ip_address", "line_number": 17, "body": "def get_my_ip_address(remote_server=\"google.com\"):\n    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:\n        s.connect((remote_server, 80))\n        return s.getsockname()[0]", "is_method": false, "function_description": "This function retrieves the local machine's IP address that is used for outgoing network connections. It provides a simple way to programmatically determine your local IP."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/logdna_example.py", "function": "get_mac_address", "line_number": 23, "body": "def get_mac_address():\n    h = iter(hex(get_mac())[2:].zfill(12))\n    return \":\".join(i + next(h) for i in h)", "is_method": false, "function_description": "Retrieves and formats the MAC address of the local machine into a standard colon-separated string. This function provides a formatted network hardware identifier."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/logdna_example.py", "function": "log_request", "line_number": 46, "body": "def log_request(request: Request):\n    logdna.info(\"I was Here with a new Request to URL: {}\".format(request.url))", "is_method": false, "function_description": "This function logs the URL of an incoming web request. It provides a record for monitoring system activity."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/override_logging.py", "function": "test", "line_number": 18, "body": "def test(request):\n    log.info(\"received request; responding with 'hey'\")\n    return text(\"hey\")", "is_method": false, "function_description": "Provides a simple \"hey\" text response, primarily used for basic API connectivity tests or as a placeholder endpoint."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/vhosts.py", "function": "name", "line_number": 38, "body": "def name(request):\n    return response.text(request.app.url_for(\"name\", _external=True))", "is_method": false, "function_description": "Provides its own absolute URL as a text response. Useful for self-discovery or programmatically generating links to this specific endpoint within a web application."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/modify_header_example.py", "function": "handle_request", "line_number": 12, "body": "def handle_request(request):\n    return response.json(\n        {'message': 'Hello world!'},\n        headers={'X-Served-By': 'sanic'},\n        status=200\n    )", "is_method": false, "function_description": "This function serves as a basic web request handler. It returns a static 'Hello world!' JSON response with custom headers and a success status code."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/modify_header_example.py", "function": "handle_request", "line_number": 21, "body": "def handle_request(request):\n    return response.json(\n        {'message': 'You are not authorized'},\n        headers={'X-Served-By': 'sanic'},\n        status=404\n    )", "is_method": false, "function_description": "Returns a fixed 404 Not Found JSON response indicating an authorization issue. It serves as a static error handler for specific server conditions."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/authorized_sanic.py", "function": "authorized", "line_number": 16, "body": "def authorized(f):\n    @wraps(f)\n    async def decorated_function(request, *args, **kwargs):\n        # run some method that checks the request\n        # for the client's authorization status\n        is_authorized = check_request_for_authorization_status(request)\n\n        if is_authorized:\n            # the user is authorized.\n            # run the handler method and return the response\n            response = await f(request, *args, **kwargs)\n            return response\n        else:\n            # the user is not authorized.\n            return json({'status': 'not_authorized'}, 403)\n    return decorated_function", "is_method": false, "function_description": "This decorator enforces authorization for a given function. It checks the request for authorization status, permitting execution only if authorized, otherwise returning a 403 Forbidden response."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/run_asgi.py", "function": "handler_text", "line_number": 18, "body": "def handler_text(request):\n    return response.text(\"Hello\")", "is_method": false, "function_description": "Provides a basic web endpoint that responds to any incoming request with a plain text \"Hello\" message."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/run_asgi.py", "function": "handler_json", "line_number": 23, "body": "def handler_json(request):\n    return response.json({\"foo\": \"bar\"})", "is_method": false, "function_description": "This function serves as a basic API endpoint, responding to any request by returning a fixed JSON payload."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/rollbar_example.py", "function": "default", "line_number": 13, "body": "def default(self, request, exception):\n        rollbar.report_message(str(exception))\n        return super().default(request, exception)", "is_method": true, "class_name": "RollbarExceptionHandler", "function_description": "This method reports a given exception to Rollbar for error tracking and then delegates to the base class's default exception handler."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "test_sync", "line_number": 17, "body": "def test_sync(request):\n    return response.json({\"test\": True})", "is_method": false, "function_description": "Returns a fixed JSON response for synchronous testing. This function can be used to verify basic endpoint connectivity."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "test_params", "line_number": 22, "body": "def test_params(request, name, i):\n    return response.text(\"yeehaww {} {}\".format(name, i))", "is_method": false, "function_description": "This function serves as a basic test endpoint, returning a text response that incorporates two provided parameters. It demonstrates parameter reception in a web environment."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "post_json", "line_number": 64, "body": "def post_json(request):\n    return response.json({\"received\": True, \"message\": request.json})", "is_method": false, "function_description": "Receives and processes an incoming JSON request, then returns a JSON response confirming receipt and echoing the submitted data."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "post_form_json", "line_number": 69, "body": "def post_form_json(request):\n    return response.json({\"received\": True, \"form_data\": request.form, \"test\": request.form.get('test')})", "is_method": false, "function_description": "Processes an incoming request to extract form data. It returns the received form data as a JSON response, confirming successful submission."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "query_string", "line_number": 74, "body": "def query_string(request):\n    return response.json({\"parsed\": True, \"args\": request.args, \"url\": request.url,\n                          \"query_string\": request.query_string})", "is_method": false, "function_description": "Returns a JSON response containing the incoming HTTP request's URL, parsed query arguments, and raw query string. It is useful for inspecting or debugging request parameters."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "before_start", "line_number": 84, "body": "def before_start(app, loop):\n    log.info(\"SERVER STARTING\")", "is_method": false, "function_description": "Provides a pre-startup hook to log the initiation of the server. Useful for monitoring server lifecycle events."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/try_everything.py", "function": "before_stop", "line_number": 94, "body": "def before_stop(app, loop):\n    log.info(\"SERVER STOPPING\")", "is_method": false, "function_description": "Notifies by logging that the server is stopping, serving as a pre-shutdown hook in the application lifecycle."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/exception_monitoring.py", "function": "default", "line_number": 20, "body": "def default(self, request, exception):\n        # Here, we have access to the exception object\n        # and can do anything with it (log, send to external service, etc)\n\n        # Some exceptions are trivial and built into Sanic (404s, etc)\n        if not isinstance(exception, SanicException):\n            print(exception)\n\n        # Then, we must finish handling the exception by returning\n        # our response to the client\n        # For this we can just call the super class' default handler\n        return super().default(request, exception)", "is_method": true, "class_name": "CustomHandler", "function_description": "The `CustomHandler`'s default method customizes exception handling by logging non-Sanic errors before invoking the superclass's default handler to generate the response. It provides a hook for specific error processing."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/pytest_xdist.py", "function": "test_port", "line_number": 23, "body": "def test_port(worker_id):\n    m = re.search(r\"[0-9]+\", worker_id)\n    if m:\n        num_id = m.group(0)\n    else:\n        num_id = 0\n    port = PORT_BASE + int(num_id)\n    return port", "is_method": false, "function_description": "Computes a unique port number for a given worker based on its ID. This allows assigning distinct ports for test processes or distributed operations."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/pytest_xdist.py", "function": "app", "line_number": 34, "body": "def app():\n    app = Sanic()\n\n    @app.route(\"/\")\n    async def index(request):\n        return text(\"OK\")\n\n    return app", "is_method": false, "function_description": "This function initializes and returns a basic Sanic web application. It configures a root endpoint (\"/\") that responds with \"OK\", serving as a simple status check."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/pytest_xdist.py", "function": "client", "line_number": 45, "body": "def client(app, test_port):\n    return SanicTestClient(app, test_port)", "is_method": false, "function_description": "Generates a test client for a Sanic application, allowing programmatic testing of routes and responses."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/pytest_xdist.py", "function": "test_index", "line_number": 50, "body": "def test_index(client, run_id):\n    request, response = client._sanic_endpoint_test(\"get\", \"/\")\n    assert response.status == 200\n    assert response.text == \"OK\"", "is_method": false, "function_description": "This function tests if the web application's root endpoint responds with a 200 status and \"OK\" text, ensuring basic service availability."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/log_request_id.py", "function": "setup", "line_number": 70, "body": "def setup(app, loop):\n    loop.set_task_factory(context.task_factory)", "is_method": false, "function_description": "Configures the event loop by setting a custom task factory. This custom factory defines how new asynchronous tasks are created within the application."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/log_request_id.py", "function": "filter", "line_number": 12, "body": "def filter(self, record):\n        try:\n            record.request_id = context.get(\"X-Request-ID\")\n        except ValueError:\n            record.request_id = \"n/a\"\n        return True", "is_method": true, "class_name": "RequestIdFilter", "function_description": "Injects the `X-Request-ID` from the current context into a log record. This enables correlation of log entries with specific requests for debugging."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/http_redirect.py", "function": "proxy", "line_number": 24, "body": "def proxy(request, path):\n    url = request.app.url_for(\n        \"proxy\",\n        path=path,\n        _server=https.config.SERVER_NAME,\n        _external=True,\n        _scheme=\"http\",\n    )\n    return response.redirect(url)", "is_method": false, "function_description": "Redirects an incoming proxy request to a canonical external HTTP URL. This ensures consistent addressing and scheme for subsequent proxy operations."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/amending_request_object.py", "function": "append_request", "line_number": 9, "body": "def append_request(request):\n    # Add new key with random value\n    request['num'] = randint(0, 100)", "is_method": false, "function_description": "Appends a random numerical identifier to a request object. This is useful for uniquely identifying or processing individual requests."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/amending_request_object.py", "function": "pop_handler", "line_number": 15, "body": "def pop_handler(request):\n    # Pop key from request object\n    num = request.pop('num')\n    return text(num)", "is_method": false, "function_description": "This function extracts and removes the 'num' key's value from a request object. It provides a service to process a specific data parameter from an incoming request."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/amending_request_object.py", "function": "key_exist_handler", "line_number": 22, "body": "def key_exist_handler(request):\n    # Check the key is exist or not\n    if 'num' in request:\n        return text('num exist in request')\n\n    return text('num does not exist in reqeust')", "is_method": false, "function_description": "Checks for the presence of the 'num' key within an incoming request. It provides a textual response indicating whether the key exists or not."}, {"file": "./dataset/RepoExec/test-apps/sanic/examples/limit_concurrency.py", "function": "init", "line_number": 13, "body": "def init(sanic, loop):\n    global sem\n    concurrency_per_worker = 4\n    sem = asyncio.Semaphore(concurrency_per_worker, loop=loop)", "is_method": false, "function_description": "This function initializes a global asyncio semaphore to limit concurrent asynchronous operations to a specific number per worker, aiding in resource management."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_run_shell_command", "line_number": 73, "body": "def _run_shell_command(command: list):\n    try:\n        process = Popen(\n            command, stderr=PIPE, stdout=PIPE, stdin=PIPE, shell=True\n        )\n        output, error = process.communicate()\n        return_code = process.returncode\n        return output.decode(\"utf-8\"), error, return_code\n    except:\n        return None, None, -1", "is_method": false, "function_description": "Provides a utility to execute a shell command, capturing its standard output, error streams, and exit code. This facilitates interaction with external command-line programs."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_fetch_default_calendar_release_version", "line_number": 85, "body": "def _fetch_default_calendar_release_version():\n    return datetime.now().strftime(\"%y.%m.0\")", "is_method": false, "function_description": "Generates a default version string based on the current calendar year and month. It provides a consistent, time-based identifier formatted as \"YY.MM.0\" for releases."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_fetch_current_version", "line_number": 89, "body": "def _fetch_current_version(config_file: str) -> str:\n    if path.isfile(config_file):\n        config_parser = RawConfigParser()\n        with open(config_file) as cfg:\n            config_parser.read_file(cfg)\n            return (\n                config_parser.get(\"version\", \"current_version\")\n                or _fetch_default_calendar_release_version()\n            )\n    else:\n        return _fetch_default_calendar_release_version()", "is_method": false, "function_description": "Retrieves the current version string from a specified configuration file. It provides a default calendar release version if the file or version entry is not found."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_change_micro_version", "line_number": 102, "body": "def _change_micro_version(current_version: str):\n    version_string = current_version.split(\".\")\n    version_string[-1] = str((int(version_string[-1]) + 1))\n    return \".\".join(version_string)", "is_method": false, "function_description": "Provides a utility to increment the patch (micro) version component of a semantic version string. This is useful for automating version updates."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_get_new_version", "line_number": 108, "body": "def _get_new_version(\n    config_file: str = \"./setup.cfg\",\n    current_version: str = None,\n    micro_release: bool = False,\n):\n    if micro_release:\n        if current_version:\n            return _change_micro_version(current_version)\n        elif config_file:\n            return _change_micro_version(_fetch_current_version(config_file))\n        else:\n            return _fetch_default_calendar_release_version()\n    else:\n        return _fetch_default_calendar_release_version()", "is_method": false, "function_description": "Calculates a new software version. It either increments a micro-release version based on an existing version or configuration file, or generates a default calendar-based release version."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_get_current_tag", "line_number": 124, "body": "def _get_current_tag(git_command_name=\"get_tag\"):\n    global GIT_COMMANDS\n    command = GIT_COMMANDS.get(git_command_name)\n    out, err, ret = _run_shell_command(command)\n    if str(out):\n        return str(out).split(\"\\n\")[0]\n    else:\n        return None", "is_method": false, "function_description": "Retrieves the current Git tag of the repository by executing a shell command. This provides the programmatic capability to get version information."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_update_release_version_for_sanic", "line_number": 134, "body": "def _update_release_version_for_sanic(\n    current_version, new_version, config_file, generate_changelog\n):\n    config_parser = RawConfigParser()\n    with open(config_file) as cfg:\n        config_parser.read_file(cfg)\n    config_parser.set(\"version\", \"current_version\", new_version)\n\n    version_files = config_parser.get(\"version\", \"files\")\n    current_version_line = config_parser.get(\n        \"version\", \"current_version_pattern\"\n    ).format(current_version=current_version)\n    new_version_line = config_parser.get(\n        \"version\", \"new_version_pattern\"\n    ).format(new_version=new_version)\n\n    for version_file in version_files.split(\",\"):\n        with open(version_file) as init_file:\n            data = init_file.read()\n\n        new_data = data.replace(current_version_line, new_version_line)\n        with open(version_file, \"w\") as init_file:\n            init_file.write(new_data)\n\n    with open(config_file, \"w\") as config:\n        config_parser.write(config)\n\n    if generate_changelog:\n        towncrier.__main(\n            draft=False,\n            directory=path.dirname(path.abspath(__file__)),\n            project_name=None,\n            project_version=new_version,\n            project_date=None,\n            answer_yes=True,\n        )\n\n    command = GIT_COMMANDS.get(\"commit_version_change\")\n    command[0] = command[0].format(\n        new_version=new_version, current_version=current_version\n    )\n    _, err, ret = _run_shell_command(command)\n    if int(ret) != 0:\n        print(\n            \"Failed to Commit Version upgrade changes to Sanic: {}\".format(\n                err.decode(\"utf-8\")\n            )\n        )\n        sys.exit(1)", "is_method": false, "function_description": "Automates the process of updating a project's release version across specified files and configuration. It also generates a changelog and commits these version changes to Git."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_generate_change_log", "line_number": 185, "body": "def _generate_change_log(current_version: str = None):\n    global GIT_COMMANDS\n    command = GIT_COMMANDS.get(\"get_change_log\")\n    command[0] = command[0].format(current_version=current_version)\n    output, error, ret = _run_shell_command(command=command)\n    if not str(output):\n        print(\"Unable to Fetch Change log details to update the Release Note\")\n        sys.exit(1)\n\n    commit_details = OrderedDict()\n    commit_details[\"authors\"] = {}\n    commit_details[\"commits\"] = []\n\n    for line in str(output).split(\"\\n\"):\n        commit, author, description = line.split(\":::\")\n        if \"GitHub\" not in author:\n            commit_details[\"authors\"][author] = 1\n        commit_details[\"commits\"].append(\" - \".join([commit, description]))\n\n    return commit_details", "is_method": false, "function_description": "Fetches and structures Git commit history, including authors and descriptions, to generate a detailed change log. This is useful for automating release notes or summarizing project changes."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_generate_markdown_document", "line_number": 207, "body": "def _generate_markdown_document(\n    milestone, release_name, current_version, release_version\n):\n    global JINJA_RELEASE_NOTE_TEMPLATE\n    release_name = release_name or release_version\n    change_log = _generate_change_log(current_version=current_version)\n    return JINJA_RELEASE_NOTE_TEMPLATE.render(\n        release_name=release_name,\n        milestone=milestone,\n        changelogs=change_log[\"commits\"],\n        authors=change_log[\"authors\"].keys(),\n    )", "is_method": false, "function_description": "Generates a markdown document for a software release. It compiles release notes by incorporating changelog details and author information for a specified milestone."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "_tag_release", "line_number": 221, "body": "def _tag_release(new_version, current_version, milestone, release_name, token):\n    global GIT_COMMANDS\n    global RELEASE_NOTE_UPDATE_URL\n    for command_name in [\"create_new_tag\", \"push_tag\"]:\n        command = GIT_COMMANDS.get(command_name)\n        command[0] = command[0].format(\n            new_version=new_version, current_version=current_version\n        )\n        out, error, ret = _run_shell_command(command=command)\n        if int(ret) != 0:\n            print(\"Failed to execute the command: {}\".format(command[0]))\n            sys.exit(1)\n\n    change_log = _generate_markdown_document(\n        milestone, release_name, current_version, new_version\n    )\n\n    body = {\"name\": release_name or new_version, \"body\": change_log}\n\n    headers = {\"content-type\": \"application/json\"}\n\n    response = patch(\n        RELEASE_NOTE_UPDATE_URL.format(new_version=new_version, token=token),\n        data=dumps(body),\n        headers=headers,\n    )\n    response.raise_for_status()", "is_method": false, "function_description": "Automates software release creation by tagging the Git repository with the new version. It also generates and publishes release notes to an external platform."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "release", "line_number": 250, "body": "def release(args: Namespace):\n    current_tag = _get_current_tag()\n    current_version = _fetch_current_version(args.config)\n    if current_tag and current_version not in current_tag:\n        print(\n            \"Tag mismatch between what's in git and what was provided by \"\n            \"--current-version. Existing: {}, Give: {}\".format(\n                current_tag, current_version\n            )\n        )\n        sys.exit(1)\n    new_version = args.release_version or _get_new_version(\n        args.config, current_version, args.micro_release\n    )\n    _update_release_version_for_sanic(\n        current_version=current_version,\n        new_version=new_version,\n        config_file=args.config,\n        generate_changelog=args.generate_changelog,\n    )\n    if args.tag_release:\n        _tag_release(\n            current_version=current_version,\n            new_version=new_version,\n            milestone=args.milestone,\n            release_name=args.release_name,\n            token=args.token,\n        )", "is_method": false, "function_description": "Automates the software release process by updating the project version, generating changelogs, and creating Git tags, optionally creating a new remote release. It ensures version consistency throughout the process."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "__enter__", "line_number": 66, "body": "def __enter__(self):\n        chdir(self._new_path)", "is_method": true, "class_name": "Directory", "function_description": "When entering a `with` block, this context manager method changes the current working directory. It temporarily switches the execution path for operations within the block."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/release.py", "function": "__exit__", "line_number": 69, "body": "def __exit__(self, exc_type, exc_val, exc_tb):\n        chdir(self._old_path)", "is_method": true, "class_name": "Directory", "function_description": "This method restores the original working directory when exiting a `with` statement. It ensures the environment is reset after temporary directory changes."}, {"file": "./dataset/RepoExec/test-apps/sanic/scripts/changelog.py", "function": "_main", "line_number": 43, "body": "def _main(\n        draft,\n        directory,\n        project_name,\n        project_version,\n        project_date,\n        answer_yes,\n    ):\n        return towncrier.__main(\n            draft,\n            directory,\n            project_name,\n            project_version,\n            project_date,\n            answer_yes,\n        )", "is_method": false, "function_description": "Executes the main functionality of the `towncrier` news fragment generation tool, acting as a direct entry point for its operations."}]