[{"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "supports_feature", "line_number": 268, "body": "def supports_feature(target_versions: Set[TargetVersion], feature: Feature) -> bool:\n    return all(feature in VERSION_TO_FEATURES[version] for version in target_versions)", "is_method": false, "function_description": "Checks if a specified feature is supported across all given target versions. This function helps determine feature compatibility in multi-version environments."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "find_pyproject_toml", "line_number": 272, "body": "def find_pyproject_toml(path_search_start: Iterable[str]) -> Optional[str]:\n    \"\"\"Find the absolute filepath to a pyproject.toml if it exists\"\"\"\n    path_project_root = find_project_root(path_search_start)\n    path_pyproject_toml = path_project_root / \"pyproject.toml\"\n    return str(path_pyproject_toml) if path_pyproject_toml.is_file() else None", "is_method": false, "function_description": "This function locates the absolute filepath of a pyproject.toml file by searching from given starting paths, assisting tools in identifying Python project configuration files."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "parse_pyproject_toml", "line_number": 279, "body": "def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n\n    If parsing fails, will raise a toml.TomlDecodeError\n    \"\"\"\n    pyproject_toml = toml.load(path_config)\n    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}", "is_method": false, "function_description": "Function that reads and extracts Black configuration options from a pyproject.toml file, returning them as a dictionary with normalized keys for convenient programmatic use."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "read_pyproject_toml", "line_number": 289, "body": "def read_pyproject_toml(\n    ctx: click.Context, param: click.Parameter, value: Optional[str]\n) -> Optional[str]:\n    \"\"\"Inject Black configuration from \"pyproject.toml\" into defaults in `ctx`.\n\n    Returns the path to a successfully found and read configuration file, None\n    otherwise.\n    \"\"\"\n    if not value:\n        value = find_pyproject_toml(ctx.params.get(\"src\", ()))\n        if value is None:\n            return None\n\n    try:\n        config = parse_pyproject_toml(value)\n    except (toml.TomlDecodeError, OSError) as e:\n        raise click.FileError(\n            filename=value, hint=f\"Error reading configuration file: {e}\"\n        )\n\n    if not config:\n        return None\n    else:\n        # Sanitize the values to be Click friendly. For more information please see:\n        # https://github.com/psf/black/issues/1458\n        # https://github.com/pallets/click/issues/1567\n        config = {\n            k: str(v) if not isinstance(v, (list, dict)) else v\n            for k, v in config.items()\n        }\n\n    target_version = config.get(\"target_version\")\n    if target_version is not None and not isinstance(target_version, list):\n        raise click.BadOptionUsage(\n            \"target-version\", \"Config key target-version must be a list\"\n        )\n\n    default_map: Dict[str, Any] = {}\n    if ctx.default_map:\n        default_map.update(ctx.default_map)\n    default_map.update(config)\n\n    ctx.default_map = default_map\n    return value", "is_method": false, "function_description": "Utility function that loads Black formatter settings from a pyproject.toml file and integrates them into the CLI context\u2019s default options, supporting configuration-driven command behavior with validation and error handling."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "target_version_option_callback", "line_number": 335, "body": "def target_version_option_callback(\n    c: click.Context, p: Union[click.Option, click.Parameter], v: Tuple[str, ...]\n) -> List[TargetVersion]:\n    \"\"\"Compute the target versions from a --target-version flag.\n\n    This is its own function because mypy couldn't infer the type correctly\n    when it was a lambda, causing mypyc trouble.\n    \"\"\"\n    return [TargetVersion[val.upper()] for val in v]", "is_method": false, "function_description": "This function converts CLI string inputs from a --target-version flag into a list of TargetVersion enum members, ensuring correct typing for further processing in command-line interfaces."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "main", "line_number": 488, "body": "def main(\n    ctx: click.Context,\n    code: Optional[str],\n    line_length: int,\n    target_version: List[TargetVersion],\n    check: bool,\n    diff: bool,\n    color: bool,\n    fast: bool,\n    pyi: bool,\n    skip_string_normalization: bool,\n    experimental_string_processing: bool,\n    quiet: bool,\n    verbose: bool,\n    include: str,\n    exclude: str,\n    force_exclude: Optional[str],\n    src: Tuple[str, ...],\n    config: Optional[str],\n) -> None:\n    \"\"\"The uncompromising code formatter.\"\"\"\n    write_back = WriteBack.from_configuration(check=check, diff=diff, color=color)\n    if target_version:\n        versions = set(target_version)\n    else:\n        # We'll autodetect later.\n        versions = set()\n    mode = Mode(\n        target_versions=versions,\n        line_length=line_length,\n        is_pyi=pyi,\n        string_normalization=not skip_string_normalization,\n        experimental_string_processing=experimental_string_processing,\n    )\n    if config and verbose:\n        out(f\"Using configuration from {config}.\", bold=False, fg=\"blue\")\n    if code is not None:\n        print(format_str(code, mode=mode))\n        ctx.exit(0)\n    report = Report(check=check, diff=diff, quiet=quiet, verbose=verbose)\n    sources = get_sources(\n        ctx=ctx,\n        src=src,\n        quiet=quiet,\n        verbose=verbose,\n        include=include,\n        exclude=exclude,\n        force_exclude=force_exclude,\n        report=report,\n    )\n\n    path_empty(\n        sources,\n        \"No Python files are present to be formatted. Nothing to do \ud83d\ude34\",\n        quiet,\n        verbose,\n        ctx,\n    )\n\n    if len(sources) == 1:\n        reformat_one(\n            src=sources.pop(),\n            fast=fast,\n            write_back=write_back,\n            mode=mode,\n            report=report,\n        )\n    else:\n        reformat_many(\n            sources=sources, fast=fast, write_back=write_back, mode=mode, report=report\n        )\n\n    if verbose or not quiet:\n        out(\"Oh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\" if report.return_code else \"All done! \u2728 \ud83c\udf70 \u2728\")\n        click.secho(str(report), err=True)\n    ctx.exit(report.return_code)", "is_method": false, "function_description": "Entrypoint function that orchestrates Python code formatting based on user options, handling single or multiple files with configurable style, reporting, and output control in a command-line context."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "get_sources", "line_number": 566, "body": "def get_sources(\n    *,\n    ctx: click.Context,\n    src: Tuple[str, ...],\n    quiet: bool,\n    verbose: bool,\n    include: str,\n    exclude: str,\n    force_exclude: Optional[str],\n    report: \"Report\",\n) -> Set[Path]:\n    \"\"\"Compute the set of files to be formatted.\"\"\"\n    try:\n        include_regex = re_compile_maybe_verbose(include)\n    except re.error:\n        err(f\"Invalid regular expression for include given: {include!r}\")\n        ctx.exit(2)\n    try:\n        exclude_regex = re_compile_maybe_verbose(exclude)\n    except re.error:\n        err(f\"Invalid regular expression for exclude given: {exclude!r}\")\n        ctx.exit(2)\n    try:\n        force_exclude_regex = (\n            re_compile_maybe_verbose(force_exclude) if force_exclude else None\n        )\n    except re.error:\n        err(f\"Invalid regular expression for force_exclude given: {force_exclude!r}\")\n        ctx.exit(2)\n\n    root = find_project_root(src)\n    sources: Set[Path] = set()\n    path_empty(src, \"No Path provided. Nothing to do \ud83d\ude34\", quiet, verbose, ctx)\n    gitignore = get_gitignore(root)\n\n    for s in src:\n        p = Path(s)\n        if p.is_dir():\n            sources.update(\n                gen_python_files(\n                    p.iterdir(),\n                    root,\n                    include_regex,\n                    exclude_regex,\n                    force_exclude_regex,\n                    report,\n                    gitignore,\n                )\n            )\n        elif s == \"-\":\n            sources.add(p)\n        elif p.is_file():\n            normalized_path = normalize_path_maybe_ignore(p, root, report)\n            if normalized_path is None:\n                continue\n\n            normalized_path = \"/\" + normalized_path\n            # Hard-exclude any files that matches the `--force-exclude` regex.\n            if force_exclude_regex:\n                force_exclude_match = force_exclude_regex.search(normalized_path)\n            else:\n                force_exclude_match = None\n            if force_exclude_match and force_exclude_match.group(0):\n                report.path_ignored(p, \"matches the --force-exclude regular expression\")\n                continue\n\n            sources.add(p)\n        else:\n            err(f\"invalid path: {s}\")\n    return sources", "is_method": false, "function_description": "Function that determines and returns the set of source files to process based on directory contents, individual files, and include/exclude regular expressions, applying ignore rules and validation for use in formatting or similar batch operations."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "path_empty", "line_number": 638, "body": "def path_empty(\n    src: Sized, msg: str, quiet: bool, verbose: bool, ctx: click.Context\n) -> None:\n    \"\"\"\n    Exit if there is no `src` provided for formatting\n    \"\"\"\n    if len(src) == 0:\n        if verbose or not quiet:\n            out(msg)\n            ctx.exit(0)", "is_method": false, "function_description": "Utility function that checks if a source is empty and, based on verbosity settings, outputs a message and exits the program gracefully when no input is provided for formatting."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "reformat_one", "line_number": 650, "body": "def reformat_one(\n    src: Path, fast: bool, write_back: WriteBack, mode: Mode, report: \"Report\"\n) -> None:\n    \"\"\"Reformat a single file under `src` without spawning child processes.\n\n    `fast`, `write_back`, and `mode` options are passed to\n    :func:`format_file_in_place` or :func:`format_stdin_to_stdout`.\n    \"\"\"\n    try:\n        changed = Changed.NO\n        if not src.is_file() and str(src) == \"-\":\n            if format_stdin_to_stdout(fast=fast, write_back=write_back, mode=mode):\n                changed = Changed.YES\n        else:\n            cache: Cache = {}\n            if write_back != WriteBack.DIFF:\n                cache = read_cache(mode)\n                res_src = src.resolve()\n                if res_src in cache and cache[res_src] == get_cache_info(res_src):\n                    changed = Changed.CACHED\n            if changed is not Changed.CACHED and format_file_in_place(\n                src, fast=fast, write_back=write_back, mode=mode\n            ):\n                changed = Changed.YES\n            if (write_back is WriteBack.YES and changed is not Changed.CACHED) or (\n                write_back is WriteBack.CHECK and changed is Changed.NO\n            ):\n                write_cache(cache, [src], mode)\n        report.done(src, changed)\n    except Exception as exc:\n        if report.verbose:\n            traceback.print_exc()\n        report.failed(src, str(exc))", "is_method": false, "function_description": "Function in charge of formatting a single source file or stdin input according to given options, managing cache to avoid redundant work, and reporting the outcome including errors."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "reformat_many", "line_number": 685, "body": "def reformat_many(\n    sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: \"Report\"\n) -> None:\n    \"\"\"Reformat multiple files using a ProcessPoolExecutor.\"\"\"\n    executor: Executor\n    loop = asyncio.get_event_loop()\n    worker_count = os.cpu_count()\n    if sys.platform == \"win32\":\n        # Work around https://bugs.python.org/issue26903\n        worker_count = min(worker_count, 61)\n    try:\n        executor = ProcessPoolExecutor(max_workers=worker_count)\n    except (ImportError, OSError):\n        # we arrive here if the underlying system does not support multi-processing\n        # like in AWS Lambda or Termux, in which case we gracefully fallback to\n        # a ThreadPollExecutor with just a single worker (more workers would not do us\n        # any good due to the Global Interpreter Lock)\n        executor = ThreadPoolExecutor(max_workers=1)\n\n    try:\n        loop.run_until_complete(\n            schedule_formatting(\n                sources=sources,\n                fast=fast,\n                write_back=write_back,\n                mode=mode,\n                report=report,\n                loop=loop,\n                executor=executor,\n            )\n        )\n    finally:\n        shutdown(loop)\n        if executor is not None:\n            executor.shutdown()", "is_method": false, "function_description": "Function that reformats multiple source files concurrently, optimizing for available system resources and managing asynchronous task execution with fallback for limited environments."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "format_file_in_place", "line_number": 793, "body": "def format_file_in_place(\n    src: Path,\n    fast: bool,\n    mode: Mode,\n    write_back: WriteBack = WriteBack.NO,\n    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy\n) -> bool:\n    \"\"\"Format file under `src` path. Return True if changed.\n\n    If `write_back` is DIFF, write a diff to stdout. If it is YES, write reformatted\n    code to the file.\n    `mode` and `fast` options are passed to :func:`format_file_contents`.\n    \"\"\"\n    if src.suffix == \".pyi\":\n        mode = replace(mode, is_pyi=True)\n\n    then = datetime.utcfromtimestamp(src.stat().st_mtime)\n    with open(src, \"rb\") as buf:\n        src_contents, encoding, newline = decode_bytes(buf.read())\n    try:\n        dst_contents = format_file_contents(src_contents, fast=fast, mode=mode)\n    except NothingChanged:\n        return False\n\n    if write_back == WriteBack.YES:\n        with open(src, \"w\", encoding=encoding, newline=newline) as f:\n            f.write(dst_contents)\n    elif write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        now = datetime.utcnow()\n        src_name = f\"{src}\\t{then} +0000\"\n        dst_name = f\"{src}\\t{now} +0000\"\n        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)\n\n        if write_back == write_back.COLOR_DIFF:\n            diff_contents = color_diff(diff_contents)\n\n        with lock or nullcontext():\n            f = io.TextIOWrapper(\n                sys.stdout.buffer,\n                encoding=encoding,\n                newline=newline,\n                write_through=True,\n            )\n            f = wrap_stream_for_windows(f)\n            f.write(diff_contents)\n            f.detach()\n\n    return True", "is_method": false, "function_description": "Method of a formatting utility that reformats a given source file in place, optionally writing changes back or displaying diffs. It serves to ensure consistent code style with flexible output and performance options."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "color_diff", "line_number": 843, "body": "def color_diff(contents: str) -> str:\n    \"\"\"Inject the ANSI color codes to the diff.\"\"\"\n    lines = contents.split(\"\\n\")\n    for i, line in enumerate(lines):\n        if line.startswith(\"+++\") or line.startswith(\"---\"):\n            line = \"\\033[1;37m\" + line + \"\\033[0m\"  # bold white, reset\n        if line.startswith(\"@@\"):\n            line = \"\\033[36m\" + line + \"\\033[0m\"  # cyan, reset\n        if line.startswith(\"+\"):\n            line = \"\\033[32m\" + line + \"\\033[0m\"  # green, reset\n        elif line.startswith(\"-\"):\n            line = \"\\033[31m\" + line + \"\\033[0m\"  # red, reset\n        lines[i] = line\n    return \"\\n\".join(lines)", "is_method": false, "function_description": "Function that adds ANSI color codes to lines of a diff string to visually distinguish additions, deletions, and metadata, enhancing readability in terminal outputs."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "wrap_stream_for_windows", "line_number": 859, "body": "def wrap_stream_for_windows(\n    f: io.TextIOWrapper,\n) -> Union[io.TextIOWrapper, \"colorama.AnsiToWin32.AnsiToWin32\"]:\n    \"\"\"\n    Wrap the stream in colorama's wrap_stream so colors are shown on Windows.\n\n    If `colorama` is not found, then no change is made. If `colorama` does\n    exist, then it handles the logic to determine whether or not to change\n    things.\n    \"\"\"\n    try:\n        from colorama import initialise\n\n        # We set `strip=False` so that we can don't have to modify\n        # test_express_diff_with_color.\n        f = initialise.wrap_stream(\n            f, convert=None, strip=False, autoreset=False, wrap=True\n        )\n\n        # wrap_stream returns a `colorama.AnsiToWin32.AnsiToWin32` object\n        # which does not have a `detach()` method. So we fake one.\n        f.detach = lambda *args, **kwargs: None  # type: ignore\n    except ImportError:\n        pass\n\n    return f", "is_method": false, "function_description": "Utility function that wraps a text stream to enable ANSI color support on Windows using colorama, ensuring colored output displays correctly if colorama is installed. Otherwise, it returns the original stream unchanged."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "format_stdin_to_stdout", "line_number": 887, "body": "def format_stdin_to_stdout(\n    fast: bool, *, write_back: WriteBack = WriteBack.NO, mode: Mode\n) -> bool:\n    \"\"\"Format file on stdin. Return True if changed.\n\n    If `write_back` is YES, write reformatted code back to stdout. If it is DIFF,\n    write a diff to stdout. The `mode` argument is passed to\n    :func:`format_file_contents`.\n    \"\"\"\n    then = datetime.utcnow()\n    src, encoding, newline = decode_bytes(sys.stdin.buffer.read())\n    dst = src\n    try:\n        dst = format_file_contents(src, fast=fast, mode=mode)\n        return True\n\n    except NothingChanged:\n        return False\n\n    finally:\n        f = io.TextIOWrapper(\n            sys.stdout.buffer, encoding=encoding, newline=newline, write_through=True\n        )\n        if write_back == WriteBack.YES:\n            f.write(dst)\n        elif write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n            now = datetime.utcnow()\n            src_name = f\"STDIN\\t{then} +0000\"\n            dst_name = f\"STDOUT\\t{now} +0000\"\n            d = diff(src, dst, src_name, dst_name)\n            if write_back == WriteBack.COLOR_DIFF:\n                d = color_diff(d)\n                f = wrap_stream_for_windows(f)\n            f.write(d)\n        f.detach()", "is_method": false, "function_description": "Function that reads Python code from standard input, reformats it according to specified options, and outputs either the formatted code or a diff. It returns True if the input was modified, facilitating format-on-the-fly workflows or editor integrations."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "format_file_contents", "line_number": 924, "body": "def format_file_contents(src_contents: str, *, fast: bool, mode: Mode) -> FileContent:\n    \"\"\"Reformat contents a file and return new contents.\n\n    If `fast` is False, additionally confirm that the reformatted code is\n    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.\n    `mode` is passed to :func:`format_str`.\n    \"\"\"\n    if src_contents.strip() == \"\":\n        raise NothingChanged\n\n    dst_contents = format_str(src_contents, mode=mode)\n    if src_contents == dst_contents:\n        raise NothingChanged\n\n    if not fast:\n        assert_equivalent(src_contents, dst_contents)\n        assert_stable(src_contents, dst_contents, mode=mode)\n    return dst_contents", "is_method": false, "function_description": "Utility function that reformats source code and returns the modified content, optionally verifying correctness and stability of the changes based on a mode and speed preference. It raises an exception if no changes occur."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "format_str", "line_number": 944, "body": "def format_str(src_contents: str, *, mode: Mode) -> FileContent:\n    \"\"\"Reformat a string and return new contents.\n\n    `mode` determines formatting options, such as how many characters per line are\n    allowed.  Example:\n\n    >>> import black\n    >>> print(black.format_str(\"def f(arg:str='')->None:...\", mode=Mode()))\n    def f(arg: str = \"\") -> None:\n        ...\n\n    A more complex example:\n\n    >>> print(\n    ...   black.format_str(\n    ...     \"def f(arg:str='')->None: hey\",\n    ...     mode=black.Mode(\n    ...       target_versions={black.TargetVersion.PY36},\n    ...       line_length=10,\n    ...       string_normalization=False,\n    ...       is_pyi=False,\n    ...     ),\n    ...   ),\n    ... )\n    def f(\n        arg: str = '',\n    ) -> None:\n        hey\n\n    \"\"\"\n    src_node = lib2to3_parse(src_contents.lstrip(), mode.target_versions)\n    dst_contents = []\n    future_imports = get_future_imports(src_node)\n    if mode.target_versions:\n        versions = mode.target_versions\n    else:\n        versions = detect_target_versions(src_node)\n    normalize_fmt_off(src_node)\n    lines = LineGenerator(\n        remove_u_prefix=\"unicode_literals\" in future_imports\n        or supports_feature(versions, Feature.UNICODE_LITERALS),\n        is_pyi=mode.is_pyi,\n        normalize_strings=mode.string_normalization,\n    )\n    elt = EmptyLineTracker(is_pyi=mode.is_pyi)\n    empty_line = Line()\n    after = 0\n    split_line_features = {\n        feature\n        for feature in {Feature.TRAILING_COMMA_IN_CALL, Feature.TRAILING_COMMA_IN_DEF}\n        if supports_feature(versions, feature)\n    }\n    for current_line in lines.visit(src_node):\n        dst_contents.append(str(empty_line) * after)\n        before, after = elt.maybe_empty_lines(current_line)\n        dst_contents.append(str(empty_line) * before)\n        for line in transform_line(\n            current_line, mode=mode, features=split_line_features\n        ):\n            dst_contents.append(str(line))\n    return \"\".join(dst_contents)", "is_method": false, "function_description": "Function from a code formatter that reformats Python source code strings based on given formatting options, returning the reformatted code as a string. It supports customizable style settings like line length, target Python versions, and string normalization."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "decode_bytes", "line_number": 1007, "body": "def decode_bytes(src: bytes) -> Tuple[FileContent, Encoding, NewLine]:\n    \"\"\"Return a tuple of (decoded_contents, encoding, newline).\n\n    `newline` is either CRLF or LF but `decoded_contents` is decoded with\n    universal newlines (i.e. only contains LF).\n    \"\"\"\n    srcbuf = io.BytesIO(src)\n    encoding, lines = tokenize.detect_encoding(srcbuf.readline)\n    if not lines:\n        return \"\", encoding, \"\\n\"\n\n    newline = \"\\r\\n\" if b\"\\r\\n\" == lines[0][-2:] else \"\\n\"\n    srcbuf.seek(0)\n    with io.TextIOWrapper(srcbuf, encoding) as tiow:\n        return tiow.read(), encoding, newline", "is_method": false, "function_description": "Function that decodes a byte string into text while detecting its encoding and original newline format, returning the decoded content normalized to LF newlines along with the detected encoding and newline style."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "get_grammars", "line_number": 1024, "body": "def get_grammars(target_versions: Set[TargetVersion]) -> List[Grammar]:\n    if not target_versions:\n        # No target_version specified, so try all grammars.\n        return [\n            # Python 3.7+\n            pygram.python_grammar_no_print_statement_no_exec_statement_async_keywords,\n            # Python 3.0-3.6\n            pygram.python_grammar_no_print_statement_no_exec_statement,\n            # Python 2.7 with future print_function import\n            pygram.python_grammar_no_print_statement,\n            # Python 2.7\n            pygram.python_grammar,\n        ]\n\n    if all(version.is_python2() for version in target_versions):\n        # Python 2-only code, so try Python 2 grammars.\n        return [\n            # Python 2.7 with future print_function import\n            pygram.python_grammar_no_print_statement,\n            # Python 2.7\n            pygram.python_grammar,\n        ]\n\n    # Python 3-compatible code, so only try Python 3 grammar.\n    grammars = []\n    # If we have to parse both, try to parse async as a keyword first\n    if not supports_feature(target_versions, Feature.ASYNC_IDENTIFIERS):\n        # Python 3.7+\n        grammars.append(\n            pygram.python_grammar_no_print_statement_no_exec_statement_async_keywords\n        )\n    if not supports_feature(target_versions, Feature.ASYNC_KEYWORDS):\n        # Python 3.0-3.6\n        grammars.append(pygram.python_grammar_no_print_statement_no_exec_statement)\n    # At least one of the above branches must have been taken, because every Python\n    # version has exactly one of the two 'ASYNC_*' flags\n    return grammars", "is_method": false, "function_description": "Function that returns appropriate Python grammar definitions based on specified target Python versions, supporting version-specific parsing needs for compatibility across Python 2 and Python 3 variants."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "lib2to3_parse", "line_number": 1063, "body": "def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -> Node:\n    \"\"\"Given a string with source, return the lib2to3 Node.\"\"\"\n    if src_txt[-1:] != \"\\n\":\n        src_txt += \"\\n\"\n\n    for grammar in get_grammars(set(target_versions)):\n        drv = driver.Driver(grammar, pytree.convert)\n        try:\n            result = drv.parse_string(src_txt, True)\n            break\n\n        except ParseError as pe:\n            lineno, column = pe.context[1]\n            lines = src_txt.splitlines()\n            try:\n                faulty_line = lines[lineno - 1]\n            except IndexError:\n                faulty_line = \"<line number missing in source>\"\n            exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n    else:\n        raise exc from None\n\n    if isinstance(result, Leaf):\n        result = Node(syms.file_input, [result])\n    return result", "is_method": false, "function_description": "Parses Python source code into a lib2to3 syntax tree node, supporting multiple target Python versions and providing detailed error reporting on invalid input."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "lib2to3_unparse", "line_number": 1090, "body": "def lib2to3_unparse(node: Node) -> str:\n    \"\"\"Given a lib2to3 node, return its string representation.\"\"\"\n    code = str(node)\n    return code", "is_method": false, "function_description": "Utility function that converts a lib2to3 syntax tree node into its corresponding source code string representation."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "whitespace", "line_number": 2090, "body": "def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa: C901\n    \"\"\"Return whitespace prefix if needed for the given `leaf`.\n\n    `complex_subscript` signals whether the given leaf is part of a subscription\n    which has non-trivial arguments, like arithmetic expressions or function calls.\n    \"\"\"\n    NO = \"\"\n    SPACE = \" \"\n    DOUBLESPACE = \"  \"\n    t = leaf.type\n    p = leaf.parent\n    v = leaf.value\n    if t in ALWAYS_NO_SPACE:\n        return NO\n\n    if t == token.COMMENT:\n        return DOUBLESPACE\n\n    assert p is not None, f\"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}\"\n    if t == token.COLON and p.type not in {\n        syms.subscript,\n        syms.subscriptlist,\n        syms.sliceop,\n    }:\n        return NO\n\n    prev = leaf.prev_sibling\n    if not prev:\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type in OPENING_BRACKETS:\n            return NO\n\n        if t == token.COLON:\n            if prevp.type == token.COLON:\n                return NO\n\n            elif prevp.type != token.COMMA and not complex_subscript:\n                return NO\n\n            return SPACE\n\n        if prevp.type == token.EQUAL:\n            if prevp.parent:\n                if prevp.parent.type in {\n                    syms.arglist,\n                    syms.argument,\n                    syms.parameters,\n                    syms.varargslist,\n                }:\n                    return NO\n\n                elif prevp.parent.type == syms.typedargslist:\n                    # A bit hacky: if the equal sign has whitespace, it means we\n                    # previously found it's a typed argument.  So, we're using\n                    # that, too.\n                    return prevp.prefix\n\n        elif prevp.type in VARARGS_SPECIALS:\n            if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS):\n                return NO\n\n        elif prevp.type == token.COLON:\n            if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}:\n                return SPACE if complex_subscript else NO\n\n        elif (\n            prevp.parent\n            and prevp.parent.type == syms.factor\n            and prevp.type in MATH_OPERATORS\n        ):\n            return NO\n\n        elif (\n            prevp.type == token.RIGHTSHIFT\n            and prevp.parent\n            and prevp.parent.type == syms.shift_expr\n            and prevp.prev_sibling\n            and prevp.prev_sibling.type == token.NAME\n            and prevp.prev_sibling.value == \"print\"  # type: ignore\n        ):\n            # Python 2 print chevron\n            return NO\n\n    elif prev.type in OPENING_BRACKETS:\n        return NO\n\n    if p.type in {syms.parameters, syms.arglist}:\n        # untyped function signatures or calls\n        if not prev or prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.varargslist:\n        # lambdas\n        if prev and prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.typedargslist:\n        # typed function signatures\n        if not prev:\n            return NO\n\n        if t == token.EQUAL:\n            if prev.type != syms.tname:\n                return NO\n\n        elif prev.type == token.EQUAL:\n            # A bit hacky: if the equal sign has whitespace, it means we\n            # previously found it's a typed argument.  So, we're using that, too.\n            return prev.prefix\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.tname:\n        # type names\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type != token.COMMA:\n                return NO\n\n    elif p.type == syms.trailer:\n        # attributes and calls\n        if t == token.LPAR or t == token.RPAR:\n            return NO\n\n        if not prev:\n            if t == token.DOT:\n                prevp = preceding_leaf(p)\n                if not prevp or prevp.type != token.NUMBER:\n                    return NO\n\n            elif t == token.LSQB:\n                return NO\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.argument:\n        # single argument\n        if t == token.EQUAL:\n            return NO\n\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type == token.LPAR:\n                return NO\n\n        elif prev.type in {token.EQUAL} | VARARGS_SPECIALS:\n            return NO\n\n    elif p.type == syms.decorator:\n        # decorators\n        return NO\n\n    elif p.type == syms.dotted_name:\n        if prev:\n            return NO\n\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type == token.AT or prevp.type == token.DOT:\n            return NO\n\n    elif p.type == syms.classdef:\n        if t == token.LPAR:\n            return NO\n\n        if prev and prev.type == token.LPAR:\n            return NO\n\n    elif p.type in {syms.subscript, syms.sliceop}:\n        # indexing\n        if not prev:\n            assert p.parent is not None, \"subscripts are always parented\"\n            if p.parent.type == syms.subscriptlist:\n                return SPACE\n\n            return NO\n\n        elif not complex_subscript:\n            return NO\n\n    elif p.type == syms.atom:\n        if prev and t == token.DOT:\n            # dots, but not the first one.\n            return NO\n\n    elif p.type == syms.dictsetmaker:\n        # dict unpacking\n        if prev and prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type in {syms.factor, syms.star_expr}:\n        # unary ops\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type in OPENING_BRACKETS:\n                return NO\n\n            prevp_parent = prevp.parent\n            assert prevp_parent is not None\n            if prevp.type == token.COLON and prevp_parent.type in {\n                syms.subscript,\n                syms.sliceop,\n            }:\n                return NO\n\n            elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument:\n                return NO\n\n        elif t in {token.NAME, token.NUMBER, token.STRING}:\n            return NO\n\n    elif p.type == syms.import_from:\n        if t == token.DOT:\n            if prev and prev.type == token.DOT:\n                return NO\n\n        elif t == token.NAME:\n            if v == \"import\":\n                return SPACE\n\n            if prev and prev.type == token.DOT:\n                return NO\n\n    elif p.type == syms.sliceop:\n        return NO\n\n    return SPACE", "is_method": false, "function_description": "Utility function that determines the appropriate whitespace prefix for a token leaf based on its syntactic context, aiding precise formatting in Python code parsing or pretty-printing, especially within complex subscription expressions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "preceding_leaf", "line_number": 2320, "body": "def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:\n    \"\"\"Return the first leaf that precedes `node`, if any.\"\"\"\n    while node:\n        res = node.prev_sibling\n        if res:\n            if isinstance(res, Leaf):\n                return res\n\n            try:\n                return list(res.leaves())[-1]\n\n            except IndexError:\n                return None\n\n        node = node.parent\n    return None", "is_method": false, "function_description": "Utility function that finds and returns the closest preceding leaf node relative to a given node, supporting tree traversal tasks such as document or syntax tree analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "prev_siblings_are", "line_number": 2338, "body": "def prev_siblings_are(node: Optional[LN], tokens: List[Optional[NodeType]]) -> bool:\n    \"\"\"Return if the `node` and its previous siblings match types against the provided\n    list of tokens; the provided `node`has its type matched against the last element in\n    the list.  `None` can be used as the first element to declare that the start of the\n    list is anchored at the start of its parent's children.\"\"\"\n    if not tokens:\n        return True\n    if tokens[-1] is None:\n        return node is None\n    if not node:\n        return False\n    if node.type != tokens[-1]:\n        return False\n    return prev_siblings_are(node.prev_sibling, tokens[:-1])", "is_method": false, "function_description": "Utility function that checks if a node and its preceding siblings in a tree match a specific sequence of node types, supporting optional anchoring at the start of the parent's children list. It enables pattern recognition in sibling node chains."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "child_towards", "line_number": 2354, "body": "def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:\n    \"\"\"Return the child of `ancestor` that contains `descendant`.\"\"\"\n    node: Optional[LN] = descendant\n    while node and node.parent != ancestor:\n        node = node.parent\n    return node", "is_method": false, "function_description": "Function to identify which immediate child of a given ancestor node lies on the path to a specified descendant node in a tree structure. Useful for navigating or analyzing hierarchical relationships between nodes."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "container_of", "line_number": 2362, "body": "def container_of(leaf: Leaf) -> LN:\n    \"\"\"Return `leaf` or one of its ancestors that is the topmost container of it.\n\n    By \"container\" we mean a node where `leaf` is the very first child.\n    \"\"\"\n    same_prefix = leaf.prefix\n    container: LN = leaf\n    while container:\n        parent = container.parent\n        if parent is None:\n            break\n\n        if parent.children[0].prefix != same_prefix:\n            break\n\n        if parent.type == syms.file_input:\n            break\n\n        if parent.prev_sibling is not None and parent.prev_sibling.type in BRACKETS:\n            break\n\n        container = parent\n    return container", "is_method": false, "function_description": "Provides the topmost ancestor node that shares the same prefix and where the given leaf is the first child, effectively identifying the largest container node for that leaf within a parsed syntax tree."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_split_after_delimiter", "line_number": 2387, "body": "def is_split_after_delimiter(leaf: Leaf, previous: Optional[Leaf] = None) -> Priority:\n    \"\"\"Return the priority of the `leaf` delimiter, given a line break after it.\n\n    The delimiter priorities returned here are from those delimiters that would\n    cause a line break after themselves.\n\n    Higher numbers are higher priority.\n    \"\"\"\n    if leaf.type == token.COMMA:\n        return COMMA_PRIORITY\n\n    return 0", "is_method": false, "function_description": "Determines the priority level of a delimiter token when a line break follows it, supporting formatting decisions based on delimiter type. Useful for managing line breaks in code or text parsing by assigning priority values to delimiters."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_split_before_delimiter", "line_number": 2401, "body": "def is_split_before_delimiter(leaf: Leaf, previous: Optional[Leaf] = None) -> Priority:\n    \"\"\"Return the priority of the `leaf` delimiter, given a line break before it.\n\n    The delimiter priorities returned here are from those delimiters that would\n    cause a line break before themselves.\n\n    Higher numbers are higher priority.\n    \"\"\"\n    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):\n        # * and ** might also be MATH_OPERATORS but in this case they are not.\n        # Don't treat them as a delimiter.\n        return 0\n\n    if (\n        leaf.type == token.DOT\n        and leaf.parent\n        and leaf.parent.type not in {syms.import_from, syms.dotted_name}\n        and (previous is None or previous.type in CLOSING_BRACKETS)\n    ):\n        return DOT_PRIORITY\n\n    if (\n        leaf.type in MATH_OPERATORS\n        and leaf.parent\n        and leaf.parent.type not in {syms.factor, syms.star_expr}\n    ):\n        return MATH_PRIORITIES[leaf.type]\n\n    if leaf.type in COMPARATORS:\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.type == token.STRING\n        and previous is not None\n        and previous.type == token.STRING\n    ):\n        return STRING_PRIORITY\n\n    if leaf.type not in {token.NAME, token.ASYNC}:\n        return 0\n\n    if (\n        leaf.value == \"for\"\n        and leaf.parent\n        and leaf.parent.type in {syms.comp_for, syms.old_comp_for}\n        or leaf.type == token.ASYNC\n    ):\n        if (\n            not isinstance(leaf.prev_sibling, Leaf)\n            or leaf.prev_sibling.value != \"async\"\n        ):\n            return COMPREHENSION_PRIORITY\n\n    if (\n        leaf.value == \"if\"\n        and leaf.parent\n        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}\n    ):\n        return COMPREHENSION_PRIORITY\n\n    if leaf.value in {\"if\", \"else\"} and leaf.parent and leaf.parent.type == syms.test:\n        return TERNARY_PRIORITY\n\n    if leaf.value == \"is\":\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.value == \"in\"\n        and leaf.parent\n        and leaf.parent.type in {syms.comp_op, syms.comparison}\n        and not (\n            previous is not None\n            and previous.type == token.NAME\n            and previous.value == \"not\"\n        )\n    ):\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.value == \"not\"\n        and leaf.parent\n        and leaf.parent.type == syms.comp_op\n        and not (\n            previous is not None\n            and previous.type == token.NAME\n            and previous.value == \"is\"\n        )\n    ):\n        return COMPARATOR_PRIORITY\n\n    if leaf.value in LOGIC_OPERATORS and leaf.parent:\n        return LOGIC_PRIORITY\n\n    return 0", "is_method": false, "function_description": "Determines the priority level of a given code delimiter when a line break occurs before it, enabling formatting decisions based on language-specific syntax and operator rules. Useful for code formatters to manage line breaking and indentation logic effectively."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "generate_comments", "line_number": 2501, "body": "def generate_comments(leaf: LN) -> Iterator[Leaf]:\n    \"\"\"Clean the prefix of the `leaf` and generate comments from it, if any.\n\n    Comments in lib2to3 are shoved into the whitespace prefix.  This happens\n    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation\n    move because it does away with modifying the grammar to include all the\n    possible places in which comments can be placed.\n\n    The sad consequence for us though is that comments don't \"belong\" anywhere.\n    This is why this function generates simple parentless Leaf objects for\n    comments.  We simply don't know what the correct parent should be.\n\n    No matter though, we can live without this.  We really only need to\n    differentiate between inline and standalone comments.  The latter don't\n    share the line with any code.\n\n    Inline comments are emitted as regular token.COMMENT leaves.  Standalone\n    are emitted with a fake STANDALONE_COMMENT token identifier.\n    \"\"\"\n    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):\n        yield Leaf(pc.type, pc.value, prefix=\"\\n\" * pc.newlines)", "is_method": false, "function_description": "Generates standalone comment leaf nodes from a code leaf\u2019s prefix, distinguishing inline versus standalone comments for parsing purposes where comments lack clear syntactic parents."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "list_comments", "line_number": 2543, "body": "def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:\n    \"\"\"Return a list of :class:`ProtoComment` objects parsed from the given `prefix`.\"\"\"\n    result: List[ProtoComment] = []\n    if not prefix or \"#\" not in prefix:\n        return result\n\n    consumed = 0\n    nlines = 0\n    ignored_lines = 0\n    for index, line in enumerate(prefix.split(\"\\n\")):\n        consumed += len(line) + 1  # adding the length of the split '\\n'\n        line = line.lstrip()\n        if not line:\n            nlines += 1\n        if not line.startswith(\"#\"):\n            # Escaped newlines outside of a comment are not really newlines at\n            # all. We treat a single-line comment following an escaped newline\n            # as a simple trailing comment.\n            if line.endswith(\"\\\\\"):\n                ignored_lines += 1\n            continue\n\n        if index == ignored_lines and not is_endmarker:\n            comment_type = token.COMMENT  # simple trailing comment\n        else:\n            comment_type = STANDALONE_COMMENT\n        comment = make_comment(line)\n        result.append(\n            ProtoComment(\n                type=comment_type, value=comment, newlines=nlines, consumed=consumed\n            )\n        )\n        nlines = 0\n    return result", "is_method": false, "function_description": "Function that parses a given text prefix to extract and return a list of structured comment objects, distinguishing between trailing and standalone comments. Useful for processing and analyzing comment metadata in source code or text blocks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "make_comment", "line_number": 2579, "body": "def make_comment(content: str) -> str:\n    \"\"\"Return a consistently formatted comment from the given `content` string.\n\n    All comments (except for \"##\", \"#!\", \"#:\", '#'\", \"#%%\") should have a single\n    space between the hash sign and the content.\n\n    If `content` didn't start with a hash sign, one is provided.\n    \"\"\"\n    content = content.rstrip()\n    if not content:\n        return \"#\"\n\n    if content[0] == \"#\":\n        content = content[1:]\n    if content and content[0] not in \" !:#'%\":\n        content = \" \" + content\n    return \"#\" + content", "is_method": false, "function_description": "Function that formats a given string as a standardized Python comment, ensuring it begins with a hash and has proper spacing. Useful for generating consistent comment lines in code generation or text processing tools."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "transform_line", "line_number": 2598, "body": "def transform_line(\n    line: Line, mode: Mode, features: Collection[Feature] = ()\n) -> Iterator[Line]:\n    \"\"\"Transform a `line`, potentially splitting it into many lines.\n\n    They should fit in the allotted `line_length` but might not be able to.\n\n    `features` are syntactical features that may be used in the output.\n    \"\"\"\n    if line.is_comment:\n        yield line\n        return\n\n    line_str = line_to_string(line)\n\n    def init_st(ST: Type[StringTransformer]) -> StringTransformer:\n        \"\"\"Initialize StringTransformer\"\"\"\n        return ST(mode.line_length, mode.string_normalization)\n\n    string_merge = init_st(StringMerger)\n    string_paren_strip = init_st(StringParenStripper)\n    string_split = init_st(StringSplitter)\n    string_paren_wrap = init_st(StringParenWrapper)\n\n    transformers: List[Transformer]\n    if (\n        not line.contains_uncollapsable_type_comments()\n        and not line.should_explode\n        and (\n            is_line_short_enough(line, line_length=mode.line_length, line_str=line_str)\n            or line.contains_unsplittable_type_ignore()\n        )\n        and not (line.inside_brackets and line.contains_standalone_comments())\n    ):\n        # Only apply basic string preprocessing, since lines shouldn't be split here.\n        if mode.experimental_string_processing:\n            transformers = [string_merge, string_paren_strip]\n        else:\n            transformers = []\n    elif line.is_def:\n        transformers = [left_hand_split]\n    else:\n\n        def rhs(line: Line, features: Collection[Feature]) -> Iterator[Line]:\n            \"\"\"Wraps calls to `right_hand_split`.\n\n            The calls increasingly `omit` right-hand trailers (bracket pairs with\n            content), meaning the trailers get glued together to split on another\n            bracket pair instead.\n            \"\"\"\n            for omit in generate_trailers_to_omit(line, mode.line_length):\n                lines = list(\n                    right_hand_split(line, mode.line_length, features, omit=omit)\n                )\n                # Note: this check is only able to figure out if the first line of the\n                # *current* transformation fits in the line length.  This is true only\n                # for simple cases.  All others require running more transforms via\n                # `transform_line()`.  This check doesn't know if those would succeed.\n                if is_line_short_enough(lines[0], line_length=mode.line_length):\n                    yield from lines\n                    return\n\n            # All splits failed, best effort split with no omits.\n            # This mostly happens to multiline strings that are by definition\n            # reported as not fitting a single line, as well as lines that contain\n            # trailing commas (those have to be exploded).\n            yield from right_hand_split(\n                line, line_length=mode.line_length, features=features\n            )\n\n        if mode.experimental_string_processing:\n            if line.inside_brackets:\n                transformers = [\n                    string_merge,\n                    string_paren_strip,\n                    delimiter_split,\n                    standalone_comment_split,\n                    string_split,\n                    string_paren_wrap,\n                    rhs,\n                ]\n            else:\n                transformers = [\n                    string_merge,\n                    string_paren_strip,\n                    string_split,\n                    string_paren_wrap,\n                    rhs,\n                ]\n        else:\n            if line.inside_brackets:\n                transformers = [delimiter_split, standalone_comment_split, rhs]\n            else:\n                transformers = [rhs]\n\n    for transform in transformers:\n        # We are accumulating lines in `result` because we might want to abort\n        # mission and return the original line in the end, or attempt a different\n        # split altogether.\n        try:\n            result = run_transformer(line, transform, mode, features, line_str=line_str)\n        except CannotTransform:\n            continue\n        else:\n            yield from result\n            break\n\n    else:\n        yield line", "is_method": false, "function_description": "Function that processes and potentially splits a line of code into multiple lines according to formatting rules, line length, and syntactical features. It supports various transformation strategies to produce well-formatted output for code formatting or linting tools."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "TErr", "line_number": 4431, "body": "def TErr(err_msg: str) -> Err[CannotTransform]:\n    \"\"\"(T)ransform Err\n\n    Convenience function used when working with the TResult type.\n    \"\"\"\n    cant_transform = CannotTransform(err_msg)\n    return Err(cant_transform)", "is_method": false, "function_description": "Utility function that creates a transformation error wrapped in a standardized error type, facilitating consistent error handling when transformations fail."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "contains_pragma_comment", "line_number": 4440, "body": "def contains_pragma_comment(comment_list: List[Leaf]) -> bool:\n    \"\"\"\n    Returns:\n        True iff one of the comments in @comment_list is a pragma used by one\n        of the more common static analysis tools for python (e.g. mypy, flake8,\n        pylint).\n    \"\"\"\n    for comment in comment_list:\n        if comment.value.startswith((\"# type:\", \"# noqa\", \"# pylint:\")):\n            return True\n\n    return False", "is_method": false, "function_description": "Function that checks if a list of comments contains any pragma directives used by common Python static analysis tools, aiding in the identification of code segments with special linting or type-checking instructions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "insert_str_child_factory", "line_number": 4454, "body": "def insert_str_child_factory(string_leaf: Leaf) -> Callable[[LN], None]:\n    \"\"\"\n    Factory for a convenience function that is used to orphan @string_leaf\n    and then insert multiple new leaves into the same part of the node\n    structure that @string_leaf had originally occupied.\n\n    Examples:\n        Let `string_leaf = Leaf(token.STRING, '\"foo\"')` and `N =\n        string_leaf.parent`. Assume the node `N` has the following\n        original structure:\n\n        Node(\n            expr_stmt, [\n                Leaf(NAME, 'x'),\n                Leaf(EQUAL, '='),\n                Leaf(STRING, '\"foo\"'),\n            ]\n        )\n\n        We then run the code snippet shown below.\n        ```\n        insert_str_child = insert_str_child_factory(string_leaf)\n\n        lpar = Leaf(token.LPAR, '(')\n        insert_str_child(lpar)\n\n        bar = Leaf(token.STRING, '\"bar\"')\n        insert_str_child(bar)\n\n        rpar = Leaf(token.RPAR, ')')\n        insert_str_child(rpar)\n        ```\n\n        After which point, it follows that `string_leaf.parent is None` and\n        the node `N` now has the following structure:\n\n        Node(\n            expr_stmt, [\n                Leaf(NAME, 'x'),\n                Leaf(EQUAL, '='),\n                Leaf(LPAR, '('),\n                Leaf(STRING, '\"bar\"'),\n                Leaf(RPAR, ')'),\n            ]\n        )\n    \"\"\"\n    string_parent = string_leaf.parent\n    string_child_idx = string_leaf.remove()\n\n    def insert_str_child(child: LN) -> None:\n        nonlocal string_child_idx\n\n        assert string_parent is not None\n        assert string_child_idx is not None\n\n        string_parent.insert_child(string_child_idx, child)\n        string_child_idx += 1\n\n    return insert_str_child", "is_method": false, "function_description": "Creates a function to replace a specific leaf node by removing it and allowing sequential insertion of new leaf nodes at its original position within the parent node. Useful for structured tree modifications while preserving node order."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "has_triple_quotes", "line_number": 4515, "body": "def has_triple_quotes(string: str) -> bool:\n    \"\"\"\n    Returns:\n        True iff @string starts with three quotation characters.\n    \"\"\"\n    raw_string = string.lstrip(STRING_PREFIX_CHARS)\n    return raw_string[:3] in {'\"\"\"', \"'''\"}", "is_method": false, "function_description": "Function that checks if a given string starts with triple quotation marks, indicating a docstring or multiline string in Python. Useful for parsing or analyzing Python source code literals."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "parent_type", "line_number": 4524, "body": "def parent_type(node: Optional[LN]) -> Optional[NodeType]:\n    \"\"\"\n    Returns:\n        @node.parent.type, if @node is not None and has a parent.\n            OR\n        None, otherwise.\n    \"\"\"\n    if node is None or node.parent is None:\n        return None\n\n    return node.parent.type", "is_method": false, "function_description": "Returns the type of the parent node if the given node and its parent exist; otherwise, returns None. Useful for navigating or analyzing node hierarchies in tree-like data structures."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_empty_par", "line_number": 4537, "body": "def is_empty_par(leaf: Leaf) -> bool:\n    return is_empty_lpar(leaf) or is_empty_rpar(leaf)", "is_method": false, "function_description": "Utility function that determines whether a leaf node represents an empty parenthesis by checking if it is either an empty left or right parenthesis."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_empty_lpar", "line_number": 4541, "body": "def is_empty_lpar(leaf: Leaf) -> bool:\n    return leaf.type == token.LPAR and leaf.value == \"\"", "is_method": false, "function_description": "Utility function that checks if a leaf token represents an empty left parenthesis. It helps identify specific token conditions within parsing or token analysis workflows."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_empty_rpar", "line_number": 4545, "body": "def is_empty_rpar(leaf: Leaf) -> bool:\n    return leaf.type == token.RPAR and leaf.value == \"\"", "is_method": false, "function_description": "This function determines whether a given leaf represents an empty right parenthesis token, useful for parsing or analyzing token streams where such specific token checks are needed."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_valid_index_factory", "line_number": 4549, "body": "def is_valid_index_factory(seq: Sequence[Any]) -> Callable[[int], bool]:\n    \"\"\"\n    Examples:\n        ```\n        my_list = [1, 2, 3]\n\n        is_valid_index = is_valid_index_factory(my_list)\n\n        assert is_valid_index(0)\n        assert is_valid_index(2)\n\n        assert not is_valid_index(3)\n        assert not is_valid_index(-1)\n        ```\n    \"\"\"\n\n    def is_valid_index(idx: int) -> bool:\n        \"\"\"\n        Returns:\n            True iff @idx is positive AND seq[@idx] does NOT raise an\n            IndexError.\n        \"\"\"\n        return 0 <= idx < len(seq)\n\n    return is_valid_index", "is_method": false, "function_description": "Creates and returns a function that checks if a given index is valid and within bounds for the provided sequence. This utility enables safe index validation for any sequence without manually handling exceptions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "line_to_string", "line_number": 4576, "body": "def line_to_string(line: Line) -> str:\n    \"\"\"Returns the string representation of @line.\n\n    WARNING: This is known to be computationally expensive.\n    \"\"\"\n    return str(line).strip(\"\\n\")", "is_method": false, "function_description": "Converts a Line object into its string form, removing trailing newline characters. Useful for obtaining a clean textual representation despite its potentially high computational cost."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "append_leaves", "line_number": 4584, "body": "def append_leaves(new_line: Line, old_line: Line, leaves: List[Leaf]) -> None:\n    \"\"\"\n    Append leaves (taken from @old_line) to @new_line, making sure to fix the\n    underlying Node structure where appropriate.\n\n    All of the leaves in @leaves are duplicated. The duplicates are then\n    appended to @new_line and used to replace their originals in the underlying\n    Node structure. Any comments attached to the old leaves are reattached to\n    the new leaves.\n\n    Pre-conditions:\n        set(@leaves) is a subset of set(@old_line.leaves).\n    \"\"\"\n    for old_leaf in leaves:\n        new_leaf = Leaf(old_leaf.type, old_leaf.value)\n        replace_child(old_leaf, new_leaf)\n        new_line.append(new_leaf)\n\n        for comment_leaf in old_line.comments_after(old_leaf):\n            new_line.append(comment_leaf, preformatted=True)", "is_method": false, "function_description": "Utility function that duplicates specified leaves from one line and appends them to another, updating the underlying node structure and preserving associated comments. It supports safe modification of line contents while maintaining structural integrity."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "replace_child", "line_number": 4606, "body": "def replace_child(old_child: LN, new_child: LN) -> None:\n    \"\"\"\n    Side Effects:\n        * If @old_child.parent is set, replace @old_child with @new_child in\n        @old_child's underlying Node structure.\n            OR\n        * Otherwise, this function does nothing.\n    \"\"\"\n    parent = old_child.parent\n    if not parent:\n        return\n\n    child_idx = old_child.remove()\n    if child_idx is not None:\n        parent.insert_child(child_idx, new_child)", "is_method": false, "function_description": "Utility function that replaces an existing child node with a new child node in the parent node\u2019s structure, if the old child has a parent assigned. Useful for modifying hierarchical node trees safely."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "get_string_prefix", "line_number": 4623, "body": "def get_string_prefix(string: str) -> str:\n    \"\"\"\n    Pre-conditions:\n        * assert_is_leaf_string(@string)\n\n    Returns:\n        @string's prefix (e.g. '', 'r', 'f', or 'rf').\n    \"\"\"\n    assert_is_leaf_string(string)\n\n    prefix = \"\"\n    prefix_idx = 0\n    while string[prefix_idx] in STRING_PREFIX_CHARS:\n        prefix += string[prefix_idx].lower()\n        prefix_idx += 1\n\n    return prefix", "is_method": false, "function_description": "Function that extracts and returns the prefix (such as '', 'r', 'f', or 'rf') from a string literal, useful for identifying string type modifiers in source code analysis or parsing tasks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "assert_is_leaf_string", "line_number": 4642, "body": "def assert_is_leaf_string(string: str) -> None:\n    \"\"\"\n    Checks the pre-condition that @string has the format that you would expect\n    of `leaf.value` where `leaf` is some Leaf such that `leaf.type ==\n    token.STRING`. A more precise description of the pre-conditions that are\n    checked are listed below.\n\n    Pre-conditions:\n        * @string starts with either ', \", <prefix>', or <prefix>\" where\n        `set(<prefix>)` is some subset of `set(STRING_PREFIX_CHARS)`.\n        * @string ends with a quote character (' or \").\n\n    Raises:\n        AssertionError(...) if the pre-conditions listed above are not\n        satisfied.\n    \"\"\"\n    dquote_idx = string.find('\"')\n    squote_idx = string.find(\"'\")\n    if -1 in [dquote_idx, squote_idx]:\n        quote_idx = max(dquote_idx, squote_idx)\n    else:\n        quote_idx = min(squote_idx, dquote_idx)\n\n    assert (\n        0 <= quote_idx < len(string) - 1\n    ), f\"{string!r} is missing a starting quote character (' or \\\").\"\n    assert string[-1] in (\n        \"'\",\n        '\"',\n    ), f\"{string!r} is missing an ending quote character (' or \\\").\"\n    assert set(string[:quote_idx]).issubset(\n        set(STRING_PREFIX_CHARS)\n    ), f\"{set(string[:quote_idx])} is NOT a subset of {set(STRING_PREFIX_CHARS)}.\"", "is_method": false, "function_description": "Utility function that validates whether a string matches the expected format of a leaf token representing a string literal, ensuring correct prefix and quote characters. It is useful for precondition checks in parsers or token validators."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "left_hand_split", "line_number": 4677, "body": "def left_hand_split(line: Line, _features: Collection[Feature] = ()) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the first matching bracket pair.\n\n    Note: this usually looks weird, only use this for function definitions.\n    Prefer RHS otherwise.  This is why this function is not symmetrical with\n    :func:`right_hand_split` which also handles optional parentheses.\n    \"\"\"\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = head_leaves\n    matching_bracket: Optional[Leaf] = None\n    for leaf in line.leaves:\n        if (\n            current_leaves is body_leaves\n            and leaf.type in CLOSING_BRACKETS\n            and leaf.opening_bracket is matching_bracket\n        ):\n            current_leaves = tail_leaves if body_leaves else head_leaves\n        current_leaves.append(leaf)\n        if current_leaves is head_leaves:\n            if leaf.type in OPENING_BRACKETS:\n                matching_bracket = leaf\n                current_leaves = body_leaves\n    if not matching_bracket:\n        raise CannotSplit(\"No brackets found\")\n\n    head = bracket_split_build_line(head_leaves, line, matching_bracket)\n    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)\n    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    for result in (head, body, tail):\n        if result:\n            yield result", "is_method": false, "function_description": "Utility function that splits a line into multiple parts at the first matching bracket pair, primarily for parsing function definitions by isolating components around bracketed expressions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "right_hand_split", "line_number": 4713, "body": "def right_hand_split(\n    line: Line,\n    line_length: int,\n    features: Collection[Feature] = (),\n    omit: Collection[LeafID] = (),\n) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the last matching bracket pair.\n\n    If the split was by optional parentheses, attempt splitting without them, too.\n    `omit` is a collection of closing bracket IDs that shouldn't be considered for\n    this split.\n\n    Note: running this function modifies `bracket_depth` on the leaves of `line`.\n    \"\"\"\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = tail_leaves\n    opening_bracket: Optional[Leaf] = None\n    closing_bracket: Optional[Leaf] = None\n    for leaf in reversed(line.leaves):\n        if current_leaves is body_leaves:\n            if leaf is opening_bracket:\n                current_leaves = head_leaves if body_leaves else tail_leaves\n        current_leaves.append(leaf)\n        if current_leaves is tail_leaves:\n            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:\n                opening_bracket = leaf.opening_bracket\n                closing_bracket = leaf\n                current_leaves = body_leaves\n    if not (opening_bracket and closing_bracket and head_leaves):\n        # If there is no opening or closing_bracket that means the split failed and\n        # all content is in the tail.  Otherwise, if `head_leaves` are empty, it means\n        # the matching `opening_bracket` wasn't available on `line` anymore.\n        raise CannotSplit(\"No brackets found\")\n\n    tail_leaves.reverse()\n    body_leaves.reverse()\n    head_leaves.reverse()\n    head = bracket_split_build_line(head_leaves, line, opening_bracket)\n    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)\n    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    if (\n        Feature.FORCE_OPTIONAL_PARENTHESES not in features\n        # the opening bracket is an optional paren\n        and opening_bracket.type == token.LPAR\n        and not opening_bracket.value\n        # the closing bracket is an optional paren\n        and closing_bracket.type == token.RPAR\n        and not closing_bracket.value\n        # it's not an import (optional parens are the only thing we can split on\n        # in this case; attempting a split without them is a waste of time)\n        and not line.is_import\n        # there are no standalone comments in the body\n        and not body.contains_standalone_comments(0)\n        # and we can actually remove the parens\n        and can_omit_invisible_parens(body, line_length, omit_on_explode=omit)\n    ):\n        omit = {id(closing_bracket), *omit}\n        try:\n            yield from right_hand_split(line, line_length, features=features, omit=omit)\n            return\n\n        except CannotSplit:\n            if not (\n                can_be_split(body)\n                or is_line_short_enough(body, line_length=line_length)\n            ):\n                raise CannotSplit(\n                    \"Splitting failed, body is still too long and can't be split.\"\n                )\n\n            elif head.contains_multiline_strings() or tail.contains_multiline_strings():\n                raise CannotSplit(\n                    \"The current optional pair of parentheses is bound to fail to\"\n                    \" satisfy the splitting algorithm because the head or the tail\"\n                    \" contains multiline strings which by definition never fit one\"\n                    \" line.\"\n                )\n\n    ensure_visible(opening_bracket)\n    ensure_visible(closing_bracket)\n    for result in (head, body, tail):\n        if result:\n            yield result", "is_method": false, "function_description": "Function of a line splitter that iteratively splits a line into head, body, and tail segments by identifying the last matching bracket pair, with special handling for optional parentheses and line length constraints. It helps break complex lines into manageable parts respecting syntax rules."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "bracket_split_succeeded_or_raise", "line_number": 4801, "body": "def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:\n    \"\"\"Raise :exc:`CannotSplit` if the last left- or right-hand split failed.\n\n    Do nothing otherwise.\n\n    A left- or right-hand split is based on a pair of brackets. Content before\n    (and including) the opening bracket is left on one line, content inside the\n    brackets is put on a separate line, and finally content starting with and\n    following the closing bracket is put on a separate line.\n\n    Those are called `head`, `body`, and `tail`, respectively. If the split\n    produced the same line (all content in `head`) or ended up with an empty `body`\n    and the `tail` is just the closing bracket, then it's considered failed.\n    \"\"\"\n    tail_len = len(str(tail).strip())\n    if not body:\n        if tail_len == 0:\n            raise CannotSplit(\"Splitting brackets produced the same line\")\n\n        elif tail_len < 3:\n            raise CannotSplit(\n                f\"Splitting brackets on an empty body to save {tail_len} characters is\"\n                \" not worth it\"\n            )", "is_method": false, "function_description": "Utility function that validates the success of a bracket-based line split by raising an exception if the split fails, ensuring that content is properly separated into head, body, and tail segments after bracket splitting."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "bracket_split_build_line", "line_number": 4827, "body": "def bracket_split_build_line(\n    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False\n) -> Line:\n    \"\"\"Return a new line with given `leaves` and respective comments from `original`.\n\n    If `is_body` is True, the result line is one-indented inside brackets and as such\n    has its first leaf's prefix normalized and a trailing comma added when expected.\n    \"\"\"\n    result = Line(depth=original.depth)\n    if is_body:\n        result.inside_brackets = True\n        result.depth += 1\n        if leaves:\n            # Since body is a new indent level, remove spurious leading whitespace.\n            normalize_prefix(leaves[0], inside_brackets=True)\n            # Ensure a trailing comma for imports and standalone function arguments, but\n            # be careful not to add one after any comments or within type annotations.\n            no_commas = (\n                original.is_def\n                and opening_bracket.value == \"(\"\n                and not any(leaf.type == token.COMMA for leaf in leaves)\n            )\n\n            if original.is_import or no_commas:\n                for i in range(len(leaves) - 1, -1, -1):\n                    if leaves[i].type == STANDALONE_COMMENT:\n                        continue\n\n                    if leaves[i].type != token.COMMA:\n                        new_comma = Leaf(token.COMMA, \",\")\n                        leaves.insert(i + 1, new_comma)\n                    break\n\n    # Populate the line\n    for leaf in leaves:\n        result.append(leaf, preformatted=True)\n        for comment_after in original.comments_after(leaf):\n            result.append(comment_after, preformatted=True)\n    if is_body and should_split_body_explode(result, opening_bracket):\n        result.should_explode = True\n    return result", "is_method": false, "function_description": "Creates a new indented line from given leaves, preserving original comments and managing trailing commas inside brackets. Useful for formatting code blocks like import statements or function arguments with proper indentation and punctuation."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "dont_increase_indentation", "line_number": 4870, "body": "def dont_increase_indentation(split_func: Transformer) -> Transformer:\n    \"\"\"Normalize prefix of the first leaf in every line returned by `split_func`.\n\n    This is a decorator over relevant split functions.\n    \"\"\"\n\n    @wraps(split_func)\n    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:\n        for line in split_func(line, features):\n            normalize_prefix(line.leaves[0], inside_brackets=True)\n            yield line\n\n    return split_wrapper", "is_method": false, "function_description": "Decorator function that wraps a line-splitting function to normalize the indentation prefix of each first leaf in the resulting lines, ensuring consistent formatting without increasing indentation."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "delimiter_split", "line_number": 4886, "body": "def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:\n    \"\"\"Split according to delimiters of the highest priority.\n\n    If the appropriate Features are given, the split will add trailing commas\n    also in function signatures and calls that contain `*` and `**`.\n    \"\"\"\n    try:\n        last_leaf = line.leaves[-1]\n    except IndexError:\n        raise CannotSplit(\"Line empty\")\n\n    bt = line.bracket_tracker\n    try:\n        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})\n    except ValueError:\n        raise CannotSplit(\"No delimiters found\")\n\n    if delimiter_priority == DOT_PRIORITY:\n        if bt.delimiter_count_with_priority(delimiter_priority) == 1:\n            raise CannotSplit(\"Splitting a single attribute from its owner looks wrong\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    lowest_depth = sys.maxsize\n    trailing_comma_safe = True\n\n    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)\n\n    for leaf in line.leaves:\n        yield from append_to_line(leaf)\n\n        for comment_after in line.comments_after(leaf):\n            yield from append_to_line(comment_after)\n\n        lowest_depth = min(lowest_depth, leaf.bracket_depth)\n        if leaf.bracket_depth == lowest_depth:\n            if is_vararg(leaf, within={syms.typedargslist}):\n                trailing_comma_safe = (\n                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features\n                )\n            elif is_vararg(leaf, within={syms.arglist, syms.argument}):\n                trailing_comma_safe = (\n                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features\n                )\n\n        leaf_priority = bt.delimiters.get(id(leaf))\n        if leaf_priority == delimiter_priority:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    if current_line:\n        if (\n            trailing_comma_safe\n            and delimiter_priority == COMMA_PRIORITY\n            and current_line.leaves[-1].type != token.COMMA\n            and current_line.leaves[-1].type != STANDALONE_COMMENT\n        ):\n            new_comma = Leaf(token.COMMA, \",\")\n            current_line.append(new_comma)\n        yield current_line", "is_method": false, "function_description": "Splits a given code line into multiple lines at the highest-priority delimiters, optionally adding trailing commas in function signatures or calls. This supports code formatting and readability by segmenting complex expressions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "standalone_comment_split", "line_number": 4957, "body": "def standalone_comment_split(\n    line: Line, features: Collection[Feature] = ()\n) -> Iterator[Line]:\n    \"\"\"Split standalone comments from the rest of the line.\"\"\"\n    if not line.contains_standalone_comments(0):\n        raise CannotSplit(\"Line does not have any standalone comments\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n\n    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)\n\n    for leaf in line.leaves:\n        yield from append_to_line(leaf)\n\n        for comment_after in line.comments_after(leaf):\n            yield from append_to_line(comment_after)\n\n    if current_line:\n        yield current_line", "is_method": false, "function_description": "Splits lines containing standalone comments into separate Line objects, isolating comments from code for better parsing or formatting. Useful in code analysis or transformation tasks needing clear separation of comments from code."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_import", "line_number": 4987, "body": "def is_import(leaf: Leaf) -> bool:\n    \"\"\"Return True if the given leaf starts an import statement.\"\"\"\n    p = leaf.parent\n    t = leaf.type\n    v = leaf.value\n    return bool(\n        t == token.NAME\n        and (\n            (v == \"import\" and p and p.type == syms.import_name)\n            or (v == \"from\" and p and p.type == syms.import_from)\n        )\n    )", "is_method": false, "function_description": "Utility function that determines whether a given syntax leaf node represents the start of a Python import statement, aiding static analysis or code parsing tools in identifying import declarations."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_type_comment", "line_number": 5001, "body": "def is_type_comment(leaf: Leaf, suffix: str = \"\") -> bool:\n    \"\"\"Return True if the given leaf is a special comment.\n    Only returns true for type comments for now.\"\"\"\n    t = leaf.type\n    v = leaf.value\n    return t in {token.COMMENT, STANDALONE_COMMENT} and v.startswith(\"# type:\" + suffix)", "is_method": false, "function_description": "Utility function that checks whether a syntax leaf node is a type comment, optionally matching a specific suffix, to identify special type annotation comments in code parsing or analysis workflows."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "normalize_prefix", "line_number": 5009, "body": "def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:\n    \"\"\"Leave existing extra newlines if not `inside_brackets`. Remove everything\n    else.\n\n    Note: don't use backslashes for formatting or you'll lose your voting rights.\n    \"\"\"\n    if not inside_brackets:\n        spl = leaf.prefix.split(\"#\")\n        if \"\\\\\" not in spl[0]:\n            nl_count = spl[-1].count(\"\\n\")\n            if len(spl) > 1:\n                nl_count -= 1\n            leaf.prefix = \"\\n\" * nl_count\n            return\n\n    leaf.prefix = \"\"", "is_method": false, "function_description": "This function cleans or adjusts the prefix of a Leaf object by selectively preserving or removing newlines based on whether the prefix is inside brackets. It supports consistent formatting by normalizing whitespace before the leaf content."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "normalize_string_prefix", "line_number": 5027, "body": "def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:\n    \"\"\"Make all string prefixes lowercase.\n\n    If remove_u_prefix is given, also removes any u prefix from the string.\n\n    Note: Mutates its argument.\n    \"\"\"\n    match = re.match(r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", leaf.value, re.DOTALL)\n    assert match is not None, f\"failed to match string {leaf.value!r}\"\n    orig_prefix = match.group(1)\n    new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n    if remove_u_prefix:\n        new_prefix = new_prefix.replace(\"u\", \"\")\n    leaf.value = f\"{new_prefix}{match.group(2)}\"", "is_method": false, "function_description": "Utility function that normalizes string literal prefixes to lowercase in a Leaf object and optionally removes the 'u' prefix, ensuring consistent string prefix formatting by mutating the input in place."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "normalize_string_quotes", "line_number": 5043, "body": "def normalize_string_quotes(leaf: Leaf) -> None:\n    \"\"\"Prefer double quotes but only if it doesn't cause more escaping.\n\n    Adds or removes backslashes as appropriate. Doesn't parse and fix\n    strings nested in f-strings (yet).\n\n    Note: Mutates its argument.\n    \"\"\"\n    value = leaf.value.lstrip(STRING_PREFIX_CHARS)\n    if value[:3] == '\"\"\"':\n        return\n\n    elif value[:3] == \"'''\":\n        orig_quote = \"'''\"\n        new_quote = '\"\"\"'\n    elif value[0] == '\"':\n        orig_quote = '\"'\n        new_quote = \"'\"\n    else:\n        orig_quote = \"'\"\n        new_quote = '\"'\n    first_quote_pos = leaf.value.find(orig_quote)\n    if first_quote_pos == -1:\n        return  # There's an internal error\n\n    prefix = leaf.value[:first_quote_pos]\n    unescaped_new_quote = re.compile(rf\"(([^\\\\]|^)(\\\\\\\\)*){new_quote}\")\n    escaped_new_quote = re.compile(rf\"([^\\\\]|^)\\\\((?:\\\\\\\\)*){new_quote}\")\n    escaped_orig_quote = re.compile(rf\"([^\\\\]|^)\\\\((?:\\\\\\\\)*){orig_quote}\")\n    body = leaf.value[first_quote_pos + len(orig_quote) : -len(orig_quote)]\n    if \"r\" in prefix.casefold():\n        if unescaped_new_quote.search(body):\n            # There's at least one unescaped new_quote in this raw string\n            # so converting is impossible\n            return\n\n        # Do not introduce or remove backslashes in raw strings\n        new_body = body\n    else:\n        # remove unnecessary escapes\n        new_body = sub_twice(escaped_new_quote, rf\"\\1\\2{new_quote}\", body)\n        if body != new_body:\n            # Consider the string without unnecessary escapes as the original\n            body = new_body\n            leaf.value = f\"{prefix}{orig_quote}{body}{orig_quote}\"\n        new_body = sub_twice(escaped_orig_quote, rf\"\\1\\2{orig_quote}\", new_body)\n        new_body = sub_twice(unescaped_new_quote, rf\"\\1\\\\{new_quote}\", new_body)\n    if \"f\" in prefix.casefold():\n        matches = re.findall(\n            r\"\"\"\n            (?:[^{]|^)\\{  # start of the string or a non-{ followed by a single {\n                ([^{].*?)  # contents of the brackets except if begins with {{\n            \\}(?:[^}]|$)  # A } followed by end of the string or a non-}\n            \"\"\",\n            new_body,\n            re.VERBOSE,\n        )\n        for m in matches:\n            if \"\\\\\" in str(m):\n                # Do not introduce backslashes in interpolated expressions\n                return\n\n    if new_quote == '\"\"\"' and new_body[-1:] == '\"':\n        # edge case:\n        new_body = new_body[:-1] + '\\\\\"'\n    orig_escape_count = body.count(\"\\\\\")\n    new_escape_count = new_body.count(\"\\\\\")\n    if new_escape_count > orig_escape_count:\n        return  # Do not introduce more escaping\n\n    if new_escape_count == orig_escape_count and orig_quote == '\"':\n        return  # Prefer double quotes\n\n    leaf.value = f\"{prefix}{new_quote}{new_body}{new_quote}\"", "is_method": false, "function_description": "Utility function that normalizes string quotes in a Leaf object's value, preferring double quotes without increasing escape characters, to standardize string formatting while preserving raw and f-string semantics."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "normalize_numeric_literal", "line_number": 5119, "body": "def normalize_numeric_literal(leaf: Leaf) -> None:\n    \"\"\"Normalizes numeric (float, int, and complex) literals.\n\n    All letters used in the representation are normalized to lowercase (except\n    in Python 2 long literals).\n    \"\"\"\n    text = leaf.value.lower()\n    if text.startswith((\"0o\", \"0b\")):\n        # Leave octal and binary literals alone.\n        pass\n    elif text.startswith(\"0x\"):\n        # Change hex literals to upper case.\n        before, after = text[:2], text[2:]\n        text = f\"{before}{after.upper()}\"\n    elif \"e\" in text:\n        before, after = text.split(\"e\")\n        sign = \"\"\n        if after.startswith(\"-\"):\n            after = after[1:]\n            sign = \"-\"\n        elif after.startswith(\"+\"):\n            after = after[1:]\n        before = format_float_or_int_string(before)\n        text = f\"{before}e{sign}{after}\"\n    elif text.endswith((\"j\", \"l\")):\n        number = text[:-1]\n        suffix = text[-1]\n        # Capitalize in \"2L\" because \"l\" looks too similar to \"1\".\n        if suffix == \"l\":\n            suffix = \"L\"\n        text = f\"{format_float_or_int_string(number)}{suffix}\"\n    else:\n        text = format_float_or_int_string(text)\n    leaf.value = text", "is_method": false, "function_description": "Normalizes numeric literals in code by adjusting letter casing and formatting for consistency, ensuring standardized representation of integers, floats, complex numbers, and certain suffixes in syntax trees. This facilitates uniform code processing or analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "format_float_or_int_string", "line_number": 5155, "body": "def format_float_or_int_string(text: str) -> str:\n    \"\"\"Formats a float string like \"1.0\".\"\"\"\n    if \".\" not in text:\n        return text\n\n    before, after = text.split(\".\")\n    return f\"{before or 0}.{after or 0}\"", "is_method": false, "function_description": "Function formats numeric strings containing decimals to ensure both integer and fractional parts are always present, standardizing float representations for consistent numeric string processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "normalize_invisible_parens", "line_number": 5164, "body": "def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:\n    \"\"\"Make existing optional parentheses invisible or create new ones.\n\n    `parens_after` is a set of string leaf values immediately after which parens\n    should be put.\n\n    Standardizes on visible parentheses for single-element tuples, and keeps\n    existing visible parentheses for other tuples and generator expressions.\n    \"\"\"\n    for pc in list_comments(node.prefix, is_endmarker=False):\n        if pc.value in FMT_OFF:\n            # This `node` has a prefix with `# fmt: off`, don't mess with parens.\n            return\n    check_lpar = False\n    for index, child in enumerate(list(node.children)):\n        # Fixes a bug where invisible parens are not properly stripped from\n        # assignment statements that contain type annotations.\n        if isinstance(child, Node) and child.type == syms.annassign:\n            normalize_invisible_parens(child, parens_after=parens_after)\n\n        # Add parentheses around long tuple unpacking in assignments.\n        if (\n            index == 0\n            and isinstance(child, Node)\n            and child.type == syms.testlist_star_expr\n        ):\n            check_lpar = True\n\n        if check_lpar:\n            if is_walrus_assignment(child):\n                continue\n\n            if child.type == syms.atom:\n                if maybe_make_parens_invisible_in_atom(child, parent=node):\n                    wrap_in_parentheses(node, child, visible=False)\n            elif is_one_tuple(child):\n                wrap_in_parentheses(node, child, visible=True)\n            elif node.type == syms.import_from:\n                # \"import from\" nodes store parentheses directly as part of\n                # the statement\n                if child.type == token.LPAR:\n                    # make parentheses invisible\n                    child.value = \"\"  # type: ignore\n                    node.children[-1].value = \"\"  # type: ignore\n                elif child.type != token.STAR:\n                    # insert invisible parentheses\n                    node.insert_child(index, Leaf(token.LPAR, \"\"))\n                    node.append_child(Leaf(token.RPAR, \"\"))\n                break\n\n            elif not (isinstance(child, Leaf) and is_multiline_string(child)):\n                wrap_in_parentheses(node, child, visible=False)\n\n        check_lpar = isinstance(child, Leaf) and child.value in parens_after", "is_method": false, "function_description": "Utility function that standardizes visible and invisible parentheses in syntax tree nodes for tuples, generator expressions, and import statements, ensuring consistent formatting around specified tokens. It also respects format-off comments to avoid unwanted changes."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "normalize_fmt_off", "line_number": 5220, "body": "def normalize_fmt_off(node: Node) -> None:\n    \"\"\"Convert content between `# fmt: off`/`# fmt: on` into standalone comments.\"\"\"\n    try_again = True\n    while try_again:\n        try_again = convert_one_fmt_off_pair(node)", "is_method": false, "function_description": "Function that transforms code regions marked with `# fmt: off`/`# fmt: on` into isolated comment blocks, ensuring consistent formatting control within the code."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "convert_one_fmt_off_pair", "line_number": 5227, "body": "def convert_one_fmt_off_pair(node: Node) -> bool:\n    \"\"\"Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.\n\n    Returns True if a pair was converted.\n    \"\"\"\n    for leaf in node.leaves():\n        previous_consumed = 0\n        for comment in list_comments(leaf.prefix, is_endmarker=False):\n            if comment.value in FMT_OFF:\n                # We only want standalone comments. If there's no previous leaf or\n                # the previous leaf is indentation, it's a standalone comment in\n                # disguise.\n                if comment.type != STANDALONE_COMMENT:\n                    prev = preceding_leaf(leaf)\n                    if prev and prev.type not in WHITESPACE:\n                        continue\n\n                ignored_nodes = list(generate_ignored_nodes(leaf))\n                if not ignored_nodes:\n                    continue\n\n                first = ignored_nodes[0]  # Can be a container node with the `leaf`.\n                parent = first.parent\n                prefix = first.prefix\n                first.prefix = prefix[comment.consumed :]\n                hidden_value = (\n                    comment.value + \"\\n\" + \"\".join(str(n) for n in ignored_nodes)\n                )\n                if hidden_value.endswith(\"\\n\"):\n                    # That happens when one of the `ignored_nodes` ended with a NEWLINE\n                    # leaf (possibly followed by a DEDENT).\n                    hidden_value = hidden_value[:-1]\n                first_idx: Optional[int] = None\n                for ignored in ignored_nodes:\n                    index = ignored.remove()\n                    if first_idx is None:\n                        first_idx = index\n                assert parent is not None, \"INTERNAL ERROR: fmt: on/off handling (1)\"\n                assert first_idx is not None, \"INTERNAL ERROR: fmt: on/off handling (2)\"\n                parent.insert_child(\n                    first_idx,\n                    Leaf(\n                        STANDALONE_COMMENT,\n                        hidden_value,\n                        prefix=prefix[:previous_consumed] + \"\\n\" * comment.newlines,\n                    ),\n                )\n                return True\n\n            previous_consumed = comment.consumed\n\n    return False", "is_method": false, "function_description": "Function that detects and converts a pair of `# fmt: off`/`# fmt: on` comments in code into a single standalone comment, facilitating clearer formatting control in code parsing or formatting tools. It returns True if such a conversion occurs."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "generate_ignored_nodes", "line_number": 5281, "body": "def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:\n    \"\"\"Starting from the container of `leaf`, generate all leaves until `# fmt: on`.\n\n    Stops at the end of the block.\n    \"\"\"\n    container: Optional[LN] = container_of(leaf)\n    while container is not None and container.type != token.ENDMARKER:\n        if is_fmt_on(container):\n            return\n\n        # fix for fmt: on in children\n        if contains_fmt_on_at_column(container, leaf.column):\n            for child in container.children:\n                if contains_fmt_on_at_column(child, leaf.column):\n                    return\n                yield child\n        else:\n            yield container\n            container = container.next_sibling", "is_method": false, "function_description": "Generates all leaf nodes from the given leaf's container up to the next `# fmt: on` directive, supporting selective code block processing by identifying ignored nodes until formatting is re-enabled."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_fmt_on", "line_number": 5302, "body": "def is_fmt_on(container: LN) -> bool:\n    \"\"\"Determine whether formatting is switched on within a container.\n    Determined by whether the last `# fmt:` comment is `on` or `off`.\n    \"\"\"\n    fmt_on = False\n    for comment in list_comments(container.prefix, is_endmarker=False):\n        if comment.value in FMT_ON:\n            fmt_on = True\n        elif comment.value in FMT_OFF:\n            fmt_on = False\n    return fmt_on", "is_method": false, "function_description": "Utility function that determines if formatting is enabled within a container by checking the last relevant formatting directive comment inside it. It helps decide whether code formatting should be applied or skipped in a given code segment."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "contains_fmt_on_at_column", "line_number": 5315, "body": "def contains_fmt_on_at_column(container: LN, column: int) -> bool:\n    \"\"\"Determine if children at a given column have formatting switched on.\"\"\"\n    for child in container.children:\n        if (\n            isinstance(child, Node)\n            and first_leaf_column(child) == column\n            or isinstance(child, Leaf)\n            and child.column == column\n        ):\n            if is_fmt_on(child):\n                return True\n\n    return False", "is_method": false, "function_description": "This function checks whether any child elements in a container have formatting enabled at a specific column position. It helps determine the presence of formatting within structured text or layout elements at a given column."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "first_leaf_column", "line_number": 5330, "body": "def first_leaf_column(node: Node) -> Optional[int]:\n    \"\"\"Returns the column of the first leaf child of a node.\"\"\"\n    for child in node.children:\n        if isinstance(child, Leaf):\n            return child.column\n    return None", "is_method": false, "function_description": "Returns the column index of the first leaf child of a given node, facilitating access to specific leaf node positions within a tree structure."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "maybe_make_parens_invisible_in_atom", "line_number": 5338, "body": "def maybe_make_parens_invisible_in_atom(node: LN, parent: LN) -> bool:\n    \"\"\"If it's safe, make the parens in the atom `node` invisible, recursively.\n    Additionally, remove repeated, adjacent invisible parens from the atom `node`\n    as they are redundant.\n\n    Returns whether the node should itself be wrapped in invisible parentheses.\n\n    \"\"\"\n    if (\n        node.type != syms.atom\n        or is_empty_tuple(node)\n        or is_one_tuple(node)\n        or (is_yield(node) and parent.type != syms.expr_stmt)\n        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY\n    ):\n        return False\n\n    first = node.children[0]\n    last = node.children[-1]\n    if first.type == token.LPAR and last.type == token.RPAR:\n        middle = node.children[1]\n        # make parentheses invisible\n        first.value = \"\"  # type: ignore\n        last.value = \"\"  # type: ignore\n        maybe_make_parens_invisible_in_atom(middle, parent=parent)\n\n        if is_atom_with_invisible_parens(middle):\n            # Strip the invisible parens from `middle` by replacing\n            # it with the child in-between the invisible parens\n            middle.replace(middle.children[1])\n\n        return False\n\n    return True", "is_method": false, "function_description": "Function that recursively removes visible parentheses from an atom node when safe, eliminates redundant invisible parentheses, and indicates if the atom itself should be wrapped in invisible parentheses. Useful for simplifying and normalizing parsed syntax trees."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_atom_with_invisible_parens", "line_number": 5374, "body": "def is_atom_with_invisible_parens(node: LN) -> bool:\n    \"\"\"Given a `LN`, determines whether it's an atom `node` with invisible\n    parens. Useful in dedupe-ing and normalizing parens.\n    \"\"\"\n    if isinstance(node, Leaf) or node.type != syms.atom:\n        return False\n\n    first, last = node.children[0], node.children[-1]\n    return (\n        isinstance(first, Leaf)\n        and first.type == token.LPAR\n        and first.value == \"\"\n        and isinstance(last, Leaf)\n        and last.type == token.RPAR\n        and last.value == \"\"\n    )", "is_method": false, "function_description": "Determines if a syntax tree node represents an atomic expression enclosed by invisible parentheses, facilitating parentheses normalization and deduplication in parsing operations."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_empty_tuple", "line_number": 5392, "body": "def is_empty_tuple(node: LN) -> bool:\n    \"\"\"Return True if `node` holds an empty tuple.\"\"\"\n    return (\n        node.type == syms.atom\n        and len(node.children) == 2\n        and node.children[0].type == token.LPAR\n        and node.children[1].type == token.RPAR\n    )", "is_method": false, "function_description": "Function that checks whether a given syntax node represents an empty tuple. It helps identify empty tuple literals in a parsed syntax tree for further processing or analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "unwrap_singleton_parenthesis", "line_number": 5402, "body": "def unwrap_singleton_parenthesis(node: LN) -> Optional[LN]:\n    \"\"\"Returns `wrapped` if `node` is of the shape ( wrapped ).\n\n    Parenthesis can be optional. Returns None otherwise\"\"\"\n    if len(node.children) != 3:\n        return None\n\n    lpar, wrapped, rpar = node.children\n    if not (lpar.type == token.LPAR and rpar.type == token.RPAR):\n        return None\n\n    return wrapped", "is_method": false, "function_description": "Function that detects and extracts the inner node wrapped by a single pair of parentheses from a given node, returning it if the node is exactly a parenthesized expression, otherwise None."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "wrap_in_parentheses", "line_number": 5416, "body": "def wrap_in_parentheses(parent: Node, child: LN, *, visible: bool = True) -> None:\n    \"\"\"Wrap `child` in parentheses.\n\n    This replaces `child` with an atom holding the parentheses and the old\n    child.  That requires moving the prefix.\n\n    If `visible` is False, the leaves will be valueless (and thus invisible).\n    \"\"\"\n    lpar = Leaf(token.LPAR, \"(\" if visible else \"\")\n    rpar = Leaf(token.RPAR, \")\" if visible else \"\")\n    prefix = child.prefix\n    child.prefix = \"\"\n    index = child.remove() or 0\n    new_child = Node(syms.atom, [lpar, child, rpar])\n    new_child.prefix = prefix\n    parent.insert_child(index, new_child)", "is_method": false, "function_description": "Utility function that wraps a given syntax tree child node in parentheses, optionally rendering them visible or invisible, which can be used to adjust syntactic grouping within a parent node."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_one_tuple", "line_number": 5434, "body": "def is_one_tuple(node: LN) -> bool:\n    \"\"\"Return True if `node` holds a tuple with one element, with or without parens.\"\"\"\n    if node.type == syms.atom:\n        gexp = unwrap_singleton_parenthesis(node)\n        if gexp is None or gexp.type != syms.testlist_gexp:\n            return False\n\n        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA\n\n    return (\n        node.type in IMPLICIT_TUPLE\n        and len(node.children) == 2\n        and node.children[1].type == token.COMMA\n    )", "is_method": false, "function_description": "Checks whether a syntax node represents a single-element tuple, accounting for optional parentheses. This is useful for parsing or analyzing Python code structures involving one-item tuples."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_walrus_assignment", "line_number": 5450, "body": "def is_walrus_assignment(node: LN) -> bool:\n    \"\"\"Return True iff `node` is of the shape ( test := test )\"\"\"\n    inner = unwrap_singleton_parenthesis(node)\n    return inner is not None and inner.type == syms.namedexpr_test", "is_method": false, "function_description": "Function that checks if a syntax tree node represents a walrus operator assignment (:=) expression, enabling detection of inline assignments in Python code analysis or transformation tools."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_yield", "line_number": 5456, "body": "def is_yield(node: LN) -> bool:\n    \"\"\"Return True if `node` holds a `yield` or `yield from` expression.\"\"\"\n    if node.type == syms.yield_expr:\n        return True\n\n    if node.type == token.NAME and node.value == \"yield\":  # type: ignore\n        return True\n\n    if node.type != syms.atom:\n        return False\n\n    if len(node.children) != 3:\n        return False\n\n    lpar, expr, rpar = node.children\n    if lpar.type == token.LPAR and rpar.type == token.RPAR:\n        return is_yield(expr)\n\n    return False", "is_method": false, "function_description": "Determines whether a given syntax node represents a Python `yield` or `yield from` expression, aiding in parsing or analyzing generator functions within the code."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_vararg", "line_number": 5477, "body": "def is_vararg(leaf: Leaf, within: Set[NodeType]) -> bool:\n    \"\"\"Return True if `leaf` is a star or double star in a vararg or kwarg.\n\n    If `within` includes VARARGS_PARENTS, this applies to function signatures.\n    If `within` includes UNPACKING_PARENTS, it applies to right hand-side\n    extended iterable unpacking (PEP 3132) and additional unpacking\n    generalizations (PEP 448).\n    \"\"\"\n    if leaf.type not in VARARGS_SPECIALS or not leaf.parent:\n        return False\n\n    p = leaf.parent\n    if p.type == syms.star_expr:\n        # Star expressions are also used as assignment targets in extended\n        # iterable unpacking (PEP 3132).  See what its parent is instead.\n        if not p.parent:\n            return False\n\n        p = p.parent\n\n    return p.type in within", "is_method": false, "function_description": "Utility function that determines if a syntax leaf node represents a star or double-star argument (vararg/kwarg) within specified parent contexts, supporting detection in function signatures or iterable unpacking scenarios."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_multiline_string", "line_number": 5500, "body": "def is_multiline_string(leaf: Leaf) -> bool:\n    \"\"\"Return True if `leaf` is a multiline string that actually spans many lines.\"\"\"\n    return has_triple_quotes(leaf.value) and \"\\n\" in leaf.value", "is_method": false, "function_description": "Utility function that determines if a string leaf contains a multiline string by checking for triple quotes and newline characters, useful for parsing or analyzing multiline string literals in code."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_stub_suite", "line_number": 5505, "body": "def is_stub_suite(node: Node) -> bool:\n    \"\"\"Return True if `node` is a suite with a stub body.\"\"\"\n    if (\n        len(node.children) != 4\n        or node.children[0].type != token.NEWLINE\n        or node.children[1].type != token.INDENT\n        or node.children[3].type != token.DEDENT\n    ):\n        return False\n\n    return is_stub_body(node.children[2])", "is_method": false, "function_description": "Utility function that determines whether a syntax tree node represents a code block (suite) containing only a stub body, useful for analyzing or processing incomplete or placeholder code segments."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_stub_body", "line_number": 5518, "body": "def is_stub_body(node: LN) -> bool:\n    \"\"\"Return True if `node` is a simple statement containing an ellipsis.\"\"\"\n    if not isinstance(node, Node) or node.type != syms.simple_stmt:\n        return False\n\n    if len(node.children) != 2:\n        return False\n\n    child = node.children[0]\n    return (\n        child.type == syms.atom\n        and len(child.children) == 3\n        and all(leaf == Leaf(token.DOT, \".\") for leaf in child.children)\n    )", "is_method": false, "function_description": "Utility function that checks if a syntax node represents a simple statement consisting solely of an ellipsis, often used to identify stub or placeholder code blocks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "max_delimiter_priority_in_atom", "line_number": 5534, "body": "def max_delimiter_priority_in_atom(node: LN) -> Priority:\n    \"\"\"Return maximum delimiter priority inside `node`.\n\n    This is specific to atoms with contents contained in a pair of parentheses.\n    If `node` isn't an atom or there are no enclosing parentheses, returns 0.\n    \"\"\"\n    if node.type != syms.atom:\n        return 0\n\n    first = node.children[0]\n    last = node.children[-1]\n    if not (first.type == token.LPAR and last.type == token.RPAR):\n        return 0\n\n    bt = BracketTracker()\n    for c in node.children[1:-1]:\n        if isinstance(c, Leaf):\n            bt.mark(c)\n        else:\n            for leaf in c.leaves():\n                bt.mark(leaf)\n    try:\n        return bt.max_delimiter_priority()\n\n    except ValueError:\n        return 0", "is_method": false, "function_description": "Utility function that returns the highest priority of delimiters within a parenthesized atom node, aiding in parsing or analyzing nested expressions with delimiter hierarchies."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "ensure_visible", "line_number": 5562, "body": "def ensure_visible(leaf: Leaf) -> None:\n    \"\"\"Make sure parentheses are visible.\n\n    They could be invisible as part of some statements (see\n    :func:`normalize_invisible_parens` and :func:`visit_import_from`).\n    \"\"\"\n    if leaf.type == token.LPAR:\n        leaf.value = \"(\"\n    elif leaf.type == token.RPAR:\n        leaf.value = \")\"", "is_method": false, "function_description": "Utility function that ensures parentheses tokens are explicitly visible by restoring their characters, supporting consistent code formatting or analysis where invisible parentheses might occur."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "should_split_body_explode", "line_number": 5574, "body": "def should_split_body_explode(line: Line, opening_bracket: Leaf) -> bool:\n    \"\"\"Should `line` be immediately split with `delimiter_split()` after RHS?\"\"\"\n\n    if not (opening_bracket.parent and opening_bracket.value in \"[{(\"):\n        return False\n\n    # We're essentially checking if the body is delimited by commas and there's more\n    # than one of them (we're excluding the trailing comma and if the delimiter priority\n    # is still commas, that means there's more).\n    exclude = set()\n    trailing_comma = False\n    try:\n        last_leaf = line.leaves[-1]\n        if last_leaf.type == token.COMMA:\n            trailing_comma = True\n            exclude.add(id(last_leaf))\n        max_priority = line.bracket_tracker.max_delimiter_priority(exclude=exclude)\n    except (IndexError, ValueError):\n        return False\n\n    return max_priority == COMMA_PRIORITY and (\n        trailing_comma\n        # always explode imports\n        or opening_bracket.parent.type in {syms.atom, syms.import_from}\n    )", "is_method": false, "function_description": "Determines whether a line containing bracketed content should be split at commas for clearer formatting. This aids in deciding if delimiter-based line splitting is appropriate, especially for imports or comma-delimited bodies."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_one_tuple_between", "line_number": 5601, "body": "def is_one_tuple_between(opening: Leaf, closing: Leaf, leaves: List[Leaf]) -> bool:\n    \"\"\"Return True if content between `opening` and `closing` looks like a one-tuple.\"\"\"\n    if opening.type != token.LPAR and closing.type != token.RPAR:\n        return False\n\n    depth = closing.bracket_depth + 1\n    for _opening_index, leaf in enumerate(leaves):\n        if leaf is opening:\n            break\n\n    else:\n        raise LookupError(\"Opening paren not found in `leaves`\")\n\n    commas = 0\n    _opening_index += 1\n    for leaf in leaves[_opening_index:]:\n        if leaf is closing:\n            break\n\n        bracket_depth = leaf.bracket_depth\n        if bracket_depth == depth and leaf.type == token.COMMA:\n            commas += 1\n            if leaf.parent and leaf.parent.type in {\n                syms.arglist,\n                syms.typedargslist,\n            }:\n                commas += 1\n                break\n\n    return commas < 2", "is_method": false, "function_description": "Function that determines whether the content enclosed by given opening and closing parentheses represents a one-element tuple, useful for parsing and analyzing Python syntax structures."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "get_features_used", "line_number": 5633, "body": "def get_features_used(node: Node) -> Set[Feature]:\n    \"\"\"Return a set of (relatively) new Python features used in this file.\n\n    Currently looking for:\n    - f-strings;\n    - underscores in numeric literals;\n    - trailing commas after * or ** in function signatures and calls;\n    - positional only arguments in function signatures and lambdas;\n    \"\"\"\n    features: Set[Feature] = set()\n    for n in node.pre_order():\n        if n.type == token.STRING:\n            value_head = n.value[:2]  # type: ignore\n            if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                features.add(Feature.F_STRINGS)\n\n        elif n.type == token.NUMBER:\n            if \"_\" in n.value:  # type: ignore\n                features.add(Feature.NUMERIC_UNDERSCORES)\n\n        elif n.type == token.SLASH:\n            if n.parent and n.parent.type in {syms.typedargslist, syms.arglist}:\n                features.add(Feature.POS_ONLY_ARGUMENTS)\n\n        elif n.type == token.COLONEQUAL:\n            features.add(Feature.ASSIGNMENT_EXPRESSIONS)\n\n        elif (\n            n.type in {syms.typedargslist, syms.arglist}\n            and n.children\n            and n.children[-1].type == token.COMMA\n        ):\n            if n.type == syms.typedargslist:\n                feature = Feature.TRAILING_COMMA_IN_DEF\n            else:\n                feature = Feature.TRAILING_COMMA_IN_CALL\n\n            for ch in n.children:\n                if ch.type in STARS:\n                    features.add(feature)\n\n                if ch.type == syms.argument:\n                    for argch in ch.children:\n                        if argch.type in STARS:\n                            features.add(feature)\n\n    return features", "is_method": false, "function_description": "Utility function that analyzes a syntax tree node to identify modern Python language features used in the code, facilitating feature detection for code analysis or compatibility checks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "detect_target_versions", "line_number": 5682, "body": "def detect_target_versions(node: Node) -> Set[TargetVersion]:\n    \"\"\"Detect the version to target based on the nodes used.\"\"\"\n    features = get_features_used(node)\n    return {\n        version for version in TargetVersion if features <= VERSION_TO_FEATURES[version]\n    }", "is_method": false, "function_description": "Function that determines compatible target versions based on the features used in a given node, aiding in version-specific processing or compatibility checks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "generate_trailers_to_omit", "line_number": 5690, "body": "def generate_trailers_to_omit(line: Line, line_length: int) -> Iterator[Set[LeafID]]:\n    \"\"\"Generate sets of closing bracket IDs that should be omitted in a RHS.\n\n    Brackets can be omitted if the entire trailer up to and including\n    a preceding closing bracket fits in one line.\n\n    Yielded sets are cumulative (contain results of previous yields, too).  First\n    set is empty, unless the line should explode, in which case bracket pairs until\n    the one that needs to explode are omitted.\n    \"\"\"\n\n    omit: Set[LeafID] = set()\n    if not line.should_explode:\n        yield omit\n\n    length = 4 * line.depth\n    opening_bracket: Optional[Leaf] = None\n    closing_bracket: Optional[Leaf] = None\n    inner_brackets: Set[LeafID] = set()\n    for index, leaf, leaf_length in enumerate_with_length(line, reversed=True):\n        length += leaf_length\n        if length > line_length:\n            break\n\n        has_inline_comment = leaf_length > len(leaf.value) + len(leaf.prefix)\n        if leaf.type == STANDALONE_COMMENT or has_inline_comment:\n            break\n\n        if opening_bracket:\n            if leaf is opening_bracket:\n                opening_bracket = None\n            elif leaf.type in CLOSING_BRACKETS:\n                prev = line.leaves[index - 1] if index > 0 else None\n                if (\n                    line.should_explode\n                    and prev\n                    and prev.type == token.COMMA\n                    and not is_one_tuple_between(\n                        leaf.opening_bracket, leaf, line.leaves\n                    )\n                ):\n                    # Never omit bracket pairs with trailing commas.\n                    # We need to explode on those.\n                    break\n\n                inner_brackets.add(id(leaf))\n        elif leaf.type in CLOSING_BRACKETS:\n            prev = line.leaves[index - 1] if index > 0 else None\n            if prev and prev.type in OPENING_BRACKETS:\n                # Empty brackets would fail a split so treat them as \"inner\"\n                # brackets (e.g. only add them to the `omit` set if another\n                # pair of brackets was good enough.\n                inner_brackets.add(id(leaf))\n                continue\n\n            if closing_bracket:\n                omit.add(id(closing_bracket))\n                omit.update(inner_brackets)\n                inner_brackets.clear()\n                yield omit\n\n            if (\n                line.should_explode\n                and prev\n                and prev.type == token.COMMA\n                and not is_one_tuple_between(leaf.opening_bracket, leaf, line.leaves)\n            ):\n                # Never omit bracket pairs with trailing commas.\n                # We need to explode on those.\n                break\n\n            if leaf.value:\n                opening_bracket = leaf.opening_bracket\n                closing_bracket = leaf", "is_method": false, "function_description": "Utility function that yields cumulative sets of bracket IDs to omit when formatting a line's right-hand side, helping determine which closing brackets can be excluded to fit within a specified line length during code formatting."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "get_future_imports", "line_number": 5766, "body": "def get_future_imports(node: Node) -> Set[str]:\n    \"\"\"Return a set of __future__ imports in the file.\"\"\"\n    imports: Set[str] = set()\n\n    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:\n        for child in children:\n            if isinstance(child, Leaf):\n                if child.type == token.NAME:\n                    yield child.value\n\n            elif child.type == syms.import_as_name:\n                orig_name = child.children[0]\n                assert isinstance(orig_name, Leaf), \"Invalid syntax parsing imports\"\n                assert orig_name.type == token.NAME, \"Invalid syntax parsing imports\"\n                yield orig_name.value\n\n            elif child.type == syms.import_as_names:\n                yield from get_imports_from_children(child.children)\n\n            else:\n                raise AssertionError(\"Invalid syntax parsing imports\")\n\n    for child in node.children:\n        if child.type != syms.simple_stmt:\n            break\n\n        first_child = child.children[0]\n        if isinstance(first_child, Leaf):\n            # Continue looking if we see a docstring; otherwise stop.\n            if (\n                len(child.children) == 2\n                and first_child.type == token.STRING\n                and child.children[1].type == token.NEWLINE\n            ):\n                continue\n\n            break\n\n        elif first_child.type == syms.import_from:\n            module_name = first_child.children[1]\n            if not isinstance(module_name, Leaf) or module_name.value != \"__future__\":\n                break\n\n            imports |= set(get_imports_from_children(first_child.children[3:]))\n        else:\n            break\n\n    return imports", "is_method": false, "function_description": "This function analyzes a syntax tree node to identify and return all `__future__` imports present in a Python source file. It provides a utility to extract future feature statements, useful for tools processing or analyzing Python code compatibility."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "get_gitignore", "line_number": 5817, "body": "def get_gitignore(root: Path) -> PathSpec:\n    \"\"\" Return a PathSpec matching gitignore content if present.\"\"\"\n    gitignore = root / \".gitignore\"\n    lines: List[str] = []\n    if gitignore.is_file():\n        with gitignore.open() as gf:\n            lines = gf.readlines()\n    return PathSpec.from_lines(\"gitwildmatch\", lines)", "is_method": false, "function_description": "Function that loads and parses a .gitignore file from a given directory, returning a PathSpec object to match paths against the gitignore patterns for filtering or exclusion purposes."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "normalize_path_maybe_ignore", "line_number": 5827, "body": "def normalize_path_maybe_ignore(\n    path: Path, root: Path, report: \"Report\"\n) -> Optional[str]:\n    \"\"\"Normalize `path`. May return `None` if `path` was ignored.\n\n    `report` is where \"path ignored\" output goes.\n    \"\"\"\n    try:\n        normalized_path = path.resolve().relative_to(root).as_posix()\n    except OSError as e:\n        report.path_ignored(path, f\"cannot be read because {e}\")\n        return None\n\n    except ValueError:\n        if path.is_symlink():\n            report.path_ignored(path, f\"is a symbolic link that points outside {root}\")\n            return None\n\n        raise\n\n    return normalized_path", "is_method": false, "function_description": "Function that attempts to normalize a file path relative to a root directory, returning None and logging a report if the path is unreadable or a disallowed symlink. Useful for safely filtering and standardizing file paths within a controlled root."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "gen_python_files", "line_number": 5850, "body": "def gen_python_files(\n    paths: Iterable[Path],\n    root: Path,\n    include: Optional[Pattern[str]],\n    exclude: Pattern[str],\n    force_exclude: Optional[Pattern[str]],\n    report: \"Report\",\n    gitignore: PathSpec,\n) -> Iterator[Path]:\n    \"\"\"Generate all files under `path` whose paths are not excluded by the\n    `exclude_regex` or `force_exclude` regexes, but are included by the `include` regex.\n\n    Symbolic links pointing outside of the `root` directory are ignored.\n\n    `report` is where output about exclusions goes.\n    \"\"\"\n    assert root.is_absolute(), f\"INTERNAL ERROR: `root` must be absolute but is {root}\"\n    for child in paths:\n        normalized_path = normalize_path_maybe_ignore(child, root, report)\n        if normalized_path is None:\n            continue\n\n        # First ignore files matching .gitignore\n        if gitignore.match_file(normalized_path):\n            report.path_ignored(child, \"matches the .gitignore file content\")\n            continue\n\n        # Then ignore with `--exclude` and `--force-exclude` options.\n        normalized_path = \"/\" + normalized_path\n        if child.is_dir():\n            normalized_path += \"/\"\n\n        exclude_match = exclude.search(normalized_path) if exclude else None\n        if exclude_match and exclude_match.group(0):\n            report.path_ignored(child, \"matches the --exclude regular expression\")\n            continue\n\n        force_exclude_match = (\n            force_exclude.search(normalized_path) if force_exclude else None\n        )\n        if force_exclude_match and force_exclude_match.group(0):\n            report.path_ignored(child, \"matches the --force-exclude regular expression\")\n            continue\n\n        if child.is_dir():\n            yield from gen_python_files(\n                child.iterdir(),\n                root,\n                include,\n                exclude,\n                force_exclude,\n                report,\n                gitignore,\n            )\n\n        elif child.is_file():\n            include_match = include.search(normalized_path) if include else True\n            if include_match:\n                yield child", "is_method": false, "function_description": "Function that recursively yields Python files from given paths, filtering them by inclusion and exclusion patterns, `.gitignore` rules, and symbolic link constraints, while reporting excluded paths. It serves to produce a cleaned file list for analysis or processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "find_project_root", "line_number": 5912, "body": "def find_project_root(srcs: Iterable[str]) -> Path:\n    \"\"\"Return a directory containing .git, .hg, or pyproject.toml.\n\n    That directory will be a common parent of all files and directories\n    passed in `srcs`.\n\n    If no directory in the tree contains a marker that would specify it's the\n    project root, the root of the file system is returned.\n    \"\"\"\n    if not srcs:\n        return Path(\"/\").resolve()\n\n    path_srcs = [Path(Path.cwd(), src).resolve() for src in srcs]\n\n    # A list of lists of parents for each 'src'. 'src' is included as a\n    # \"parent\" of itself if it is a directory\n    src_parents = [\n        list(path.parents) + ([path] if path.is_dir() else []) for path in path_srcs\n    ]\n\n    common_base = max(\n        set.intersection(*(set(parents) for parents in src_parents)),\n        key=lambda path: path.parts,\n    )\n\n    for directory in (common_base, *common_base.parents):\n        if (directory / \".git\").exists():\n            return directory\n\n        if (directory / \".hg\").is_dir():\n            return directory\n\n        if (directory / \"pyproject.toml\").is_file():\n            return directory\n\n    return directory", "is_method": false, "function_description": "Function that identifies the common ancestor directory of given paths containing version control or project configuration markers, helping locate the root directory of a project for source files."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "parse_ast", "line_number": 6036, "body": "def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n    filename = \"<unknown>\"\n    if sys.version_info >= (3, 8):\n        # TODO: support Python 4+ ;)\n        for minor_version in range(sys.version_info[1], 4, -1):\n            try:\n                return ast.parse(src, filename, feature_version=(3, minor_version))\n            except SyntaxError:\n                continue\n    else:\n        for feature_version in (7, 6):\n            try:\n                return ast3.parse(src, filename, feature_version=feature_version)\n            except SyntaxError:\n                continue\n\n    return ast27.parse(src)", "is_method": false, "function_description": "Function that parses source code into an abstract syntax tree (AST) compatible with multiple Python versions, providing a unified interface for code analysis across different Python syntax standards."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_fixup_ast_constants", "line_number": 6055, "body": "def _fixup_ast_constants(\n    node: Union[ast.AST, ast3.AST, ast27.AST]\n) -> Union[ast.AST, ast3.AST, ast27.AST]:\n    \"\"\"Map ast nodes deprecated in 3.8 to Constant.\"\"\"\n    if isinstance(node, (ast.Str, ast3.Str, ast27.Str, ast.Bytes, ast3.Bytes)):\n        return ast.Constant(value=node.s)\n\n    if isinstance(node, (ast.Num, ast3.Num, ast27.Num)):\n        return ast.Constant(value=node.n)\n\n    if isinstance(node, (ast.NameConstant, ast3.NameConstant)):\n        return ast.Constant(value=node.value)\n\n    return node", "is_method": false, "function_description": "Internal utility function that normalizes various deprecated AST constant node types to a unified Constant node, ensuring compatibility across different Python AST versions during code analysis or transformation."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_stringify_ast", "line_number": 6071, "body": "def _stringify_ast(\n    node: Union[ast.AST, ast3.AST, ast27.AST], depth: int = 0\n) -> Iterator[str]:\n    \"\"\"Simple visitor generating strings to compare ASTs by content.\"\"\"\n\n    node = _fixup_ast_constants(node)\n\n    yield f\"{'  ' * depth}{node.__class__.__name__}(\"\n\n    for field in sorted(node._fields):  # noqa: F402\n        # TypeIgnore has only one field 'lineno' which breaks this comparison\n        type_ignore_classes = (ast3.TypeIgnore, ast27.TypeIgnore)\n        if sys.version_info >= (3, 8):\n            type_ignore_classes += (ast.TypeIgnore,)\n        if isinstance(node, type_ignore_classes):\n            break\n\n        try:\n            value = getattr(node, field)\n        except AttributeError:\n            continue\n\n        yield f\"{'  ' * (depth+1)}{field}=\"\n\n        if isinstance(value, list):\n            for item in value:\n                # Ignore nested tuples within del statements, because we may insert\n                # parentheses and they change the AST.\n                if (\n                    field == \"targets\"\n                    and isinstance(node, (ast.Delete, ast3.Delete, ast27.Delete))\n                    and isinstance(item, (ast.Tuple, ast3.Tuple, ast27.Tuple))\n                ):\n                    for item in item.elts:\n                        yield from _stringify_ast(item, depth + 2)\n\n                elif isinstance(item, (ast.AST, ast3.AST, ast27.AST)):\n                    yield from _stringify_ast(item, depth + 2)\n\n        elif isinstance(value, (ast.AST, ast3.AST, ast27.AST)):\n            yield from _stringify_ast(value, depth + 2)\n\n        else:\n            # Constant strings may be indented across newlines, if they are\n            # docstrings; fold spaces after newlines when comparing. Similarly,\n            # trailing and leading space may be removed.\n            if (\n                isinstance(node, ast.Constant)\n                and field == \"value\"\n                and isinstance(value, str)\n            ):\n                normalized = re.sub(r\" *\\n[ \\t]*\", \"\\n\", value).strip()\n            else:\n                normalized = value\n            yield f\"{'  ' * (depth+2)}{normalized!r},  # {value.__class__.__name__}\"\n\n    yield f\"{'  ' * depth})  # /{node.__class__.__name__}\"", "is_method": false, "function_description": "Utility function that recursively converts an abstract syntax tree (AST) node into a formatted string iterator, facilitating comparison of AST structures by content for syntax or semantic analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "assert_equivalent", "line_number": 6130, "body": "def assert_equivalent(src: str, dst: str) -> None:\n    \"\"\"Raise AssertionError if `src` and `dst` aren't equivalent.\"\"\"\n    try:\n        src_ast = parse_ast(src)\n    except Exception as exc:\n        raise AssertionError(\n            \"cannot use --safe with this file; failed to parse source file.  AST\"\n            f\" error message: {exc}\"\n        )\n\n    try:\n        dst_ast = parse_ast(dst)\n    except Exception as exc:\n        log = dump_to_file(\"\".join(traceback.format_tb(exc.__traceback__)), dst)\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced invalid code: {exc}. Please report a bug\"\n            \" on https://github.com/psf/black/issues.  This invalid output might be\"\n            f\" helpful: {log}\"\n        ) from None\n\n    src_ast_str = \"\\n\".join(_stringify_ast(src_ast))\n    dst_ast_str = \"\\n\".join(_stringify_ast(dst_ast))\n    if src_ast_str != dst_ast_str:\n        log = dump_to_file(diff(src_ast_str, dst_ast_str, \"src\", \"dst\"))\n        raise AssertionError(\n            \"INTERNAL ERROR: Black produced code that is not equivalent to the\"\n            \" source.  Please report a bug on https://github.com/psf/black/issues. \"\n            f\" This diff might be helpful: {log}\"\n        ) from None", "is_method": false, "function_description": "Function that verifies if two source code strings are semantically equivalent by comparing their abstract syntax trees and raises an AssertionError if they differ or cannot be parsed. This ensures code transformations preserve original logic, useful for code formatting or refactoring tools."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "assert_stable", "line_number": 6161, "body": "def assert_stable(src: str, dst: str, mode: Mode) -> None:\n    \"\"\"Raise AssertionError if `dst` reformats differently the second time.\"\"\"\n    newdst = format_str(dst, mode=mode)\n    if dst != newdst:\n        log = dump_to_file(\n            str(mode),\n            diff(src, dst, \"source\", \"first pass\"),\n            diff(dst, newdst, \"first pass\", \"second pass\"),\n        )\n        raise AssertionError(\n            \"INTERNAL ERROR: Black produced different code on the second pass of the\"\n            \" formatter.  Please report a bug on https://github.com/psf/black/issues.\"\n            f\"  This diff might be helpful: {log}\"\n        ) from None", "is_method": false, "function_description": "Utility function that verifies if a formatted string remains consistent upon reformatting, ensuring stability and idempotence of code formatting in the given mode. It raises an error if the formatting changes between passes."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "dump_to_file", "line_number": 6178, "body": "def dump_to_file(*output: str) -> str:\n    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n    with tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"blk_\", suffix=\".log\", delete=False, encoding=\"utf8\"\n    ) as f:\n        for lines in output:\n            f.write(lines)\n            if lines and lines[-1] != \"\\n\":\n                f.write(\"\\n\")\n    return f.name", "is_method": false, "function_description": "Utility function that writes given strings to a uniquely named temporary log file and returns its file path, facilitating temporary storage of output data for later access or processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "nullcontext", "line_number": 6191, "body": "def nullcontext() -> Iterator[None]:\n    \"\"\"Return an empty context manager.\n\n    To be used like `nullcontext` in Python 3.7.\n    \"\"\"\n    yield", "is_method": false, "function_description": "Utility function that provides a no-op context manager, useful for conditional context management where a context manager is syntactically required but no setup or teardown is needed."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "diff", "line_number": 6199, "body": "def diff(a: str, b: str, a_name: str, b_name: str) -> str:\n    \"\"\"Return a unified diff string between strings `a` and `b`.\"\"\"\n    import difflib\n\n    a_lines = [line + \"\\n\" for line in a.splitlines()]\n    b_lines = [line + \"\\n\" for line in b.splitlines()]\n    return \"\".join(\n        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n    )", "is_method": false, "function_description": "Function that generates a unified diff string showing line-by-line differences between two text inputs, labeled with given names, useful for comparing version changes or content differences in text data."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "cancel", "line_number": 6210, "body": "def cancel(tasks: Iterable[\"asyncio.Task[Any]\"]) -> None:\n    \"\"\"asyncio signal handler that cancels all `tasks` and reports to stderr.\"\"\"\n    err(\"Aborted!\")\n    for task in tasks:\n        task.cancel()", "is_method": false, "function_description": "Function that cancels a collection of asyncio tasks and outputs an abort message to standard error. It provides a simple mechanism to stop ongoing asynchronous operations in response to a signal."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "shutdown", "line_number": 6217, "body": "def shutdown(loop: asyncio.AbstractEventLoop) -> None:\n    \"\"\"Cancel all pending tasks on `loop`, wait for them, and close the loop.\"\"\"\n    try:\n        if sys.version_info[:2] >= (3, 7):\n            all_tasks = asyncio.all_tasks\n        else:\n            all_tasks = asyncio.Task.all_tasks\n        # This part is borrowed from asyncio/runners.py in Python 3.7b2.\n        to_cancel = [task for task in all_tasks(loop) if not task.done()]\n        if not to_cancel:\n            return\n\n        for task in to_cancel:\n            task.cancel()\n        loop.run_until_complete(\n            asyncio.gather(*to_cancel, loop=loop, return_exceptions=True)\n        )\n    finally:\n        # `concurrent.futures.Future` objects cannot be cancelled once they\n        # are already running. There might be some when the `shutdown()` happened.\n        # Silence their logger's spew about the event loop being closed.\n        cf_logger = logging.getLogger(\"concurrent.futures\")\n        cf_logger.setLevel(logging.CRITICAL)\n        loop.close()", "is_method": false, "function_description": "Function that safely cancels all pending asyncio tasks on an event loop, waits for their completion, and then closes the loop to ensure a clean shutdown. Useful for gracefully terminating asynchronous programs or services."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "sub_twice", "line_number": 6243, "body": "def sub_twice(regex: Pattern[str], replacement: str, original: str) -> str:\n    \"\"\"Replace `regex` with `replacement` twice on `original`.\n\n    This is used by string normalization to perform replaces on\n    overlapping matches.\n    \"\"\"\n    return regex.sub(replacement, regex.sub(replacement, original))", "is_method": false, "function_description": "Function that applies a regex substitution twice on a string to handle overlapping matches, supporting advanced string normalization scenarios."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "re_compile_maybe_verbose", "line_number": 6252, "body": "def re_compile_maybe_verbose(regex: str) -> Pattern[str]:\n    \"\"\"Compile a regular expression string in `regex`.\n\n    If it contains newlines, use verbose mode.\n    \"\"\"\n    if \"\\n\" in regex:\n        regex = \"(?x)\" + regex\n    compiled: Pattern[str] = re.compile(regex)\n    return compiled", "is_method": false, "function_description": "Utility function that compiles a regular expression string, automatically enabling verbose mode if the pattern contains newlines for improved readability and maintainability."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "enumerate_reversed", "line_number": 6263, "body": "def enumerate_reversed(sequence: Sequence[T]) -> Iterator[Tuple[Index, T]]:\n    \"\"\"Like `reversed(enumerate(sequence))` if that were possible.\"\"\"\n    index = len(sequence) - 1\n    for element in reversed(sequence):\n        yield (index, element)\n        index -= 1", "is_method": false, "function_description": "Utility function that provides reversed enumeration of a sequence, yielding index-element pairs from the sequence's end to start. It enables iteration over a sequence in reverse with both element values and their original indices."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "enumerate_with_length", "line_number": 6271, "body": "def enumerate_with_length(\n    line: Line, reversed: bool = False\n) -> Iterator[Tuple[Index, Leaf, int]]:\n    \"\"\"Return an enumeration of leaves with their length.\n\n    Stops prematurely on multiline strings and standalone comments.\n    \"\"\"\n    op = cast(\n        Callable[[Sequence[Leaf]], Iterator[Tuple[Index, Leaf]]],\n        enumerate_reversed if reversed else enumerate,\n    )\n    for index, leaf in op(line.leaves):\n        length = len(leaf.prefix) + len(leaf.value)\n        if \"\\n\" in leaf.value:\n            return  # Multiline strings, we can't continue.\n\n        for comment in line.comments_after(leaf):\n            length += len(comment.value)\n\n        yield index, leaf, length", "is_method": false, "function_description": "Utility function that enumerates leaves in a line, yielding each leaf with its cumulative length while stopping at multiline strings or standalone comments to support line-based token processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_line_short_enough", "line_number": 6293, "body": "def is_line_short_enough(line: Line, *, line_length: int, line_str: str = \"\") -> bool:\n    \"\"\"Return True if `line` is no longer than `line_length`.\n\n    Uses the provided `line_str` rendering, if any, otherwise computes a new one.\n    \"\"\"\n    if not line_str:\n        line_str = line_to_string(line)\n    return (\n        len(line_str) <= line_length\n        and \"\\n\" not in line_str  # multiline strings\n        and not line.contains_standalone_comments()\n    )", "is_method": false, "function_description": "Function that checks if a given line's string representation is within a specified length, contains no newline characters, and has no standalone comments. It helps validate line length constraints for code formatting or analysis tasks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "can_be_split", "line_number": 6307, "body": "def can_be_split(line: Line) -> bool:\n    \"\"\"Return False if the line cannot be split *for sure*.\n\n    This is not an exhaustive search but a cheap heuristic that we can use to\n    avoid some unfortunate formattings (mostly around wrapping unsplittable code\n    in unnecessary parentheses).\n    \"\"\"\n    leaves = line.leaves\n    if len(leaves) < 2:\n        return False\n\n    if leaves[0].type == token.STRING and leaves[1].type == token.DOT:\n        call_count = 0\n        dot_count = 0\n        next = leaves[-1]\n        for leaf in leaves[-2::-1]:\n            if leaf.type in OPENING_BRACKETS:\n                if next.type not in CLOSING_BRACKETS:\n                    return False\n\n                call_count += 1\n            elif leaf.type == token.DOT:\n                dot_count += 1\n            elif leaf.type == token.NAME:\n                if not (next.type == token.DOT or next.type in OPENING_BRACKETS):\n                    return False\n\n            elif leaf.type not in CLOSING_BRACKETS:\n                return False\n\n            if dot_count > 1 and call_count > 1:\n                return False\n\n    return True", "is_method": false, "function_description": "Utility function that heuristically determines if a given line of code can be split without causing formatting issues, helping avoid unnecessary parentheses around unsplittable code elements."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "can_omit_invisible_parens", "line_number": 6343, "body": "def can_omit_invisible_parens(\n    line: Line,\n    line_length: int,\n    omit_on_explode: Collection[LeafID] = (),\n) -> bool:\n    \"\"\"Does `line` have a shape safe to reformat without optional parens around it?\n\n    Returns True for only a subset of potentially nice looking formattings but\n    the point is to not return false positives that end up producing lines that\n    are too long.\n    \"\"\"\n    bt = line.bracket_tracker\n    if not bt.delimiters:\n        # Without delimiters the optional parentheses are useless.\n        return True\n\n    max_priority = bt.max_delimiter_priority()\n    if bt.delimiter_count_with_priority(max_priority) > 1:\n        # With more than one delimiter of a kind the optional parentheses read better.\n        return False\n\n    if max_priority == DOT_PRIORITY:\n        # A single stranded method call doesn't require optional parentheses.\n        return True\n\n    assert len(line.leaves) >= 2, \"Stranded delimiter\"\n\n    # With a single delimiter, omit if the expression starts or ends with\n    # a bracket.\n    first = line.leaves[0]\n    second = line.leaves[1]\n    if first.type in OPENING_BRACKETS and second.type not in CLOSING_BRACKETS:\n        if _can_omit_opening_paren(line, first=first, line_length=line_length):\n            return True\n\n        # Note: we are not returning False here because a line might have *both*\n        # a leading opening bracket and a trailing closing bracket.  If the\n        # opening bracket doesn't match our rule, maybe the closing will.\n\n    penultimate = line.leaves[-2]\n    last = line.leaves[-1]\n    if line.should_explode:\n        try:\n            penultimate, last = last_two_except(line.leaves, omit=omit_on_explode)\n        except LookupError:\n            # Turns out we'd omit everything.  We cannot skip the optional parentheses.\n            return False\n\n    if (\n        last.type == token.RPAR\n        or last.type == token.RBRACE\n        or (\n            # don't use indexing for omitting optional parentheses;\n            # it looks weird\n            last.type == token.RSQB\n            and last.parent\n            and last.parent.type != syms.trailer\n        )\n    ):\n        if penultimate.type in OPENING_BRACKETS:\n            # Empty brackets don't help.\n            return False\n\n        if is_multiline_string(first):\n            # Additional wrapping of a multiline string in this situation is\n            # unnecessary.\n            return True\n\n        if line.should_explode and penultimate.type == token.COMMA:\n            # The rightmost non-omitted bracket pair is the one we want to explode on.\n            return True\n\n        if _can_omit_closing_paren(line, last=last, line_length=line_length):\n            return True\n\n    return False", "is_method": false, "function_description": "Utility function that determines if optional parentheses around an expression can be safely omitted without risking line length overflow or readability issues during code reformatting. It helps formatters decide when parentheses are unnecessary around certain bracketed expressions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_can_omit_opening_paren", "line_number": 6421, "body": "def _can_omit_opening_paren(line: Line, *, first: Leaf, line_length: int) -> bool:\n    \"\"\"See `can_omit_invisible_parens`.\"\"\"\n    remainder = False\n    length = 4 * line.depth\n    _index = -1\n    for _index, leaf, leaf_length in enumerate_with_length(line):\n        if leaf.type in CLOSING_BRACKETS and leaf.opening_bracket is first:\n            remainder = True\n        if remainder:\n            length += leaf_length\n            if length > line_length:\n                break\n\n            if leaf.type in OPENING_BRACKETS:\n                # There are brackets we can further split on.\n                remainder = False\n\n    else:\n        # checked the entire string and line length wasn't exceeded\n        if len(line.leaves) == _index + 1:\n            return True\n\n    return False", "is_method": false, "function_description": "Private utility function that determines if opening parentheses related to a given leaf in a code line can be omitted based on line length and bracket structure, aiding in formatting or code style decisions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_can_omit_closing_paren", "line_number": 6446, "body": "def _can_omit_closing_paren(line: Line, *, last: Leaf, line_length: int) -> bool:\n    \"\"\"See `can_omit_invisible_parens`.\"\"\"\n    length = 4 * line.depth\n    seen_other_brackets = False\n    for _index, leaf, leaf_length in enumerate_with_length(line):\n        length += leaf_length\n        if leaf is last.opening_bracket:\n            if seen_other_brackets or length <= line_length:\n                return True\n\n        elif leaf.type in OPENING_BRACKETS:\n            # There are brackets we can further split on.\n            seen_other_brackets = True\n\n    return False", "is_method": false, "function_description": "Determines if the closing parenthesis in a line can be omitted based on bracket structure and line length constraints. Useful for formatting code by conditionally removing unnecessary closing brackets."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "last_two_except", "line_number": 6463, "body": "def last_two_except(leaves: List[Leaf], omit: Collection[LeafID]) -> Tuple[Leaf, Leaf]:\n    \"\"\"Return (penultimate, last) leaves skipping brackets in `omit` and contents.\"\"\"\n    stop_after = None\n    last = None\n    for leaf in reversed(leaves):\n        if stop_after:\n            if leaf is stop_after:\n                stop_after = None\n            continue\n\n        if last:\n            return leaf, last\n\n        if id(leaf) in omit:\n            stop_after = leaf.opening_bracket\n        else:\n            last = leaf\n    else:\n        raise LookupError(\"Last two leaves were also skipped\")", "is_method": false, "function_description": "This function returns the last two leaves from a list, excluding any leaves or bracketed groups specified in an omit collection. It is useful for parsing or processing tree-like structures while ignoring certain subtrees."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "run_transformer", "line_number": 6484, "body": "def run_transformer(\n    line: Line,\n    transform: Transformer,\n    mode: Mode,\n    features: Collection[Feature],\n    *,\n    line_str: str = \"\",\n) -> List[Line]:\n    if not line_str:\n        line_str = line_to_string(line)\n    result: List[Line] = []\n    for transformed_line in transform(line, features):\n        if str(transformed_line).strip(\"\\n\") == line_str:\n            raise CannotTransform(\"Line transformer returned an unchanged result\")\n\n        result.extend(transform_line(transformed_line, mode=mode, features=features))\n\n    if not (\n        transform.__name__ == \"rhs\"\n        and line.bracket_tracker.invisible\n        and not any(bracket.value for bracket in line.bracket_tracker.invisible)\n        and not line.contains_multiline_strings()\n        and not result[0].contains_uncollapsable_type_comments()\n        and not result[0].contains_unsplittable_type_ignore()\n        and not is_line_short_enough(result[0], line_length=mode.line_length)\n    ):\n        return result\n\n    line_copy = line.clone()\n    append_leaves(line_copy, line, line.leaves)\n    features_fop = set(features) | {Feature.FORCE_OPTIONAL_PARENTHESES}\n    second_opinion = run_transformer(\n        line_copy, transform, mode, features_fop, line_str=line_str\n    )\n    if all(\n        is_line_short_enough(ln, line_length=mode.line_length) for ln in second_opinion\n    ):\n        result = second_opinion\n    return result", "is_method": false, "function_description": "Function that applies a given line transformation and recursively refines the result based on formatting features and line length constraints to ensure meaningful code reformatting without redundant outputs."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "get_cache_file", "line_number": 6525, "body": "def get_cache_file(mode: Mode) -> Path:\n    return CACHE_DIR / f\"cache.{mode.get_cache_key()}.pickle\"", "is_method": false, "function_description": "Returns the file path for the cache corresponding to a given mode, facilitating organized access to cached data based on mode-specific keys."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "read_cache", "line_number": 6529, "body": "def read_cache(mode: Mode) -> Cache:\n    \"\"\"Read the cache if it exists and is well formed.\n\n    If it is not well formed, the call to write_cache later should resolve the issue.\n    \"\"\"\n    cache_file = get_cache_file(mode)\n    if not cache_file.exists():\n        return {}\n\n    with cache_file.open(\"rb\") as fobj:\n        try:\n            cache: Cache = pickle.load(fobj)\n        except (pickle.UnpicklingError, ValueError):\n            return {}\n\n    return cache", "is_method": false, "function_description": "Function to load and return a serialized cache for a given mode, returning an empty cache if none exists or if the stored cache is corrupted. It supports cache management and data persistence across sessions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "get_cache_info", "line_number": 6547, "body": "def get_cache_info(path: Path) -> CacheInfo:\n    \"\"\"Return the information used to check if a file is already formatted or not.\"\"\"\n    stat = path.stat()\n    return stat.st_mtime, stat.st_size", "is_method": false, "function_description": "Function that provides file metadata (modification time and size) to determine if the file has been previously formatted or needs reprocessing, assisting in caching or file change detection workflows."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "filter_cached", "line_number": 6553, "body": "def filter_cached(cache: Cache, sources: Iterable[Path]) -> Tuple[Set[Path], Set[Path]]:\n    \"\"\"Split an iterable of paths in `sources` into two sets.\n\n    The first contains paths of files that modified on disk or are not in the\n    cache. The other contains paths to non-modified files.\n    \"\"\"\n    todo, done = set(), set()\n    for src in sources:\n        src = src.resolve()\n        if cache.get(src) != get_cache_info(src):\n            todo.add(src)\n        else:\n            done.add(src)\n    return todo, done", "is_method": false, "function_description": "Utility function that divides file paths into those needing processing due to modifications or absence in cache, and those that are unchanged, facilitating efficient file handling based on cache status."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "write_cache", "line_number": 6569, "body": "def write_cache(cache: Cache, sources: Iterable[Path], mode: Mode) -> None:\n    \"\"\"Update the cache file.\"\"\"\n    cache_file = get_cache_file(mode)\n    try:\n        CACHE_DIR.mkdir(parents=True, exist_ok=True)\n        new_cache = {**cache, **{src.resolve(): get_cache_info(src) for src in sources}}\n        with tempfile.NamedTemporaryFile(dir=str(cache_file.parent), delete=False) as f:\n            pickle.dump(new_cache, f, protocol=4)\n        os.replace(f.name, cache_file)\n    except OSError:\n        pass", "is_method": false, "function_description": "Function that updates a cache file by merging existing cache data with new information from specified source files, ensuring atomic writes to prevent corruption. It supports cache management for file-based data tracking or retrieval systems."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "patch_click", "line_number": 6582, "body": "def patch_click() -> None:\n    \"\"\"Make Click not crash.\n\n    On certain misconfigured environments, Python 3 selects the ASCII encoding as the\n    default which restricts paths that it can access during the lifetime of the\n    application.  Click refuses to work in this scenario by raising a RuntimeError.\n\n    In case of Black the likelihood that non-ASCII characters are going to be used in\n    file paths is minimal since it's Python source code.  Moreover, this crash was\n    spurious on Python 3.7 thanks to PEP 538 and PEP 540.\n    \"\"\"\n    try:\n        from click import core\n        from click import _unicodefun  # type: ignore\n    except ModuleNotFoundError:\n        return\n\n    for module in (core, _unicodefun):\n        if hasattr(module, \"_verify_python3_env\"):\n            module._verify_python3_env = lambda: None", "is_method": false, "function_description": "Function that disables Click\u2019s environment verification to prevent runtime errors in environments with ASCII default encoding, improving compatibility for applications handling mostly ASCII file paths like Python source code formatting tools."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_docstring", "line_number": 6610, "body": "def is_docstring(leaf: Leaf) -> bool:\n    if not is_multiline_string(leaf):\n        # For the purposes of docstring re-indentation, we don't need to do anything\n        # with single-line docstrings.\n        return False\n\n    if prev_siblings_are(\n        leaf.parent, [None, token.NEWLINE, token.INDENT, syms.simple_stmt]\n    ):\n        return True\n\n    # Multiline docstring on the same line as the `def`.\n    if prev_siblings_are(leaf.parent, [syms.parameters, token.COLON, syms.simple_stmt]):\n        # `syms.parameters` is only used in funcdefs and async_funcdefs in the Python\n        # grammar. We're safe to return True without further checks.\n        return True\n\n    return False", "is_method": false, "function_description": "Determines if a given syntax leaf node represents a multiline docstring based on its indentation and sibling nodes, aiding code parsing or refactoring tools in identifying docstrings accurately."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "fix_docstring", "line_number": 6630, "body": "def fix_docstring(docstring: str, prefix: str) -> str:\n    # https://www.python.org/dev/peps/pep-0257/#handling-docstring-indentation\n    if not docstring:\n        return \"\"\n    # Convert tabs to spaces (following the normal Python rules)\n    # and split into a list of lines:\n    lines = docstring.expandtabs().splitlines()\n    # Determine minimum indentation (first line doesn't count):\n    indent = sys.maxsize\n    for line in lines[1:]:\n        stripped = line.lstrip()\n        if stripped:\n            indent = min(indent, len(line) - len(stripped))\n    # Remove indentation (first line is special):\n    trimmed = [lines[0].strip()]\n    if indent < sys.maxsize:\n        last_line_idx = len(lines) - 2\n        for i, line in enumerate(lines[1:]):\n            stripped_line = line[indent:].rstrip()\n            if stripped_line or i == last_line_idx:\n                trimmed.append(prefix + stripped_line)\n            else:\n                trimmed.append(\"\")\n    return \"\\n\".join(trimmed)", "is_method": false, "function_description": "Utility function that normalizes a docstring's indentation according to Python conventions, optionally prefixing lines; useful for consistent formatting and display of multi-line docstrings across different environments."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "ok", "line_number": 123, "body": "def ok(self) -> T:\n        return self._value", "is_method": true, "class_name": "Ok", "function_description": "Returns the stored value encapsulated by the Ok instance, providing access to its underlying successful result."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "err", "line_number": 131, "body": "def err(self) -> E:\n        return self._e", "is_method": true, "class_name": "Err", "function_description": "Accessor method in the Err class that returns the stored error value, facilitating error retrieval for handling or reporting purposes."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "from_configuration", "line_number": 151, "body": "def from_configuration(\n        cls, *, check: bool, diff: bool, color: bool = False\n    ) -> \"WriteBack\":\n        if check and not diff:\n            return cls.CHECK\n\n        if diff and color:\n            return cls.COLOR_DIFF\n\n        return cls.DIFF if diff else cls.YES", "is_method": true, "class_name": "WriteBack", "function_description": "Factory method of the WriteBack class that returns a specific WriteBack mode based on check, diff, and color flags, facilitating configurable write-back behavior in different scenarios."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_python2", "line_number": 178, "body": "def is_python2(self) -> bool:\n        return self is TargetVersion.PY27", "is_method": true, "class_name": "TargetVersion", "function_description": "Determines if the current TargetVersion instance represents Python 2.7, enabling version-specific behavior or compatibility checks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "get_cache_key", "line_number": 247, "body": "def get_cache_key(self) -> str:\n        if self.target_versions:\n            version_str = \",\".join(\n                str(version.value)\n                for version in sorted(self.target_versions, key=lambda v: v.value)\n            )\n        else:\n            version_str = \"-\"\n        parts = [\n            version_str,\n            str(self.line_length),\n            str(int(self.string_normalization)),\n            str(int(self.is_pyi)),\n        ]\n        return \".\".join(parts)", "is_method": true, "class_name": "Mode", "function_description": "Generates a unique string key representing the Mode instance\u2019s configuration by encoding its target versions, line length, normalization flag, and a type indicator. This key supports caching or deduplication based on mode settings."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit", "line_number": 1099, "body": "def visit(self, node: LN) -> Iterator[T]:\n        \"\"\"Main method to visit `node` and its children.\n\n        It tries to find a `visit_*()` method for the given `node.type`, like\n        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.\n        If no dedicated `visit_*()` method is found, chooses `visit_default()`\n        instead.\n\n        Then yields objects of type `T` from the selected visitor.\n        \"\"\"\n        if node.type < 256:\n            name = token.tok_name[node.type]\n        else:\n            name = str(type_repr(node.type))\n        # We explicitly branch on whether a visitor exists (instead of\n        # using self.visit_default as the default arg to getattr) in order\n        # to save needing to create a bound method object and so mypyc can\n        # generate a native call to visit_default.\n        visitf = getattr(self, f\"visit_{name}\", None)\n        if visitf:\n            yield from visitf(node)\n        else:\n            yield from self.visit_default(node)", "is_method": true, "class_name": "Visitor", "function_description": "Core traversal method of the Visitor class that dispatches visiting behavior based on a node's type by invoking a corresponding specialized method or falling back to a default visitor, yielding processed results from the node and its children."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_default", "line_number": 1123, "body": "def visit_default(self, node: LN) -> Iterator[T]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)", "is_method": true, "class_name": "Visitor", "function_description": "Core method of the Visitor class that recursively traverses child nodes from a given node, providing default behavior for visiting node structures in tree-like data. It supports flexible iteration over hierarchical elements."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_default", "line_number": 1134, "body": "def visit_default(self, node: LN) -> Iterator[T]:\n        indent = \" \" * (2 * self.tree_depth)\n        if isinstance(node, Node):\n            _type = type_repr(node.type)\n            out(f\"{indent}{_type}\", fg=\"yellow\")\n            self.tree_depth += 1\n            for child in node.children:\n                yield from self.visit(child)\n\n            self.tree_depth -= 1\n            out(f\"{indent}/{_type}\", fg=\"yellow\", bold=False)\n        else:\n            _type = token.tok_name.get(node.type, str(node.type))\n            out(f\"{indent}{_type}\", fg=\"blue\", nl=False)\n            if node.prefix:\n                # We don't have to handle prefixes for `Node` objects since\n                # that delegates to the first child anyway.\n                out(f\" {node.prefix!r}\", fg=\"green\", bold=False, nl=False)\n            out(f\" {node.value!r}\", fg=\"blue\", bold=False)", "is_method": true, "class_name": "DebugVisitor", "function_description": "Utility function within DebugVisitor class that traverses and visually formats an abstract syntax tree node and its children, printing node types and values with indentation and color-coded output for debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "show", "line_number": 1155, "body": "def show(cls, code: Union[str, Leaf, Node]) -> None:\n        \"\"\"Pretty-print the lib2to3 AST of a given string of `code`.\n\n        Convenience method for debugging.\n        \"\"\"\n        v: DebugVisitor[None] = DebugVisitor()\n        if isinstance(code, str):\n            code = lib2to3_parse(code)\n        list(v.visit(code))", "is_method": true, "class_name": "DebugVisitor", "function_description": "Utility method of DebugVisitor that pretty-prints the lib2to3 abstract syntax tree (AST) of given code for easier debugging and inspection of code structure."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "mark", "line_number": 1290, "body": "def mark(self, leaf: Leaf) -> None:\n        \"\"\"Mark `leaf` with bracket-related metadata. Keep track of delimiters.\n\n        All leaves receive an int `bracket_depth` field that stores how deep\n        within brackets a given leaf is. 0 means there are no enclosing brackets\n        that started on this line.\n\n        If a leaf is itself a closing bracket, it receives an `opening_bracket`\n        field that it forms a pair with. This is a one-directional link to\n        avoid reference cycles.\n\n        If a leaf is a delimiter (a token on which Black can split the line if\n        needed) and it's on depth 0, its `id()` is stored in the tracker's\n        `delimiters` field.\n        \"\"\"\n        if leaf.type == token.COMMENT:\n            return\n\n        self.maybe_decrement_after_for_loop_variable(leaf)\n        self.maybe_decrement_after_lambda_arguments(leaf)\n        if leaf.type in CLOSING_BRACKETS:\n            self.depth -= 1\n            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))\n            leaf.opening_bracket = opening_bracket\n            if not leaf.value:\n                self.invisible.append(leaf)\n        leaf.bracket_depth = self.depth\n        if self.depth == 0:\n            delim = is_split_before_delimiter(leaf, self.previous)\n            if delim and self.previous is not None:\n                self.delimiters[id(self.previous)] = delim\n            else:\n                delim = is_split_after_delimiter(leaf, self.previous)\n                if delim:\n                    self.delimiters[id(leaf)] = delim\n        if leaf.type in OPENING_BRACKETS:\n            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf\n            self.depth += 1\n            if not leaf.value:\n                self.invisible.append(leaf)\n        self.previous = leaf\n        self.maybe_increment_lambda_arguments(leaf)\n        self.maybe_increment_for_loop_variable(leaf)", "is_method": true, "class_name": "BracketTracker", "function_description": "Tracks bracket nesting levels and marks leaves with bracket metadata, linking closing brackets to their corresponding openings and identifying top-level delimiters for line splitting. Enables structural analysis of code tokens regarding bracket depth and delimiter positions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "any_open_brackets", "line_number": 1334, "body": "def any_open_brackets(self) -> bool:\n        \"\"\"Return True if there is an yet unmatched open bracket on the line.\"\"\"\n        return bool(self.bracket_match)", "is_method": true, "class_name": "BracketTracker", "function_description": "Utility method of BracketTracker that indicates if there are any unmatched open brackets currently tracked, helping to verify bracket pairing status in text processing or parsing tasks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "max_delimiter_priority", "line_number": 1338, "body": "def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> Priority:\n        \"\"\"Return the highest priority of a delimiter found on the line.\n\n        Values are consistent with what `is_split_*_delimiter()` return.\n        Raises ValueError on no delimiters.\n        \"\"\"\n        return max(v for k, v in self.delimiters.items() if k not in exclude)", "is_method": true, "class_name": "BracketTracker", "function_description": "This method identifies the highest priority delimiter present in the tracked line, excluding specified delimiters if given. It helps determine which delimiter should be processed first when splitting or parsing text."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "delimiter_count_with_priority", "line_number": 1346, "body": "def delimiter_count_with_priority(self, priority: Priority = 0) -> int:\n        \"\"\"Return the number of delimiters with the given `priority`.\n\n        If no `priority` is passed, defaults to max priority on the line.\n        \"\"\"\n        if not self.delimiters:\n            return 0\n\n        priority = priority or self.max_delimiter_priority()\n        return sum(1 for p in self.delimiters.values() if p == priority)", "is_method": true, "class_name": "BracketTracker", "function_description": "Counts how many delimiters in the current context have a specific priority level, defaulting to the highest existing priority if none is specified. Useful for prioritizing or filtering delimiters based on their importance in parsing or processing tasks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "maybe_increment_for_loop_variable", "line_number": 1357, "body": "def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"In a for loop, or comprehension, the variables are often unpacks.\n\n        To avoid splitting on the comma in this situation, increase the depth of\n        tokens between `for` and `in`.\n        \"\"\"\n        if leaf.type == token.NAME and leaf.value == \"for\":\n            self.depth += 1\n            self._for_loop_depths.append(self.depth)\n            return True\n\n        return False", "is_method": true, "class_name": "BracketTracker", "function_description": "Tracks and adjusts the token parsing depth when encountering a 'for' keyword to correctly handle variable unpacking in loops or comprehensions, preventing incorrect splitting of tokens like commas within the loop header."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "maybe_decrement_after_for_loop_variable", "line_number": 1370, "body": "def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"See `maybe_increment_for_loop_variable` above for explanation.\"\"\"\n        if (\n            self._for_loop_depths\n            and self._for_loop_depths[-1] == self.depth\n            and leaf.type == token.NAME\n            and leaf.value == \"in\"\n        ):\n            self.depth -= 1\n            self._for_loop_depths.pop()\n            return True\n\n        return False", "is_method": true, "class_name": "BracketTracker", "function_description": "Utility method of BracketTracker that adjusts loop nesting depth when detecting the end of a for-loop variable declaration, helping manage accurate tracking of loop structures during parsing or analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "maybe_increment_lambda_arguments", "line_number": 1384, "body": "def maybe_increment_lambda_arguments(self, leaf: Leaf) -> bool:\n        \"\"\"In a lambda expression, there might be more than one argument.\n\n        To avoid splitting on the comma in this situation, increase the depth of\n        tokens between `lambda` and `:`.\n        \"\"\"\n        if leaf.type == token.NAME and leaf.value == \"lambda\":\n            self.depth += 1\n            self._lambda_argument_depths.append(self.depth)\n            return True\n\n        return False", "is_method": true, "class_name": "BracketTracker", "function_description": "Tracks and manages the depth of tokens within lambda expressions to correctly handle multiple lambda arguments without misinterpreting commas as separators."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "maybe_decrement_after_lambda_arguments", "line_number": 1397, "body": "def maybe_decrement_after_lambda_arguments(self, leaf: Leaf) -> bool:\n        \"\"\"See `maybe_increment_lambda_arguments` above for explanation.\"\"\"\n        if (\n            self._lambda_argument_depths\n            and self._lambda_argument_depths[-1] == self.depth\n            and leaf.type == token.COLON\n        ):\n            self.depth -= 1\n            self._lambda_argument_depths.pop()\n            return True\n\n        return False", "is_method": true, "class_name": "BracketTracker", "function_description": "Utility method of BracketTracker that conditionally decreases the bracket depth after parsing lambda arguments when encountering a colon, supporting accurate tracking of nested lambda expressions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "get_open_lsqb", "line_number": 1410, "body": "def get_open_lsqb(self) -> Optional[Leaf]:\n        \"\"\"Return the most recent opening square bracket (if any).\"\"\"\n        return self.bracket_match.get((self.depth - 1, token.RSQB))", "is_method": true, "class_name": "BracketTracker", "function_description": "Returns the most recent unmatched opening square bracket tracked, or None if none exists. This supports bracket matching and parsing tasks by identifying open brackets at the current nesting depth."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "append", "line_number": 1427, "body": "def append(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Add a new `leaf` to the end of the line.\n\n        Unless `preformatted` is True, the `leaf` will receive a new consistent\n        whitespace prefix and metadata applied by :class:`BracketTracker`.\n        Trailing commas are maybe removed, unpacked for loop variables are\n        demoted from being delimiters.\n\n        Inline comments are put aside.\n        \"\"\"\n        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())\n        if not has_value:\n            return\n\n        if token.COLON == leaf.type and self.is_class_paren_empty:\n            del self.leaves[-2:]\n        if self.leaves and not preformatted:\n            # Note: at this point leaf.prefix should be empty except for\n            # imports, for which we only preserve newlines.\n            leaf.prefix += whitespace(\n                leaf, complex_subscript=self.is_complex_subscript(leaf)\n            )\n        if self.inside_brackets or not preformatted:\n            self.bracket_tracker.mark(leaf)\n            if self.maybe_should_explode(leaf):\n                self.should_explode = True\n        if not self.append_comment(leaf):\n            self.leaves.append(leaf)", "is_method": true, "class_name": "Line", "function_description": "Utility method of the Line class that appends a new leaf element, optionally adjusting its whitespace, metadata, and formatting. It manages bracket tracking and inline comments to maintain consistent code structure."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "append_safe", "line_number": 1456, "body": "def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Like :func:`append()` but disallow invalid standalone comment structure.\n\n        Raises ValueError when any `leaf` is appended after a standalone comment\n        or when a standalone comment is not the first leaf on the line.\n        \"\"\"\n        if self.bracket_tracker.depth == 0:\n            if self.is_comment:\n                raise ValueError(\"cannot append to standalone comments\")\n\n            if self.leaves and leaf.type == STANDALONE_COMMENT:\n                raise ValueError(\n                    \"cannot append standalone comments to a populated line\"\n                )\n\n        self.append(leaf, preformatted=preformatted)", "is_method": true, "class_name": "Line", "function_description": "Ensures safe appending of leaf elements to a line by preventing invalid standalone comment placements, enforcing structural integrity when modifying line content. Useful for maintaining syntactically correct comment positioning in code lines."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_comment", "line_number": 1474, "body": "def is_comment(self) -> bool:\n        \"\"\"Is this line a standalone comment?\"\"\"\n        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT", "is_method": true, "class_name": "Line", "function_description": "Utility method of the Line class that determines if a line represents a standalone comment, aiding in code analysis or parsing tasks that differentiate comments from other line types."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_decorator", "line_number": 1479, "body": "def is_decorator(self) -> bool:\n        \"\"\"Is this line a decorator?\"\"\"\n        return bool(self) and self.leaves[0].type == token.AT", "is_method": true, "class_name": "Line", "function_description": "Utility method of the Line class that determines if the line represents a Python decorator by checking its initial token type. It facilitates identifying decorator syntax in code parsing or analysis tasks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_import", "line_number": 1484, "body": "def is_import(self) -> bool:\n        \"\"\"Is this an import line?\"\"\"\n        return bool(self) and is_import(self.leaves[0])", "is_method": true, "class_name": "Line", "function_description": "Utility method of the Line class that determines whether the line represents an import statement. It enables parsing or analysis workflows to identify import lines efficiently."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_class", "line_number": 1489, "body": "def is_class(self) -> bool:\n        \"\"\"Is this line a class definition?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == \"class\"\n        )", "is_method": true, "class_name": "Line", "function_description": "Determines whether the line represents a Python class declaration by checking its initial token. Useful for parsing or analyzing code structure to identify class definitions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_stub_class", "line_number": 1498, "body": "def is_stub_class(self) -> bool:\n        \"\"\"Is this line a class definition with a body consisting only of \"...\"?\"\"\"\n        return self.is_class and self.leaves[-3:] == [\n            Leaf(token.DOT, \".\") for _ in range(3)\n        ]", "is_method": true, "class_name": "Line", "function_description": "Method of the Line class that determines if the line defines a class whose body contains only an ellipsis (\"...\"). Useful for identifying stub or placeholder class definitions in code analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_def", "line_number": 1505, "body": "def is_def(self) -> bool:\n        \"\"\"Is this a function definition? (Also returns True for async defs.)\"\"\"\n        try:\n            first_leaf = self.leaves[0]\n        except IndexError:\n            return False\n\n        try:\n            second_leaf: Optional[Leaf] = self.leaves[1]\n        except IndexError:\n            second_leaf = None\n        return (first_leaf.type == token.NAME and first_leaf.value == \"def\") or (\n            first_leaf.type == token.ASYNC\n            and second_leaf is not None\n            and second_leaf.type == token.NAME\n            and second_leaf.value == \"def\"\n        )", "is_method": true, "class_name": "Line", "function_description": "Method of the Line class that determines whether the line represents a function definition, including async functions. It enables code parsing utilities to identify function declaration lines."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_class_paren_empty", "line_number": 1524, "body": "def is_class_paren_empty(self) -> bool:\n        \"\"\"Is this a class with no base classes but using parentheses?\n\n        Those are unnecessary and should be removed.\n        \"\"\"\n        return (\n            bool(self)\n            and len(self.leaves) == 4\n            and self.is_class\n            and self.leaves[2].type == token.LPAR\n            and self.leaves[2].value == \"(\"\n            and self.leaves[3].type == token.RPAR\n            and self.leaves[3].value == \")\"\n        )", "is_method": true, "class_name": "Line", "function_description": "Utility method of the Line class that detects if a class declaration includes unnecessary empty parentheses, helping to identify and potentially clean up redundant base class syntax."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_triple_quoted_string", "line_number": 1540, "body": "def is_triple_quoted_string(self) -> bool:\n        \"\"\"Is the line a triple quoted string?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.STRING\n            and self.leaves[0].value.startswith(('\"\"\"', \"'''\"))\n        )", "is_method": true, "class_name": "Line", "function_description": "Utility method of the Line class that determines if the line represents a triple quoted string literal, supporting parsing or analysis tasks involving multiline strings."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "contains_standalone_comments", "line_number": 1548, "body": "def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:\n        \"\"\"If so, needs to be split before emitting.\"\"\"\n        for leaf in self.leaves:\n            if leaf.type == STANDALONE_COMMENT and leaf.bracket_depth <= depth_limit:\n                return True\n\n        return False", "is_method": true, "class_name": "Line", "function_description": "Utility method in the Line class that checks if it contains any standalone comments within a specified bracket depth, indicating whether the line needs splitting before further processing or emission."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "contains_uncollapsable_type_comments", "line_number": 1556, "body": "def contains_uncollapsable_type_comments(self) -> bool:\n        ignored_ids = set()\n        try:\n            last_leaf = self.leaves[-1]\n            ignored_ids.add(id(last_leaf))\n            if last_leaf.type == token.COMMA or (\n                last_leaf.type == token.RPAR and not last_leaf.value\n            ):\n                # When trailing commas or optional parens are inserted by Black for\n                # consistency, comments after the previous last element are not moved\n                # (they don't have to, rendering will still be correct).  So we ignore\n                # trailing commas and invisible.\n                last_leaf = self.leaves[-2]\n                ignored_ids.add(id(last_leaf))\n        except IndexError:\n            return False\n\n        # A type comment is uncollapsable if it is attached to a leaf\n        # that isn't at the end of the line (since that could cause it\n        # to get associated to a different argument) or if there are\n        # comments before it (since that could cause it to get hidden\n        # behind a comment.\n        comment_seen = False\n        for leaf_id, comments in self.comments.items():\n            for comment in comments:\n                if is_type_comment(comment):\n                    if comment_seen or (\n                        not is_type_comment(comment, \" ignore\")\n                        and leaf_id not in ignored_ids\n                    ):\n                        return True\n\n                comment_seen = True\n\n        return False", "is_method": true, "class_name": "Line", "function_description": "Determines if the line contains type comments that cannot be safely repositioned without affecting code meaning, helping ensure correct handling of inline type annotations during code formatting or transformations."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "contains_unsplittable_type_ignore", "line_number": 1592, "body": "def contains_unsplittable_type_ignore(self) -> bool:\n        if not self.leaves:\n            return False\n\n        # If a 'type: ignore' is attached to the end of a line, we\n        # can't split the line, because we can't know which of the\n        # subexpressions the ignore was meant to apply to.\n        #\n        # We only want this to apply to actual physical lines from the\n        # original source, though: we don't want the presence of a\n        # 'type: ignore' at the end of a multiline expression to\n        # justify pushing it all onto one line. Thus we\n        # (unfortunately) need to check the actual source lines and\n        # only report an unsplittable 'type: ignore' if this line was\n        # one line in the original code.\n\n        # Grab the first and last line numbers, skipping generated leaves\n        first_line = next((leaf.lineno for leaf in self.leaves if leaf.lineno != 0), 0)\n        last_line = next(\n            (leaf.lineno for leaf in reversed(self.leaves) if leaf.lineno != 0), 0\n        )\n\n        if first_line == last_line:\n            # We look at the last two leaves since a comma or an\n            # invisible paren could have been added at the end of the\n            # line.\n            for node in self.leaves[-2:]:\n                for comment in self.comments.get(id(node), []):\n                    if is_type_comment(comment, \" ignore\"):\n                        return True\n\n        return False", "is_method": true, "class_name": "Line", "function_description": "Determines if a single-line code segment contains an unsplittable 'type: ignore' comment at its end, preventing line splitting. This helps maintain original source code structure during formatting or analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "contains_multiline_strings", "line_number": 1625, "body": "def contains_multiline_strings(self) -> bool:\n        return any(is_multiline_string(leaf) for leaf in self.leaves)", "is_method": true, "class_name": "Line", "function_description": "Determines if the Line instance contains any string elements spanning multiple lines. Useful for identifying multiline string constructs within a line's parsed components."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "maybe_should_explode", "line_number": 1628, "body": "def maybe_should_explode(self, closing: Leaf) -> bool:\n        \"\"\"Return True if this line should explode (always be split), that is when:\n        - there's a trailing comma here; and\n        - it's not a one-tuple.\n        \"\"\"\n        if not (\n            closing.type in CLOSING_BRACKETS\n            and self.leaves\n            and self.leaves[-1].type == token.COMMA\n        ):\n            return False\n\n        if closing.type in {token.RBRACE, token.RSQB}:\n            return True\n\n        if self.is_import:\n            return True\n\n        if not is_one_tuple_between(closing.opening_bracket, closing, self.leaves):\n            return True\n\n        return False", "is_method": true, "class_name": "Line", "function_description": "Determines whether a line containing a closing bracket and trailing comma should always be split (exploded), such as in multi-item collections or imports, but not in single-element tuples. Useful for formatting code readability and style enforcement."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "append_comment", "line_number": 1651, "body": "def append_comment(self, comment: Leaf) -> bool:\n        \"\"\"Add an inline or standalone comment to the line.\"\"\"\n        if (\n            comment.type == STANDALONE_COMMENT\n            and self.bracket_tracker.any_open_brackets()\n        ):\n            comment.prefix = \"\"\n            return False\n\n        if comment.type != token.COMMENT:\n            return False\n\n        if not self.leaves:\n            comment.type = STANDALONE_COMMENT\n            comment.prefix = \"\"\n            return False\n\n        last_leaf = self.leaves[-1]\n        if (\n            last_leaf.type == token.RPAR\n            and not last_leaf.value\n            and last_leaf.parent\n            and len(list(last_leaf.parent.leaves())) <= 3\n            and not is_type_comment(comment)\n        ):\n            # Comments on an optional parens wrapping a single leaf should belong to\n            # the wrapped node except if it's a type comment. Pinning the comment like\n            # this avoids unstable formatting caused by comment migration.\n            if len(self.leaves) < 2:\n                comment.type = STANDALONE_COMMENT\n                comment.prefix = \"\"\n                return False\n\n            last_leaf = self.leaves[-2]\n        self.comments.setdefault(id(last_leaf), []).append(comment)\n        return True", "is_method": true, "class_name": "Line", "function_description": "Method of the Line class that attempts to attach an inline or standalone comment to the line, ensuring comments are appropriately associated and formatted based on line structure and bracket context."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "comments_after", "line_number": 1688, "body": "def comments_after(self, leaf: Leaf) -> List[Leaf]:\n        \"\"\"Generate comments that should appear directly after `leaf`.\"\"\"\n        return self.comments.get(id(leaf), [])", "is_method": true, "class_name": "Line", "function_description": "Provides the comments associated to appear immediately after a given leaf node in the Line class, supporting comment retrieval for specific elements in a structured text or code representation."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "remove_trailing_comma", "line_number": 1692, "body": "def remove_trailing_comma(self) -> None:\n        \"\"\"Remove the trailing comma and moves the comments attached to it.\"\"\"\n        trailing_comma = self.leaves.pop()\n        trailing_comma_comments = self.comments.pop(id(trailing_comma), [])\n        self.comments.setdefault(id(self.leaves[-1]), []).extend(\n            trailing_comma_comments\n        )", "is_method": true, "class_name": "Line", "function_description": "Utility method of the Line class that removes a trailing comma from its elements and transfers any associated comments to the preceding element. This maintains comment placement consistency after comma removal."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "is_complex_subscript", "line_number": 1700, "body": "def is_complex_subscript(self, leaf: Leaf) -> bool:\n        \"\"\"Return True iff `leaf` is part of a slice with non-trivial exprs.\"\"\"\n        open_lsqb = self.bracket_tracker.get_open_lsqb()\n        if open_lsqb is None:\n            return False\n\n        subscript_start = open_lsqb.next_sibling\n\n        if isinstance(subscript_start, Node):\n            if subscript_start.type == syms.listmaker:\n                return False\n\n            if subscript_start.type == syms.subscriptlist:\n                subscript_start = child_towards(subscript_start, leaf)\n        return subscript_start is not None and any(\n            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()\n        )", "is_method": true, "class_name": "Line", "function_description": "Determines if a given leaf node is part of a complex slice expression within a line, helping to identify non-trivial subscript structures potentially relevant for syntax analysis or code formatting."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "clone", "line_number": 1718, "body": "def clone(self) -> \"Line\":\n        return Line(\n            depth=self.depth,\n            inside_brackets=self.inside_brackets,\n            should_explode=self.should_explode,\n        )", "is_method": true, "class_name": "Line", "function_description": "Creates and returns a new Line object that duplicates the current line's key attributes, supporting operations requiring an independent copy of a Line instance."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__str__", "line_number": 1725, "body": "def __str__(self) -> str:\n        \"\"\"Render the line.\"\"\"\n        if not self:\n            return \"\\n\"\n\n        indent = \"    \" * self.depth\n        leaves = iter(self.leaves)\n        first = next(leaves)\n        res = f\"{first.prefix}{indent}{first.value}\"\n        for leaf in leaves:\n            res += str(leaf)\n        for comment in itertools.chain.from_iterable(self.comments.values()):\n            res += str(comment)\n\n        return res + \"\\n\"", "is_method": true, "class_name": "Line", "function_description": "Provides a string representation of the Line object, rendering its content with appropriate indentation, prefixes, nested leaves, and comments, suitable for textual display or serialization."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__bool__", "line_number": 1741, "body": "def __bool__(self) -> bool:\n        \"\"\"Return True if the line has leaves or comments.\"\"\"\n        return bool(self.leaves or self.comments)", "is_method": true, "class_name": "Line", "function_description": "Returns True if the Line contains any leaves or comments, indicating it has meaningful content or annotations. This enables easy truth-value testing of Line objects based on their content presence."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "maybe_empty_lines", "line_number": 1761, "body": "def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        \"\"\"Return the number of extra empty lines before and after the `current_line`.\n\n        This is for separating `def`, `async def` and `class` with extra empty\n        lines (two on module-level).\n        \"\"\"\n        before, after = self._maybe_empty_lines(current_line)\n        before = (\n            # Black should not insert empty lines at the beginning\n            # of the file\n            0\n            if self.previous_line is None\n            else before - self.previous_after\n        )\n        self.previous_after = after\n        self.previous_line = current_line\n        return before, after", "is_method": true, "class_name": "EmptyLineTracker", "function_description": "Determines how many extra empty lines should surround a given line to properly space definitions or classes, adapting spacing based on position and previous lines to ensure consistent formatting."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_maybe_empty_lines", "line_number": 1779, "body": "def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        max_allowed = 1\n        if current_line.depth == 0:\n            max_allowed = 1 if self.is_pyi else 2\n        if current_line.leaves:\n            # Consume the first leaf's extra newlines.\n            first_leaf = current_line.leaves[0]\n            before = first_leaf.prefix.count(\"\\n\")\n            before = min(before, max_allowed)\n            first_leaf.prefix = \"\"\n        else:\n            before = 0\n        depth = current_line.depth\n        while self.previous_defs and self.previous_defs[-1] >= depth:\n            self.previous_defs.pop()\n            if self.is_pyi:\n                before = 0 if depth else 1\n            else:\n                before = 1 if depth else 2\n        if current_line.is_decorator or current_line.is_def or current_line.is_class:\n            return self._maybe_empty_lines_for_class_or_def(current_line, before)\n\n        if (\n            self.previous_line\n            and self.previous_line.is_import\n            and not current_line.is_import\n            and depth == self.previous_line.depth\n        ):\n            return (before or 1), 0\n\n        if (\n            self.previous_line\n            and self.previous_line.is_class\n            and current_line.is_triple_quoted_string\n        ):\n            return before, 1\n\n        return before, 0", "is_method": true, "class_name": "EmptyLineTracker", "function_description": "Utility method in EmptyLineTracker that determines the number of empty lines to insert before and after a given code line, adapting formatting based on contextual attributes like line depth, type, and previous lines for consistent source code style."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_maybe_empty_lines_for_class_or_def", "line_number": 1818, "body": "def _maybe_empty_lines_for_class_or_def(\n        self, current_line: Line, before: int\n    ) -> Tuple[int, int]:\n        if not current_line.is_decorator:\n            self.previous_defs.append(current_line.depth)\n        if self.previous_line is None:\n            # Don't insert empty lines before the first line in the file.\n            return 0, 0\n\n        if self.previous_line.is_decorator:\n            return 0, 0\n\n        if self.previous_line.depth < current_line.depth and (\n            self.previous_line.is_class or self.previous_line.is_def\n        ):\n            return 0, 0\n\n        if (\n            self.previous_line.is_comment\n            and self.previous_line.depth == current_line.depth\n            and before == 0\n        ):\n            return 0, 0\n\n        if self.is_pyi:\n            if self.previous_line.depth > current_line.depth:\n                newlines = 1\n            elif current_line.is_class or self.previous_line.is_class:\n                if current_line.is_stub_class and self.previous_line.is_stub_class:\n                    # No blank line between classes with an empty body\n                    newlines = 0\n                else:\n                    newlines = 1\n            elif current_line.is_def and not self.previous_line.is_def:\n                # Blank line between a block of functions and a block of non-functions\n                newlines = 1\n            else:\n                newlines = 0\n        else:\n            newlines = 2\n        if current_line.depth and newlines:\n            newlines -= 1\n        return newlines, 0", "is_method": true, "class_name": "EmptyLineTracker", "function_description": "Utility method in EmptyLineTracker that determines the appropriate number of empty lines to insert before a class or function definition, supporting code formatting rules including handling decorators, comments, and stub files."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "line", "line_number": 1876, "body": "def line(self, indent: int = 0) -> Iterator[Line]:\n        \"\"\"Generate a line.\n\n        If the line is empty, only emit if it makes sense.\n        If the line is too long, split it first and then generate.\n\n        If any lines were generated, set up a new current_line.\n        \"\"\"\n        if not self.current_line:\n            self.current_line.depth += indent\n            return  # Line is empty, don't emit. Creating a new one unnecessary.\n\n        complete_line = self.current_line\n        self.current_line = Line(depth=complete_line.depth + indent)\n        yield complete_line", "is_method": true, "class_name": "LineGenerator", "function_description": "Generates and yields the current line with optional indentation, handling empty lines and ensuring long lines are properly split. Useful for producing formatted lines sequentially within a line-generation context."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_default", "line_number": 1892, "body": "def visit_default(self, node: LN) -> Iterator[Line]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Leaf):\n            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()\n            for comment in generate_comments(node):\n                if any_open_brackets:\n                    # any comment within brackets is subject to splitting\n                    self.current_line.append(comment)\n                elif comment.type == token.COMMENT:\n                    # regular trailing comment\n                    self.current_line.append(comment)\n                    yield from self.line()\n\n                else:\n                    # regular standalone comment\n                    yield from self.line()\n\n                    self.current_line.append(comment)\n                    yield from self.line()\n\n            normalize_prefix(node, inside_brackets=any_open_brackets)\n            if self.normalize_strings and node.type == token.STRING:\n                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)\n                normalize_string_quotes(node)\n            if node.type == token.NUMBER:\n                normalize_numeric_literal(node)\n            if node.type not in WHITESPACE:\n                self.current_line.append(node)\n        yield from super().visit_default(node)", "is_method": true, "class_name": "LineGenerator", "function_description": "Processes a syntax tree node to generate formatted lines of code, handling comments, string and numeric normalization, and bracket contexts. It serves as a default visitor method to produce properly formatted code lines during tree traversal."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_INDENT", "line_number": 1922, "body": "def visit_INDENT(self, node: Leaf) -> Iterator[Line]:\n        \"\"\"Increase indentation level, maybe yield a line.\"\"\"\n        # In blib2to3 INDENT never holds comments.\n        yield from self.line(+1)\n        yield from self.visit_default(node)", "is_method": true, "class_name": "LineGenerator", "function_description": "Helper method in LineGenerator that increases indentation level and yields lines accordingly during syntax tree traversal."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_DEDENT", "line_number": 1928, "body": "def visit_DEDENT(self, node: Leaf) -> Iterator[Line]:\n        \"\"\"Decrease indentation level, maybe yield a line.\"\"\"\n        # The current line might still wait for trailing comments.  At DEDENT time\n        # there won't be any (they would be prefixes on the preceding NEWLINE).\n        # Emit the line then.\n        yield from self.line()\n\n        # While DEDENT has no value, its prefix may contain standalone comments\n        # that belong to the current indentation level.  Get 'em.\n        yield from self.visit_default(node)\n\n        # Finally, emit the dedent.\n        yield from self.line(-1)", "is_method": true, "class_name": "LineGenerator", "function_description": "Method of LineGenerator that handles a dedentation token by yielding appropriate lines, including any trailing comments and updating the indentation level during code formatting or parsing."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_stmt", "line_number": 1942, "body": "def visit_stmt(\n        self, node: Node, keywords: Set[str], parens: Set[str]\n    ) -> Iterator[Line]:\n        \"\"\"Visit a statement.\n\n        This implementation is shared for `if`, `while`, `for`, `try`, `except`,\n        `def`, `with`, `class`, `assert` and assignments.\n\n        The relevant Python language `keywords` for a given statement will be\n        NAME leaves within it. This methods puts those on a separate line.\n\n        `parens` holds a set of string leaf values immediately after which\n        invisible parens should be put.\n        \"\"\"\n        normalize_invisible_parens(node, parens_after=parens)\n        for child in node.children:\n            if child.type == token.NAME and child.value in keywords:  # type: ignore\n                yield from self.line()\n\n            yield from self.visit(child)", "is_method": true, "class_name": "LineGenerator", "function_description": "Utility method of the LineGenerator class that processes various Python statements, separating specified keywords onto new lines and managing invisible parentheses placement to aid in structured code line generation."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_suite", "line_number": 1963, "body": "def visit_suite(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit a suite.\"\"\"\n        if self.is_pyi and is_stub_suite(node):\n            yield from self.visit(node.children[2])\n        else:\n            yield from self.visit_default(node)", "is_method": true, "class_name": "LineGenerator", "function_description": "Produces lines by visiting a suite node, handling stub suites specially if in a stub file context; otherwise, it processes the node with the default visit method. Useful for generating code lines based on syntax tree suites."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_simple_stmt", "line_number": 1970, "body": "def visit_simple_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit a statement without nested statements.\"\"\"\n        is_suite_like = node.parent and node.parent.type in STATEMENT\n        if is_suite_like:\n            if self.is_pyi and is_stub_body(node):\n                yield from self.visit_default(node)\n            else:\n                yield from self.line(+1)\n                yield from self.visit_default(node)\n                yield from self.line(-1)\n\n        else:\n            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):\n                yield from self.line()\n            yield from self.visit_default(node)", "is_method": true, "class_name": "LineGenerator", "function_description": "Method of the LineGenerator class that produces formatted lines for simple statements, managing indentation levels based on statement context and special file or stub handling. It supports generating properly indented code fragments for code generation or formatting tasks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_async_stmt", "line_number": 1986, "body": "def visit_async_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit `async def`, `async for`, `async with`.\"\"\"\n        yield from self.line()\n\n        children = iter(node.children)\n        for child in children:\n            yield from self.visit(child)\n\n            if child.type == token.ASYNC:\n                break\n\n        internal_stmt = next(children)\n        for child in internal_stmt.children:\n            yield from self.visit(child)", "is_method": true, "class_name": "LineGenerator", "function_description": "Generates lines representing asynchronous statements by traversing and yielding their components line by line. Enables structured processing of async constructs for code analysis or transformation."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_decorators", "line_number": 2001, "body": "def visit_decorators(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit decorators.\"\"\"\n        for child in node.children:\n            yield from self.line()\n            yield from self.visit(child)", "is_method": true, "class_name": "LineGenerator", "function_description": "Utility method of the LineGenerator class that iterates over a node\u2019s decorators, yielding generated lines and recursively processing each decorator node for code generation or transformation purposes."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_SEMI", "line_number": 2007, "body": "def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Remove a semicolon and put the other statement on a separate line.\"\"\"\n        yield from self.line()", "is_method": true, "class_name": "LineGenerator", "function_description": "Method of the LineGenerator class that splits statements separated by semicolons by removing the semicolon and yielding the subsequent statement on a new line."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_ENDMARKER", "line_number": 2011, "body": "def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"End of file. Process outstanding comments and end with a newline.\"\"\"\n        yield from self.visit_default(leaf)\n        yield from self.line()", "is_method": true, "class_name": "LineGenerator", "function_description": "Handles the end of a file by processing any remaining comments and yielding a final newline line, supporting proper termination of line generation in the LineGenerator class."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_STANDALONE_COMMENT", "line_number": 2016, "body": "def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:\n        if not self.current_line.bracket_tracker.any_open_brackets():\n            yield from self.line()\n        yield from self.visit_default(leaf)", "is_method": true, "class_name": "LineGenerator", "function_description": "This method handles standalone comment leaves by yielding the current line if no brackets are open, then processes the comment normally. It ensures correct line generation behavior around standalone comments in parsing or code formatting workflows."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_factor", "line_number": 2021, "body": "def visit_factor(self, node: Node) -> Iterator[Line]:\n        \"\"\"Force parentheses between a unary op and a binary power:\n\n        -2 ** 8 -> -(2 ** 8)\n        \"\"\"\n        _operator, operand = node.children\n        if (\n            operand.type == syms.power\n            and len(operand.children) == 3\n            and operand.children[1].type == token.DOUBLESTAR\n        ):\n            lpar = Leaf(token.LPAR, \"(\")\n            rpar = Leaf(token.RPAR, \")\")\n            index = operand.remove() or 0\n            node.insert_child(index, Node(syms.atom, [lpar, operand, rpar]))\n        yield from self.visit_default(node)", "is_method": true, "class_name": "LineGenerator", "function_description": "Ensures correct grouping by inserting parentheses between a unary operator and a binary power expression, preserving intended evaluation order in generated code lines. This supports accurate syntactic formatting during code generation."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "visit_STRING", "line_number": 2038, "body": "def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n        if is_docstring(leaf) and \"\\\\\\n\" not in leaf.value:\n            # We're ignoring docstrings with backslash newline escapes because changing\n            # indentation of those changes the AST representation of the code.\n            prefix = get_string_prefix(leaf.value)\n            lead_len = len(prefix) + 3\n            tail_len = -3\n            indent = \" \" * 4 * self.current_line.depth\n            docstring = fix_docstring(leaf.value[lead_len:tail_len], indent)\n            if docstring:\n                if leaf.value[lead_len - 1] == docstring[0]:\n                    docstring = \" \" + docstring\n                if leaf.value[tail_len + 1] == docstring[-1]:\n                    docstring = docstring + \" \"\n            leaf.value = leaf.value[0:lead_len] + docstring + leaf.value[tail_len:]\n            normalize_string_quotes(leaf)\n\n        yield from self.visit_default(leaf)", "is_method": true, "class_name": "LineGenerator", "function_description": "Processes and reformats docstring nodes to adjust indentation consistently within code lines, while preserving original string formatting. It enables proper handling of docstring indentation for code generation or formatting tasks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__post_init__", "line_number": 2057, "body": "def __post_init__(self) -> None:\n        \"\"\"You are in a twisty little maze of passages.\"\"\"\n        v = self.visit_stmt\n        \u00d8: Set[str] = set()\n        self.visit_assert_stmt = partial(v, keywords={\"assert\"}, parens={\"assert\", \",\"})\n        self.visit_if_stmt = partial(\n            v, keywords={\"if\", \"else\", \"elif\"}, parens={\"if\", \"elif\"}\n        )\n        self.visit_while_stmt = partial(v, keywords={\"while\", \"else\"}, parens={\"while\"})\n        self.visit_for_stmt = partial(v, keywords={\"for\", \"else\"}, parens={\"for\", \"in\"})\n        self.visit_try_stmt = partial(\n            v, keywords={\"try\", \"except\", \"else\", \"finally\"}, parens=\u00d8\n        )\n        self.visit_except_clause = partial(v, keywords={\"except\"}, parens=\u00d8)\n        self.visit_with_stmt = partial(v, keywords={\"with\"}, parens=\u00d8)\n        self.visit_funcdef = partial(v, keywords={\"def\"}, parens=\u00d8)\n        self.visit_classdef = partial(v, keywords={\"class\"}, parens=\u00d8)\n        self.visit_expr_stmt = partial(v, keywords=\u00d8, parens=ASSIGNMENTS)\n        self.visit_return_stmt = partial(v, keywords={\"return\"}, parens={\"return\"})\n        self.visit_import_from = partial(v, keywords=\u00d8, parens={\"import\"})\n        self.visit_del_stmt = partial(v, keywords=\u00d8, parens={\"del\"})\n        self.visit_async_funcdef = self.visit_async_stmt\n        self.visit_decorated = self.visit_decorators", "is_method": true, "class_name": "LineGenerator", "function_description": "Initializes specialized statement visitor methods by partially applying a common visitor function with relevant keywords and parentheses sets to streamline parsing various Python statement types within the LineGenerator class."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "init_st", "line_number": 2613, "body": "def init_st(ST: Type[StringTransformer]) -> StringTransformer:\n        \"\"\"Initialize StringTransformer\"\"\"\n        return ST(mode.line_length, mode.string_normalization)", "is_method": false, "function_description": "Initializes and returns an instance of the given StringTransformer class using the current mode's line length and string normalization settings."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "do_match", "line_number": 2742, "body": "def do_match(self, line: Line) -> TMatchResult:\n        \"\"\"\n        Returns:\n            * Ok(string_idx) such that `line.leaves[string_idx]` is our target\n            string, if a match was able to be made.\n                OR\n            * Err(CannotTransform), if a match was not able to be made.\n        \"\"\"", "is_method": true, "class_name": "StringTransformer", "function_description": "Core method of StringTransformer that attempts to locate the target string within a line's tokenized leaves, returning a successful match index or an error if no suitable match is found."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "do_transform", "line_number": 2752, "body": "def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:\n        \"\"\"\n        Yields:\n            * Ok(new_line) where new_line is the new transformed line.\n                OR\n            * Err(CannotTransform) if the transformation failed for some reason. The\n            `do_match(...)` template method should usually be used to reject\n            the form of the given Line, but in some cases it is difficult to\n            know whether or not a Line meets the StringTransformer's\n            requirements until the transformation is already midway.\n\n        Side Effects:\n            This method should NOT mutate @line directly, but it MAY mutate the\n            Line's underlying Node structure. (WARNING: If the underlying Node\n            structure IS altered, then this method should NOT be allowed to\n            yield an CannotTransform after that point.)\n        \"\"\"", "is_method": true, "class_name": "StringTransformer", "function_description": "Provides a transformation service that attempts to convert an input line into a new form, yielding success or failure results while ensuring safe mutation of the line's underlying structure during processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__call__", "line_number": 2770, "body": "def __call__(self, line: Line, _features: Collection[Feature]) -> Iterator[Line]:\n        \"\"\"\n        StringTransformer instances have a call signature that mirrors that of\n        the Transformer type.\n\n        Raises:\n            CannotTransform(...) if the concrete StringTransformer class is unable\n            to transform @line.\n        \"\"\"\n        # Optimization to avoid calling `self.do_match(...)` when the line does\n        # not contain any string.\n        if not any(leaf.type == token.STRING for leaf in line.leaves):\n            raise CannotTransform(\"There are no strings in this line.\")\n\n        match_result = self.do_match(line)\n\n        if isinstance(match_result, Err):\n            cant_transform = match_result.err()\n            raise CannotTransform(\n                f\"The string transformer {self.__class__.__name__} does not recognize\"\n                \" this line as one that it can transform.\"\n            ) from cant_transform\n\n        string_idx = match_result.ok()\n\n        for line_result in self.do_transform(line, string_idx):\n            if isinstance(line_result, Err):\n                cant_transform = line_result.err()\n                raise CannotTransform(\n                    \"StringTransformer failed while attempting to transform string.\"\n                ) from cant_transform\n            line = line_result.ok()\n            yield line", "is_method": true, "class_name": "StringTransformer", "function_description": "Core method of StringTransformer that applies string-specific transformations to lines containing string tokens, yielding transformed lines or raising errors if transformation is not possible. It supports safe, iterable processing of text line transformations."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_get_key", "line_number": 2842, "body": "def _get_key(string: str) -> \"CustomSplitMapMixin._Key\":\n        \"\"\"\n        Returns:\n            A unique identifier that is used internally to map @string to a\n            group of custom splits.\n        \"\"\"\n        return (id(string), string)", "is_method": true, "class_name": "CustomSplitMapMixin", "function_description": "Internal utility method of CustomSplitMapMixin that generates a unique identifier for a given string to map it to corresponding custom split groups within the class."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "add_custom_splits", "line_number": 2850, "body": "def add_custom_splits(\n        self, string: str, custom_splits: Iterable[CustomSplit]\n    ) -> None:\n        \"\"\"Custom Split Map Setter Method\n\n        Side Effects:\n            Adds a mapping from @string to the custom splits @custom_splits.\n        \"\"\"\n        key = self._get_key(string)\n        self._CUSTOM_SPLIT_MAP[key] = tuple(custom_splits)", "is_method": true, "class_name": "CustomSplitMapMixin", "function_description": "Method of CustomSplitMapMixin that maps a given string to a specified sequence of custom splits, enabling customized splitting behavior for that string within the mixin's context."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "pop_custom_splits", "line_number": 2861, "body": "def pop_custom_splits(self, string: str) -> List[CustomSplit]:\n        \"\"\"Custom Split Map Getter Method\n\n        Returns:\n            * A list of the custom splits that are mapped to @string, if any\n            exist.\n                OR\n            * [], otherwise.\n\n        Side Effects:\n            Deletes the mapping between @string and its associated custom\n            splits (which are returned to the caller).\n        \"\"\"\n        key = self._get_key(string)\n\n        custom_splits = self._CUSTOM_SPLIT_MAP[key]\n        del self._CUSTOM_SPLIT_MAP[key]\n\n        return list(custom_splits)", "is_method": true, "class_name": "CustomSplitMapMixin", "function_description": "Method of CustomSplitMapMixin that retrieves and removes the list of custom splits associated with a given string, enabling one-time access and cleanup of those mappings."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "has_custom_splits", "line_number": 2881, "body": "def has_custom_splits(self, string: str) -> bool:\n        \"\"\"\n        Returns:\n            True iff @string is associated with a set of custom splits.\n        \"\"\"\n        key = self._get_key(string)\n        return key in self._CUSTOM_SPLIT_MAP", "is_method": true, "class_name": "CustomSplitMapMixin", "function_description": "Checks if a given string has predefined custom split configurations available, enabling conditional processing based on these custom splits."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "do_match", "line_number": 2913, "body": "def do_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        for (i, leaf) in enumerate(LL):\n            if (\n                leaf.type == token.STRING\n                and is_valid_index(i + 1)\n                and LL[i + 1].type == token.STRING\n            ):\n                return Ok(i)\n\n            if leaf.type == token.STRING and \"\\\\\\n\" in leaf.value:\n                return Ok(i)\n\n        return TErr(\"This line has no strings that need merging.\")", "is_method": true, "class_name": "StringMerger", "function_description": "Checks a line's tokens to identify if adjacent or line-continuing string tokens exist, indicating strings that require merging. This enables preprocessing steps in StringMerger to combine split or consecutive string literals efficiently."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "do_transform", "line_number": 2931, "body": "def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:\n        new_line = line\n        rblc_result = self.__remove_backslash_line_continuation_chars(\n            new_line, string_idx\n        )\n        if isinstance(rblc_result, Ok):\n            new_line = rblc_result.ok()\n\n        msg_result = self.__merge_string_group(new_line, string_idx)\n        if isinstance(msg_result, Ok):\n            new_line = msg_result.ok()\n\n        if isinstance(rblc_result, Err) and isinstance(msg_result, Err):\n            msg_cant_transform = msg_result.err()\n            rblc_cant_transform = rblc_result.err()\n            cant_transform = CannotTransform(\n                \"StringMerger failed to merge any strings in this line.\"\n            )\n\n            # Chain the errors together using `__cause__`.\n            msg_cant_transform.__cause__ = rblc_cant_transform\n            cant_transform.__cause__ = msg_cant_transform\n\n            yield Err(cant_transform)\n        else:\n            yield Ok(new_line)", "is_method": true, "class_name": "StringMerger", "function_description": "Core method of the StringMerger class that attempts to transform a line by removing backslash continuations and merging string groups, yielding either the transformed line or detailed errors if both steps fail."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__remove_backslash_line_continuation_chars", "line_number": 2959, "body": "def __remove_backslash_line_continuation_chars(\n        line: Line, string_idx: int\n    ) -> TResult[Line]:\n        \"\"\"\n        Merge strings that were split across multiple lines using\n        line-continuation backslashes.\n\n        Returns:\n            Ok(new_line), if @line contains backslash line-continuation\n            characters.\n                OR\n            Err(CannotTransform), otherwise.\n        \"\"\"\n        LL = line.leaves\n\n        string_leaf = LL[string_idx]\n        if not (\n            string_leaf.type == token.STRING\n            and \"\\\\\\n\" in string_leaf.value\n            and not has_triple_quotes(string_leaf.value)\n        ):\n            return TErr(\n                f\"String leaf {string_leaf} does not contain any backslash line\"\n                \" continuation characters.\"\n            )\n\n        new_line = line.clone()\n        new_line.comments = line.comments.copy()\n        append_leaves(new_line, line, LL)\n\n        new_string_leaf = new_line.leaves[string_idx]\n        new_string_leaf.value = new_string_leaf.value.replace(\"\\\\\\n\", \"\")\n\n        return Ok(new_line)", "is_method": true, "class_name": "StringMerger", "function_description": "Utility method of StringMerger that detects and removes backslash line-continuation characters from a string token within a line, merging split multi-line strings into a single continuous string."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__merge_string_group", "line_number": 2994, "body": "def __merge_string_group(self, line: Line, string_idx: int) -> TResult[Line]:\n        \"\"\"\n        Merges string group (i.e. set of adjacent strings) where the first\n        string in the group is `line.leaves[string_idx]`.\n\n        Returns:\n            Ok(new_line), if ALL of the validation checks found in\n            __validate_msg(...) pass.\n                OR\n            Err(CannotTransform), otherwise.\n        \"\"\"\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        vresult = self.__validate_msg(line, string_idx)\n        if isinstance(vresult, Err):\n            return vresult\n\n        # If the string group is wrapped inside an Atom node, we must make sure\n        # to later replace that Atom with our new (merged) string leaf.\n        atom_node = LL[string_idx].parent\n\n        # We will place BREAK_MARK in between every two substrings that we\n        # merge. We will then later go through our final result and use the\n        # various instances of BREAK_MARK we find to add the right values to\n        # the custom split map.\n        BREAK_MARK = \"@@@@@ BLACK BREAKPOINT MARKER @@@@@\"\n\n        QUOTE = LL[string_idx].value[-1]\n\n        def make_naked(string: str, string_prefix: str) -> str:\n            \"\"\"Strip @string (i.e. make it a \"naked\" string)\n\n            Pre-conditions:\n                * assert_is_leaf_string(@string)\n\n            Returns:\n                A string that is identical to @string except that\n                @string_prefix has been stripped, the surrounding QUOTE\n                characters have been removed, and any remaining QUOTE\n                characters have been escaped.\n            \"\"\"\n            assert_is_leaf_string(string)\n\n            RE_EVEN_BACKSLASHES = r\"(?:(?<!\\\\)(?:\\\\\\\\)*)\"\n            naked_string = string[len(string_prefix) + 1 : -1]\n            naked_string = re.sub(\n                \"(\" + RE_EVEN_BACKSLASHES + \")\" + QUOTE, r\"\\1\\\\\" + QUOTE, naked_string\n            )\n            return naked_string\n\n        # Holds the CustomSplit objects that will later be added to the custom\n        # split map.\n        custom_splits = []\n\n        # Temporary storage for the 'has_prefix' part of the CustomSplit objects.\n        prefix_tracker = []\n\n        # Sets the 'prefix' variable. This is the prefix that the final merged\n        # string will have.\n        next_str_idx = string_idx\n        prefix = \"\"\n        while (\n            not prefix\n            and is_valid_index(next_str_idx)\n            and LL[next_str_idx].type == token.STRING\n        ):\n            prefix = get_string_prefix(LL[next_str_idx].value)\n            next_str_idx += 1\n\n        # The next loop merges the string group. The final string will be\n        # contained in 'S'.\n        #\n        # The following convenience variables are used:\n        #\n        #   S: string\n        #   NS: naked string\n        #   SS: next string\n        #   NSS: naked next string\n        S = \"\"\n        NS = \"\"\n        num_of_strings = 0\n        next_str_idx = string_idx\n        while is_valid_index(next_str_idx) and LL[next_str_idx].type == token.STRING:\n            num_of_strings += 1\n\n            SS = LL[next_str_idx].value\n            next_prefix = get_string_prefix(SS)\n\n            # If this is an f-string group but this substring is not prefixed\n            # with 'f'...\n            if \"f\" in prefix and \"f\" not in next_prefix:\n                # Then we must escape any braces contained in this substring.\n                SS = re.subf(r\"(\\{|\\})\", \"{1}{1}\", SS)\n\n            NSS = make_naked(SS, next_prefix)\n\n            has_prefix = bool(next_prefix)\n            prefix_tracker.append(has_prefix)\n\n            S = prefix + QUOTE + NS + NSS + BREAK_MARK + QUOTE\n            NS = make_naked(S, prefix)\n\n            next_str_idx += 1\n\n        S_leaf = Leaf(token.STRING, S)\n        if self.normalize_strings:\n            normalize_string_quotes(S_leaf)\n\n        # Fill the 'custom_splits' list with the appropriate CustomSplit objects.\n        temp_string = S_leaf.value[len(prefix) + 1 : -1]\n        for has_prefix in prefix_tracker:\n            mark_idx = temp_string.find(BREAK_MARK)\n            assert (\n                mark_idx >= 0\n            ), \"Logic error while filling the custom string breakpoint cache.\"\n\n            temp_string = temp_string[mark_idx + len(BREAK_MARK) :]\n            breakpoint_idx = mark_idx + (len(prefix) if has_prefix else 0) + 1\n            custom_splits.append(CustomSplit(has_prefix, breakpoint_idx))\n\n        string_leaf = Leaf(token.STRING, S_leaf.value.replace(BREAK_MARK, \"\"))\n\n        if atom_node is not None:\n            replace_child(atom_node, string_leaf)\n\n        # Build the final line ('new_line') that this method will later return.\n        new_line = line.clone()\n        for (i, leaf) in enumerate(LL):\n            if i == string_idx:\n                new_line.append(string_leaf)\n\n            if string_idx <= i < string_idx + num_of_strings:\n                for comment_leaf in line.comments_after(LL[i]):\n                    new_line.append(comment_leaf, preformatted=True)\n                continue\n\n            append_leaves(new_line, line, [leaf])\n\n        self.add_custom_splits(string_leaf.value, custom_splits)\n        return Ok(new_line)", "is_method": true, "class_name": "StringMerger", "function_description": "Method of StringMerger that merges a group of adjacent string tokens starting at a specified index into a single normalized string leaf, preserving and tracking custom split points for later reference in the merged result."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__validate_msg", "line_number": 3138, "body": "def __validate_msg(line: Line, string_idx: int) -> TResult[None]:\n        \"\"\"Validate (M)erge (S)tring (G)roup\n\n        Transform-time string validation logic for __merge_string_group(...).\n\n        Returns:\n            * Ok(None), if ALL validation checks (listed below) pass.\n                OR\n            * Err(CannotTransform), if any of the following are true:\n                - The target string is not in a string group (i.e. it has no\n                  adjacent strings).\n                - The string group has more than one inline comment.\n                - The string group has an inline comment that appears to be a pragma.\n                - The set of all string prefixes in the string group is of\n                  length greater than one and is not equal to {\"\", \"f\"}.\n                - The string group consists of raw strings.\n        \"\"\"\n        num_of_inline_string_comments = 0\n        set_of_prefixes = set()\n        num_of_strings = 0\n        for leaf in line.leaves[string_idx:]:\n            if leaf.type != token.STRING:\n                # If the string group is trailed by a comma, we count the\n                # comments trailing the comma to be one of the string group's\n                # comments.\n                if leaf.type == token.COMMA and id(leaf) in line.comments:\n                    num_of_inline_string_comments += 1\n                break\n\n            if has_triple_quotes(leaf.value):\n                return TErr(\"StringMerger does NOT merge multiline strings.\")\n\n            num_of_strings += 1\n            prefix = get_string_prefix(leaf.value)\n            if \"r\" in prefix:\n                return TErr(\"StringMerger does NOT merge raw strings.\")\n\n            set_of_prefixes.add(prefix)\n\n            if id(leaf) in line.comments:\n                num_of_inline_string_comments += 1\n                if contains_pragma_comment(line.comments[id(leaf)]):\n                    return TErr(\"Cannot merge strings which have pragma comments.\")\n\n        if num_of_strings < 2:\n            return TErr(\n                f\"Not enough strings to merge (num_of_strings={num_of_strings}).\"\n            )\n\n        if num_of_inline_string_comments > 1:\n            return TErr(\n                f\"Too many inline string comments ({num_of_inline_string_comments}).\"\n            )\n\n        if len(set_of_prefixes) > 1 and set_of_prefixes != {\"\", \"f\"}:\n            return TErr(f\"Too many different prefixes ({set_of_prefixes}).\")\n\n        return Ok(None)", "is_method": true, "class_name": "StringMerger", "function_description": "Private method in StringMerger that validates if a group of adjacent strings on a line can be merged based on prefixes, comments, and string properties. It ensures merging conditions are met before combining strings."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "do_match", "line_number": 3217, "body": "def do_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        for (idx, leaf) in enumerate(LL):\n            # Should be a string...\n            if leaf.type != token.STRING:\n                continue\n\n            # Should be preceded by a non-empty LPAR...\n            if (\n                not is_valid_index(idx - 1)\n                or LL[idx - 1].type != token.LPAR\n                or is_empty_lpar(LL[idx - 1])\n            ):\n                continue\n\n            # That LPAR should NOT be preceded by a function name or a closing\n            # bracket (which could be a function which returns a function or a\n            # list/dictionary that contains a function)...\n            if is_valid_index(idx - 2) and (\n                LL[idx - 2].type == token.NAME or LL[idx - 2].type in CLOSING_BRACKETS\n            ):\n                continue\n\n            string_idx = idx\n\n            # Skip the string trailer, if one exists.\n            string_parser = StringParser()\n            next_idx = string_parser.parse(LL, string_idx)\n\n            # if the leaves in the parsed string include a PERCENT, we need to\n            # make sure the initial LPAR is NOT preceded by an operator with\n            # higher or equal precedence to PERCENT\n            if is_valid_index(idx - 2):\n                # mypy can't quite follow unless we name this\n                before_lpar = LL[idx - 2]\n                if token.PERCENT in {leaf.type for leaf in LL[idx - 1 : next_idx]} and (\n                    (\n                        before_lpar.type\n                        in {\n                            token.STAR,\n                            token.AT,\n                            token.SLASH,\n                            token.DOUBLESLASH,\n                            token.PERCENT,\n                            token.TILDE,\n                            token.DOUBLESTAR,\n                            token.AWAIT,\n                            token.LSQB,\n                            token.LPAR,\n                        }\n                    )\n                    or (\n                        # only unary PLUS/MINUS\n                        before_lpar.parent\n                        and before_lpar.parent.type == syms.factor\n                        and (before_lpar.type in {token.PLUS, token.MINUS})\n                    )\n                ):\n                    continue\n\n            # Should be followed by a non-empty RPAR...\n            if (\n                is_valid_index(next_idx)\n                and LL[next_idx].type == token.RPAR\n                and not is_empty_rpar(LL[next_idx])\n            ):\n                # That RPAR should NOT be followed by anything with higher\n                # precedence than PERCENT\n                if is_valid_index(next_idx + 1) and LL[next_idx + 1].type in {\n                    token.DOUBLESTAR,\n                    token.LSQB,\n                    token.LPAR,\n                    token.DOT,\n                }:\n                    continue\n\n                return Ok(string_idx)\n\n        return TErr(\"This line has no strings wrapped in parens.\")", "is_method": true, "class_name": "StringParenStripper", "function_description": "Service method of the StringParenStripper class that identifies strings directly enclosed by non-empty parentheses not part of function calls or expressions with higher-precedence operators, aiding syntax-aware parsing or transformation tasks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "do_transform", "line_number": 3300, "body": "def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:\n        LL = line.leaves\n\n        string_parser = StringParser()\n        rpar_idx = string_parser.parse(LL, string_idx)\n\n        for leaf in (LL[string_idx - 1], LL[rpar_idx]):\n            if line.comments_after(leaf):\n                yield TErr(\n                    \"Will not strip parentheses which have comments attached to them.\"\n                )\n\n        new_line = line.clone()\n        new_line.comments = line.comments.copy()\n        append_leaves(new_line, line, LL[: string_idx - 1])\n\n        string_leaf = Leaf(token.STRING, LL[string_idx].value)\n        LL[string_idx - 1].remove()\n        replace_child(LL[string_idx], string_leaf)\n        new_line.append(string_leaf)\n\n        append_leaves(\n            new_line, line, LL[string_idx + 1 : rpar_idx] + LL[rpar_idx + 1 :]\n        )\n\n        LL[rpar_idx].remove()\n\n        yield Ok(new_line)", "is_method": true, "class_name": "StringParenStripper", "function_description": "Utility method of StringParenStripper that removes parentheses around a string leaf in a line, while ensuring no comments are attached to those parentheses; it yields transformed lines or errors accordingly."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "do_match", "line_number": 3363, "body": "def do_match(self, line: Line) -> TMatchResult:\n        match_result = self.do_splitter_match(line)\n        if isinstance(match_result, Err):\n            return match_result\n\n        string_idx = match_result.ok()\n        vresult = self.__validate(line, string_idx)\n        if isinstance(vresult, Err):\n            return vresult\n\n        return match_result", "is_method": true, "class_name": "BaseStringSplitter", "function_description": "Core method of BaseStringSplitter that attempts to find and validate a match within a line, returning the match result or an error if matching or validation fails. It supports controlled string splitting based on matching criteria."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__validate", "line_number": 3375, "body": "def __validate(self, line: Line, string_idx: int) -> TResult[None]:\n        \"\"\"\n        Checks that @line meets all of the requirements listed in this classes'\n        docstring. Refer to `help(BaseStringSplitter)` for a detailed\n        description of those requirements.\n\n        Returns:\n            * Ok(None), if ALL of the requirements are met.\n                OR\n            * Err(CannotTransform), if ANY of the requirements are NOT met.\n        \"\"\"\n        LL = line.leaves\n\n        string_leaf = LL[string_idx]\n\n        max_string_length = self.__get_max_string_length(line, string_idx)\n        if len(string_leaf.value) <= max_string_length:\n            return TErr(\n                \"The string itself is not what is causing this line to be too long.\"\n            )\n\n        if not string_leaf.parent or [L.type for L in string_leaf.parent.children] == [\n            token.STRING,\n            token.NEWLINE,\n        ]:\n            return TErr(\n                f\"This string ({string_leaf.value}) appears to be pointless (i.e. has\"\n                \" no parent).\"\n            )\n\n        if id(line.leaves[string_idx]) in line.comments and contains_pragma_comment(\n            line.comments[id(line.leaves[string_idx])]\n        ):\n            return TErr(\n                \"Line appears to end with an inline pragma comment. Splitting the line\"\n                \" could modify the pragma's behavior.\"\n            )\n\n        if has_triple_quotes(string_leaf.value):\n            return TErr(\"We cannot split multiline strings.\")\n\n        return Ok(None)", "is_method": true, "class_name": "BaseStringSplitter", "function_description": "Method of BaseStringSplitter that verifies if a specific string segment in a line meets predefined criteria for safe splitting, ensuring structural integrity and avoiding problematic cases like multiline strings or pragma comments."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__get_max_string_length", "line_number": 3418, "body": "def __get_max_string_length(self, line: Line, string_idx: int) -> int:\n        \"\"\"\n        Calculates the max string length used when attempting to determine\n        whether or not the target string is responsible for causing the line to\n        go over the line length limit.\n\n        WARNING: This method is tightly coupled to both StringSplitter and\n        (especially) StringParenWrapper. There is probably a better way to\n        accomplish what is being done here.\n\n        Returns:\n            max_string_length: such that `line.leaves[string_idx].value >\n            max_string_length` implies that the target string IS responsible\n            for causing this line to exceed the line length limit.\n        \"\"\"\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        # We use the shorthand \"WMA4\" in comments to abbreviate \"We must\n        # account for\". When giving examples, we use STRING to mean some/any\n        # valid string.\n        #\n        # Finally, we use the following convenience variables:\n        #\n        #   P:  The leaf that is before the target string leaf.\n        #   N:  The leaf that is after the target string leaf.\n        #   NN: The leaf that is after N.\n\n        # WMA4 the whitespace at the beginning of the line.\n        offset = line.depth * 4\n\n        if is_valid_index(string_idx - 1):\n            p_idx = string_idx - 1\n            if (\n                LL[string_idx - 1].type == token.LPAR\n                and LL[string_idx - 1].value == \"\"\n                and string_idx >= 2\n            ):\n                # If the previous leaf is an empty LPAR placeholder, we should skip it.\n                p_idx -= 1\n\n            P = LL[p_idx]\n            if P.type == token.PLUS:\n                # WMA4 a space and a '+' character (e.g. `+ STRING`).\n                offset += 2\n\n            if P.type == token.COMMA:\n                # WMA4 a space, a comma, and a closing bracket [e.g. `), STRING`].\n                offset += 3\n\n            if P.type in [token.COLON, token.EQUAL, token.NAME]:\n                # This conditional branch is meant to handle dictionary keys,\n                # variable assignments, 'return STRING' statement lines, and\n                # 'else STRING' ternary expression lines.\n\n                # WMA4 a single space.\n                offset += 1\n\n                # WMA4 the lengths of any leaves that came before that space.\n                for leaf in LL[: p_idx + 1]:\n                    offset += len(str(leaf))\n\n        if is_valid_index(string_idx + 1):\n            N = LL[string_idx + 1]\n            if N.type == token.RPAR and N.value == \"\" and len(LL) > string_idx + 2:\n                # If the next leaf is an empty RPAR placeholder, we should skip it.\n                N = LL[string_idx + 2]\n\n            if N.type == token.COMMA:\n                # WMA4 a single comma at the end of the string (e.g `STRING,`).\n                offset += 1\n\n            if is_valid_index(string_idx + 2):\n                NN = LL[string_idx + 2]\n\n                if N.type == token.DOT and NN.type == token.NAME:\n                    # This conditional branch is meant to handle method calls invoked\n                    # off of a string literal up to and including the LPAR character.\n\n                    # WMA4 the '.' character.\n                    offset += 1\n\n                    if (\n                        is_valid_index(string_idx + 3)\n                        and LL[string_idx + 3].type == token.LPAR\n                    ):\n                        # WMA4 the left parenthesis character.\n                        offset += 1\n\n                    # WMA4 the length of the method's name.\n                    offset += len(NN.value)\n\n        has_comments = False\n        for comment_leaf in line.comments_after(LL[string_idx]):\n            if not has_comments:\n                has_comments = True\n                # WMA4 two spaces before the '#' character.\n                offset += 2\n\n            # WMA4 the length of the inline comment.\n            offset += len(comment_leaf.value)\n\n        max_string_length = self.line_length - offset\n        return max_string_length", "is_method": true, "class_name": "BaseStringSplitter", "function_description": "Calculates the maximum allowable length of a specific string in a line to determine if that string causes the line to exceed the length limit. This helps identify which string segment is responsible for line length violations during string splitting."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "do_splitter_match", "line_number": 3574, "body": "def do_splitter_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        idx = 0\n\n        # The first leaf MAY be a '+' symbol...\n        if is_valid_index(idx) and LL[idx].type == token.PLUS:\n            idx += 1\n\n        # The next/first leaf MAY be an empty LPAR...\n        if is_valid_index(idx) and is_empty_lpar(LL[idx]):\n            idx += 1\n\n        # The next/first leaf MUST be a string...\n        if not is_valid_index(idx) or LL[idx].type != token.STRING:\n            return TErr(\"Line does not start with a string.\")\n\n        string_idx = idx\n\n        # Skip the string trailer, if one exists.\n        string_parser = StringParser()\n        idx = string_parser.parse(LL, string_idx)\n\n        # That string MAY be followed by an empty RPAR...\n        if is_valid_index(idx) and is_empty_rpar(LL[idx]):\n            idx += 1\n\n        # That string / empty RPAR leaf MAY be followed by a comma...\n        if is_valid_index(idx) and LL[idx].type == token.COMMA:\n            idx += 1\n\n        # But no more leaves are allowed...\n        if is_valid_index(idx):\n            return TErr(\"This line does not end with a string.\")\n\n        return Ok(string_idx)", "is_method": true, "class_name": "StringSplitter", "function_description": "Determines if a given line of tokens starts with a syntactically valid string pattern optionally enclosed by parentheses and/or prefixed by a plus sign, returning the index of the string or an error. Useful for syntax validation and structured string extraction in parsing workflows."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "do_transform", "line_number": 3613, "body": "def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:\n        LL = line.leaves\n\n        QUOTE = LL[string_idx].value[-1]\n\n        is_valid_index = is_valid_index_factory(LL)\n        insert_str_child = insert_str_child_factory(LL[string_idx])\n\n        prefix = get_string_prefix(LL[string_idx].value)\n\n        # We MAY choose to drop the 'f' prefix from substrings that don't\n        # contain any f-expressions, but ONLY if the original f-string\n        # contains at least one f-expression. Otherwise, we will alter the AST\n        # of the program.\n        drop_pointless_f_prefix = (\"f\" in prefix) and re.search(\n            self.RE_FEXPR, LL[string_idx].value, re.VERBOSE\n        )\n\n        first_string_line = True\n        starts_with_plus = LL[0].type == token.PLUS\n\n        def line_needs_plus() -> bool:\n            return first_string_line and starts_with_plus\n\n        def maybe_append_plus(new_line: Line) -> None:\n            \"\"\"\n            Side Effects:\n                If @line starts with a plus and this is the first line we are\n                constructing, this function appends a PLUS leaf to @new_line\n                and replaces the old PLUS leaf in the node structure. Otherwise\n                this function does nothing.\n            \"\"\"\n            if line_needs_plus():\n                plus_leaf = Leaf(token.PLUS, \"+\")\n                replace_child(LL[0], plus_leaf)\n                new_line.append(plus_leaf)\n\n        ends_with_comma = (\n            is_valid_index(string_idx + 1) and LL[string_idx + 1].type == token.COMMA\n        )\n\n        def max_last_string() -> int:\n            \"\"\"\n            Returns:\n                The max allowed length of the string value used for the last\n                line we will construct.\n            \"\"\"\n            result = self.line_length\n            result -= line.depth * 4\n            result -= 1 if ends_with_comma else 0\n            result -= 2 if line_needs_plus() else 0\n            return result\n\n        # --- Calculate Max Break Index (for string value)\n        # We start with the line length limit\n        max_break_idx = self.line_length\n        # The last index of a string of length N is N-1.\n        max_break_idx -= 1\n        # Leading whitespace is not present in the string value (e.g. Leaf.value).\n        max_break_idx -= line.depth * 4\n        if max_break_idx < 0:\n            yield TErr(\n                f\"Unable to split {LL[string_idx].value} at such high of a line depth:\"\n                f\" {line.depth}\"\n            )\n            return\n\n        # Check if StringMerger registered any custom splits.\n        custom_splits = self.pop_custom_splits(LL[string_idx].value)\n        # We use them ONLY if none of them would produce lines that exceed the\n        # line limit.\n        use_custom_breakpoints = bool(\n            custom_splits\n            and all(csplit.break_idx <= max_break_idx for csplit in custom_splits)\n        )\n\n        # Temporary storage for the remaining chunk of the string line that\n        # can't fit onto the line currently being constructed.\n        rest_value = LL[string_idx].value\n\n        def more_splits_should_be_made() -> bool:\n            \"\"\"\n            Returns:\n                True iff `rest_value` (the remaining string value from the last\n                split), should be split again.\n            \"\"\"\n            if use_custom_breakpoints:\n                return len(custom_splits) > 1\n            else:\n                return len(rest_value) > max_last_string()\n\n        string_line_results: List[Ok[Line]] = []\n        while more_splits_should_be_made():\n            if use_custom_breakpoints:\n                # Custom User Split (manual)\n                csplit = custom_splits.pop(0)\n                break_idx = csplit.break_idx\n            else:\n                # Algorithmic Split (automatic)\n                max_bidx = max_break_idx - 2 if line_needs_plus() else max_break_idx\n                maybe_break_idx = self.__get_break_idx(rest_value, max_bidx)\n                if maybe_break_idx is None:\n                    # If we are unable to algorithmically determine a good split\n                    # and this string has custom splits registered to it, we\n                    # fall back to using them--which means we have to start\n                    # over from the beginning.\n                    if custom_splits:\n                        rest_value = LL[string_idx].value\n                        string_line_results = []\n                        first_string_line = True\n                        use_custom_breakpoints = True\n                        continue\n\n                    # Otherwise, we stop splitting here.\n                    break\n\n                break_idx = maybe_break_idx\n\n            # --- Construct `next_value`\n            next_value = rest_value[:break_idx] + QUOTE\n            if (\n                # Are we allowed to try to drop a pointless 'f' prefix?\n                drop_pointless_f_prefix\n                # If we are, will we be successful?\n                and next_value != self.__normalize_f_string(next_value, prefix)\n            ):\n                # If the current custom split did NOT originally use a prefix,\n                # then `csplit.break_idx` will be off by one after removing\n                # the 'f' prefix.\n                break_idx = (\n                    break_idx + 1\n                    if use_custom_breakpoints and not csplit.has_prefix\n                    else break_idx\n                )\n                next_value = rest_value[:break_idx] + QUOTE\n                next_value = self.__normalize_f_string(next_value, prefix)\n\n            # --- Construct `next_leaf`\n            next_leaf = Leaf(token.STRING, next_value)\n            insert_str_child(next_leaf)\n            self.__maybe_normalize_string_quotes(next_leaf)\n\n            # --- Construct `next_line`\n            next_line = line.clone()\n            maybe_append_plus(next_line)\n            next_line.append(next_leaf)\n            string_line_results.append(Ok(next_line))\n\n            rest_value = prefix + QUOTE + rest_value[break_idx:]\n            first_string_line = False\n\n        yield from string_line_results\n\n        if drop_pointless_f_prefix:\n            rest_value = self.__normalize_f_string(rest_value, prefix)\n\n        rest_leaf = Leaf(token.STRING, rest_value)\n        insert_str_child(rest_leaf)\n\n        # NOTE: I could not find a test case that verifies that the following\n        # line is actually necessary, but it seems to be. Otherwise we risk\n        # not normalizing the last substring, right?\n        self.__maybe_normalize_string_quotes(rest_leaf)\n\n        last_line = line.clone()\n        maybe_append_plus(last_line)\n\n        # If there are any leaves to the right of the target string...\n        if is_valid_index(string_idx + 1):\n            # We use `temp_value` here to determine how long the last line\n            # would be if we were to append all the leaves to the right of the\n            # target string to the last string line.\n            temp_value = rest_value\n            for leaf in LL[string_idx + 1 :]:\n                temp_value += str(leaf)\n                if leaf.type == token.LPAR:\n                    break\n\n            # Try to fit them all on the same line with the last substring...\n            if (\n                len(temp_value) <= max_last_string()\n                or LL[string_idx + 1].type == token.COMMA\n            ):\n                last_line.append(rest_leaf)\n                append_leaves(last_line, line, LL[string_idx + 1 :])\n                yield Ok(last_line)\n            # Otherwise, place the last substring on one line and everything\n            # else on a line below that...\n            else:\n                last_line.append(rest_leaf)\n                yield Ok(last_line)\n\n                non_string_line = line.clone()\n                append_leaves(non_string_line, line, LL[string_idx + 1 :])\n                yield Ok(non_string_line)\n        # Else the target string was the last leaf...\n        else:\n            last_line.append(rest_leaf)\n            last_line.comments = line.comments.copy()\n            yield Ok(last_line)", "is_method": true, "class_name": "StringSplitter", "function_description": "Method of the StringSplitter class that splits long string literals into multiple lines respecting line length and syntax rules, ensuring readable and correctly formatted string expressions in code transformations."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__get_break_idx", "line_number": 3814, "body": "def __get_break_idx(self, string: str, max_break_idx: int) -> Optional[int]:\n        \"\"\"\n        This method contains the algorithm that StringSplitter uses to\n        determine which character to split each string at.\n\n        Args:\n            @string: The substring that we are attempting to split.\n            @max_break_idx: The ideal break index. We will return this value if it\n            meets all the necessary conditions. In the likely event that it\n            doesn't we will try to find the closest index BELOW @max_break_idx\n            that does. If that fails, we will expand our search by also\n            considering all valid indices ABOVE @max_break_idx.\n\n        Pre-Conditions:\n            * assert_is_leaf_string(@string)\n            * 0 <= @max_break_idx < len(@string)\n\n        Returns:\n            break_idx, if an index is able to be found that meets all of the\n            conditions listed in the 'Transformations' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        is_valid_index = is_valid_index_factory(string)\n\n        assert is_valid_index(max_break_idx)\n        assert_is_leaf_string(string)\n\n        _fexpr_slices: Optional[List[Tuple[Index, Index]]] = None\n\n        def fexpr_slices() -> Iterator[Tuple[Index, Index]]:\n            \"\"\"\n            Yields:\n                All ranges of @string which, if @string were to be split there,\n                would result in the splitting of an f-expression (which is NOT\n                allowed).\n            \"\"\"\n            nonlocal _fexpr_slices\n\n            if _fexpr_slices is None:\n                _fexpr_slices = []\n                for match in re.finditer(self.RE_FEXPR, string, re.VERBOSE):\n                    _fexpr_slices.append(match.span())\n\n            yield from _fexpr_slices\n\n        is_fstring = \"f\" in get_string_prefix(string)\n\n        def breaks_fstring_expression(i: Index) -> bool:\n            \"\"\"\n            Returns:\n                True iff returning @i would result in the splitting of an\n                f-expression (which is NOT allowed).\n            \"\"\"\n            if not is_fstring:\n                return False\n\n            for (start, end) in fexpr_slices():\n                if start <= i < end:\n                    return True\n\n            return False\n\n        def passes_all_checks(i: Index) -> bool:\n            \"\"\"\n            Returns:\n                True iff ALL of the conditions listed in the 'Transformations'\n                section of this classes' docstring would be be met by returning @i.\n            \"\"\"\n            is_space = string[i] == \" \"\n            is_big_enough = (\n                len(string[i:]) >= self.MIN_SUBSTR_SIZE\n                and len(string[:i]) >= self.MIN_SUBSTR_SIZE\n            )\n            return is_space and is_big_enough and not breaks_fstring_expression(i)\n\n        # First, we check all indices BELOW @max_break_idx.\n        break_idx = max_break_idx\n        while is_valid_index(break_idx - 1) and not passes_all_checks(break_idx):\n            break_idx -= 1\n\n        if not passes_all_checks(break_idx):\n            # If that fails, we check all indices ABOVE @max_break_idx.\n            #\n            # If we are able to find a valid index here, the next line is going\n            # to be longer than the specified line length, but it's probably\n            # better than doing nothing at all.\n            break_idx = max_break_idx + 1\n            while is_valid_index(break_idx + 1) and not passes_all_checks(break_idx):\n                break_idx += 1\n\n            if not is_valid_index(break_idx) or not passes_all_checks(break_idx):\n                return None\n\n        return break_idx", "is_method": true, "class_name": "StringSplitter", "function_description": "Determines the optimal index to split a string without breaking f-string expressions or violating substring size constraints, supporting controlled string splitting for the StringSplitter class."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__maybe_normalize_string_quotes", "line_number": 3911, "body": "def __maybe_normalize_string_quotes(self, leaf: Leaf) -> None:\n        if self.normalize_strings:\n            normalize_string_quotes(leaf)", "is_method": true, "class_name": "StringSplitter", "function_description": "Private method of the StringSplitter class that conditionally normalizes quotation marks in a text segment based on a configuration flag, supporting consistent string formatting during text processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__normalize_f_string", "line_number": 3915, "body": "def __normalize_f_string(self, string: str, prefix: str) -> str:\n        \"\"\"\n        Pre-Conditions:\n            * assert_is_leaf_string(@string)\n\n        Returns:\n            * If @string is an f-string that contains no f-expressions, we\n            return a string identical to @string except that the 'f' prefix\n            has been stripped and all double braces (i.e. '{{' or '}}') have\n            been normalized (i.e. turned into '{' or '}').\n                OR\n            * Otherwise, we return @string.\n        \"\"\"\n        assert_is_leaf_string(string)\n\n        if \"f\" in prefix and not re.search(self.RE_FEXPR, string, re.VERBOSE):\n            new_prefix = prefix.replace(\"f\", \"\")\n\n            temp = string[len(prefix) :]\n            temp = re.sub(r\"\\{\\{\", \"{\", temp)\n            temp = re.sub(r\"\\}\\}\", \"}\", temp)\n            new_string = temp\n\n            return f\"{new_prefix}{new_string}\"\n        else:\n            return string", "is_method": true, "class_name": "StringSplitter", "function_description": "Utility method in StringSplitter that normalizes f-strings without expressions by removing the 'f' prefix and converting double braces to single braces, preserving other strings unchanged for consistent string parsing."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "do_splitter_match", "line_number": 3992, "body": "def do_splitter_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        string_idx = None\n        string_idx = string_idx or self._return_match(LL)\n        string_idx = string_idx or self._else_match(LL)\n        string_idx = string_idx or self._assert_match(LL)\n        string_idx = string_idx or self._assign_match(LL)\n        string_idx = string_idx or self._dict_match(LL)\n\n        if string_idx is not None:\n            string_value = line.leaves[string_idx].value\n            # If the string has no spaces...\n            if \" \" not in string_value:\n                # And will still violate the line length limit when split...\n                max_string_length = self.line_length - ((line.depth + 1) * 4)\n                if len(string_value) > max_string_length:\n                    # And has no associated custom splits...\n                    if not self.has_custom_splits(string_value):\n                        # Then we should NOT put this string on its own line.\n                        return TErr(\n                            \"We do not wrap long strings in parentheses when the\"\n                            \" resultant line would still be over the specified line\"\n                            \" length and can't be split further by StringSplitter.\"\n                        )\n            return Ok(string_idx)\n\n        return TErr(\"This line does not contain any non-atomic strings.\")", "is_method": true, "class_name": "StringParenWrapper", "function_description": "Checks a line for various string patterns to determine if it can be split or wrapped within parentheses, enforcing line length constraints and split feasibility for formatting purposes."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_return_match", "line_number": 4022, "body": "def _return_match(LL: List[Leaf]) -> Optional[int]:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the return/yield statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is apart of a return/yield statement and the first leaf\n        # contains either the \"return\" or \"yield\" keywords...\n        if parent_type(LL[0]) in [syms.return_stmt, syms.yield_expr] and LL[\n            0\n        ].value in [\"return\", \"yield\"]:\n            is_valid_index = is_valid_index_factory(LL)\n\n            idx = 2 if is_valid_index(1) and is_empty_par(LL[1]) else 1\n            # The next visible leaf MUST contain a string...\n            if is_valid_index(idx) and LL[idx].type == token.STRING:\n                return idx\n\n        return None", "is_method": true, "class_name": "StringParenWrapper", "function_description": "Determines the index of a string leaf matching return or yield statement criteria within a list of leaves, aiding parsing or analysis of such statements in code. Returns None if no suitable match is found."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_else_match", "line_number": 4047, "body": "def _else_match(LL: List[Leaf]) -> Optional[int]:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the ternary expression\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is apart of a ternary expression and the first leaf\n        # contains the \"else\" keyword...\n        if (\n            parent_type(LL[0]) == syms.test\n            and LL[0].type == token.NAME\n            and LL[0].value == \"else\"\n        ):\n            is_valid_index = is_valid_index_factory(LL)\n\n            idx = 2 if is_valid_index(1) and is_empty_par(LL[1]) else 1\n            # The next visible leaf MUST contain a string...\n            if is_valid_index(idx) and LL[idx].type == token.STRING:\n                return idx\n\n        return None", "is_method": true, "class_name": "StringParenWrapper", "function_description": "Identifies the index of the \"else\" string leaf in a ternary expression if present, facilitating parsing of conditional expressions within the StringParenWrapper class. Returns None if the expression doesn't match ternary structure criteria."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_assert_match", "line_number": 4074, "body": "def _assert_match(LL: List[Leaf]) -> Optional[int]:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the assert statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is apart of an assert statement and the first leaf\n        # contains the \"assert\" keyword...\n        if parent_type(LL[0]) == syms.assert_stmt and LL[0].value == \"assert\":\n            is_valid_index = is_valid_index_factory(LL)\n\n            for (i, leaf) in enumerate(LL):\n                # We MUST find a comma...\n                if leaf.type == token.COMMA:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That comma MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None", "is_method": true, "class_name": "StringParenWrapper", "function_description": "Utility method in StringParenWrapper that identifies if a given token list represents a valid assert statement with a trailing string message, returning the string's index if conditions are met for further processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_assign_match", "line_number": 4109, "body": "def _assign_match(LL: List[Leaf]) -> Optional[int]:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the assignment statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is apart of an expression statement or is a function\n        # argument AND the first leaf contains a variable name...\n        if (\n            parent_type(LL[0]) in [syms.expr_stmt, syms.argument, syms.power]\n            and LL[0].type == token.NAME\n        ):\n            is_valid_index = is_valid_index_factory(LL)\n\n            for (i, leaf) in enumerate(LL):\n                # We MUST find either an '=' or '+=' symbol...\n                if leaf.type in [token.EQUAL, token.PLUSEQUAL]:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That symbol MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # The next leaf MAY be a comma iff this line is apart\n                        # of a function argument...\n                        if (\n                            parent_type(LL[0]) == syms.argument\n                            and is_valid_index(idx)\n                            and LL[idx].type == token.COMMA\n                        ):\n                            idx += 1\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None", "is_method": true, "class_name": "StringParenWrapper", "function_description": "Core utility method of the StringParenWrapper class that identifies and returns the index of target string assignments within a list of tokens if they meet specific syntactic assignment criteria, supporting parsing and analysis of string assignment expressions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_dict_match", "line_number": 4156, "body": "def _dict_match(LL: List[Leaf]) -> Optional[int]:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the dictionary key assignment\n            statement requirements listed in the 'Requirements' section of this\n            classes' docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is apart of a dictionary key assignment...\n        if syms.dictsetmaker in [parent_type(LL[0]), parent_type(LL[0].parent)]:\n            is_valid_index = is_valid_index_factory(LL)\n\n            for (i, leaf) in enumerate(LL):\n                # We MUST find a colon...\n                if leaf.type == token.COLON:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That colon MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # That string MAY be followed by a comma...\n                        if is_valid_index(idx) and LL[idx].type == token.COMMA:\n                            idx += 1\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None", "is_method": true, "class_name": "StringParenWrapper", "function_description": "Utility method of the StringParenWrapper class that identifies if a list of tokens represents a dictionary key assignment matching specific structural criteria, returning the index of the matching string token or None otherwise."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "do_transform", "line_number": 4193, "body": "def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n        insert_str_child = insert_str_child_factory(LL[string_idx])\n\n        comma_idx = len(LL) - 1\n        ends_with_comma = False\n        if LL[comma_idx].type == token.COMMA:\n            ends_with_comma = True\n\n        leaves_to_steal_comments_from = [LL[string_idx]]\n        if ends_with_comma:\n            leaves_to_steal_comments_from.append(LL[comma_idx])\n\n        # --- First Line\n        first_line = line.clone()\n        left_leaves = LL[:string_idx]\n\n        # We have to remember to account for (possibly invisible) LPAR and RPAR\n        # leaves that already wrapped the target string. If these leaves do\n        # exist, we will replace them with our own LPAR and RPAR leaves.\n        old_parens_exist = False\n        if left_leaves and left_leaves[-1].type == token.LPAR:\n            old_parens_exist = True\n            leaves_to_steal_comments_from.append(left_leaves[-1])\n            left_leaves.pop()\n\n        append_leaves(first_line, line, left_leaves)\n\n        lpar_leaf = Leaf(token.LPAR, \"(\")\n        if old_parens_exist:\n            replace_child(LL[string_idx - 1], lpar_leaf)\n        else:\n            insert_str_child(lpar_leaf)\n        first_line.append(lpar_leaf)\n\n        # We throw inline comments that were originally to the right of the\n        # target string to the top line. They will now be shown to the right of\n        # the LPAR.\n        for leaf in leaves_to_steal_comments_from:\n            for comment_leaf in line.comments_after(leaf):\n                first_line.append(comment_leaf, preformatted=True)\n\n        yield Ok(first_line)\n\n        # --- Middle (String) Line\n        # We only need to yield one (possibly too long) string line, since the\n        # `StringSplitter` will break it down further if necessary.\n        string_value = LL[string_idx].value\n        string_line = Line(\n            depth=line.depth + 1,\n            inside_brackets=True,\n            should_explode=line.should_explode,\n        )\n        string_leaf = Leaf(token.STRING, string_value)\n        insert_str_child(string_leaf)\n        string_line.append(string_leaf)\n\n        old_rpar_leaf = None\n        if is_valid_index(string_idx + 1):\n            right_leaves = LL[string_idx + 1 :]\n            if ends_with_comma:\n                right_leaves.pop()\n\n            if old_parens_exist:\n                assert (\n                    right_leaves and right_leaves[-1].type == token.RPAR\n                ), \"Apparently, old parentheses do NOT exist?!\"\n                old_rpar_leaf = right_leaves.pop()\n\n            append_leaves(string_line, line, right_leaves)\n\n        yield Ok(string_line)\n\n        # --- Last Line\n        last_line = line.clone()\n        last_line.bracket_tracker = first_line.bracket_tracker\n\n        new_rpar_leaf = Leaf(token.RPAR, \")\")\n        if old_rpar_leaf is not None:\n            replace_child(old_rpar_leaf, new_rpar_leaf)\n        else:\n            insert_str_child(new_rpar_leaf)\n        last_line.append(new_rpar_leaf)\n\n        # If the target string ended with a comma, we place this comma to the\n        # right of the RPAR on the last line.\n        if ends_with_comma:\n            comma_leaf = Leaf(token.COMMA, \",\")\n            replace_child(LL[comma_idx], comma_leaf)\n            last_line.append(comma_leaf)\n\n        yield Ok(last_line)", "is_method": true, "class_name": "StringParenWrapper", "function_description": "Transforms a line by wrapping a specified string element in parentheses, preserving formatting and comments. It yields a sequence of lines representing the transformation split into parts before, within, and after the parentheses for structured code editing."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "parse", "line_number": 4361, "body": "def parse(self, leaves: List[Leaf], string_idx: int) -> int:\n        \"\"\"\n        Pre-conditions:\n            * @leaves[@string_idx].type == token.STRING\n\n        Returns:\n            The index directly after the last leaf which is apart of the string\n            trailer, if a \"trailer\" exists.\n                OR\n            @string_idx + 1, if no string \"trailer\" exists.\n        \"\"\"\n        assert leaves[string_idx].type == token.STRING\n\n        idx = string_idx + 1\n        while idx < len(leaves) and self._next_state(leaves[idx]):\n            idx += 1\n        return idx", "is_method": true, "class_name": "StringParser", "function_description": "Utility method of StringParser that identifies the extent of a string token sequence, returning the index after the last related token including any optional trailing tokens. It helps in accurately parsing string literals with possible continuations."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "_next_state", "line_number": 4379, "body": "def _next_state(self, leaf: Leaf) -> bool:\n        \"\"\"\n        Pre-conditions:\n            * On the first call to this function, @leaf MUST be the leaf that\n            was directly after the string leaf in question (e.g. if our target\n            string is `line.leaves[i]` then the first call to this method must\n            be `line.leaves[i + 1]`).\n            * On the next call to this function, the leaf parameter passed in\n            MUST be the leaf directly following @leaf.\n\n        Returns:\n            True iff @leaf is apart of the string's trailer.\n        \"\"\"\n        # We ignore empty LPAR or RPAR leaves.\n        if is_empty_par(leaf):\n            return True\n\n        next_token = leaf.type\n        if next_token == token.LPAR:\n            self._unmatched_lpars += 1\n\n        current_state = self._state\n\n        # The LPAR parser state is a special case. We will return True until we\n        # find the matching RPAR token.\n        if current_state == self.LPAR:\n            if next_token == token.RPAR:\n                self._unmatched_lpars -= 1\n                if self._unmatched_lpars == 0:\n                    self._state = self.RPAR\n        # Otherwise, we use a lookup table to determine the next state.\n        else:\n            # If the lookup table matches the current state to the next\n            # token, we use the lookup table.\n            if (current_state, next_token) in self._goto:\n                self._state = self._goto[current_state, next_token]\n            else:\n                # Otherwise, we check if a the current state was assigned a\n                # default.\n                if (current_state, self.DEFAULT_TOKEN) in self._goto:\n                    self._state = self._goto[current_state, self.DEFAULT_TOKEN]\n                # If no default has been assigned, then this parser has a logic\n                # error.\n                else:\n                    raise RuntimeError(f\"{self.__class__.__name__} LOGIC ERROR!\")\n\n            if self._state == self.DONE:\n                return False\n\n        return True", "is_method": true, "class_name": "StringParser", "function_description": "Internal method of StringParser that updates and tracks the parser's state based on the next leaf token, determining if the leaf is part of a target string's trailer during parsing. It supports nested parentheses and enforces parsing logic consistency."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "insert_str_child", "line_number": 4503, "body": "def insert_str_child(child: LN) -> None:\n        nonlocal string_child_idx\n\n        assert string_parent is not None\n        assert string_child_idx is not None\n\n        string_parent.insert_child(string_child_idx, child)\n        string_child_idx += 1", "is_method": false, "function_description": "Inserts a child node into a specific position within a parent node, then updates the insertion index for subsequent children. This supports controlled, ordered child insertion in a node structure."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "split_wrapper", "line_number": 4877, "body": "def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:\n        for line in split_func(line, features):\n            normalize_prefix(line.leaves[0], inside_brackets=True)\n            yield line", "is_method": false, "function_description": "Core utility function that processes a line by splitting it using a helper function and then normalizing its first element, providing a sequence of refined line segments for further text processing workflows."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "append_to_line", "line_number": 4911, "body": "def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)", "is_method": false, "function_description": "Method that attempts to append a leaf element to the current line, yielding the current line and starting a new one if the append operation fails due to formatting constraints. It helps manage line construction with conditional line breaks."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "append_to_line", "line_number": 4966, "body": "def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)", "is_method": false, "function_description": "Utility function that appends a leaf element to the current line or yields the current line and starts a new one if appending fails, supporting incremental line construction with overflow handling."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "get_imports_from_children", "line_number": 5770, "body": "def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:\n        for child in children:\n            if isinstance(child, Leaf):\n                if child.type == token.NAME:\n                    yield child.value\n\n            elif child.type == syms.import_as_name:\n                orig_name = child.children[0]\n                assert isinstance(orig_name, Leaf), \"Invalid syntax parsing imports\"\n                assert orig_name.type == token.NAME, \"Invalid syntax parsing imports\"\n                yield orig_name.value\n\n            elif child.type == syms.import_as_names:\n                yield from get_imports_from_children(child.children)\n\n            else:\n                raise AssertionError(\"Invalid syntax parsing imports\")", "is_method": false, "function_description": "Utility function that extracts and yields import names from a list of syntax tree nodes, facilitating analysis or processing of Python import statements within a parsed code structure."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "done", "line_number": 5962, "body": "def done(self, src: Path, changed: Changed) -> None:\n        \"\"\"Increment the counter for successful reformatting. Write out a message.\"\"\"\n        if changed is Changed.YES:\n            reformatted = \"would reformat\" if self.check or self.diff else \"reformatted\"\n            if self.verbose or not self.quiet:\n                out(f\"{reformatted} {src}\")\n            self.change_count += 1\n        else:\n            if self.verbose:\n                if changed is Changed.NO:\n                    msg = f\"{src} already well formatted, good job.\"\n                else:\n                    msg = f\"{src} wasn't modified on disk since last run.\"\n                out(msg, bold=False)\n            self.same_count += 1", "is_method": true, "class_name": "Report", "function_description": "Method of the Report class that updates success counters and outputs status messages after attempting to reformat a file, helping track and report formatting changes and results."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "failed", "line_number": 5978, "body": "def failed(self, src: Path, message: str) -> None:\n        \"\"\"Increment the counter for failed reformatting. Write out a message.\"\"\"\n        err(f\"error: cannot format {src}: {message}\")\n        self.failure_count += 1", "is_method": true, "class_name": "Report", "function_description": "Utility method of the Report class that logs a formatting failure message for a given source and increments the failure count. It tracks and records unsuccessful reformatting attempts."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "path_ignored", "line_number": 5983, "body": "def path_ignored(self, path: Path, message: str) -> None:\n        if self.verbose:\n            out(f\"{path} ignored: {message}\", bold=False)", "is_method": true, "class_name": "Report", "function_description": "Utility method of the Report class that logs a message when a specific file path is ignored, aiding in verbose reporting or debugging processes."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "return_code", "line_number": 5988, "body": "def return_code(self) -> int:\n        \"\"\"Return the exit code that the app should use.\n\n        This considers the current state of changed files and failures:\n        - if there were any failures, return 123;\n        - if any files were changed and --check is being used, return 1;\n        - otherwise return 0.\n        \"\"\"\n        # According to http://tldp.org/LDP/abs/html/exitcodes.html starting with\n        # 126 we have special return codes reserved by the shell.\n        if self.failure_count:\n            return 123\n\n        elif self.change_count and self.check:\n            return 1\n\n        return 0", "is_method": true, "class_name": "Report", "function_description": "Returns an exit code based on the report's failure status and file changes, supporting command-line applications that need to signal success, failure, or changes when run with a check option."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "__str__", "line_number": 6006, "body": "def __str__(self) -> str:\n        \"\"\"Render a color report of the current state.\n\n        Use `click.unstyle` to remove colors.\n        \"\"\"\n        if self.check or self.diff:\n            reformatted = \"would be reformatted\"\n            unchanged = \"would be left unchanged\"\n            failed = \"would fail to reformat\"\n        else:\n            reformatted = \"reformatted\"\n            unchanged = \"left unchanged\"\n            failed = \"failed to reformat\"\n        report = []\n        if self.change_count:\n            s = \"s\" if self.change_count > 1 else \"\"\n            report.append(\n                click.style(f\"{self.change_count} file{s} {reformatted}\", bold=True)\n            )\n        if self.same_count:\n            s = \"s\" if self.same_count > 1 else \"\"\n            report.append(f\"{self.same_count} file{s} {unchanged}\")\n        if self.failure_count:\n            s = \"s\" if self.failure_count > 1 else \"\"\n            report.append(\n                click.style(f\"{self.failure_count} file{s} {failed}\", fg=\"red\")\n            )\n        return \", \".join(report) + \".\"", "is_method": true, "class_name": "Report", "function_description": "Provides a color-coded summary of file formatting results, indicating counts of reformatted, unchanged, and failed files. It generates a human-readable status report reflecting the current report state for display."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "make_naked", "line_number": 3025, "body": "def make_naked(string: str, string_prefix: str) -> str:\n            \"\"\"Strip @string (i.e. make it a \"naked\" string)\n\n            Pre-conditions:\n                * assert_is_leaf_string(@string)\n\n            Returns:\n                A string that is identical to @string except that\n                @string_prefix has been stripped, the surrounding QUOTE\n                characters have been removed, and any remaining QUOTE\n                characters have been escaped.\n            \"\"\"\n            assert_is_leaf_string(string)\n\n            RE_EVEN_BACKSLASHES = r\"(?:(?<!\\\\)(?:\\\\\\\\)*)\"\n            naked_string = string[len(string_prefix) + 1 : -1]\n            naked_string = re.sub(\n                \"(\" + RE_EVEN_BACKSLASHES + \")\" + QUOTE, r\"\\1\\\\\" + QUOTE, naked_string\n            )\n            return naked_string", "is_method": true, "class_name": "StringMerger", "function_description": "Method of StringMerger that returns the input string stripped of a specified prefix and surrounding quotes, while escaping any internal quote characters. It is useful for processing and normalizing quoted strings by removing syntactic decorations."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "line_needs_plus", "line_number": 3634, "body": "def line_needs_plus() -> bool:\n            return first_string_line and starts_with_plus", "is_method": true, "class_name": "StringSplitter", "function_description": "Determines whether a line should begin with a plus sign based on specific conditions. This helps control string formatting when splitting or processing multiline strings."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "maybe_append_plus", "line_number": 3637, "body": "def maybe_append_plus(new_line: Line) -> None:\n            \"\"\"\n            Side Effects:\n                If @line starts with a plus and this is the first line we are\n                constructing, this function appends a PLUS leaf to @new_line\n                and replaces the old PLUS leaf in the node structure. Otherwise\n                this function does nothing.\n            \"\"\"\n            if line_needs_plus():\n                plus_leaf = Leaf(token.PLUS, \"+\")\n                replace_child(LL[0], plus_leaf)\n                new_line.append(plus_leaf)", "is_method": true, "class_name": "StringSplitter", "function_description": "Utility method of StringSplitter that conditionally appends a plus symbol leaf to a line if the line begins with a plus, supporting internal line construction and node structure updates."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "max_last_string", "line_number": 3654, "body": "def max_last_string() -> int:\n            \"\"\"\n            Returns:\n                The max allowed length of the string value used for the last\n                line we will construct.\n            \"\"\"\n            result = self.line_length\n            result -= line.depth * 4\n            result -= 1 if ends_with_comma else 0\n            result -= 2 if line_needs_plus() else 0\n            return result", "is_method": true, "class_name": "StringSplitter", "function_description": "Calculates the maximum allowed length for the final string segment based on line length, indentation depth, and specific formatting conditions. It helps enforce length constraints when constructing the last line of a split string."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "more_splits_should_be_made", "line_number": 3693, "body": "def more_splits_should_be_made() -> bool:\n            \"\"\"\n            Returns:\n                True iff `rest_value` (the remaining string value from the last\n                split), should be split again.\n            \"\"\"\n            if use_custom_breakpoints:\n                return len(custom_splits) > 1\n            else:\n                return len(rest_value) > max_last_string()", "is_method": true, "class_name": "StringSplitter", "function_description": "Determines whether the remaining part of a string should undergo additional splitting based on custom breakpoints or length criteria. This helps control iterative string segmentation in the StringSplitter class."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "fexpr_slices", "line_number": 3845, "body": "def fexpr_slices() -> Iterator[Tuple[Index, Index]]:\n            \"\"\"\n            Yields:\n                All ranges of @string which, if @string were to be split there,\n                would result in the splitting of an f-expression (which is NOT\n                allowed).\n            \"\"\"\n            nonlocal _fexpr_slices\n\n            if _fexpr_slices is None:\n                _fexpr_slices = []\n                for match in re.finditer(self.RE_FEXPR, string, re.VERBOSE):\n                    _fexpr_slices.append(match.span())\n\n            yield from _fexpr_slices", "is_method": true, "class_name": "StringSplitter", "function_description": "Identifies and yields ranges within a string where splitting would break f-expressions, helping to prevent invalid splits during string processing operations."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "breaks_fstring_expression", "line_number": 3863, "body": "def breaks_fstring_expression(i: Index) -> bool:\n            \"\"\"\n            Returns:\n                True iff returning @i would result in the splitting of an\n                f-expression (which is NOT allowed).\n            \"\"\"\n            if not is_fstring:\n                return False\n\n            for (start, end) in fexpr_slices():\n                if start <= i < end:\n                    return True\n\n            return False", "is_method": true, "class_name": "StringSplitter", "function_description": "Utility method of the StringSplitter class that checks if splitting at a given index would break an f-string expression, preventing invalid splits within embedded expressions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "passes_all_checks", "line_number": 3878, "body": "def passes_all_checks(i: Index) -> bool:\n            \"\"\"\n            Returns:\n                True iff ALL of the conditions listed in the 'Transformations'\n                section of this classes' docstring would be be met by returning @i.\n            \"\"\"\n            is_space = string[i] == \" \"\n            is_big_enough = (\n                len(string[i:]) >= self.MIN_SUBSTR_SIZE\n                and len(string[:i]) >= self.MIN_SUBSTR_SIZE\n            )\n            return is_space and is_big_enough and not breaks_fstring_expression(i)", "is_method": true, "class_name": "StringSplitter", "function_description": "Checks whether a given index in the string meets all criteria for splitting, including being a space, ensuring substrings meet minimum size, and not breaking f-string expressions."}, {"file": "./dataset/RepoExec/test-apps/black/src/black/__init__.py", "function": "rhs", "line_number": 2641, "body": "def rhs(line: Line, features: Collection[Feature]) -> Iterator[Line]:\n            \"\"\"Wraps calls to `right_hand_split`.\n\n            The calls increasingly `omit` right-hand trailers (bracket pairs with\n            content), meaning the trailers get glued together to split on another\n            bracket pair instead.\n            \"\"\"\n            for omit in generate_trailers_to_omit(line, mode.line_length):\n                lines = list(\n                    right_hand_split(line, mode.line_length, features, omit=omit)\n                )\n                # Note: this check is only able to figure out if the first line of the\n                # *current* transformation fits in the line length.  This is true only\n                # for simple cases.  All others require running more transforms via\n                # `transform_line()`.  This check doesn't know if those would succeed.\n                if is_line_short_enough(lines[0], line_length=mode.line_length):\n                    yield from lines\n                    return\n\n            # All splits failed, best effort split with no omits.\n            # This mostly happens to multiline strings that are by definition\n            # reported as not fitting a single line, as well as lines that contain\n            # trailing commas (those have to be exploded).\n            yield from right_hand_split(\n                line, line_length=mode.line_length, features=features\n            )", "is_method": false, "function_description": "Utility function that attempts to split a line into shorter segments by selectively omitting trailing bracket content to fit within a target line length, yielding viable splits or a best-effort fallback if none fit."}, {"file": "./dataset/RepoExec/test-apps/black/src/blackd/__init__.py", "function": "main", "line_number": 50, "body": "def main(bind_host: str, bind_port: int) -> None:\n    logging.basicConfig(level=logging.INFO)\n    app = make_app()\n    ver = black.__version__\n    black.out(f\"blackd version {ver} listening on {bind_host} port {bind_port}\")\n    web.run_app(app, host=bind_host, port=bind_port, handle_signals=True, print=None)", "is_method": false, "function_description": "This function launches and runs a web server application bound to a specified host and port, initializing logging and displaying version information before starting. It provides the service of hosting the app and handling incoming requests."}, {"file": "./dataset/RepoExec/test-apps/black/src/blackd/__init__.py", "function": "make_app", "line_number": 58, "body": "def make_app() -> web.Application:\n    app = web.Application()\n    executor = ProcessPoolExecutor()\n\n    cors = aiohttp_cors.setup(app)\n    resource = cors.add(app.router.add_resource(\"/\"))\n    cors.add(\n        resource.add_route(\"POST\", partial(handle, executor=executor)),\n        {\n            \"*\": aiohttp_cors.ResourceOptions(\n                allow_headers=(*BLACK_HEADERS, \"Content-Type\"), expose_headers=\"*\"\n            )\n        },\n    )\n\n    return app", "is_method": false, "function_description": "Constructs and configures an aiohttp web application with CORS support and a POST route that processes requests asynchronously using a process pool executor."}, {"file": "./dataset/RepoExec/test-apps/black/src/blackd/__init__.py", "function": "parse_python_variant_header", "line_number": 152, "body": "def parse_python_variant_header(value: str) -> Tuple[bool, Set[black.TargetVersion]]:\n    if value == \"pyi\":\n        return True, set()\n    else:\n        versions = set()\n        for version in value.split(\",\"):\n            if version.startswith(\"py\"):\n                version = version[len(\"py\") :]\n            if \".\" in version:\n                major_str, *rest = version.split(\".\")\n            else:\n                major_str = version[0]\n                rest = [version[1:]] if len(version) > 1 else []\n            try:\n                major = int(major_str)\n                if major not in (2, 3):\n                    raise InvalidVariantHeader(\"major version must be 2 or 3\")\n                if len(rest) > 0:\n                    minor = int(rest[0])\n                    if major == 2 and minor != 7:\n                        raise InvalidVariantHeader(\n                            \"minor version must be 7 for Python 2\"\n                        )\n                else:\n                    # Default to lowest supported minor version.\n                    minor = 7 if major == 2 else 3\n                version_str = f\"PY{major}{minor}\"\n                if major == 3 and not hasattr(black.TargetVersion, version_str):\n                    raise InvalidVariantHeader(f\"3.{minor} is not supported\")\n                versions.add(black.TargetVersion[version_str])\n            except (KeyError, ValueError):\n                raise InvalidVariantHeader(\"expected e.g. '3.7', 'py3.5'\")\n        return False, versions", "is_method": false, "function_description": "Parses Python version strings from a header value, validating and converting them into a set of target Python versions or identifying a stub type. It facilitates interpreting version specifications for tooling compatibility or code analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/blackd/__init__.py", "function": "patched_main", "line_number": 187, "body": "def patched_main() -> None:\n    freeze_support()\n    black.patch_click()\n    main()", "is_method": false, "function_description": "This function initializes necessary runtime patches and multiprocessing support before executing the main application logic. It ensures compatibility and proper startup in a multiprocessing environment."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "type_repr", "line_number": 42, "body": "def type_repr(type_num: int) -> Union[Text, int]:\n    global _type_reprs\n    if not _type_reprs:\n        from .pygram import python_symbols\n\n        # printing tokens is possible but not as useful\n        # from .pgen2 import token // token.__dict__.items():\n        for name in dir(python_symbols):\n            val = getattr(python_symbols, name)\n            if type(val) == int:\n                _type_reprs[val] = name\n    return _type_reprs.setdefault(type_num, type_num)", "is_method": false, "function_description": "Utility function that returns the symbolic name of a Python grammar token given its numeric type, aiding in readable representation of token types during parsing or analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "convert", "line_number": 478, "body": "def convert(gr: Grammar, raw_node: RawNode) -> NL:\n    \"\"\"\n    Convert raw node information to a Node or Leaf instance.\n\n    This is passed to the parser driver which calls it whenever a reduction of a\n    grammar rule produces a new complete node, so that the tree is build\n    strictly bottom-up.\n    \"\"\"\n    type, value, context, children = raw_node\n    if children or type in gr.number2symbol:\n        # If there's exactly one child, return that child instead of\n        # creating a new node.\n        assert children is not None\n        if len(children) == 1:\n            return children[0]\n        return Node(type, children, context=context)\n    else:\n        return Leaf(type, value or \"\", context=context)", "is_method": false, "function_description": "Core function that transforms raw parse data into structured tree nodes or leaves, facilitating the bottom-up construction of parse trees during grammar parsing."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "generate_matches", "line_number": 951, "body": "def generate_matches(\n    patterns: List[BasePattern], nodes: List[NL]\n) -> Iterator[Tuple[int, _Results]]:\n    \"\"\"\n    Generator yielding matches for a sequence of patterns and nodes.\n\n    Args:\n        patterns: a sequence of patterns\n        nodes: a sequence of nodes\n\n    Yields:\n        (count, results) tuples where:\n        count: the entire sequence of patterns matches nodes[:count];\n        results: dict containing named submatches.\n    \"\"\"\n    if not patterns:\n        yield 0, {}\n    else:\n        p, rest = patterns[0], patterns[1:]\n        for c0, r0 in p.generate_matches(nodes):\n            if not rest:\n                yield c0, r0\n            else:\n                for c1, r1 in generate_matches(rest, nodes[c0:]):\n                    r = {}\n                    r.update(r0)\n                    r.update(r1)\n                    yield c0 + c1, r", "is_method": false, "function_description": "Function generating combined match results for a sequence of pattern matches over nodes, yielding the cumulative match length and aggregated named submatches. Useful for pattern-based parsing or matching tasks on node sequences."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "__new__", "line_number": 81, "body": "def __new__(cls, *args, **kwds):\n        \"\"\"Constructor that prevents Base from being instantiated.\"\"\"\n        assert cls is not Base, \"Cannot instantiate Base\"\n        return object.__new__(cls)", "is_method": true, "class_name": "Base", "function_description": "Constructor method in the Base class that prevents direct instantiation of Base, enforcing subclassing by raising an assertion if instantiation is attempted."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "__eq__", "line_number": 86, "body": "def __eq__(self, other: Any) -> bool:\n        \"\"\"\n        Compare two nodes for equality.\n\n        This calls the method _eq().\n        \"\"\"\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return self._eq(other)", "is_method": true, "class_name": "Base", "function_description": "Provides object equality comparison tailored for nodes by delegating to a class-specific method, ensuring type-safe equality checks within the Base class hierarchy."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "replace", "line_number": 137, "body": "def replace(self, new: Union[NL, List[NL]]) -> None:\n        \"\"\"Replace this node with a new one in the parent.\"\"\"\n        assert self.parent is not None, str(self)\n        assert new is not None\n        if not isinstance(new, list):\n            new = [new]\n        l_children = []\n        found = False\n        for ch in self.parent.children:\n            if ch is self:\n                assert not found, (self.parent.children, self, new)\n                if new is not None:\n                    l_children.extend(new)\n                found = True\n            else:\n                l_children.append(ch)\n        assert found, (self.children, self, new)\n        self.parent.children = l_children\n        self.parent.changed()\n        self.parent.invalidate_sibling_maps()\n        for x in new:\n            x.parent = self.parent\n        self.parent = None", "is_method": true, "class_name": "Base", "function_description": "Provides capability to replace the current node with one or more new nodes within its parent, updating parental relationships and internal parent state to maintain tree integrity. Useful for modifying or restructuring node hierarchies dynamically."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "get_lineno", "line_number": 161, "body": "def get_lineno(self) -> Optional[int]:\n        \"\"\"Return the line number which generated the invocant node.\"\"\"\n        node = self\n        while not isinstance(node, Leaf):\n            if not node.children:\n                return None\n            node = node.children[0]\n        return node.lineno", "is_method": true, "class_name": "Base", "function_description": "Utility method of the Base class that returns the line number where the invoking node or its first descendant leaf node was generated, aiding in source code location tracking."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "changed", "line_number": 170, "body": "def changed(self) -> None:\n        if self.was_changed:\n            return\n        if self.parent:\n            self.parent.changed()\n        self.was_changed = True", "is_method": true, "class_name": "Base", "function_description": "Core utility method of the Base class that propagates and marks an object and its ancestors as changed, enabling change tracking within hierarchical structures."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "remove", "line_number": 177, "body": "def remove(self) -> Optional[int]:\n        \"\"\"\n        Remove the node from the tree. Returns the position of the node in its\n        parent's children before it was removed.\n        \"\"\"\n        if self.parent:\n            for i, node in enumerate(self.parent.children):\n                if node is self:\n                    del self.parent.children[i]\n                    self.parent.changed()\n                    self.parent.invalidate_sibling_maps()\n                    self.parent = None\n                    return i\n        return None", "is_method": true, "class_name": "Base", "function_description": "Utility method of the Base class that removes the current node from its parent's children and returns the node's former position. It helps manage and update tree structure integrity after node removal."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "next_sibling", "line_number": 193, "body": "def next_sibling(self) -> Optional[NL]:\n        \"\"\"\n        The node immediately following the invocant in their parent's children\n        list. If the invocant does not have a next sibling, it is None\n        \"\"\"\n        if self.parent is None:\n            return None\n\n        if self.parent.next_sibling_map is None:\n            self.parent.update_sibling_maps()\n        assert self.parent.next_sibling_map is not None\n        return self.parent.next_sibling_map[id(self)]", "is_method": true, "class_name": "Base", "function_description": "Utility method in the Base class that returns the node immediately following the current one among its parent\u2019s children, or None if no such sibling exists. It supports navigation within tree-like structures."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "prev_sibling", "line_number": 207, "body": "def prev_sibling(self) -> Optional[NL]:\n        \"\"\"\n        The node immediately preceding the invocant in their parent's children\n        list. If the invocant does not have a previous sibling, it is None.\n        \"\"\"\n        if self.parent is None:\n            return None\n\n        if self.parent.prev_sibling_map is None:\n            self.parent.update_sibling_maps()\n        assert self.parent.prev_sibling_map is not None\n        return self.parent.prev_sibling_map[id(self)]", "is_method": true, "class_name": "Base", "function_description": "Utility method of the Base class that returns the previous sibling node of the current node within its parent's children, or None if no such sibling exists. It supports navigation and traversal of tree-like structures."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "leaves", "line_number": 220, "body": "def leaves(self) -> Iterator[\"Leaf\"]:\n        for child in self.children:\n            yield from child.leaves()", "is_method": true, "class_name": "Base", "function_description": "Core traversal method of the Base class that recursively yields all leaf nodes from its child nodes, supporting hierarchical tree processing and iteration over terminal elements."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "depth", "line_number": 224, "body": "def depth(self) -> int:\n        if self.parent is None:\n            return 0\n        return 1 + self.parent.depth()", "is_method": true, "class_name": "Base", "function_description": "Returns the hierarchical depth level of the current node relative to its root ancestor in a tree structure, enabling determination of node positioning within nested relationships."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "get_suffix", "line_number": 229, "body": "def get_suffix(self) -> Text:\n        \"\"\"\n        Return the string immediately following the invocant node. This is\n        effectively equivalent to node.next_sibling.prefix\n        \"\"\"\n        next_sib = self.next_sibling\n        if next_sib is None:\n            return \"\"\n        prefix = next_sib.prefix\n        return prefix", "is_method": true, "class_name": "Base", "function_description": "Retrieves the string directly following the current node, providing access to the immediate suffix in a node sequence."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "__repr__", "line_number": 278, "body": "def __repr__(self) -> Text:\n        \"\"\"Return a canonical string representation.\"\"\"\n        assert self.type is not None\n        return \"%s(%s, %r)\" % (\n            self.__class__.__name__,\n            type_repr(self.type),\n            self.children,\n        )", "is_method": true, "class_name": "Node", "function_description": "Core method of the Node class providing a clear, standardized string representation including its type and children for debugging and logging purposes."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "__str__", "line_number": 287, "body": "def __str__(self) -> Text:\n        \"\"\"\n        Return a pretty string representation.\n\n        This reproduces the input source exactly.\n        \"\"\"\n        return \"\".join(map(str, self.children))", "is_method": true, "class_name": "Node", "function_description": "Returns a formatted string that exactly reconstructs the original input source represented by the Node object and its children. This aids in displaying or exporting the node's content as readable text."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "_eq", "line_number": 295, "body": "def _eq(self, other) -> bool:\n        \"\"\"Compare two nodes for equality.\"\"\"\n        return (self.type, self.children) == (other.type, other.children)", "is_method": true, "class_name": "Node", "function_description": "Private method of the Node class that checks if two nodes are equal by comparing their type and children. Useful for determining node equivalence in data structures representing hierarchies or trees."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "clone", "line_number": 299, "body": "def clone(self) -> \"Node\":\n        assert self.type is not None\n        \"\"\"Return a cloned (deep) copy of self.\"\"\"\n        return Node(\n            self.type,\n            [ch.clone() for ch in self.children],\n            fixers_applied=self.fixers_applied,\n        )", "is_method": true, "class_name": "Node", "function_description": "Creates and returns a deep copy of the Node instance, including all child nodes and applied fixers. This enables safe duplication of node structures without shared references."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "post_order", "line_number": 308, "body": "def post_order(self) -> Iterator[NL]:\n        \"\"\"Return a post-order iterator for the tree.\"\"\"\n        for child in self.children:\n            yield from child.post_order()\n        yield self", "is_method": true, "class_name": "Node", "function_description": "Provides an iterator that traverses the tree nodes in post-order sequence, enabling operations that require processing child nodes before their parent within the Node tree structure."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "pre_order", "line_number": 314, "body": "def pre_order(self) -> Iterator[NL]:\n        \"\"\"Return a pre-order iterator for the tree.\"\"\"\n        yield self\n        for child in self.children:\n            yield from child.pre_order()", "is_method": true, "class_name": "Node", "function_description": "Pre-order traversal method for the Node class that enables visiting the node and its descendants in a root-first order. It provides a way to iterate through the tree structure for hierarchical processing or analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "prefix", "line_number": 321, "body": "def prefix(self) -> Text:\n        \"\"\"\n        The whitespace and comments preceding this node in the input.\n        \"\"\"\n        if not self.children:\n            return \"\"\n        return self.children[0].prefix", "is_method": true, "class_name": "Node", "function_description": "Utility method in the Node class that retrieves the leading whitespace and comments before the node's first child, useful for preserving or analyzing source formatting and code structure."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "prefix", "line_number": 330, "body": "def prefix(self, prefix) -> None:\n        if self.children:\n            self.children[0].prefix = prefix", "is_method": true, "class_name": "Node", "function_description": "Sets the prefix attribute of the first child node if any children exist. This method allows propagation of prefix data from a node to its immediate child in a node hierarchy."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "set_child", "line_number": 334, "body": "def set_child(self, i: int, child: NL) -> None:\n        \"\"\"\n        Equivalent to 'node.children[i] = child'. This method also sets the\n        child's parent attribute appropriately.\n        \"\"\"\n        child.parent = self\n        self.children[i].parent = None\n        self.children[i] = child\n        self.changed()\n        self.invalidate_sibling_maps()", "is_method": true, "class_name": "Node", "function_description": "Sets a specific child node at the given index, updating parent-child relationships accordingly. This maintains tree structure consistency within the Node class."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "insert_child", "line_number": 345, "body": "def insert_child(self, i: int, child: NL) -> None:\n        \"\"\"\n        Equivalent to 'node.children.insert(i, child)'. This method also sets\n        the child's parent attribute appropriately.\n        \"\"\"\n        child.parent = self\n        self.children.insert(i, child)\n        self.changed()\n        self.invalidate_sibling_maps()", "is_method": true, "class_name": "Node", "function_description": "Method of the Node class that inserts a child node at a specified position, updates the child's parent link, and refreshes node state to maintain tree integrity. It supports structured tree manipulation with parent-child relationships."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "append_child", "line_number": 355, "body": "def append_child(self, child: NL) -> None:\n        \"\"\"\n        Equivalent to 'node.children.append(child)'. This method also sets the\n        child's parent attribute appropriately.\n        \"\"\"\n        child.parent = self\n        self.children.append(child)\n        self.changed()\n        self.invalidate_sibling_maps()", "is_method": true, "class_name": "Node", "function_description": "Adds a child node to the current node, establishing parent-child relationships and updating internal state for consistency. This supports tree structure management within the Node class."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "invalidate_sibling_maps", "line_number": 365, "body": "def invalidate_sibling_maps(self) -> None:\n        self.prev_sibling_map: Optional[Dict[int, Optional[NL]]] = None\n        self.next_sibling_map: Optional[Dict[int, Optional[NL]]] = None", "is_method": true, "class_name": "Node", "function_description": "Clears cached mappings of the node's previous and next siblings to ensure sibling references are reset. Useful for maintaining accurate node relationship data after structural changes."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "update_sibling_maps", "line_number": 369, "body": "def update_sibling_maps(self) -> None:\n        _prev: Dict[int, Optional[NL]] = {}\n        _next: Dict[int, Optional[NL]] = {}\n        self.prev_sibling_map = _prev\n        self.next_sibling_map = _next\n        previous: Optional[NL] = None\n        for current in self.children:\n            _prev[id(current)] = previous\n            _next[id(previous)] = current\n            previous = current\n        _next[id(current)] = None", "is_method": true, "class_name": "Node", "function_description": "Updates the Node's internal mappings to link each child node to its immediate previous and next siblings, facilitating efficient sibling traversal within its children."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "__repr__", "line_number": 421, "body": "def __repr__(self) -> str:\n        \"\"\"Return a canonical string representation.\"\"\"\n        from .pgen2.token import tok_name\n\n        assert self.type is not None\n        return \"%s(%s, %r)\" % (\n            self.__class__.__name__,\n            tok_name.get(self.type, self.type),\n            self.value,\n        )", "is_method": true, "class_name": "Leaf", "function_description": "Provides a canonical string representation of a Leaf instance showing its type name and value, facilitating clear and consistent debugging or logging outputs."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "__str__", "line_number": 432, "body": "def __str__(self) -> Text:\n        \"\"\"\n        Return a pretty string representation.\n\n        This reproduces the input source exactly.\n        \"\"\"\n        return self.prefix + str(self.value)", "is_method": true, "class_name": "Leaf", "function_description": "Provides a readable string representation of a Leaf object by concatenating its prefix with its value, reproducing the original input format. Useful for displaying or logging Leaf instances accurately."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "_eq", "line_number": 440, "body": "def _eq(self, other) -> bool:\n        \"\"\"Compare two nodes for equality.\"\"\"\n        return (self.type, self.value) == (other.type, other.value)", "is_method": true, "class_name": "Leaf", "function_description": "Private comparison method of the Leaf class that determines equality by comparing the type and value attributes of two nodes. It supports internal use cases requiring node equivalence checks."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "clone", "line_number": 444, "body": "def clone(self) -> \"Leaf\":\n        assert self.type is not None\n        \"\"\"Return a cloned (deep) copy of self.\"\"\"\n        return Leaf(\n            self.type,\n            self.value,\n            (self.prefix, (self.lineno, self.column)),\n            fixers_applied=self.fixers_applied,\n        )", "is_method": true, "class_name": "Leaf", "function_description": "Utility method of the Leaf class that creates and returns a deep copy of the Leaf instance, preserving its type, value, position, and applied fixers."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "leaves", "line_number": 454, "body": "def leaves(self) -> Iterator[\"Leaf\"]:\n        yield self", "is_method": true, "class_name": "Leaf", "function_description": "Returns an iterator that yields the current Leaf instance itself, supporting uniform traversal or processing in contexts expecting multiple leaves."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "post_order", "line_number": 457, "body": "def post_order(self) -> Iterator[\"Leaf\"]:\n        \"\"\"Return a post-order iterator for the tree.\"\"\"\n        yield self", "is_method": true, "class_name": "Leaf", "function_description": "Returns an iterator that yields the current leaf node in post-order traversal, useful for tree traversal operations in the Leaf class context."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "pre_order", "line_number": 461, "body": "def pre_order(self) -> Iterator[\"Leaf\"]:\n        \"\"\"Return a pre-order iterator for the tree.\"\"\"\n        yield self", "is_method": true, "class_name": "Leaf", "function_description": "Provides a pre-order traversal iterator for the Leaf node, yielding itself as the traversal result. Useful for iterating through tree nodes starting from this leaf in a pre-order manner."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "prefix", "line_number": 466, "body": "def prefix(self) -> Text:\n        \"\"\"\n        The whitespace and comments preceding this token in the input.\n        \"\"\"\n        return self._prefix", "is_method": true, "class_name": "Leaf", "function_description": "Returns the whitespace and comments that appear before the token in the input, providing context or formatting information associated with the token."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "prefix", "line_number": 473, "body": "def prefix(self, prefix) -> None:\n        self.changed()\n        self._prefix = prefix", "is_method": true, "class_name": "Leaf", "function_description": "Sets a prefix string for the Leaf instance and marks it as changed. This method enables dynamic updating of the object's prefix attribute."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "__new__", "line_number": 523, "body": "def __new__(cls, *args, **kwds):\n        \"\"\"Constructor that prevents BasePattern from being instantiated.\"\"\"\n        assert cls is not BasePattern, \"Cannot instantiate BasePattern\"\n        return object.__new__(cls)", "is_method": true, "class_name": "BasePattern", "function_description": "Constructor method in BasePattern that prevents direct instantiation of the base class, enforcing its use only through subclasses."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "__repr__", "line_number": 528, "body": "def __repr__(self) -> Text:\n        assert self.type is not None\n        args = [type_repr(self.type), self.content, self.name]\n        while args and args[-1] is None:\n            del args[-1]\n        return \"%s(%s)\" % (self.__class__.__name__, \", \".join(map(repr, args)))", "is_method": true, "class_name": "BasePattern", "function_description": "Provides a standardized string representation of a BasePattern instance, displaying its type, content, and name attributes for easier debugging and logging."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "optimize", "line_number": 538, "body": "def optimize(self) -> \"BasePattern\":\n        \"\"\"\n        A subclass can define this as a hook for optimizations.\n\n        Returns either self or another node with the same effect.\n        \"\"\"\n        return self", "is_method": true, "class_name": "BasePattern", "function_description": "Core utility method of the BasePattern class that provides a hook for subclasses to implement optimizations, returning an equivalent pattern node for improved efficiency or the original pattern if no changes are made."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "match", "line_number": 546, "body": "def match(self, node: NL, results: Optional[_Results] = None) -> bool:\n        \"\"\"\n        Does this pattern exactly match a node?\n\n        Returns True if it matches, False if not.\n\n        If results is not None, it must be a dict which will be\n        updated with the nodes matching named subpatterns.\n\n        Default implementation for non-wildcard patterns.\n        \"\"\"\n        if self.type is not None and node.type != self.type:\n            return False\n        if self.content is not None:\n            r: Optional[_Results] = None\n            if results is not None:\n                r = {}\n            if not self._submatch(node, r):\n                return False\n            if r:\n                assert results is not None\n                results.update(r)\n        if results is not None and self.name:\n            results[self.name] = node\n        return True", "is_method": true, "class_name": "BasePattern", "function_description": "Provides a way to determine if a given node exactly matches the pattern, optionally capturing named subpattern matches into a results dictionary for further use."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "match_seq", "line_number": 572, "body": "def match_seq(self, nodes: List[NL], results: Optional[_Results] = None) -> bool:\n        \"\"\"\n        Does this pattern exactly match a sequence of nodes?\n\n        Default implementation for non-wildcard patterns.\n        \"\"\"\n        if len(nodes) != 1:\n            return False\n        return self.match(nodes[0], results)", "is_method": true, "class_name": "BasePattern", "function_description": "Core method of the BasePattern class that checks if a pattern exactly matches a single-node sequence, primarily used for precise pattern matching in sequences without wildcards."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "generate_matches", "line_number": 582, "body": "def generate_matches(self, nodes: List[NL]) -> Iterator[Tuple[int, _Results]]:\n        \"\"\"\n        Generator yielding all matches for this pattern.\n\n        Default implementation for non-wildcard patterns.\n        \"\"\"\n        r: _Results = {}\n        if nodes and self.match(nodes[0], r):\n            yield 1, r", "is_method": true, "class_name": "BasePattern", "function_description": "Method of BasePattern that generates all matches of a pattern against a given node list, yielding match results along with the count of matched nodes."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "match", "line_number": 619, "body": "def match(self, node: NL, results=None):\n        \"\"\"Override match() to insist on a leaf node.\"\"\"\n        if not isinstance(node, Leaf):\n            return False\n        return BasePattern.match(self, node, results)", "is_method": true, "class_name": "LeafPattern", "function_description": "Checks if a given node is a leaf and matches it against a pattern, enforcing that only leaf nodes are considered valid matches. Useful for pattern matching in tree structures where leaves have special significance."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "_submatch", "line_number": 625, "body": "def _submatch(self, node, results=None):\n        \"\"\"\n        Match the pattern's content to the node's children.\n\n        This assumes the node type matches and self.content is not None.\n\n        Returns True if it matches, False if not.\n\n        If results is not None, it must be a dict which will be\n        updated with the nodes matching named subpatterns.\n\n        When returning False, the results dict may still be updated.\n        \"\"\"\n        return self.content == node.value", "is_method": true, "class_name": "LeafPattern", "function_description": "Private method of LeafPattern that checks if the pattern's content exactly matches a node's value and optionally collects named subpattern matches. It provides node-level pattern matching functionality within a larger matching process."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "_submatch", "line_number": 679, "body": "def _submatch(self, node, results=None) -> bool:\n        \"\"\"\n        Match the pattern's content to the node's children.\n\n        This assumes the node type matches and self.content is not None.\n\n        Returns True if it matches, False if not.\n\n        If results is not None, it must be a dict which will be\n        updated with the nodes matching named subpatterns.\n\n        When returning False, the results dict may still be updated.\n        \"\"\"\n        if self.wildcards:\n            for c, r in generate_matches(self.content, node.children):\n                if c == len(node.children):\n                    if results is not None:\n                        results.update(r)\n                    return True\n            return False\n        if len(self.content) != len(node.children):\n            return False\n        for subpattern, child in zip(self.content, node.children):\n            if not subpattern.match(child, results):\n                return False\n        return True", "is_method": true, "class_name": "NodePattern", "function_description": "Core internal method of the NodePattern class that checks if a pattern's content matches a node's children, optionally capturing named subpattern matches, and returns whether the match is successful."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "optimize", "line_number": 768, "body": "def optimize(self) -> Any:\n        \"\"\"Optimize certain stacked wildcard patterns.\"\"\"\n        subpattern = None\n        if (\n            self.content is not None\n            and len(self.content) == 1\n            and len(self.content[0]) == 1\n        ):\n            subpattern = self.content[0][0]\n        if self.min == 1 and self.max == 1:\n            if self.content is None:\n                return NodePattern(name=self.name)\n            if subpattern is not None and self.name == subpattern.name:\n                return subpattern.optimize()\n        if (\n            self.min <= 1\n            and isinstance(subpattern, WildcardPattern)\n            and subpattern.min <= 1\n            and self.name == subpattern.name\n        ):\n            return WildcardPattern(\n                subpattern.content,\n                self.min * subpattern.min,\n                self.max * subpattern.max,\n                subpattern.name,\n            )\n        return self", "is_method": true, "class_name": "WildcardPattern", "function_description": "Core method of WildcardPattern that simplifies nested wildcard patterns by merging or reducing redundant stacked patterns to improve pattern matching efficiency."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "match", "line_number": 796, "body": "def match(self, node, results=None) -> bool:\n        \"\"\"Does this pattern exactly match a node?\"\"\"\n        return self.match_seq([node], results)", "is_method": true, "class_name": "WildcardPattern", "function_description": "Utility method of the WildcardPattern class that checks if the pattern exactly matches a given node, optionally collecting matching results. It acts as a simple entry point for node pattern matching."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "match_seq", "line_number": 800, "body": "def match_seq(self, nodes, results=None) -> bool:\n        \"\"\"Does this pattern exactly match a sequence of nodes?\"\"\"\n        for c, r in self.generate_matches(nodes):\n            if c == len(nodes):\n                if results is not None:\n                    results.update(r)\n                    if self.name:\n                        results[self.name] = list(nodes)\n                return True\n        return False", "is_method": true, "class_name": "WildcardPattern", "function_description": "Core method of WildcardPattern that checks if the pattern exactly matches a given sequence of nodes, optionally capturing and returning the matching results for further use."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "generate_matches", "line_number": 811, "body": "def generate_matches(self, nodes) -> Iterator[Tuple[int, _Results]]:\n        \"\"\"\n        Generator yielding matches for a sequence of nodes.\n\n        Args:\n            nodes: sequence of nodes\n\n        Yields:\n            (count, results) tuples where:\n            count: the match comprises nodes[:count];\n            results: dict containing named submatches.\n        \"\"\"\n        if self.content is None:\n            # Shortcut for special case (see __init__.__doc__)\n            for count in range(self.min, 1 + min(len(nodes), self.max)):\n                r = {}\n                if self.name:\n                    r[self.name] = nodes[:count]\n                yield count, r\n        elif self.name == \"bare_name\":\n            yield self._bare_name_matches(nodes)\n        else:\n            # The reason for this is that hitting the recursion limit usually\n            # results in some ugly messages about how RuntimeErrors are being\n            # ignored. We only have to do this on CPython, though, because other\n            # implementations don't have this nasty bug in the first place.\n            if hasattr(sys, \"getrefcount\"):\n                save_stderr = sys.stderr\n                sys.stderr = StringIO()\n            try:\n                for count, r in self._recursive_matches(nodes, 0):\n                    if self.name:\n                        r[self.name] = nodes[:count]\n                    yield count, r\n            except RuntimeError:\n                # We fall back to the iterative pattern matching scheme if the recursive\n                # scheme hits the recursion limit.\n                for count, r in self._iterative_matches(nodes):\n                    if self.name:\n                        r[self.name] = nodes[:count]\n                    yield count, r\n            finally:\n                if hasattr(sys, \"getrefcount\"):\n                    sys.stderr = save_stderr", "is_method": true, "class_name": "WildcardPattern", "function_description": "Generates all matching prefixes of a given node sequence according to the wildcard pattern, yielding match lengths and named submatch details; supports recursive and iterative matching strategies with fallback on recursion limits."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "_iterative_matches", "line_number": 856, "body": "def _iterative_matches(self, nodes) -> Iterator[Tuple[int, _Results]]:\n        \"\"\"Helper to iteratively yield the matches.\"\"\"\n        nodelen = len(nodes)\n        if 0 >= self.min:\n            yield 0, {}\n\n        results = []\n        # generate matches that use just one alt from self.content\n        for alt in self.content:\n            for c, r in generate_matches(alt, nodes):\n                yield c, r\n                results.append((c, r))\n\n        # for each match, iterate down the nodes\n        while results:\n            new_results = []\n            for c0, r0 in results:\n                # stop if the entire set of nodes has been matched\n                if c0 < nodelen and c0 <= self.max:\n                    for alt in self.content:\n                        for c1, r1 in generate_matches(alt, nodes[c0:]):\n                            if c1 > 0:\n                                r = {}\n                                r.update(r0)\n                                r.update(r1)\n                                yield c0 + c1, r\n                                new_results.append((c0 + c1, r))\n            results = new_results", "is_method": true, "class_name": "WildcardPattern", "function_description": "Helper method of the WildcardPattern class that iteratively generates all possible matching spans and captures their results within specified minimum and maximum bounds for pattern matching. It supports complex pattern matching by combining alternative sub-pattern matches over nodes."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "_bare_name_matches", "line_number": 885, "body": "def _bare_name_matches(self, nodes) -> Tuple[int, _Results]:\n        \"\"\"Special optimized matcher for bare_name.\"\"\"\n        count = 0\n        r = {}  # type: _Results\n        done = False\n        max = len(nodes)\n        while not done and count < max:\n            done = True\n            for leaf in self.content:\n                if leaf[0].match(nodes[count], r):\n                    count += 1\n                    done = False\n                    break\n        assert self.name is not None\n        r[self.name] = nodes[:count]\n        return count, r", "is_method": true, "class_name": "WildcardPattern", "function_description": "Core method of the WildcardPattern class that matches a sequence of nodes against its pattern's content, returning the number of matched nodes and their associated results for use in pattern matching workflows."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "_recursive_matches", "line_number": 902, "body": "def _recursive_matches(self, nodes, count) -> Iterator[Tuple[int, _Results]]:\n        \"\"\"Helper to recursively yield the matches.\"\"\"\n        assert self.content is not None\n        if count >= self.min:\n            yield 0, {}\n        if count < self.max:\n            for alt in self.content:\n                for c0, r0 in generate_matches(alt, nodes):\n                    for c1, r1 in self._recursive_matches(nodes[c0:], count + 1):\n                        r = {}\n                        r.update(r0)\n                        r.update(r1)\n                        yield c0 + c1, r", "is_method": true, "class_name": "WildcardPattern", "function_description": "Helper method of WildcardPattern that recursively generates all possible pattern matches within specified repetition limits, enabling complex pattern matching by combining sub-patterns in a flexible search process."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "match", "line_number": 931, "body": "def match(self, node, results=None) -> bool:\n        # We never match a node in its entirety\n        return False", "is_method": true, "class_name": "NegatedPattern", "function_description": "Returns False to indicate that no node should ever fully match the negated pattern, serving as a definitive non-match behavior in pattern matching contexts."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "match_seq", "line_number": 935, "body": "def match_seq(self, nodes, results=None) -> bool:\n        # We only match an empty sequence of nodes in its entirety\n        return len(nodes) == 0", "is_method": true, "class_name": "NegatedPattern", "function_description": "Method of NegatedPattern that checks if the provided sequence of nodes is empty, matching only when the entire sequence has no elements. It is useful for pattern matching scenarios requiring negation of any node presence."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pytree.py", "function": "generate_matches", "line_number": 939, "body": "def generate_matches(self, nodes) -> Iterator[Tuple[int, _Results]]:\n        if self.content is None:\n            # Return a match if there is an empty sequence\n            if len(nodes) == 0:\n                yield 0, {}\n        else:\n            # Return a match if the argument pattern has no matches\n            for c, r in self.content.generate_matches(nodes):\n                return\n            yield 0, {}", "is_method": true, "class_name": "NegatedPattern", "function_description": "Core method of the NegatedPattern class that yields a match only if its inner pattern does not match the given nodes, enabling pattern negation in complex matching operations."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pygram.py", "function": "initialize", "line_number": 157, "body": "def initialize(cache_dir: Union[str, \"os.PathLike[str]\", None] = None) -> None:\n    global python_grammar\n    global python_grammar_no_print_statement\n    global python_grammar_no_print_statement_no_exec_statement\n    global python_grammar_no_print_statement_no_exec_statement_async_keywords\n    global python_symbols\n    global pattern_grammar\n    global pattern_symbols\n\n    # The grammar file\n    _GRAMMAR_FILE = os.path.join(os.path.dirname(__file__), \"Grammar.txt\")\n    _PATTERN_GRAMMAR_FILE = os.path.join(\n        os.path.dirname(__file__), \"PatternGrammar.txt\"\n    )\n\n    # Python 2\n    python_grammar = driver.load_packaged_grammar(\"blib2to3\", _GRAMMAR_FILE, cache_dir)\n\n    python_symbols = _python_symbols(python_grammar)\n\n    # Python 2 + from __future__ import print_function\n    python_grammar_no_print_statement = python_grammar.copy()\n    del python_grammar_no_print_statement.keywords[\"print\"]\n\n    # Python 3.0-3.6\n    python_grammar_no_print_statement_no_exec_statement = python_grammar.copy()\n    del python_grammar_no_print_statement_no_exec_statement.keywords[\"print\"]\n    del python_grammar_no_print_statement_no_exec_statement.keywords[\"exec\"]\n\n    # Python 3.7+\n    python_grammar_no_print_statement_no_exec_statement_async_keywords = (\n        python_grammar_no_print_statement_no_exec_statement.copy()\n    )\n    python_grammar_no_print_statement_no_exec_statement_async_keywords.async_keywords = (\n        True\n    )\n\n    pattern_grammar = driver.load_packaged_grammar(\n        \"blib2to3\", _PATTERN_GRAMMAR_FILE, cache_dir\n    )\n    pattern_symbols = _pattern_symbols(pattern_grammar)", "is_method": false, "function_description": "Function that initializes and configures various Python grammar objects and related symbols used for parsing different Python versions and syntax variants, optionally utilizing a cache directory for grammar loading."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/literals.py", "function": "escape", "line_number": 25, "body": "def escape(m: Match[Text]) -> Text:\n    all, tail = m.group(0, 1)\n    assert all.startswith(\"\\\\\")\n    esc = simple_escapes.get(tail)\n    if esc is not None:\n        return esc\n    if tail.startswith(\"x\"):\n        hexes = tail[1:]\n        if len(hexes) < 2:\n            raise ValueError(\"invalid hex string escape ('\\\\%s')\" % tail)\n        try:\n            i = int(hexes, 16)\n        except ValueError:\n            raise ValueError(\"invalid hex string escape ('\\\\%s')\" % tail) from None\n    else:\n        try:\n            i = int(tail, 8)\n        except ValueError:\n            raise ValueError(\"invalid octal string escape ('\\\\%s')\" % tail) from None\n    return chr(i)", "is_method": false, "function_description": "Function that converts regex match objects representing escape sequences into their corresponding characters, supporting simple, hex, and octal escapes for correct string interpretation."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/literals.py", "function": "evalString", "line_number": 47, "body": "def evalString(s: Text) -> Text:\n    assert s.startswith(\"'\") or s.startswith('\"'), repr(s[:1])\n    q = s[0]\n    if s[:3] == q * 3:\n        q = q * 3\n    assert s.endswith(q), repr(s[-len(q) :])\n    assert len(s) >= 2 * len(q)\n    s = s[len(q) : -len(q)]\n    return re.sub(r\"\\\\(\\'|\\\"|\\\\|[abfnrtv]|x.{0,2}|[0-7]{1,3})\", escape, s)", "is_method": false, "function_description": "Function that processes a quoted string literal by stripping its surrounding quotes and interpreting escape sequences, returning the evaluated string content."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/grammar.py", "function": "dump", "line_number": 98, "body": "def dump(self, filename: Path) -> None:\n        \"\"\"Dump the grammar tables to a pickle file.\"\"\"\n\n        # mypyc generates objects that don't have a __dict__, but they\n        # do have __getstate__ methods that will return an equivalent\n        # dictionary\n        if hasattr(self, \"__dict__\"):\n            d = self.__dict__\n        else:\n            d = self.__getstate__()  # type: ignore\n\n        with tempfile.NamedTemporaryFile(\n            dir=os.path.dirname(filename), delete=False\n        ) as f:\n            pickle.dump(d, f, pickle.HIGHEST_PROTOCOL)\n        os.replace(f.name, filename)", "is_method": true, "class_name": "Grammar", "function_description": "Provides functionality to serialize and save the Grammar object's internal state to a specified file using a safe temporary file replacement method. This enables persistent storage and later retrieval of grammar tables."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/grammar.py", "function": "_update", "line_number": 115, "body": "def _update(self, attrs: Dict[str, Any]) -> None:\n        for k, v in attrs.items():\n            setattr(self, k, v)", "is_method": true, "class_name": "Grammar", "function_description": "Internal helper method of the Grammar class that updates multiple attributes of an instance based on a given dictionary of key-value pairs. It provides a convenient way to modify the object's state in bulk."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/grammar.py", "function": "load", "line_number": 119, "body": "def load(self, filename: Path) -> None:\n        \"\"\"Load the grammar tables from a pickle file.\"\"\"\n        with open(filename, \"rb\") as f:\n            d = pickle.load(f)\n        self._update(d)", "is_method": true, "class_name": "Grammar", "function_description": "Loads grammar configuration data from a pickle file to update the Grammar object's internal tables, enabling it to utilize pre-saved grammar rules and structures."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/grammar.py", "function": "loads", "line_number": 125, "body": "def loads(self, pkl: bytes) -> None:\n        \"\"\"Load the grammar tables from a pickle bytes object.\"\"\"\n        self._update(pickle.loads(pkl))", "is_method": true, "class_name": "Grammar", "function_description": "Method of the Grammar class that loads and updates grammar tables from a pickle-serialized bytes object, enabling restoration of grammar state from serialized data."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/grammar.py", "function": "copy", "line_number": 129, "body": "def copy(self: _P) -> _P:\n        \"\"\"\n        Copy the grammar.\n        \"\"\"\n        new = self.__class__()\n        for dict_attr in (\n            \"symbol2number\",\n            \"number2symbol\",\n            \"dfas\",\n            \"keywords\",\n            \"tokens\",\n            \"symbol2label\",\n        ):\n            setattr(new, dict_attr, getattr(self, dict_attr).copy())\n        new.labels = self.labels[:]\n        new.states = self.states[:]\n        new.start = self.start\n        new.async_keywords = self.async_keywords\n        return new", "is_method": true, "class_name": "Grammar", "function_description": "Creates and returns a deep copy of the Grammar object, duplicating all its internal attributes. This allows safe modifications without affecting the original grammar instance."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/grammar.py", "function": "report", "line_number": 149, "body": "def report(self) -> None:\n        \"\"\"Dump the grammar tables to standard output, for debugging.\"\"\"\n        from pprint import pprint\n\n        print(\"s2n\")\n        pprint(self.symbol2number)\n        print(\"n2s\")\n        pprint(self.number2symbol)\n        print(\"states\")\n        pprint(self.states)\n        print(\"dfas\")\n        pprint(self.dfas)\n        print(\"labels\")\n        pprint(self.labels)\n        print(\"start\", self.start)", "is_method": true, "class_name": "Grammar", "function_description": "Provides a debugging utility in the Grammar class that outputs all internal grammar tables and attributes to the console for inspection. It helps developers understand and verify the grammar's structure during development."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/parse.py", "function": "lam_sub", "line_number": 37, "body": "def lam_sub(grammar: Grammar, node: RawNode) -> NL:\n    assert node[3] is not None\n    return Node(type=node[0], children=node[3], context=node[2])", "is_method": false, "function_description": "Transforms a raw parse node into a structured node with type, children, and context based on a grammar. Useful for processing and converting parsed data into a normalized language representation."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/parse.py", "function": "setup", "line_number": 119, "body": "def setup(self, start: Optional[int] = None) -> None:\n        \"\"\"Prepare for parsing.\n\n        This *must* be called before starting to parse.\n\n        The optional argument is an alternative start symbol; it\n        defaults to the grammar's start symbol.\n\n        You can use a Parser instance to parse any number of programs;\n        each time you call setup() the parser is reset to an initial\n        state determined by the (implicit or explicit) start symbol.\n\n        \"\"\"\n        if start is None:\n            start = self.grammar.start\n        # Each stack entry is a tuple: (dfa, state, node).\n        # A node is a tuple: (type, value, context, children),\n        # where children is a list of nodes or None, and context may be None.\n        newnode: RawNode = (start, None, None, [])\n        stackentry = (self.grammar.dfas[start], 0, newnode)\n        self.stack: List[Tuple[DFAS, int, RawNode]] = [stackentry]\n        self.rootnode: Optional[NL] = None\n        self.used_names: Set[str] = set()", "is_method": true, "class_name": "Parser", "function_description": "Resets the parser to its initial state with an optional start symbol, preparing it to parse new inputs. Enables repeated parsing sessions by reinitializing internal state and parse stack."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/parse.py", "function": "addtoken", "line_number": 143, "body": "def addtoken(self, type: int, value: Optional[Text], context: Context) -> bool:\n        \"\"\"Add a token; return True iff this is the end of the program.\"\"\"\n        # Map from token to label\n        ilabel = self.classify(type, value, context)\n        # Loop until the token is shifted; may raise exceptions\n        while True:\n            dfa, state, node = self.stack[-1]\n            states, first = dfa\n            arcs = states[state]\n            # Look for a state with this label\n            for i, newstate in arcs:\n                t, v = self.grammar.labels[i]\n                if ilabel == i:\n                    # Look it up in the list of labels\n                    assert t < 256\n                    # Shift a token; we're done with it\n                    self.shift(type, value, newstate, context)\n                    # Pop while we are in an accept-only state\n                    state = newstate\n                    while states[state] == [(0, state)]:\n                        self.pop()\n                        if not self.stack:\n                            # Done parsing!\n                            return True\n                        dfa, state, node = self.stack[-1]\n                        states, first = dfa\n                    # Done with this token\n                    return False\n                elif t >= 256:\n                    # See if it's a symbol and if we're in its first set\n                    itsdfa = self.grammar.dfas[t]\n                    itsstates, itsfirst = itsdfa\n                    if ilabel in itsfirst:\n                        # Push a symbol\n                        self.push(t, self.grammar.dfas[t], newstate, context)\n                        break  # To continue the outer while loop\n            else:\n                if (0, state) in arcs:\n                    # An accepting state, pop it and try something else\n                    self.pop()\n                    if not self.stack:\n                        # Done parsing, but another token is input\n                        raise ParseError(\"too much input\", type, value, context)\n                else:\n                    # No success finding a transition\n                    raise ParseError(\"bad input\", type, value, context)", "is_method": true, "class_name": "Parser", "function_description": "Core parsing method of the Parser class that processes input tokens, manages parser state transitions, and determines when parsing of the entire input is complete. It enables syntactic analysis by shifting tokens and handling grammar-driven state changes."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/parse.py", "function": "classify", "line_number": 190, "body": "def classify(self, type: int, value: Optional[Text], context: Context) -> int:\n        \"\"\"Turn a token into a label.  (Internal)\"\"\"\n        if type == token.NAME:\n            # Keep a listing of all used names\n            assert value is not None\n            self.used_names.add(value)\n            # Check for reserved words\n            ilabel = self.grammar.keywords.get(value)\n            if ilabel is not None:\n                return ilabel\n        ilabel = self.grammar.tokens.get(type)\n        if ilabel is None:\n            raise ParseError(\"bad token\", type, value, context)\n        return ilabel", "is_method": true, "class_name": "Parser", "function_description": "Utility method of the Parser class that maps a token's type and value to a corresponding grammar label, identifying reserved keywords and validating tokens during parsing. It supports token classification essential for syntax analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/parse.py", "function": "shift", "line_number": 205, "body": "def shift(\n        self, type: int, value: Optional[Text], newstate: int, context: Context\n    ) -> None:\n        \"\"\"Shift a token.  (Internal)\"\"\"\n        dfa, state, node = self.stack[-1]\n        assert value is not None\n        assert context is not None\n        rawnode: RawNode = (type, value, context, None)\n        newnode = self.convert(self.grammar, rawnode)\n        if newnode is not None:\n            assert node[-1] is not None\n            node[-1].append(newnode)\n        self.stack[-1] = (dfa, newstate, node)", "is_method": true, "class_name": "Parser", "function_description": "Internal method of the Parser class that advances the parser state by shifting a token and updating the parse stack with a new syntax node. It supports incremental parsing within a given parsing context."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/parse.py", "function": "push", "line_number": 219, "body": "def push(self, type: int, newdfa: DFAS, newstate: int, context: Context) -> None:\n        \"\"\"Push a nonterminal.  (Internal)\"\"\"\n        dfa, state, node = self.stack[-1]\n        newnode: RawNode = (type, None, context, [])\n        self.stack[-1] = (dfa, newstate, node)\n        self.stack.append((newdfa, 0, newnode))", "is_method": true, "class_name": "Parser", "function_description": "Internal method of the Parser class that manages parser state by pushing a new nonterminal onto its stack, facilitating the transition to a new parsing context. It supports state tracking during the parsing process."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/parse.py", "function": "pop", "line_number": 226, "body": "def pop(self) -> None:\n        \"\"\"Pop a nonterminal.  (Internal)\"\"\"\n        popdfa, popstate, popnode = self.stack.pop()\n        newnode = self.convert(self.grammar, popnode)\n        if newnode is not None:\n            if self.stack:\n                dfa, state, node = self.stack[-1]\n                assert node[-1] is not None\n                node[-1].append(newnode)\n            else:\n                self.rootnode = newnode\n                self.rootnode.used_names = self.used_names", "is_method": true, "class_name": "Parser", "function_description": "Core method of the Parser class that processes and integrates a popped nonterminal node into the parse tree, updating the current parsing state or establishing the root parse node when at the top level."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/token.py", "function": "ISTERMINAL", "line_number": 80, "body": "def ISTERMINAL(x: int) -> bool:\n    return x < NT_OFFSET", "is_method": false, "function_description": "Determines if an integer represents a terminal symbol by comparing it against a predefined offset constant. Useful in parsing or grammar-related contexts to distinguish terminal from non-terminal tokens."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/token.py", "function": "ISNONTERMINAL", "line_number": 84, "body": "def ISNONTERMINAL(x: int) -> bool:\n    return x >= NT_OFFSET", "is_method": false, "function_description": "This function determines if a given integer represents a nonterminal symbol based on a threshold value NT_OFFSET. It supports parsing or grammar processing by identifying nonterminal tokens."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/token.py", "function": "ISEOF", "line_number": 88, "body": "def ISEOF(x: int) -> bool:\n    return x == ENDMARKER", "is_method": false, "function_description": "Returns True if the integer input equals the sentinel end marker, indicating the end of a sequence or stream. Useful for detecting termination conditions in parsing or iteration processes."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/conv.py", "function": "run", "line_number": 49, "body": "def run(self, graminit_h, graminit_c):\n        \"\"\"Load the grammar tables from the text files written by pgen.\"\"\"\n        self.parse_graminit_h(graminit_h)\n        self.parse_graminit_c(graminit_c)\n        self.finish_off()", "is_method": true, "class_name": "Converter", "function_description": "Utility method of the Converter class that loads and processes grammar tables from specified text files to initialize its internal state for further grammar conversions or analyses."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/conv.py", "function": "parse_graminit_h", "line_number": 55, "body": "def parse_graminit_h(self, filename):\n        \"\"\"Parse the .h file written by pgen.  (Internal)\n\n        This file is a sequence of #define statements defining the\n        nonterminals of the grammar as numbers.  We build two tables\n        mapping the numbers to names and back.\n\n        \"\"\"\n        try:\n            f = open(filename)\n        except OSError as err:\n            print(\"Can't open %s: %s\" % (filename, err))\n            return False\n        self.symbol2number = {}\n        self.number2symbol = {}\n        lineno = 0\n        for line in f:\n            lineno += 1\n            mo = re.match(r\"^#define\\s+(\\w+)\\s+(\\d+)$\", line)\n            if not mo and line.strip():\n                print(\"%s(%s): can't parse %s\" % (filename, lineno, line.strip()))\n            else:\n                symbol, number = mo.groups()\n                number = int(number)\n                assert symbol not in self.symbol2number\n                assert number not in self.number2symbol\n                self.symbol2number[symbol] = number\n                self.number2symbol[number] = symbol\n        return True", "is_method": true, "class_name": "Converter", "function_description": "Parses a grammar header file to create bidirectional mappings between grammar symbols and their numeric codes. This enables translating grammar nonterminals to their identifiers and vice versa for parsing tasks."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/conv.py", "function": "parse_graminit_c", "line_number": 85, "body": "def parse_graminit_c(self, filename):\n        \"\"\"Parse the .c file written by pgen.  (Internal)\n\n        The file looks as follows.  The first two lines are always this:\n\n        #include \"pgenheaders.h\"\n        #include \"grammar.h\"\n\n        After that come four blocks:\n\n        1) one or more state definitions\n        2) a table defining dfas\n        3) a table defining labels\n        4) a struct defining the grammar\n\n        A state definition has the following form:\n        - one or more arc arrays, each of the form:\n          static arc arcs_<n>_<m>[<k>] = {\n                  {<i>, <j>},\n                  ...\n          };\n        - followed by a state array, of the form:\n          static state states_<s>[<t>] = {\n                  {<k>, arcs_<n>_<m>},\n                  ...\n          };\n\n        \"\"\"\n        try:\n            f = open(filename)\n        except OSError as err:\n            print(\"Can't open %s: %s\" % (filename, err))\n            return False\n        # The code below essentially uses f's iterator-ness!\n        lineno = 0\n\n        # Expect the two #include lines\n        lineno, line = lineno + 1, next(f)\n        assert line == '#include \"pgenheaders.h\"\\n', (lineno, line)\n        lineno, line = lineno + 1, next(f)\n        assert line == '#include \"grammar.h\"\\n', (lineno, line)\n\n        # Parse the state definitions\n        lineno, line = lineno + 1, next(f)\n        allarcs = {}\n        states = []\n        while line.startswith(\"static arc \"):\n            while line.startswith(\"static arc \"):\n                mo = re.match(r\"static arc arcs_(\\d+)_(\\d+)\\[(\\d+)\\] = {$\", line)\n                assert mo, (lineno, line)\n                n, m, k = list(map(int, mo.groups()))\n                arcs = []\n                for _ in range(k):\n                    lineno, line = lineno + 1, next(f)\n                    mo = re.match(r\"\\s+{(\\d+), (\\d+)},$\", line)\n                    assert mo, (lineno, line)\n                    i, j = list(map(int, mo.groups()))\n                    arcs.append((i, j))\n                lineno, line = lineno + 1, next(f)\n                assert line == \"};\\n\", (lineno, line)\n                allarcs[(n, m)] = arcs\n                lineno, line = lineno + 1, next(f)\n            mo = re.match(r\"static state states_(\\d+)\\[(\\d+)\\] = {$\", line)\n            assert mo, (lineno, line)\n            s, t = list(map(int, mo.groups()))\n            assert s == len(states), (lineno, line)\n            state = []\n            for _ in range(t):\n                lineno, line = lineno + 1, next(f)\n                mo = re.match(r\"\\s+{(\\d+), arcs_(\\d+)_(\\d+)},$\", line)\n                assert mo, (lineno, line)\n                k, n, m = list(map(int, mo.groups()))\n                arcs = allarcs[n, m]\n                assert k == len(arcs), (lineno, line)\n                state.append(arcs)\n            states.append(state)\n            lineno, line = lineno + 1, next(f)\n            assert line == \"};\\n\", (lineno, line)\n            lineno, line = lineno + 1, next(f)\n        self.states = states\n\n        # Parse the dfas\n        dfas = {}\n        mo = re.match(r\"static dfa dfas\\[(\\d+)\\] = {$\", line)\n        assert mo, (lineno, line)\n        ndfas = int(mo.group(1))\n        for i in range(ndfas):\n            lineno, line = lineno + 1, next(f)\n            mo = re.match(r'\\s+{(\\d+), \"(\\w+)\", (\\d+), (\\d+), states_(\\d+),$', line)\n            assert mo, (lineno, line)\n            symbol = mo.group(2)\n            number, x, y, z = list(map(int, mo.group(1, 3, 4, 5)))\n            assert self.symbol2number[symbol] == number, (lineno, line)\n            assert self.number2symbol[number] == symbol, (lineno, line)\n            assert x == 0, (lineno, line)\n            state = states[z]\n            assert y == len(state), (lineno, line)\n            lineno, line = lineno + 1, next(f)\n            mo = re.match(r'\\s+(\"(?:\\\\\\d\\d\\d)*\")},$', line)\n            assert mo, (lineno, line)\n            first = {}\n            rawbitset = eval(mo.group(1))\n            for i, c in enumerate(rawbitset):\n                byte = ord(c)\n                for j in range(8):\n                    if byte & (1 << j):\n                        first[i * 8 + j] = 1\n            dfas[number] = (state, first)\n        lineno, line = lineno + 1, next(f)\n        assert line == \"};\\n\", (lineno, line)\n        self.dfas = dfas\n\n        # Parse the labels\n        labels = []\n        lineno, line = lineno + 1, next(f)\n        mo = re.match(r\"static label labels\\[(\\d+)\\] = {$\", line)\n        assert mo, (lineno, line)\n        nlabels = int(mo.group(1))\n        for i in range(nlabels):\n            lineno, line = lineno + 1, next(f)\n            mo = re.match(r'\\s+{(\\d+), (0|\"\\w+\")},$', line)\n            assert mo, (lineno, line)\n            x, y = mo.groups()\n            x = int(x)\n            if y == \"0\":\n                y = None\n            else:\n                y = eval(y)\n            labels.append((x, y))\n        lineno, line = lineno + 1, next(f)\n        assert line == \"};\\n\", (lineno, line)\n        self.labels = labels\n\n        # Parse the grammar struct\n        lineno, line = lineno + 1, next(f)\n        assert line == \"grammar _PyParser_Grammar = {\\n\", (lineno, line)\n        lineno, line = lineno + 1, next(f)\n        mo = re.match(r\"\\s+(\\d+),$\", line)\n        assert mo, (lineno, line)\n        ndfas = int(mo.group(1))\n        assert ndfas == len(self.dfas)\n        lineno, line = lineno + 1, next(f)\n        assert line == \"\\tdfas,\\n\", (lineno, line)\n        lineno, line = lineno + 1, next(f)\n        mo = re.match(r\"\\s+{(\\d+), labels},$\", line)\n        assert mo, (lineno, line)\n        nlabels = int(mo.group(1))\n        assert nlabels == len(self.labels), (lineno, line)\n        lineno, line = lineno + 1, next(f)\n        mo = re.match(r\"\\s+(\\d+)$\", line)\n        assert mo, (lineno, line)\n        start = int(mo.group(1))\n        assert start in self.number2symbol, (lineno, line)\n        self.start = start\n        lineno, line = lineno + 1, next(f)\n        assert line == \"};\\n\", (lineno, line)\n        try:\n            lineno, line = lineno + 1, next(f)\n        except StopIteration:\n            pass\n        else:\n            assert 0, (lineno, line)", "is_method": true, "class_name": "Converter", "function_description": "Method of the Converter class that parses a specialized .c file to reconstruct and populate grammar-related internal data structures representing states, dfas, labels, and the grammar's start symbol. It enables converting generated parser code back into in-memory grammar representations."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/conv.py", "function": "finish_off", "line_number": 248, "body": "def finish_off(self):\n        \"\"\"Create additional useful structures.  (Internal).\"\"\"\n        self.keywords = {}  # map from keyword strings to arc labels\n        self.tokens = {}  # map from numeric token values to arc labels\n        for ilabel, (type, value) in enumerate(self.labels):\n            if type == token.NAME and value is not None:\n                self.keywords[value] = ilabel\n            elif value is None:\n                self.tokens[type] = ilabel", "is_method": true, "class_name": "Converter", "function_description": "Internal method that builds mappings from keyword strings and token values to arc labels, supporting lookup and classification of tokens within the Converter class."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "group", "line_number": 62, "body": "def group(*choices):\n    return \"(\" + \"|\".join(choices) + \")\"", "is_method": false, "function_description": "Utility function that combines multiple string choices into a grouped pattern with alternation, typically used for building regular expression patterns to match any of the specified options."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "any", "line_number": 66, "body": "def any(*choices):\n    return group(*choices) + \"*\"", "is_method": false, "function_description": "This function creates a pattern that matches any one of the given choices one or more times. It serves as a utility to build flexible matching patterns from multiple options."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "maybe", "line_number": 70, "body": "def maybe(*choices):\n    return group(*choices) + \"?\"", "is_method": false, "function_description": "Function that constructs a pattern representing an optional choice among given options by grouping them and appending a question mark. It can be used to define optional components in pattern matching or parsing contexts."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "_combinations", "line_number": 74, "body": "def _combinations(*l):\n    return set(x + y for x in l for y in l + (\"\",) if x.casefold() != y.casefold())", "is_method": false, "function_description": "Utility function that generates a set of unique case-insensitive concatenations from the given input strings, useful for creating combined string variants with optional suffixes."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "printtoken", "line_number": 184, "body": "def printtoken(type, token, xxx_todo_changeme, xxx_todo_changeme1, line):  # for testing\n    (srow, scol) = xxx_todo_changeme\n    (erow, ecol) = xxx_todo_changeme1\n    print(\n        \"%d,%d-%d,%d:\\t%s\\t%s\" % (srow, scol, erow, ecol, tok_name[type], repr(token))\n    )", "is_method": false, "function_description": "Utility function that prints detailed information about a token, including its position and type, primarily for debugging or testing tokenization processes."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "tokenize", "line_number": 196, "body": "def tokenize(readline: Callable[[], Text], tokeneater: TokenEater = printtoken) -> None:\n    \"\"\"\n    The tokenize() function accepts two parameters: one representing the\n    input stream, and one providing an output mechanism for tokenize().\n\n    The first parameter, readline, must be a callable object which provides\n    the same interface as the readline() method of built-in file objects.\n    Each call to the function should return one line of input as a string.\n\n    The second parameter, tokeneater, must also be a callable object. It is\n    called once for each token, with five arguments, corresponding to the\n    tuples generated by generate_tokens().\n    \"\"\"\n    try:\n        tokenize_loop(readline, tokeneater)\n    except StopTokenizing:\n        pass", "is_method": false, "function_description": "Utility function that processes input text line-by-line, extracting tokens and passing each token to a specified callback for handling, enabling customizable token consumption from any readline-style input source."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "tokenize_loop", "line_number": 216, "body": "def tokenize_loop(readline, tokeneater):\n    for token_info in generate_tokens(readline):\n        tokeneater(*token_info)", "is_method": false, "function_description": "Utility function that iterates over tokens generated from an input stream and processes each token using a provided callback, facilitating customizable token consumption in parsing or lexical analysis workflows."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "_get_normal_name", "line_number": 292, "body": "def _get_normal_name(orig_enc: str) -> str:\n    \"\"\"Imitates get_normal_name in tokenizer.c.\"\"\"\n    # Only care about the first 12 characters.\n    enc = orig_enc[:12].lower().replace(\"_\", \"-\")\n    if enc == \"utf-8\" or enc.startswith(\"utf-8-\"):\n        return \"utf-8\"\n    if enc in (\"latin-1\", \"iso-8859-1\", \"iso-latin-1\") or enc.startswith(\n        (\"latin-1-\", \"iso-8859-1-\", \"iso-latin-1-\")\n    ):\n        return \"iso-8859-1\"\n    return orig_enc", "is_method": false, "function_description": "Utility function that normalizes character encoding names to standard forms, helping ensure consistent encoding identifiers across the application. It simplifies handling of common encodings like UTF-8 and Latin-1 variants."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "detect_encoding", "line_number": 305, "body": "def detect_encoding(readline: Callable[[], bytes]) -> Tuple[str, List[bytes]]:\n    \"\"\"\n    The detect_encoding() function is used to detect the encoding that should\n    be used to decode a Python source file. It requires one argument, readline,\n    in the same way as the tokenize() generator.\n\n    It will call readline a maximum of twice, and return the encoding used\n    (as a string) and a list of any lines (left as bytes) it has read\n    in.\n\n    It detects the encoding from the presence of a utf-8 bom or an encoding\n    cookie as specified in pep-0263. If both a bom and a cookie are present, but\n    disagree, a SyntaxError will be raised. If the encoding cookie is an invalid\n    charset, raise a SyntaxError.  Note that if a utf-8 bom is found,\n    'utf-8-sig' is returned.\n\n    If no encoding is specified, then the default of 'utf-8' will be returned.\n    \"\"\"\n    bom_found = False\n    encoding = None\n    default = \"utf-8\"\n\n    def read_or_stop() -> bytes:\n        try:\n            return readline()\n        except StopIteration:\n            return bytes()\n\n    def find_cookie(line: bytes) -> Optional[str]:\n        try:\n            line_string = line.decode(\"ascii\")\n        except UnicodeDecodeError:\n            return None\n        match = cookie_re.match(line_string)\n        if not match:\n            return None\n        encoding = _get_normal_name(match.group(1))\n        try:\n            codec = lookup(encoding)\n        except LookupError:\n            # This behaviour mimics the Python interpreter\n            raise SyntaxError(\"unknown encoding: \" + encoding)\n\n        if bom_found:\n            if codec.name != \"utf-8\":\n                # This behaviour mimics the Python interpreter\n                raise SyntaxError(\"encoding problem: utf-8\")\n            encoding += \"-sig\"\n        return encoding\n\n    first = read_or_stop()\n    if first.startswith(BOM_UTF8):\n        bom_found = True\n        first = first[3:]\n        default = \"utf-8-sig\"\n    if not first:\n        return default, []\n\n    encoding = find_cookie(first)\n    if encoding:\n        return encoding, [first]\n    if not blank_re.match(first):\n        return default, [first]\n\n    second = read_or_stop()\n    if not second:\n        return default, [first]\n\n    encoding = find_cookie(second)\n    if encoding:\n        return encoding, [first, second]\n\n    return default, [first, second]", "is_method": false, "function_description": "Function that determines the correct text encoding for a Python source file by inspecting its initial lines, supporting UTF-8 BOM and encoding cookies, to enable accurate decoding of the file contents. It returns the detected encoding and the raw lines read during detection."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "untokenize", "line_number": 380, "body": "def untokenize(iterable: Iterable[TokenInfo]) -> Text:\n    \"\"\"Transform tokens back into Python source code.\n\n    Each element returned by the iterable must be a token sequence\n    with at least two elements, a token number and token value.  If\n    only two tokens are passed, the resulting output is poor.\n\n    Round-trip invariant for full input:\n        Untokenized source will match input source exactly\n\n    Round-trip invariant for limited input:\n        # Output text will tokenize the back to the input\n        t1 = [tok[:2] for tok in generate_tokens(f.readline)]\n        newcode = untokenize(t1)\n        readline = iter(newcode.splitlines(1)).next\n        t2 = [tok[:2] for tokin generate_tokens(readline)]\n        assert t1 == t2\n    \"\"\"\n    ut = Untokenizer()\n    return ut.untokenize(iterable)", "is_method": false, "function_description": "Function that converts a sequence of Python tokens back into the original source code text, ensuring that tokenized input can be accurately reconstructed for code generation or analysis tools."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "generate_tokens", "line_number": 402, "body": "def generate_tokens(\n    readline: Callable[[], Text], grammar: Optional[Grammar] = None\n) -> Iterator[GoodTokenInfo]:\n    \"\"\"\n    The generate_tokens() generator requires one argument, readline, which\n    must be a callable object which provides the same interface as the\n    readline() method of built-in file objects. Each call to the function\n    should return one line of input as a string.  Alternately, readline\n    can be a callable function terminating with StopIteration:\n        readline = open(myfile).next    # Example of alternate readline\n\n    The generator produces 5-tuples with these members: the token type; the\n    token string; a 2-tuple (srow, scol) of ints specifying the row and\n    column where the token begins in the source; a 2-tuple (erow, ecol) of\n    ints specifying the row and column where the token ends in the source;\n    and the line on which the token was found. The line passed is the\n    logical line; continuation lines are included.\n    \"\"\"\n    lnum = parenlev = continued = 0\n    numchars = \"0123456789\"\n    contstr, needcont = \"\", 0\n    contline: Optional[str] = None\n    indents = [0]\n\n    # If we know we're parsing 3.7+, we can unconditionally parse `async` and\n    # `await` as keywords.\n    async_keywords = False if grammar is None else grammar.async_keywords\n    # 'stashed' and 'async_*' are used for async/await parsing\n    stashed = None\n    async_def = False\n    async_def_indent = 0\n    async_def_nl = False\n\n    strstart: Tuple[int, int]\n    endprog: Pattern[str]\n\n    while 1:  # loop over lines in stream\n        try:\n            line = readline()\n        except StopIteration:\n            line = \"\"\n        lnum = lnum + 1\n        pos, max = 0, len(line)\n\n        if contstr:  # continued string\n            assert contline is not None\n            if not line:\n                raise TokenError(\"EOF in multi-line string\", strstart)\n            endmatch = endprog.match(line)\n            if endmatch:\n                pos = end = endmatch.end(0)\n                yield (\n                    STRING,\n                    contstr + line[:end],\n                    strstart,\n                    (lnum, end),\n                    contline + line,\n                )\n                contstr, needcont = \"\", 0\n                contline = None\n            elif needcont and line[-2:] != \"\\\\\\n\" and line[-3:] != \"\\\\\\r\\n\":\n                yield (\n                    ERRORTOKEN,\n                    contstr + line,\n                    strstart,\n                    (lnum, len(line)),\n                    contline,\n                )\n                contstr = \"\"\n                contline = None\n                continue\n            else:\n                contstr = contstr + line\n                contline = contline + line\n                continue\n\n        elif parenlev == 0 and not continued:  # new statement\n            if not line:\n                break\n            column = 0\n            while pos < max:  # measure leading whitespace\n                if line[pos] == \" \":\n                    column = column + 1\n                elif line[pos] == \"\\t\":\n                    column = (column // tabsize + 1) * tabsize\n                elif line[pos] == \"\\f\":\n                    column = 0\n                else:\n                    break\n                pos = pos + 1\n            if pos == max:\n                break\n\n            if stashed:\n                yield stashed\n                stashed = None\n\n            if line[pos] in \"\\r\\n\":  # skip blank lines\n                yield (NL, line[pos:], (lnum, pos), (lnum, len(line)), line)\n                continue\n\n            if line[pos] == \"#\":  # skip comments\n                comment_token = line[pos:].rstrip(\"\\r\\n\")\n                nl_pos = pos + len(comment_token)\n                yield (\n                    COMMENT,\n                    comment_token,\n                    (lnum, pos),\n                    (lnum, pos + len(comment_token)),\n                    line,\n                )\n                yield (NL, line[nl_pos:], (lnum, nl_pos), (lnum, len(line)), line)\n                continue\n\n            if column > indents[-1]:  # count indents\n                indents.append(column)\n                yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)\n\n            while column < indents[-1]:  # count dedents\n                if column not in indents:\n                    raise IndentationError(\n                        \"unindent does not match any outer indentation level\",\n                        (\"<tokenize>\", lnum, pos, line),\n                    )\n                indents = indents[:-1]\n\n                if async_def and async_def_indent >= indents[-1]:\n                    async_def = False\n                    async_def_nl = False\n                    async_def_indent = 0\n\n                yield (DEDENT, \"\", (lnum, pos), (lnum, pos), line)\n\n            if async_def and async_def_nl and async_def_indent >= indents[-1]:\n                async_def = False\n                async_def_nl = False\n                async_def_indent = 0\n\n        else:  # continued statement\n            if not line:\n                raise TokenError(\"EOF in multi-line statement\", (lnum, 0))\n            continued = 0\n\n        while pos < max:\n            pseudomatch = pseudoprog.match(line, pos)\n            if pseudomatch:  # scan for tokens\n                start, end = pseudomatch.span(1)\n                spos, epos, pos = (lnum, start), (lnum, end), end\n                token, initial = line[start:end], line[start]\n\n                if initial in numchars or (\n                    initial == \".\" and token != \".\"\n                ):  # ordinary number\n                    yield (NUMBER, token, spos, epos, line)\n                elif initial in \"\\r\\n\":\n                    newline = NEWLINE\n                    if parenlev > 0:\n                        newline = NL\n                    elif async_def:\n                        async_def_nl = True\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (newline, token, spos, epos, line)\n\n                elif initial == \"#\":\n                    assert not token.endswith(\"\\n\")\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (COMMENT, token, spos, epos, line)\n                elif token in triple_quoted:\n                    endprog = endprogs[token]\n                    endmatch = endprog.match(line, pos)\n                    if endmatch:  # all on one line\n                        pos = endmatch.end(0)\n                        token = line[start:pos]\n                        if stashed:\n                            yield stashed\n                            stashed = None\n                        yield (STRING, token, spos, (lnum, pos), line)\n                    else:\n                        strstart = (lnum, start)  # multiple lines\n                        contstr = line[start:]\n                        contline = line\n                        break\n                elif (\n                    initial in single_quoted\n                    or token[:2] in single_quoted\n                    or token[:3] in single_quoted\n                ):\n                    if token[-1] == \"\\n\":  # continued string\n                        strstart = (lnum, start)\n                        endprog = (\n                            endprogs[initial]\n                            or endprogs[token[1]]\n                            or endprogs[token[2]]\n                        )\n                        contstr, needcont = line[start:], 1\n                        contline = line\n                        break\n                    else:  # ordinary string\n                        if stashed:\n                            yield stashed\n                            stashed = None\n                        yield (STRING, token, spos, epos, line)\n                elif initial.isidentifier():  # ordinary name\n                    if token in (\"async\", \"await\"):\n                        if async_keywords or async_def:\n                            yield (\n                                ASYNC if token == \"async\" else AWAIT,\n                                token,\n                                spos,\n                                epos,\n                                line,\n                            )\n                            continue\n\n                    tok = (NAME, token, spos, epos, line)\n                    if token == \"async\" and not stashed:\n                        stashed = tok\n                        continue\n\n                    if token in (\"def\", \"for\"):\n                        if stashed and stashed[0] == NAME and stashed[1] == \"async\":\n\n                            if token == \"def\":\n                                async_def = True\n                                async_def_indent = indents[-1]\n\n                            yield (\n                                ASYNC,\n                                stashed[1],\n                                stashed[2],\n                                stashed[3],\n                                stashed[4],\n                            )\n                            stashed = None\n\n                    if stashed:\n                        yield stashed\n                        stashed = None\n\n                    yield tok\n                elif initial == \"\\\\\":  # continued stmt\n                    # This yield is new; needed for better idempotency:\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (NL, token, spos, (lnum, pos), line)\n                    continued = 1\n                else:\n                    if initial in \"([{\":\n                        parenlev = parenlev + 1\n                    elif initial in \")]}\":\n                        parenlev = parenlev - 1\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (OP, token, spos, epos, line)\n            else:\n                yield (ERRORTOKEN, line[pos], (lnum, pos), (lnum, pos + 1), line)\n                pos = pos + 1\n\n    if stashed:\n        yield stashed\n        stashed = None\n\n    for indent in indents[1:]:  # pop remaining indent levels\n        yield (DEDENT, \"\", (lnum, 0), (lnum, 0), \"\")\n    yield (ENDMARKER, \"\", (lnum, 0), (lnum, 0), \"\")", "is_method": false, "function_description": "Function that tokenizes Python source code from a line-producing callable, yielding detailed tokens with types, positions, and lines. It serves as a core utility for parsing and analyzing Python code syntactically."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "add_whitespace", "line_number": 236, "body": "def add_whitespace(self, start: Coord) -> None:\n        row, col = start\n        assert row <= self.prev_row\n        col_offset = col - self.prev_col\n        if col_offset:\n            self.tokens.append(\" \" * col_offset)", "is_method": true, "class_name": "Untokenizer", "function_description": "Adds spaces to the token list based on column offset to maintain correct whitespace alignment during the untokenizing process. This helps reconstruct source code formatting accurately."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "untokenize", "line_number": 243, "body": "def untokenize(self, iterable: Iterable[TokenInfo]) -> Text:\n        for t in iterable:\n            if len(t) == 2:\n                self.compat(cast(Tuple[int, str], t), iterable)\n                break\n            tok_type, token, start, end, line = cast(\n                Tuple[int, Text, Coord, Coord, Text], t\n            )\n            self.add_whitespace(start)\n            self.tokens.append(token)\n            self.prev_row, self.prev_col = end\n            if tok_type in (NEWLINE, NL):\n                self.prev_row += 1\n                self.prev_col = 0\n        return \"\".join(self.tokens)", "is_method": true, "class_name": "Untokenizer", "function_description": "Reconstructs source code text from a sequence of tokens, restoring original whitespace and formatting. This enables conversion from tokenized code back to readable source form."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "compat", "line_number": 259, "body": "def compat(self, token: Tuple[int, Text], iterable: Iterable[TokenInfo]) -> None:\n        startline = False\n        indents = []\n        toks_append = self.tokens.append\n        toknum, tokval = token\n        if toknum in (NAME, NUMBER):\n            tokval += \" \"\n        if toknum in (NEWLINE, NL):\n            startline = True\n        for tok in iterable:\n            toknum, tokval = tok[:2]\n\n            if toknum in (NAME, NUMBER, ASYNC, AWAIT):\n                tokval += \" \"\n\n            if toknum == INDENT:\n                indents.append(tokval)\n                continue\n            elif toknum == DEDENT:\n                indents.pop()\n                continue\n            elif toknum in (NEWLINE, NL):\n                startline = True\n            elif startline and indents:\n                toks_append(indents[-1])\n                startline = False\n            toks_append(tokval)", "is_method": true, "class_name": "Untokenizer", "function_description": "Utility method of the Untokenizer class that processes tokens and iterables to reconstruct source code spacing and indentation accurately, ensuring compatibility with different token streams for code untokenization."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "read_or_stop", "line_number": 327, "body": "def read_or_stop() -> bytes:\n        try:\n            return readline()\n        except StopIteration:\n            return bytes()", "is_method": false, "function_description": "This function attempts to read the next line of input and returns it as bytes, returning empty bytes if there is no more input to read. It provides a safe way to read lines without raising iteration exceptions."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/tokenize.py", "function": "find_cookie", "line_number": 333, "body": "def find_cookie(line: bytes) -> Optional[str]:\n        try:\n            line_string = line.decode(\"ascii\")\n        except UnicodeDecodeError:\n            return None\n        match = cookie_re.match(line_string)\n        if not match:\n            return None\n        encoding = _get_normal_name(match.group(1))\n        try:\n            codec = lookup(encoding)\n        except LookupError:\n            # This behaviour mimics the Python interpreter\n            raise SyntaxError(\"unknown encoding: \" + encoding)\n\n        if bom_found:\n            if codec.name != \"utf-8\":\n                # This behaviour mimics the Python interpreter\n                raise SyntaxError(\"encoding problem: utf-8\")\n            encoding += \"-sig\"\n        return encoding", "is_method": false, "function_description": "This function detects and validates the encoding declared in a byte line, returning the encoding name if valid, or raising errors for unknown or unsupported encodings. It assists in determining file encoding for correct text processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "generate_grammar", "line_number": 428, "body": "def generate_grammar(filename: Path = \"Grammar.txt\") -> PgenGrammar:\n    p = ParserGenerator(filename)\n    return p.make_grammar()", "is_method": false, "function_description": "This function generates and returns a grammar object by reading grammar rules from a specified file, enabling parser creation and syntax analysis based on those rules."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "make_grammar", "line_number": 55, "body": "def make_grammar(self) -> PgenGrammar:\n        c = PgenGrammar()\n        names = list(self.dfas.keys())\n        names.sort()\n        names.remove(self.startsymbol)\n        names.insert(0, self.startsymbol)\n        for name in names:\n            i = 256 + len(c.symbol2number)\n            c.symbol2number[name] = i\n            c.number2symbol[i] = name\n        for name in names:\n            dfa = self.dfas[name]\n            states = []\n            for state in dfa:\n                arcs = []\n                for label, next in sorted(state.arcs.items()):\n                    arcs.append((self.make_label(c, label), dfa.index(next)))\n                if state.isfinal:\n                    arcs.append((0, dfa.index(state)))\n                states.append(arcs)\n            c.states.append(states)\n            c.dfas[c.symbol2number[name]] = (states, self.make_first(c, name))\n        c.start = c.symbol2number[self.startsymbol]\n        return c", "is_method": true, "class_name": "ParserGenerator", "function_description": "Constructs and returns a grammar representation object by converting internal DFA structures and symbols into mappings and states for parsing processes. This enables generating a grammar suitable for parser generation workflows within the ParserGenerator context."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "make_first", "line_number": 80, "body": "def make_first(self, c: PgenGrammar, name: Text) -> Dict[int, int]:\n        rawfirst = self.first[name]\n        assert rawfirst is not None\n        first = {}\n        for label in sorted(rawfirst):\n            ilabel = self.make_label(c, label)\n            ##assert ilabel not in first # XXX failed on <> ... !=\n            first[ilabel] = 1\n        return first", "is_method": true, "class_name": "ParserGenerator", "function_description": "Core method of the ParserGenerator class that converts a raw set of grammar elements into a mapping of internal labels, representing the first tokens expected for a grammar rule. It supports parsing by identifying valid starting tokens."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "make_label", "line_number": 90, "body": "def make_label(self, c: PgenGrammar, label: Text) -> int:\n        # XXX Maybe this should be a method on a subclass of converter?\n        ilabel = len(c.labels)\n        if label[0].isalpha():\n            # Either a symbol name or a named token\n            if label in c.symbol2number:\n                # A symbol name (a non-terminal)\n                if label in c.symbol2label:\n                    return c.symbol2label[label]\n                else:\n                    c.labels.append((c.symbol2number[label], None))\n                    c.symbol2label[label] = ilabel\n                    return ilabel\n            else:\n                # A named token (NAME, NUMBER, STRING)\n                itoken = getattr(token, label, None)\n                assert isinstance(itoken, int), label\n                assert itoken in token.tok_name, label\n                if itoken in c.tokens:\n                    return c.tokens[itoken]\n                else:\n                    c.labels.append((itoken, None))\n                    c.tokens[itoken] = ilabel\n                    return ilabel\n        else:\n            # Either a keyword or an operator\n            assert label[0] in ('\"', \"'\"), label\n            value = eval(label)\n            if value[0].isalpha():\n                # A keyword\n                if value in c.keywords:\n                    return c.keywords[value]\n                else:\n                    c.labels.append((token.NAME, value))\n                    c.keywords[value] = ilabel\n                    return ilabel\n            else:\n                # An operator (any non-numeric token)\n                itoken = grammar.opmap[value]  # Fails if unknown token\n                if itoken in c.tokens:\n                    return c.tokens[itoken]\n                else:\n                    c.labels.append((itoken, None))\n                    c.tokens[itoken] = ilabel\n                    return ilabel", "is_method": true, "class_name": "ParserGenerator", "function_description": "Core method of the ParserGenerator class that assigns or retrieves unique integer labels for grammar symbols, tokens, keywords, or operators, aiding grammar construction and parsing by maintaining consistent label mappings."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "addfirstsets", "line_number": 136, "body": "def addfirstsets(self) -> None:\n        names = list(self.dfas.keys())\n        names.sort()\n        for name in names:\n            if name not in self.first:\n                self.calcfirst(name)", "is_method": true, "class_name": "ParserGenerator", "function_description": "Adds missing first sets for grammar symbols by calculating them, supporting the ParserGenerator's grammar analysis and parser construction processes."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "calcfirst", "line_number": 144, "body": "def calcfirst(self, name: Text) -> None:\n        dfa = self.dfas[name]\n        self.first[name] = None  # dummy to detect left recursion\n        state = dfa[0]\n        totalset: Dict[str, int] = {}\n        overlapcheck = {}\n        for label, next in state.arcs.items():\n            if label in self.dfas:\n                if label in self.first:\n                    fset = self.first[label]\n                    if fset is None:\n                        raise ValueError(\"recursion for rule %r\" % name)\n                else:\n                    self.calcfirst(label)\n                    fset = self.first[label]\n                    assert fset is not None\n                totalset.update(fset)\n                overlapcheck[label] = fset\n            else:\n                totalset[label] = 1\n                overlapcheck[label] = {label: 1}\n        inverse: Dict[str, str] = {}\n        for label, itsfirst in overlapcheck.items():\n            for symbol in itsfirst:\n                if symbol in inverse:\n                    raise ValueError(\n                        \"rule %s is ambiguous; %s is in the first sets of %s as well\"\n                        \" as %s\"\n                        % (name, symbol, label, inverse[symbol])\n                    )\n                inverse[symbol] = label\n        self.first[name] = totalset", "is_method": true, "class_name": "ParserGenerator", "function_description": "Computes the FIRST set for a grammar rule to determine which tokens can begin strings derived from that rule, detecting left recursion and ambiguity. This aids in parsing decisions within the ParserGenerator class."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "parse", "line_number": 177, "body": "def parse(self) -> Tuple[Dict[Text, List[\"DFAState\"]], Text]:\n        dfas = {}\n        startsymbol: Optional[str] = None\n        # MSTART: (NEWLINE | RULE)* ENDMARKER\n        while self.type != token.ENDMARKER:\n            while self.type == token.NEWLINE:\n                self.gettoken()\n            # RULE: NAME ':' RHS NEWLINE\n            name = self.expect(token.NAME)\n            self.expect(token.OP, \":\")\n            a, z = self.parse_rhs()\n            self.expect(token.NEWLINE)\n            # self.dump_nfa(name, a, z)\n            dfa = self.make_dfa(a, z)\n            # self.dump_dfa(name, dfa)\n            oldlen = len(dfa)\n            self.simplify_dfa(dfa)\n            newlen = len(dfa)\n            dfas[name] = dfa\n            # print name, oldlen, newlen\n            if startsymbol is None:\n                startsymbol = name\n        assert startsymbol is not None\n        return dfas, startsymbol", "is_method": true, "class_name": "ParserGenerator", "function_description": "Core method of the ParserGenerator class that parses grammar rules into deterministic finite automata (DFAs) and identifies the start symbol, facilitating syntax analysis for language parsing tasks."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "make_dfa", "line_number": 202, "body": "def make_dfa(self, start: \"NFAState\", finish: \"NFAState\") -> List[\"DFAState\"]:\n        # To turn an NFA into a DFA, we define the states of the DFA\n        # to correspond to *sets* of states of the NFA.  Then do some\n        # state reduction.  Let's represent sets as dicts with 1 for\n        # values.\n        assert isinstance(start, NFAState)\n        assert isinstance(finish, NFAState)\n\n        def closure(state: NFAState) -> Dict[NFAState, int]:\n            base: Dict[NFAState, int] = {}\n            addclosure(state, base)\n            return base\n\n        def addclosure(state: NFAState, base: Dict[NFAState, int]) -> None:\n            assert isinstance(state, NFAState)\n            if state in base:\n                return\n            base[state] = 1\n            for label, next in state.arcs:\n                if label is None:\n                    addclosure(next, base)\n\n        states = [DFAState(closure(start), finish)]\n        for state in states:  # NB states grows while we're iterating\n            arcs: Dict[str, Dict[NFAState, int]] = {}\n            for nfastate in state.nfaset:\n                for label, next in nfastate.arcs:\n                    if label is not None:\n                        addclosure(next, arcs.setdefault(label, {}))\n            for label, nfaset in sorted(arcs.items()):\n                for st in states:\n                    if st.nfaset == nfaset:\n                        break\n                else:\n                    st = DFAState(nfaset, finish)\n                    states.append(st)\n                state.addarc(st, label)\n        return states", "is_method": true, "class_name": "ParserGenerator", "function_description": "Core function of the ParserGenerator class that converts a given NFA defined by start and finish states into an equivalent set of DFA states, enabling deterministic pattern recognition for parsing tasks."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "dump_nfa", "line_number": 241, "body": "def dump_nfa(self, name: Text, start: \"NFAState\", finish: \"NFAState\") -> None:\n        print(\"Dump of NFA for\", name)\n        todo = [start]\n        for i, state in enumerate(todo):\n            print(\"  State\", i, state is finish and \"(final)\" or \"\")\n            for label, next in state.arcs:\n                if next in todo:\n                    j = todo.index(next)\n                else:\n                    j = len(todo)\n                    todo.append(next)\n                if label is None:\n                    print(\"    -> %d\" % j)\n                else:\n                    print(\"    %s -> %d\" % (label, j))", "is_method": true, "class_name": "ParserGenerator", "function_description": "Utility method of ParserGenerator that prints a readable representation of a non-deterministic finite automaton (NFA), showing states and transitions to help visualize or debug its structure."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "dump_dfa", "line_number": 257, "body": "def dump_dfa(self, name: Text, dfa: Sequence[\"DFAState\"]) -> None:\n        print(\"Dump of DFA for\", name)\n        for i, state in enumerate(dfa):\n            print(\"  State\", i, state.isfinal and \"(final)\" or \"\")\n            for label, next in sorted(state.arcs.items()):\n                print(\"    %s -> %d\" % (label, dfa.index(next)))", "is_method": true, "class_name": "ParserGenerator", "function_description": "Method of ParserGenerator that outputs a textual representation of a given DFA's states and transitions, primarily aiding debugging or visualization of the DFA structure."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "simplify_dfa", "line_number": 264, "body": "def simplify_dfa(self, dfa: List[\"DFAState\"]) -> None:\n        # This is not theoretically optimal, but works well enough.\n        # Algorithm: repeatedly look for two states that have the same\n        # set of arcs (same labels pointing to the same nodes) and\n        # unify them, until things stop changing.\n\n        # dfa is a list of DFAState instances\n        changes = True\n        while changes:\n            changes = False\n            for i, state_i in enumerate(dfa):\n                for j in range(i + 1, len(dfa)):\n                    state_j = dfa[j]\n                    if state_i == state_j:\n                        # print \"  unify\", i, j\n                        del dfa[j]\n                        for state in dfa:\n                            state.unifystate(state_j, state_i)\n                        changes = True\n                        break", "is_method": true, "class_name": "ParserGenerator", "function_description": "Core method of ParserGenerator that reduces the complexity of a DFA by merging states with identical transitions, optimizing the DFA structure for more efficient parsing or pattern recognition."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "parse_rhs", "line_number": 285, "body": "def parse_rhs(self) -> Tuple[\"NFAState\", \"NFAState\"]:\n        # RHS: ALT ('|' ALT)*\n        a, z = self.parse_alt()\n        if self.value != \"|\":\n            return a, z\n        else:\n            aa = NFAState()\n            zz = NFAState()\n            aa.addarc(a)\n            z.addarc(zz)\n            while self.value == \"|\":\n                self.gettoken()\n                a, z = self.parse_alt()\n                aa.addarc(a)\n                z.addarc(zz)\n            return aa, zz", "is_method": true, "class_name": "ParserGenerator", "function_description": "Core parsing method of ParserGenerator translating a right-hand side pattern with alternatives into an NFA fragment, supporting regex-style union operations useful for syntactic analysis and pattern-matching automata construction."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "parse_alt", "line_number": 302, "body": "def parse_alt(self) -> Tuple[\"NFAState\", \"NFAState\"]:\n        # ALT: ITEM+\n        a, b = self.parse_item()\n        while self.value in (\"(\", \"[\") or self.type in (token.NAME, token.STRING):\n            c, d = self.parse_item()\n            b.addarc(c)\n            b = d\n        return a, b", "is_method": true, "class_name": "ParserGenerator", "function_description": "Core parsing method of ParserGenerator that processes one or more alternative grammar items and constructs a corresponding sequence of NFA states representing these alternatives."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "parse_item", "line_number": 311, "body": "def parse_item(self) -> Tuple[\"NFAState\", \"NFAState\"]:\n        # ITEM: '[' RHS ']' | ATOM ['+' | '*']\n        if self.value == \"[\":\n            self.gettoken()\n            a, z = self.parse_rhs()\n            self.expect(token.OP, \"]\")\n            a.addarc(z)\n            return a, z\n        else:\n            a, z = self.parse_atom()\n            value = self.value\n            if value not in (\"+\", \"*\"):\n                return a, z\n            self.gettoken()\n            z.addarc(a)\n            if value == \"+\":\n                return a, z\n            else:\n                return a, a", "is_method": true, "class_name": "ParserGenerator", "function_description": "Method of the ParserGenerator class that parses an item in a grammar, constructing and returning corresponding NFA state pairs representing sequences, repetitions, or optional constructs in parsing automata."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "parse_atom", "line_number": 331, "body": "def parse_atom(self) -> Tuple[\"NFAState\", \"NFAState\"]:\n        # ATOM: '(' RHS ')' | NAME | STRING\n        if self.value == \"(\":\n            self.gettoken()\n            a, z = self.parse_rhs()\n            self.expect(token.OP, \")\")\n            return a, z\n        elif self.type in (token.NAME, token.STRING):\n            a = NFAState()\n            z = NFAState()\n            a.addarc(z, self.value)\n            self.gettoken()\n            return a, z\n        else:\n            self.raise_error(\n                \"expected (...) or NAME or STRING, got %s/%s\", self.type, self.value\n            )\n            assert False", "is_method": true, "class_name": "ParserGenerator", "function_description": "Core method of ParserGenerator that parses atomic grammar units (parenthesized expressions, names, or strings) into corresponding NFA start and end states, enabling building of finite automata for grammar parsing."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "expect", "line_number": 350, "body": "def expect(self, type: int, value: Optional[Any] = None) -> Text:\n        if self.type != type or (value is not None and self.value != value):\n            self.raise_error(\n                \"expected %s/%s, got %s/%s\", type, value, self.type, self.value\n            )\n        value = self.value\n        self.gettoken()\n        return value", "is_method": true, "class_name": "ParserGenerator", "function_description": "Core method of the ParserGenerator class that verifies the next token matches an expected type and optional value, advancing the token stream if valid or raising an error if not. It facilitates strict syntax validation during parsing."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "gettoken", "line_number": 359, "body": "def gettoken(self) -> None:\n        tup = next(self.generator)\n        while tup[0] in (tokenize.COMMENT, tokenize.NL):\n            tup = next(self.generator)\n        self.type, self.value, self.begin, self.end, self.line = tup", "is_method": true, "class_name": "ParserGenerator", "function_description": "Core utility of the ParserGenerator class that advances the token stream, skipping comments and newlines, to provide the next meaningful token for parsing source code."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "raise_error", "line_number": 366, "body": "def raise_error(self, msg: str, *args: Any) -> NoReturn:\n        if args:\n            try:\n                msg = msg % args\n            except:\n                msg = \" \".join([msg] + list(map(str, args)))\n        raise SyntaxError(msg, (self.filename, self.end[0], self.end[1], self.line))", "is_method": true, "class_name": "ParserGenerator", "function_description": "Utility method of the ParserGenerator class that raises a detailed SyntaxError with a formatted message and precise location information when parsing fails. It facilitates consistent and informative error reporting during parsing processes."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "addarc", "line_number": 381, "body": "def addarc(self, next: \"NFAState\", label: Optional[Text] = None) -> None:\n        assert label is None or isinstance(label, str)\n        assert isinstance(next, NFAState)\n        self.arcs.append((label, next))", "is_method": true, "class_name": "NFAState", "function_description": "Adds a labeled or unlabeled transition from the current NFA state to another, supporting construction of non-deterministic finite automata by linking states with optional input labels."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "addarc", "line_number": 400, "body": "def addarc(self, next: \"DFAState\", label: Text) -> None:\n        assert isinstance(label, str)\n        assert label not in self.arcs\n        assert isinstance(next, DFAState)\n        self.arcs[label] = next", "is_method": true, "class_name": "DFAState", "function_description": "Adds a labeled transition from the current DFAState to another, defining state changes driven by input symbols in the deterministic finite automaton."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "unifystate", "line_number": 406, "body": "def unifystate(self, old: \"DFAState\", new: \"DFAState\") -> None:\n        for label, next in self.arcs.items():\n            if next is old:\n                self.arcs[label] = new", "is_method": true, "class_name": "DFAState", "function_description": "Replaces references to a specified old state with a new state in the current DFA state's transitions, enabling state unification or merging within the DFA."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "__eq__", "line_number": 411, "body": "def __eq__(self, other: Any) -> bool:\n        # Equality test -- ignore the nfaset instance variable\n        assert isinstance(other, DFAState)\n        if self.isfinal != other.isfinal:\n            return False\n        # Can't just return self.arcs == other.arcs, because that\n        # would invoke this method recursively, with cycles...\n        if len(self.arcs) != len(other.arcs):\n            return False\n        for label, next in self.arcs.items():\n            if next is not other.arcs.get(label):\n                return False\n        return True", "is_method": true, "class_name": "DFAState", "function_description": "Method of the DFAState class that determines if two DFA states are equal by comparing their finality and transition arcs without causing recursive comparison cycles. It enables accurate state equivalence checks within deterministic finite automata operations."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "closure", "line_number": 210, "body": "def closure(state: NFAState) -> Dict[NFAState, int]:\n            base: Dict[NFAState, int] = {}\n            addclosure(state, base)\n            return base", "is_method": true, "class_name": "ParserGenerator", "function_description": "Generates the epsilon-closure of a given NFA state, returning all reachable states with their respective distances. This supports state exploration in non-deterministic finite automaton processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/pgen.py", "function": "addclosure", "line_number": 215, "body": "def addclosure(state: NFAState, base: Dict[NFAState, int]) -> None:\n            assert isinstance(state, NFAState)\n            if state in base:\n                return\n            base[state] = 1\n            for label, next in state.arcs:\n                if label is None:\n                    addclosure(next, base)", "is_method": true, "class_name": "ParserGenerator", "function_description": "Core utility of the ParserGenerator class that expands an NFA state set by recursively adding all states reachable via epsilon (None) transitions, enabling closure computation in automata processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/driver.py", "function": "_generate_pickle_name", "line_number": 172, "body": "def _generate_pickle_name(gt: Path, cache_dir: Optional[Path] = None) -> Text:\n    head, tail = os.path.splitext(gt)\n    if tail == \".txt\":\n        tail = \"\"\n    name = head + tail + \".\".join(map(str, sys.version_info)) + \".pickle\"\n    if cache_dir:\n        return os.path.join(cache_dir, os.path.basename(name))\n    else:\n        return name", "is_method": false, "function_description": "Utility function that creates a unique pickle filename based on a given path and Python version, optionally placing it in a specified cache directory for consistent caching and retrieval."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/driver.py", "function": "load_grammar", "line_number": 183, "body": "def load_grammar(\n    gt: Text = \"Grammar.txt\",\n    gp: Optional[Text] = None,\n    save: bool = True,\n    force: bool = False,\n    logger: Optional[Logger] = None,\n) -> Grammar:\n    \"\"\"Load the grammar (maybe from a pickle).\"\"\"\n    if logger is None:\n        logger = logging.getLogger(__name__)\n    gp = _generate_pickle_name(gt) if gp is None else gp\n    if force or not _newer(gp, gt):\n        logger.info(\"Generating grammar tables from %s\", gt)\n        g: grammar.Grammar = pgen.generate_grammar(gt)\n        if save:\n            logger.info(\"Writing grammar tables to %s\", gp)\n            try:\n                g.dump(gp)\n            except OSError as e:\n                logger.info(\"Writing failed: %s\", e)\n    else:\n        g = grammar.Grammar()\n        g.load(gp)\n    return g", "is_method": false, "function_description": "This function loads grammar rules from a source file or a cached pickle, optionally regenerating and saving the grammar tables. It provides efficient grammar loading for parsing-related tasks by minimizing redundant grammar generation."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/driver.py", "function": "_newer", "line_number": 209, "body": "def _newer(a: Text, b: Text) -> bool:\n    \"\"\"Inquire whether file a was written since file b.\"\"\"\n    if not os.path.exists(a):\n        return False\n    if not os.path.exists(b):\n        return True\n    return os.path.getmtime(a) >= os.path.getmtime(b)", "is_method": false, "function_description": "Utility function that checks if file a is newer than or has been modified since file b, which helps determine file update status or synchronization needs."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/driver.py", "function": "load_packaged_grammar", "line_number": 218, "body": "def load_packaged_grammar(\n    package: str, grammar_source: Text, cache_dir: Optional[Path] = None\n) -> grammar.Grammar:\n    \"\"\"Normally, loads a pickled grammar by doing\n        pkgutil.get_data(package, pickled_grammar)\n    where *pickled_grammar* is computed from *grammar_source* by adding the\n    Python version and using a ``.pickle`` extension.\n\n    However, if *grammar_source* is an extant file, load_grammar(grammar_source)\n    is called instead. This facilitates using a packaged grammar file when needed\n    but preserves load_grammar's automatic regeneration behavior when possible.\n\n    \"\"\"\n    if os.path.isfile(grammar_source):\n        gp = _generate_pickle_name(grammar_source, cache_dir) if cache_dir else None\n        return load_grammar(grammar_source, gp=gp)\n    pickled_name = _generate_pickle_name(os.path.basename(grammar_source), cache_dir)\n    data = pkgutil.get_data(package, pickled_name)\n    assert data is not None\n    g = grammar.Grammar()\n    g.loads(data)\n    return g", "is_method": false, "function_description": "Function that loads a grammar object either from a packaged pickled resource or directly from a grammar source file. It supports cached loading and automatic regeneration for flexible grammar retrieval."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/driver.py", "function": "main", "line_number": 242, "body": "def main(*args: Text) -> bool:\n    \"\"\"Main program, when run as a script: produce grammar pickle files.\n\n    Calls load_grammar for each argument, a path to a grammar text file.\n    \"\"\"\n    if not args:\n        args = tuple(sys.argv[1:])\n    logging.basicConfig(level=logging.INFO, stream=sys.stdout, format=\"%(message)s\")\n    for gt in args:\n        load_grammar(gt, save=True, force=True)\n    return True", "is_method": false, "function_description": "Primary purpose is to run as a script entry point that processes grammar text files by loading and saving their pickle representations. It enables batch conversion of grammar specifications for further use."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/driver.py", "function": "parse_tokens", "line_number": 60, "body": "def parse_tokens(self, tokens: Iterable[Any], debug: bool = False) -> NL:\n        \"\"\"Parse a series of tokens and return the syntax tree.\"\"\"\n        # XXX Move the prefix computation into a wrapper around tokenize.\n        p = parse.Parser(self.grammar, self.convert)\n        p.setup()\n        lineno = 1\n        column = 0\n        indent_columns = []\n        type = value = start = end = line_text = None\n        prefix = \"\"\n        for quintuple in tokens:\n            type, value, start, end, line_text = quintuple\n            if start != (lineno, column):\n                assert (lineno, column) <= start, ((lineno, column), start)\n                s_lineno, s_column = start\n                if lineno < s_lineno:\n                    prefix += \"\\n\" * (s_lineno - lineno)\n                    lineno = s_lineno\n                    column = 0\n                if column < s_column:\n                    prefix += line_text[column:s_column]\n                    column = s_column\n            if type in (tokenize.COMMENT, tokenize.NL):\n                prefix += value\n                lineno, column = end\n                if value.endswith(\"\\n\"):\n                    lineno += 1\n                    column = 0\n                continue\n            if type == token.OP:\n                type = grammar.opmap[value]\n            if debug:\n                self.logger.debug(\n                    \"%s %r (prefix=%r)\", token.tok_name[type], value, prefix\n                )\n            if type == token.INDENT:\n                indent_columns.append(len(value))\n                _prefix = prefix + value\n                prefix = \"\"\n                value = \"\"\n            elif type == token.DEDENT:\n                _indent_col = indent_columns.pop()\n                prefix, _prefix = self._partially_consume_prefix(prefix, _indent_col)\n            if p.addtoken(type, value, (prefix, start)):\n                if debug:\n                    self.logger.debug(\"Stop.\")\n                break\n            prefix = \"\"\n            if type in {token.INDENT, token.DEDENT}:\n                prefix = _prefix\n            lineno, column = end\n            if value.endswith(\"\\n\"):\n                lineno += 1\n                column = 0\n        else:\n            # We never broke out -- EOF is too soon (how can this happen???)\n            assert start is not None\n            raise parse.ParseError(\"incomplete input\", type, value, (prefix, start))\n        assert p.rootnode is not None\n        return p.rootnode", "is_method": true, "class_name": "Driver", "function_description": "Parses a sequence of tokens into a syntax tree representing the input's grammatical structure. This method enables syntactic analysis and validation of code or text based on a defined grammar."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/driver.py", "function": "parse_stream_raw", "line_number": 121, "body": "def parse_stream_raw(self, stream: IO[Text], debug: bool = False) -> NL:\n        \"\"\"Parse a stream and return the syntax tree.\"\"\"\n        tokens = tokenize.generate_tokens(stream.readline, grammar=self.grammar)\n        return self.parse_tokens(tokens, debug)", "is_method": true, "class_name": "Driver", "function_description": "Core function of the Driver class that parses a text stream into a syntax tree by tokenizing and analyzing its content, facilitating syntax analysis and further processing of the input data."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/driver.py", "function": "parse_stream", "line_number": 126, "body": "def parse_stream(self, stream: IO[Text], debug: bool = False) -> NL:\n        \"\"\"Parse a stream and return the syntax tree.\"\"\"\n        return self.parse_stream_raw(stream, debug)", "is_method": true, "class_name": "Driver", "function_description": "Utility method of the Driver class that parses an input text stream and returns its syntax tree representation for further linguistic analysis."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/driver.py", "function": "parse_file", "line_number": 130, "body": "def parse_file(\n        self, filename: Path, encoding: Optional[Text] = None, debug: bool = False\n    ) -> NL:\n        \"\"\"Parse a file and return the syntax tree.\"\"\"\n        with io.open(filename, \"r\", encoding=encoding) as stream:\n            return self.parse_stream(stream, debug)", "is_method": true, "class_name": "Driver", "function_description": "Utility method of the Driver class that reads a file and returns its parsed syntax tree, facilitating further processing of source content with optional encoding and debugging support."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/driver.py", "function": "parse_string", "line_number": 137, "body": "def parse_string(self, text: Text, debug: bool = False) -> NL:\n        \"\"\"Parse a string and return the syntax tree.\"\"\"\n        tokens = tokenize.generate_tokens(\n            io.StringIO(text).readline, grammar=self.grammar\n        )\n        return self.parse_tokens(tokens, debug)", "is_method": true, "class_name": "Driver", "function_description": "Core method of the Driver class that parses a text string into a syntax tree representation. It transforms raw text into structured linguistic data for further syntactic analysis or processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/blib2to3/pgen2/driver.py", "function": "_partially_consume_prefix", "line_number": 144, "body": "def _partially_consume_prefix(self, prefix: Text, column: int) -> Tuple[Text, Text]:\n        lines: List[str] = []\n        current_line = \"\"\n        current_column = 0\n        wait_for_nl = False\n        for char in prefix:\n            current_line += char\n            if wait_for_nl:\n                if char == \"\\n\":\n                    if current_line.strip() and current_column < column:\n                        res = \"\".join(lines)\n                        return res, prefix[len(res) :]\n\n                    lines.append(current_line)\n                    current_line = \"\"\n                    current_column = 0\n                    wait_for_nl = False\n            elif char in \" \\t\":\n                current_column += 1\n            elif char == \"\\n\":\n                # unexpected empty line\n                current_column = 0\n            else:\n                # indent is finished\n                wait_for_nl = True\n        return \"\".join(lines), current_line", "is_method": true, "class_name": "Driver", "function_description": "Utility method of the Driver class that processes a text prefix to extract lines up to a specified column indentation, returning the consumed part and the remaining text for further parsing or processing."}, {"file": "./dataset/RepoExec/test-apps/black/src/black_primer/cli.py", "function": "_handle_debug", "line_number": 25, "body": "def _handle_debug(\n    ctx: click.core.Context,\n    param: Union[click.core.Option, click.core.Parameter],\n    debug: Union[bool, int, str],\n) -> Union[bool, int, str]:\n    \"\"\"Turn on debugging if asked otherwise INFO default\"\"\"\n    log_level = logging.DEBUG if debug else logging.INFO\n    logging.basicConfig(\n        format=\"[%(asctime)s] %(levelname)s: %(message)s (%(filename)s:%(lineno)d)\",\n        level=log_level,\n    )\n    return debug", "is_method": false, "function_description": "Utility function that configures logging level based on a debug flag, enabling detailed debug output when requested and defaulting to info-level logging otherwise. It supports command-line contexts using click parameters."}, {"file": "./dataset/RepoExec/test-apps/black/src/black_primer/cli.py", "function": "main", "line_number": 124, "body": "def main(ctx: click.core.Context, **kwargs: Any) -> None:\n    \"\"\"primer - prime projects for blackening... \ud83c\udff4\"\"\"\n    LOG.debug(f\"Starting {sys.argv[0]}\")\n    # TODO: Change to asyncio.run when Black >= 3.7 only\n    loop = asyncio.get_event_loop()\n    try:\n        ctx.exit(loop.run_until_complete(async_main(**kwargs)))\n    finally:\n        loop.close()", "is_method": false, "function_description": "Starts the asynchronous main routine for the application using the given context and parameters, managing the event loop lifecycle for executing async tasks. It serves as the entry point for priming projects in preparation for formatting."}, {"file": "./dataset/RepoExec/test-apps/black/src/black_primer/lib.py", "function": "analyze_results", "line_number": 70, "body": "def analyze_results(project_count: int, results: Results) -> int:\n    failed_pct = round(((results.stats[\"failed\"] / project_count) * 100), 2)\n    success_pct = round(((results.stats[\"success\"] / project_count) * 100), 2)\n\n    click.secho(\"-- primer results \ud83d\udcca --\\n\", bold=True)\n    click.secho(\n        f\"{results.stats['success']} / {project_count} succeeded ({success_pct}%) \u2705\",\n        bold=True,\n        fg=\"green\",\n    )\n    click.secho(\n        f\"{results.stats['failed']} / {project_count} FAILED ({failed_pct}%) \ud83d\udca9\",\n        bold=bool(results.stats[\"failed\"]),\n        fg=\"red\",\n    )\n    s = \"\" if results.stats[\"disabled\"] == 1 else \"s\"\n    click.echo(f\" - {results.stats['disabled']} project{s} disabled by config\")\n    s = \"\" if results.stats[\"wrong_py_ver\"] == 1 else \"s\"\n    click.echo(\n        f\" - {results.stats['wrong_py_ver']} project{s} skipped due to Python version\"\n    )\n    click.echo(\n        f\" - {results.stats['skipped_long_checkout']} skipped due to long checkout\"\n    )\n\n    if results.failed_projects:\n        click.secho(\"\\nFailed projects:\\n\", bold=True)\n\n    for project_name, project_cpe in results.failed_projects.items():\n        print(f\"## {project_name}:\")\n        print(f\" - Returned {project_cpe.returncode}\")\n        if project_cpe.stderr:\n            print(f\" - stderr:\\n{project_cpe.stderr.decode('utf8')}\")\n        if project_cpe.stdout:\n            print(f\" - stdout:\\n{project_cpe.stdout.decode('utf8')}\")\n        print(\"\")\n\n    return results.stats[\"failed\"]", "is_method": false, "function_description": "Function that analyzes and summarizes project test results by calculating success and failure percentages, printing detailed statistics and error outputs for failed projects, and returning the total count of failed projects."}, {"file": "./dataset/RepoExec/test-apps/black/src/black_primer/lib.py", "function": "handle_PermissionError", "line_number": 187, "body": "def handle_PermissionError(\n    func: Callable, path: Path, exc: Tuple[Any, Any, Any]\n) -> None:\n    \"\"\"\n    Handle PermissionError during shutil.rmtree.\n\n    This checks if the erroring function is either 'os.rmdir' or 'os.unlink', and that\n    the error was EACCES (i.e. Permission denied). If true, the path is set writable,\n    readable, and executable by everyone. Finally, it tries the error causing delete\n    operation again.\n\n    If the check is false, then the original error will be reraised as this function\n    can't handle it.\n    \"\"\"\n    excvalue = exc[1]\n    LOG.debug(f\"Handling {excvalue} from {func.__name__}... \")\n    if func in (os.rmdir, os.unlink) and excvalue.errno == errno.EACCES:\n        LOG.debug(f\"Setting {path} writable, readable, and executable by everyone... \")\n        os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)  # chmod 0777\n        func(path)  # Try the error causing delete operation again\n    else:\n        raise", "is_method": false, "function_description": "Utility function that handles PermissionError during directory or file deletion by modifying path permissions to allow retry, ensuring removal operations succeed despite initial access restrictions."}]