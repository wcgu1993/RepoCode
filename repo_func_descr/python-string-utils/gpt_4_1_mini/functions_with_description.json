[{"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "reverse", "line_number": 282, "body": "def reverse(input_string: str) -> str:\n    \"\"\"\n    Returns the string with its chars reversed.\n\n    *Example:*\n\n    >>> reverse('hello') # returns 'olleh'\n\n    :param input_string: String to revert.\n    :type input_string: str\n    :return: Reversed string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return input_string[::-1]", "is_method": false, "function_description": "Function that returns the input string with its characters in reverse order. Useful for text processing tasks requiring reversed string output."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "camel_case_to_snake", "line_number": 300, "body": "def camel_case_to_snake(input_string, separator='_'):\n    \"\"\"\n    Convert a camel case string into a snake case one.\n    (The original string is returned if is not a valid camel case string)\n\n    *Example:*\n\n    >>> camel_case_to_snake('ThisIsACamelStringTest') # returns 'this_is_a_camel_case_string_test'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign to use as separator.\n    :type separator: str\n    :return: Converted string.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_camel_case(input_string):\n        return input_string\n\n    return CAMEL_CASE_REPLACE_RE.sub(lambda m: m.group(1) + separator, input_string).lower()", "is_method": false, "function_description": "Function that converts camel case strings to snake case using a specified separator, facilitating consistent naming conventions in code or data formatting. It returns the original string if the input is not valid camel case."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "snake_case_to_camel", "line_number": 324, "body": "def snake_case_to_camel(input_string: str, upper_case_first: bool = True, separator: str = '_') -> str:\n    \"\"\"\n    Convert a snake case string into a camel case one.\n    (The original string is returned if is not a valid snake case string)\n\n    *Example:*\n\n    >>> snake_case_to_camel('the_snake_is_green') # returns 'TheSnakeIsGreen'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param upper_case_first: True to turn the first letter into uppercase (default).\n    :type upper_case_first: bool\n    :param separator: Sign to use as separator (default to \"_\").\n    :type separator: str\n    :return: Converted string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    if not is_snake_case(input_string, separator):\n        return input_string\n\n    tokens = [s.title() for s in input_string.split(separator) if is_full_string(s)]\n\n    if not upper_case_first:\n        tokens[0] = tokens[0].lower()\n\n    out = ''.join(tokens)\n\n    return out", "is_method": false, "function_description": "Function that converts a valid snake_case string into camelCase or PascalCase format based on options, facilitating naming convention transformations in code or text processing."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "shuffle", "line_number": 357, "body": "def shuffle(input_string: str) -> str:\n    \"\"\"\n    Return a new string containing same chars of the given one but in a randomized order.\n\n    *Example:*\n\n    >>> shuffle('hello world') # possible output: 'l wodheorll'\n\n    :param input_string: String to shuffle\n    :type input_string: str\n    :return: Shuffled string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # turn the string into a list of chars\n    chars = list(input_string)\n\n    # shuffle the list\n    random.shuffle(chars)\n\n    # convert the shuffled list back to string\n    return ''.join(chars)", "is_method": false, "function_description": "Function that produces a randomized rearrangement of the characters in a given string. Useful for generating permutations or obfuscating text while preserving original characters."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "strip_html", "line_number": 382, "body": "def strip_html(input_string: str, keep_tag_content: bool = False) -> str:\n    \"\"\"\n    Remove html code contained into the given string.\n\n    *Examples:*\n\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>') # returns 'test: '\n    >>> strip_html('test: <a href=\"foo/bar\">click here</a>', keep_tag_content=True) # returns 'test: click here'\n\n    :param input_string: String to manipulate.\n    :type input_string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE\n\n    return r.sub('', input_string)", "is_method": false, "function_description": "Function that removes HTML tags from a string, optionally preserving the content inside those tags. Useful for cleaning or extracting plain text from HTML-formatted input."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "prettify", "line_number": 405, "body": "def prettify(input_string: str) -> str:\n    \"\"\"\n    Reformat a string by applying the following basic grammar and formatting rules:\n\n    - String cannot start or end with spaces\n    - The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n    - String cannot have multiple sequential spaces, empty lines or punctuation (except for \"?\", \"!\" and \".\")\n    - Arithmetic operators (+, -, /, \\\\*, =) must have one, and only one space before and after themselves\n    - One, and only one space should follow a dot, a comma, an exclamation or a question mark\n    - Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and \\\n    after quotes (foo\" bar\"baz -> foo \"bar\" baz)\n    - Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and \\\n    after brackets (\"foo(bar )baz\" -> \"foo (bar) baz\")\n    - Percentage sign (\"%\") cannot be preceded by a space if there is a number before (\"100 %\" -> \"100%\")\n    - Saxon genitive is correct (\"Dave' s dog\" -> \"Dave's dog\")\n\n    *Examples:*\n\n    >>> prettify(' unprettified string ,, like this one,will be\"prettified\" .it\\\\' s awesome! ')\n    >>> # -> 'Unprettified string, like this one, will be \"prettified\". It\\'s awesome!'\n\n    :param input_string: String to manipulate\n    :return: Prettified string.\n    \"\"\"\n    formatted = __StringFormatter(input_string).format()\n    return formatted", "is_method": false, "function_description": "Function that reformats strings to correct spacing, capitalization, punctuation, and common grammar issues, producing clean, consistently styled text suitable for user-facing display or textual data normalization."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "asciify", "line_number": 433, "body": "def asciify(input_string: str) -> str:\n    \"\"\"\n    Force string content to be ascii-only by translating all non-ascii chars into the closest possible representation\n    (eg: \u00f3 -> o, \u00cb -> E, \u00e7 -> c...).\n\n    **Bear in mind**: Some chars may be lost if impossible to translate.\n\n    *Example:*\n\n    >>> asciify('\u00e8\u00e9\u00f9\u00fa\u00f2\u00f3\u00e4\u00e5\u00eb\u00fd\u00f1\u00c5\u00c0\u00c1\u00c7\u00cc\u00cd\u00d1\u00d3\u00cb') # returns 'eeuuooaaeynAAACIINOE'\n\n    :param input_string: String to convert\n    :return: Ascii utf-8 string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # \"NFKD\" is the algorithm which is able to successfully translate the most of non-ascii chars\n    normalized = unicodedata.normalize('NFKD', input_string)\n\n    # encode string forcing ascii and ignore any errors (unrepresentable chars will be stripped out)\n    ascii_bytes = normalized.encode('ascii', 'ignore')\n\n    # turns encoded bytes into an utf-8 string\n    ascii_string = ascii_bytes.decode('utf-8')\n\n    return ascii_string", "is_method": false, "function_description": "Function that converts any string to an ASCII-only version by replacing accented and special characters with their closest ASCII equivalents, facilitating consistent text processing where non-ASCII characters are unsupported or problematic."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "slugify", "line_number": 462, "body": "def slugify(input_string: str, separator: str = '-') -> str:\n    \"\"\"\n    Converts a string into a \"slug\" using provided separator.\n    The returned string has the following properties:\n\n    - it has no spaces\n    - all letters are in lower case\n    - all punctuation signs and non alphanumeric chars are removed\n    - words are divided using provided separator\n    - all chars are encoded as ascii (by using `asciify()`)\n    - is safe for URL\n\n    *Examples:*\n\n    >>> slugify('Top 10 Reasons To Love Dogs!!!') # returns: 'top-10-reasons-to-love-dogs'\n    >>> slugify('M\u00f6nst\u00e9r M\u00e4gn\u00ebt') # returns 'monster-magnet'\n\n    :param input_string: String to convert.\n    :type input_string: str\n    :param separator: Sign used to join string tokens (default to \"-\").\n    :type separator: str\n    :return: Slug string\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    # replace any character that is NOT letter or number with spaces\n    out = NO_LETTERS_OR_NUMBERS_RE.sub(' ', input_string.lower()).strip()\n\n    # replace spaces with join sign\n    out = SPACES_RE.sub(separator, out)\n\n    # normalize joins (remove duplicates)\n    out = re.sub(re.escape(separator) + r'+', separator, out)\n\n    return asciify(out)", "is_method": false, "function_description": "Utility function that transforms any input string into a lowercase, URL-safe slug by removing punctuation, spaces, and non-alphanumeric characters, using a customizable separator between words."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "booleanize", "line_number": 500, "body": "def booleanize(input_string: str) -> bool:\n    \"\"\"\n    Turns a string into a boolean based on its content (CASE INSENSITIVE).\n\n    A positive boolean (True) is returned if the string value is one of the following:\n\n    - \"true\"\n    - \"1\"\n    - \"yes\"\n    - \"y\"\n\n    Otherwise False is returned.\n\n    *Examples:*\n\n    >>> booleanize('true') # returns True\n    >>> booleanize('YES') # returns True\n    >>> booleanize('nope') # returns False\n\n    :param input_string: String to convert\n    :type input_string: str\n    :return: True if the string contains a boolean-like positive value, false otherwise\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return input_string.lower() in ('true', '1', 'yes', 'y')", "is_method": false, "function_description": "Utility function that converts case-insensitive string representations of affirmative values into True, returning False otherwise. It is useful for interpreting user input or configuration values as boolean flags."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "strip_margin", "line_number": 529, "body": "def strip_margin(input_string: str) -> str:\n    \"\"\"\n    Removes tab indentation from multi line strings (inspired by analogous Scala function).\n\n    *Example:*\n\n    >>> strip_margin('''\n    >>>                 line 1\n    >>>                 line 2\n    >>>                 line 3\n    >>> ''')\n    >>> # returns:\n    >>> '''\n    >>> line 1\n    >>> line 2\n    >>> line 3\n    >>> '''\n\n    :param input_string: String to format\n    :type input_string: str\n    :return: A string without left margins\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    line_separator = '\\n'\n    lines = [MARGIN_RE.sub('', line) for line in input_string.split(line_separator)]\n    out = line_separator.join(lines)\n\n    return out", "is_method": false, "function_description": "Function that removes leading tab-based indentation from multi-line strings, simplifying their left margin for cleaner formatting and display in text processing or output formatting tasks."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "compress", "line_number": 561, "body": "def compress(input_string: str, encoding: str = 'utf-8', compression_level: int = 9) -> str:\n    \"\"\"\n    Compress the given string by returning a shorter one that can be safely used in any context (like URL) and\n    restored back to its original state using `decompress()`.\n\n    **Bear in mind:**\n    Besides the provided `compression_level`, the compression result (how much the string is actually compressed\n    by resulting into a shorter string) depends on 2 factors:\n\n    1. The amount of data (string size): short strings might not provide a significant compression result\\\n    or even be longer than the given input string (this is due to the fact that some bytes have to be embedded\\\n    into the compressed string in order to be able to restore it later on)\\\n\n    2. The content type: random sequences of chars are very unlikely to be successfully compressed, while the best\\\n    compression result is obtained when the string contains several recurring char sequences (like in the example).\n\n    Behind the scenes this method makes use of the standard Python's zlib and base64 libraries.\n\n    *Examples:*\n\n    >>> n = 0 # <- ignore this, it's a fix for Pycharm (not fixable using ignore comments)\n    >>> # \"original\" will be a string with 169 chars:\n    >>> original = ' '.join(['word n{}'.format(n) for n in range(20)])\n    >>> # \"compressed\" will be a string of 88 chars\n    >>> compressed = compress(original)\n\n    :param input_string: String to compress (must be not empty or a ValueError will be raised).\n    :type input_string: str\n    :param encoding: String encoding (default to \"utf-8\").\n    :type encoding: str\n    :param compression_level: A value between 0 (no compression) and 9 (best compression), default to 9.\n    :type compression_level: int\n    :return: Compressed string.\n    \"\"\"\n    return __StringCompressor.compress(input_string, encoding, compression_level)", "is_method": false, "function_description": "Function providing string compression into a shorter, safely transmittable format (e.g., for URLs) that can be restored later, supporting configurable encoding and compression levels to optimize size reduction."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "decompress", "line_number": 598, "body": "def decompress(input_string: str, encoding: str = 'utf-8') -> str:\n    \"\"\"\n    Restore a previously compressed string (obtained using `compress()`) back to its original state.\n\n    :param input_string: String to restore.\n    :type input_string: str\n    :param encoding: Original string encoding.\n    :type encoding: str\n    :return: Decompressed string.\n    \"\"\"\n    return __StringCompressor.decompress(input_string, encoding)", "is_method": false, "function_description": "Utility function that restores a previously compressed string to its original form using the specified encoding. It serves to reverse compression and recover the original textual data for further use."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "roman_encode", "line_number": 611, "body": "def roman_encode(input_number: Union[str, int]) -> str:\n    \"\"\"\n    Convert the given number/string into a roman number.\n\n    The passed input must represents a positive integer in the range 1-3999 (inclusive).\n\n    Why this limit? You may be wondering:\n\n    1. zero is forbidden since there is no related representation in roman numbers\n    2. the upper bound 3999 is due to the limitation in the ascii charset\\\n    (the higher quantity sign displayable in ascii is \"M\" which is equal to 1000, therefore based on\\\n    roman numbers rules we can use 3 times M to reach 3000 but we can't go any further in thousands without\\\n    special \"boxed chars\").\n\n    *Examples:*\n\n    >>> roman_encode(37) # returns 'XXXVIII'\n    >>> roman_encode('2020') # returns 'MMXX'\n\n    :param input_number: An integer or a string to be converted.\n    :type input_number: Union[str, int]\n    :return: Roman number string.\n    \"\"\"\n    return __RomanNumbers.encode(input_number)", "is_method": false, "function_description": "Utility function that converts a positive integer (1-3999) or its string representation into a Roman numeral string, enabling numeric values to be expressed in classical Roman number format."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "roman_decode", "line_number": 637, "body": "def roman_decode(input_string: str) -> int:\n    \"\"\"\n    Decode a roman number string into an integer if the provided string is valid.\n\n    *Example:*\n\n    >>> roman_decode('VII') # returns 7\n\n    :param input_string: (Assumed) Roman number\n    :type input_string: str\n    :return: Integer value\n    \"\"\"\n    return __RomanNumbers.decode(input_string)", "is_method": false, "function_description": "Function that converts a valid Roman numeral string into its integer equivalent, enabling numeric interpretation of Roman numeral inputs."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__encode_digit", "line_number": 53, "body": "def __encode_digit(cls, index: int, value: int) -> str:\n        # if digit is zero, there is no sign to display\n        if value == 0:\n            return ''\n\n        # from 1 to 3 we have just to repeat the sign N times (eg: III, XXX...)\n        if value <= 3:\n            return cls.__mappings[index][1] * value\n\n        # if 4 we have to add unit prefix\n        if value == 4:\n            return cls.__mappings[index][1] + cls.__mappings[index][5]\n\n        # if is 5, is a straight map\n        if value == 5:\n            return cls.__mappings[index][5]\n\n        # if 6, 7 or 8 we have to append unit suffixes\n        if value <= 8:\n            suffix = cls.__mappings[index][1] * (value - 5)\n            return cls.__mappings[index][5] + suffix\n\n        # if 9 we have to prepend current unit to next\n        return cls.__mappings[index][1] + cls.__mappings[index + 1][1]", "is_method": true, "class_name": "__RomanNumbers", "function_description": "Utility method of the __RomanNumbers class that converts a single digit value at a given place index into its Roman numeral representation, supporting correct numeral formation for values 0 through 9."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "encode", "line_number": 79, "body": "def encode(cls, input_number: Union[str, int]) -> str:\n        # force input conversion to a string (we need it in order to iterate on each digit)\n        input_string = str(input_number)\n\n        if not is_integer(input_string):\n            raise ValueError('Invalid input, only strings or integers are allowed')\n\n        value = int(input_string)\n\n        if value < 1 or value > 3999:\n            raise ValueError('Input must be >= 1 and <= 3999')\n\n        input_len = len(input_string)\n        output = ''\n\n        # decode digits from right to left (start from units to thousands)\n        for index in range(input_len):\n            # get actual digit value as int\n            digit = int(input_string[input_len - index - 1])\n\n            # encode digit to roman string\n            encoded_digit = cls.__encode_digit(index, digit)\n\n            # prepend encoded value to the current output in order to have the final string sorted\n            # from thousands to units\n            output = encoded_digit + output\n\n        return output", "is_method": true, "class_name": "__RomanNumbers", "function_description": "Method of the __RomanNumbers class that converts an integer (1 to 3999) into its Roman numeral representation as a string. It validates input type and range before providing the corresponding Roman numeral encoding."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__index_for_sign", "line_number": 109, "body": "def __index_for_sign(cls, sign: str) -> int:\n        for index, mapping in enumerate(cls.__reversed_mappings):\n            if sign in mapping:\n                return index\n\n        raise ValueError('Invalid token found: \"{}\"'.format(sign))", "is_method": true, "class_name": "__RomanNumbers", "function_description": "Utility method of the __RomanNumbers class that finds the index of a given Roman numeral sign within reversed mappings, raising an error if the sign is invalid. It supports validating and locating Roman numeral components."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "decode", "line_number": 117, "body": "def decode(cls, input_string: str) -> int:\n        if not is_full_string(input_string):\n            raise ValueError('Input must be a non empty string')\n\n        # reverse the provided string so that we can start parsing from units to thousands\n        reversed_string = reverse(input_string.upper())\n\n        # track last used value\n        last_value = None\n\n        # computed number to return\n        output = 0\n\n        # for each sign in the string we get its numeric value and add or subtract it to the computed output\n        for sign in reversed_string:\n            # are we dealing with units, tens, hundreds or thousands?\n            index = cls.__index_for_sign(sign)\n\n            # it's basically 1 or 5 (based on mapping rules definitions)\n            key_value = cls.__reversed_mappings[index][sign]\n\n            # Based on the level (tens, hundreds...) we have to add as many zeroes as the level into which we are\n            # in order to have the actual sign value.\n            # For instance, if we are at level 2 we are dealing with hundreds, therefore instead of 1 or 5, we will\n            # obtain 100 or 500 by adding 2 zeroes\n            sign_value = int(str(key_value) + '0' * index)\n\n            # increase total value if we are moving on with level\n            if last_value is None or sign_value >= last_value:\n                output += sign_value\n\n            # Decrease value if we are back to a previous level\n            # For instance, if we are parsing \"IX\", we first encounter \"X\" which is ten then \"I\" which is unit,\n            # So we have to do the following operation in order to get 9 (the final result): 10 - 1\n            else:\n                output -= sign_value\n\n            last_value = sign_value\n\n        return output", "is_method": true, "class_name": "__RomanNumbers", "function_description": "Decodes a Roman numeral string into its integer value, validating input and correctly handling subtractive notation. This function enables conversion from Roman numeral representations to standard integers."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__require_valid_input_and_encoding", "line_number": 162, "body": "def __require_valid_input_and_encoding(input_string: str, encoding: str):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        if len(input_string) == 0:\n            raise ValueError('Input string cannot be empty')\n\n        if not is_string(encoding):\n            raise ValueError('Invalid encoding')", "is_method": true, "class_name": "__StringCompressor", "function_description": "Private validation method of the __StringCompressor class that ensures the input is a non-empty string and the encoding parameter is a valid string before compression operations."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "compress", "line_number": 173, "body": "def compress(cls, input_string: str, encoding: str = 'utf-8', compression_level: int = 9) -> str:\n        cls.__require_valid_input_and_encoding(input_string, encoding)\n\n        if not isinstance(compression_level, int) or compression_level < 0 or compression_level > 9:\n            raise ValueError('Invalid compression_level: it must be an \"int\" between 0 and 9')\n\n        # turns input string into a sequence of bytes using provided encoding\n        original_bytes = input_string.encode(encoding)\n\n        # compress bytes using zlib library\n        compressed_bytes = zlib.compress(original_bytes, compression_level)\n\n        # encode compressed bytes using base64\n        # (this ensure that all characters will be available and that the output string can be used safely in any\n        # context such URLs)\n        encoded_bytes = base64.urlsafe_b64encode(compressed_bytes)\n\n        # finally turns base64 bytes into a string\n        output = encoded_bytes.decode(encoding)\n\n        return output", "is_method": true, "class_name": "__StringCompressor", "function_description": "Utility method of the __StringCompressor class that compresses a string into a base64-encoded format using zlib with configurable compression level, enabling safe, compact string storage or transmission across various contexts."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "decompress", "line_number": 196, "body": "def decompress(cls, input_string: str, encoding: str = 'utf-8') -> str:\n        cls.__require_valid_input_and_encoding(input_string, encoding)\n\n        # turns input string into a sequence of bytes\n        # (the string is assumed to be a previously compressed string, therefore we have to decode it using base64)\n        input_bytes = base64.urlsafe_b64decode(input_string)\n\n        # decompress bytes using zlib\n        decompressed_bytes = zlib.decompress(input_bytes)\n\n        # decode the decompressed bytes to get the original string back\n        original_string = decompressed_bytes.decode(encoding)\n\n        return original_string", "is_method": true, "class_name": "__StringCompressor", "function_description": "Decompresses a base64-encoded and zlib-compressed string back to its original form using the specified text encoding. This method enables recovery of compressed string data for further use or processing."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__uppercase_first_char", "line_number": 219, "body": "def __uppercase_first_char(self, regex_match):\n        return regex_match.group(0).upper()", "is_method": true, "class_name": "__StringFormatter", "function_description": "Private helper method in the __StringFormatter class that converts the first character of a regex match to uppercase, typically used for text formatting or capitalization processes."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__remove_duplicates", "line_number": 222, "body": "def __remove_duplicates(self, regex_match):\n        return regex_match.group(1)[0]", "is_method": true, "class_name": "__StringFormatter", "function_description": "Private helper method of the __StringFormatter class that returns the first character from a regex match group to remove duplicate consecutive characters. It supports internal string deduplication processes."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__uppercase_first_letter_after_sign", "line_number": 225, "body": "def __uppercase_first_letter_after_sign(self, regex_match):\n        match = regex_match.group(1)\n        return match[:-1] + match[2].upper()", "is_method": true, "class_name": "__StringFormatter", "function_description": "Private helper method in __StringFormatter that transforms a regex match by uppercasing the first letter following a specific sign in the matched text."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__ensure_right_space_only", "line_number": 229, "body": "def __ensure_right_space_only(self, regex_match):\n        return regex_match.group(1).strip() + ' '", "is_method": true, "class_name": "__StringFormatter", "function_description": "Private method of the __StringFormatter class that ensures a single trailing space follows a matched substring, helping maintain consistent spacing in formatted strings."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__ensure_left_space_only", "line_number": 232, "body": "def __ensure_left_space_only(self, regex_match):\n        return ' ' + regex_match.group(1).strip()", "is_method": true, "class_name": "__StringFormatter", "function_description": "Private helper method of the __StringFormatter class that ensures only a single leading space is retained before matched text, trimming any extra spaces on the left side."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__ensure_spaces_around", "line_number": 235, "body": "def __ensure_spaces_around(self, regex_match):\n        return ' ' + regex_match.group(1).strip() + ' '", "is_method": true, "class_name": "__StringFormatter", "function_description": "Private utility method of the __StringFormatter class that ensures a matched substring is padded with spaces on both sides, aiding consistent formatting of text segments during string manipulation."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__remove_internal_spaces", "line_number": 238, "body": "def __remove_internal_spaces(self, regex_match):\n        return regex_match.group(1).strip()", "is_method": true, "class_name": "__StringFormatter", "function_description": "Core utility method of the __StringFormatter class that removes leading and trailing spaces from a regex match's captured group, aiding in precise string formatting or cleaning operations."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__fix_saxon_genitive", "line_number": 241, "body": "def __fix_saxon_genitive(self, regex_match):\n        return regex_match.group(1).replace(' ', '') + ' '", "is_method": true, "class_name": "__StringFormatter", "function_description": "Private helper method in __StringFormatter that corrects spacing in Saxon genitive expressions by removing spaces before the possessive apostrophe."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "__placeholder_key", "line_number": 247, "body": "def __placeholder_key():\n        return '$' + uuid4().hex + '$'", "is_method": true, "class_name": "__StringFormatter", "function_description": "Generates a unique placeholder string using a random UUID, typically used to mark or substitute text segments uniquely during string processing."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/manipulation.py", "function": "format", "line_number": 250, "body": "def format(self) -> str:\n        # map of temporary placeholders\n        placeholders = {}\n        out = self.input_string\n\n        # looks for url or email and updates placeholders map with found values\n        placeholders.update({self.__placeholder_key(): m[0] for m in URLS_RE.findall(out)})\n        placeholders.update({self.__placeholder_key(): m for m in EMAILS_RE.findall(out)})\n\n        # replace original value with the placeholder key\n        for p in placeholders:\n            out = out.replace(placeholders[p], p, 1)\n\n        out = PRETTIFY_RE['UPPERCASE_FIRST_LETTER'].sub(self.__uppercase_first_char, out)\n        out = PRETTIFY_RE['DUPLICATES'].sub(self.__remove_duplicates, out)\n        out = PRETTIFY_RE['RIGHT_SPACE'].sub(self.__ensure_right_space_only, out)\n        out = PRETTIFY_RE['LEFT_SPACE'].sub(self.__ensure_left_space_only, out)\n        out = PRETTIFY_RE['SPACES_AROUND'].sub(self.__ensure_spaces_around, out)\n        out = PRETTIFY_RE['SPACES_INSIDE'].sub(self.__remove_internal_spaces, out)\n        out = PRETTIFY_RE['UPPERCASE_AFTER_SIGN'].sub(self.__uppercase_first_letter_after_sign, out)\n        out = PRETTIFY_RE['SAXON_GENITIVE'].sub(self.__fix_saxon_genitive, out)\n        out = out.strip()\n\n        # restore placeholder keys with their associated original value\n        for p in placeholders:\n            out = out.replace(p, placeholders[p], 1)\n\n        return out", "is_method": true, "class_name": "__StringFormatter", "function_description": "Core method of the __StringFormatter class that normalizes and prettifies an input string by formatting spaces, casing, duplicates, and special text patterns while preserving and restoring URLs and email addresses."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_string", "line_number": 83, "body": "def is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)", "is_method": false, "function_description": "Utility function that determines whether a given object is a string, facilitating type-checking in data processing or validation tasks."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_full_string", "line_number": 98, "body": "def is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    return is_string(input_string) and input_string.strip() != ''", "is_method": false, "function_description": "Utility function that checks if an input is a non-empty string containing at least one non-space character, useful for validating meaningful textual input."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_number", "line_number": 116, "body": "def is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None", "is_method": false, "function_description": "Function that determines whether a given string represents a valid numeric value, including integers, decimals, signed numbers, and scientific notation. It provides input validation useful for parsing or data processing tasks requiring numeric detection."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_integer", "line_number": 141, "body": "def is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string", "is_method": false, "function_description": "Function that determines if a string represents a whole integer (including signed and scientific notation forms) but excludes decimal numbers. Useful for validating numeric input where only integers are acceptable."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_decimal", "line_number": 159, "body": "def is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string", "is_method": false, "function_description": "Utility function that determines if a string represents a decimal number (including signed or scientific notation), distinguishing decimals from integers for accurate numeric type identification."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_url", "line_number": 177, "body": "def is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    valid = URL_RE.match(input_string) is not None\n\n    if allowed_schemes:\n        return valid and any([input_string.startswith(s) for s in allowed_schemes])\n\n    return valid", "is_method": false, "function_description": "Utility function that verifies whether a given string is a valid URL, optionally restricting the check to specified URL schemes like 'http' or 'https'. It supports input validation for URL recognition in applications requiring URL format confirmation."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_email", "line_number": 204, "body": "def is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    # first simple \"pre check\": it must be a non empty string with max len 320 and cannot start with a dot\n    if not is_full_string(input_string) or len(input_string) > 320 or input_string.startswith('.'):\n        return False\n\n    try:\n        # we expect 2 tokens, one before \"@\" and one after, otherwise we have an exception and the email is not valid\n        head, tail = input_string.split('@')\n\n        # head's size must be <= 64, tail <= 255, head must not start with a dot or contain multiple consecutive dots\n        if len(head) > 64 or len(tail) > 255 or head.endswith('.') or ('..' in head):\n            return False\n\n        # removes escaped spaces, so that later on the test regex will accept the string\n        head = head.replace('\\\\ ', '')\n        if head.startswith('\"') and head.endswith('\"'):\n            head = head.replace(' ', '')[1:-1]\n\n        return EMAIL_RE.match(head + '@' + tail) is not None\n\n    except ValueError:\n        # borderline case in which we have multiple \"@\" signs but the head part is correctly escaped\n        if ESCAPED_AT_SIGN.search(input_string) is not None:\n            # replace \"@\" with \"a\" in the head\n            return is_email(ESCAPED_AT_SIGN.sub('a', input_string))\n\n        return False", "is_method": false, "function_description": "Function that validates whether a given string conforms to the standard format of an email address, ensuring structural and length constraints. It is useful for input validation where confirming email correctness is required."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_credit_card", "line_number": 247, "body": "def is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if card_type:\n        if card_type not in CREDIT_CARDS:\n            raise KeyError(\n                'Invalid card type \"{}\". Valid types are: {}'.format(card_type, ', '.join(CREDIT_CARDS.keys()))\n            )\n        return CREDIT_CARDS[card_type].match(input_string) is not None\n\n    for c in CREDIT_CARDS:\n        if CREDIT_CARDS[c].match(input_string) is not None:\n            return True\n\n    return False", "is_method": false, "function_description": "Utility function that validates whether a string represents a valid credit card number, optionally restricted to a specific card type from popular providers like VISA or MASTERCARD."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_camel_case", "line_number": 286, "body": "def is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None", "is_method": false, "function_description": "Utility function that checks if a given string follows camel case formatting, containing both uppercase and lowercase letters, and starting with a letter. It helps validate naming conventions in code or data inputs."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_snake_case", "line_number": 308, "body": "def is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n    if is_full_string(input_string):\n        re_map = {\n            '_': SNAKE_CASE_TEST_RE,\n            '-': SNAKE_CASE_TEST_DASH_RE\n        }\n        re_template = r'([a-z]+\\d*{sign}[a-z\\d{sign}]*|{sign}+[a-z\\d]+[a-z\\d{sign}]*)'\n        r = re_map.get(\n            separator,\n            re.compile(re_template.format(sign=re.escape(separator)), re.IGNORECASE)\n        )\n\n        return r.match(input_string) is not None\n\n    return False", "is_method": false, "function_description": "Utility function that determines if a string conforms to snake case formatting using a specified separator, supporting validation of identifiers or variable names in code or data processing tasks."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_json", "line_number": 345, "body": "def is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if is_full_string(input_string) and JSON_WRAPPER_RE.match(input_string) is not None:\n        try:\n            return isinstance(json.loads(input_string), (dict, list))\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    return False", "is_method": false, "function_description": "Utility function that determines whether a given string is a valid JSON object or array, aiding input validation and data parsing processes."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_uuid", "line_number": 368, "body": "def is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None", "is_method": false, "function_description": "Function that determines whether a given string represents a valid UUID, optionally accepting a hex-only format. It is useful for validating identifiers in applications requiring UUID verification."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_ip_v4", "line_number": 393, "body": "def is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True", "is_method": false, "function_description": "Utility function that validates whether a given string represents a well-formed IPv4 address, ensuring correct format and numeric range for each octet. This aids input validation in networking-related applications."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_ip_v6", "line_number": 418, "body": "def is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None", "is_method": false, "function_description": "Function that verifies whether a given string is a valid IPv6 address, providing a simple way to validate IP formats in networking or data processing applications."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_ip", "line_number": 434, "body": "def is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    return is_ip_v6(input_string) or is_ip_v4(input_string)", "is_method": false, "function_description": "Function that determines whether a given string is a valid IPv4 or IPv6 address. It is useful for validating input or filtering network-related data."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_palindrome", "line_number": 451, "body": "def is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    *Examples:*\n\n    >>> is_palindrome('LOL') # returns true\n    >>> is_palindrome('Lol') # returns false\n    >>> is_palindrome('Lol', ignore_case=True) # returns true\n    >>> is_palindrome('ROTFL') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param ignore_spaces: False if white spaces matter (default), true otherwise.\n    :type ignore_spaces: bool\n    :param ignore_case: False if char case matters (default), true otherwise.\n    :type ignore_case: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\\\n    False otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if ignore_spaces:\n        input_string = SPACES_RE.sub('', input_string)\n\n    string_len = len(input_string)\n\n    # Traverse the string one char at step, and for each step compares the\n    # \"head_char\" (the one on the left of the string) to the \"tail_char\" (the one on the right).\n    # In this way we avoid to manipulate the whole string in advance if not necessary and provide a faster\n    # algorithm which can scale very well for long strings.\n    for index in range(string_len):\n        head_char = input_string[index]\n        tail_char = input_string[string_len - index - 1]\n\n        if ignore_case:\n            head_char = head_char.lower()\n            tail_char = tail_char.lower()\n\n        if head_char != tail_char:\n            return False\n\n    return True", "is_method": false, "function_description": "Function that determines whether a given string is a palindrome, with options to ignore spaces and character case. It helps validate palindromic strings for use cases like text analysis or pattern recognition."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_pangram", "line_number": 497, "body": "def is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return set(SPACES_RE.sub('', input_string)).issuperset(set(string.ascii_lowercase))", "is_method": false, "function_description": "Function that determines whether a given string contains every letter of the English alphabet at least once, useful for validating pangram sentences in text processing."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_isogram", "line_number": 516, "body": "def is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and len(set(input_string)) == len(input_string)", "is_method": false, "function_description": "Function that determines whether a given string is an isogram, meaning it contains no repeating letters. It can be used for validating inputs or analyzing text uniqueness properties."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_slug", "line_number": 532, "body": "def is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None", "is_method": false, "function_description": "Utility function that determines if a given string conforms to the format of a slug, typically lowercase words separated by a specified character, aiding validation of URL-friendly identifiers."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "contains_html", "line_number": 555, "body": "def contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return HTML_RE.search(input_string) is not None", "is_method": false, "function_description": "Function that detects whether a given string contains any HTML or XML tags, useful for identifying potentially malicious or unwanted markup in text inputs."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "words_count", "line_number": 577, "body": "def words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return len(WORDS_COUNT_RE.findall(input_string))", "is_method": false, "function_description": "Function that counts and returns the number of alphanumeric words in a string, correctly handling punctuation as word separators. It serves as a utility for accurate word count in text processing tasks."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_isbn_10", "line_number": 601, "body": "def is_isbn_10(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 10 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_10('1506715214') # returns true\n    >>> is_isbn_10('150-6715214') # returns true\n    >>> is_isbn_10('150-6715214', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 10, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_10()", "is_method": false, "function_description": "Function that validates whether a given string is a properly formatted ISBN-10, optionally allowing hyphens. It helps verify book identifier correctness in various input formats."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_isbn_13", "line_number": 621, "body": "def is_isbn_13(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 13 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_13('9780312498580') # returns true\n    >>> is_isbn_13('978-0312498580') # returns true\n    >>> is_isbn_13('978-0312498580', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 13, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13()", "is_method": false, "function_description": "Utility function that validates whether a given string is a properly formatted ISBN-13, optionally ignoring hyphens. It helps confirm the correctness of book identifier inputs in applications handling bibliographic data."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_isbn", "line_number": 641, "body": "def is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()", "is_method": false, "function_description": "Utility function that validates whether a string is a correct ISBN-10 or ISBN-13, optionally ignoring hyphens. It provides ISBN validation to support book identification and cataloging tasks."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_isbn_13", "line_number": 49, "body": "def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if (index % 2 == 0) else 3\n                    product += int(digit) * weight\n\n                return product % 10 == 0\n\n            except ValueError:\n                pass\n\n        return False", "is_method": true, "class_name": "__ISBNChecker", "function_description": "Method of the __ISBNChecker class that verifies whether the input string is a valid ISBN-13 by checking its length and checksum digit according to ISBN-13 standards. It provides a boolean validation result for ISBN-13 format correctness."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/validation.py", "function": "is_isbn_10", "line_number": 65, "body": "def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False", "is_method": true, "class_name": "__ISBNChecker", "function_description": "Core method of the __ISBNChecker class that verifies if the input string is a valid ISBN-10 number by checking length and checksum validity. It provides a boolean confirmation for ISBN-10 format compliance."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/generation.py", "function": "uuid", "line_number": 21, "body": "def uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)", "is_method": false, "function_description": "Utility function that generates a random UUID string, optionally returning it as a hex value without dashes, useful for creating unique identifiers in various contexts."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/generation.py", "function": "random_string", "line_number": 41, "body": "def random_string(size: int) -> str:\n    \"\"\"\n    Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n    *Example:*\n\n    >>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n    :param size: Desired string size\n    :type size: int\n    :return: Random string\n    \"\"\"\n    if not isinstance(size, int) or size < 1:\n        raise ValueError('size must be >= 1')\n\n    chars = string.ascii_letters + string.digits\n    buffer = [random.choice(chars) for _ in range(size)]\n    out = ''.join(buffer)\n\n    return out", "is_method": false, "function_description": "Utility function that generates a random alphanumeric string of a given length, useful for creating identifiers, tokens, or random data in testing and security contexts."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/generation.py", "function": "secure_random_hex", "line_number": 63, "body": "def secure_random_hex(byte_count: int) -> str:\n    \"\"\"\n    Generates a random string using secure low level random generator (os.urandom).\n\n    **Bear in mind**: due to hex conversion, the returned string will have a size that is exactly\\\n    the double of the given `byte_count`.\n\n    *Example:*\n\n    >>> secure_random_hex(9) # possible output: 'aac4cf1d1d87bd5036'\n\n    :param byte_count: Number of random bytes to generate\n    :type byte_count: int\n    :return: Hexadecimal string representation of generated random bytes\n    \"\"\"\n    if not isinstance(byte_count, int) or byte_count < 1:\n        raise ValueError('byte_count must be >= 1')\n\n    random_bytes = os.urandom(byte_count)\n    hex_bytes = binascii.hexlify(random_bytes)\n    hex_string = hex_bytes.decode()\n\n    return hex_string", "is_method": false, "function_description": "Function that produces a cryptographically secure random hexadecimal string of twice the specified byte length, useful for generating unpredictable tokens or identifiers."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/generation.py", "function": "roman_range", "line_number": 88, "body": "def roman_range(stop: int, start: int = 1, step: int = 1) -> Generator:\n    \"\"\"\n    Similarly to native Python's `range()`, returns a Generator object which generates a new roman number\n    on each iteration instead of an integer.\n\n    *Example:*\n\n    >>> for n in roman_range(7): print(n)\n    >>> # prints: I, II, III, IV, V, VI, VII\n    >>> for n in roman_range(start=7, stop=1, step=-1): print(n)\n    >>> # prints: VII, VI, V, IV, III, II, I\n\n    :param stop: Number at which the generation must stop (must be <= 3999).\n    :param start: Number at which the generation must start (must be >= 1).\n    :param step: Increment of each generation step (default to 1).\n    :return: Generator of roman numbers.\n    \"\"\"\n\n    def validate(arg_value, arg_name, allow_negative=False):\n        msg = '\"{}\" must be an integer in the range 1-3999'.format(arg_name)\n\n        if not isinstance(arg_value, int):\n            raise ValueError(msg)\n\n        if allow_negative:\n            arg_value = abs(arg_value)\n\n        if arg_value < 1 or arg_value > 3999:\n            raise ValueError(msg)\n\n    def generate():\n        current = start\n\n        # generate values for each step\n        while current != stop:\n            yield roman_encode(current)\n            current += step\n\n        # last value to return\n        yield roman_encode(current)\n\n    # checks each single argument value\n    validate(stop, 'stop')\n    validate(start, 'start')\n    validate(step, 'step', allow_negative=True)\n\n    # checks if the provided configuration leads to a feasible iteration with respect to boundaries or not\n    forward_exceed = step > 0 and (start > stop or start + step > stop)\n    backward_exceed = step < 0 and (start < stop or start + step < stop)\n    if forward_exceed or backward_exceed:\n        raise OverflowError('Invalid start/stop/step configuration')\n\n    return generate()", "is_method": false, "function_description": "Generates a sequence of Roman numerals between specified start and stop integers with a given step, similar to Python's range(). Useful for iterating over Roman numeral ranges in custom numeric formats or displays."}, {"file": "./dataset/RepoExec/test-apps/python-string-utils/string_utils/generation.py", "function": "validate", "line_number": 106, "body": "def validate(arg_value, arg_name, allow_negative=False):\n        msg = '\"{}\" must be an integer in the range 1-3999'.format(arg_name)\n\n        if not isinstance(arg_value, int):\n            raise ValueError(msg)\n\n        if allow_negative:\n            arg_value = abs(arg_value)\n\n        if arg_value < 1 or arg_value > 3999:\n            raise ValueError(msg)", "is_method": false, "function_description": "This function validates that a given argument is an integer within the range 1 to 3999, optionally allowing negative inputs by converting them to positive. It ensures input correctness for parameters requiring constrained integer values."}]