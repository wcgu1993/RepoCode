[{"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_m", "line_number": 31, "body": "def _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)", "is_method": false, "function_description": "Forms a dot-separated string from input parts. Useful for constructing hierarchical names like module paths or fully qualified identifiers."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_attr", "line_number": 36, "body": "def _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n", "is_method": false, "function_description": "Safely retrieves a nested attribute from an object using a dot-separated string path. It returns None if any part of the path is not found, preventing AttributeError."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_defaults", "line_number": 46, "body": "def _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)", "is_method": false, "function_description": "Generates a sequence of formatted string representations for given expressions, returning a space for `None` values. This internal helper transforms AST nodes into readable code snippets or literals."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "parent", "line_number": 51, "body": "def parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]", "is_method": false, "function_description": "Retrieves the parent segment of a dot-separated hierarchical name. It allows specifying the desired number of levels to ascend in the hierarchy."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "is_magic", "line_number": 56, "body": "def is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'", "is_method": false, "function_description": "This function checks if a given name string follows the Python 'magic' or 'dunder' naming convention. It helps identify special Python methods or attributes for introspection or analysis."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "is_public_family", "line_number": 62, "body": "def is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True", "is_method": false, "function_description": "Checks if a dotted Python name represents a public entity by verifying none of its non-magic components start with an underscore, indicating a private element."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "walk_body", "line_number": 74, "body": "def walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node", "is_method": false, "function_description": "Recursively traverses an Abstract Syntax Tree (AST) body, yielding all individual statements, including those nested within conditional and exception handling blocks. This flattens the statement structure for analysis."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "code", "line_number": 90, "body": "def code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"", "is_method": false, "function_description": "Formats a string for display as inline code, escaping Markdown characters like '|'. It wraps the content in backticks or HTML `<code>` tags as appropriate."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "esc_underscore", "line_number": 101, "body": "def esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc", "is_method": false, "function_description": "Escapes all underscores in a string by replacing them with `\\_`, but only if the string contains more than one underscore."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "doctest", "line_number": 109, "body": "def doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)", "is_method": false, "function_description": "Transforms a string of Python doctests into Markdown code blocks. Each line beginning with '>>>' is individually enclosed in a `python` code fence."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_table_cell", "line_number": 130, "body": "def _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'", "is_method": false, "function_description": "Formats a sequence of strings into a single string, representing a row of table cells. Useful for generating text-based tables."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_table_split", "line_number": 135, "body": "def _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'", "is_method": false, "function_description": "Creates a Markdown-compatible table row separator string. It dynamically sizes the separator segments based on the provided column headers' lengths."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "table", "line_number": 141, "body": "def table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'", "is_method": false, "function_description": "Generates a multi-column table string from provided titles and data items. It formats tabular information for clear display in text-based outputs."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_type_name", "line_number": 156, "body": "def _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__", "is_method": false, "function_description": "Returns the fully qualified name of an object's type. This function provides a precise string representation for introspection or debugging."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_e_type", "line_number": 161, "body": "def _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'", "is_method": false, "function_description": "This utility function determines and formats the types of constant values found within sequences of expressions. It provides a structured string representation, indicating 'Any' if types vary."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "const_type", "line_number": 182, "body": "def const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (Tuple, List, Set)):\n        return _type_name(node).lower() + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        return 'dict' + _e_type(node.keys, node.values)\n    elif isinstance(node, Call) and isinstance(node.func, (Name, Attribute)):\n        func = unparse(node.func)\n        if func in chain({'bool', 'int', 'float', 'complex', 'str'},\n                         PEP585.keys(), PEP585.values()):\n            return func\n    return ANY", "is_method": false, "function_description": "Performs constant type inference for an Abstract Syntax Tree (AST) expression node. It returns the string type for literals, collections, and results of common built-in type constructors."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "visit_Constant", "line_number": 208, "body": "def visit_Constant(self, node: Constant) -> AST:\n        \"\"\"Check string is a name.\"\"\"\n        if not isinstance(node.value, str):\n            return node\n        try:\n            e = cast(Expr, parse(node.value).body[0])\n        except SyntaxError:\n            return node\n        else:\n            return self.visit(e.value)", "is_method": true, "class_name": "Resolver", "function_description": "The Resolver's `visit_Constant` method interprets string constants as Python expressions. It recursively visits the resulting AST node, enabling the resolution of dynamically embedded code within string literals."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "visit_Name", "line_number": 219, "body": "def visit_Name(self, node: Name) -> AST:\n        \"\"\"Replace global names with its expression recursively.\"\"\"\n        if node.id == self.self_ty:\n            return Name(\"Self\", Load())\n        name = _m(self.root, node.id)\n        if name in self.alias and name not in self.alias[name]:\n            e = cast(Expr, parse(self.alias[name]).body[0])\n            # Support `TypeVar`\n            if isinstance(e.value, Call) and isinstance(e.value.func, Name):\n                func_name = e.value.func.id\n                idf = self.alias.get(_m(self.root, func_name), func_name)\n                if idf == 'typing.TypeVar':\n                    return node\n            return self.visit(e.value)\n        else:\n            return node", "is_method": true, "class_name": "Resolver", "function_description": "Transforms AST `Name` nodes by replacing them with their resolved expressions or special types. It provides name resolution and substitution, crucial for static analysis or code transformation tasks."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "visit_Subscript", "line_number": 236, "body": "def visit_Subscript(self, node: Subscript) -> AST:\n        \"\"\"Implementation of PEP585 and PEP604.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        name = node.value.id\n        idf = self.alias.get(_m(self.root, name), name)\n        if idf == 'typing.Union':\n            if not isinstance(node.slice, Tuple):\n                return node.slice\n            b = node.slice.elts[0]\n            for e in node.slice.elts[1:]:\n                b = BinOp(b, BitOr(), e)\n            return b\n        elif idf == 'typing.Optional':\n            return BinOp(node.slice, BitOr(), Constant(None))\n        elif idf in PEP585:\n            logger.warning(f\"{node.lineno}:{node.col_offset}: \"\n                           f\"find deprecated name {idf}, \"\n                           f\"recommended to use {PEP585[idf]}\")\n            return Subscript(Name(PEP585[idf], Load), node.slice, node.ctx)\n        else:\n            return node", "is_method": true, "class_name": "Resolver", "function_description": "Modernizes Python type hint syntax within AST subscript nodes. It transforms legacy `typing.Union`, `typing.Optional`, and PEP 585 generics into their contemporary forms (e.g., `A | B`, `list[int]`)."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "visit_Attribute", "line_number": 259, "body": "def visit_Attribute(self, node: Attribute) -> AST:\n        \"\"\"Remove `typing.*` prefix of annotation.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        if node.value.id == 'typing':\n            return Name(node.attr, Load())\n        else:\n            return node", "is_method": true, "class_name": "Resolver", "function_description": "The `visit_Attribute` method transforms AST nodes by removing the 'typing.' prefix from type annotations. This simplifies qualified `typing` module references, converting `typing.List` to `List` for further processing."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "new", "line_number": 295, "body": "def new(cls: type[_Self], link: bool, level: int, toc: bool) -> _Self:\n        \"\"\"Create a parser by options.\"\"\"\n        return cls(link, level, toc)", "is_method": true, "class_name": "Parser", "function_description": "A class method that creates and returns a new Parser instance, configured with specified options for link handling, parsing level, and table of contents generation."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "__post_init__", "line_number": 299, "body": "def __post_init__(self):\n        if self.toc:\n            self.link = True", "is_method": true, "class_name": "Parser", "function_description": "This method initializes the Parser object by setting `link` to `True` if `toc` (table of contents) is enabled. It ensures linking functionality is active when a table of contents is present."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "parse", "line_number": 303, "body": "def parse(self, root: str, script: str) -> None:\n        \"\"\"Main parser of the entire module.\"\"\"\n        self.doc[root] = '#' * self.b_level + \"# Module `{}`\"\n        if self.link:\n            self.doc[root] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[root] += '\\n\\n'\n        self.level[root] = root.count('.')\n        self.imp[root] = set()\n        self.root[root] = root\n        root_node = parse(script, type_comments=True)\n        for node in walk_body(root_node.body):\n            # \"Execute\" assignments\n            if isinstance(node, (Import, ImportFrom)):\n                self.imports(root, node)\n            elif isinstance(node, (Assign, AnnAssign)):\n                self.globals(root, node)\n        doc = get_docstring(root_node)\n        if doc is not None:\n            self.docstring[root] = doctest(doc)\n        for node in walk_body(root_node.body):\n            if isinstance(node, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, node)", "is_method": true, "class_name": "Parser", "function_description": "This method serves as the primary parser for a Python module. It processes the script, extracting and organizing information about its structure, imports, globals, functions, and classes for internal representation."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "imports", "line_number": 326, "body": "def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)", "is_method": true, "class_name": "Parser", "function_description": "This Parser method processes AST import nodes to record mappings between imported names (and their aliases) and their fully qualified module paths. It supports static analysis by tracking symbol origins."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "globals", "line_number": 341, "body": "def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))", "is_method": true, "class_name": "Parser", "function_description": "This Parser method processes global assignments, identifying and setting up type aliases, constants, and the `__all__` variable."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "api", "line_number": 381, "body": "def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)", "is_method": true, "class_name": "Parser", "function_description": "This method of the Parser class generates API documentation for Python functions and classes. It formats the basic structure, includes decorators and docstrings, and recursively handles nested definitions."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "func_api", "line_number": 418, "body": "def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])", "is_method": true, "class_name": "Parser", "function_description": "Method of the Parser class that formats and adds a function's full API signature to the internal documentation. It processes all argument types and the return annotation for clear representation."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "class_api", "line_number": 451, "body": "def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))", "is_method": true, "class_name": "Parser", "function_description": "Processes a Python class definition to extract base classes, enum members, and public attributes. It then generates structured API documentation for the class within the parser's documentation structure."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "func_ann", "line_number": 494, "body": "def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY", "is_method": true, "class_name": "Parser", "function_description": "Generates resolved type annotations for a function's arguments, correctly handling `self` for instance and class methods. It provides a processed sequence of annotations."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "resolve", "line_number": 513, "body": "def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))", "is_method": true, "class_name": "Parser", "function_description": "Provides the service of resolving global names found within an Abstract Syntax Tree expression node. This is typically used for processing type annotations, returning the unparsed string representation of the resolved expression."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "load_docstring", "line_number": 518, "body": "def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)", "is_method": true, "class_name": "Parser", "function_description": "This method extracts and processes docstrings for qualified names within a given Python module. It populates an internal dictionary, making these docstrings available for analysis or documentation purposes."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "__is_immediate_family", "line_number": 528, "body": "def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))", "is_method": true, "class_name": "Parser", "function_description": "Determines if two names, `n1` and `n2`, represent an 'immediate family' relationship according to the parser's internal hierarchical rules. This private method verifies specific structural dependencies between the names."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "__find_alias", "line_number": 532, "body": "def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)", "is_method": true, "class_name": "Parser", "function_description": "Performs alias substitution within the parser's internal document structures. It renames and remaps entries based on defined aliases to normalize data representation."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "is_public", "line_number": 550, "body": "def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)", "is_method": true, "class_name": "Parser", "function_description": "Determines if a given Python name should be considered public, based on common naming conventions or explicit module declarations. This is useful for tools analyzing or documenting code."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "__get_const", "line_number": 564, "body": "def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"", "is_method": true, "class_name": "Parser", "function_description": "This method retrieves and formats a table of public constants associated with a given name from the parser's definitions. It provides a structured representation for specific constant sets."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "__names_cmp", "line_number": 576, "body": "def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()", "is_method": true, "class_name": "Parser", "function_description": "Generates a multi-criteria sort key for a given name string. This enables consistent comparison and ordering of names based on internal levels and case sensitivity rules."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "compile", "line_number": 580, "body": "def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'", "is_method": true, "class_name": "Parser", "function_description": "This method compiles internal documentation data into a single, formatted string, optionally including a table of contents. It filters for public items, producing a structured output suitable for user-facing documentation."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "_read", "line_number": 24, "body": "def _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()", "is_method": false, "function_description": "This function reads the entire content of a file from the specified path. It serves as a simple utility for loading text data from disk."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "_write", "line_number": 30, "body": "def _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)", "is_method": false, "function_description": "Writes a given string of text content to a file at the specified path. It creates or overwrites the file if it exists."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "_site_path", "line_number": 36, "body": "def _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])", "is_method": false, "function_description": "Provides the installation directory for a specified Python module or package, such as its location within `site-packages`, if found on the system."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "walk_packages", "line_number": 44, "body": "def walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path", "is_method": false, "function_description": "Provides an iterator over Python modules and packages found under a given path. It yields module names and their file paths, enabling static analysis or discovery without importing code."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "_load_module", "line_number": 63, "body": "def _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False", "is_method": false, "function_description": "Dynamically loads a Python module from a specified file path. It then processes the module's docstring using a provided parser, enabling introspection or documentation generation."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "loader", "line_number": 79, "body": "def loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()", "is_method": false, "function_description": "Discovers and processes Python packages, including pure Python and extension modules, within a specified root. It parses their source to compile a structural representation, useful for code analysis or documentation."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "gen_api", "line_number": 109, "body": "def gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs", "is_method": false, "function_description": "Generates API documentation for specified Python modules or packages. It loads API information, formats it into Markdown files, and writes them to a designated directory."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/__main__.py", "function": "main", "line_number": 13, "body": "def main() -> None:\n    \"\"\"Main function.\"\"\"\n    from apimd import __version__\n    ver = f\"apimd {__version__}\"\n    parser = ArgumentParser(\n        prog=ver,\n        description=\"Compile Python public API into Generic Markdown.\",\n        epilog=f\"{__copyright__} {__license__} {__author__} {__email__}\"\n    )\n    parser.add_argument('-v', '--version', action='version', version=ver)\n    parser.add_argument(\n        'module',\n        default=None,\n        nargs='+',\n        type=str,\n        help=\"the module name in the current path, use the syntax \"\n             \"`Module-Name=module_name` to specify a name for it\"\n    )\n    for cmd, f, h in [\n        (('-c', '--current'), \".\", \"additional current directory\"),\n        (('-d', '--dir'), \"docs\", \"output to a specific directory\"),\n    ]:\n        parser.add_argument(*cmd, metavar=\"DIR\", default=f, nargs='?',\n                            type=str, help=h)\n    parser.add_argument('--level', metavar=\"LEVEL\", default=1, nargs='?',\n                        type=int, help=\"the starting level of the sections\")\n    for cmd, h in [\n        ('--toc', \"generate table of contents\"),\n        ('--no-link', \"don't use link anchor\"),\n        ('--dry', \"show the result instead write the file\"),\n    ]:\n        parser.add_argument(cmd, action='store_true', help=h)\n    arg = parser.parse_args()\n    root_names = {}\n    for m in arg.module:  # type: str\n        n = m.split('=', maxsplit=1)\n        if len(n) == 1:\n            n.append(n[0])\n        if n[1] == \"\":\n            n[1] = n[0]\n        root_names[n[0]] = n[1]\n    from apimd.loader import gen_api\n    gen_api(root_names, arg.current, prefix=arg.dir, link=not arg.no_link,\n            level=arg.level, toc=arg.toc, dry=arg.dry)", "is_method": false, "function_description": "This function serves as the command-line entry point for the `apimd` tool. It parses arguments to compile Python public APIs into customizable Markdown documentation files."}]