[{"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_m", "line_number": 31, "body": "def _m(*names: str) -> str:\n    \"\"\"Get module names\"\"\"\n    return '.'.join(s for s in names if s)", "is_method": false, "function_description": "Utility function that concatenates given strings to form a dot-separated module path, filtering out any empty components. It aids in constructing valid Python module names dynamically."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_attr", "line_number": 36, "body": "def _attr(obj: object, attr: str) -> object:\n    \"\"\"Nest `getattr` function.\"\"\"\n    n = obj\n    for p in attr.split('.'):\n        n = getattr(n, p, None)\n        if n is None:\n            return None\n    return n", "is_method": false, "function_description": "Utility function that retrieves the value of a potentially nested attribute from an object, returning None if any attribute in the chain is missing."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_defaults", "line_number": 46, "body": "def _defaults(args: Sequence[Optional[expr]]) -> Iterator[str]:\n    \"\"\"Literals of the table.\"\"\"\n    yield from (code(unparse(a)) if a is not None else \" \" for a in args)", "is_method": false, "function_description": "This function generates string representations of given expressions, substituting a space for any None values. It provides a way to serialize optional expressions in a sequence, useful for code generation or formatting tasks."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "parent", "line_number": 51, "body": "def parent(name: str, *, level: int = 1) -> str:\n    \"\"\"Get parent name with level.\"\"\"\n    return name.rsplit('.', maxsplit=level)[0]", "is_method": false, "function_description": "Function that returns the parent segment of a dot-separated string by removing the specified number of trailing levels. Useful for hierarchical naming or namespace parsing."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "is_magic", "line_number": 56, "body": "def is_magic(name: str) -> bool:\n    \"\"\"Check magic name.\"\"\"\n    name = name.rsplit('.', maxsplit=1)[-1]\n    return name[:2] == name[-2:] == '__'", "is_method": false, "function_description": "Utility function that determines if a given name follows the Python magic (dunder) method naming convention, useful for identifying special methods or attributes in classes."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "is_public_family", "line_number": 62, "body": "def is_public_family(name: str) -> bool:\n    \"\"\"Check the name is come from public modules or not.\"\"\"\n    for n in name.split('.'):\n        # Magic name\n        if is_magic(n):\n            continue\n        # Local or private name\n        if n.startswith('_'):\n            return False\n    return True", "is_method": false, "function_description": "Function that determines if a given name belongs to public modules by checking for absence of private or local naming conventions. Useful for filtering or validating identifiers based on visibility in modular code."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "walk_body", "line_number": 74, "body": "def walk_body(body: Sequence[stmt]) -> Iterator[stmt]:\n    \"\"\"Traverse around body and its simple definition scope.\"\"\"\n    for node in body:\n        if isinstance(node, If):\n            yield from walk_body(node.body)\n            yield from walk_body(node.orelse)\n        elif isinstance(node, Try):\n            yield from walk_body(node.body)\n            for h in node.handlers:\n                yield from walk_body(h.body)\n            yield from walk_body(node.orelse)\n            yield from walk_body(node.finalbody)\n        else:\n            yield node", "is_method": false, "function_description": "Function that recursively iterates through the statements in a code block, including nested blocks within conditional and try-except structures, yielding all constituent statements for analysis or processing."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "code", "line_number": 90, "body": "def code(doc: str) -> str:\n    \"\"\"Escape Markdown charters from inline code.\"\"\"\n    doc = doc.replace('|', '&#124;')\n    if '&' in doc:\n        return f\"<code>{doc}</code>\"\n    elif doc:\n        return f\"`{doc}`\"\n    else:\n        return \" \"", "is_method": false, "function_description": "Function that formats a given string as inline code in Markdown, escaping specific characters. It generates an HTML or Markdown code snippet to ensure proper rendering in markdown content."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "esc_underscore", "line_number": 101, "body": "def esc_underscore(doc: str) -> str:\n    \"\"\"Escape underscore in names.\"\"\"\n    if doc.count('_') > 1:\n        return doc.replace('_', r\"\\_\")\n    else:\n        return doc", "is_method": false, "function_description": "Function that escapes underscores in a string if there are multiple underscores, useful for text processing scenarios where underscore characters need to be preserved or escaped (e.g., in markup or code documentation)."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "doctest", "line_number": 109, "body": "def doctest(doc: str) -> str:\n    \"\"\"Wrap doctest as markdown Python code.\"\"\"\n    keep = False\n    docs = []\n    lines = doc.splitlines()\n    for i, line in enumerate(lines):\n        signed = line.startswith(\">>> \")\n        if signed:\n            if not keep:\n                docs.append(\"```python\")\n                keep = True\n        elif keep:\n            docs.append(\"```\")\n            keep = False\n        docs.append(line)\n        if signed and i == len(lines) - 1:\n            docs.append(\"```\")\n            keep = False\n    return '\\n'.join(docs)", "is_method": false, "function_description": "This function formats a string containing Python doctest examples by wrapping them in markdown Python code blocks, enhancing readability and presentation in markdown documents."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_table_cell", "line_number": 130, "body": "def _table_cell(items: Iterable[str]) -> str:\n    \"\"\"Make a row of table cell.\"\"\"\n    return '|' + '|'.join(f\" {t} \" for t in items) + '|'", "is_method": false, "function_description": "Utility function that formats a list of strings into a markdown-style table row, converting each item into a table cell separated by vertical bars."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_table_split", "line_number": 135, "body": "def _table_split(args: Iterable[str]) -> str:\n    \"\"\"The split line of the table.\"\"\"\n    return '|' + '|'.join(\":\" + '-' * (len(a) if len(a) > 3 else 3) + \":\"\n                          for a in args) + '|'", "is_method": false, "function_description": "Generates a Markdown table divider line with column widths based on input strings, useful for formatting tables with aligned columns in Markdown documents."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "table", "line_number": 141, "body": "def table(*titles: str, items: Iterable[Union[str, Iterable[str]]]) -> str:\n    \"\"\"Create multi-column table with the titles.\n\n    Usage:\n    >>> table('a', 'b', [['c', 'd'], ['e', 'f']])\n    | a | b |\n    |:---:|:---:|\n    | c | d |\n    | e | f |\n    \"\"\"\n    return '\\n'.join([_table_cell(titles), _table_split(titles),\n                      '\\n'.join(_table_cell([n] if isinstance(n, str) else n)\n                                for n in items)]) + '\\n\\n'", "is_method": false, "function_description": "Function that generates a formatted multi-column markdown table from given column titles and row items, useful for presenting tabular data as plain text in markdown-compatible environments."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_type_name", "line_number": 156, "body": "def _type_name(obj: object) -> str:\n    \"\"\"Get type name.\"\"\"\n    return type(obj).__qualname__", "is_method": false, "function_description": "Utility function that returns the qualified class name of an object's type, useful for type identification and debugging in various contexts."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "_e_type", "line_number": 161, "body": "def _e_type(*elements: Sequence[Optional[expr]]) -> str:\n    \"\"\"Get element type if type is constants.\"\"\"\n    if not elements:\n        return \"\"\n    ts = []\n    for element in elements:\n        if not element:\n            return \"\"\n        t = \"\"\n        for e in element:\n            if not isinstance(e, Constant):\n                return \"\"\n            nw_t = _type_name(e.value)\n            if t and t != nw_t:\n                t = \"Any\"\n                break\n            t = nw_t\n        ts.append(t)\n    return '[' + \", \".join(ts) + ']'", "is_method": false, "function_description": "Utility function that determines a combined type annotation string for given sequences of constant elements, returning \"Any\" if mixed types are detected or an empty string if conditions aren't met."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "const_type", "line_number": 182, "body": "def const_type(node: expr) -> str:\n    \"\"\"Constant type inference.\"\"\"\n    if isinstance(node, Constant):\n        return _type_name(node.value)\n    elif isinstance(node, (Tuple, List, Set)):\n        return _type_name(node).lower() + _e_type(node.elts)\n    elif isinstance(node, Dict):\n        return 'dict' + _e_type(node.keys, node.values)\n    elif isinstance(node, Call) and isinstance(node.func, (Name, Attribute)):\n        func = unparse(node.func)\n        if func in chain({'bool', 'int', 'float', 'complex', 'str'},\n                         PEP585.keys(), PEP585.values()):\n            return func\n    return ANY", "is_method": false, "function_description": "Function that infers and returns the type of a constant expression node, supporting basic constants, collections, and certain constructor calls. It provides type identification to assist in static analysis or type checking workflows."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "visit_Constant", "line_number": 208, "body": "def visit_Constant(self, node: Constant) -> AST:\n        \"\"\"Check string is a name.\"\"\"\n        if not isinstance(node.value, str):\n            return node\n        try:\n            e = cast(Expr, parse(node.value).body[0])\n        except SyntaxError:\n            return node\n        else:\n            return self.visit(e.value)", "is_method": true, "class_name": "Resolver", "function_description": "Method of the Resolver class that attempts to parse string constants as expressions and recursively visits the resulting AST nodes, enabling resolution of embedded code within string literals."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "visit_Name", "line_number": 219, "body": "def visit_Name(self, node: Name) -> AST:\n        \"\"\"Replace global names with its expression recursively.\"\"\"\n        if node.id == self.self_ty:\n            return Name(\"Self\", Load())\n        name = _m(self.root, node.id)\n        if name in self.alias and name not in self.alias[name]:\n            e = cast(Expr, parse(self.alias[name]).body[0])\n            # Support `TypeVar`\n            if isinstance(e.value, Call) and isinstance(e.value.func, Name):\n                func_name = e.value.func.id\n                idf = self.alias.get(_m(self.root, func_name), func_name)\n                if idf == 'typing.TypeVar':\n                    return node\n            return self.visit(e.value)\n        else:\n            return node", "is_method": true, "class_name": "Resolver", "function_description": "Core method of the Resolver class that recursively substitutes global names with their corresponding expressions, supporting aliases and special handling for typing constructs like TypeVar. It enables dynamic resolution of identifiers within an AST."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "visit_Subscript", "line_number": 236, "body": "def visit_Subscript(self, node: Subscript) -> AST:\n        \"\"\"Implementation of PEP585 and PEP604.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        name = node.value.id\n        idf = self.alias.get(_m(self.root, name), name)\n        if idf == 'typing.Union':\n            if not isinstance(node.slice, Tuple):\n                return node.slice\n            b = node.slice.elts[0]\n            for e in node.slice.elts[1:]:\n                b = BinOp(b, BitOr(), e)\n            return b\n        elif idf == 'typing.Optional':\n            return BinOp(node.slice, BitOr(), Constant(None))\n        elif idf in PEP585:\n            logger.warning(f\"{node.lineno}:{node.col_offset}: \"\n                           f\"find deprecated name {idf}, \"\n                           f\"recommended to use {PEP585[idf]}\")\n            return Subscript(Name(PEP585[idf], Load), node.slice, node.ctx)\n        else:\n            return node", "is_method": true, "class_name": "Resolver", "function_description": "Method of the Resolver class that translates legacy typing annotations into modern syntax per PEP585 and PEP604, enabling updated AST transformations for improved type hint compatibility in Python code."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "visit_Attribute", "line_number": 259, "body": "def visit_Attribute(self, node: Attribute) -> AST:\n        \"\"\"Remove `typing.*` prefix of annotation.\"\"\"\n        if not isinstance(node.value, Name):\n            return node\n        if node.value.id == 'typing':\n            return Name(node.attr, Load())\n        else:\n            return node", "is_method": true, "class_name": "Resolver", "function_description": "Method of the Resolver class that simplifies type annotations by removing the 'typing.' prefix, converting qualified names into simpler unqualified names for straightforward type resolution."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "new", "line_number": 295, "body": "def new(cls: type[_Self], link: bool, level: int, toc: bool) -> _Self:\n        \"\"\"Create a parser by options.\"\"\"\n        return cls(link, level, toc)", "is_method": true, "class_name": "Parser", "function_description": "Factory method of the Parser class that creates a new parser instance configured with specified options for link parsing, hierarchical level, and table of contents inclusion."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "__post_init__", "line_number": 299, "body": "def __post_init__(self):\n        if self.toc:\n            self.link = True", "is_method": true, "class_name": "Parser", "function_description": "Initializer method in Parser that automatically enables linking if the table of contents (toc) feature is activated."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "parse", "line_number": 303, "body": "def parse(self, root: str, script: str) -> None:\n        \"\"\"Main parser of the entire module.\"\"\"\n        self.doc[root] = '#' * self.b_level + \"# Module `{}`\"\n        if self.link:\n            self.doc[root] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[root] += '\\n\\n'\n        self.level[root] = root.count('.')\n        self.imp[root] = set()\n        self.root[root] = root\n        root_node = parse(script, type_comments=True)\n        for node in walk_body(root_node.body):\n            # \"Execute\" assignments\n            if isinstance(node, (Import, ImportFrom)):\n                self.imports(root, node)\n            elif isinstance(node, (Assign, AnnAssign)):\n                self.globals(root, node)\n        doc = get_docstring(root_node)\n        if doc is not None:\n            self.docstring[root] = doctest(doc)\n        for node in walk_body(root_node.body):\n            if isinstance(node, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, node)", "is_method": true, "class_name": "Parser", "function_description": "Core method of the Parser class that processes a Python module's source code, extracts imports, global assignments, docstrings, and API components, and organizes this information for further analysis or documentation generation."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "imports", "line_number": 326, "body": "def imports(self, root: str, node: _I) -> None:\n        \"\"\"Save import names.\"\"\"\n        if isinstance(node, Import):\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = a.name\n        elif node.module is not None:\n            if node.level:\n                m = parent(root, level=node.level - 1)\n            else:\n                m = ''\n            for a in node.names:\n                name = a.name if a.asname is None else a.asname\n                self.alias[_m(root, name)] = _m(m, node.module, a.name)", "is_method": true, "class_name": "Parser", "function_description": "Core method of the Parser class that processes import statements to record and map import aliases to their fully qualified module names for accurate reference resolution during code analysis."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "globals", "line_number": 341, "body": "def globals(self, root: str, node: _G) -> None:\n        \"\"\"Set up globals:\n\n        + Type alias\n        + Constants\n        + `__all__` filter\n        \"\"\"\n        if (\n            isinstance(node, AnnAssign)\n            and isinstance(node.target, Name)\n            and node.value is not None\n        ):\n            left = node.target\n            expression = unparse(node.value)\n            ann = self.resolve(root, node.annotation)\n        elif (\n            isinstance(node, Assign)\n            and len(node.targets) == 1\n            and isinstance(node.targets[0], Name)\n        ):\n            left = node.targets[0]\n            expression = unparse(node.value)\n            if node.type_comment is None:\n                ann = const_type(node.value)\n            else:\n                ann = node.type_comment\n        else:\n            return\n        name = _m(root, left.id)\n        self.alias[name] = expression\n        if left.id.isupper():\n            self.root[name] = root\n            if self.const.get(name, ANY) == ANY:\n                self.const[name] = ann\n        if left.id != '__all__' or not isinstance(node.value, (Tuple, List)):\n            return\n        for e in node.value.elts:\n            if isinstance(e, Constant) and isinstance(e.value, str):\n                self.imp[root].add(_m(root, e.value))", "is_method": true, "class_name": "Parser", "function_description": "Parser method that processes assignment nodes to register global type aliases, constants, and __all__ filters, supporting accurate tracking and resolution of globally defined names within a given root context."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "api", "line_number": 381, "body": "def api(self, root: str, node: _API, *, prefix: str = '') -> None:\n        \"\"\"Create API doc for only functions and classes.\n        Where `name` is the full name.\n        \"\"\"\n        level = '#' * (self.b_level + (2 if not prefix else 3))\n        name = _m(root, prefix, node.name)\n        self.level[name] = self.level[root]\n        self.root[name] = root\n        shirt_name = esc_underscore(_m(prefix, node.name))\n        if isinstance(node, FunctionDef):\n            self.doc[name] = f\"{level} {shirt_name}()\\n\\n\"\n        elif isinstance(node, AsyncFunctionDef):\n            self.doc[name] = f\"{level} async {shirt_name}()\\n\\n\"\n        else:\n            self.doc[name] = f\"{level} class {shirt_name}\\n\\n\"\n        self.doc[name] += \"*Full name:* `{}`\"\n        if self.link:\n            self.doc[name] += \"\\n<a id=\\\"{}\\\"></a>\"\n        self.doc[name] += '\\n\\n'\n        decs = ['@' + self.resolve(root, d) for d in node.decorator_list]\n        if decs:\n            self.doc[name] += table(\"Decorators\", items=map(code, decs))\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\n            self.func_api(root, name, node.args, node.returns,\n                          has_self=bool(prefix) and '@staticmethod' not in decs,\n                          cls_method='@classmethod' in decs)\n        else:\n            self.class_api(root, name, node.bases, node.body)\n        doc = get_docstring(node)\n        if doc is not None:\n            self.docstring[name] = doctest(doc)\n        if not isinstance(node, ClassDef):\n            return\n        for e in walk_body(node.body):\n            if isinstance(e, (FunctionDef, AsyncFunctionDef, ClassDef)):\n                self.api(root, e, prefix=node.name)", "is_method": true, "class_name": "Parser", "function_description": "Generates structured API documentation for functions and classes in a codebase, including decorators and docstrings, recursively documenting nested classes and methods. Useful for automated code documentation generation within a parsing context."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "func_api", "line_number": 418, "body": "def func_api(self, root: str, name: str, node: arguments,\n                 returns: Optional[expr], *,\n                 has_self: bool, cls_method: bool) -> None:\n        \"\"\"Create function API.\"\"\"\n        args = []\n        default: list[Optional[expr]] = []\n        if node.posonlyargs:\n            args.extend(node.posonlyargs)\n            args.append(arg('/', None))\n            default.extend([None] * len(node.posonlyargs))\n        args.extend(node.args)\n        default.extend([None] * (len(node.args) - len(node.defaults)))\n        default.extend(node.defaults)\n        if node.vararg is not None:\n            args.append(arg('*' + node.vararg.arg, node.vararg.annotation))\n        elif node.kwonlyargs:\n            args.append(arg('*', None))\n        default.append(None)\n        args.extend(node.kwonlyargs)\n        default.extend([None] * (len(node.kwonlyargs) - len(node.kw_defaults)))\n        default.extend(node.kw_defaults)\n        if node.kwarg is not None:\n            args.append(arg('**' + node.kwarg.arg, node.kwarg.annotation))\n            default.append(None)\n        args.append(arg('return', returns))\n        default.append(None)\n        ann = map(code, self.func_ann(root, args, has_self=has_self,\n                                      cls_method=cls_method))\n        has_default = all(d is None for d in default)\n        self.doc[name] += table(\n            *(a.arg for a in args),\n            items=[ann] if has_default else [ann, _defaults(default)])", "is_method": true, "class_name": "Parser", "function_description": "Generates a detailed API representation of a function's signature, including arguments, default values, and return type, to facilitate documentation or interface generation within the parsing process."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "class_api", "line_number": 451, "body": "def class_api(self, root: str, name: str, bases: list[expr],\n                  body: list[stmt]) -> None:\n        \"\"\"Create class API.\"\"\"\n        r_bases = [self.resolve(root, d) for d in bases]\n        if r_bases:\n            self.doc[name] += table(\"Bases\", items=map(code, r_bases))\n        is_enum = any(map(lambda s: s.startswith('enum.'), r_bases))\n        mem = {}\n        enums = []\n        for node in walk_body(body):\n            if isinstance(node, AnnAssign) and isinstance(node.target, Name):\n                attr = node.target.id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    mem[attr] = self.resolve(root, node.annotation)\n            elif (\n                isinstance(node, Assign)\n                and len(node.targets) == 1\n                and isinstance(node.targets[0], Name)\n            ):\n                attr = node.targets[0].id\n                if is_enum:\n                    enums.append(attr)\n                elif is_public_family(attr):\n                    if node.type_comment is None:\n                        mem[attr] = const_type(node.value)\n                    else:\n                        mem[attr] = node.type_comment\n            elif isinstance(node, Delete):\n                for d in node.targets:\n                    if not isinstance(d, Name):\n                        continue\n                    attr = d.id\n                    mem.pop(attr, None)\n                    if attr in enums:\n                        enums.remove(attr)\n        if enums:\n            self.doc[name] += table(\"Enums\", items=enums)\n        elif mem:\n            self.doc[name] += table('Members', 'Type', items=(\n                (code(n), code(mem[n])) for n in sorted(mem)))", "is_method": true, "class_name": "Parser", "function_description": "Method of the Parser class that analyzes a class definition to document its base classes, enum members, and public attributes with types, enriching the API documentation with structured tables."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "func_ann", "line_number": 494, "body": "def func_ann(self, root: str, args: Sequence[arg], *,\n                 has_self: bool, cls_method: bool) -> Iterator[str]:\n        \"\"\"Function annotation table.\"\"\"\n        self_ty = \"\"\n        for i, a in enumerate(args):\n            if has_self and i == 0:\n                if a.annotation is not None:\n                    self_ty = self.resolve(root, a.annotation)\n                    if cls_method:\n                        self_ty = (self_ty.removeprefix('type[')\n                                   .removesuffix(']'))\n                yield 'type[Self]' if cls_method else 'Self'\n            elif a.arg == '*':\n                yield \"\"\n            elif a.annotation is not None:\n                yield self.resolve(root, a.annotation, self_ty)\n            else:\n                yield ANY", "is_method": true, "class_name": "Parser", "function_description": "Generates type annotation strings for function arguments, correctly handling self and class method conventions. Useful for parsing and interpreting function signatures with annotated types."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "resolve", "line_number": 513, "body": "def resolve(self, root: str, node: expr, self_ty: str = \"\") -> str:\n        \"\"\"Search and resolve global names in annotation.\"\"\"\n        r = Resolver(root, self.alias, self_ty)\n        return unparse(r.generic_visit(r.visit(node)))", "is_method": true, "class_name": "Parser", "function_description": "Utility function in the Parser class that resolves and converts annotated global names within a syntax node into their string representations. It supports name resolution based on a given root context and optional type information."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "load_docstring", "line_number": 518, "body": "def load_docstring(self, root: str, m: ModuleType) -> None:\n        \"\"\"Load docstring from the module.\"\"\"\n        for name in self.doc:\n            if not name.startswith(root):\n                continue\n            attr = name.removeprefix(root + '.')\n            doc = getdoc(_attr(m, attr))\n            if doc is not None:\n                self.docstring[name] = doctest(doc)", "is_method": true, "class_name": "Parser", "function_description": "Loads and processes docstrings from a module's attributes matching a specified prefix, storing their doctest-parsed content for further use. This is useful for extracting and testing documentation dynamically within the Parser class."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "__is_immediate_family", "line_number": 528, "body": "def __is_immediate_family(self, n1: str, n2: str) -> bool:\n        \"\"\"Check the name is immediate family.\"\"\"\n        return n2.startswith(n1.removesuffix(n2.removeprefix(self.root[n2])))", "is_method": true, "class_name": "Parser", "function_description": "Private method of the Parser class that determines if one name represents an immediate family member of another based on a shared root prefix pattern, supporting family relationship parsing logic."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "__find_alias", "line_number": 532, "body": "def __find_alias(self):\n        \"\"\"Alias substitution.\"\"\"\n        for n, a in self.alias.items():\n            if a not in self.doc or not self.__is_immediate_family(n, a):\n                continue\n            for ch in list(self.doc):\n                if not ch.startswith(a):\n                    continue\n                nw = n + ch.removeprefix(a)\n                self.doc[nw] = self.doc.pop(ch)\n                self.docstring[nw] = self.docstring.pop(ch, \"\")\n                name = ch.removeprefix(self.root.pop(ch))\n                self.root[nw] = nw.removesuffix(name)\n                self.level.pop(ch)\n                self.level[nw] = self.root[nw].count('.')\n                if ch in self.const:\n                    self.const[nw] = self.const.pop(ch)", "is_method": true, "class_name": "Parser", "function_description": "Refines document keys by substituting aliases with their canonical names, maintaining consistent references and hierarchical metadata within the Parser's document structures."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "is_public", "line_number": 550, "body": "def is_public(self, s: str) -> bool:\n        \"\"\"Check the name is public style or listed in `__all__`.\"\"\"\n        if s in self.imp:\n            for ch in chain(self.doc.keys(), self.const.keys()):\n                if ch.startswith(s + '.') and is_public_family(ch):\n                    break\n            else:\n                return False\n        all_l = self.imp[self.root[s]]\n        if all_l:\n            return s == self.root[s] or bool({s, parent(s)} & all_l)\n        else:\n            return is_public_family(s)", "is_method": true, "class_name": "Parser", "function_description": "Method of the Parser class that determines if a given name is considered publicly accessible based on style conventions and inclusion in the module's export list (`__all__`). It helps identify names intended for external use within parsing contexts."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "__get_const", "line_number": 564, "body": "def __get_const(self, name: str) -> str:\n        \"\"\"Get constants table.\"\"\"\n        const = []\n        for c in self.const:\n            if self.root[c] == name and self.is_public(c):\n                ch = c.removeprefix(name + '.')\n                const.append((code(ch), code(self.const[c])))\n        if const:\n            return table('Constants', 'Type', items=const)\n        else:\n            return \"\"", "is_method": true, "class_name": "Parser", "function_description": "Method of the Parser class that retrieves and formats constant values matching a specified name from its constants table, returning a structured representation if public constants exist, or an empty string otherwise."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "__names_cmp", "line_number": 576, "body": "def __names_cmp(self, s: str) -> tuple[int, str, bool]:\n        \"\"\"Name comparison function.\"\"\"\n        return self.level[s], s.lower(), not s.islower()", "is_method": true, "class_name": "Parser", "function_description": "Private comparison helper for sorting names based on their assigned level, case-insensitive alphabetical order, and capitalization status. Useful for ordering or prioritizing names within the Parser class."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/parser.py", "function": "compile", "line_number": 580, "body": "def compile(self) -> str:\n        \"\"\"Compile documentation.\"\"\"\n        self.__find_alias()\n        toc = ['**Table of contents:**']\n        docs = []\n        for name in sorted(self.doc, key=self.__names_cmp):\n            if not self.is_public(name):\n                continue\n            link = name.lower().replace('.', '-')\n            doc = self.doc[name].format(name, link)\n            if name in self.imp:\n                doc += self.__get_const(name)\n            if name in self.docstring:\n                doc += self.docstring[name]\n            elif is_magic(name):\n                continue\n            else:\n                logger.warning(f\"Missing documentation for {name}\")\n            level = name.removeprefix(self.root[name]).count('.')\n            toc.append(\" \" * 4 * level + f\"+ [{code(name)}](#{link})\")\n            docs.append(doc.rstrip())\n        if self.toc:\n            return '\\n'.join(toc) + '\\n\\n' + \"\\n\\n\".join(docs) + '\\n'\n        return \"\\n\\n\".join(docs) + '\\n'", "is_method": true, "class_name": "Parser", "function_description": "Generates formatted documentation with a table of contents for all public entities, combining summaries, constants, and docstrings into a structured markdown text. It serves as a comprehensive documentation compilation tool within the Parser class."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "_read", "line_number": 24, "body": "def _read(path: str) -> str:\n    \"\"\"Read the script from file.\"\"\"\n    with open(path, 'r') as f:\n        return f.read()", "is_method": false, "function_description": "Utility function that reads and returns the entire content of a file from the given file path."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "_write", "line_number": 30, "body": "def _write(path: str, doc: str) -> None:\n    \"\"\"Write text to the file.\"\"\"\n    with open(path, 'w+', encoding='utf-8') as f:\n        f.write(doc)", "is_method": false, "function_description": "Utility function that writes the given text content to a specified file path, creating or overwriting the file as needed."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "_site_path", "line_number": 36, "body": "def _site_path(name: str) -> str:\n    \"\"\"Get the path in site-packages if exist.\"\"\"\n    s = find_spec(name)\n    if s is None or s.submodule_search_locations is None:\n        return \"\"\n    return dirname(s.submodule_search_locations[0])", "is_method": false, "function_description": "Utility function that returns the filesystem path of a Python package's site-packages directory, if the package exists and is installed."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "walk_packages", "line_number": 44, "body": "def walk_packages(name: str, path: str) -> Iterator[tuple[str, str]]:\n    \"\"\"Walk packages without import them.\"\"\"\n    path = abspath(path) + sep\n    valid = (path + name, path + name + PEP561_SUFFIX)\n    for root, _, fs in walk(path):\n        for f in fs:\n            if not f.endswith(('.py', '.pyi')):\n                continue\n            f_path = parent(join(root, f))\n            if not f_path.startswith(valid):\n                continue\n            name = (f_path\n                    .removeprefix(path)\n                    .replace(PEP561_SUFFIX, \"\")\n                    .replace(sep, '.')\n                    .removesuffix('.__init__'))\n            yield name, f_path", "is_method": false, "function_description": "Utility function that traverses a directory to identify Python package modules by path and name without importing them, useful for package inspection or analysis tools."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "_load_module", "line_number": 63, "body": "def _load_module(name: str, path: str, p: Parser) -> bool:\n    \"\"\"Load module directly.\"\"\"\n    # Load root first to avoid import error\n    try:\n        __import__(parent(name))\n    except ImportError:\n        return False\n    s = spec_from_file_location(name, path)\n    if s is not None and isinstance(s.loader, Loader):\n        m = module_from_spec(s)\n        s.loader.exec_module(m)\n        p.load_docstring(name, m)\n        return True\n    return False", "is_method": false, "function_description": "Internal helper function that attempts to load a Python module from a file path and process its docstring using a parser, returning success status."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "loader", "line_number": 79, "body": "def loader(root: str, pwd: str, link: bool, level: int, toc: bool) -> str:\n    \"\"\"Package searching algorithm.\"\"\"\n    p = Parser.new(link, level, toc)\n    for name, path in walk_packages(root, pwd):\n        # Load its source or stub\n        pure_py = False\n        for ext in [\".py\", \".pyi\"]:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            p.parse(name, _read(path_ext))\n            if ext == \".py\":\n                pure_py = True\n        if pure_py:\n            continue\n        logger.debug(f\"loading extension module for fully documented:\")\n        # Try to load module here\n        for ext in EXTENSION_SUFFIXES:\n            path_ext = path + ext\n            if not isfile(path_ext):\n                continue\n            logger.debug(f\"{name} <= {path_ext}\")\n            if _load_module(name, path_ext, p):\n                break\n        else:\n            logger.warning(f\"no module for {name} in this platform\")\n    return p.compile()", "is_method": false, "function_description": "Function that recursively searches and parses Python packages starting from a root directory, handling pure Python and extension modules, then compiles collected data into a final package representation. It supports module documentation extraction and multi-level package traversal."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/loader.py", "function": "gen_api", "line_number": 109, "body": "def gen_api(\n    root_names: dict[str, str],\n    pwd: Optional[str] = None,\n    *,\n    prefix: str = 'docs',\n    link: bool = True,\n    level: int = 1,\n    toc: bool = False,\n    dry: bool = False\n) -> Sequence[str]:\n    \"\"\"Generate API. All rules are listed in the readme.\n\n    The path `pwd` is the current path that provided to `pkgutil`,\n    which allows the \"site-packages\" directory to be used.\n    \"\"\"\n    if pwd is not None:\n        sys_path.append(pwd)\n    if not isdir(prefix):\n        logger.info(f\"Create directory: {prefix}\")\n        mkdir(prefix)\n    docs = []\n    for title, name in root_names.items():\n        logger.info(f\"Load root: {name} ({title})\")\n        doc = loader(name, _site_path(name), link, level, toc)\n        if not doc.strip():\n            logger.warning(f\"'{name}' can not be found\")\n            continue\n        doc = '#' * level + f\" {title} API\\n\\n\" + doc\n        path = join(prefix, f\"{name.replace('_', '-')}-api.md\")\n        logger.info(f\"Write file: {path}\")\n        if dry:\n            logger.info('=' * 12)\n            logger.info(doc)\n        else:\n            _write(path, doc)\n        docs.append(doc)\n    return docs", "is_method": false, "function_description": "Utility function that generates API documentation files for given package names, supporting custom paths, directory creation, and optional table of contents and linking features. It returns the generated documentation as a sequence of markdown-formatted strings."}, {"file": "./dataset/RepoExec/test-apps/apimd/apimd/__main__.py", "function": "main", "line_number": 13, "body": "def main() -> None:\n    \"\"\"Main function.\"\"\"\n    from apimd import __version__\n    ver = f\"apimd {__version__}\"\n    parser = ArgumentParser(\n        prog=ver,\n        description=\"Compile Python public API into Generic Markdown.\",\n        epilog=f\"{__copyright__} {__license__} {__author__} {__email__}\"\n    )\n    parser.add_argument('-v', '--version', action='version', version=ver)\n    parser.add_argument(\n        'module',\n        default=None,\n        nargs='+',\n        type=str,\n        help=\"the module name in the current path, use the syntax \"\n             \"`Module-Name=module_name` to specify a name for it\"\n    )\n    for cmd, f, h in [\n        (('-c', '--current'), \".\", \"additional current directory\"),\n        (('-d', '--dir'), \"docs\", \"output to a specific directory\"),\n    ]:\n        parser.add_argument(*cmd, metavar=\"DIR\", default=f, nargs='?',\n                            type=str, help=h)\n    parser.add_argument('--level', metavar=\"LEVEL\", default=1, nargs='?',\n                        type=int, help=\"the starting level of the sections\")\n    for cmd, h in [\n        ('--toc', \"generate table of contents\"),\n        ('--no-link', \"don't use link anchor\"),\n        ('--dry', \"show the result instead write the file\"),\n    ]:\n        parser.add_argument(cmd, action='store_true', help=h)\n    arg = parser.parse_args()\n    root_names = {}\n    for m in arg.module:  # type: str\n        n = m.split('=', maxsplit=1)\n        if len(n) == 1:\n            n.append(n[0])\n        if n[1] == \"\":\n            n[1] = n[0]\n        root_names[n[0]] = n[1]\n    from apimd.loader import gen_api\n    gen_api(root_names, arg.current, prefix=arg.dir, link=not arg.no_link,\n            level=arg.level, toc=arg.toc, dry=arg.dry)", "is_method": false, "function_description": "Main entry point that parses command-line arguments to configure and invoke API documentation generation from specified Python modules, allowing customization of output directory, formatting, and display options."}]