[{"file": "./dataset/RepoExec/test-apps/python-semantic-release/setup.py", "function": "_read_long_description", "line_number": 6, "body": "def _read_long_description():\n    try:\n        with open(\"readme.rst\") as fd:\n            return fd.read()\n    except Exception:\n        return None", "is_method": false, "function_description": "Utility function that attempts to read and return the content of a \"readme.rst\" file, providing descriptive text if available. It supports documentation loading while gracefully handling read errors."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/docs/conf.py", "function": "run_apidoc", "line_number": 41, "body": "def run_apidoc(_):\n    from sphinx import apidoc\n\n    docs_path = os.path.dirname(__file__)\n    apidoc_path = os.path.join(docs_path, \"api\")\n    module_path = os.path.join(docs_path, \"..\", \"semantic_release\")\n\n    apidoc.main(\n        [\n            \"--force\",\n            \"--module-first\",\n            \"--separate\",\n            \"-d\",\n            \"3\",\n            \"-o\",\n            apidoc_path,\n            module_path,\n        ]\n    )", "is_method": false, "function_description": "Generates Sphinx API documentation files for the semantic_release module, organizing output in a designated directory. Useful for automating documentation during development."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/docs/conf.py", "function": "setup", "line_number": 62, "body": "def setup(app):\n    app.connect(\"builder-inited\", run_apidoc)", "is_method": false, "function_description": "Connects the run_apidoc function to the builder-inited event in the app, enabling automatic API documentation generation during the build initialization phase."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "common_options", "line_number": 80, "body": "def common_options(func):\n    \"\"\"\n    Decorator that adds all the options in COMMON_OPTIONS\n    \"\"\"\n    for option in reversed(COMMON_OPTIONS):\n        func = option(func)\n    return func", "is_method": false, "function_description": "Decorator function that applies a predefined set of common option decorators to another function, enabling consistent option handling across multiple command or handler functions."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "print_version", "line_number": 89, "body": "def print_version(*, current=False, force_level=None, **kwargs):\n    \"\"\"\n    Print the current or new version to standard output.\n    \"\"\"\n    try:\n        current_version = get_current_version()\n    except GitError as e:\n        print(str(e), file=sys.stderr)\n        return False\n    if current:\n        print(current_version, end=\"\")\n        return True\n\n    # Find what the new version number should be\n    level_bump = evaluate_version_bump(current_version, force_level)\n    new_version = get_new_version(current_version, level_bump)\n    if should_bump_version(current_version=current_version, new_version=new_version):\n        print(new_version, end=\"\")\n        return True\n\n    print(\"No release will be made.\", file=sys.stderr)\n    return False", "is_method": false, "function_description": "Function that prints the current or next version number based on version bump rules, helping automate version management and release decision-making in a software project."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "version", "line_number": 113, "body": "def version(*, retry=False, noop=False, force_level=None, **kwargs):\n    \"\"\"\n    Detect the new version according to git log and semver.\n\n    Write the new version number and commit it, unless the noop option is True.\n    \"\"\"\n    if retry:\n        logger.info(\"Retrying publication of the same version\")\n    else:\n        logger.info(\"Creating new version\")\n\n    # Get the current version number\n    try:\n        current_version = get_current_version()\n        logger.info(f\"Current version: {current_version}\")\n    except GitError as e:\n        logger.error(str(e))\n        return False\n    # Find what the new version number should be\n    level_bump = evaluate_version_bump(current_version, force_level)\n    new_version = get_new_version(current_version, level_bump)\n\n    if not should_bump_version(\n        current_version=current_version, new_version=new_version, retry=retry, noop=noop\n    ):\n        return False\n\n    if retry:\n        # No need to make changes to the repo, we're just retrying.\n        return True\n\n    # Bump the version\n    bump_version(new_version, level_bump)\n    return True", "is_method": false, "function_description": "Function that determines and optionally updates the project version based on git logs and semantic versioning rules, supporting retries, forced version levels, and no-operation checks. It facilitates automated version management and commit handling in version control workflows."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "should_bump_version", "line_number": 149, "body": "def should_bump_version(*, current_version, new_version, retry=False, noop=False):\n    \"\"\"Test whether the version should be bumped.\"\"\"\n    if new_version == current_version and not retry:\n        logger.info(\"No release will be made.\")\n        return False\n\n    if noop:\n        logger.warning(\n            \"No operation mode. Should have bumped \"\n            f\"from {current_version} to {new_version}\"\n        )\n        return False\n\n    if config.get(\"check_build_status\"):\n        logger.info(\"Checking build status...\")\n        owner, name = get_repository_owner_and_name()\n        if not check_build_status(owner, name, get_current_head_hash()):\n            logger.warning(\"The build failed, cancelling the release\")\n            return False\n        logger.info(\"The build was a success, continuing the release\")\n\n    return True", "is_method": false, "function_description": "Determines if a software version should be incremented based on version comparison, build status, and operational flags. It helps automate release decisions by validating conditions prior to version bumping."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "bump_version", "line_number": 173, "body": "def bump_version(new_version, level_bump):\n    \"\"\"\n    Set the version to the given `new_version`.\n\n    Edit in the source code, commit and create a git tag.\n    \"\"\"\n    set_new_version(new_version)\n    if config.get(\n        \"commit_version_number\",\n        config.get(\"version_source\") == \"commit\",\n    ):\n        commit_new_version(new_version)\n    tag_new_version(new_version)\n\n    logger.info(f\"Bumping with a {level_bump} version to {new_version}\")", "is_method": false, "function_description": "Function that updates the software version to a specified new version, commits the change to source control if configured, and creates a corresponding git tag. It supports automated version management and release tagging."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "changelog", "line_number": 190, "body": "def changelog(*, unreleased=False, noop=False, post=False, **kwargs):\n    \"\"\"\n    Generate the changelog since the last release.\n\n    :raises ImproperConfigurationError: if there is no current version\n    \"\"\"\n    current_version = get_current_version()\n    if current_version is None:\n        raise ImproperConfigurationError(\n            \"Unable to get the current version. \"\n            \"Make sure semantic_release.version_variable \"\n            \"is setup correctly\"\n        )\n\n    previous_version = get_previous_version(current_version)\n\n    # Generate the changelog\n    if unreleased:\n        log = generate_changelog(current_version, None)\n    else:\n        log = generate_changelog(previous_version, current_version)\n\n    owner, name = get_repository_owner_and_name()\n    # print is used to keep the changelog on stdout, separate from log messages\n    print(markdown_changelog(owner, name, current_version, log, header=False))\n\n    # Post changelog to HVCS if enabled\n    if not noop and post:\n        if check_token():\n            logger.info(\"Posting changelog to HVCS\")\n            post_changelog(\n                owner,\n                name,\n                current_version,\n                markdown_changelog(owner, name, current_version, log, header=False),\n            )\n        else:\n            logger.error(\"Missing token: cannot post changelog to HVCS\")", "is_method": false, "function_description": "Generates and optionally posts a changelog since the last release, supporting both unreleased changes and posting to hosted version control services. Useful for automating changelog creation and distribution in release workflows."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "publish", "line_number": 230, "body": "def publish(**kwargs):\n    \"\"\"Run the version task, then push to git and upload to PyPI / GitHub Releases.\"\"\"\n    current_version = get_current_version()\n\n    retry = kwargs.get(\"retry\")\n    if retry:\n        logger.info(\"Retry is on\")\n        # The \"new\" version will actually be the current version, and the\n        # \"current\" version will be the previous version.\n        level_bump = None\n        new_version = current_version\n        current_version = get_previous_version(current_version)\n    else:\n        # Calculate the new version\n        level_bump = evaluate_version_bump(current_version, kwargs.get(\"force_level\"))\n        new_version = get_new_version(current_version, level_bump)\n\n    owner, name = get_repository_owner_and_name()\n\n    branch = config.get(\"branch\")\n    logger.debug(f\"Running publish on branch {branch}\")\n    ci_checks.check(branch)\n    checkout(branch)\n\n    if should_bump_version(\n        current_version=current_version,\n        new_version=new_version,\n        retry=retry,\n        noop=kwargs.get(\"noop\"),\n    ):\n        log = generate_changelog(current_version)\n        changelog_md = markdown_changelog(\n            owner,\n            name,\n            new_version,\n            log,\n            header=False,\n            previous_version=current_version,\n        )\n\n        if not retry:\n            update_changelog_file(new_version, changelog_md)\n            bump_version(new_version, level_bump)\n        # A new version was released\n        logger.info(\"Pushing new version\")\n        push_new_version(\n            auth_token=get_token(),\n            owner=owner,\n            name=name,\n            branch=branch,\n            domain=get_domain(),\n        )\n\n        # Get config options for uploads\n        dist_path = config.get(\"dist_path\")\n        upload_pypi = config.get(\"upload_to_pypi\")\n        upload_to_pypi_glob_patterns = config.get(\"upload_to_pypi_glob_patterns\")\n        upload_release = config.get(\"upload_to_release\")\n\n        if upload_to_pypi_glob_patterns:\n            upload_to_pypi_glob_patterns = upload_to_pypi_glob_patterns.split(\",\")\n\n        if should_build():\n            # We need to run the command to build wheels for releasing\n            logger.info(\"Building distributions\")\n            if should_remove_dist():\n                # Remove old distributions before building\n                remove_dists(dist_path)\n            build_dists()\n\n        if upload_pypi:\n            logger.info(\"Uploading to PyPI\")\n            upload_to_pypi(\n                path=dist_path,\n                # If we are retrying, we don't want errors for files that are already on PyPI.\n                skip_existing=retry,\n                glob_patterns=upload_to_pypi_glob_patterns,\n            )\n\n        if check_token():\n            # Update changelog on HVCS\n            logger.info(\"Posting changelog to HVCS\")\n            try:\n                post_changelog(owner, name, new_version, changelog_md)\n            except GitError:\n                logger.error(\"Posting changelog failed\")\n        else:\n            logger.warning(\"Missing token: cannot post changelog to HVCS\")\n\n        # Upload to GitHub Releases\n        if upload_release and check_token():\n            logger.info(\"Uploading to HVCS release\")\n            upload_to_release(owner, name, new_version, dist_path)\n        # Remove distribution files as they are no longer needed\n        if should_remove_dist():\n            remove_dists(dist_path)\n\n        logger.info(\"New release published\")", "is_method": false, "function_description": "Function that automates version management, runs CI checks, builds distributions, and publishes a new software release to Git, PyPI, and GitHub Releases. It also updates changelogs and handles retries for release publishing."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "filter_output_for_secrets", "line_number": 332, "body": "def filter_output_for_secrets(message):\n    \"\"\"Remove secrets from cli output.\"\"\"\n    output = message\n    for secret_name in SECRET_NAMES:\n        secret = os.environ.get(secret_name)\n        if secret != \"\" and secret is not None:\n            output = output.replace(secret, f\"${secret_name}\")\n\n    return output", "is_method": false, "function_description": "Function removes sensitive information stored in environment variables from a given message by replacing them with placeholder names. It helps sanitize CLI output to prevent secret leakage."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "entry", "line_number": 343, "body": "def entry():\n    # Move flags to after the command\n    ARGS = sorted(sys.argv[1:], key=lambda x: 1 if x.startswith(\"--\") else -1)\n\n    if ARGS and not ARGS[0].startswith(\"print-\"):\n        # print-* command output should not be polluted with logging.\n        click_log.basic_config()\n\n    main(args=ARGS)", "is_method": false, "function_description": "Utility function that preprocesses command-line arguments by sorting flags and initializes logging before calling the main application logic, ensuring clean output for print commands."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "main", "line_number": 363, "body": "def main(**kwargs):\n    logger.debug(f\"Main args: {kwargs}\")\n    message = \"\"\n    for secret_name in SECRET_NAMES:\n        message += f'{secret_name}=\"{os.environ.get(secret_name)}\",'\n    logger.debug(f\"Environment: {filter_output_for_secrets(message)}\")\n\n    obj = {}\n    for key in [\n        \"check_build_status\",\n        \"commit_subject\",\n        \"commit_message\",\n        \"commit_parser\",\n        \"patch_without_tag\",\n        \"major_on_zero\",\n        \"upload_to_pypi\",\n        \"version_source\",\n    ]:\n        obj[key] = config.get(key)\n    logger.debug(f\"Main config: {obj}\")", "is_method": false, "function_description": "Utility function for initializing and logging environment secrets and configuration settings, supporting debugging and visibility into runtime parameters."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "cmd_publish", "line_number": 387, "body": "def cmd_publish(**kwargs):\n    try:\n        return publish(**kwargs)\n    except Exception as error:\n        logger.error(filter_output_for_secrets(str(error)))\n        exit(1)", "is_method": false, "function_description": "Function wrapping a publish call that executes a publishing process with provided arguments, logs any exceptions while masking sensitive data, and terminates the program on failure."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "cmd_changelog", "line_number": 401, "body": "def cmd_changelog(**kwargs):\n    try:\n        return changelog(**kwargs)\n    except Exception as error:\n        logger.error(filter_output_for_secrets(str(error)))\n        exit(1)", "is_method": false, "function_description": "This function attempts to execute a changelog retrieval command with given arguments, logging any errors securely and terminating the program on failure. It facilitates safe execution of changelog operations with error handling."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "cmd_version", "line_number": 411, "body": "def cmd_version(**kwargs):\n    try:\n        return version(**kwargs)\n    except Exception as error:\n        logger.error(filter_output_for_secrets(str(error)))\n        exit(1)", "is_method": false, "function_description": "Utility function that calls the version retrieval process with error handling, logging issues securely and terminating the program on failure. It provides a safe interface for accessing version information."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/cli.py", "function": "cmd_print_version", "line_number": 426, "body": "def cmd_print_version(**kwargs):\n    try:\n        return print_version(**kwargs)\n    except Exception as error:\n        print(filter_output_for_secrets(str(error)), file=sys.stderr)\n        exit(1)", "is_method": false, "function_description": "Utility function that attempts to print version information using print_version and handles errors by filtering sensitive details and terminating on failure."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/dist.py", "function": "should_build", "line_number": 12, "body": "def should_build():\n    upload_pypi = config.get(\"upload_to_pypi\")\n    upload_release = config.get(\"upload_to_release\")\n    build_command = config.get(\"build_command\")\n    build_command = build_command if build_command != \"false\" else False\n    return bool(build_command and (upload_pypi or upload_release))", "is_method": false, "function_description": "Determines if a build process should proceed based on configuration settings related to build commands and upload targets. It helps decide whether to execute a build before releasing or uploading packages."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/dist.py", "function": "should_remove_dist", "line_number": 20, "body": "def should_remove_dist():\n    remove_dist = config.get(\"remove_dist\")\n    return bool(remove_dist and should_build())", "is_method": false, "function_description": "Determines whether the distribution files should be removed based on configuration settings and build conditions. It helps automate cleanup decisions during the build process."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/dist.py", "function": "remove_dists", "line_number": 31, "body": "def remove_dists(path: str):\n    command = f\"rm -rf {path}\"\n    logger.debug(f\"Running {command}\")\n    run(command)", "is_method": false, "function_description": "Function that deletes the directory or file at the specified path, providing a simple way to remove unwanted data from the filesystem."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/pypi.py", "function": "upload_to_pypi", "line_number": 18, "body": "def upload_to_pypi(\n    path: str = \"dist\", skip_existing: bool = False, glob_patterns: List[str] = None\n):\n    \"\"\"Upload wheels to PyPI with Twine.\n\n    Wheels must already be created and stored at the given path.\n\n    Credentials are taken from either the environment variable\n    ``PYPI_TOKEN``, or from ``PYPI_USERNAME`` and ``PYPI_PASSWORD``.\n\n    :param path: Path to dist folder containing the files to upload.\n    :param skip_existing: Continue uploading files if one already exists.\n        (Only valid when uploading to PyPI. Other implementations may not support this.)\n    :param glob_patterns: List of glob patterns to include in the upload ([\"*\"] by default).\n    \"\"\"\n    if not glob_patterns:\n        glob_patterns = [\"*\"]\n\n    # Attempt to get an API token from environment\n    token = os.environ.get(\"PYPI_TOKEN\")\n    username = None\n    password = None\n    if not token:\n        # Look for a username and password instead\n        username = os.environ.get(\"PYPI_USERNAME\")\n        password = os.environ.get(\"PYPI_PASSWORD\")\n        home_dir = os.environ.get(\"HOME\", \"\")\n        if not (username or password) and (\n            not home_dir or not os.path.isfile(os.path.join(home_dir, \".pypirc\"))\n        ):\n            raise ImproperConfigurationError(\n                \"Missing credentials for uploading to PyPI\"\n            )\n    elif not token.startswith(\"pypi-\"):\n        raise ImproperConfigurationError('PyPI token should begin with \"pypi-\"')\n    else:\n        username = \"__token__\"\n        password = token\n\n    repository = config.get(\"repository\", None)\n    repository_arg = f\" -r '{repository}'\" if repository else \"\"\n\n    username_password = (\n        f\"-u '{username}' -p '{password}'\" if username and password else \"\"\n    )\n\n    dist = \" \".join(\n        ['\"{}/{}\"'.format(path, glob_pattern.strip()) for glob_pattern in glob_patterns]\n    )\n\n    skip_existing_param = \" --skip-existing\" if skip_existing else \"\"\n\n    run(f\"twine upload {username_password}{repository_arg}{skip_existing_param} {dist}\")", "is_method": false, "function_description": "Function that uploads Python package distributions from a specified directory to PyPI using Twine, supporting credential retrieval from environment variables and optional skipping of already existing files. It facilitates automated publishing of packages to Python Package Index repositories."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/ci_checks.py", "function": "checker", "line_number": 9, "body": "def checker(func: Callable) -> Callable:\n    \"\"\"\n    A decorator that will convert AssertionErrors into\n    CiVerificationError.\n\n    :param func: A function that will raise AssertionError\n    :return: The given function wrapped to raise a CiVerificationError on AssertionError\n    \"\"\"\n\n    def func_wrapper(*args, **kwargs):\n        try:\n            func(*args, **kwargs)\n            return True\n        except AssertionError:\n            raise CiVerificationError(\n                \"The verification check for the environment did not pass.\"\n            )\n\n    return func_wrapper", "is_method": false, "function_description": "Utility decorator that wraps a function to convert AssertionErrors into CiVerificationError exceptions, standardizing error handling for verification checks in continuous integration environments."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/ci_checks.py", "function": "travis", "line_number": 31, "body": "def travis(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the travis build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"TRAVIS_BRANCH\") == branch\n    assert os.environ.get(\"TRAVIS_PULL_REQUEST\") == \"false\"", "is_method": false, "function_description": "Function that verifies if the current Travis CI environment matches the specified branch and is not a pull request, ensuring conditions are met for creating releases during automated builds."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/ci_checks.py", "function": "semaphore", "line_number": 43, "body": "def semaphore(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the semaphore build is successful,\n    on the correct branch and not a pull-request.\n\n    :param branch:  The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BRANCH_NAME\") == branch\n    assert os.environ.get(\"PULL_REQUEST_NUMBER\") is None\n    assert os.environ.get(\"SEMAPHORE_THREAD_RESULT\") != \"failed\"", "is_method": false, "function_description": "Function that validates the build environment to ensure it runs on a specific branch, is not triggered by a pull request, and that the semaphore thread's build has not failed."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/ci_checks.py", "function": "frigg", "line_number": 56, "body": "def frigg(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the frigg build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"FRIGG_BUILD_BRANCH\") == branch\n    assert not os.environ.get(\"FRIGG_PULL_REQUEST\")", "is_method": false, "function_description": "Function that verifies the current Frigg build environment matches the specified branch and is not triggered by a pull request, ensuring release builds run under correct conditions."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/ci_checks.py", "function": "circle", "line_number": 68, "body": "def circle(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the circle build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CIRCLE_BRANCH\") == branch\n    assert not os.environ.get(\"CI_PULL_REQUEST\")", "is_method": false, "function_description": "Function that verifies if the current CircleCI build is for a specified branch and not a pull request, ensuring release builds run only in appropriate environments."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/ci_checks.py", "function": "gitlab", "line_number": 80, "body": "def gitlab(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the gitlab build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CI_COMMIT_REF_NAME\") == branch", "is_method": false, "function_description": "Function that verifies the current GitLab CI build runs on the specified branch, ensuring that release creation occurs only from the intended branch."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/ci_checks.py", "function": "bitbucket", "line_number": 92, "body": "def bitbucket(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the bitbucket build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BITBUCKET_BRANCH\") == branch\n    assert not os.environ.get(\"BITBUCKET_PR_ID\")", "is_method": false, "function_description": "Function that verifies if the current Bitbucket build is on a specific branch and not triggered by a pull request, ensuring conditions are met before creating releases."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/ci_checks.py", "function": "jenkins", "line_number": 104, "body": "def jenkins(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the jenkins build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n\n    branch_name = os.environ.get(\"BRANCH_NAME\") or os.environ.get(\"GIT_BRANCH\")\n    assert os.environ.get(\"JENKINS_URL\") is not None\n    assert branch_name == branch\n    assert not os.environ.get(\"CHANGE_ID\")", "is_method": false, "function_description": "Function that verifies if the current Jenkins build environment matches the specified branch and is eligible for creating releases by checking environment variables and build context."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/ci_checks.py", "function": "check", "line_number": 118, "body": "def check(branch: str = \"master\"):\n    \"\"\"\n    Detects the current CI environment, if any, and performs necessary\n    environment checks.\n\n    :param branch: The branch that should be the current branch.\n    \"\"\"\n    if os.environ.get(\"TRAVIS\") == \"true\":\n        travis(branch)\n    elif os.environ.get(\"SEMAPHORE\") == \"true\":\n        semaphore(branch)\n    elif os.environ.get(\"FRIGG\") == \"true\":\n        frigg(branch)\n    elif os.environ.get(\"CIRCLECI\") == \"true\":\n        circle(branch)\n    elif os.environ.get(\"GITLAB_CI\") == \"true\":\n        gitlab(branch)\n    elif os.environ.get(\"JENKINS_URL\") is not None:\n        jenkins(branch)\n    elif \"BITBUCKET_BUILD_NUMBER\" in os.environ:\n        bitbucket(branch)", "is_method": false, "function_description": "Function that detects the active Continuous Integration environment and runs corresponding validation checks for the specified branch. It ensures CI-specific requirements are met during automated build processes."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/__init__.py", "function": "setup_hook", "line_number": 10, "body": "def setup_hook(argv: list):\n    \"\"\"\n    A hook to be used in setup.py to enable `python setup.py publish`.\n\n    :param argv: sys.argv\n    \"\"\"\n    if len(argv) > 1 and argv[1] in [\"version\", \"publish\", \"changelog\"]:\n        from .cli import main\n\n        main()", "is_method": false, "function_description": "Utility function that enables custom commands like \"version,\" \"publish,\" or \"changelog\" in a setup.py script, triggering corresponding CLI actions during Python package setup."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/settings.py", "function": "_config", "line_number": 20, "body": "def _config():\n    cwd = getcwd()\n    ini_paths = [\n        os.path.join(os.path.dirname(__file__), \"defaults.cfg\"),\n        os.path.join(cwd, \"setup.cfg\"),\n    ]\n    ini_config = _config_from_ini(ini_paths)\n\n    toml_path = os.path.join(cwd, \"pyproject.toml\")\n    toml_config = _config_from_pyproject(toml_path)\n\n    # Cast to a UserDict so that we can mock the get() method.\n    return UserDict({**ini_config, **toml_config})", "is_method": false, "function_description": "Core utility function that loads and merges configuration settings from standard INI and TOML files in the current working directory and script location, providing a combined configuration dictionary for application use."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/settings.py", "function": "_config_from_ini", "line_number": 35, "body": "def _config_from_ini(paths):\n    parser = configparser.ConfigParser()\n    parser.read(paths)\n\n    flags = {\n        \"changelog_capitalize\",\n        \"changelog_scope\",\n        \"check_build_status\",\n        \"commit_version_number\",\n        \"patch_without_tag\",\n        \"major_on_zero\",\n        \"remove_dist\",\n        \"upload_to_pypi\",\n        \"upload_to_release\",\n    }\n\n    # Iterate through the sections so that default values are applied\n    # correctly.  See:\n    # https://stackoverflow.com/questions/1773793/convert-configparser-items-to-dictionary\n    config = {}\n    for key, _ in parser.items(\"semantic_release\"):\n        if key in flags:\n            config[key] = parser.getboolean(\"semantic_release\", key)\n        else:\n            config[key] = parser.get(\"semantic_release\", key)\n\n    return config", "is_method": false, "function_description": "Utility function that reads semantic release configuration from INI files, parsing keys with appropriate types for use in build and deployment processes."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/settings.py", "function": "_config_from_pyproject", "line_number": 64, "body": "def _config_from_pyproject(path):\n    if os.path.isfile(path):\n        try:\n            with open(path, \"r\") as f:\n                pyproject = tomlkit.loads(f.read())\n            if pyproject:\n                return pyproject.get(\"tool\", {}).get(\"semantic_release\", {})\n        except TOMLKitError as e:\n            logger.debug(f\"Could not decode pyproject.toml: {e}\")\n\n    return {}", "is_method": false, "function_description": "This function extracts and returns the \"semantic_release\" configuration from a pyproject.toml file, facilitating access to project-specific release settings if they exist and are properly formatted."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/settings.py", "function": "current_commit_parser", "line_number": 80, "body": "def current_commit_parser() -> Callable:\n    \"\"\"Get the currently-configured commit parser\n\n    :raises ImproperConfigurationError: if ImportError or AttributeError is raised\n    :returns: Commit parser\n    \"\"\"\n\n    try:\n        # All except the last part is the import path\n        parts = config.get(\"commit_parser\").split(\".\")\n        module = \".\".join(parts[:-1])\n        # The final part is the name of the parse function\n        return getattr(importlib.import_module(module), parts[-1])\n    except (ImportError, AttributeError) as error:\n        raise ImproperConfigurationError(f'Unable to import parser \"{error}\"')", "is_method": false, "function_description": "Utility function that dynamically loads and returns the commit parser specified in configuration, enabling flexible commit parsing based on configurable import paths. It raises an error if the configured parser cannot be imported or found."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/settings.py", "function": "current_changelog_components", "line_number": 97, "body": "def current_changelog_components() -> List[Callable]:\n    \"\"\"Get the currently-configured changelog components\n\n    :raises ImproperConfigurationError: if ImportError or AttributeError is raised\n    :returns: List of component functions\n    \"\"\"\n    component_paths = config.get(\"changelog_components\").split(\",\")\n    components = list()\n\n    for path in component_paths:\n        try:\n            # All except the last part is the import path\n            parts = path.split(\".\")\n            module = \".\".join(parts[:-1])\n            # The final part is the name of the component function\n            components.append(getattr(importlib.import_module(module), parts[-1]))\n        except (ImportError, AttributeError) as error:\n            raise ImproperConfigurationError(\n                f'Unable to import changelog component \"{path}\"'\n            )\n\n    return components", "is_method": false, "function_description": "Function that retrieves and returns the list of currently configured changelog component functions by dynamically importing them based on configuration, ensuring valid setup or raising errors if misconfigured."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/settings.py", "function": "overload_configuration", "line_number": 121, "body": "def overload_configuration(func):\n    \"\"\"This decorator gets the content of the \"define\" array and edits \"config\"\n    according to the pairs of key/value.\n    \"\"\"\n\n    @wraps(func)\n    def wrap(*args, **kwargs):\n        if \"define\" in kwargs:\n            for defined_param in kwargs[\"define\"]:\n                pair = defined_param.split(\"=\", maxsplit=1)\n                if len(pair) == 2:\n                    config[str(pair[0])] = pair[1]\n        return func(*args, **kwargs)\n\n    return wrap", "is_method": false, "function_description": "Decorator that updates a global configuration dictionary based on key/value pairs passed via the \"define\" argument before executing the decorated function. It enables dynamic configuration adjustments at runtime through function calls."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "check_repo", "line_number": 27, "body": "def check_repo(func):\n    \"\"\"Decorator which checks that we are in a git repository.\"\"\"\n\n    @wraps(func)\n    def function_wrapper(*args, **kwargs):\n        if repo is None:\n            raise GitError(\"Not in a valid git repository\")\n        return func(*args, **kwargs)\n\n    return function_wrapper", "is_method": false, "function_description": "Decorator function that ensures the wrapped function runs only within a valid git repository context, raising an error otherwise to prevent invalid git operations."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "get_commit_log", "line_number": 40, "body": "def get_commit_log(from_rev=None):\n    \"\"\"Yield all commit messages from last to first.\"\"\"\n    rev = None\n    if from_rev:\n        try:\n            repo.commit(from_rev)\n            rev = f\"...{from_rev}\"\n        except BadName:\n            logger.debug(\n                f\"Reference {from_rev} does not exist, considering entire history\"\n            )\n\n    for commit in repo.iter_commits(rev):\n        yield (commit.hexsha, commit.message.replace(\"\\r\\n\", \"\\n\"))", "is_method": false, "function_description": "Function that iterates backward through git commits starting from an optional revision, yielding each commit\u2019s hash and message. It supports retrieving historical commit logs for version tracking or analysis."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "get_last_version", "line_number": 58, "body": "def get_last_version(skip_tags=None) -> Optional[str]:\n    \"\"\"\n    Find the latest version using repo tags.\n\n    :return: A string containing a version number.\n    \"\"\"\n    skip_tags = skip_tags or []\n\n    def version_finder(tag):\n        if isinstance(tag.commit, TagObject):\n            return tag.tag.tagged_date\n        return tag.commit.committed_date\n\n    for i in sorted(repo.tags, reverse=True, key=version_finder):\n        if re.match(r\"v\\d+\\.\\d+\\.\\d+\", i.name):  # Matches vX.X.X\n            if i.name in skip_tags:\n                continue\n            return i.name[1:]  # Strip off 'v'\n\n    return None", "is_method": false, "function_description": "Function that retrieves the latest semantic version string from a repository's tags, optionally skipping specified tags. It enables tools to determine the most recent release version efficiently."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "get_version_from_tag", "line_number": 82, "body": "def get_version_from_tag(tag_name: str) -> Optional[str]:\n    \"\"\"\n    Get the git commit hash corresponding to a tag name.\n\n    :param tag_name: Name of the git tag (i.e. 'v1.0.0')\n    :return: sha1 hash of the commit\n    \"\"\"\n    for i in repo.tags:\n        if i.name == tag_name:\n            return i.commit.hexsha\n    return None", "is_method": false, "function_description": "Function that retrieves the commit hash associated with a given Git tag name, enabling identification of specific code versions by their tags in a repository."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "get_repository_owner_and_name", "line_number": 97, "body": "def get_repository_owner_and_name() -> Tuple[str, str]:\n    \"\"\"\n    Check the 'origin' remote to get the owner and name of the remote repository.\n\n    :return: A tuple of the owner and name.\n    \"\"\"\n    url = repo.remote(\"origin\").url\n    split_url = urlsplit(url)\n    # Select the owner and name as regex groups\n    parts = re.search(r\"[:/]([^:]+)/([^/]*?)(.git)?$\", split_url.path)\n    if not parts:\n        raise HvcsRepoParseError\n\n    return parts.group(1), parts.group(2)", "is_method": false, "function_description": "Function that extracts and returns the owner and repository name from the remote 'origin' URL of a version control repository. It is useful for identifying repository metadata in automation or integration tasks."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "get_current_head_hash", "line_number": 114, "body": "def get_current_head_hash() -> str:\n    \"\"\"\n    Get the commit hash of the current HEAD.\n\n    :return: The commit hash.\n    \"\"\"\n    return repo.head.commit.name_rev.split(\" \")[0]", "is_method": false, "function_description": "Utility function that returns the commit hash of the current HEAD in a Git repository, facilitating version tracking or identification of the latest commit."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "commit_new_version", "line_number": 125, "body": "def commit_new_version(version: str):\n    \"\"\"\n    Commit the file containing the version number variable.\n\n    The commit message will be generated from the configured template.\n\n    :param version: Version number to be used in the commit message.\n    \"\"\"\n    from .history import load_version_declarations\n\n    commit_subject = config.get(\"commit_subject\")\n    message = commit_subject.format(version=version)\n\n    # Add an extended message if one is configured\n    commit_message = config.get(\"commit_message\")\n    if commit_message:\n        message += \"\\n\\n\"\n        message += commit_message.format(version=version)\n\n    commit_author = config.get(\n        \"commit_author\",\n        \"semantic-release <semantic-release>\",\n    )\n\n    for declaration in load_version_declarations():\n        git_path = PurePath(os.getcwd(), declaration.path).relative_to(repo.working_dir)\n        repo.git.add(str(git_path))\n\n    return repo.git.commit(m=message, author=commit_author)", "is_method": false, "function_description": "Function that creates a git commit for files specifying the version number, using a templated commit message with the given version and configured author details. It streamlines version update commits in release workflows."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "update_changelog_file", "line_number": 158, "body": "def update_changelog_file(version: str, content_to_add: str):\n    \"\"\"\n    Update changelog file with changelog for the release.\n\n    :param version: The release version number, as a string.\n    :param content_to_add: The release notes for the version.\n    \"\"\"\n    changelog_file = config.get(\"changelog_file\")\n    changelog_placeholder = config.get(\"changelog_placeholder\")\n    git_path = Path(os.getcwd(), changelog_file)\n    if not git_path.exists():\n        original_content = f\"# Changelog\\n\\n{changelog_placeholder}\\n\"\n        logger.warning(f\"Changelog file not found: {git_path} - creating it.\")\n    else:\n        original_content = git_path.read_text()\n\n    if changelog_placeholder not in original_content:\n        logger.warning(\n            f\"Placeholder '{changelog_placeholder}' not found \"\n            f\"in changelog file {git_path} - skipping change.\"\n        )\n        return\n\n    updated_content = original_content.replace(\n        changelog_placeholder,\n        \"\\n\".join(\n            [\n                changelog_placeholder,\n                \"\",\n                f\"## v{version} ({date.today():%Y-%m-%d})\",\n                content_to_add,\n            ]\n        ),\n    )\n    git_path.write_text(updated_content)\n    repo.git.add(str(git_path.relative_to(repo.working_dir)))", "is_method": false, "function_description": "Function that appends a new release entry with version and notes to a changelog file, creating the file if missing and using a placeholder to insert updated content. It helps automate maintaining project release histories."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "tag_new_version", "line_number": 198, "body": "def tag_new_version(version: str):\n    \"\"\"\n    Create a new tag with the version number, prefixed with v.\n\n    :param version: The version number used in the tag as a string.\n    \"\"\"\n    return repo.git.tag(\"-a\", f\"v{version}\", m=f\"v{version}\")", "is_method": false, "function_description": "Function that creates a new Git tag prefixed with \"v\" for the specified version string, enabling version control and release management."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "push_new_version", "line_number": 209, "body": "def push_new_version(\n    auth_token: str = None,\n    owner: str = None,\n    name: str = None,\n    branch: str = \"master\",\n    domain: str = \"github.com\",\n):\n    \"\"\"\n    Run git push and git push --tags.\n\n    :param auth_token: Authentication token used to push.\n    :param owner: Organisation or user that owns the repository.\n    :param name: Name of repository.\n    :param branch: Branch to push to\n    :param server_url: Name of the server. Will be used to identify a gitlab instance.\n    :raises GitError: if GitCommandError is raised\n    \"\"\"\n    server = \"origin\"\n    if auth_token:\n        token = auth_token\n        if config.get(\"hvcs\") == \"gitlab\":\n            token = \"gitlab-ci-token:\" + token\n        actor = os.environ.get(\"GITHUB_ACTOR\")\n        if actor:\n            server = f\"https://{actor}:{token}@{domain}/{owner}/{name}.git\"\n        else:\n            server = f\"https://{token}@{domain}/{owner}/{name}.git\"\n\n    try:\n        repo.git.push(server, branch)\n        repo.git.push(\"--tags\", server, branch)\n    except GitCommandError as error:\n        message = str(error)\n        if auth_token:\n            message = message.replace(auth_token, \"[AUTH_TOKEN]\")\n        raise GitError(message)", "is_method": false, "function_description": "Function that pushes code and tags to a specified Git repository branch, supporting authentication tokens and customizable repository details for automated version updates."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "checkout", "line_number": 249, "body": "def checkout(branch: str):\n    \"\"\"\n    Check out the given branch in the local repository.\n\n    :param branch: The branch to checkout.\n    \"\"\"\n    return repo.git.checkout(branch)", "is_method": false, "function_description": "Function enabling switching to a specified branch in a local Git repository, facilitating version control workflows that require context changes between code branches."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/vcs_helpers.py", "function": "version_finder", "line_number": 66, "body": "def version_finder(tag):\n        if isinstance(tag.commit, TagObject):\n            return tag.tag.tagged_date\n        return tag.commit.committed_date", "is_method": false, "function_description": "Determine and return the relevant date of a version tag, prioritizing the tag's own date if available, otherwise using the commit's date. This function helps identify when a version was created or committed."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/helpers.py", "function": "format_arg", "line_number": 9, "body": "def format_arg(value):\n    if type(value) == str:\n        return f\"'{value.strip()}'\"\n    else:\n        return str(value)", "is_method": false, "function_description": "Utility function that formats a value as a string, enclosing strings in quotes and trimming whitespace, to standardize argument representation for display or logging purposes."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/helpers.py", "function": "build_requests_session", "line_number": 16, "body": "def build_requests_session(\n    raise_for_status=True, retry: Union[bool, int, Retry] = True\n) -> Session:\n    \"\"\"\n    Create a requests session.\n    :param raise_for_status: If True, a hook to invoke raise_for_status be installed\n    :param retry: If true, it will use default Retry configuration. if an integer, it will use default Retry\n    configuration with given integer as total retry count. if Retry instance, it will use this instance.\n    :return: configured requests Session\n    \"\"\"\n    session = Session()\n    if raise_for_status:\n        session.hooks = {\"response\": [lambda r, *args, **kwargs: r.raise_for_status()]}\n    if retry:\n        if isinstance(retry, bool):\n            retry = Retry()\n        elif isinstance(retry, int):\n            retry = Retry(retry)\n        elif not isinstance(retry, Retry):\n            raise ValueError(\"retry should be a bool, int or Retry instance.\")\n        adapter = HTTPAdapter(max_retries=retry)\n        session.mount(\"http://\", adapter)\n        session.mount(\"https://\", adapter)\n    return session", "is_method": false, "function_description": "Function that constructs and returns a configurable HTTP requests session with optional automatic error raising on responses and customizable retry logic for robust network communication."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/helpers.py", "function": "__call__", "line_number": 55, "body": "def __call__(self, func):\n        @functools.wraps(func)\n        def logged_func(*args, **kwargs):\n            # Log function name and arguments\n            self.logger.debug(\n                \"{function}({args}{kwargs})\".format(\n                    function=func.__name__,\n                    args=\", \".join([format_arg(x) for x in args]),\n                    kwargs=\"\".join(\n                        [f\", {k}={format_arg(v)}\" for k, v in kwargs.items()]\n                    ),\n                )\n            )\n\n            # Call function\n            result = func(*args, **kwargs)\n\n            # Log result\n            if result is not None:\n                self.logger.debug(f\"{func.__name__} -> {result}\")\n            return result\n\n        return logged_func", "is_method": true, "class_name": "LoggedFunction", "function_description": "Provides a decorator that logs function calls, including their arguments and return values, aiding debugging and monitoring by capturing detailed execution information. It wraps any function to automatically produce these logs without altering the function's behavior."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/helpers.py", "function": "logged_func", "line_number": 57, "body": "def logged_func(*args, **kwargs):\n            # Log function name and arguments\n            self.logger.debug(\n                \"{function}({args}{kwargs})\".format(\n                    function=func.__name__,\n                    args=\", \".join([format_arg(x) for x in args]),\n                    kwargs=\"\".join(\n                        [f\", {k}={format_arg(v)}\" for k, v in kwargs.items()]\n                    ),\n                )\n            )\n\n            # Call function\n            result = func(*args, **kwargs)\n\n            # Log result\n            if result is not None:\n                self.logger.debug(f\"{func.__name__} -> {result}\")\n            return result", "is_method": true, "class_name": "LoggedFunction", "function_description": "Core utility of the LoggedFunction class that wraps another function to log its name, input arguments, and result, enabling detailed traceability and debugging of function calls."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "_fix_mime_types", "line_number": 52, "body": "def _fix_mime_types():\n    \"\"\"Fix incorrect entries in the `mimetypes` registry.\n    On Windows, the Python standard library's `mimetypes` reads in\n    mappings from file extension to MIME type from the Windows\n    registry. Other applications can and do write incorrect values\n    to this registry, which causes `mimetypes.guess_type` to return\n    incorrect values, which causes TensorBoard to fail to render on\n    the frontend.\n    This method hard-codes the correct mappings for certain MIME\n    types that are known to be either used by python-semantic-release or\n    problematic in general.\n    \"\"\"\n    mimetypes.add_type(\"text/markdown\", \".md\")", "is_method": false, "function_description": "Fixes incorrect MIME type mappings in the system registry by hard-coding correct values to ensure proper MIME type recognition, preventing frontend rendering issues in applications like TensorBoard."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "get_hvcs", "line_number": 430, "body": "def get_hvcs() -> Base:\n    \"\"\"Get HVCS helper class\n\n    :raises ImproperConfigurationError: if the hvcs option provided is not valid\n    \"\"\"\n    hvcs = config.get(\"hvcs\")\n    try:\n        return globals()[hvcs.capitalize()]\n    except KeyError:\n        raise ImproperConfigurationError('\"{0}\" is not a valid option for hvcs.')", "is_method": false, "function_description": "This function retrieves and returns a version control system helper class based on a configuration setting, raising an error for invalid configurations. It enables dynamic selection of HVCS helpers for managing version control operations."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "check_build_status", "line_number": 442, "body": "def check_build_status(owner: str, repository: str, ref: str) -> bool:\n    \"\"\"\n    Checks the build status of a commit on the api from your hosted version control provider.\n\n    :param owner: The owner of the repository\n    :param repository: The repository name\n    :param ref: Commit or branch reference\n    :return: A boolean with the build status\n    \"\"\"\n    logger.debug(f\"Checking build status for {owner}/{repository}#{ref}\")\n    return get_hvcs().check_build_status(owner, repository, ref)", "is_method": false, "function_description": "Function that checks if a specific commit or branch build has succeeded by querying the hosted version control provider\u2019s API, useful for CI/CD status monitoring and automation workflows."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "post_changelog", "line_number": 455, "body": "def post_changelog(owner: str, repository: str, version: str, changelog: str) -> bool:\n    \"\"\"\n    Posts the changelog to the current hvcs release API\n\n    :param owner: The owner of the repository\n    :param repository: The repository name\n    :param version: A string with the new version\n    :param changelog: A string with the changelog in correct format\n    :return: a tuple with success status and payload from hvcs\n    \"\"\"\n    logger.debug(f\"Posting release changelog for {owner}/{repository} {version}\")\n    return get_hvcs().post_release_changelog(owner, repository, version, changelog)", "is_method": false, "function_description": "Function that publishes a changelog for a specific version of a repository to the hosting service's release API, facilitating automated release documentation updates."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "upload_to_release", "line_number": 469, "body": "def upload_to_release(owner: str, repository: str, version: str, path: str) -> bool:\n    \"\"\"\n    Upload distributions to the current hvcs release API\n\n    :param owner: The owner of the repository\n    :param repository: The repository name\n    :param version: A string with the version to upload for\n    :param path: Path to dist directory\n\n    :return: Status of the request\n    \"\"\"\n\n    return get_hvcs().upload_dists(owner, repository, version, path)", "is_method": false, "function_description": "Function that uploads distribution files to a specified version release in a version control hosting service, facilitating automated deployment or release management workflows."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "get_token", "line_number": 484, "body": "def get_token() -> Optional[str]:\n    \"\"\"\n    Returns the token for the current VCS\n\n    :return: The token in string form\n    \"\"\"\n    return get_hvcs().token()", "is_method": false, "function_description": "Utility function that returns the authentication token for the current version control system (VCS), enabling authorized interactions with the VCS APIs or services."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "get_domain", "line_number": 493, "body": "def get_domain() -> Optional[str]:\n    \"\"\"\n    Returns the domain for the current VCS\n\n    :return: The domain in string form\n    \"\"\"\n    return get_hvcs().domain()", "is_method": false, "function_description": "This function provides the domain name associated with the current version control system, enabling other functions to identify or interact with the appropriate VCS endpoint."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "check_token", "line_number": 502, "body": "def check_token() -> bool:\n    \"\"\"\n    Checks whether there exists a token or not.\n\n    :return: A boolean telling if there is a token.\n    \"\"\"\n    return get_hvcs().token() is not None", "is_method": false, "function_description": "Utility function that verifies the presence of a token by checking if a valid token exists within the system. It provides a simple boolean status for token availability."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "api_url", "line_number": 29, "body": "def api_url() -> str:\n        raise NotImplementedError", "is_method": true, "class_name": "Base", "function_description": "Returns the API URL endpoint for the service. This placeholder method must be implemented by subclasses to specify their API URL."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "upload_dists", "line_number": 47, "body": "def upload_dists(cls, owner: str, repo: str, version: str, path: str) -> bool:\n        # Skip on unsupported HVCS instead of raising error\n        return True", "is_method": true, "class_name": "Base", "function_description": "Returns True as a placeholder to indicate successful upload for distribution packages; used when handling unsupported version control systems without errors."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "__eq__", "line_number": 75, "body": "def __eq__(self, other):\n        return all(\n            [\n                self.token == getattr(other, \"token\", None),\n            ]\n        )", "is_method": true, "class_name": "TokenAuth", "function_description": "Equality comparison method for TokenAuth instances that checks if their authentication tokens are the same, enabling accurate token-based identity verification."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "__ne__", "line_number": 82, "body": "def __ne__(self, other):\n        return not self == other", "is_method": true, "class_name": "TokenAuth", "function_description": "Overrides inequality comparison to determine if two TokenAuth instances are not equal, enabling straightforward inequality checks in authentication logic."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "__call__", "line_number": 85, "body": "def __call__(self, r):\n        r.headers[\"Authorization\"] = f\"token {self.token}\"\n        return r", "is_method": true, "class_name": "TokenAuth", "function_description": "Adds an authorization token to HTTP request headers, enabling authenticated API calls using token-based authentication."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "domain", "line_number": 97, "body": "def domain() -> str:\n        \"\"\"Github domain property\n\n        :return: The Github domain\n        \"\"\"\n        hvcs_domain = config.get(\"hvcs_domain\")\n        domain = hvcs_domain if hvcs_domain else Github.DEFAULT_DOMAIN\n        return domain", "is_method": true, "class_name": "Github", "function_description": "Returns the GitHub domain currently configured, defaulting to the standard GitHub domain if no custom domain is set. This supports flexibility for GitHub Enterprise or custom setups."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "api_url", "line_number": 107, "body": "def api_url() -> str:\n        \"\"\"Github api_url property\n\n        :return: The Github API URL\n        \"\"\"\n        # not necessarily prefixed with api in the case of a custom domain, so\n        # can't just default DEFAULT_DOMAIN to github.com\n        hvcs_domain = config.get(\"hvcs_domain\")\n        hostname = hvcs_domain if hvcs_domain else \"api.\" + Github.DEFAULT_DOMAIN\n        return f\"https://{hostname}\"", "is_method": true, "class_name": "Github", "function_description": "Provides the base URL for GitHub's API, accommodating custom domains when configured. This function enables other components to construct API requests with the correct endpoint."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "token", "line_number": 119, "body": "def token() -> Optional[str]:\n        \"\"\"Github token property\n\n        :return: The Github token environment variable (GH_TOKEN) value\n        \"\"\"\n        return os.environ.get(\"GH_TOKEN\")", "is_method": true, "class_name": "Github", "function_description": "Utility method of the Github class that retrieves the Github token from the environment variable \"GH_TOKEN\" for authentication purposes in API interactions."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "auth", "line_number": 127, "body": "def auth() -> Optional[TokenAuth]:\n        \"\"\"Github token property\n\n        :return: The Github token environment variable (GH_TOKEN) value\n        \"\"\"\n        token = Github.token()\n        if not token:\n            return None\n        return TokenAuth(token)", "is_method": true, "class_name": "Github", "function_description": "Returns a GitHub authentication token wrapped in a TokenAuth object if available; otherwise, returns None. This method enables authenticated interactions with the GitHub API using environment-stored credentials."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "session", "line_number": 138, "body": "def session(\n        raise_for_status=True, retry: Union[Retry, bool, int] = True\n    ) -> Session:\n        session = build_requests_session(raise_for_status=raise_for_status, retry=retry)\n        session.auth = Github.auth()\n        return session", "is_method": true, "class_name": "Github", "function_description": "Creates and returns an authenticated HTTP session configured for GitHub API requests, supporting automatic retries and optional error raising to facilitate robust interaction with GitHub services."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "check_build_status", "line_number": 147, "body": "def check_build_status(owner: str, repo: str, ref: str) -> bool:\n        \"\"\"Check build status\n\n        https://docs.github.com/rest/reference/repos#get-the-combined-status-for-a-specific-reference\n\n        :param owner: The owner namespace of the repository\n        :param repo: The repository name\n        :param ref: The sha1 hash of the commit ref\n\n        :return: Was the build status success?\n        \"\"\"\n        url = \"{domain}/repos/{owner}/{repo}/commits/{ref}/status\"\n        try:\n            response = Github.session().get(\n                url.format(domain=Github.api_url(), owner=owner, repo=repo, ref=ref)\n            )\n            return response.json().get(\"state\") == \"success\"\n        except HTTPError as e:\n            logger.warning(f\"Build status check on Github has failed: {e}\")\n            return False", "is_method": true, "class_name": "Github", "function_description": "Utility method of the Github class that checks if the latest build status for a specific commit in a repository was successful, enabling automation or monitoring of continuous integration outcomes."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "create_release", "line_number": 170, "body": "def create_release(cls, owner: str, repo: str, tag: str, changelog: str) -> bool:\n        \"\"\"Create a new release\n\n        https://docs.github.com/rest/reference/repos#create-a-release\n\n        :param owner: The owner namespace of the repository\n        :param repo: The repository name\n        :param tag: Tag to create release for\n        :param changelog: The release notes for this version\n\n        :return: Whether the request succeeded\n        \"\"\"\n        try:\n            Github.session().post(\n                f\"{Github.api_url()}/repos/{owner}/{repo}/releases\",\n                json={\n                    \"tag_name\": tag,\n                    \"name\": tag,\n                    \"body\": changelog,\n                    \"draft\": False,\n                    \"prerelease\": False,\n                },\n            )\n            return True\n        except HTTPError as e:\n            logger.warning(f\"Release creation on Github has failed: {e}\")\n            return False", "is_method": true, "class_name": "Github", "function_description": "Creates a new release in a specified GitHub repository with a given tag and changelog, returning success status. This enables automated management of release versions on GitHub."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "get_release", "line_number": 200, "body": "def get_release(cls, owner: str, repo: str, tag: str) -> Optional[int]:\n        \"\"\"Get a release by its tag name\n\n        https://docs.github.com/rest/reference/repos#get-a-release-by-tag-name\n\n        :param owner: The owner namespace of the repository\n        :param repo: The repository name\n        :param tag: Tag to get release for\n\n        :return: ID of found release\n        \"\"\"\n        try:\n            response = Github.session().get(\n                f\"{Github.api_url()}/repos/{owner}/{repo}/releases/tags/{tag}\"\n            )\n            return response.json().get(\"id\")\n        except HTTPError as e:\n            if e.response.status_code != 404:\n                logger.debug(f\"Get release by tag on Github has failed: {e}\")\n            return None", "is_method": true, "class_name": "Github", "function_description": "Utility method of the Github class that retrieves the ID of a repository release matching a specified tag name, facilitating release identification and management in GitHub repositories."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "edit_release", "line_number": 223, "body": "def edit_release(cls, owner: str, repo: str, id: int, changelog: str) -> bool:\n        \"\"\"Edit a release with updated change notes\n\n        https://docs.github.com/rest/reference/repos#update-a-release\n\n        :param owner: The owner namespace of the repository\n        :param repo: The repository name\n        :param id: ID of release to update\n        :param changelog: The release notes for this version\n\n        :return: Whether the request succeeded\n        \"\"\"\n        try:\n            Github.session().post(\n                f\"{Github.api_url()}/repos/{owner}/{repo}/releases/{id}\",\n                json={\"body\": changelog},\n            )\n            return True\n        except HTTPError as e:\n            logger.warning(f\"Edit release on Github has failed: {e}\")\n            return False", "is_method": true, "class_name": "Github", "function_description": "Provides the capability to update the changelog of a specific GitHub repository release by its ID. Returns success status indicating if the update request was completed."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "post_release_changelog", "line_number": 247, "body": "def post_release_changelog(\n        cls, owner: str, repo: str, version: str, changelog: str\n    ) -> bool:\n        \"\"\"Post release changelog\n\n        :param owner: The owner namespace of the repository\n        :param repo: The repository name\n        :param version: The version number\n        :param changelog: The release notes for this version\n\n        :return: The status of the request\n        \"\"\"\n        tag = f\"v{version}\"\n        logger.debug(f\"Attempting to create release for {tag}\")\n        success = Github.create_release(owner, repo, tag, changelog)\n\n        if not success:\n            logger.debug(\"Unsuccessful, looking for an existing release to update\")\n            release_id = Github.get_release(owner, repo, tag)\n            if release_id:\n                logger.debug(f\"Updating release {release_id}\")\n                success = Github.edit_release(owner, repo, release_id, changelog)\n            else:\n                logger.debug(f\"Existing release not found\")\n\n        return success", "is_method": true, "class_name": "Github", "function_description": "Class Github's post_release_changelog method manages release notes by posting or updating changelogs for specific repository versions. It facilitates automated release documentation updates on GitHub."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "upload_asset", "line_number": 276, "body": "def upload_asset(\n        cls, owner: str, repo: str, release_id: int, file: str, label: str = None\n    ) -> bool:\n        \"\"\"Upload an asset to an existing release\n\n        https://docs.github.com/rest/reference/repos#upload-a-release-asset\n\n        :param owner: The owner namespace of the repository\n        :param repo: The repository name\n        :param release_id: ID of the release to upload to\n        :param file: Path of the file to upload\n        :param label: Custom label for this file\n\n        :return: The status of the request\n        \"\"\"\n        url = f\"https://uploads.github.com/repos/{owner}/{repo}/releases/{release_id}/assets\"\n\n        content_type = mimetypes.guess_type(file, strict=False)[0]\n        if not content_type:\n            content_type = \"application/octet-stream\"\n\n        try:\n            response = Github.session().post(\n                url,\n                params={\"name\": os.path.basename(file), \"label\": label},\n                headers={\n                    \"Content-Type\": content_type,\n                },\n                data=open(file, \"rb\").read(),\n            )\n\n            logger.debug(\n                f\"Asset upload on Github completed, url: {response.url}, status code: {response.status_code}\"\n            )\n\n            return True\n        except HTTPError as e:\n            logger.warning(f\"Asset upload {file} on Github has failed: {e}\")\n            return False", "is_method": true, "class_name": "Github", "function_description": "Uploads a specified file as an asset to an existing GitHub release, optionally labeling it. This enables automated management of release assets within repositories."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "upload_dists", "line_number": 317, "body": "def upload_dists(cls, owner: str, repo: str, version: str, path: str) -> bool:\n        \"\"\"Upload distributions to a release\n\n        :param owner: The owner namespace of the repository\n        :param repo: The repository name\n        :param version: Version to upload for\n        :param path: Path to the dist directory\n\n        :return: The status of the request\n        \"\"\"\n\n        # Find the release corresponding to this version\n        release_id = Github.get_release(owner, repo, f\"v{version}\")\n        if not release_id:\n            logger.debug(\"No release found to upload assets to\")\n            return False\n\n        # Upload assets\n        one_or_more_failed = False\n        for file in os.listdir(path):\n            file_path = os.path.join(path, file)\n\n            if not Github.upload_asset(owner, repo, release_id, file_path):\n                one_or_more_failed = True\n\n        return not one_or_more_failed", "is_method": true, "class_name": "Github", "function_description": "Utility method of the Github class that uploads all distribution files from a directory to a specified repository release version, returning success status for the entire batch upload process."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "domain", "line_number": 349, "body": "def domain() -> str:\n        \"\"\"Gitlab domain property\n\n        :return: The Gitlab instance domain\n        \"\"\"\n        domain = config.get(\"hvcs_domain\", os.environ.get(\"CI_SERVER_HOST\"))\n        return domain if domain else \"gitlab.com\"", "is_method": true, "class_name": "Gitlab", "function_description": "Returns the domain name of the Gitlab instance in use, defaulting to \"gitlab.com\" if no custom domain is configured. This supports functions requiring knowledge of the current Gitlab host environment."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "api_url", "line_number": 358, "body": "def api_url() -> str:\n        \"\"\"Gitlab api_url property\n\n        :return: The Gitlab instance API url\n        \"\"\"\n        return f\"https://{Gitlab.domain()}\"", "is_method": true, "class_name": "Gitlab", "function_description": "Returns the base API URL for the Gitlab instance, providing a centralized reference for making API requests within the Gitlab context."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "token", "line_number": 366, "body": "def token() -> Optional[str]:\n        \"\"\"Gitlab token property\n\n        :return: The Gitlab token environment variable (GL_TOKEN) value\n        \"\"\"\n        return os.environ.get(\"GL_TOKEN\")", "is_method": true, "class_name": "Gitlab", "function_description": "This function provides access to the Gitlab API token stored in environment variables, enabling authenticated interactions with Gitlab services requiring this token."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "check_build_status", "line_number": 375, "body": "def check_build_status(owner: str, repo: str, ref: str) -> bool:\n        \"\"\"Check last build status\n\n        :param owner: The owner namespace of the repository. It includes all groups and subgroups.\n        :param repo: The repository name\n        :param ref: The sha1 hash of the commit ref\n\n        :return: the status of the pipeline (False if a job failed)\n        \"\"\"\n        gl = gitlab.Gitlab(Gitlab.api_url(), private_token=Gitlab.token())\n        gl.auth()\n        jobs = gl.projects.get(owner + \"/\" + repo).commits.get(ref).statuses.list()\n        for job in jobs:\n            if job[\"status\"] not in [\"success\", \"skipped\"]:\n                if job[\"status\"] == \"pending\":\n                    logger.debug(\n                        f\"check_build_status: job {job['name']} is still in pending status\"\n                    )\n                    return False\n                elif job[\"status\"] == \"failed\" and not job[\"allow_failure\"]:\n                    logger.debug(f\"check_build_status: job {job['name']} failed\")\n                    return False\n        return True", "is_method": true, "class_name": "Gitlab", "function_description": "Checks the latest pipeline build status for a specific commit, returning True if all jobs succeeded or were skipped, and False if any job failed or is still pending. Useful for automated validation of CI/CD build outcomes."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/hvcs.py", "function": "post_release_changelog", "line_number": 401, "body": "def post_release_changelog(\n        cls, owner: str, repo: str, version: str, changelog: str\n    ) -> bool:\n        \"\"\"Post release changelog\n\n        :param owner: The owner namespace of the repository\n        :param repo: The repository name\n        :param version: The version number\n        :param changelog: The release notes for this version\n\n        :return: The status of the request\n        \"\"\"\n        ref = \"v\" + version\n        gl = gitlab.Gitlab(Gitlab.api_url(), private_token=Gitlab.token())\n        gl.auth()\n        try:\n            tag = gl.projects.get(owner + \"/\" + repo).tags.get(ref)\n            tag.set_release_description(changelog)\n        except gitlab.exceptions.GitlabGetError:\n            logger.debug(f\"Tag {ref} was not found for project {owner}/{repo}\")\n            return False\n        except gitlab.exceptions.GitlabUpdateError:\n            logger.debug(f\"Failed to update tag {ref} for project {owner}/{repo}\")\n            return False\n\n        return True", "is_method": true, "class_name": "Gitlab", "function_description": "Method of the Gitlab class that posts release notes to a specific repository version tag, enabling automated update of changelogs on GitLab projects. It returns the success status of this update operation."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/parser_emoji.py", "function": "parse_commit_message", "line_number": 14, "body": "def parse_commit_message(\n    message: str,\n) -> ParsedCommit:\n    \"\"\"\n    Parse a commit using an emoji in the subject line.\n\n    When multiple emojis are encountered, the one with the highest bump\n    level is used. If there are multiple emojis on the same level, the\n    we use the one listed earliest in the configuration.\n\n    If the message does not contain any known emojis, then the level to bump\n    will be 0 and the type of change \"Other\". This parser never raises\n    UnknownCommitMessageStyleError.\n\n    Emojis are not removed from the description, and will appear alongside\n    the commit subject in the changelog.\n\n    :param message: A string of a commit message.\n    :return: A tuple of (level to bump, type of change, scope of change, a tuple with descriptions)\n    \"\"\"\n\n    subject = message.split(\"\\n\")[0]\n\n    major = config.get(\"major_emoji\").split(\",\")\n    minor = config.get(\"minor_emoji\").split(\",\")\n    patch = config.get(\"patch_emoji\").split(\",\")\n    all_emojis = major + minor + patch\n\n    # Loop over emojis from most important to least important\n    # Therefore, we find the highest level emoji first\n    primary_emoji = \"Other\"\n    for emoji in all_emojis:\n        if emoji in subject:\n            primary_emoji = emoji\n            break\n    logger.debug(f\"Selected {primary_emoji} as the primary emoji\")\n\n    # Find which level this commit was from\n    level_bump = 0\n    if primary_emoji in major:\n        level_bump = 3\n    elif primary_emoji in minor:\n        level_bump = 2\n    elif primary_emoji in patch:\n        level_bump = 1\n\n    # All emojis will remain part of the returned description\n    descriptions = parse_paragraphs(message)\n    return ParsedCommit(\n        level_bump,\n        primary_emoji,\n        None,\n        descriptions,\n        descriptions[1:] if level_bump == 3 else [],\n    )", "is_method": false, "function_description": "Function that analyzes a commit message for configured emojis to determine the semantic version bump level and change type. It returns a structured summary including descriptions while preserving emojis for changelog use."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/parser_helpers.py", "function": "parse_paragraphs", "line_number": 15, "body": "def parse_paragraphs(text: str) -> List[str]:\n    \"\"\"\n    This will take a text block and return a tuple containing each\n    paragraph with single line breaks collapsed into spaces.\n\n    :param text: The text string to be divided.\n    :return: A tuple of paragraphs.\n    \"\"\"\n    return [\n        paragraph.replace(\"\\n\", \" \")\n        for paragraph in text.split(\"\\n\\n\")\n        if len(paragraph) > 0\n    ]", "is_method": false, "function_description": "Function that splits a block of text into paragraphs by double line breaks, collapsing single line breaks within paragraphs into spaces, facilitating paragraph-level text processing or analysis."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "get_current_version_by_tag", "line_number": 183, "body": "def get_current_version_by_tag() -> str:\n    \"\"\"\n    Find the current version of the package in the current working directory using git tags.\n\n    :return: A string with the version number or 0.0.0 on failure.\n    \"\"\"\n    version = get_last_version()\n    if version:\n        return version\n\n    logger.debug(\"no version found, returning default of v0.0.0\")\n    return \"0.0.0\"", "is_method": false, "function_description": "Function that retrieves the current package version from git tags in the working directory, returning \"0.0.0\" if no version is found. It provides versioning information useful for deployment or build validation."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "get_current_version_by_config_file", "line_number": 198, "body": "def get_current_version_by_config_file() -> str:\n    \"\"\"\n    Get current version from the version variable defined in the configuration.\n\n    :return: A string with the current version number\n    :raises ImproperConfigurationError: if either no versions are found, or\n    multiple versions are found.\n    \"\"\"\n    declarations = load_version_declarations()\n    versions = set.union(*[x.parse() for x in declarations])\n\n    if len(versions) == 0:\n        raise ImproperConfigurationError(\n            \"no versions found in the configured locations\"\n        )\n    if len(versions) != 1:\n        version_strs = \", \".join(repr(x) for x in versions)\n        raise ImproperConfigurationError(f\"found conflicting versions: {version_strs}\")\n\n    version = versions.pop()\n    logger.debug(f\"Regex matched version: {version}\")\n    return version", "is_method": false, "function_description": "Function that retrieves the current version string defined in configuration files, ensuring exactly one unique version is specified; it raises errors for absent or conflicting version declarations."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "get_current_version", "line_number": 222, "body": "def get_current_version() -> str:\n    \"\"\"\n    Get current version from tag or version variable, depending on configuration.\n\n    :return: A string with the current version number\n    \"\"\"\n    if config.get(\"version_source\") == \"tag\":\n        return get_current_version_by_tag()\n    return get_current_version_by_config_file()", "is_method": false, "function_description": "Utility function that retrieves the current version string from either a tag or configuration file based on settings, enabling consistent version tracking across different version management approaches."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "get_new_version", "line_number": 234, "body": "def get_new_version(current_version: str, level_bump: str) -> str:\n    \"\"\"\n    Calculate the next version based on the given bump level with semver.\n\n    :param current_version: The version the package has now.\n    :param level_bump: The level of the version number that should be bumped.\n        Should be `'major'`, `'minor'` or `'patch'`.\n    :return: A string with the next version number.\n    \"\"\"\n    if not level_bump:\n        logger.debug(\"No bump requested, returning input version\")\n        return current_version\n    return str(semver.VersionInfo.parse(current_version).next_version(part=level_bump))", "is_method": false, "function_description": "Function that calculates the next semantic version string by incrementing the specified version component (major, minor, or patch) based on a given current version. It ensures consistent versioning for package releases or updates."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "get_previous_version", "line_number": 250, "body": "def get_previous_version(version: str) -> Optional[str]:\n    \"\"\"\n    Return the version prior to the given version.\n\n    :param version: A string with the version number.\n    :return: A string with the previous version number.\n    \"\"\"\n    found_version = False\n    for commit_hash, commit_message in get_commit_log():\n        logger.debug(f\"Checking commit {commit_hash}\")\n        if version in commit_message:\n            found_version = True\n            logger.debug(f'Found version in commit \"{commit_message}\"')\n            continue\n\n        if found_version:\n            matches = re.match(r\"v?(\\d+.\\d+.\\d+)\", commit_message)\n            if matches:\n                logger.debug(f\"Version matches regex {commit_message}\")\n                return matches.group(1).strip()\n\n    return get_last_version([version, f\"v{version}\"])", "is_method": false, "function_description": "Function that finds and returns the version string immediately preceding a specified version by analyzing commit history. Useful for tracking software version progression or dependencies."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "set_new_version", "line_number": 275, "body": "def set_new_version(new_version: str) -> bool:\n    \"\"\"\n    Update the version number in each configured location.\n\n    :param new_version: The new version number as a string.\n    :return: `True` if it succeeded.\n    \"\"\"\n\n    for declaration in load_version_declarations():\n        declaration.replace(new_version)\n\n    return True", "is_method": false, "function_description": "Function that updates the version number across all configured locations, ensuring consistency of versioning in a project or system. It returns True upon successfully applying the new version."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "load_version_declarations", "line_number": 289, "body": "def load_version_declarations() -> List[VersionDeclaration]:\n    \"\"\"\n    Create the `VersionDeclaration` objects specified by the config file.\n    \"\"\"\n    declarations = []\n\n    def iter_fields(x):\n        if not x:\n            return\n        if isinstance(x, list):\n            yield from x\n        else:\n            # Split by commas, but allow the user to escape commas if\n            # necessary.\n            yield from next(csv.reader([x]))\n\n    for version_var in iter_fields(config.get(\"version_variable\")):\n        declaration = VersionDeclaration.from_variable(version_var)\n        declarations.append(declaration)\n    for version_pat in iter_fields(config.get(\"version_pattern\")):\n        declaration = VersionDeclaration.from_pattern(version_pat)\n        declarations.append(declaration)\n    for version_toml in iter_fields(config.get(\"version_toml\")):\n        declaration = VersionDeclaration.from_toml(version_toml)\n        declarations.append(declaration)\n\n    if not declarations:\n        raise ImproperConfigurationError(\n            \"must specify either 'version_variable', 'version_pattern' or 'version_toml'\"\n        )\n\n    return declarations", "is_method": false, "function_description": "Function that reads version declaration settings from configuration and creates corresponding VersionDeclaration objects for each specified version variable, pattern, or TOML entry, supporting flexible version management setups."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "from_toml", "line_number": 31, "body": "def from_toml(config_str: str):\n        \"\"\"\n        Instantiate a `TomlVersionDeclaration` from a string specifying a path and a key\n        matching the version number.\n        \"\"\"\n        path, key = config_str.split(\":\", 1)\n        return TomlVersionDeclaration(path, key)", "is_method": true, "class_name": "VersionDeclaration", "function_description": "Creates a TomlVersionDeclaration instance by parsing a string containing a file path and key that reference a version number in a TOML configuration."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "from_variable", "line_number": 40, "body": "def from_variable(config_str: str):\n        \"\"\"\n        Instantiate a `PatternVersionDeclaration` from a string specifying a path and a\n        variable name.\n        \"\"\"\n        path, variable = config_str.split(\":\", 1)\n        pattern = (\n            rf'{variable} *[:=] *[\"\\']{PatternVersionDeclaration.version_regex}[\"\\']'\n        )\n        return PatternVersionDeclaration(path, pattern)", "is_method": true, "class_name": "VersionDeclaration", "function_description": "Creates a PatternVersionDeclaration instance by parsing a string with a file path and variable name, constructing a pattern to match version declarations in that variable. Useful for extracting version info from code or config files."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "from_pattern", "line_number": 52, "body": "def from_pattern(config_str: str):\n        \"\"\"\n        Instantiate a `PatternVersionDeclaration` from a string specifying a path and a\n        regular expression matching the version number.\n        \"\"\"\n        path, pattern = config_str.split(\":\", 1)\n        pattern = pattern.format(version=PatternVersionDeclaration.version_regex)\n        return PatternVersionDeclaration(path, pattern)", "is_method": true, "class_name": "VersionDeclaration", "function_description": "Creates a PatternVersionDeclaration instance by parsing a string containing a file path and a version-matching regex pattern, enabling version extraction based on custom patterns."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "parse", "line_number": 62, "body": "def parse(self) -> Set[str]:\n        \"\"\"\n        Return the versions.\n\n        Because a source can match in multiple places, this method returns a\n        set of matches. Generally, there should only be one element in this\n        set (i.e. even if the version is specified in multiple places, it\n        should be the same version in each place), but it falls on the caller\n        to check for this condition.\n        \"\"\"", "is_method": true, "class_name": "VersionDeclaration", "function_description": "Returns a set of all version identifiers found by parsing the source, allowing callers to handle multiple version matches within the VersionDeclaration context."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "replace", "line_number": 74, "body": "def replace(self, new_version: str):\n        \"\"\"\n        Update the versions.\n\n        This method reads the underlying file, replaces each occurrence of the\n        matched pattern, then writes the updated file.\n\n        :param new_version: The new version number as a string\n        \"\"\"", "is_method": true, "class_name": "VersionDeclaration", "function_description": "Updates the version declarations in a file by replacing all occurrences of the matched pattern with a new version string, ensuring the file reflects the specified version."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "_read", "line_number": 90, "body": "def _read(self):\n        with open(self.path, \"r\") as f:\n            return Dotty(tomlkit.loads(f.read()))", "is_method": true, "class_name": "TomlVersionDeclaration", "function_description": "Utility method of TomlVersionDeclaration that reads and parses a TOML file from a given path, returning its contents wrapped for easy nested access and manipulation."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "parse", "line_number": 94, "body": "def parse(self) -> Set[str]:\n        config = self._read()\n        if self.key in config:\n            return {config.get(self.key)}\n        return set()", "is_method": true, "class_name": "TomlVersionDeclaration", "function_description": "Core function of TomlVersionDeclaration that reads configuration and extracts a set containing the version string associated with a specific key, facilitating version management from TOML files."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "replace", "line_number": 100, "body": "def replace(self, new_version: str):\n        config = self._read()\n        version = self.key in config\n        if version:\n            config[self.key] = new_version\n            with open(self.path, \"w\") as f:\n                f.write(tomlkit.dumps(config))", "is_method": true, "class_name": "TomlVersionDeclaration", "function_description": "Method of TomlVersionDeclaration that updates the version string in a TOML configuration file, replacing the existing version key with a new specified version. It enables automated version management directly in TOML files."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "parse", "line_number": 127, "body": "def parse(self) -> Set[str]:\n        \"\"\"\n        Return the versions matching this pattern.\n\n        Because a pattern can match in multiple places, this method returns a\n        set of matches.  Generally, there should only be one element in this\n        set (i.e. even if the version is specified in multiple places, it\n        should be the same version in each place), but it falls on the caller\n        to check for this condition.\n        \"\"\"\n        with open(self.path, \"r\") as f:\n            content = f.read()\n\n        versions = {\n            m.group(1) for m in re.finditer(self.pattern, content, re.MULTILINE)\n        }\n\n        logger.debug(\n            f\"Parsing current version: path={self.path!r} pattern={self.pattern!r} num_matches={len(versions)}\"\n        )\n        return versions", "is_method": true, "class_name": "PatternVersionDeclaration", "function_description": "Method of PatternVersionDeclaration that extracts and returns all unique version strings matching a specified pattern from the content of a given file path. Useful for identifying versions declared in various file sections."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "replace", "line_number": 149, "body": "def replace(self, new_version: str):\n        \"\"\"\n        Update the versions matching this pattern.\n\n        This method reads the underlying file, replaces each occurrence of the\n        matched pattern, then writes the updated file.\n\n        :param new_version: The new version number as a string\n        \"\"\"\n        n = 0\n        with open(self.path, \"r\") as f:\n            old_content = f.read()\n\n        def swap_version(m):\n            nonlocal n\n            n += 1\n            s = m.string\n            i, j = m.span()\n            ii, jj = m.span(1)\n            return s[i:ii] + new_version + s[jj:j]\n\n        new_content = re.sub(\n            self.pattern, swap_version, old_content, flags=re.MULTILINE\n        )\n\n        logger.debug(\n            f\"Writing new version number: path={self.path!r} pattern={self.pattern!r} num_matches={n!r}\"\n        )\n\n        with open(self.path, mode=\"w\") as f:\n            f.write(new_content)", "is_method": true, "class_name": "PatternVersionDeclaration", "function_description": "Core method of PatternVersionDeclaration that updates all occurrences of a version pattern in a file by replacing them with a new version string, ensuring the file is overwritten with the updated content."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "iter_fields", "line_number": 295, "body": "def iter_fields(x):\n        if not x:\n            return\n        if isinstance(x, list):\n            yield from x\n        else:\n            # Split by commas, but allow the user to escape commas if\n            # necessary.\n            yield from next(csv.reader([x]))", "is_method": false, "function_description": "Utility function that iterates over elements in a list or parses a comma-separated string with escape support, yielding each field for flexible input handling in data processing tasks."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/__init__.py", "function": "swap_version", "line_number": 162, "body": "def swap_version(m):\n            nonlocal n\n            n += 1\n            s = m.string\n            i, j = m.span()\n            ii, jj = m.span(1)\n            return s[i:ii] + new_version + s[jj:j]", "is_method": true, "class_name": "PatternVersionDeclaration", "function_description": "This helper function modifies a matched substring by replacing its captured version part with a new version string, tracking the number of replacements made in the surrounding context."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/parser_angular.py", "function": "parse_commit_message", "line_number": 49, "body": "def parse_commit_message(message: str) -> ParsedCommit:\n    \"\"\"\n    Parse a commit message according to the angular commit guidelines specification.\n\n    :param message: A string of a commit message.\n    :return: A tuple of (level to bump, type of change, scope of change, a tuple with descriptions)\n    :raises UnknownCommitMessageStyleError: if regular expression matching fails\n    \"\"\"\n    # Attempt to parse the commit message with a regular expression\n    parsed = re_parser.match(message)\n    if not parsed:\n        raise UnknownCommitMessageStyleError(\n            f\"Unable to parse the given commit message: {message}\"\n        )\n\n    if parsed.group(\"text\"):\n        descriptions = parse_paragraphs(parsed.group(\"text\"))\n    else:\n        descriptions = list()\n    # Insert the subject before the other paragraphs\n    descriptions.insert(0, parsed.group(\"subject\"))\n\n    # Look for descriptions of breaking changes\n    breaking_descriptions = [\n        match.group(1)\n        for match in (re_breaking.match(p) for p in descriptions[1:])\n        if match\n    ]\n\n    level_bump = 0\n    if parsed.group(\"break\") or breaking_descriptions:\n        level_bump = 3  # Major\n    elif parsed.group(\"type\") in MINOR_TYPES:\n        level_bump = 2  # Minor\n    elif parsed.group(\"type\") in PATCH_TYPES:\n        level_bump = 1  # Patch\n\n    return ParsedCommit(\n        level_bump,\n        TYPES[parsed.group(\"type\")],\n        parsed.group(\"scope\"),\n        descriptions,\n        breaking_descriptions,\n    )", "is_method": false, "function_description": "Parses a commit message following the Angular commit guidelines to extract change level, type, scope, and descriptions. It categorizes the commit for semantic versioning and changelog generation based on message content."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/parser_tag.py", "function": "parse_commit_message", "line_number": 17, "body": "def parse_commit_message(\n    message: str,\n) -> ParsedCommit:\n    \"\"\"\n    Parse a commit message according to the 1.0 version of python-semantic-release.\n\n    It expects a tag of some sort in the commit message and will use the rest of the first line\n    as changelog content.\n\n    :param message: A string of a commit message.\n    :raises UnknownCommitMessageStyleError: If it does not recognise the commit style\n    :return: A tuple of (level to bump, type of change, scope of change, a tuple with descriptions)\n    \"\"\"\n\n    # Attempt to parse the commit message with a regular expression\n    parsed = re_parser.match(message)\n    if not parsed:\n        raise UnknownCommitMessageStyleError(\n            f\"Unable to parse the given commit message: {message}\"\n        )\n\n    subject = parsed.group(\"subject\")\n\n    # Check tags for minor or patch\n    if config.get(\"minor_tag\") in message:\n        level = \"feature\"\n        level_bump = 2\n        if subject:\n            subject = subject.replace(config.get(\"minor_tag\"), \"\")\n\n    elif config.get(\"fix_tag\") in message:\n        level = \"fix\"\n        level_bump = 1\n        if subject:\n            subject = subject.replace(config.get(\"fix_tag\"), \"\")\n\n    else:\n        # We did not find any tags in the commit message\n        raise UnknownCommitMessageStyleError(\n            f\"Unable to parse the given commit message: {message}\"\n        )\n\n    if parsed.group(\"text\"):\n        descriptions = parse_paragraphs(parsed.group(\"text\"))\n    else:\n        descriptions = list()\n    descriptions.insert(0, subject.strip())\n\n    # Look for descriptions of breaking changes\n    breaking_descriptions = [\n        match.group(1)\n        for match in (re_breaking.match(p) for p in descriptions[1:])\n        if match\n    ]\n    if breaking_descriptions:\n        level = \"breaking\"\n        level_bump = 3\n\n    return ParsedCommit(level_bump, level, None, descriptions, breaking_descriptions)", "is_method": false, "function_description": "Service function that parses commit messages to determine the semantic versioning level, type of change, and descriptions for changelog generation. It supports identifying features, fixes, and breaking changes based on message tags."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/logs.py", "function": "evaluate_version_bump", "line_number": 22, "body": "def evaluate_version_bump(current_version: str, force: str = None) -> Optional[str]:\n    \"\"\"\n    Read git log since the last release to decide if we should make a major, minor or patch release.\n\n    :param current_version: A string with the current version number.\n    :param force: A string with the bump level that should be forced.\n    :return: A string with either major, minor or patch if there should be a release.\n             If no release is necessary, None will be returned.\n    \"\"\"\n    if force:\n        return force\n\n    bump = None\n\n    changes = []\n    commit_count = 0\n\n    for _hash, commit_message in get_commit_log(f\"v{current_version}\"):\n        if commit_message.startswith(current_version):\n            # Stop once we reach the current version\n            # (we are looping in the order of newest -> oldest)\n            logger.debug(\n                f'\"{commit_message}\" is commit for {current_version}, breaking loop'\n            )\n            break\n\n        commit_count += 1\n\n        # Attempt to parse this commit using the currently-configured parser\n        try:\n            message = current_commit_parser()(commit_message)\n            changes.append(message.bump)\n        except UnknownCommitMessageStyleError as err:\n            logger.debug(f\"Ignoring UnknownCommitMessageStyleError: {err}\")\n            pass\n\n    logger.debug(f\"Commits found since last release: {commit_count}\")\n\n    if changes:\n        # Select the largest required bump level from the commits we parsed\n        level = max(changes)\n        if level in LEVELS:\n            bump = LEVELS[level]\n        else:\n            logger.warning(f\"Unknown bump level {level}\")\n\n    if config.get(\"patch_without_tag\") and commit_count > 0 and bump is None:\n        bump = \"patch\"\n        logger.debug(f\"Changing bump level to patch based on config patch_without_tag\")\n\n    if (\n        not config.get(\"major_on_zero\")\n        and current_version.startswith(\"0.\")\n        and bump == \"major\"\n    ):\n        bump = \"minor\"\n        logger.debug(\"Changing bump level to minor based on config major_on_zero\")\n\n    return bump", "is_method": false, "function_description": "Determines whether to make a major, minor, or patch version release based on recent git commit messages or a forced bump level. It supports automated versioning by analyzing change types since the last release."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/history/logs.py", "function": "generate_changelog", "line_number": 84, "body": "def generate_changelog(from_version: str, to_version: str = None) -> dict:\n    \"\"\"\n    Parse a changelog dictionary for the given version.\n\n    :param from_version: The version before where the changelog starts.\n                         The changelog will be generated from the commit after this one.\n    :param to_version: The last version included in the changelog.\n    :return: A dict with changelog sections and commits\n    \"\"\"\n    # Additional sections will be added as new types are encountered\n    changes: dict = {\"breaking\": []}\n\n    rev = None\n    if from_version:\n        rev = f\"v{from_version}\"\n\n    found_the_release = to_version is None\n    for _hash, commit_message in get_commit_log(rev):\n        if not found_the_release:\n            # Skip until we find the last commit in this release\n            # (we are looping in the order of newest -> oldest)\n            if to_version and to_version not in commit_message:\n                continue\n            else:\n                logger.debug(\n                    f\"Reached the start of {to_version}, beginning changelog generation\"\n                )\n                found_the_release = True\n\n        if from_version is not None and from_version in commit_message:\n            # We reached the previous release\n            logger.debug(f\"{from_version} reached, ending changelog generation\")\n            break\n\n        try:\n            message = current_commit_parser()(commit_message)\n            if message.type not in changes:\n                logger.debug(f\"Creating new changelog section for {message.type} \")\n                changes[message.type] = list()\n\n            # Capitalize the first letter of the message, leaving others as they were\n            # (using str.capitalize() would make the other letters lowercase)\n            formatted_message = (\n                message.descriptions[0][0].upper() + message.descriptions[0][1:]\n            )\n            if config.get(\"changelog_capitalize\") is False:\n                formatted_message = message.descriptions[0]\n\n            # By default, feat(x): description shows up in changelog with the\n            # scope bolded, like:\n            #\n            # * **x**: description\n            if config.get(\"changelog_scope\") and message.scope:\n                formatted_message = f\"**{message.scope}:** {formatted_message}\"\n\n            changes[message.type].append((_hash, formatted_message))\n\n            if message.breaking_descriptions:\n                # Copy breaking change descriptions into changelog\n                for paragraph in message.breaking_descriptions:\n                    changes[\"breaking\"].append((_hash, paragraph))\n            elif message.bump == 3:\n                # Major, but no breaking descriptions, use commit subject instead\n                changes[\"breaking\"].append((_hash, message.descriptions[0]))\n\n        except UnknownCommitMessageStyleError as err:\n            logger.debug(f\"Ignoring UnknownCommitMessageStyleError: {err}\")\n\n    return changes", "is_method": false, "function_description": "Function that generates a structured changelog dictionary summarizing commits between two versions, categorizing changes by type and highlighting breaking changes for release notes."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/changelog/changelog.py", "function": "add_pr_link", "line_number": 8, "body": "def add_pr_link(owner: str, repo_name: str, message: str) -> str:\n    \"\"\"\n    GitHub release notes automagically link to the PR, but changelog markdown\n    doesn't. Replace (#123) at the end of a message with a markdown link.\n    \"\"\"\n\n    pr_pattern = re.compile(r\"\\s+\\(#(\\d{1,8})\\)$\")\n    match = re.search(pr_pattern, message)\n\n    if match:\n        pr_number = match.group(1)\n        url = (\n            f\"https://{Gitlab.domain()}/{owner}/{repo_name}/-/merge_requests/{pr_number}\"\n            if config.get(\"hvcs\") == \"gitlab\"\n            else f\"https://{Github.domain()}/{owner}/{repo_name}/issues/{pr_number}\"\n        )\n\n        return re.sub(pr_pattern, f\" ([#{pr_number}]({url}))\", message)\n\n    return message", "is_method": false, "function_description": "Function that converts trailing pull request references in release note messages into clickable markdown links, adapting URLs for GitHub or GitLab repositories. It enhances changelog readability by linking PR numbers directly to their web pages."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/changelog/changelog.py", "function": "get_changelog_sections", "line_number": 30, "body": "def get_changelog_sections(changelog: dict, changelog_sections: list) -> Iterable[str]:\n    \"\"\"Generator which yields each changelog section to be included\"\"\"\n\n    included_sections = config.get(\"changelog_sections\")\n    included_sections = [s.strip() for s in included_sections.split(\",\")]\n\n    for section in included_sections:\n        if section in changelog and changelog[section]:\n            yield section", "is_method": false, "function_description": "Function that generates the names of specified changelog sections present and non-empty in a changelog dictionary, supporting selective inclusion of changelog parts for processing or display."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/changelog/changelog.py", "function": "get_hash_link", "line_number": 41, "body": "def get_hash_link(owner: str, repo_name: str, hash_: str) -> str:\n    \"\"\"Generate the link for commit hash\"\"\"\n    url = (\n        f\"https://{Gitlab.domain()}/{owner}/{repo_name}/-/commit/{hash_}\"\n        if config.get(\"hvcs\") == \"gitlab\"\n        else f\"https://{Github.domain()}/{owner}/{repo_name}/commit/{hash_}\"\n    )\n    short_hash = hash_[:7]\n    return f\"[`{short_hash}`]({url})\"", "is_method": false, "function_description": "Function generating a markdown-formatted hyperlink to a specific commit identified by its hash in a GitLab or GitHub repository. It provides a quick reference to commit details for use in documentation or issue tracking."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/changelog/changelog.py", "function": "changelog_headers", "line_number": 52, "body": "def changelog_headers(\n    owner: str, repo_name: str, changelog: dict, changelog_sections: list, **kwargs\n) -> Optional[str]:\n    output = \"\"\n\n    for section in get_changelog_sections(changelog, changelog_sections):\n        # Add a header for this section\n        output += f\"\\n### {section.capitalize()}\\n\"\n\n        # Add each commit from the section in an unordered list\n        for item in changelog[section]:\n            message = add_pr_link(owner, repo_name, item[1])\n            output += f\"* {message} ({get_hash_link(owner, repo_name, item[0])})\\n\"\n\n    return output", "is_method": false, "function_description": "Generates formatted markdown headers with commit entries for specified changelog sections, including links to pull requests and commit hashes. Useful for creating readable, linked changelog summaries in repositories."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/changelog/changelog.py", "function": "changelog_table", "line_number": 69, "body": "def changelog_table(\n    owner: str, repo_name: str, changelog: dict, changelog_sections: list, **kwargs\n) -> str:\n    output = \"| Type | Change |\\n| --- | --- |\\n\"\n\n    for section in get_changelog_sections(changelog, changelog_sections):\n        items = \"<br>\".join(\n            [\n                f\"{add_pr_link(owner, repo_name, item[1])} \"\n                f\"({get_hash_link(owner, repo_name, item[0])})\"\n                for item in changelog[section]\n            ]\n        )\n        output += f\"| {section.title()} | {items} |\\n\"\n\n    return output", "is_method": false, "function_description": "Function that formats changelog entries into a Markdown table, organizing changes by section with links to pull requests and commit hashes for clear version tracking and release notes generation."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/changelog/__init__.py", "function": "markdown_changelog", "line_number": 13, "body": "def markdown_changelog(\n    owner: str,\n    repo_name: str,\n    version: str,\n    changelog: dict,\n    header: bool = False,\n    previous_version: str = None,\n) -> str:\n    \"\"\"\n    Generate a markdown version of the changelog.\n\n    :param owner: The repo owner.\n    :param repo_name: The repo name.\n    :param version: A string with the version number.\n    :param previous_version: A string with the last version number, to\n        use for the comparison URL. If omitted, the URL will not be included.\n    :param changelog: A parsed changelog dict from generate_changelog.\n    :param header: A boolean that decides whether a version number header should be included.\n    :return: The markdown formatted changelog.\n    \"\"\"\n    output = f\"## v{version}\\n\" if header else \"\"\n\n    # Add the output of each component separated by a blank line\n    output += \"\\n\\n\".join(\n        (\n            component_output.strip()\n            for component_output in (\n                component(\n                    owner=owner,\n                    repo_name=repo_name,\n                    version=version,\n                    previous_version=previous_version,\n                    changelog=changelog,\n                    changelog_sections=config.get(\"changelog_sections\").split(\",\"),\n                )\n                for component in current_changelog_components()\n            )\n            if component_output is not None\n        )\n    )\n\n    return output", "is_method": false, "function_description": "Utility function that compiles a parsed changelog dictionary into a formatted markdown string, optionally including a version header and comparison URLs, to produce readable changelog summaries for software repositories."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/changelog/compare.py", "function": "get_github_compare_url", "line_number": 7, "body": "def get_github_compare_url(from_version: str, to_version: str) -> str:\n    \"\"\"\n    Get the GitHub comparison link between two version tags.\n\n    :param from_version: The older version to compare.\n    :param to_version: The newer version to compare.\n    :return: Link to view a comparison between the two versions.\n    \"\"\"\n    owner, name = get_repository_owner_and_name()\n    return (\n        f\"https://github.com/{owner}/{name}\" f\"/compare/v{from_version}...v{to_version}\"\n    )", "is_method": false, "function_description": "This function generates a GitHub URL that shows the code differences between two version tags, enabling users to quickly review changes between software releases."}, {"file": "./dataset/RepoExec/test-apps/python-semantic-release/semantic_release/changelog/compare.py", "function": "compare_url", "line_number": 21, "body": "def compare_url(version: str, previous_version: str = None, **kwargs) -> Optional[str]:\n    if config.get(\"hvcs\").lower() == \"github\" and previous_version:\n        compare_url = get_github_compare_url(previous_version, version)\n        return f\"**[See all commits in this version]({compare_url})**\"\n\n    return None", "is_method": false, "function_description": "Function generates a GitHub URL to compare two version tags, providing a direct link to view all commits between them. Useful for integrating version control comparisons in release notes or changelogs."}]