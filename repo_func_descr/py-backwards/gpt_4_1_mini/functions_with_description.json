[{"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/compiler.py", "function": "_transform", "line_number": 36, "body": "def _transform(path: str, code: str, target: CompilationTarget) -> Tuple[str, List[str]]:\n    \"\"\"Applies all transformation for passed target.\"\"\"\n    debug((lambda: 'Compiling \"{}\"'.format(path)))\n    dependencies = []\n    tree = ast.parse(code, path)\n    debug((lambda: 'Initial ast:\\n{}'.format(dump(tree))))\n    for transformer in transformers:\n        if (transformer.target < target):\n            debug((lambda: 'Skip transformer \"{}\"'.format(transformer.__name__)))\n            continue\n        debug((lambda: 'Use transformer \"{}\"'.format(transformer.__name__)))\n        working_tree = deepcopy(tree)\n        try:\n            result = transformer.transform(working_tree)\n        except:\n            raise TransformationError(\n                path, transformer, dump(tree), format_exc())\n        if (not result.tree_changed):\n            debug((lambda: 'Tree not changed'))\n            continue\n        tree = working_tree\n        debug((lambda: 'Tree changed:\\n{}'.format(dump(tree))))\n        dependencies.extend(result.dependencies)\n        try:\n            code = unparse(tree)\n            debug((lambda: 'Code changed:\\n{}'.format(code)))\n        except:\n            raise TransformationError(\n                path, transformer, dump(tree), format_exc())\n    return (fix_code(code), dependencies)", "is_method": false, "function_description": "This function applies a sequence of code transformations based on a specified compilation target, returning the transformed source code along with its dependencies. It enables progressive code modification and tracking for compilation or analysis pipelines."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/compiler.py", "function": "_compile_file", "line_number": 68, "body": "def _compile_file(paths, target):\n    'Compiles a single file.'\n    with paths.input.open() as f:\n        code = f.read()\n    try:\n        (transformed, dependencies) = _transform(\n            paths.input.as_posix(), code, target)\n    except SyntaxError as e:\n        raise CompilationError(paths.input.as_posix(),\n                               code, e.lineno, e.offset)\n    try:\n        paths.output.parent.mkdir(parents=True)\n    except FileExistsError:\n        pass\n    with paths.output.open('w') as f:\n        f.write(transformed)\n    return dependencies", "is_method": false, "function_description": "Function that compiles a source file by transforming its code for a specified target, writes the transformed code to an output path, and returns its dependencies for further processing or tracking."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/compiler.py", "function": "compile_files", "line_number": 87, "body": "def compile_files(input_, output, target, root=None):\n    'Compiles all files from input_ to output.'\n    dependencies = set()\n    start = time()\n    count = 0\n    for paths in get_input_output_paths(input_, output, root):\n        count += 1\n        dependencies.update(_compile_file(paths, target))\n    return CompilationResult(count, (time() - start), target, sorted(dependencies))", "is_method": false, "function_description": "Function that compiles multiple files from a specified input source to a target output, tracking dependencies and execution time, and returning a summary of the compilation process."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/files.py", "function": "get_input_output_paths", "line_number": 12, "body": "def get_input_output_paths(input_: str, output: str,\n                           root: Optional[str]) -> Iterable[InputOutput]:\n    \"\"\"Get input/output paths pairs.\"\"\"\n    if output.endswith('.py') and not input_.endswith('.py'):\n        raise InvalidInputOutput\n\n    if not Path(input_).exists():\n        raise InputDoesntExists\n\n    if input_.endswith('.py'):\n        if output.endswith('.py'):\n            yield InputOutput(Path(input_), Path(output))\n        else:\n            input_path = Path(input_)\n            if root is None:\n                output_path = Path(output).joinpath(input_path.name)\n            else:\n                output_path = Path(output).joinpath(\n                    input_path.relative_to(root))\n            yield InputOutput(input_path, output_path)\n    else:\n        output_path = Path(output)\n        input_path = Path(input_)\n        root_path = input_path if root is None else Path(root)\n        for child_input in input_path.glob('**/*.py'):\n            child_output = output_path.joinpath(\n                child_input.relative_to(root_path))\n            yield InputOutput(child_input, child_output)", "is_method": false, "function_description": "Generates pairs of input and output file paths for Python files, validating inputs and supporting directory traversal to map source files to corresponding output locations. Useful for batch processing or transforming Python code files."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "_format_line", "line_number": 9, "body": "def _format_line(line: str, n: int, padding: int) -> str:\n    'Format single line of code.'\n    return '  {dim}{n}{reset}: {line}'.format(dim=Style.DIM, n=str((n + 1)).zfill(padding), line=line, reset=Style.RESET_ALL)", "is_method": false, "function_description": "Formats a code line with a padded line number and styling for display purposes. Useful for presenting code snippets with consistent indentation and visual clarity."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "_get_lines_with_highlighted_error", "line_number": 14, "body": "def _get_lines_with_highlighted_error(e: CompilationError) -> Iterable[str]:\n    'Format code with highlighted syntax error.'\n    error_line = (e.lineno - 1)\n    lines = e.code.split('\\n')\n    padding = len(str(len(lines)))\n    from_line = (error_line - const.SYNTAX_ERROR_OFFSET)\n    if (from_line < 0):\n        from_line = 0\n    if (from_line < error_line):\n        for n in range(from_line, error_line):\n            (yield _format_line(lines[n], n, padding))\n    (yield '  {dim}{n}{reset}: {bright}{line}{reset}'.format(dim=Style.DIM, n=str((error_line + 1)).zfill(padding), line=lines[error_line], reset=Style.RESET_ALL, bright=Style.BRIGHT))\n    (yield '  {padding}{bright}^{reset}'.format(padding=(' ' * ((padding + e.offset) + 1)), bright=Style.BRIGHT, reset=Style.RESET_ALL))\n    to_line = (error_line + const.SYNTAX_ERROR_OFFSET)\n    if (to_line > len(lines)):\n        to_line = len(lines)\n    for n in range((error_line + 1), to_line):\n        (yield _format_line(lines[n], n, padding))", "is_method": false, "function_description": "Utility function that formats and yields lines of code around a compilation error, highlighting the exact error location to assist in debugging and syntax troubleshooting."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "syntax_error", "line_number": 34, "body": "def syntax_error(e: CompilationError) -> str:\n    lines = _get_lines_with_highlighted_error(e)\n    return '{red}Syntax error in \"{e.filename}\", line {e.lineno}, pos {e.offset}:{reset}\\n{lines}'.format(red=Fore.RED, e=e, reset=Style.RESET_ALL, bright=Style.BRIGHT, lines='\\n'.join(lines))", "is_method": false, "function_description": "Function that formats and returns a detailed syntax error message highlighting the location and context of a compilation error in source code. It aids in identifying and displaying code errors for debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "transformation_error", "line_number": 39, "body": "def transformation_error(e: TransformationError) -> str:\n    return '{red}{bright}Transformation error in \"{e.filename}\", transformer \"{e.transformer.__name__}\" failed with:{reset}\\n{e.traceback}\\n{bright}AST:{reset}\\n{e.ast}'.format(red=Fore.RED, e=e, reset=Style.RESET_ALL, bright=Style.BRIGHT)", "is_method": false, "function_description": "Formats a TransformationError into a detailed, color-coded string highlighting the error context, traceback, and AST for improved debugging and error reporting in code transformation workflows."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "input_doesnt_exists", "line_number": 43, "body": "def input_doesnt_exists(input_: str) -> str:\n    return '{red}Input path \"{path}\" doesn\\'t exists{reset}'.format(red=Fore.RED, path=input_, reset=Style.RESET_ALL)", "is_method": false, "function_description": "Function generates a formatted error message indicating a given input path does not exist, providing clear, color-coded feedback for user input validation or error handling."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "invalid_output", "line_number": 47, "body": "def invalid_output(input_: str, output: str) -> str:\n    return '{red}Invalid output, when input \"{input}\" is a directory,output \"{output}\" should be a directory too{reset}'.format(red=Fore.RED, input=input_, output=output, reset=Style.RESET_ALL)", "is_method": false, "function_description": "Function that generates a formatted error message indicating that when the input is a directory, the output must also be a directory, highlighting the mismatch."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "permission_error", "line_number": 51, "body": "def permission_error(output: str) -> str:\n    return '{red}Permission denied to \"{output}\"{reset}'.format(red=Fore.RED, output=output, reset=Style.RESET_ALL)", "is_method": false, "function_description": "Utility function that formats a given string as a permission denied error message, highlighting it in red for clear output display."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "compilation_result", "line_number": 55, "body": "def compilation_result(result: CompilationResult) -> str:\n    if result.dependencies:\n        dependencies = '\\n  Additional dependencies:\\n{bright}    {dependencies}{reset}'.format(\n            dependencies='\\n    '.join((dep for dep in result.dependencies)), bright=Style.BRIGHT, reset=Style.RESET_ALL)\n    else:\n        dependencies = ''\n    return '{bright}Compilation succeed{reset}:\\n  target: {bright}{target}{reset}\\n  files: {bright}{files}{reset}\\n  took: {bright}{time:.2f}{reset} seconds{dependencies}'.format(bright=Style.BRIGHT, reset=Style.RESET_ALL, target='{}.{}'.format(*list(list(result.target))), files=result.files, time=result.time, dependencies=dependencies)", "is_method": false, "function_description": "Function that formats and returns a detailed summary string of a compilation process, including target info, involved files, duration, and optionally additional dependencies. It serves to provide a clear human-readable compilation report."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "warn", "line_number": 64, "body": "def warn(message: str) -> str:\n    return '{bright}{red}WARN:{reset} {message}'.format(bright=Style.BRIGHT, red=Fore.RED, reset=Style.RESET_ALL, message=message)", "is_method": false, "function_description": "Function that formats a warning message string with bright red coloring for emphasis, suitable for alerting users or logging warnings in terminal output."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "debug", "line_number": 68, "body": "def debug(message: str) -> str:\n    return '{bright}{blue}DEBUG:{reset} {message}'.format(bright=Style.BRIGHT, blue=Fore.BLUE, reset=Style.RESET_ALL, message=message)", "is_method": false, "function_description": "Utility function that formats a given message as a blue, bright \"DEBUG\" string for consistent debug output styling in console applications."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/conf.py", "function": "init_settings", "line_number": 34, "body": "def init_settings(args):\n    if args.debug:\n        settings.debug = True", "is_method": false, "function_description": "Initialize application settings based on provided arguments, specifically enabling debug mode if specified."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/main.py", "function": "main", "line_number": 11, "body": "def main() -> int:\n    parser = ArgumentParser(\n        'py-backwards',\n        description='Python to python compiler that allows you to use some '\n                    'Python 3.6 features in older versions.')\n    parser.add_argument('-i', '--input', type=str, nargs='+', required=True,\n                        help='input file or folder')\n    parser.add_argument('-o', '--output', type=str, required=True,\n                        help='output file or folder')\n    parser.add_argument('-t', '--target', type=str,\n                        required=True, choices=const.TARGETS.keys(),\n                        help='target python version')\n    parser.add_argument('-r', '--root', type=str, required=False,\n                        help='sources root')\n    parser.add_argument('-d', '--debug', action='store_true', required=False,\n                        help='enable debug output')\n    args = parser.parse_args()\n    init_settings(args)\n\n    try:\n        for input_ in args.input:\n            result = compile_files(input_, args.output,\n                                   const.TARGETS[args.target],\n                                   args.root)\n    except exceptions.CompilationError as e:\n        print(messages.syntax_error(e), file=sys.stderr)\n        return 1\n    except exceptions.TransformationError as e:\n        print(messages.transformation_error(e), file=sys.stderr)\n        return 1\n    except exceptions.InputDoesntExists:\n        print(messages.input_doesnt_exists(args.input), file=sys.stderr)\n        return 1\n    except exceptions.InvalidInputOutput:\n        print(messages.invalid_output(args.input, args.output),\n              file=sys.stderr)\n        return 1\n    except PermissionError:\n        print(messages.permission_error(args.output), file=sys.stderr)\n        return 1\n\n    print(messages.compilation_result(result))\n    return 0", "is_method": false, "function_description": "Main entry point that parses command-line arguments, initializes settings, compiles Python files to a specified target version, handles related errors, and returns an exit status indicating success or failure."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "find_variables", "line_number": 10, "body": "def find_variables(tree: ast.AST) -> Iterable[str]:\n    \"\"\"Finds variables and remove `let` calls.\"\"\"\n    for node in find(tree, ast.Call):\n        if isinstance(node.func, ast.Name) and node.func.id == 'let':\n            parent, index = get_non_exp_parent_and_index(tree, node)\n            parent.body.pop(index)  # type: ignore\n            yield node.args[0].id", "is_method": false, "function_description": "Function that identifies variables defined via 'let' calls in an AST, removes those calls from the code tree, and yields the variable names for further processing or analysis."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "extend_tree", "line_number": 93, "body": "def extend_tree(tree: ast.AST, variables: Dict[str, Variable]) -> None:\n    for node in find(tree, ast.Call):\n        if isinstance(node.func, ast.Name) and node.func.id == 'extend':\n            parent, index = get_non_exp_parent_and_index(tree, node)\n            # type: ignore\n            replace_at(index, parent, variables[node.args[0].id])", "is_method": false, "function_description": "Function that modifies an AST by replacing calls to 'extend' with corresponding variable nodes, enabling dynamic tree transformation based on provided variables."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "let", "line_number": 133, "body": "def let(var: Any) -> None:\n    \"\"\"Declares unique value in snippet. Code of snippet like:\n\n        let(x)\n        x += 1\n        y = 1\n\n    Will end up like:\n\n        _py_backwards_x_0 += 1\n        y = 1\n    \"\"\"", "is_method": false, "function_description": "This function marks a variable for unique renaming within a code snippet to avoid naming conflicts during transformation or code generation processes. It supports code rewriting by enabling safe variable shadowing or isolation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "_replace_field_or_node", "line_number": 28, "body": "def _replace_field_or_node(self, node: T, field: str, all_types=False) -> T:\n        value = getattr(node, field, None)\n        if value in self._variables:\n            if isinstance(self._variables[value], str):\n                setattr(node, field, self._variables[value])\n            elif all_types or isinstance(self._variables[value], type(node)):\n                node = self._variables[value]  # type: ignore\n\n        return node", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Core utility within VariablesReplacer that substitutes specified fields or nodes with corresponding variable values, supporting type-based replacements and flexible control via the all_types flag."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_Name", "line_number": 38, "body": "def visit_Name(self, node: ast.Name) -> ast.Name:\n        node = self._replace_field_or_node(node, 'id', True)\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Core utility method of the VariablesReplacer class that processes variable name nodes in an AST, replacing or modifying them according to defined rules while continuing standard AST traversal."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_FunctionDef", "line_number": 42, "body": "def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.FunctionDef:\n        node = self._replace_field_or_node(node, 'name')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Updates the function name in an AST node and continues processing its child nodes, supporting variable replacement tasks in code transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_Attribute", "line_number": 46, "body": "def visit_Attribute(self, node: ast.Attribute) -> ast.Attribute:\n        node = self._replace_field_or_node(node, 'name')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Method of VariablesReplacer that updates attribute nodes by replacing specified fields and continues traversing the AST for further transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_keyword", "line_number": 50, "body": "def visit_keyword(self, node: ast.keyword) -> ast.keyword:\n        node = self._replace_field_or_node(node, 'arg')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Method of the VariablesReplacer class that processes AST keyword nodes to replace specified fields and continues traversal. It enables targeted modification of keyword arguments in AST transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_ClassDef", "line_number": 54, "body": "def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef:\n        node = self._replace_field_or_node(node, 'name')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Method of VariablesReplacer that processes class definitions by potentially replacing the class name, then continues traversing its child nodes for further replacements or analysis."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_arg", "line_number": 58, "body": "def visit_arg(self, node: ast.arg) -> ast.arg:\n        node = self._replace_field_or_node(node, 'arg')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Method of VariablesReplacer that processes and potentially replaces variable argument names within the AST, then continues visiting child nodes for further transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "_replace_module", "line_number": 62, "body": "def _replace_module(self, module: str) -> str:\n        def _replace(name):\n            if name in self._variables:\n                if isinstance(self._variables[name], str):\n                    return self._variables[name]\n\n            return name\n\n        return '.'.join(_replace(part) for part in module.split('.'))", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Utility method of the VariablesReplacer class that substitutes variable names within a dotted module path using a predefined variables mapping, enabling dynamic and context-aware module name transformation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_ImportFrom", "line_number": 72, "body": "def visit_ImportFrom(self, node: ast.ImportFrom) -> ast.ImportFrom:\n        node.module = self._replace_module(node.module)\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Method in VariablesReplacer that modifies imported module names during AST traversal to replace variables consistently. It supports automated code transformation by updating module references in import-from statements."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_alias", "line_number": 76, "body": "def visit_alias(self, node: ast.alias) -> ast.alias:\n        node.name = self._replace_module(node.name)\n        node = self._replace_field_or_node(node, 'asname')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Method of VariablesReplacer that processes an AST alias node by replacing its module name and optional alias, supporting code transformation or refactoring tasks involving import statements."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_ExceptHandler", "line_number": 81, "body": "def visit_ExceptHandler(self, node: ast.ExceptHandler) -> ast.ExceptHandler:\n        node = self._replace_field_or_node(node, 'name')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Method in VariablesReplacer that processes exception handler nodes by replacing variable names used in except blocks, supporting consistent variable renaming within abstract syntax tree transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "replace", "line_number": 86, "body": "def replace(cls, tree: T, variables: Dict[str, Variable]) -> T:\n        \"\"\"Replaces all variables with unique names.\"\"\"\n        inst = cls(variables)\n        inst.visit(tree)\n        return tree", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Core method of VariablesReplacer that substitutes all variables in a syntax tree with unique instances based on a provided mapping, enabling consistent variable renaming or replacement in code transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "_get_variables", "line_number": 109, "body": "def _get_variables(self, tree: ast.AST,\n                       snippet_kwargs: Dict[str, Variable]) -> Dict[str, Variable]:\n        names = find_variables(tree)\n        variables = {name: VariablesGenerator.generate(name)\n                     for name in names}\n\n        for key, val in snippet_kwargs.items():\n            if isinstance(val, ast.Name):\n                variables[key] = val.id\n            else:\n                variables[key] = val  # type: ignore\n\n        return variables", "is_method": true, "class_name": "snippet", "function_description": "Helper method in snippet class that extracts variable names from an AST node and merges them with provided keyword arguments, producing a consolidated mapping of variable identifiers for code snippet processing."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "get_body", "line_number": 123, "body": "def get_body(self, **snippet_kwargs: Variable) -> List[ast.AST]:\n        \"\"\"Get AST of snippet body with replaced variables.\"\"\"\n        source = get_source(self._fn)\n        tree = ast.parse(source)\n        variables = self._get_variables(tree, snippet_kwargs)\n        extend_tree(tree, variables)\n        VariablesReplacer.replace(tree, variables)\n        return tree.body[0].body", "is_method": true, "class_name": "snippet", "function_description": "Core method of the snippet class that returns the abstract syntax tree (AST) nodes representing the function body with specified variables substituted, enabling dynamic code analysis or transformation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "_replace", "line_number": 63, "body": "def _replace(name):\n            if name in self._variables:\n                if isinstance(self._variables[name], str):\n                    return self._variables[name]\n\n            return name", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Utility method of the VariablesReplacer class that replaces a variable name with its corresponding string value if defined, otherwise returns the original name. It facilitates dynamic substitution of variables during processing."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "eager", "line_number": 12, "body": "def eager(fn: Callable[..., Iterable[T]]) -> Callable[..., List[T]]:\n    @wraps(fn)\n    def wrapped(*args: Any, **kwargs: Any) -> List[T]:\n        return list(fn(*args, **kwargs))\n\n    return wrapped", "is_method": false, "function_description": "Decorator that converts a generator function\u2019s output into a list, enabling consumers to work with fully realized sequences instead of lazy iterables. Useful for forcing eager evaluation of iterable-producing functions."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "get_source", "line_number": 32, "body": "def get_source(fn: Callable[..., Any]) -> str:\n    \"\"\"Returns source code of the function.\"\"\"\n    source_lines = getsource(fn).split('\\n')\n    padding = len(re.findall(r'^(\\s*)', source_lines[0])[0])\n    return '\\n'.join(line[padding:] for line in source_lines)", "is_method": false, "function_description": "Utility function that extracts and returns the original source code of a given Python function, preserving its internal formatting but removing leading indentation. This can be used for code analysis, display, or serialization purposes."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "warn", "line_number": 39, "body": "def warn(message: str) -> None:\n    print(messages.warn(message), file=sys.stderr)", "is_method": false, "function_description": "Function that outputs a warning message to the standard error stream, facilitating user notifications or debugging alerts."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "debug", "line_number": 43, "body": "def debug(get_message: Callable[[], str]) -> None:\n    if settings.debug:\n        print(messages.debug(get_message()), file=sys.stderr)", "is_method": false, "function_description": "Utility function that conditionally outputs a debug message to standard error based on a debug setting, supporting deferred message evaluation for efficient logging during development."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "wrapped", "line_number": 14, "body": "def wrapped(*args: Any, **kwargs: Any) -> List[T]:\n        return list(fn(*args, **kwargs))", "is_method": false, "function_description": "Converts the output of a given function into a list, ensuring the result is always a list regardless of the original iterable type returned by the function. This is useful for standardizing output formats in data processing pipelines."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "generate", "line_number": 24, "body": "def generate(cls, variable: str) -> str:\n        \"\"\"Generates unique name for variable.\"\"\"\n        try:\n            return '_py_backwards_{}_{}'.format(variable, cls._counter)\n        finally:\n            cls._counter += 1", "is_method": true, "class_name": "VariablesGenerator", "function_description": "Generates a unique variable name by appending an incrementing counter to a given base name, ensuring distinct identifiers during code generation or transformation processes."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "_build_parents", "line_number": 9, "body": "def _build_parents(tree: ast.AST) -> None:\n    for node in ast.walk(tree):\n        for child in ast.iter_child_nodes(node):\n            _parents[child] = node", "is_method": false, "function_description": "Internal helper function that annotates each AST node with its parent node, enabling upward navigation in an abstract syntax tree for further analysis or transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "get_parent", "line_number": 15, "body": "def get_parent(tree: ast.AST, node: ast.AST, rebuild: bool = False) -> ast.AST:\n    \"\"\"Get parrent of node in tree.\"\"\"\n    if node not in _parents or rebuild:\n        _build_parents(tree)\n\n    try:\n        return _parents[node]\n    except IndexError:\n        raise NodeNotFound('Parent for {} not found'.format(node))", "is_method": false, "function_description": "Utility function that returns the parent node of a specified AST node within a given syntax tree, optionally rebuilding the parent mapping to ensure accurate retrieval of node relationships."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "get_non_exp_parent_and_index", "line_number": 26, "body": "def get_non_exp_parent_and_index(tree: ast.AST, node: ast.AST) \\\n        -> Tuple[ast.AST, int]:\n    \"\"\"Get non-Exp parent and index of child.\"\"\"\n    parent = get_parent(tree, node)\n\n    while not hasattr(parent, 'body'):\n        node = parent\n        parent = get_parent(tree, parent)\n\n    return parent, parent.body.index(node)", "is_method": false, "function_description": "Utility function that identifies the closest ancestor node in an AST with a body attribute and returns that ancestor along with the position index of the specified node within it. This is useful for analyzing or modifying the structure around non-expression nodes."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "find", "line_number": 41, "body": "def find(tree: ast.AST, type_: Type[T]) -> Iterable[T]:\n    \"\"\"Finds all nodes with type T.\"\"\"\n    for node in ast.walk(tree):\n        if isinstance(node, type_):\n            yield node", "is_method": false, "function_description": "Utility function that iterates through an AST to find and yield all nodes of a specified type, enabling targeted analysis or transformation of abstract syntax trees."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "insert_at", "line_number": 48, "body": "def insert_at(index: int, parent: ast.AST,\n              nodes: Union[ast.AST, List[ast.AST]]) -> None:\n    \"\"\"Inserts nodes to parents body at index.\"\"\"\n    if not isinstance(nodes, list):\n        nodes = [nodes]\n\n    for child in nodes[::-1]:\n        parent.body.insert(index, child)", "is_method": false, "function_description": "Utility function that inserts one or multiple AST nodes into a specified position within a parent AST node's body, enabling precise modification or augmentation of abstract syntax trees."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "replace_at", "line_number": 58, "body": "def replace_at(index: int, parent: ast.AST,\n               nodes: Union[ast.AST, List[ast.AST]]) -> None:\n    \"\"\"Replaces node in parents body at index with nodes.\"\"\"\n    parent.body.pop(index)  # type: ignore\n    insert_at(index, parent, nodes)", "is_method": false, "function_description": "Utility function that replaces a node at a specified index within a parent AST node's body with one or more new AST nodes, facilitating AST modifications during code transformations or analysis."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "get_closest_parent_of", "line_number": 65, "body": "def get_closest_parent_of(tree: ast.AST, node: ast.AST,\n                          type_: Type[T]) -> T:\n    \"\"\"Get a closest parent of passed type.\"\"\"\n    parent = node\n\n    while True:\n        parent = get_parent(tree, parent)\n\n        if isinstance(parent, type_):\n            return parent", "is_method": false, "function_description": "Utility function that finds and returns the nearest ancestor node of a specified type in an AST, enabling context-aware analysis or transformations within abstract syntax trees."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "_has_starred", "line_number": 20, "body": "def _has_starred(self, xs: List[ast.expr]) -> bool:\n        for x in xs:\n            if isinstance(x, ast.Starred):\n                return True\n\n        return False", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "Checks if any expression in a list includes a starred expression (e.g., *args), allowing transformations to detect unpacking syntax within AST nodes."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "_split_by_starred", "line_number": 27, "body": "def _split_by_starred(self, xs: Iterable[ast.expr]) -> List[Splitted]:\n        \"\"\"Split `xs` to separate list by Starred.\"\"\"\n        lists = [[]]  # type: List[Splitted]\n        for x in xs:\n            if isinstance(x, ast.Starred):\n                lists.append(x)\n                lists.append([])\n            else:\n                assert isinstance(lists[-1], list)\n                lists[-1].append(x)\n        return lists", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "Utility method in StarredUnpackingTransformer that separates a list of AST expressions into sublists and starred elements, facilitating processing of starred unpacking syntax in Python code transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "_prepare_lists", "line_number": 39, "body": "def _prepare_lists(self, xs: List[Splitted]) -> Iterable[ListEntry]:\n        \"\"\"Wrap starred in list call and list elts to just List.\"\"\"\n        for x in xs:\n            if isinstance(x, ast.Starred):\n                yield ast.Call(\n                    func=ast.Name(id='list'),\n                    args=[x.value],\n                    keywords=[])\n            elif x:\n                yield ast.List(elts=x)", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "Prepares and transforms elements by wrapping starred expressions in a list call and other elements in list nodes, facilitating uniform list processing in AST transformations within the StarredUnpackingTransformer class."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "_merge_lists", "line_number": 50, "body": "def _merge_lists(self, xs: List[ListEntry]) -> Union[ast.BinOp, ListEntry]:\n        \"\"\"Merge lists by summing them.\"\"\"\n        if len(xs) == 1:\n            return xs[0]\n\n        result = ast.BinOp(left=xs[0], right=xs[1], op=ast.Add())\n        for x in xs[2:]:\n            result = ast.BinOp(left=result, right=x, op=ast.Add())\n        return result", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "Internal method of StarredUnpackingTransformer that combines multiple list-like nodes into a single addition operation, effectively merging lists by summing them in abstract syntax tree transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "_to_sum_of_lists", "line_number": 60, "body": "def _to_sum_of_lists(self, xs: List[ast.expr]) -> Union[ast.BinOp, ListEntry]:\n        \"\"\"Convert list of arguments / list to sum of lists.\"\"\"\n        splitted = self._split_by_starred(xs)\n        prepared = list(self._prepare_lists(splitted))\n        return self._merge_lists(prepared)", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "Internal utility of StarredUnpackingTransformer that converts a list of expressions into a combined representation by splitting and merging starred and non-starred elements for further AST transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "visit_List", "line_number": 66, "body": "def visit_List(self, node: ast.List) -> ast.List:\n        if not self._has_starred(node.elts):\n            return self.generic_visit(node)  # type: ignore\n\n        self._tree_changed = True\n\n        # type: ignore\n        return self.generic_visit(self._to_sum_of_lists(node.elts))", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "Core method of StarredUnpackingTransformer that processes list nodes containing starred elements, transforming them into an equivalent sum of lists representation to facilitate further AST manipulations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "visit_Call", "line_number": 75, "body": "def visit_Call(self, node: ast.Call) -> ast.Call:\n        if not self._has_starred(node.args):\n            return self.generic_visit(self.generic_visit(node))  # type: ignore\n\n        self._tree_changed = True\n\n        args = self._to_sum_of_lists(node.args)\n        node.args = [ast.Starred(value=args)]\n        return self.generic_visit(node)", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "Transforms function call nodes by consolidating starred arguments into a single starred list for simplified AST processing, enabling consistent handling of unpacked arguments during code transformation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/formatted_values.py", "function": "visit_FormattedValue", "line_number": 15, "body": "def visit_FormattedValue(self, node: ast.FormattedValue) -> ast.Call:\n        self._tree_changed = True\n\n        if node.format_spec:\n            template = ''.join(['{:', node.format_spec.s, '}'])  # type: ignore\n        else:\n            template = '{}'\n\n        format_call = ast.Call(func=ast.Attribute(value=ast.Str(s=template),\n                                                  attr='format'),\n                               args=[node.value],\n                               keywords=[])\n        return self.generic_visit(format_call)", "is_method": true, "class_name": "FormattedValuesTransformer", "function_description": "Transforms an AST FormattedValue node into an explicit string format call, enabling consistent handling of formatted string expressions during AST transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/formatted_values.py", "function": "visit_JoinedStr", "line_number": 29, "body": "def visit_JoinedStr(self, node: ast.JoinedStr) -> ast.Call:\n        self._tree_changed = True\n\n        join_call = ast.Call(func=ast.Attribute(value=ast.Str(s=''),\n                                                attr='join'),\n                             args=[ast.List(elts=node.values)],\n                             keywords=[])\n        return self.generic_visit(join_call)", "is_method": true, "class_name": "FormattedValuesTransformer", "function_description": "Transforms an f-string AST node into an equivalent string join call, facilitating manipulation or analysis of formatted string expressions in the AST."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/python2_future.py", "function": "visit_Module", "line_number": 24, "body": "def visit_Module(self, node: ast.Module) -> ast.Module:\n        self._tree_changed = True\n        node.body = imports.get_body(\n            future='__future__') + node.body  # type: ignore\n        return self.generic_visit(node)", "is_method": true, "class_name": "Python2FutureTransformer", "function_description": "Adds future imports to a Python AST module node to enable Python 2 to Python 3 code transformations, facilitating compatibility updates by modifying the syntax tree accordingly."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "_py_backwards_merge_dicts", "line_number": 10, "body": "def _py_backwards_merge_dicts(dicts):\n        result = {}\n        for dict_ in dicts:\n            result.update(dict_)\n        return result", "is_method": false, "function_description": "Private utility function that merges a sequence of dictionaries into one, with later dictionaries' keys overwriting earlier ones. Useful for combining configuration or data dictionaries in reverse order."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "_split_by_None", "line_number": 33, "body": "def _split_by_None(self, pairs: Iterable[Pair]) -> Splitted:\n        \"\"\"Splits pairs to lists separated by dict unpacking statements.\"\"\"\n        result = [[]]  # type: Splitted\n        for key, value in pairs:\n            if key is None:\n                result.append(value)\n                result.append([])\n            else:\n                assert isinstance(result[-1], list)\n                result[-1].append((key, value))\n\n        return result", "is_method": true, "class_name": "DictUnpackingTransformer", "function_description": "Core internal method of DictUnpackingTransformer that divides key-value pairs into separate lists at points where dictionary unpacking (key is None) occurs, helping to process and reorganize mixed dict unpacking statements."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "_prepare_splitted", "line_number": 46, "body": "def _prepare_splitted(self, splitted: Splitted) \\\n            -> Iterable[Union[ast.Call, ast.Dict]]:\n        \"\"\"Wraps splitted in Call or Dict.\"\"\"\n        for group in splitted:\n            if not isinstance(group, list):\n                yield ast.Call(\n                    func=ast.Name(id='dict'),\n                    args=[group],\n                    keywords=[])\n            elif group:\n                yield ast.Dict(keys=[key for key, _ in group],\n                               values=[value for _, value in group])", "is_method": true, "class_name": "DictUnpackingTransformer", "function_description": "Utility method in DictUnpackingTransformer that converts groups of key-value pairs into AST Call or Dict nodes, preparing them for further processing or transformation in abstract syntax trees."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "_merge_dicts", "line_number": 59, "body": "def _merge_dicts(self, xs: Iterable[Union[ast.Call, ast.Dict]]) \\\n            -> ast.Call:\n        \"\"\"Creates call of function for merging dicts.\"\"\"\n        return ast.Call(\n            func=ast.Name(id='_py_backwards_merge_dicts'),\n            args=[ast.List(elts=list(xs))],\n            keywords=[])", "is_method": true, "class_name": "DictUnpackingTransformer", "function_description": "Core helper of DictUnpackingTransformer that generates an AST call node representing a function call to merge multiple dictionaries. It enables transforming code involving dictionary unpacking into an explicit merge function call."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "visit_Module", "line_number": 67, "body": "def visit_Module(self, node: ast.Module) -> ast.Module:\n        insert_at(0, node, merge_dicts.get_body())  # type: ignore\n        return self.generic_visit(node)", "is_method": true, "class_name": "DictUnpackingTransformer", "function_description": "Method of DictUnpackingTransformer that inserts predefined dictionary merging code at the start of a module, preparing it for transformations involving dictionary unpacking syntax."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "visit_Dict", "line_number": 71, "body": "def visit_Dict(self, node: ast.Dict) -> Union[ast.Dict, ast.Call]:\n        if None not in node.keys:\n            return self.generic_visit(node)  # type: ignore\n\n        self._tree_changed = True\n        pairs = zip(node.keys, node.values)\n        splitted = self._split_by_None(pairs)\n        prepared = self._prepare_splitted(splitted)\n        return self._merge_dicts(prepared)", "is_method": true, "class_name": "DictUnpackingTransformer", "function_description": "Transforms dictionary AST nodes containing unpacked keys by splitting and merging them into explicit dictionary calls, facilitating code analysis or transformation involving dict unpacking syntax."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/functions_annotations.py", "function": "visit_arg", "line_number": 16, "body": "def visit_arg(self, node: ast.arg) -> ast.arg:\n        self._tree_changed = True\n        node.annotation = None\n        return self.generic_visit(node)", "is_method": true, "class_name": "FunctionsAnnotationsTransformer", "function_description": "Removes annotations from function argument nodes during AST traversal, enabling transformation or simplification of function signatures without type hints."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/functions_annotations.py", "function": "visit_FunctionDef", "line_number": 21, "body": "def visit_FunctionDef(self, node: ast.FunctionDef):\n        self._tree_changed = True\n        node.returns = None\n        return self.generic_visit(node)", "is_method": true, "class_name": "FunctionsAnnotationsTransformer", "function_description": "Removes return type annotations from function definitions in an AST node, signaling that the AST has been modified. This supports transformations that simplify or normalize function signatures."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/class_without_bases.py", "function": "visit_ClassDef", "line_number": 15, "body": "def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef:\n        if not node.bases:\n            node.bases = [ast.Name(id='object')]\n            self._tree_changed = True\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "ClassWithoutBasesTransformer", "function_description": "Core method of ClassWithoutBasesTransformer that ensures every class definition explicitly inherits from 'object' if no base classes are specified, supporting consistent class hierarchy transformation in Python AST processing."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/super_without_arguments.py", "function": "_replace_super_args", "line_number": 18, "body": "def _replace_super_args(self, node: ast.Call) -> None:\n        try:\n            func = get_closest_parent_of(self._tree, node, ast.FunctionDef)\n        except NodeNotFound:\n            warn('super() outside of function')\n            return\n\n        try:\n            cls = get_closest_parent_of(self._tree, node, ast.ClassDef)\n        except NodeNotFound:\n            warn('super() outside of class')\n            return\n\n        node.args = [ast.Name(id=cls.name), ast.Name(id=func.args.args[0].arg)]", "is_method": true, "class_name": "SuperWithoutArgumentsTransformer", "function_description": "Rewrites calls to zero-argument super() by injecting the current class and method's first argument, enabling explicit super() usage in AST transformations without relying on implicit context."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/super_without_arguments.py", "function": "visit_Call", "line_number": 33, "body": "def visit_Call(self, node: ast.Call) -> ast.Call:\n        if isinstance(node.func, ast.Name) and node.func.id == 'super' and not len(node.args):\n            self._replace_super_args(node)\n            self._tree_changed = True\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "SuperWithoutArgumentsTransformer", "function_description": "Transforms calls to parameterless super() by adding explicit arguments, ensuring compatibility or clarity in class inheritance method calls."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "transform", "line_number": 13, "body": "def transform(cls, tree: ast.AST) -> TransformationResult:\n        ...", "is_method": true, "class_name": "BaseTransformer", "function_description": "Core method of BaseTransformer that applies a transformation to an abstract syntax tree (AST) and returns the result, typically used to modify or analyze Python code programmatically."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "transform", "line_number": 26, "body": "def transform(cls, tree: ast.AST) -> TransformationResult:\n        inst = cls(tree)\n        inst.visit(tree)\n        return TransformationResult(tree, inst._tree_changed, cls.dependencies)", "is_method": true, "class_name": "BaseNodeTransformer", "function_description": "Utility method of the BaseNodeTransformer class that applies a transformation to an AST tree and returns the transformed tree along with change status and dependencies information. It facilitates AST manipulation workflows requiring transformation tracking."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_get_matched_rewrite", "line_number": 43, "body": "def _get_matched_rewrite(self, name: Optional[str]) -> Optional[Tuple[str, str]]:\n        \"\"\"Returns rewrite for module name.\"\"\"\n        if name is None:\n            return None\n\n        for from_, to in self.rewrites:\n            if name == from_ or name.startswith(from_ + '.'):\n                return from_, to\n\n        return None", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Utility method in BaseImportRewrite that finds and returns a matching module name rewrite rule, if any, based on the provided module name. It supports checking exact matches or module prefixes for import path transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_replace_import", "line_number": 54, "body": "def _replace_import(self, node: ast.Import, from_: str, to: str) -> ast.Try:\n        \"\"\"Replace import with try/except with old and new import.\"\"\"\n        self._tree_changed = True\n\n        rewrote_name = node.names[0].name.replace(from_, to, 1)\n        import_as = node.names[0].asname or node.names[0].name.split('.')[-1]\n\n        rewrote = ast.Import(names=[\n            ast.alias(name=rewrote_name,\n                      asname=import_as)])\n\n        return import_rewrite.get_body(previous=node,  # type: ignore\n                                       current=rewrote)[0]", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Utility method of BaseImportRewrite that replaces a given import statement with a try/except block attempting the original and rewritten imports, facilitating backward-compatible import rewriting."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "visit_Import", "line_number": 68, "body": "def visit_Import(self, node: ast.Import) -> Union[ast.Import, ast.Try]:\n        rewrite = self._get_matched_rewrite(node.names[0].name)\n        if rewrite:\n            return self._replace_import(node, *rewrite)\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Method of BaseImportRewrite that checks if an import statement matches a rewrite rule and replaces it accordingly; otherwise, it continues with the standard node traversal."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_replace_import_from_module", "line_number": 75, "body": "def _replace_import_from_module(self, node: ast.ImportFrom, from_: str, to: str) -> ast.Try:\n        \"\"\"Replaces import from with try/except with old and new import module.\"\"\"\n        self._tree_changed = True\n\n        rewrote_module = node.module.replace(from_, to, 1)\n        rewrote = ast.ImportFrom(module=rewrote_module,\n                                 names=node.names,\n                                 level=node.level)\n\n        return import_rewrite.get_body(previous=node,  # type: ignore\n                                       current=rewrote)[0]", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Utility method in BaseImportRewrite that transforms an import-from statement to a try/except block, attempting an import from an updated module path with fallback to the original import for compatibility handling."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_get_names_to_replace", "line_number": 87, "body": "def _get_names_to_replace(self, node: ast.ImportFrom) -> Iterable[Tuple[str, Tuple[str, str]]]:\n        \"\"\"Finds names/aliases to replace.\"\"\"\n        for alias in node.names:\n            full_name = '{}.{}'.format(node.module, alias.name)\n            if alias.name != '*':\n                rewrite = self._get_matched_rewrite(full_name)\n                if rewrite:\n                    yield (full_name, rewrite)", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Core utility method in BaseImportRewrite that identifies import names and aliases from a syntax node requiring replacement, facilitating targeted import rewriting based on matching rewrite rules."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_get_replaced_import_from_part", "line_number": 96, "body": "def _get_replaced_import_from_part(self, node: ast.ImportFrom, alias: ast.alias,\n                                       names_to_replace: Dict[str, Tuple[str, str]]) -> ast.ImportFrom:\n        \"\"\"Returns import from statement with changed module or alias.\"\"\"\n        full_name = '{}.{}'.format(node.module, alias.name)\n        if full_name in names_to_replace:\n            full_name = full_name.replace(names_to_replace[full_name][0],\n                                          names_to_replace[full_name][1],\n                                          1)\n        module_name = '.'.join(full_name.split('.')[:-1])\n        name = full_name.split('.')[-1]\n        return ast.ImportFrom(\n            module=module_name,\n            names=[ast.alias(name=name,\n                             asname=alias.asname or alias.name)],\n            level=node.level)", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Transforms an import-from statement by substituting specified module or alias names based on a replacement mapping, facilitating dynamic modification of import paths during code rewriting."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_replace_import_from_names", "line_number": 112, "body": "def _replace_import_from_names(self, node: ast.ImportFrom,\n                                   names_to_replace: Dict[str, Tuple[str, str]]) -> ast.Try:\n        \"\"\"Replaces import from with try/except with old and new \n        import module and names.\n\n        \"\"\"\n        self._tree_changed = True\n\n        rewrotes = [\n            self._get_replaced_import_from_part(node, alias, names_to_replace)\n            for alias in node.names]\n\n        return import_rewrite.get_body(previous=node,  # type: ignore\n                                       current=rewrotes)[0]", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Utility method in BaseImportRewrite that transforms specific 'from ... import ...' statements into try/except blocks to conditionally import old and new names, enabling safer or backward-compatible import rewriting."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "visit_ImportFrom", "line_number": 127, "body": "def visit_ImportFrom(self, node: ast.ImportFrom) -> Union[ast.ImportFrom, ast.Try]:\n        rewrite = self._get_matched_rewrite(node.module)\n        if rewrite:\n            return self._replace_import_from_module(node, *rewrite)\n\n        names_to_replace = dict(self._get_names_to_replace(node))\n        if names_to_replace:\n            return self._replace_import_from_names(node, names_to_replace)\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Processes an import-from AST node to rewrite its module or imported names based on predefined mappings, enabling automated modification of import statements during code transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/yield_from.py", "function": "result_assignment", "line_number": 13, "body": "def result_assignment(exc, target):\n    if hasattr(exc, 'value'):\n        target = exc.value", "is_method": false, "function_description": "Assigns the 'value' attribute of an exception to a target variable if it exists, allowing extraction of embedded exception data for further use."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/yield_from.py", "function": "_get_yield_from_index", "line_number": 34, "body": "def _get_yield_from_index(self, node: ast.AST,\n                              type_: Type[Holder]) -> Optional[int]:\n        if hasattr(node, 'body') and isinstance(node.body, list):  # type: ignore\n            for n, child in enumerate(node.body):  # type: ignore\n                if isinstance(child, type_) and isinstance(child.value, ast.YieldFrom):\n                    return n\n\n        return None", "is_method": true, "class_name": "YieldFromTransformer", "function_description": "Internal method of YieldFromTransformer that locates the index of a specific child node containing a 'yield from' expression within a given AST node\u2019s body, facilitating targeted AST transformations involving 'yield from'."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/yield_from.py", "function": "_emulate_yield_from", "line_number": 43, "body": "def _emulate_yield_from(self, target: Optional[ast.AST],\n                            node: ast.YieldFrom) -> List[ast.AST]:\n        exc = VariablesGenerator.generate('exc')\n        if target is not None:\n            assignment = result_assignment.get_body(exc=exc, target=target)\n        else:\n            assignment = []\n\n        return yield_from.get_body(generator=node.value,\n                                   assignment=assignment,\n                                   exc=exc)", "is_method": true, "class_name": "YieldFromTransformer", "function_description": "Core utility of YieldFromTransformer that converts a yield-from AST node into an equivalent sequence of AST statements, optionally assigning results to a target and managing exceptions for code transformation purposes."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/yield_from.py", "function": "_handle_assignments", "line_number": 55, "body": "def _handle_assignments(self, node: Node) -> Node:\n        while True:\n            index = self._get_yield_from_index(node, ast.Assign)\n            if index is None:\n                return node\n\n            assign = node.body.pop(index)\n            yield_from_ast = self._emulate_yield_from(assign.targets[0],  # type: ignore\n                                                      assign.value)  # type: ignore\n            insert_at(index, node, yield_from_ast)\n            self._tree_changed = True", "is_method": true, "class_name": "YieldFromTransformer", "function_description": "Core method of YieldFromTransformer that processes assignment statements involving 'yield from' expressions, transforming them to enable proper handling or emulation of generator delegation within the node's body."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/yield_from.py", "function": "_handle_expressions", "line_number": 67, "body": "def _handle_expressions(self, node: Node) -> Node:\n        while True:\n            index = self._get_yield_from_index(node, ast.Expr)\n            if index is None:\n                return node\n\n            exp = node.body.pop(index)\n            yield_from_ast = self._emulate_yield_from(\n                None, exp.value)  # type: ignore\n            insert_at(index, node, yield_from_ast)\n            self._tree_changed = True", "is_method": true, "class_name": "YieldFromTransformer", "function_description": "Internal method of YieldFromTransformer that processes expression nodes within an AST, transforming any yield-from constructs to ensure compatibility during AST manipulation or code transformation tasks."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/yield_from.py", "function": "visit", "line_number": 79, "body": "def visit(self, node: ast.AST) -> ast.AST:\n        node = self._handle_assignments(node)  # type: ignore\n        node = self._handle_expressions(node)  # type: ignore\n        return self.generic_visit(node)", "is_method": true, "class_name": "YieldFromTransformer", "function_description": "Core method of YieldFromTransformer that processes an AST node by handling assignments and expressions, then continues recursive traversal to transform the abstract syntax tree."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/variables_annotations.py", "function": "transform", "line_number": 20, "body": "def transform(cls, tree: ast.AST) -> TransformationResult:\n        tree_changed = False\n\n        for node in find(tree, ast.AnnAssign):\n            try:\n                parent, index = get_non_exp_parent_and_index(tree, node)\n            except NodeNotFound:\n                warn('Assignment outside of body')\n                continue\n\n            tree_changed = True\n            parent.body.pop(index)  # type: ignore\n\n            if node.value is not None:\n                insert_at(index, parent,\n                          ast.Assign(targets=[node.target],  # type: ignore\n                                     value=node.value,\n                                     type_comment=node.annotation))\n\n        return TransformationResult(tree, tree_changed, [])", "is_method": true, "class_name": "VariablesAnnotationsTransformer", "function_description": "Transforms annotated variable assignments in the AST into standard assignments with type comments, facilitating compatibility with Python versions or tools that do not support variable annotations directly."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/string_types.py", "function": "transform", "line_number": 14, "body": "def transform(cls, tree: ast.AST) -> TransformationResult:\n        tree_changed = False\n\n        for node in find(tree, ast.Name):\n            if node.id == 'str':\n                node.id = 'unicode'\n                tree_changed = True\n\n        return TransformationResult(tree, tree_changed, [])", "is_method": true, "class_name": "StringTypesTransformer", "function_description": "Transforms Python AST nodes by replacing all occurrences of the identifier 'str' with 'unicode', enabling compatibility with codebases or tools that distinguish these types differently."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/six_moves.py", "function": "_get_rewrites", "line_number": 210, "body": "def _get_rewrites():\n    for prefix, moves in prefixed_moves:\n        for move in moves:\n            if isinstance(move, MovedAttribute):\n                path = '{}.{}'.format(move.new_mod, move.new_attr)\n                yield (path, 'six.moves{}.{}'.format(prefix, move.name))\n            elif isinstance(move, MovedModule):\n                yield (move.new, 'six.moves{}.{}'.format(prefix, move.name))", "is_method": false, "function_description": "Returns an iterator of module and attribute renaming paths for code compatibility, mapping new locations to legacy references. Useful for managing Python 2 and 3 compatibility via the six.moves module."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/return_from_generator.py", "function": "return_from_generator", "line_number": 8, "body": "def return_from_generator(return_value):\n    let(exc)\n    exc = StopIteration()\n    exc.value = return_value\n    raise exc", "is_method": false, "function_description": "Raises a StopIteration exception with a given return value to signal generator completion and pass the value back to the caller. This function enables returning a value from within a generator context."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/return_from_generator.py", "function": "_find_generator_returns", "line_number": 29, "body": "def _find_generator_returns(self, node: ast.FunctionDef) \\\n            -> List[Tuple[ast.stmt, ast.Return]]:\n        \"\"\"Using bfs find all `return` statements in function.\"\"\"\n        to_check = [(node, x) for x in node.body]  # type: ignore\n        returns = []\n        has_yield = False\n        while to_check:\n            parent, current = to_check.pop()\n\n            if isinstance(current, ast.FunctionDef):\n                continue\n            elif hasattr(current, 'value'):\n                to_check.append((current, current.value))  # type: ignore\n            elif hasattr(current, 'body') and isinstance(current.body, list):  # type: ignore\n                to_check.extend([(parent, x)\n                                for x in current.body])  # type: ignore\n\n            if isinstance(current, ast.Yield) or isinstance(current, ast.YieldFrom):\n                has_yield = True\n\n            if isinstance(current, ast.Return) and current.value is not None:\n                returns.append((parent, current))\n\n        if has_yield:\n            return returns  # type: ignore\n        else:\n            return []", "is_method": true, "class_name": "ReturnFromGeneratorTransformer", "function_description": "Utility method of ReturnFromGeneratorTransformer that locates all non-empty return statements within a function node if the function contains any yield expressions, supporting analysis of generator functions' return behaviors."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/return_from_generator.py", "function": "_replace_return", "line_number": 57, "body": "def _replace_return(self, parent: Any, return_: ast.Return) -> None:\n        \"\"\"Replace return with exception raising.\"\"\"\n        index = parent.body.index(return_)\n        parent.body.pop(index)\n\n        for line in return_from_generator.get_body(return_value=return_.value)[::-1]:\n            parent.body.insert(index, line)", "is_method": true, "class_name": "ReturnFromGeneratorTransformer", "function_description": "Internal helper of ReturnFromGeneratorTransformer that replaces a return statement with equivalent code that raises an exception, enabling transformation of generator returns into a compatible control flow."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/return_from_generator.py", "function": "visit_FunctionDef", "line_number": 65, "body": "def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.FunctionDef:\n        generator_returns = self._find_generator_returns(node)\n\n        if generator_returns:\n            self._tree_changed = True\n\n        for parent, return_ in generator_returns:\n            self._replace_return(parent, return_)\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "ReturnFromGeneratorTransformer", "function_description": "Processes a function AST node to identify and replace generator return statements, enabling transformation of generator-based functions within the ReturnFromGeneratorTransformer class."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/metaclass.py", "function": "visit_Module", "line_number": 28, "body": "def visit_Module(self, node: ast.Module) -> ast.Module:\n        insert_at(0, node, six_import.get_body())\n        return self.generic_visit(node)", "is_method": true, "class_name": "MetaclassTransformer", "function_description": "Adds import statements from a predefined source at the beginning of a Python module's AST, then continues processing the module tree. This supports automated modification or augmentation of Python code during AST transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/metaclass.py", "function": "visit_ClassDef", "line_number": 32, "body": "def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef:\n        if node.keywords:\n            metaclass = node.keywords[0].value\n            node.bases = class_bases.get_body(metaclass=metaclass,  # type: ignore\n                                              bases=ast.List(elts=node.bases))\n            node.keywords = []\n            self._tree_changed = True\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "MetaclassTransformer", "function_description": "Transforms a class definition by replacing its base classes based on a specified metaclass, enabling dynamic adjustment of class inheritance during AST processing."}]