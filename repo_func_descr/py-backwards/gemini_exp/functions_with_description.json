[{"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/compiler.py", "function": "_transform", "line_number": 36, "body": "def _transform(path: str, code: str, target: CompilationTarget) -> Tuple[str, List[str]]:\n    \"\"\"Applies all transformation for passed target.\"\"\"\n    debug((lambda: 'Compiling \"{}\"'.format(path)))\n    dependencies = []\n    tree = ast.parse(code, path)\n    debug((lambda: 'Initial ast:\\n{}'.format(dump(tree))))\n    for transformer in transformers:\n        if (transformer.target < target):\n            debug((lambda: 'Skip transformer \"{}\"'.format(transformer.__name__)))\n            continue\n        debug((lambda: 'Use transformer \"{}\"'.format(transformer.__name__)))\n        working_tree = deepcopy(tree)\n        try:\n            result = transformer.transform(working_tree)\n        except:\n            raise TransformationError(\n                path, transformer, dump(tree), format_exc())\n        if (not result.tree_changed):\n            debug((lambda: 'Tree not changed'))\n            continue\n        tree = working_tree\n        debug((lambda: 'Tree changed:\\n{}'.format(dump(tree))))\n        dependencies.extend(result.dependencies)\n        try:\n            code = unparse(tree)\n            debug((lambda: 'Code changed:\\n{}'.format(code)))\n        except:\n            raise TransformationError(\n                path, transformer, dump(tree), format_exc())\n    return (fix_code(code), dependencies)", "is_method": false, "function_description": "Orchestrates a series of Abstract Syntax Tree (AST) transformations on Python source code. It prepares the code for a specific compilation target and collects any introduced dependencies."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/compiler.py", "function": "_compile_file", "line_number": 68, "body": "def _compile_file(paths, target):\n    'Compiles a single file.'\n    with paths.input.open() as f:\n        code = f.read()\n    try:\n        (transformed, dependencies) = _transform(\n            paths.input.as_posix(), code, target)\n    except SyntaxError as e:\n        raise CompilationError(paths.input.as_posix(),\n                               code, e.lineno, e.offset)\n    try:\n        paths.output.parent.mkdir(parents=True)\n    except FileExistsError:\n        pass\n    with paths.output.open('w') as f:\n        f.write(transformed)\n    return dependencies", "is_method": false, "function_description": "Compiles a single source file by reading its content, applying a transformation, and writing the processed code to an output file. It also returns any dependencies discovered during compilation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/compiler.py", "function": "compile_files", "line_number": 87, "body": "def compile_files(input_, output, target, root=None):\n    'Compiles all files from input_ to output.'\n    dependencies = set()\n    start = time()\n    count = 0\n    for paths in get_input_output_paths(input_, output, root):\n        count += 1\n        dependencies.update(_compile_file(paths, target))\n    return CompilationResult(count, (time() - start), target, sorted(dependencies))", "is_method": false, "function_description": "Compiles all specified files from an input location to an output target, providing a summary of the compilation process including dependencies and execution time."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/files.py", "function": "get_input_output_paths", "line_number": 12, "body": "def get_input_output_paths(input_: str, output: str,\n                           root: Optional[str]) -> Iterable[InputOutput]:\n    \"\"\"Get input/output paths pairs.\"\"\"\n    if output.endswith('.py') and not input_.endswith('.py'):\n        raise InvalidInputOutput\n\n    if not Path(input_).exists():\n        raise InputDoesntExists\n\n    if input_.endswith('.py'):\n        if output.endswith('.py'):\n            yield InputOutput(Path(input_), Path(output))\n        else:\n            input_path = Path(input_)\n            if root is None:\n                output_path = Path(output).joinpath(input_path.name)\n            else:\n                output_path = Path(output).joinpath(\n                    input_path.relative_to(root))\n            yield InputOutput(input_path, output_path)\n    else:\n        output_path = Path(output)\n        input_path = Path(input_)\n        root_path = input_path if root is None else Path(root)\n        for child_input in input_path.glob('**/*.py'):\n            child_output = output_path.joinpath(\n                child_input.relative_to(root_path))\n            yield InputOutput(child_input, child_output)", "is_method": false, "function_description": "Generates pairs of input and output file paths for Python files, handling single files or recursively processing directories while preserving their relative structure."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "_format_line", "line_number": 9, "body": "def _format_line(line: str, n: int, padding: int) -> str:\n    'Format single line of code.'\n    return '  {dim}{n}{reset}: {line}'.format(dim=Style.DIM, n=str((n + 1)).zfill(padding), line=line, reset=Style.RESET_ALL)", "is_method": false, "function_description": "Formats a single line of code for display by prepending a zero-padded line number with styling. This function is typically used for presenting code snippets or error messages.\nFormats a single line of code for display by prepending a zero-padded line number with styling. This function is typically used for presenting code snippets or error messages."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "_get_lines_with_highlighted_error", "line_number": 14, "body": "def _get_lines_with_highlighted_error(e: CompilationError) -> Iterable[str]:\n    'Format code with highlighted syntax error.'\n    error_line = (e.lineno - 1)\n    lines = e.code.split('\\n')\n    padding = len(str(len(lines)))\n    from_line = (error_line - const.SYNTAX_ERROR_OFFSET)\n    if (from_line < 0):\n        from_line = 0\n    if (from_line < error_line):\n        for n in range(from_line, error_line):\n            (yield _format_line(lines[n], n, padding))\n    (yield '  {dim}{n}{reset}: {bright}{line}{reset}'.format(dim=Style.DIM, n=str((error_line + 1)).zfill(padding), line=lines[error_line], reset=Style.RESET_ALL, bright=Style.BRIGHT))\n    (yield '  {padding}{bright}^{reset}'.format(padding=(' ' * ((padding + e.offset) + 1)), bright=Style.BRIGHT, reset=Style.RESET_ALL))\n    to_line = (error_line + const.SYNTAX_ERROR_OFFSET)\n    if (to_line > len(lines)):\n        to_line = len(lines)\n    for n in range((error_line + 1), to_line):\n        (yield _format_line(lines[n], n, padding))", "is_method": false, "function_description": "Formats a segment of code for display, highlighting a compilation error line and indicating its precise location for improved readability."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "syntax_error", "line_number": 34, "body": "def syntax_error(e: CompilationError) -> str:\n    lines = _get_lines_with_highlighted_error(e)\n    return '{red}Syntax error in \"{e.filename}\", line {e.lineno}, pos {e.offset}:{reset}\\n{lines}'.format(red=Fore.RED, e=e, reset=Style.RESET_ALL, bright=Style.BRIGHT, lines='\\n'.join(lines))", "is_method": false, "function_description": "Formats a `CompilationError` into a human-readable, color-coded string, providing clear information about the syntax error's location and context for user feedback.\nFormats a `CompilationError` into a human-readable, color-coded string, providing clear information about the syntax error's location and context for user feedback."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "transformation_error", "line_number": 39, "body": "def transformation_error(e: TransformationError) -> str:\n    return '{red}{bright}Transformation error in \"{e.filename}\", transformer \"{e.transformer.__name__}\" failed with:{reset}\\n{e.traceback}\\n{bright}AST:{reset}\\n{e.ast}'.format(red=Fore.RED, e=e, reset=Style.RESET_ALL, bright=Style.BRIGHT)", "is_method": false, "function_description": "Formats a `TransformationError` into a detailed, human-readable string for console output. It includes filename, transformer, traceback, and AST for debugging failed code transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "input_doesnt_exists", "line_number": 43, "body": "def input_doesnt_exists(input_: str) -> str:\n    return '{red}Input path \"{path}\" doesn\\'t exists{reset}'.format(red=Fore.RED, path=input_, reset=Style.RESET_ALL)", "is_method": false, "function_description": "Generates a color-coded error message indicating that a specified input path does not exist, useful for standardizing user feedback."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "invalid_output", "line_number": 47, "body": "def invalid_output(input_: str, output: str) -> str:\n    return '{red}Invalid output, when input \"{input}\" is a directory,output \"{output}\" should be a directory too{reset}'.format(red=Fore.RED, input=input_, output=output, reset=Style.RESET_ALL)", "is_method": false, "function_description": "Generates a color-coded error message string for a specific validation failure. It indicates that an output path must be a directory if the input path is one."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "permission_error", "line_number": 51, "body": "def permission_error(output: str) -> str:\n    return '{red}Permission denied to \"{output}\"{reset}'.format(red=Fore.RED, output=output, reset=Style.RESET_ALL)", "is_method": false, "function_description": "Generates a console-ready, red-colored error message indicating a permission denial for a specified resource or operation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "compilation_result", "line_number": 55, "body": "def compilation_result(result: CompilationResult) -> str:\n    if result.dependencies:\n        dependencies = '\\n  Additional dependencies:\\n{bright}    {dependencies}{reset}'.format(\n            dependencies='\\n    '.join((dep for dep in result.dependencies)), bright=Style.BRIGHT, reset=Style.RESET_ALL)\n    else:\n        dependencies = ''\n    return '{bright}Compilation succeed{reset}:\\n  target: {bright}{target}{reset}\\n  files: {bright}{files}{reset}\\n  took: {bright}{time:.2f}{reset} seconds{dependencies}'.format(bright=Style.BRIGHT, reset=Style.RESET_ALL, target='{}.{}'.format(*list(list(result.target))), files=result.files, time=result.time, dependencies=dependencies)", "is_method": false, "function_description": "Provides a formatted, human-readable string summarizing the details of a successful code compilation. It includes the target, compiled files, time taken, and any additional dependencies."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "warn", "line_number": 64, "body": "def warn(message: str) -> str:\n    return '{bright}{red}WARN:{reset} {message}'.format(bright=Style.BRIGHT, red=Fore.RED, reset=Style.RESET_ALL, message=message)", "is_method": false, "function_description": "Formats a given message as a brightly colored, red warning string for console output. This function is useful for clearly highlighting warnings in logs or the terminal."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/messages.py", "function": "debug", "line_number": 68, "body": "def debug(message: str) -> str:\n    return '{bright}{blue}DEBUG:{reset} {message}'.format(bright=Style.BRIGHT, blue=Fore.BLUE, reset=Style.RESET_ALL, message=message)", "is_method": false, "function_description": "Generates a colored and styled debug message string from a given input, useful for clear console logging or display."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/conf.py", "function": "init_settings", "line_number": 34, "body": "def init_settings(args):\n    if args.debug:\n        settings.debug = True", "is_method": false, "function_description": "Enables debug mode for the application if specified by the provided arguments."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/main.py", "function": "main", "line_number": 11, "body": "def main() -> int:\n    parser = ArgumentParser(\n        'py-backwards',\n        description='Python to python compiler that allows you to use some '\n                    'Python 3.6 features in older versions.')\n    parser.add_argument('-i', '--input', type=str, nargs='+', required=True,\n                        help='input file or folder')\n    parser.add_argument('-o', '--output', type=str, required=True,\n                        help='output file or folder')\n    parser.add_argument('-t', '--target', type=str,\n                        required=True, choices=const.TARGETS.keys(),\n                        help='target python version')\n    parser.add_argument('-r', '--root', type=str, required=False,\n                        help='sources root')\n    parser.add_argument('-d', '--debug', action='store_true', required=False,\n                        help='enable debug output')\n    args = parser.parse_args()\n    init_settings(args)\n\n    try:\n        for input_ in args.input:\n            result = compile_files(input_, args.output,\n                                   const.TARGETS[args.target],\n                                   args.root)\n    except exceptions.CompilationError as e:\n        print(messages.syntax_error(e), file=sys.stderr)\n        return 1\n    except exceptions.TransformationError as e:\n        print(messages.transformation_error(e), file=sys.stderr)\n        return 1\n    except exceptions.InputDoesntExists:\n        print(messages.input_doesnt_exists(args.input), file=sys.stderr)\n        return 1\n    except exceptions.InvalidInputOutput:\n        print(messages.invalid_output(args.input, args.output),\n              file=sys.stderr)\n        return 1\n    except PermissionError:\n        print(messages.permission_error(args.output), file=sys.stderr)\n        return 1\n\n    print(messages.compilation_result(result))\n    return 0", "is_method": false, "function_description": "This function serves as the main entry point for the `py-backwards` compiler. It parses command-line arguments to orchestrate the compilation of Python code to older versions, managing errors."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "find_variables", "line_number": 10, "body": "def find_variables(tree: ast.AST) -> Iterable[str]:\n    \"\"\"Finds variables and remove `let` calls.\"\"\"\n    for node in find(tree, ast.Call):\n        if isinstance(node.func, ast.Name) and node.func.id == 'let':\n            parent, index = get_non_exp_parent_and_index(tree, node)\n            parent.body.pop(index)  # type: ignore\n            yield node.args[0].id", "is_method": false, "function_description": "This function processes an Abstract Syntax Tree (AST) to identify and remove specific \"let\" function calls. It extracts and returns the variable names defined within these removed calls, effectively transforming the tree."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "extend_tree", "line_number": 93, "body": "def extend_tree(tree: ast.AST, variables: Dict[str, Variable]) -> None:\n    for node in find(tree, ast.Call):\n        if isinstance(node.func, ast.Name) and node.func.id == 'extend':\n            parent, index = get_non_exp_parent_and_index(tree, node)\n            # type: ignore\n            replace_at(index, parent, variables[node.args[0].id])", "is_method": false, "function_description": "This function transforms an abstract syntax tree by replacing all 'extend' function calls with their corresponding values from a given variable mapping."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "let", "line_number": 133, "body": "def let(var: Any) -> None:\n    \"\"\"Declares unique value in snippet. Code of snippet like:\n\n        let(x)\n        x += 1\n        y = 1\n\n    Will end up like:\n\n        _py_backwards_x_0 += 1\n        y = 1\n    \"\"\"", "is_method": false, "function_description": "Marks a variable for unique internal renaming within a code snippet. This ensures the variable gets a distinct identifier (e.g., `_py_backwards_x_0`) to prevent name collisions or for specific code transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "extend", "line_number": 147, "body": "def extend(var: Any) -> None:\n    \"\"\"Extends code, so code like:\n\n        extend(vars)\n        print(x, y)\n\n    When vars contains AST of assignments will end up:\n\n        x = 1\n        x = 2\n        print(x, y)\n    \"\"\"", "is_method": false, "function_description": "Inserts dynamic variable assignments from a given input into the current scope. This allows subsequent code to access programmatically defined variables."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "_replace_field_or_node", "line_number": 28, "body": "def _replace_field_or_node(self, node: T, field: str, all_types=False) -> T:\n        value = getattr(node, field, None)\n        if value in self._variables:\n            if isinstance(self._variables[value], str):\n                setattr(node, field, self._variables[value])\n            elif all_types or isinstance(self._variables[value], type(node)):\n                node = self._variables[value]  # type: ignore\n\n        return node", "is_method": true, "class_name": "VariablesReplacer", "function_description": "As a private helper for `VariablesReplacer`, this method conditionally replaces a node's field value or the entire node with a predefined variable. It facilitates dynamic substitution within data structures."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_Name", "line_number": 38, "body": "def visit_Name(self, node: ast.Name) -> ast.Name:\n        node = self._replace_field_or_node(node, 'id', True)\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "This method visits `ast.Name` nodes in an AST to replace their identifiers (names). It facilitates the renaming of variables or other named entities during code transformation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_FunctionDef", "line_number": 42, "body": "def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.FunctionDef:\n        node = self._replace_field_or_node(node, 'name')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "This method, part of an AST transformer, replaces the name of a function definition node. It then proceeds to visit the function's internal structure."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_Attribute", "line_number": 46, "body": "def visit_Attribute(self, node: ast.Attribute) -> ast.Attribute:\n        node = self._replace_field_or_node(node, 'name')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Modifies `ast.Attribute` nodes by replacing their attribute names. This enables renaming or substituting variable attributes during an AST transformation process."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_keyword", "line_number": 50, "body": "def visit_keyword(self, node: ast.keyword) -> ast.keyword:\n        node = self._replace_field_or_node(node, 'arg')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Provides the capability to transform `ast.keyword` nodes during AST traversal. It replaces variables found in the keyword's `arg` field, then recursively visits other nodes."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_ClassDef", "line_number": 54, "body": "def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef:\n        node = self._replace_field_or_node(node, 'name')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Modifies an Abstract Syntax Tree by replacing the name of a class definition node. It facilitates programmatic renaming of classes within the AST."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_arg", "line_number": 58, "body": "def visit_arg(self, node: ast.arg) -> ast.arg:\n        node = self._replace_field_or_node(node, 'arg')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Processes an AST argument node, applying variable replacement to its name field. It ensures argument names conform to specified transformations during AST traversal."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "_replace_module", "line_number": 62, "body": "def _replace_module(self, module: str) -> str:\n        def _replace(name):\n            if name in self._variables:\n                if isinstance(self._variables[name], str):\n                    return self._variables[name]\n\n            return name\n\n        return '.'.join(_replace(part) for part in module.split('.'))", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Replaces components of a module path string with corresponding string values found within the class's internal variables. This allows dynamic resolution of module names."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_ImportFrom", "line_number": 72, "body": "def visit_ImportFrom(self, node: ast.ImportFrom) -> ast.ImportFrom:\n        node.module = self._replace_module(node.module)\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "This AST visitor method modifies the source module name in `from ... import ...` statements. It enables renaming or redirecting module imports during code transformation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_alias", "line_number": 76, "body": "def visit_alias(self, node: ast.alias) -> ast.alias:\n        node.name = self._replace_module(node.name)\n        node = self._replace_field_or_node(node, 'asname')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Updates an AST alias node, replacing both the imported module's original name and its 'as' name. It ensures consistent variable referencing within import statements."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "visit_ExceptHandler", "line_number": 81, "body": "def visit_ExceptHandler(self, node: ast.ExceptHandler) -> ast.ExceptHandler:\n        node = self._replace_field_or_node(node, 'name')\n        return self.generic_visit(node)", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Within the `VariablesReplacer` class, this method processes `except` blocks in an Abstract Syntax Tree. It specifically replaces or modifies the name of the caught exception variable."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "replace", "line_number": 86, "body": "def replace(cls, tree: T, variables: Dict[str, Variable]) -> T:\n        \"\"\"Replaces all variables with unique names.\"\"\"\n        inst = cls(variables)\n        inst.visit(tree)\n        return tree", "is_method": true, "class_name": "VariablesReplacer", "function_description": "This class method replaces all variables within a given tree structure with unique names. It ensures naming consistency for further processing."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "_get_variables", "line_number": 109, "body": "def _get_variables(self, tree: ast.AST,\n                       snippet_kwargs: Dict[str, Variable]) -> Dict[str, Variable]:\n        names = find_variables(tree)\n        variables = {name: VariablesGenerator.generate(name)\n                     for name in names}\n\n        for key, val in snippet_kwargs.items():\n            if isinstance(val, ast.Name):\n                variables[key] = val.id\n            else:\n                variables[key] = val  # type: ignore\n\n        return variables", "is_method": true, "class_name": "snippet", "function_description": "An internal method that gathers variable names from an AST and maps them to generated `Variable` objects. It incorporates explicit variable assignments from given keyword arguments for code snippet processing."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "get_body", "line_number": 123, "body": "def get_body(self, **snippet_kwargs: Variable) -> List[ast.AST]:\n        \"\"\"Get AST of snippet body with replaced variables.\"\"\"\n        source = get_source(self._fn)\n        tree = ast.parse(source)\n        variables = self._get_variables(tree, snippet_kwargs)\n        extend_tree(tree, variables)\n        VariablesReplacer.replace(tree, variables)\n        return tree.body[0].body", "is_method": true, "class_name": "snippet", "function_description": "Retrieves the Abstract Syntax Tree (AST) body of a code snippet. It processes the snippet by identifying and replacing variables within its AST structure."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/snippet.py", "function": "_replace", "line_number": 63, "body": "def _replace(name):\n            if name in self._variables:\n                if isinstance(self._variables[name], str):\n                    return self._variables[name]\n\n            return name", "is_method": true, "class_name": "VariablesReplacer", "function_description": "Substitutes a given name with its string value if found in the internal variables dictionary. Otherwise, the original name is returned, facilitating variable replacement."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "eager", "line_number": 12, "body": "def eager(fn: Callable[..., Iterable[T]]) -> Callable[..., List[T]]:\n    @wraps(fn)\n    def wrapped(*args: Any, **kwargs: Any) -> List[T]:\n        return list(fn(*args, **kwargs))\n\n    return wrapped", "is_method": false, "function_description": "This decorator transforms a function that returns an iterable into one that returns a materialized list. It ensures all iterable elements are eagerly computed and collected immediately into a list."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "get_source", "line_number": 32, "body": "def get_source(fn: Callable[..., Any]) -> str:\n    \"\"\"Returns source code of the function.\"\"\"\n    source_lines = getsource(fn).split('\\n')\n    padding = len(re.findall(r'^(\\s*)', source_lines[0])[0])\n    return '\\n'.join(line[padding:] for line in source_lines)", "is_method": false, "function_description": "Provides the complete, un-indented source code string for any given Python function. Useful for introspection, debugging, or dynamic analysis."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "warn", "line_number": 39, "body": "def warn(message: str) -> None:\n    print(messages.warn(message), file=sys.stderr)", "is_method": false, "function_description": "Prints a formatted warning message to the standard error stream. It provides immediate feedback for non-critical issues during program execution."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "debug", "line_number": 43, "body": "def debug(get_message: Callable[[], str]) -> None:\n    if settings.debug:\n        print(messages.debug(get_message()), file=sys.stderr)", "is_method": false, "function_description": "Provides a utility to conditionally print debug messages to standard error. Message generation is deferred until debugging is enabled, optimizing performance."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "wrapped", "line_number": 14, "body": "def wrapped(*args: Any, **kwargs: Any) -> List[T]:\n        return list(fn(*args, **kwargs))", "is_method": false, "function_description": "This function wraps a callable `fn`, executing it with the given arguments and ensuring its return value is always converted into a list. It provides a standardized list output for any wrapped function."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/helpers.py", "function": "generate", "line_number": 24, "body": "def generate(cls, variable: str) -> str:\n        \"\"\"Generates unique name for variable.\"\"\"\n        try:\n            return '_py_backwards_{}_{}'.format(variable, cls._counter)\n        finally:\n            cls._counter += 1", "is_method": true, "class_name": "VariablesGenerator", "function_description": "Generates a unique, non-conflicting name for a given variable string. This capability is useful for avoiding naming clashes in dynamic code generation or transformation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "_build_parents", "line_number": 9, "body": "def _build_parents(tree: ast.AST) -> None:\n    for node in ast.walk(tree):\n        for child in ast.iter_child_nodes(node):\n            _parents[child] = node", "is_method": false, "function_description": "Populates an external dictionary, mapping each node in an Abstract Syntax Tree (AST) to its parent node. This facilitates upward traversal and contextual analysis of the AST structure."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "get_parent", "line_number": 15, "body": "def get_parent(tree: ast.AST, node: ast.AST, rebuild: bool = False) -> ast.AST:\n    \"\"\"Get parrent of node in tree.\"\"\"\n    if node not in _parents or rebuild:\n        _build_parents(tree)\n\n    try:\n        return _parents[node]\n    except IndexError:\n        raise NodeNotFound('Parent for {} not found'.format(node))", "is_method": false, "function_description": "Retrieves the parent node of a given AST node within an Abstract Syntax Tree. This function is essential for navigating ASTs to understand code structure and relationships."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "get_non_exp_parent_and_index", "line_number": 26, "body": "def get_non_exp_parent_and_index(tree: ast.AST, node: ast.AST) \\\n        -> Tuple[ast.AST, int]:\n    \"\"\"Get non-Exp parent and index of child.\"\"\"\n    parent = get_parent(tree, node)\n\n    while not hasattr(parent, 'body'):\n        node = parent\n        parent = get_parent(tree, parent)\n\n    return parent, parent.body.index(node)", "is_method": false, "function_description": "Identifies the nearest ancestor node that functions as a statement container (e.g., function, class, or module). It returns this container and the child node's index within its statement body."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "find", "line_number": 41, "body": "def find(tree: ast.AST, type_: Type[T]) -> Iterable[T]:\n    \"\"\"Finds all nodes with type T.\"\"\"\n    for node in ast.walk(tree):\n        if isinstance(node, type_):\n            yield node", "is_method": false, "function_description": "Traverses a Python Abstract Syntax Tree (AST) to discover and yield all nodes matching a specific type. It's used for static code analysis."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "insert_at", "line_number": 48, "body": "def insert_at(index: int, parent: ast.AST,\n              nodes: Union[ast.AST, List[ast.AST]]) -> None:\n    \"\"\"Inserts nodes to parents body at index.\"\"\"\n    if not isinstance(nodes, list):\n        nodes = [nodes]\n\n    for child in nodes[::-1]:\n        parent.body.insert(index, child)", "is_method": false, "function_description": "Inserts one or more Abstract Syntax Tree (AST) nodes into the body of a parent AST node at a specified index. This enables programmatic modification of Python code structures."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "replace_at", "line_number": 58, "body": "def replace_at(index: int, parent: ast.AST,\n               nodes: Union[ast.AST, List[ast.AST]]) -> None:\n    \"\"\"Replaces node in parents body at index with nodes.\"\"\"\n    parent.body.pop(index)  # type: ignore\n    insert_at(index, parent, nodes)", "is_method": false, "function_description": "Replaces a specific Abstract Syntax Tree (AST) node at an index within a parent's body with new AST nodes, enabling programmatic code transformation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/utils/tree.py", "function": "get_closest_parent_of", "line_number": 65, "body": "def get_closest_parent_of(tree: ast.AST, node: ast.AST,\n                          type_: Type[T]) -> T:\n    \"\"\"Get a closest parent of passed type.\"\"\"\n    parent = node\n\n    while True:\n        parent = get_parent(tree, parent)\n\n        if isinstance(parent, type_):\n            return parent", "is_method": false, "function_description": "This function finds the closest ancestor of a given AST node that matches a specified type. It is useful for navigating Abstract Syntax Trees to understand hierarchical relationships."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "_has_starred", "line_number": 20, "body": "def _has_starred(self, xs: List[ast.expr]) -> bool:\n        for x in xs:\n            if isinstance(x, ast.Starred):\n                return True\n\n        return False", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "Checks if a list of AST expressions contains any starred unpacking expression (e.g., `*args`). It identifies if a collection requires special handling for starred items."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "_split_by_starred", "line_number": 27, "body": "def _split_by_starred(self, xs: Iterable[ast.expr]) -> List[Splitted]:\n        \"\"\"Split `xs` to separate list by Starred.\"\"\"\n        lists = [[]]  # type: List[Splitted]\n        for x in xs:\n            if isinstance(x, ast.Starred):\n                lists.append(x)\n                lists.append([])\n            else:\n                assert isinstance(lists[-1], list)\n                lists[-1].append(x)\n        return lists", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "Splits a sequence of abstract syntax tree expressions into sub-lists, using `ast.Starred` nodes as separators. It includes the `Starred` nodes themselves within the resulting structure for processing."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "_prepare_lists", "line_number": 39, "body": "def _prepare_lists(self, xs: List[Splitted]) -> Iterable[ListEntry]:\n        \"\"\"Wrap starred in list call and list elts to just List.\"\"\"\n        for x in xs:\n            if isinstance(x, ast.Starred):\n                yield ast.Call(\n                    func=ast.Name(id='list'),\n                    args=[x.value],\n                    keywords=[])\n            elif x:\n                yield ast.List(elts=x)", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "This helper method standardizes AST representations of starred expressions and sequence elements. It converts starred unpacking into explicit list calls and other elements into list nodes for further processing."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "_merge_lists", "line_number": 50, "body": "def _merge_lists(self, xs: List[ListEntry]) -> Union[ast.BinOp, ListEntry]:\n        \"\"\"Merge lists by summing them.\"\"\"\n        if len(xs) == 1:\n            return xs[0]\n\n        result = ast.BinOp(left=xs[0], right=xs[1], op=ast.Add())\n        for x in xs[2:]:\n            result = ast.BinOp(left=result, right=x, op=ast.Add())\n        return result", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "Transforms a list of Abstract Syntax Tree (AST) expressions into a single AST binary operation node that represents their summation. Facilitates code transformations involving sequence concatenation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "_to_sum_of_lists", "line_number": 60, "body": "def _to_sum_of_lists(self, xs: List[ast.expr]) -> Union[ast.BinOp, ListEntry]:\n        \"\"\"Convert list of arguments / list to sum of lists.\"\"\"\n        splitted = self._split_by_starred(xs)\n        prepared = list(self._prepare_lists(splitted))\n        return self._merge_lists(prepared)", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "Transforms an AST list of expressions, potentially with starred unpacking, into a normalized representation as a concatenation of simpler lists. This aids subsequent AST processing."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "visit_List", "line_number": 66, "body": "def visit_List(self, node: ast.List) -> ast.List:\n        if not self._has_starred(node.elts):\n            return self.generic_visit(node)  # type: ignore\n\n        self._tree_changed = True\n\n        # type: ignore\n        return self.generic_visit(self._to_sum_of_lists(node.elts))", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "As part of the `StarredUnpackingTransformer`, this method transforms AST list nodes containing starred unpacking into an equivalent structure for explicit list concatenation. It desugars the starred expressions to simplify the AST."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/starred_unpacking.py", "function": "visit_Call", "line_number": 75, "body": "def visit_Call(self, node: ast.Call) -> ast.Call:\n        if not self._has_starred(node.args):\n            return self.generic_visit(self.generic_visit(node))  # type: ignore\n\n        self._tree_changed = True\n\n        args = self._to_sum_of_lists(node.args)\n        node.args = [ast.Starred(value=args)]\n        return self.generic_visit(node)", "is_method": true, "class_name": "StarredUnpackingTransformer", "function_description": "This method transforms `ast.Call` nodes containing starred arguments. It consolidates all function call arguments, including unpacked ones, into a single starred expression within the Abstract Syntax Tree."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/formatted_values.py", "function": "visit_FormattedValue", "line_number": 15, "body": "def visit_FormattedValue(self, node: ast.FormattedValue) -> ast.Call:\n        self._tree_changed = True\n\n        if node.format_spec:\n            template = ''.join(['{:', node.format_spec.s, '}'])  # type: ignore\n        else:\n            template = '{}'\n\n        format_call = ast.Call(func=ast.Attribute(value=ast.Str(s=template),\n                                                  attr='format'),\n                               args=[node.value],\n                               keywords=[])\n        return self.generic_visit(format_call)", "is_method": true, "class_name": "FormattedValuesTransformer", "function_description": "Transforms an f-string's formatted value into an equivalent `str.format()` method call in the AST. This de-sugars f-string components for compatibility or analysis."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/formatted_values.py", "function": "visit_JoinedStr", "line_number": 29, "body": "def visit_JoinedStr(self, node: ast.JoinedStr) -> ast.Call:\n        self._tree_changed = True\n\n        join_call = ast.Call(func=ast.Attribute(value=ast.Str(s=''),\n                                                attr='join'),\n                             args=[ast.List(elts=node.values)],\n                             keywords=[])\n        return self.generic_visit(join_call)", "is_method": true, "class_name": "FormattedValuesTransformer", "function_description": "Rewrites f-string (ast.JoinedStr) nodes into equivalent `\"\".join()` call structures in the Abstract Syntax Tree. This serves to normalize f-string syntax for code analysis or transpilation purposes."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/python2_future.py", "function": "imports", "line_number": 7, "body": "def imports(future):\n    from future import absolute_import\n    from future import division\n    from future import print_function\n    from future import unicode_literals", "is_method": false, "function_description": "This function imports key `__future__` statements to enable Python 3-like behaviors and syntax, such as absolute imports and print as a function. It helps ensure code compatibility across Python 2 and 3 environments."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/python2_future.py", "function": "visit_Module", "line_number": 24, "body": "def visit_Module(self, node: ast.Module) -> ast.Module:\n        self._tree_changed = True\n        node.body = imports.get_body(\n            future='__future__') + node.body  # type: ignore\n        return self.generic_visit(node)", "is_method": true, "class_name": "Python2FutureTransformer", "function_description": "Prepends `__future__` import statements to a Python module's AST. This service enables automatic transformation of Python 2 code to behave like Python 3."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "_py_backwards_merge_dicts", "line_number": 10, "body": "def _py_backwards_merge_dicts(dicts):\n        result = {}\n        for dict_ in dicts:\n            result.update(dict_)\n        return result", "is_method": false, "function_description": "Merges multiple dictionaries from an iterable into a single dictionary, with later dictionaries overwriting values for duplicate keys."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "_split_by_None", "line_number": 33, "body": "def _split_by_None(self, pairs: Iterable[Pair]) -> Splitted:\n        \"\"\"Splits pairs to lists separated by dict unpacking statements.\"\"\"\n        result = [[]]  # type: Splitted\n        for key, value in pairs:\n            if key is None:\n                result.append(value)\n                result.append([])\n            else:\n                assert isinstance(result[-1], list)\n                result[-1].append((key, value))\n\n        return result", "is_method": true, "class_name": "DictUnpackingTransformer", "function_description": "Segments an iterable of key-value pairs, using `None` keys to delineate and extract dictionary unpacking statements. It prepares data for transformation processes that handle Python's dictionary unpacking syntax."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "_prepare_splitted", "line_number": 46, "body": "def _prepare_splitted(self, splitted: Splitted) \\\n            -> Iterable[Union[ast.Call, ast.Dict]]:\n        \"\"\"Wraps splitted in Call or Dict.\"\"\"\n        for group in splitted:\n            if not isinstance(group, list):\n                yield ast.Call(\n                    func=ast.Name(id='dict'),\n                    args=[group],\n                    keywords=[])\n            elif group:\n                yield ast.Dict(keys=[key for key, _ in group],\n                               values=[value for _, value in group])", "is_method": true, "class_name": "DictUnpackingTransformer", "function_description": "This method transforms structured input data into an iterable of Abstract Syntax Tree (AST) nodes, representing either dictionary literals or dictionary constructor calls. It prepares data for subsequent AST transformations related to dictionary unpacking."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "_merge_dicts", "line_number": 59, "body": "def _merge_dicts(self, xs: Iterable[Union[ast.Call, ast.Dict]]) \\\n            -> ast.Call:\n        \"\"\"Creates call of function for merging dicts.\"\"\"\n        return ast.Call(\n            func=ast.Name(id='_py_backwards_merge_dicts'),\n            args=[ast.List(elts=list(xs))],\n            keywords=[])", "is_method": true, "class_name": "DictUnpackingTransformer", "function_description": "This method generates an Abstract Syntax Tree (AST) node. This node represents a function call to programmatically merge multiple dictionary expressions during code transformation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "visit_Module", "line_number": 67, "body": "def visit_Module(self, node: ast.Module) -> ast.Module:\n        insert_at(0, node, merge_dicts.get_body())  # type: ignore\n        return self.generic_visit(node)", "is_method": true, "class_name": "DictUnpackingTransformer", "function_description": "This method modifies a Python module's Abstract Syntax Tree. It injects a helper function for dictionary merging at the module's beginning to support subsequent transformations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/dict_unpacking.py", "function": "visit_Dict", "line_number": 71, "body": "def visit_Dict(self, node: ast.Dict) -> Union[ast.Dict, ast.Call]:\n        if None not in node.keys:\n            return self.generic_visit(node)  # type: ignore\n\n        self._tree_changed = True\n        pairs = zip(node.keys, node.values)\n        splitted = self._split_by_None(pairs)\n        prepared = self._prepare_splitted(splitted)\n        return self._merge_dicts(prepared)", "is_method": true, "class_name": "DictUnpackingTransformer", "function_description": "Transforms AST dictionary nodes containing unpacking syntax (`**kwargs`) into an equivalent, rewritten dictionary expression. This enables compatibility or normalization of dictionary creation patterns."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/functions_annotations.py", "function": "visit_arg", "line_number": 16, "body": "def visit_arg(self, node: ast.arg) -> ast.arg:\n        self._tree_changed = True\n        node.annotation = None\n        return self.generic_visit(node)", "is_method": true, "class_name": "FunctionsAnnotationsTransformer", "function_description": "Strips type annotations from function arguments during Abstract Syntax Tree transformation, effectively removing them from the code."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/functions_annotations.py", "function": "visit_FunctionDef", "line_number": 21, "body": "def visit_FunctionDef(self, node: ast.FunctionDef):\n        self._tree_changed = True\n        node.returns = None\n        return self.generic_visit(node)", "is_method": true, "class_name": "FunctionsAnnotationsTransformer", "function_description": "This method, part of an AST transformer, removes the return type annotation from a function definition. It provides a way to programmatically strip specific type hints from Python code."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/class_without_bases.py", "function": "visit_ClassDef", "line_number": 15, "body": "def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef:\n        if not node.bases:\n            node.bases = [ast.Name(id='object')]\n            self._tree_changed = True\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "ClassWithoutBasesTransformer", "function_description": "This method ensures all class definitions within an Abstract Syntax Tree explicitly inherit from `object` when no base classes are specified, standardizing class inheritance."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/super_without_arguments.py", "function": "_replace_super_args", "line_number": 18, "body": "def _replace_super_args(self, node: ast.Call) -> None:\n        try:\n            func = get_closest_parent_of(self._tree, node, ast.FunctionDef)\n        except NodeNotFound:\n            warn('super() outside of function')\n            return\n\n        try:\n            cls = get_closest_parent_of(self._tree, node, ast.ClassDef)\n        except NodeNotFound:\n            warn('super() outside of class')\n            return\n\n        node.args = [ast.Name(id=cls.name), ast.Name(id=func.args.args[0].arg)]", "is_method": true, "class_name": "SuperWithoutArgumentsTransformer", "function_description": "Transforms an AST `super()` call node by explicitly adding the containing class and instance arguments. This makes implicit `super()` calls explicit for AST processing."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/super_without_arguments.py", "function": "visit_Call", "line_number": 33, "body": "def visit_Call(self, node: ast.Call) -> ast.Call:\n        if isinstance(node.func, ast.Name) and node.func.id == 'super' and not len(node.args):\n            self._replace_super_args(node)\n            self._tree_changed = True\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "SuperWithoutArgumentsTransformer", "function_description": "Identifies and transforms `super()` calls made without arguments in the abstract syntax tree. It explicitly adds the required class and instance parameters."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "import_rewrite", "line_number": 33, "body": "def import_rewrite(previous, current):\n    try:\n        extend(previous)\n    except ImportError:\n        extend(current)", "is_method": false, "function_description": "This function attempts to load a module or resource from a preferred source. If an import error occurs, it falls back to loading from an alternative source, ensuring robust module resolution."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "transform", "line_number": 26, "body": "def transform(cls, tree: ast.AST) -> TransformationResult:\n        inst = cls(tree)\n        inst.visit(tree)\n        return TransformationResult(tree, inst._tree_changed, cls.dependencies)", "is_method": true, "class_name": "BaseNodeTransformer", "function_description": "This class method applies a specific AST transformation to a given abstract syntax tree. It returns the potentially modified tree along with information about changes made during the process."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_get_matched_rewrite", "line_number": 43, "body": "def _get_matched_rewrite(self, name: Optional[str]) -> Optional[Tuple[str, str]]:\n        \"\"\"Returns rewrite for module name.\"\"\"\n        if name is None:\n            return None\n\n        for from_, to in self.rewrites:\n            if name == from_ or name.startswith(from_ + '.'):\n                return from_, to\n\n        return None", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Retrieves the configured import rewrite rule (original, target) for a given module name. It identifies rules for both direct modules and their submodules."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_replace_import", "line_number": 54, "body": "def _replace_import(self, node: ast.Import, from_: str, to: str) -> ast.Try:\n        \"\"\"Replace import with try/except with old and new import.\"\"\"\n        self._tree_changed = True\n\n        rewrote_name = node.names[0].name.replace(from_, to, 1)\n        import_as = node.names[0].asname or node.names[0].name.split('.')[-1]\n\n        rewrote = ast.Import(names=[\n            ast.alias(name=rewrote_name,\n                      asname=import_as)])\n\n        return import_rewrite.get_body(previous=node,  # type: ignore\n                                       current=rewrote)[0]", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Transforms an import statement in the Abstract Syntax Tree into a try-except block. This block attempts to import a rewritten module, falling back to the original for backward compatibility."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "visit_Import", "line_number": 68, "body": "def visit_Import(self, node: ast.Import) -> Union[ast.Import, ast.Try]:\n        rewrite = self._get_matched_rewrite(node.names[0].name)\n        if rewrite:\n            return self._replace_import(node, *rewrite)\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Intercepts and rewrites `import` statements in an Abstract Syntax Tree. It replaces specific imports with alternative module paths if a defined rewrite rule applies."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_replace_import_from_module", "line_number": 75, "body": "def _replace_import_from_module(self, node: ast.ImportFrom, from_: str, to: str) -> ast.Try:\n        \"\"\"Replaces import from with try/except with old and new import module.\"\"\"\n        self._tree_changed = True\n\n        rewrote_module = node.module.replace(from_, to, 1)\n        rewrote = ast.ImportFrom(module=rewrote_module,\n                                 names=node.names,\n                                 level=node.level)\n\n        return import_rewrite.get_body(previous=node,  # type: ignore\n                                       current=rewrote)[0]", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Rewrites a Python `import from` statement, replacing the original module path with a new one. It creates a `try/except` block for graceful fallback during module migrations."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_get_names_to_replace", "line_number": 87, "body": "def _get_names_to_replace(self, node: ast.ImportFrom) -> Iterable[Tuple[str, Tuple[str, str]]]:\n        \"\"\"Finds names/aliases to replace.\"\"\"\n        for alias in node.names:\n            full_name = '{}.{}'.format(node.module, alias.name)\n            if alias.name != '*':\n                rewrite = self._get_matched_rewrite(full_name)\n                if rewrite:\n                    yield (full_name, rewrite)", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Identifies specific module-aliased names within an `import from` statement that are marked for replacement. It yields the original name and its corresponding rewrite rule."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_get_replaced_import_from_part", "line_number": 96, "body": "def _get_replaced_import_from_part(self, node: ast.ImportFrom, alias: ast.alias,\n                                       names_to_replace: Dict[str, Tuple[str, str]]) -> ast.ImportFrom:\n        \"\"\"Returns import from statement with changed module or alias.\"\"\"\n        full_name = '{}.{}'.format(node.module, alias.name)\n        if full_name in names_to_replace:\n            full_name = full_name.replace(names_to_replace[full_name][0],\n                                          names_to_replace[full_name][1],\n                                          1)\n        module_name = '.'.join(full_name.split('.')[:-1])\n        name = full_name.split('.')[-1]\n        return ast.ImportFrom(\n            module=module_name,\n            names=[ast.alias(name=name,\n                             asname=alias.asname or alias.name)],\n            level=node.level)", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Transforms an AST `ImportFrom` node by replacing specified module path or alias segments. It enables programmatic rewriting of Python `from ... import` statements for refactoring or code manipulation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "_replace_import_from_names", "line_number": 112, "body": "def _replace_import_from_names(self, node: ast.ImportFrom,\n                                   names_to_replace: Dict[str, Tuple[str, str]]) -> ast.Try:\n        \"\"\"Replaces import from with try/except with old and new \n        import module and names.\n\n        \"\"\"\n        self._tree_changed = True\n\n        rewrotes = [\n            self._get_replaced_import_from_part(node, alias, names_to_replace)\n            for alias in node.names]\n\n        return import_rewrite.get_body(previous=node,  # type: ignore\n                                       current=rewrotes)[0]", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Provides a core utility for `BaseImportRewrite` to transform `import from` statements. It replaces them with a try/except block, enabling graceful transitions between old and new module or name conventions."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/base.py", "function": "visit_ImportFrom", "line_number": 127, "body": "def visit_ImportFrom(self, node: ast.ImportFrom) -> Union[ast.ImportFrom, ast.Try]:\n        rewrite = self._get_matched_rewrite(node.module)\n        if rewrite:\n            return self._replace_import_from_module(node, *rewrite)\n\n        names_to_replace = dict(self._get_names_to_replace(node))\n        if names_to_replace:\n            return self._replace_import_from_names(node, names_to_replace)\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "BaseImportRewrite", "function_description": "Modifies `from ... import ...` statements in an AST. It rewrites the imported module or specific names based on predefined rules, enabling dynamic import adjustments."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/yield_from.py", "function": "_get_yield_from_index", "line_number": 34, "body": "def _get_yield_from_index(self, node: ast.AST,\n                              type_: Type[Holder]) -> Optional[int]:\n        if hasattr(node, 'body') and isinstance(node.body, list):  # type: ignore\n            for n, child in enumerate(node.body):  # type: ignore\n                if isinstance(child, type_) and isinstance(child.value, ast.YieldFrom):\n                    return n\n\n        return None", "is_method": true, "class_name": "YieldFromTransformer", "function_description": "Finds the index of the first child node of a specified type that contains a `yield from` expression. This internal method assists AST transformers in locating such constructs."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/yield_from.py", "function": "_emulate_yield_from", "line_number": 43, "body": "def _emulate_yield_from(self, target: Optional[ast.AST],\n                            node: ast.YieldFrom) -> List[ast.AST]:\n        exc = VariablesGenerator.generate('exc')\n        if target is not None:\n            assignment = result_assignment.get_body(exc=exc, target=target)\n        else:\n            assignment = []\n\n        return yield_from.get_body(generator=node.value,\n                                   assignment=assignment,\n                                   exc=exc)", "is_method": true, "class_name": "YieldFromTransformer", "function_description": "Provides AST-level emulation of Python's `yield from` statement. It transforms the `yield from` node into a sequence of simpler operations, handling result assignment if present."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/yield_from.py", "function": "_handle_assignments", "line_number": 55, "body": "def _handle_assignments(self, node: Node) -> Node:\n        while True:\n            index = self._get_yield_from_index(node, ast.Assign)\n            if index is None:\n                return node\n\n            assign = node.body.pop(index)\n            yield_from_ast = self._emulate_yield_from(assign.targets[0],  # type: ignore\n                                                      assign.value)  # type: ignore\n            insert_at(index, node, yield_from_ast)\n            self._tree_changed = True", "is_method": true, "class_name": "YieldFromTransformer", "function_description": "Within the AST, this method iteratively finds and replaces assignment nodes. It transforms them into an equivalent `yield from` structure, refactoring the code."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/yield_from.py", "function": "_handle_expressions", "line_number": 67, "body": "def _handle_expressions(self, node: Node) -> Node:\n        while True:\n            index = self._get_yield_from_index(node, ast.Expr)\n            if index is None:\n                return node\n\n            exp = node.body.pop(index)\n            yield_from_ast = self._emulate_yield_from(\n                None, exp.value)  # type: ignore\n            insert_at(index, node, yield_from_ast)\n            self._tree_changed = True", "is_method": true, "class_name": "YieldFromTransformer", "function_description": "As part of a `YieldFromTransformer`, this method iteratively identifies and replaces `yield from` expressions within an AST node with an emulated equivalent. It ensures compatibility by transforming modern syntax."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/yield_from.py", "function": "visit", "line_number": 79, "body": "def visit(self, node: ast.AST) -> ast.AST:\n        node = self._handle_assignments(node)  # type: ignore\n        node = self._handle_expressions(node)  # type: ignore\n        return self.generic_visit(node)", "is_method": true, "class_name": "YieldFromTransformer", "function_description": "Core method of an AST transformer that processes assignment and expression nodes, likely for `yield from` syntax. It then continues the standard AST traversal."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/variables_annotations.py", "function": "transform", "line_number": 20, "body": "def transform(cls, tree: ast.AST) -> TransformationResult:\n        tree_changed = False\n\n        for node in find(tree, ast.AnnAssign):\n            try:\n                parent, index = get_non_exp_parent_and_index(tree, node)\n            except NodeNotFound:\n                warn('Assignment outside of body')\n                continue\n\n            tree_changed = True\n            parent.body.pop(index)  # type: ignore\n\n            if node.value is not None:\n                insert_at(index, parent,\n                          ast.Assign(targets=[node.target],  # type: ignore\n                                     value=node.value,\n                                     type_comment=node.annotation))\n\n        return TransformationResult(tree, tree_changed, [])", "is_method": true, "class_name": "VariablesAnnotationsTransformer", "function_description": "Removes type annotations from variable assignments within an AST by converting `ast.AnnAssign` nodes into standard `ast.Assign` nodes. This transforms code by stripping explicit type hints."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/string_types.py", "function": "transform", "line_number": 14, "body": "def transform(cls, tree: ast.AST) -> TransformationResult:\n        tree_changed = False\n\n        for node in find(tree, ast.Name):\n            if node.id == 'str':\n                node.id = 'unicode'\n                tree_changed = True\n\n        return TransformationResult(tree, tree_changed, [])", "is_method": true, "class_name": "StringTypesTransformer", "function_description": "Transforms an Abstract Syntax Tree (AST) by replacing all instances of the 'str' type identifier with 'unicode'. This is useful for adapting codebases to specific string type conventions."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/six_moves.py", "function": "_get_rewrites", "line_number": 210, "body": "def _get_rewrites():\n    for prefix, moves in prefixed_moves:\n        for move in moves:\n            if isinstance(move, MovedAttribute):\n                path = '{}.{}'.format(move.new_mod, move.new_attr)\n                yield (path, 'six.moves{}.{}'.format(prefix, move.name))\n            elif isinstance(move, MovedModule):\n                yield (move.new, 'six.moves{}.{}'.format(prefix, move.name))", "is_method": false, "function_description": "This generator function provides a mapping of original Python module and attribute paths to their `six.moves` compatibility equivalents. It facilitates rewriting code for Python 2/3 compatibility."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/return_from_generator.py", "function": "_find_generator_returns", "line_number": 29, "body": "def _find_generator_returns(self, node: ast.FunctionDef) \\\n            -> List[Tuple[ast.stmt, ast.Return]]:\n        \"\"\"Using bfs find all `return` statements in function.\"\"\"\n        to_check = [(node, x) for x in node.body]  # type: ignore\n        returns = []\n        has_yield = False\n        while to_check:\n            parent, current = to_check.pop()\n\n            if isinstance(current, ast.FunctionDef):\n                continue\n            elif hasattr(current, 'value'):\n                to_check.append((current, current.value))  # type: ignore\n            elif hasattr(current, 'body') and isinstance(current.body, list):  # type: ignore\n                to_check.extend([(parent, x)\n                                for x in current.body])  # type: ignore\n\n            if isinstance(current, ast.Yield) or isinstance(current, ast.YieldFrom):\n                has_yield = True\n\n            if isinstance(current, ast.Return) and current.value is not None:\n                returns.append((parent, current))\n\n        if has_yield:\n            return returns  # type: ignore\n        else:\n            return []", "is_method": true, "class_name": "ReturnFromGeneratorTransformer", "function_description": "Locates `return` statements with values inside a given AST function node. This helper method specifically targets generator functions, identifying explicit return values for transformation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/return_from_generator.py", "function": "_replace_return", "line_number": 57, "body": "def _replace_return(self, parent: Any, return_: ast.Return) -> None:\n        \"\"\"Replace return with exception raising.\"\"\"\n        index = parent.body.index(return_)\n        parent.body.pop(index)\n\n        for line in return_from_generator.get_body(return_value=return_.value)[::-1]:\n            parent.body.insert(index, line)", "is_method": true, "class_name": "ReturnFromGeneratorTransformer", "function_description": "This `ReturnFromGeneratorTransformer` method modifies the Abstract Syntax Tree. It replaces a return statement with equivalent code that raises an exception, enabling specific generator control flow."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/return_from_generator.py", "function": "visit_FunctionDef", "line_number": 65, "body": "def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.FunctionDef:\n        generator_returns = self._find_generator_returns(node)\n\n        if generator_returns:\n            self._tree_changed = True\n\n        for parent, return_ in generator_returns:\n            self._replace_return(parent, return_)\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "ReturnFromGeneratorTransformer", "function_description": "Transforms a function's Abstract Syntax Tree by replacing `return` statements found within generator contexts. This ensures correct generator semantics, making the function suitable for code transformation tools."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/metaclass.py", "function": "class_bases", "line_number": 13, "body": "def class_bases(metaclass, bases):\n    _py_backwards_six_withmetaclass(metaclass, *bases)", "is_method": false, "function_description": "Provides a compatibility layer for defining classes with metaclasses. It wraps an internal helper function to ensure cross-version Python class creation."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/metaclass.py", "function": "visit_Module", "line_number": 28, "body": "def visit_Module(self, node: ast.Module) -> ast.Module:\n        insert_at(0, node, six_import.get_body())\n        return self.generic_visit(node)", "is_method": true, "class_name": "MetaclassTransformer", "function_description": "This `MetaclassTransformer` method modifies a Python module's abstract syntax tree. It inserts compatibility imports (likely `six`) at the module's beginning, ensuring broader Python version compatibility."}, {"file": "./dataset/RepoExec/test-apps/py-backwards/py_backwards/transformers/metaclass.py", "function": "visit_ClassDef", "line_number": 32, "body": "def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef:\n        if node.keywords:\n            metaclass = node.keywords[0].value\n            node.bases = class_bases.get_body(metaclass=metaclass,  # type: ignore\n                                              bases=ast.List(elts=node.bases))\n            node.keywords = []\n            self._tree_changed = True\n\n        return self.generic_visit(node)", "is_method": true, "class_name": "MetaclassTransformer", "function_description": "Transforms class definitions in an AST by modifying their base classes. It dynamically updates inheritance based on the class's specified metaclass."}]