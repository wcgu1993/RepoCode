[{"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/watch-previews/app/main.py", "function": "get_message", "line_number": 39, "body": "def get_message(commit: str) -> str:\n    return f\"Docs preview for commit {commit} at\"", "is_method": false, "function_description": "This function generates a formatted preview message string for a given commit identifier, useful for displaying or logging commit-specific documentation updates."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_graphql_response", "line_number": 265, "body": "def get_graphql_response(\n    *, settings: Settings, query: str, after: Optional[str] = None\n):\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    variables = {\"after\": after}\n    response = httpx.post(\n        github_graphql_url,\n        headers=headers,\n        json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n    )\n    if not response.status_code == 200:\n        logging.error(f\"Response was not 200, after: {after}\")\n        logging.error(response.text)\n        raise RuntimeError(response.text)\n    data = response.json()\n    return data", "is_method": false, "function_description": "Function providing a convenient way to execute a GitHub GraphQL query with authentication, handling pagination and response validation. It returns the JSON response, facilitating interaction with GitHub's GraphQL API in client applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_graphql_issue_edges", "line_number": 283, "body": "def get_graphql_issue_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=issues_query, after=after)\n    graphql_response = IssuesResponse.parse_obj(data)\n    return graphql_response.data.repository.issues.edges", "is_method": false, "function_description": "Function that fetches a paginated list of issue edges from a GraphQL API using provided settings, supporting pagination via an optional cursor. It serves to retrieve structured issue data efficiently for further processing or display."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_graphql_pr_edges", "line_number": 289, "body": "def get_graphql_pr_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=prs_query, after=after)\n    graphql_response = PRsResponse.parse_obj(data)\n    return graphql_response.data.repository.pullRequests.edges", "is_method": false, "function_description": "Function that fetches paginated pull request edges from a GraphQL API based on given settings and an optional cursor, enabling retrieval of pull request data for repository queries."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_graphql_sponsor_edges", "line_number": 295, "body": "def get_graphql_sponsor_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=sponsors_query, after=after)\n    graphql_response = SponsorsResponse.parse_obj(data)\n    return graphql_response.data.user.sponsorshipsAsMaintainer.edges", "is_method": false, "function_description": "This function fetches and returns sponsorship relationship edges from a GraphQL API, supporting pagination to retrieve sponsor information relevant to a maintainer context. It enables access to sponsorship data for further processing or analysis."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_experts", "line_number": 301, "body": "def get_experts(settings: Settings):\n    issue_nodes: List[IssuesNode] = []\n    issue_edges = get_graphql_issue_edges(settings=settings)\n\n    while issue_edges:\n        for edge in issue_edges:\n            issue_nodes.append(edge.node)\n        last_edge = issue_edges[-1]\n        issue_edges = get_graphql_issue_edges(settings=settings, after=last_edge.cursor)\n\n    commentors = Counter()\n    last_month_commentors = Counter()\n    authors: Dict[str, Author] = {}\n\n    now = datetime.now(tz=timezone.utc)\n    one_month_ago = now - timedelta(days=30)\n\n    for issue in issue_nodes:\n        issue_author_name = None\n        if issue.author:\n            authors[issue.author.login] = issue.author\n            issue_author_name = issue.author.login\n        issue_commentors = set()\n        for comment in issue.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == issue_author_name:\n                    continue\n                issue_commentors.add(comment.author.login)\n        for author_name in issue_commentors:\n            commentors[author_name] += 1\n            if issue.createdAt > one_month_ago:\n                last_month_commentors[author_name] += 1\n    return commentors, last_month_commentors, authors", "is_method": false, "function_description": "Function that aggregates and returns issue participants' activity statistics from a GraphQL source, providing counts of all-time and last-month commenters along with their author details for identifying active contributors or experts."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_contributors", "line_number": 337, "body": "def get_contributors(settings: Settings):\n    pr_nodes: List[PullRequestNode] = []\n    pr_edges = get_graphql_pr_edges(settings=settings)\n\n    while pr_edges:\n        for edge in pr_edges:\n            pr_nodes.append(edge.node)\n        last_edge = pr_edges[-1]\n        pr_edges = get_graphql_pr_edges(settings=settings, after=last_edge.cursor)\n\n    contributors = Counter()\n    commentors = Counter()\n    reviewers = Counter()\n    authors: Dict[str, Author] = {}\n\n    for pr in pr_nodes:\n        author_name = None\n        if pr.author:\n            authors[pr.author.login] = pr.author\n            author_name = pr.author.login\n        pr_commentors: Set[str] = set()\n        pr_reviewers: Set[str] = set()\n        for comment in pr.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == author_name:\n                    continue\n                pr_commentors.add(comment.author.login)\n        for author_name in pr_commentors:\n            commentors[author_name] += 1\n        for review in pr.reviews.nodes:\n            if review.author:\n                authors[review.author.login] = review.author\n                pr_reviewers.add(review.author.login)\n        for reviewer in pr_reviewers:\n            reviewers[reviewer] += 1\n        if pr.state == \"MERGED\" and pr.author:\n            contributors[pr.author.login] += 1\n    return contributors, commentors, reviewers, authors", "is_method": false, "function_description": "Function that aggregates contributors, commentors, and reviewers from pull request data, returning their activity counts and author details for use in project contribution analytics or reporting."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_individual_sponsors", "line_number": 378, "body": "def get_individual_sponsors(settings: Settings):\n    nodes: List[SponsorshipAsMaintainerNode] = []\n    edges = get_graphql_sponsor_edges(settings=settings)\n\n    while edges:\n        for edge in edges:\n            nodes.append(edge.node)\n        last_edge = edges[-1]\n        edges = get_graphql_sponsor_edges(settings=settings, after=last_edge.cursor)\n\n    tiers: DefaultDict[float, Dict[str, SponsorEntity]] = defaultdict(dict)\n    for node in nodes:\n        tiers[node.tier.monthlyPriceInDollars][\n            node.sponsorEntity.login\n        ] = node.sponsorEntity\n    return tiers", "is_method": false, "function_description": "Function that retrieves and organizes individual sponsor entities from a paginated GraphQL API, grouping them by their sponsorship tier for use in sponsorship management or display systems."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_top_users", "line_number": 396, "body": "def get_top_users(\n    *,\n    counter: Counter,\n    min_count: int,\n    authors: Dict[str, Author],\n    skip_users: Container[str],\n):\n    users = []\n    for commentor, count in counter.most_common(50):\n        if commentor in skip_users:\n            continue\n        if count >= min_count:\n            author = authors[commentor]\n            users.append(\n                {\n                    \"login\": commentor,\n                    \"count\": count,\n                    \"avatarUrl\": author.avatarUrl,\n                    \"url\": author.url,\n                }\n            )\n    return users", "is_method": false, "function_description": "Function that identifies and returns a list of top users with activity counts above a threshold, excluding specified users, along with their profile details. It supports ranking contributors based on engagement metrics for leaderboards or analytics."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/wsgi/tutorial001.py", "function": "read_main", "line_number": 18, "body": "def read_main():\n    return {\"message\": \"Hello World\"}", "is_method": false, "function_description": "Simple function that returns a greeting message. It can be used as a default or health check endpoint response in web applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_cookies/tutorial001.py", "function": "create_cookie", "line_number": 8, "body": "def create_cookie():\n    content = {\"message\": \"Come to the dark side, we have cookies\"}\n    response = JSONResponse(content=content)\n    response.set_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\")\n    return response", "is_method": false, "function_description": "Function to generate a JSON response containing a message and set a cookie named \"fakesession\" with a preset value, useful for simulating session behavior in client-server interactions."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_cookies/tutorial002.py", "function": "create_cookie", "line_number": 7, "body": "def create_cookie(response: Response):\n    response.set_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\")\n    return {\"message\": \"Come to the dark side, we have cookies\"}", "is_method": false, "function_description": "Function that adds a specific cookie to an HTTP response and returns a confirmation message, useful for session simulation or testing cookie behavior in web applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/using_request_directly/tutorial001.py", "function": "read_root", "line_number": 7, "body": "def read_root(item_id: str, request: Request):\n    client_host = request.client.host\n    return {\"client_host\": client_host, \"item_id\": item_id}", "is_method": false, "function_description": "Function that returns the client's host address and a given item ID from an incoming request, useful for tracking request sources and associated item data."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/nosql_databases/tutorial001.py", "function": "get_bucket", "line_number": 12, "body": "def get_bucket():\n    cluster = Cluster(\n        \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\"\n    )\n    authenticator = PasswordAuthenticator(\"username\", \"password\")\n    cluster.authenticate(authenticator)\n    bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT)\n    bucket.timeout = 30\n    bucket.n1ql_timeout = 300\n    return bucket", "is_method": false, "function_description": "Utility function that establishes and returns an authenticated connection to a specific Couchbase bucket with configured timeouts, enabling interaction with the database for data operations."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/nosql_databases/tutorial001.py", "function": "get_user", "line_number": 36, "body": "def get_user(bucket: Bucket, username: str):\n    doc_id = f\"userprofile::{username}\"\n    result = bucket.get(doc_id, quiet=True)\n    if not result.value:\n        return None\n    user = UserInDB(**result.value)\n    return user", "is_method": false, "function_description": "Utility function that fetches and returns a user's profile from a storage bucket by username, returning None if the profile does not exist."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/nosql_databases/tutorial001.py", "function": "read_user", "line_number": 50, "body": "def read_user(username: str):\n    bucket = get_bucket()\n    user = get_user(bucket=bucket, username=username)\n    return user", "is_method": false, "function_description": "Utility function that retrieves user data from a storage bucket based on the provided username, enabling access to user information for other processes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/extending_openapi/tutorial001.py", "function": "custom_openapi", "line_number": 12, "body": "def custom_openapi():\n    if app.openapi_schema:\n        return app.openapi_schema\n    openapi_schema = get_openapi(\n        title=\"Custom title\",\n        version=\"2.5.0\",\n        description=\"This is a very custom OpenAPI schema\",\n        routes=app.routes,\n    )\n    openapi_schema[\"info\"][\"x-logo\"] = {\n        \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\"\n    }\n    app.openapi_schema = openapi_schema\n    return app.openapi_schema", "is_method": false, "function_description": "Generates and caches a customized OpenAPI schema for the application, including title, version, description, and a logo, to provide tailored API documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dataclasses/tutorial003.py", "function": "get_authors", "line_number": 29, "body": "def get_authors():  # (8)\n    return [  # (9)\n        {\n            \"name\": \"Breaters\",\n            \"items\": [\n                {\n                    \"name\": \"Island In The Moon\",\n                    \"description\": \"A place to be be playin' and havin' fun\",\n                },\n                {\"name\": \"Holy Buddies\"},\n            ],\n        },\n        {\n            \"name\": \"System of an Up\",\n            \"items\": [\n                {\n                    \"name\": \"Salt\",\n                    \"description\": \"The kombucha mushroom people's favorite\",\n                },\n                {\"name\": \"Pad Thai\"},\n                {\n                    \"name\": \"Lonely Night\",\n                    \"description\": \"The mostests lonliest nightiest of allest\",\n                },\n            ],\n        },\n    ]", "is_method": false, "function_description": "Function that returns a predefined list of author data with their associated items and descriptions, useful for providing static information about authors and their works."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sub_applications/tutorial001.py", "function": "read_main", "line_number": 7, "body": "def read_main():\n    return {\"message\": \"Hello World from main app\"}", "is_method": false, "function_description": "Returns a simple greeting message as a dictionary, typically serving as a health check or basic response in a web application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sub_applications/tutorial001.py", "function": "read_sub", "line_number": 15, "body": "def read_sub():\n    return {\"message\": \"Hello World from sub API\"}", "is_method": false, "function_description": "Returns a simple dictionary with a greeting message, serving as a basic example or health-check response in an API context."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/graphql/tutorial001.py", "function": "user", "line_number": 15, "body": "def user(self) -> User:\n        return User(name=\"Patrick\", age=100)", "is_method": true, "class_name": "Query", "function_description": "Returns a User object with predefined attributes representing a user named Patrick aged 100. This method provides a simple way to access a specific user instance within the Query context."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial004.py", "function": "verify_password", "line_number": 55, "body": "def verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)", "is_method": false, "function_description": "Utility function that verifies whether a plain text password matches a given hashed password, supporting secure authentication processes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial004.py", "function": "get_password_hash", "line_number": 59, "body": "def get_password_hash(password):\n    return pwd_context.hash(password)", "is_method": false, "function_description": "Utility function that generates a secure hash of a password for safe storage and verification in authentication workflows."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial004.py", "function": "get_user", "line_number": 63, "body": "def get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)", "is_method": false, "function_description": "This function retrieves and returns a user record from the database by username, converting it into a UserInDB object. It provides a convenient way to access user data for authentication or profile management."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial004.py", "function": "authenticate_user", "line_number": 69, "body": "def authenticate_user(fake_db, username: str, password: str):\n    user = get_user(fake_db, username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user", "is_method": false, "function_description": "Function that verifies user credentials against stored data and returns the authenticated user object if successful, or False if authentication fails. It provides user authentication capability for access control."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial004.py", "function": "create_access_token", "line_number": 78, "body": "def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt", "is_method": false, "function_description": "Generates a JWT access token containing provided data with a configurable expiration time, supporting secure user authentication and authorization in applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial007.py", "function": "get_current_username", "line_number": 11, "body": "def get_current_username(credentials: HTTPBasicCredentials = Depends(security)):\n    correct_username = secrets.compare_digest(credentials.username, \"stanleyjobson\")\n    correct_password = secrets.compare_digest(credentials.password, \"swordfish\")\n    if not (correct_username and correct_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect email or password\",\n            headers={\"WWW-Authenticate\": \"Basic\"},\n        )\n    return credentials.username", "is_method": false, "function_description": "This function verifies HTTP Basic Authentication credentials and returns the username if valid, raising an authorization error otherwise. It provides a secure way to authenticate users in web applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial007.py", "function": "read_current_user", "line_number": 24, "body": "def read_current_user(username: str = Depends(get_current_username)):\n    return {\"username\": username}", "is_method": false, "function_description": "Utility function that returns the current authenticated user's username, facilitating user identification and access control in dependent components or API endpoints."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial003.py", "function": "fake_hash_password", "line_number": 27, "body": "def fake_hash_password(password: str):\n    return \"fakehashed\" + password", "is_method": false, "function_description": "Simple utility function that returns a mocked hashed version of a password, primarily useful for testing or demonstration purposes without actual hashing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial003.py", "function": "get_user", "line_number": 45, "body": "def get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)", "is_method": false, "function_description": "Function that retrieves and returns a user object from a database by username, enabling access to stored user information when available."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial003.py", "function": "fake_decode_token", "line_number": 51, "body": "def fake_decode_token(token):\n    # This doesn't provide any security at all\n    # Check the next version\n    user = get_user(fake_users_db, token)\n    return user", "is_method": false, "function_description": "Function that retrieves a user from a fake user database based on a token, primarily used for testing or prototyping authentication workflows without security guarantees."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial005.py", "function": "verify_password", "line_number": 70, "body": "def verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)", "is_method": false, "function_description": "Utility function that validates a plain-text password against a hashed version, enabling secure authentication in password management systems."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial005.py", "function": "get_password_hash", "line_number": 74, "body": "def get_password_hash(password):\n    return pwd_context.hash(password)", "is_method": false, "function_description": "Utility function that generates a secure hash of a given password, enabling safe storage and verification in authentication systems."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial005.py", "function": "get_user", "line_number": 78, "body": "def get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)", "is_method": false, "function_description": "This function retrieves and returns a user object from the database using a username. It enables easy access to user data stored in dictionary form for authentication or profile management purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial005.py", "function": "authenticate_user", "line_number": 84, "body": "def authenticate_user(fake_db, username: str, password: str):\n    user = get_user(fake_db, username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user", "is_method": false, "function_description": "Function that verifies a user's credentials against stored data and returns the user object if authentication succeeds. It supports user validation in authentication workflows."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial005.py", "function": "create_access_token", "line_number": 93, "body": "def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt", "is_method": false, "function_description": "Generates a JWT access token embedding given data with an optional expiration time. This function supports secure authentication by producing time-limited tokens for client authorization."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial002.py", "function": "fake_decode_token", "line_number": 19, "body": "def fake_decode_token(token):\n    return User(\n        username=token + \"fakedecoded\", email=\"john@example.com\", full_name=\"John Doe\"\n    )", "is_method": false, "function_description": "Utility function that fakes decoding an authentication token into a User object with preset user details for testing or placeholder purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial006.py", "function": "read_current_user", "line_number": 10, "body": "def read_current_user(credentials: HTTPBasicCredentials = Depends(security)):\n    return {\"username\": credentials.username, \"password\": credentials.password}", "is_method": false, "function_description": "Utility function that extracts and returns the current user's username and password from HTTP Basic authentication credentials for use in authentication or authorization workflows."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/conditional_openapi/tutorial001.py", "function": "root", "line_number": 15, "body": "def root():\n    return {\"message\": \"Hello World\"}", "is_method": false, "function_description": "Simple function that returns a greeting message in a dictionary format, often used as a basic API root endpoint response."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/websockets/tutorial003.py", "function": "disconnect", "line_number": 54, "body": "def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)", "is_method": true, "class_name": "ConnectionManager", "function_description": "Removes a given websocket connection from the active connections managed by the ConnectionManager, effectively terminating its tracked session. This supports managing live connection states in real-time applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial004.py", "function": "get_name_with_age", "line_number": 1, "body": "def get_name_with_age(name: str, age: int):\n    name_with_age = name + \" is this old: \" + str(age)\n    return name_with_age", "is_method": false, "function_description": "Function that formats and returns a string combining a person's name with their age, useful for generating simple descriptive text outputs."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial008.py", "function": "process_items", "line_number": 4, "body": "def process_items(prices: Dict[str, float]):\n    for item_name, item_price in prices.items():\n        print(item_name)\n        print(item_price)", "is_method": false, "function_description": "This function iterates over a dictionary of items and their prices, printing each item's name and price. It serves as a simple utility for displaying pricing information."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial001.py", "function": "get_full_name", "line_number": 1, "body": "def get_full_name(first_name, last_name):\n    full_name = first_name.title() + \" \" + last_name.title()\n    return full_name", "is_method": false, "function_description": "Function that formats and combines first and last names into a properly capitalized full name string for consistent display or identification."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial007.py", "function": "process_items", "line_number": 4, "body": "def process_items(items_t: Tuple[int, int, str], items_s: Set[bytes]):\n    return items_t, items_s", "is_method": false, "function_description": "Returns the given tuple and set of items without modification. This function can be used to simultaneously handle and pass through two different data collections."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial009.py", "function": "say_hi", "line_number": 4, "body": "def say_hi(name: Optional[str] = None):\n    if name is not None:\n        print(f\"Hey {name}!\")\n    else:\n        print(\"Hello World\")", "is_method": false, "function_description": "This function provides a simple greeting message, optionally personalized with a given name. It can be used to display friendly messages in user interactions or demonstrations."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial003.py", "function": "get_name_with_age", "line_number": 1, "body": "def get_name_with_age(name: str, age: int):\n    name_with_age = name + \" is this old: \" + age\n    return name_with_age", "is_method": false, "function_description": "Function attempts to create a string combining a name and age but incorrectly concatenates a string with an integer without conversion. Its intended purpose seems to be returning a descriptive string with a person's name and age."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial005.py", "function": "get_items", "line_number": 1, "body": "def get_items(item_a: str, item_b: int, item_c: float, item_d: bool, item_e: bytes):\n    return item_a, item_b, item_c, item_d, item_d, item_e", "is_method": false, "function_description": "Function that returns a tuple containing its input parameters, including a duplicated boolean value, useful for grouping diverse data items together."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial002.py", "function": "get_full_name", "line_number": 1, "body": "def get_full_name(first_name: str, last_name: str):\n    full_name = first_name.title() + \" \" + last_name.title()\n    return full_name", "is_method": false, "function_description": "Function that formats and combines first and last names into a properly capitalized full name string for consistent display or identification purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial010.py", "function": "get_person_name", "line_number": 6, "body": "def get_person_name(one_person: Person):\n    return one_person.name", "is_method": false, "function_description": "Utility function that extracts and returns the name attribute from a Person object. It provides a simple interface to access a person's name in various contexts."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial006.py", "function": "process_items", "line_number": 4, "body": "def process_items(items: List[str]):\n    for item in items:\n        print(item)", "is_method": false, "function_description": "This function iterates over a list of strings and prints each item. It provides a simple way to output all elements from a given list."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/path_operation_advanced_configuration/tutorial002.py", "function": "use_route_names_as_operation_ids", "line_number": 12, "body": "def use_route_names_as_operation_ids(app: FastAPI) -> None:\n    \"\"\"\n    Simplify operation IDs so that generated API clients have simpler function\n    names.\n\n    Should be called only after all routes have been added.\n    \"\"\"\n    for route in app.routes:\n        if isinstance(route, APIRoute):\n            route.operation_id = route.name", "is_method": false, "function_description": "Function that simplifies API operation IDs by setting each route's operation ID to its name, facilitating clearer and more concise client function names after all routes are defined."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/path_operation_advanced_configuration/tutorial006.py", "function": "magic_data_reader", "line_number": 6, "body": "def magic_data_reader(raw_body: bytes):\n    return {\n        \"size\": len(raw_body),\n        \"content\": {\n            \"name\": \"Maaaagic\",\n            \"price\": 42,\n            \"description\": \"Just kiddin', no magic here. \u2728\",\n        },\n    }", "is_method": false, "function_description": "Utility function that processes raw byte data to return its size along with fixed example metadata, potentially serving as a placeholder or mock data generator for testing or demonstration purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/first_steps/tutorial003.py", "function": "root", "line_number": 7, "body": "def root():\n    return {\"message\": \"Hello World\"}", "is_method": false, "function_description": "Function that returns a basic greeting message, useful as a simple health check or introductory response in a web service or API endpoint."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_directly/tutorial001.py", "function": "update_item", "line_number": 20, "body": "def update_item(id: str, item: Item):\n    json_compatible_item_data = jsonable_encoder(item)\n    return JSONResponse(content=json_compatible_item_data)", "is_method": false, "function_description": "Utility function that converts an Item object into a JSON-compatible format and returns it as a JSON HTTP response, facilitating data updating or API response generation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_directly/tutorial002.py", "function": "get_legacy_data", "line_number": 7, "body": "def get_legacy_data():\n    data = \"\"\"<?xml version=\"1.0\"?>\n    <shampoo>\n    <Header>\n        Apply shampoo here.\n    </Header>\n    <Body>\n        You'll have to use soap here.\n    </Body>\n    </shampoo>\n    \"\"\"\n    return Response(content=data, media_type=\"application/xml\")", "is_method": false, "function_description": "Returns a fixed XML response containing legacy shampoo application instructions, suitable for serving predefined XML data in an HTTP response."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/events/tutorial002.py", "function": "shutdown_event", "line_number": 7, "body": "def shutdown_event():\n    with open(\"log.txt\", mode=\"a\") as log:\n        log.write(\"Application shutdown\")", "is_method": false, "function_description": "Logs a shutdown event to a file named \"log.txt\" indicating the application has stopped running. This function supports tracking application lifecycle events for auditing or debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_response/tutorial004.py", "function": "generate_html_response", "line_number": 7, "body": "def generate_html_response():\n    html_content = \"\"\"\n    <html>\n        <head>\n            <title>Some HTML in here</title>\n        </head>\n        <body>\n            <h1>Look ma! HTML!</h1>\n        </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(content=html_content, status_code=200)", "is_method": false, "function_description": "Function that creates and returns a standard HTML response with fixed content and a 200 status code. It provides a simple web response for HTTP endpoints requiring static HTML output."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_response/tutorial008.py", "function": "main", "line_number": 9, "body": "def main():\n    def iterfile():  # (1)\n        with open(some_file_path, mode=\"rb\") as file_like:  # (2)\n            yield from file_like  # (3)\n\n    return StreamingResponse(iterfile(), media_type=\"video/mp4\")", "is_method": false, "function_description": "Returns a streaming response that reads and streams a video file in MP4 format, enabling efficient video data delivery without loading the entire file into memory."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_response/tutorial008.py", "function": "iterfile", "line_number": 10, "body": "def iterfile():  # (1)\n        with open(some_file_path, mode=\"rb\") as file_like:  # (2)\n            yield from file_like", "is_method": false, "function_description": "This function provides an iterator over the bytes of a file, enabling efficient streaming of file content without loading it entirely into memory."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "get_user", "line_number": 6, "body": "def get_user(db: Session, user_id: int):\n    return db.query(models.User).filter(models.User.id == user_id).first()", "is_method": false, "function_description": "Utility function that fetches a user record by ID from the database session, enabling retrieval of user details for authentication or profile management."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "get_user_by_email", "line_number": 10, "body": "def get_user_by_email(db: Session, email: str):\n    return db.query(models.User).filter(models.User.email == email).first()", "is_method": false, "function_description": "Function that retrieves the first user record matching the provided email from the database session, enabling user lookup by email address."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "get_users", "line_number": 14, "body": "def get_users(db: Session, skip: int = 0, limit: int = 100):\n    return db.query(models.User).offset(skip).limit(limit).all()", "is_method": false, "function_description": "Core utility function that retrieves a list of User records from the database with pagination support using skip and limit parameters. It enables fetching user data in manageable batches for efficient data handling."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "create_user", "line_number": 18, "body": "def create_user(db: Session, user: schemas.UserCreate):\n    fake_hashed_password = user.password + \"notreallyhashed\"\n    db_user = models.User(email=user.email, hashed_password=fake_hashed_password)\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return db_user", "is_method": false, "function_description": "Creates a new user record in the database with the provided email and a placeholder hashed password. This function enables adding users to the system's persistent storage."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "get_items", "line_number": 27, "body": "def get_items(db: Session, skip: int = 0, limit: int = 100):\n    return db.query(models.Item).offset(skip).limit(limit).all()", "is_method": false, "function_description": "Function that fetches a paginated list of Item records from the database, supporting offset and limit for controlled data retrieval in list or browsing operations."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "create_user_item", "line_number": 31, "body": "def create_user_item(db: Session, item: schemas.ItemCreate, user_id: int):\n    db_item = models.Item(**item.dict(), owner_id=user_id)\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "is_method": false, "function_description": "Creates and stores a new item linked to a specific user in the database. This function enables adding user-owned records while managing database persistence and returning the created item."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "get_db", "line_number": 15, "body": "def get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()", "is_method": false, "function_description": "Utility function that provides a database session generator, ensuring the session is properly closed after use for safe and efficient database interactions."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "create_user", "line_number": 24, "body": "def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):\n    db_user = crud.get_user_by_email(db, email=user.email)\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    return crud.create_user(db=db, user=user)", "is_method": false, "function_description": "Creates a new user in the database after verifying the email is not already registered, ensuring unique user accounts. It facilitates user registration by handling email duplication checks and user record creation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "read_users", "line_number": 32, "body": "def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    users = crud.get_users(db, skip=skip, limit=limit)\n    return users", "is_method": false, "function_description": "Function retrieves a list of user records from the database with optional pagination using skip and limit parameters, supporting efficient user data access in applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "read_user", "line_number": 38, "body": "def read_user(user_id: int, db: Session = Depends(get_db)):\n    db_user = crud.get_user(db, user_id=user_id)\n    if db_user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return db_user", "is_method": false, "function_description": "Core function to fetch a user record by ID from the database, raising an error if the user does not exist. It provides a standardized way to retrieve user data within API handlers."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "create_item_for_user", "line_number": 46, "body": "def create_item_for_user(\n    user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db)\n):\n    return crud.create_user_item(db=db, item=item, user_id=user_id)", "is_method": false, "function_description": "Utility function that creates a new item associated with a specific user in the database, encapsulating database interaction for item creation within user context."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "read_items", "line_number": 53, "body": "def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    items = crud.get_items(db, skip=skip, limit=limit)\n    return items", "is_method": false, "function_description": "Retrieves a list of items from the database with optional pagination parameters to skip and limit the number of results returned. Useful for fetching subsets of data efficiently in applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "get_db", "line_number": 26, "body": "def get_db(request: Request):\n    return request.state.db", "is_method": false, "function_description": "Utility function that retrieves the database connection object from a request's state, facilitating database access within request handling contexts."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "create_user", "line_number": 31, "body": "def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):\n    db_user = crud.get_user_by_email(db, email=user.email)\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    return crud.create_user(db=db, user=user)", "is_method": false, "function_description": "Creates a new user in the database after verifying the email is not already registered, ensuring unique user accounts. This function supports user registration workflows by enforcing email uniqueness and storing user data."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "read_users", "line_number": 39, "body": "def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    users = crud.get_users(db, skip=skip, limit=limit)\n    return users", "is_method": false, "function_description": "Retrieves a paginated list of users from the database, supporting offset and limit parameters for efficient user data fetching. Useful for user management or display in applications with large user bases."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "read_user", "line_number": 45, "body": "def read_user(user_id: int, db: Session = Depends(get_db)):\n    db_user = crud.get_user(db, user_id=user_id)\n    if db_user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return db_user", "is_method": false, "function_description": "Function that retrieves a user record from the database by user ID, raising an error if the user does not exist. It provides a way to fetch user data for further processing or validation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "create_item_for_user", "line_number": 53, "body": "def create_item_for_user(\n    user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db)\n):\n    return crud.create_user_item(db=db, item=item, user_id=user_id)", "is_method": false, "function_description": "Creates a new item associated with a specific user in the database, facilitating user-specific data management. This function acts as a service layer connecting request data to persistent storage."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "read_items", "line_number": 60, "body": "def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    items = crud.get_items(db, skip=skip, limit=limit)\n    return items", "is_method": false, "function_description": "Function provides paginated retrieval of items from a database session, supporting efficient access to subsets of data for listing or processing purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/tests/test_sql_app.py", "function": "override_get_db", "line_number": 19, "body": "def override_get_db():\n    try:\n        db = TestingSessionLocal()\n        yield db\n    finally:\n        db.close()", "is_method": false, "function_description": "Provides a context-managed database session for testing, ensuring proper opening and closing of the connection during tests. This supports safe and isolated database operations in test environments."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/openapi_callbacks/tutorial001.py", "function": "create_invoice", "line_number": 36, "body": "def create_invoice(invoice: Invoice, callback_url: Optional[HttpUrl] = None):\n    \"\"\"\n    Create an invoice.\n\n    This will (let's imagine) let the API user (some external developer) create an\n    invoice.\n\n    And this path operation will:\n\n    * Send the invoice to the client.\n    * Collect the money from the client.\n    * Send a notification back to the API user (the external developer), as a callback.\n        * At this point is that the API will somehow send a POST request to the\n            external API with the notification of the invoice event\n            (e.g. \"payment successful\").\n    \"\"\"\n    # Send the invoice, collect the money, send the notification (the callback)\n    return {\"msg\": \"Invoice received\"}", "is_method": false, "function_description": "Function in an API context that creates and processes an invoice, sending it to the client, handling payment collection, and optionally notifying an external system via a callback URL upon invoice events."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_change_status_code/tutorial001.py", "function": "get_or_create_task", "line_number": 9, "body": "def get_or_create_task(task_id: str, response: Response):\n    if task_id not in tasks:\n        tasks[task_id] = \"This didn't exist before\"\n        response.status_code = status.HTTP_201_CREATED\n    return tasks[task_id]", "is_method": false, "function_description": "Function that retrieves a task by ID or creates it if absent, updating response status accordingly. Useful for managing tasks with automatic creation and retrieval in one operation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/encoder/tutorial001.py", "function": "update_item", "line_number": 21, "body": "def update_item(id: str, item: Item):\n    json_compatible_item_data = jsonable_encoder(item)\n    fake_db[id] = json_compatible_item_data", "is_method": false, "function_description": "Function that updates or inserts an item in a database by converting it to a JSON-compatible format and storing it with a given identifier. Useful for maintaining or modifying records in a key-value store."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/settings/app03/main.py", "function": "get_settings", "line_number": 11, "body": "def get_settings():\n    return config.Settings()", "is_method": false, "function_description": "Returns a new instance of the Settings configuration object, providing access to application or system settings for other components to use."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/settings/app02/main.py", "function": "get_settings", "line_number": 11, "body": "def get_settings():\n    return Settings()", "is_method": false, "function_description": "Returns a new instance of the Settings class, providing access to application configuration parameters for other functions or components."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/settings/app02/test_main.py", "function": "get_settings_override", "line_number": 9, "body": "def get_settings_override():\n    return Settings(admin_email=\"testing_admin@example.com\")", "is_method": false, "function_description": "Returns a Settings object with predefined admin email values for overriding default configuration settings during testing or development."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/settings/app02/test_main.py", "function": "test_app", "line_number": 16, "body": "def test_app():\n    response = client.get(\"/info\")\n    data = response.json()\n    assert data == {\n        \"app_name\": \"Awesome API\",\n        \"admin_email\": \"testing_admin@example.com\",\n        \"items_per_user\": 50,\n    }", "is_method": false, "function_description": "This function tests the API endpoint \"/info\" to verify it returns the expected application metadata. It ensures the correctness of app name, admin email, and items per user in the response."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/database.py", "function": "__setattr__", "line_number": 15, "body": "def __setattr__(self, name, value):\n        self._state.get()[name] = value", "is_method": true, "class_name": "PeeweeConnectionState", "function_description": "Overrides attribute assignment to store values in the internal state dictionary, allowing dynamic state management within the PeeweeConnectionState instance."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/database.py", "function": "__getattr__", "line_number": 18, "body": "def __getattr__(self, name):\n        return self._state.get()[name]", "is_method": true, "class_name": "PeeweeConnectionState", "function_description": "Provides dynamic access to attributes stored in the connection state dictionary of the PeeweeConnectionState instance. Enables convenient retrieval of connection-related state information by attribute name."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/schemas.py", "function": "get", "line_number": 9, "body": "def get(self, key: Any, default: Any = None):\n        res = getattr(self._obj, key, default)\n        if isinstance(res, peewee.ModelSelect):\n            return list(res)\n        return res", "is_method": true, "class_name": "PeeweeGetterDict", "function_description": "Utility method of PeeweeGetterDict that retrieves an attribute by key from the wrapped Peewee model object, converting query results into lists for easier consumption by other functions."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "get_user", "line_number": 4, "body": "def get_user(user_id: int):\n    return models.User.filter(models.User.id == user_id).first()", "is_method": false, "function_description": "Fetches and returns the first user record matching the given user ID from the data store. This function is useful for retrieving user details based on unique identifiers."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "get_user_by_email", "line_number": 8, "body": "def get_user_by_email(email: str):\n    return models.User.filter(models.User.email == email).first()", "is_method": false, "function_description": "Retrieves the first user record matching a given email address from the data store. This function enables user lookup by email for authentication or profile management."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "get_users", "line_number": 12, "body": "def get_users(skip: int = 0, limit: int = 100):\n    return list(models.User.select().offset(skip).limit(limit))", "is_method": false, "function_description": "Function that retrieves a list of user records from the database with optional pagination control via skip and limit parameters. Useful for fetching batches of users efficiently in applications managing user data."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "create_user", "line_number": 16, "body": "def create_user(user: schemas.UserCreate):\n    fake_hashed_password = user.password + \"notreallyhashed\"\n    db_user = models.User(email=user.email, hashed_password=fake_hashed_password)\n    db_user.save()\n    return db_user", "is_method": false, "function_description": "Function that creates and saves a new user with an email and a placeholder hashed password for authentication purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "get_items", "line_number": 23, "body": "def get_items(skip: int = 0, limit: int = 100):\n    return list(models.Item.select().offset(skip).limit(limit))", "is_method": false, "function_description": "Function that retrieves a specified subset of items from a data source, supporting pagination via skip and limit parameters. It enables efficient batch access to items for display or processing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "create_user_item", "line_number": 27, "body": "def create_user_item(item: schemas.ItemCreate, user_id: int):\n    db_item = models.Item(**item.dict(), owner_id=user_id)\n    db_item.save()\n    return db_item", "is_method": false, "function_description": "Creates and saves a new item associated with a specific user ID, linking user ownership to the item for database storage or further processing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "get_db", "line_number": 23, "body": "def get_db(db_state=Depends(reset_db_state)):\n    try:\n        database.db.connect()\n        yield\n    finally:\n        if not database.db.is_closed():\n            database.db.close()", "is_method": false, "function_description": "Utility function providing a managed database connection context that ensures the connection is opened before use and properly closed afterward to maintain resource integrity."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "create_user", "line_number": 33, "body": "def create_user(user: schemas.UserCreate):\n    db_user = crud.get_user_by_email(email=user.email)\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    return crud.create_user(user=user)", "is_method": false, "function_description": "Creates a new user if the email is not already registered, enforcing unique email constraints to prevent duplicates. This function facilitates safe user registration by validating email availability before creation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "read_users", "line_number": 41, "body": "def read_users(skip: int = 0, limit: int = 100):\n    users = crud.get_users(skip=skip, limit=limit)\n    return users", "is_method": false, "function_description": "Function providing paginated access to user records by retrieving a specified subset based on skip and limit parameters, facilitating efficient user data listing or processing in applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "read_user", "line_number": 49, "body": "def read_user(user_id: int):\n    db_user = crud.get_user(user_id=user_id)\n    if db_user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return db_user", "is_method": false, "function_description": "Function that retrieves a user record by ID from the database, raising an error if the user does not exist. It provides reliable access to user data for other operations needing user information."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "create_item_for_user", "line_number": 61, "body": "def create_item_for_user(user_id: int, item: schemas.ItemCreate):\n    return crud.create_user_item(item=item, user_id=user_id)", "is_method": false, "function_description": "Creates a new item associated with a specific user by delegating to a CRUD operation. It facilitates adding user-specific data entries efficiently."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "read_items", "line_number": 66, "body": "def read_items(skip: int = 0, limit: int = 100):\n    items = crud.get_items(skip=skip, limit=limit)\n    return items", "is_method": false, "function_description": "Function that fetches a subset of items with pagination controls for skipping and limiting the number of results, facilitating controlled retrieval of multiple records from a dataset."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "read_slow_users", "line_number": 74, "body": "def read_slow_users(skip: int = 0, limit: int = 100):\n    global sleep_time\n    sleep_time = max(0, sleep_time - 1)\n    time.sleep(sleep_time)  # Fake long processing request\n    users = crud.get_users(skip=skip, limit=limit)\n    return users", "is_method": false, "function_description": "Function that retrieves a list of users with pagination while simulating slow processing by introducing a decreasing artificial delay. Useful for testing or simulating latency effects in user retrieval operations."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_headers/tutorial001.py", "function": "get_headers", "line_number": 8, "body": "def get_headers():\n    content = {\"message\": \"Hello World\"}\n    headers = {\"X-Cat-Dog\": \"alone in the world\", \"Content-Language\": \"en-US\"}\n    return JSONResponse(content=content, headers=headers)", "is_method": false, "function_description": "Creates a JSON HTTP response with a fixed greeting message and custom headers, useful for sending predefined content alongside specific metadata in web applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_headers/tutorial002.py", "function": "get_headers", "line_number": 7, "body": "def get_headers(response: Response):\n    response.headers[\"X-Cat-Dog\"] = \"alone in the world\"\n    return {\"message\": \"Hello World\"}", "is_method": false, "function_description": "This function modifies a response's headers to include a custom field and returns a fixed greeting message. It can be used to add metadata to HTTP responses while returning a simple JSON payload."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/debugging/tutorial001.py", "function": "root", "line_number": 8, "body": "def root():\n    a = \"a\"\n    b = \"b\" + a\n    return {\"hello world\": b}", "is_method": false, "function_description": "Returns a dictionary with a fixed key \"hello world\" and a value constructed from concatenating \"b\" and \"a\". This function provides a simple example of string manipulation and dictionary creation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/background_tasks/tutorial001.py", "function": "write_notification", "line_number": 6, "body": "def write_notification(email: str, message=\"\"):\n    with open(\"log.txt\", mode=\"w\") as email_file:\n        content = f\"notification for {email}: {message}\"\n        email_file.write(content)", "is_method": false, "function_description": "Function that writes a notification message for a given email to a log file, overwriting previous content. It provides a simple way to log email notifications with customizable messages."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/background_tasks/tutorial002.py", "function": "write_log", "line_number": 8, "body": "def write_log(message: str):\n    with open(\"log.txt\", mode=\"a\") as log:\n        log.write(message)", "is_method": false, "function_description": "Utility function that appends a given message to a log file, enabling simple logging of events or information during program execution."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/background_tasks/tutorial002.py", "function": "get_query", "line_number": 13, "body": "def get_query(background_tasks: BackgroundTasks, q: Optional[str] = None):\n    if q:\n        message = f\"found query: {q}\\n\"\n        background_tasks.add_task(write_log, message)\n    return q", "is_method": false, "function_description": "Returns the provided query string and schedules a background task to log it if present. This function helps manage query logging asynchronously while returning the query for further use."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/extra_models/tutorial001.py", "function": "fake_password_hasher", "line_number": 29, "body": "def fake_password_hasher(raw_password: str):\n    return \"supersecret\" + raw_password", "is_method": false, "function_description": "This function creates a simple hashed representation of a password by prefixing it with a fixed string. It can be used for basic password transformation or testing purposes but lacks security features."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/extra_models/tutorial001.py", "function": "fake_save_user", "line_number": 33, "body": "def fake_save_user(user_in: UserIn):\n    hashed_password = fake_password_hasher(user_in.password)\n    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)\n    print(\"User saved! ..not really\")\n    return user_in_db", "is_method": false, "function_description": "This function simulates saving a user by hashing the password and returning a user database object without actual persistence, useful for testing authentication workflows without database operations."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/extra_models/tutorial002.py", "function": "fake_password_hasher", "line_number": 27, "body": "def fake_password_hasher(raw_password: str):\n    return \"supersecret\" + raw_password", "is_method": false, "function_description": "Function that generates a simple hashed-like string by prefixing a fixed secret to a given password, primarily useful for testing authentication mechanisms without real hashing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/extra_models/tutorial002.py", "function": "fake_save_user", "line_number": 31, "body": "def fake_save_user(user_in: UserIn):\n    hashed_password = fake_password_hasher(user_in.password)\n    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)\n    print(\"User saved! ..not really\")\n    return user_in_db", "is_method": false, "function_description": "Simulates saving a user by hashing their password and returning a user database object without actual persistence, useful for testing or demonstration purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/behind_a_proxy/tutorial004.py", "function": "read_main", "line_number": 14, "body": "def read_main(request: Request):\n    return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")}", "is_method": false, "function_description": "This function provides a simple HTTP response with a greeting message and includes the request's root path, serving as a basic endpoint handler in a web application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/behind_a_proxy/tutorial001.py", "function": "read_main", "line_number": 7, "body": "def read_main(request: Request):\n    return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")}", "is_method": false, "function_description": "This function handles an HTTP request by returning a greeting message along with the request's root path information. It serves as a simple endpoint response provider in a web application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/behind_a_proxy/tutorial003.py", "function": "read_main", "line_number": 13, "body": "def read_main(request: Request):\n    return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")}", "is_method": false, "function_description": "Returns a greeting message along with the root path from an incoming request, useful for basic API health checks or connection validation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/behind_a_proxy/tutorial002.py", "function": "read_main", "line_number": 7, "body": "def read_main(request: Request):\n    return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")}", "is_method": false, "function_description": "Simple handler function that returns a greeting message along with the request's root path, useful for basic API health checks or confirming routing context."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/app_testing/tutorial001.py", "function": "test_read_main", "line_number": 15, "body": "def test_read_main():\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"msg\": \"Hello World\"}", "is_method": false, "function_description": "This function tests that the main endpoint (\"/\") of a web service responds successfully with a status code 200 and returns the expected JSON message. It is used to verify basic connectivity and correctness of the root API route."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/app_testing/test_main.py", "function": "test_read_main", "line_number": 8, "body": "def test_read_main():\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"msg\": \"Hello World\"}", "is_method": false, "function_description": "Test function that verifies the main endpoint \"/\" responds with status 200 and the expected JSON message, ensuring the application's basic API route is operational."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/app_testing/tutorial002.py", "function": "test_read_main", "line_number": 20, "body": "def test_read_main():\n    client = TestClient(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"msg\": \"Hello World\"}", "is_method": false, "function_description": "This function tests the main application endpoint by sending a GET request to the root URL and verifying that the response status and content match expected values. It ensures the app's primary route is functioning correctly."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/app_testing/tutorial002.py", "function": "test_websocket", "line_number": 27, "body": "def test_websocket():\n    client = TestClient(app)\n    with client.websocket_connect(\"/ws\") as websocket:\n        data = websocket.receive_json()\n        assert data == {\"msg\": \"Hello WebSocket\"}", "is_method": false, "function_description": "Test utility function that establishes a WebSocket connection to verify the server sends the expected initial JSON message, useful for automated WebSocket endpoint testing in web applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_request_and_route/tutorial001.py", "function": "get_route_handler", "line_number": 19, "body": "def get_route_handler(self) -> Callable:\n        original_route_handler = super().get_route_handler()\n\n        async def custom_route_handler(request: Request) -> Response:\n            request = GzipRequest(request.scope, request.receive)\n            return await original_route_handler(request)\n\n        return custom_route_handler", "is_method": true, "class_name": "GzipRoute", "function_description": "Provides a route handler that wraps incoming requests with GzipRequest, enabling automatic handling of gzip-compressed request bodies within the GzipRoute. This facilitates transparent decompression for downstream processing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_request_and_route/tutorial003.py", "function": "get_route_handler", "line_number": 9, "body": "def get_route_handler(self) -> Callable:\n        original_route_handler = super().get_route_handler()\n\n        async def custom_route_handler(request: Request) -> Response:\n            before = time.time()\n            response: Response = await original_route_handler(request)\n            duration = time.time() - before\n            response.headers[\"X-Response-Time\"] = str(duration)\n            print(f\"route duration: {duration}\")\n            print(f\"route response: {response}\")\n            print(f\"route response headers: {response.headers}\")\n            return response\n\n        return custom_route_handler", "is_method": true, "class_name": "TimedRoute", "function_description": "Provides a route handler that measures and logs the processing time of HTTP requests, adding the duration as a response header for performance monitoring and debugging in web applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_request_and_route/tutorial002.py", "function": "get_route_handler", "line_number": 9, "body": "def get_route_handler(self) -> Callable:\n        original_route_handler = super().get_route_handler()\n\n        async def custom_route_handler(request: Request) -> Response:\n            try:\n                return await original_route_handler(request)\n            except RequestValidationError as exc:\n                body = await request.body()\n                detail = {\"errors\": exc.errors(), \"body\": body.decode()}\n                raise HTTPException(status_code=422, detail=detail)\n\n        return custom_route_handler", "is_method": true, "class_name": "ValidationErrorLoggingRoute", "function_description": "Provides a route handler that intercepts request validation errors to return detailed 422 HTTP responses, including error info and request body, enhancing error transparency in API request validation workflows."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependencies/tutorial005.py", "function": "query_extractor", "line_number": 8, "body": "def query_extractor(q: Optional[str] = None):\n    return q", "is_method": false, "function_description": "Returns the provided query string as-is, serving as a simple passthrough or placeholder for query extraction functionality."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependencies/tutorial005.py", "function": "query_or_cookie_extractor", "line_number": 12, "body": "def query_or_cookie_extractor(\n    q: str = Depends(query_extractor), last_query: Optional[str] = Cookie(None)\n):\n    if not q:\n        return last_query\n    return q", "is_method": false, "function_description": "Function that extracts a query parameter if present, otherwise returns the last query stored in a cookie, facilitating retrieval of the current or previous query in an HTTP request context."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependencies/tutorial010.py", "function": "__enter__", "line_number": 5, "body": "def __enter__(self):\n        return self.db", "is_method": true, "class_name": "MySuperContextManager", "function_description": "Enables use of the MySuperContextManager instance in a with-statement by providing access to its database resource upon entering the context."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependencies/tutorial010.py", "function": "__exit__", "line_number": 8, "body": "def __exit__(self, exc_type, exc_value, traceback):\n        self.db.close()", "is_method": true, "class_name": "MySuperContextManager", "function_description": "Handles cleanup by closing the database connection when exiting the context, ensuring resource management and preventing leaks in MySuperContextManager usage."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependencies/tutorial011.py", "function": "__call__", "line_number": 10, "body": "def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False", "is_method": true, "class_name": "FixedContentQueryChecker", "function_description": "Method of FixedContentQueryChecker that checks if a predefined fixed content string is present within a given query, returning a boolean result accordingly."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "_prepare_response_content", "line_number": 60, "body": "def _prepare_response_content(\n    res: Any,\n    *,\n    exclude_unset: bool,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -> Any:\n    if isinstance(res, BaseModel):\n        read_with_orm_mode = getattr(res.__config__, \"read_with_orm_mode\", None)\n        if read_with_orm_mode:\n            # Let from_orm extract the data from this model instead of converting\n            # it now to a dict.\n            # Otherwise there's no way to extract lazy data that requires attribute\n            # access instead of dict iteration, e.g. lazy relationships.\n            return res\n        return res.dict(\n            by_alias=True,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n    elif isinstance(res, list):\n        return [\n            _prepare_response_content(\n                item,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for item in res\n        ]\n    elif isinstance(res, dict):\n        return {\n            k: _prepare_response_content(\n                v,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for k, v in res.items()\n        }\n    elif dataclasses.is_dataclass(res):\n        return dataclasses.asdict(res)\n    return res", "is_method": false, "function_description": "Internal helper function that recursively converts models, dataclasses, or collections into dictionaries while applying exclusion rules, preparing response content for serialization or client consumption."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "get_request_handler", "line_number": 164, "body": "def get_request_handler(\n    dependant: Dependant,\n    body_field: Optional[ModelField] = None,\n    status_code: Optional[int] = None,\n    response_class: Union[Type[Response], DefaultPlaceholder] = Default(JSONResponse),\n    response_field: Optional[ModelField] = None,\n    response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    response_model_by_alias: bool = True,\n    response_model_exclude_unset: bool = False,\n    response_model_exclude_defaults: bool = False,\n    response_model_exclude_none: bool = False,\n    dependency_overrides_provider: Optional[Any] = None,\n) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.field_info, params.Form)\n    if isinstance(response_class, DefaultPlaceholder):\n        actual_response_class: Type[Response] = response_class.value\n    else:\n        actual_response_class = response_class\n\n    async def app(request: Request) -> Response:\n        try:\n            body: Any = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        json_body: Any = Undefined\n                        content_type_value = request.headers.get(\"content-type\")\n                        if not content_type_value:\n                            json_body = await request.json()\n                        else:\n                            message = email.message.Message()\n                            message[\"content-type\"] = content_type_value\n                            if message.get_content_maintype() == \"application\":\n                                subtype = message.get_content_subtype()\n                                if subtype == \"json\" or subtype.endswith(\"+json\"):\n                                    json_body = await request.json()\n                        if json_body != Undefined:\n                            body = json_body\n                        else:\n                            body = body_bytes\n        except json.JSONDecodeError as e:\n            raise RequestValidationError([ErrorWrapper(e, (\"body\", e.pos))], body=e.doc)\n        except Exception as e:\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            ) from e\n        solved_result = await solve_dependencies(\n            request=request,\n            dependant=dependant,\n            body=body,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, background_tasks, sub_response, _ = solved_result\n        if errors:\n            raise RequestValidationError(errors, body=body)\n        else:\n            raw_response = await run_endpoint_function(\n                dependant=dependant, values=values, is_coroutine=is_coroutine\n            )\n\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = await serialize_response(\n                field=response_field,\n                response_content=raw_response,\n                include=response_model_include,\n                exclude=response_model_exclude,\n                by_alias=response_model_by_alias,\n                exclude_unset=response_model_exclude_unset,\n                exclude_defaults=response_model_exclude_defaults,\n                exclude_none=response_model_exclude_none,\n                is_coroutine=is_coroutine,\n            )\n            response_args: Dict[str, Any] = {\"background\": background_tasks}\n            # If status_code was set, use it, otherwise use the default from the\n            # response class, in the case of redirect it's 307\n            if status_code is not None:\n                response_args[\"status_code\"] = status_code\n            response = actual_response_class(response_data, **response_args)\n            response.headers.raw.extend(sub_response.headers.raw)\n            if sub_response.status_code:\n                response.status_code = sub_response.status_code\n            return response\n\n    return app", "is_method": false, "function_description": "Generates an async request handler that processes input, resolves dependencies, executes the endpoint function, and serializes the output into an HTTP response with optional status and response customization. Useful for building customizable API endpoints."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "get_websocket_app", "line_number": 259, "body": "def get_websocket_app(\n    dependant: Dependant, dependency_overrides_provider: Optional[Any] = None\n) -> Callable[[WebSocket], Coroutine[Any, Any, Any]]:\n    async def app(websocket: WebSocket) -> None:\n        solved_result = await solve_dependencies(\n            request=websocket,\n            dependant=dependant,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, _, _2, _3 = solved_result\n        if errors:\n            await websocket.close(code=WS_1008_POLICY_VIOLATION)\n            raise WebSocketRequestValidationError(errors)\n        assert dependant.call is not None, \"dependant.call must be a function\"\n        await dependant.call(**values)\n\n    return app", "is_method": false, "function_description": "Creates and returns an asynchronous WebSocket handler that resolves dependencies, validates requests, and invokes a specified callable with the resolved parameters. It facilitates dependency-injected WebSocket endpoints with error handling for validation failures."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "get_route_handler", "line_number": 419, "body": "def get_route_handler(self) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n        return get_request_handler(\n            dependant=self.dependant,\n            body_field=self.body_field,\n            status_code=self.status_code,\n            response_class=self.response_class,\n            response_field=self.secure_cloned_response_field,\n            response_model_include=self.response_model_include,\n            response_model_exclude=self.response_model_exclude,\n            response_model_by_alias=self.response_model_by_alias,\n            response_model_exclude_unset=self.response_model_exclude_unset,\n            response_model_exclude_defaults=self.response_model_exclude_defaults,\n            response_model_exclude_none=self.response_model_exclude_none,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )", "is_method": true, "class_name": "APIRoute", "function_description": "Provides a configured asynchronous request handler for the APIRoute that processes incoming requests and generates appropriate responses based on route specifications and dependencies."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "add_api_route", "line_number": 479, "body": "def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        name: Optional[str] = None,\n        route_class_override: Optional[Type[APIRoute]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        route_class = route_class_override or self.route_class\n        responses = responses or {}\n        combined_responses = {**self.responses, **responses}\n        current_response_class = get_value_or_default(\n            response_class, self.default_response_class\n        )\n        current_tags = self.tags.copy()\n        if tags:\n            current_tags.extend(tags)\n        current_dependencies = self.dependencies.copy()\n        if dependencies:\n            current_dependencies.extend(dependencies)\n        current_callbacks = self.callbacks.copy()\n        if callbacks:\n            current_callbacks.extend(callbacks)\n        route = route_class(\n            self.prefix + path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=current_tags,\n            dependencies=current_dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=combined_responses,\n            deprecated=deprecated or self.deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema and self.include_in_schema,\n            response_class=current_response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            callbacks=current_callbacks,\n            openapi_extra=openapi_extra,\n        )\n        self.routes.append(route)", "is_method": true, "class_name": "APIRouter", "function_description": "Adds a new API route to the APIRouter, linking a URL path to an endpoint with customizable behavior, metadata, and integration options. This enables flexible route registration for building modular web APIs."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "api_route", "line_number": 554, "body": "def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                callbacks=callbacks,\n                openapi_extra=openapi_extra,\n            )\n            return func\n\n        return decorator", "is_method": true, "class_name": "APIRouter", "function_description": "Decorator method of the APIRouter class that registers a function as an API route with configurable request/response details, enabling flexible endpoint definition and integration within a web application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "add_api_websocket_route", "line_number": 612, "body": "def add_api_websocket_route(\n        self, path: str, endpoint: Callable[..., Any], name: Optional[str] = None\n    ) -> None:\n        route = APIWebSocketRoute(\n            path,\n            endpoint=endpoint,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n        self.routes.append(route)", "is_method": true, "class_name": "APIRouter", "function_description": "Adds a new WebSocket route to the API router, linking a URL path to a specified endpoint function for handling WebSocket connections. This enables real-time bidirectional communication within the API framework."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "websocket", "line_number": 623, "body": "def websocket(\n        self, path: str, name: Optional[str] = None\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator", "is_method": true, "class_name": "APIRouter", "function_description": "Provides a decorator to register a WebSocket route on a specified path, enabling functions to handle WebSocket connections within the APIRouter."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "include_router", "line_number": 632, "body": "def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        else:\n            for r in router.routes:\n                path = getattr(r, \"path\")\n                name = getattr(r, \"name\", \"unknown\")\n                if path is not None and not path:\n                    raise Exception(\n                        f\"Prefix and path cannot be both empty (path operation: {name})\"\n                    )\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                use_response_class = get_value_or_default(\n                    route.response_class,\n                    router.default_response_class,\n                    default_response_class,\n                    self.default_response_class,\n                )\n                current_tags = []\n                if tags:\n                    current_tags.extend(tags)\n                if route.tags:\n                    current_tags.extend(route.tags)\n                current_dependencies: List[params.Depends] = []\n                if dependencies:\n                    current_dependencies.extend(dependencies)\n                if route.dependencies:\n                    current_dependencies.extend(route.dependencies)\n                current_callbacks = []\n                if callbacks:\n                    current_callbacks.extend(callbacks)\n                if route.callbacks:\n                    current_callbacks.extend(route.callbacks)\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=current_tags,\n                    dependencies=current_dependencies,\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated or deprecated or self.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_exclude_unset=route.response_model_exclude_unset,\n                    response_model_exclude_defaults=route.response_model_exclude_defaults,\n                    response_model_exclude_none=route.response_model_exclude_none,\n                    include_in_schema=route.include_in_schema\n                    and self.include_in_schema\n                    and include_in_schema,\n                    response_class=use_response_class,\n                    name=route.name,\n                    route_class_override=type(route),\n                    callbacks=current_callbacks,\n                    openapi_extra=route.openapi_extra,\n                )\n            elif isinstance(route, routing.Route):\n                methods = list(route.methods or [])  # type: ignore # in Starlette\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=methods,\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                self.add_api_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n        for handler in router.on_startup:\n            self.add_event_handler(\"startup\", handler)\n        for handler in router.on_shutdown:\n            self.add_event_handler(\"shutdown\", handler)", "is_method": true, "class_name": "APIRouter", "function_description": "Integrates all routes, dependencies, and event handlers from another APIRouter instance into the current router, optionally applying a common path prefix and shared metadata. This facilitates modular composition and reuse of route groups within a web application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "get", "line_number": 735, "body": "def get(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Defines a decorator to register a GET HTTP route with detailed configuration options in the APIRouter, enabling easy endpoint declaration with customizable response models, status codes, metadata, and OpenAPI schema integration."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "put", "line_number": 787, "body": "def put(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Registers a PUT endpoint on the APIRouter, allowing configuration of route path, response model, status code, and other OpenAPI metadata. It facilitates defining HTTP PUT operations with extensive customization for API routing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "post", "line_number": 839, "body": "def post(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Utility method of the APIRouter class that registers a POST endpoint with customizable request/response settings, enabling users to define API routes with detailed metadata and behavior."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "delete", "line_number": 891, "body": "def delete(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Utility method of the APIRouter class that defines a DELETE HTTP endpoint with customizable request and response configurations, enabling easy routing of DELETE requests in a web API."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "options", "line_number": 943, "body": "def options(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Provides a decorator to register an HTTP OPTIONS route on the APIRouter, allowing configuration of request and response details for that path. It facilitates declaring endpoint metadata and handling OPTIONS requests in an API."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "head", "line_number": 995, "body": "def head(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Registers a HEAD HTTP endpoint on the APIRouter, allowing users to define route metadata and configuration for handling HEAD requests in an API. It facilitates standardized route creation with detailed OpenAPI-compatible documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "patch", "line_number": 1047, "body": "def patch(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Creates and registers a PATCH HTTP endpoint with detailed configuration options in an API router. It enables defining request handling, response models, metadata, and documentation for PATCH requests in a web application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "trace", "line_number": 1099, "body": "def trace(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Utility method of APIRouter that registers a route handling HTTP TRACE requests with customizable response and documentation options, enabling tracing capabilities in web APIs."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "decorator", "line_number": 581, "body": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                callbacks=callbacks,\n                openapi_extra=openapi_extra,\n            )\n            return func", "is_method": true, "class_name": "APIRouter", "function_description": "Decorator method of the APIRouter class that registers a function as an API route with detailed configuration options, enabling streamlined endpoint declaration and integration into the router's routing system."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "decorator", "line_number": 626, "body": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func", "is_method": true, "class_name": "APIRouter", "function_description": "Decorator method in APIRouter that registers a function as a WebSocket route handler at a specified path, enabling WebSocket endpoint setup via function decoration."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "openapi", "line_number": 134, "body": "def openapi(self) -> Dict[str, Any]:\n        if not self.openapi_schema:\n            self.openapi_schema = get_openapi(\n                title=self.title,\n                version=self.version,\n                openapi_version=self.openapi_version,\n                description=self.description,\n                terms_of_service=self.terms_of_service,\n                contact=self.contact,\n                license_info=self.license_info,\n                routes=self.routes,\n                tags=self.openapi_tags,\n                servers=self.servers,\n            )\n        return self.openapi_schema", "is_method": true, "class_name": "FastAPI", "function_description": "Core method of the FastAPI class that generates and returns the OpenAPI schema for the application, summarizing its metadata and routes for API documentation and client integration."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "setup", "line_number": 150, "body": "def setup(self) -> None:\n        if self.openapi_url:\n            urls = (server_data.get(\"url\") for server_data in self.servers)\n            server_urls = {url for url in urls if url}\n\n            async def openapi(req: Request) -> JSONResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                if root_path not in server_urls:\n                    if root_path and self.root_path_in_servers:\n                        self.servers.insert(0, {\"url\": root_path})\n                        server_urls.add(root_path)\n                return JSONResponse(self.openapi())\n\n            self.add_route(self.openapi_url, openapi, include_in_schema=False)\n        if self.openapi_url and self.docs_url:\n\n            async def swagger_ui_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                oauth2_redirect_url = self.swagger_ui_oauth2_redirect_url\n                if oauth2_redirect_url:\n                    oauth2_redirect_url = root_path + oauth2_redirect_url\n                return get_swagger_ui_html(\n                    openapi_url=openapi_url,\n                    title=self.title + \" - Swagger UI\",\n                    oauth2_redirect_url=oauth2_redirect_url,\n                    init_oauth=self.swagger_ui_init_oauth,\n                )\n\n            self.add_route(self.docs_url, swagger_ui_html, include_in_schema=False)\n\n            if self.swagger_ui_oauth2_redirect_url:\n\n                async def swagger_ui_redirect(req: Request) -> HTMLResponse:\n                    return get_swagger_ui_oauth2_redirect_html()\n\n                self.add_route(\n                    self.swagger_ui_oauth2_redirect_url,\n                    swagger_ui_redirect,\n                    include_in_schema=False,\n                )\n        if self.openapi_url and self.redoc_url:\n\n            async def redoc_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                return get_redoc_html(\n                    openapi_url=openapi_url, title=self.title + \" - ReDoc\"\n                )\n\n            self.add_route(self.redoc_url, redoc_html, include_in_schema=False)", "is_method": true, "class_name": "FastAPI", "function_description": "Method of FastAPI that configures routes to serve OpenAPI schema and interactive API documentation (Swagger UI and ReDoc), enabling API docs viewing and OAuth2 support."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "add_api_route", "line_number": 212, "body": "def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Coroutine[Any, Any, Response]],\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        name: Optional[str] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        self.router.add_api_route(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Adds a new API route to the FastAPI application, specifying its path, request handler, response model, and other HTTP metadata to define the endpoint's behavior and documentation. This enables dynamic extension of the API with custom operations."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "api_route", "line_number": 267, "body": "def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.router.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                openapi_extra=openapi_extra,\n            )\n            return func\n\n        return decorator", "is_method": true, "class_name": "FastAPI", "function_description": "Utility method of the FastAPI class that defines a new API route by decorating endpoint functions with various request and response configurations. It enables flexible route creation with metadata, validation, and schema integration for building web APIs."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "add_api_websocket_route", "line_number": 323, "body": "def add_api_websocket_route(\n        self, path: str, endpoint: Callable[..., Any], name: Optional[str] = None\n    ) -> None:\n        self.router.add_api_websocket_route(path, endpoint, name=name)", "is_method": true, "class_name": "FastAPI", "function_description": "Utility method of FastAPI that registers a WebSocket route to the application, enabling real-time bi-directional communication on the specified path with a handler function."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "websocket", "line_number": 328, "body": "def websocket(\n        self, path: str, name: Optional[str] = None\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator", "is_method": true, "class_name": "FastAPI", "function_description": "Decorator method of the FastAPI class that registers a WebSocket route at a specified path, enabling the attachment of WebSocket handler functions for real-time communication."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "include_router", "line_number": 337, "body": "def include_router(\n        self,\n        router: routing.APIRouter,\n        *,\n        prefix: str = \"\",\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> None:\n        self.router.include_router(\n            router,\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            responses=responses,\n            deprecated=deprecated,\n            include_in_schema=include_in_schema,\n            default_response_class=default_response_class,\n            callbacks=callbacks,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Provides a way to add and configure a sub-router within a FastAPI application, enabling modular routing with options for path prefixes, tags, dependencies, and response customization."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "get", "line_number": 362, "body": "def get(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.get(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Core method of the FastAPI class that registers a function as an HTTP GET endpoint, enabling route declaration with customizable request handling, response modeling, and OpenAPI documentation integration."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "put", "line_number": 413, "body": "def put(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.put(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Registers a PUT endpoint on the FastAPI app with customizable request handling, response models, metadata, and OpenAPI schema options, enabling RESTful update operations in web APIs."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "post", "line_number": 464, "body": "def post(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.post(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Registers a POST HTTP endpoint with flexible configuration in a FastAPI application, enabling route handling, response modeling, and metadata definition for API documentation and behavior."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "delete", "line_number": 515, "body": "def delete(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.delete(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            operation_id=operation_id,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Core method of the FastAPI class that registers a DELETE HTTP endpoint with customizable response, metadata, and dependency options for building RESTful APIs. It facilitates defining route behavior and documentation for DELETE requests."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "options", "line_number": 566, "body": "def options(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.options(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Provides a decorator to define an HTTP OPTIONS endpoint on a given path with customizable response schemas, metadata, and dependencies, facilitating endpoint introspection and CORS support in FastAPI applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "head", "line_number": 617, "body": "def head(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.head(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Provides a decorator to define a HEAD HTTP endpoint in a FastAPI application, allowing configuration of its path, response model, metadata, and other route-specific options. Enables handling HEAD requests with detailed OpenAPI integration."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "patch", "line_number": 668, "body": "def patch(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.patch(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Provides a decorator to define a PATCH HTTP endpoint in a FastAPI application, specifying route path, response models, status codes, metadata, and other configurations for handling partial resource updates."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "trace", "line_number": 719, "body": "def trace(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.trace(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Provides a decorator to define a TRACE HTTP endpoint with detailed configuration in a FastAPI application. It allows customization of response models, status codes, metadata, and route behavior for tracing operations."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "decorator", "line_number": 293, "body": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.router.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                openapi_extra=openapi_extra,\n            )\n            return func", "is_method": true, "class_name": "FastAPI", "function_description": "Provides a decorator that registers a function as an API route in the FastAPI application, configuring its HTTP path, response models, metadata, and related request handling options."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "decorator", "line_number": 331, "body": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func", "is_method": true, "class_name": "FastAPI", "function_description": "Core method in FastAPI that decorates a function by registering it as a WebSocket route at a specified path, enabling WebSocket communication endpoints within the application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/encoders.py", "function": "generate_encoders_by_class_tuples", "line_number": 15, "body": "def generate_encoders_by_class_tuples(\n    type_encoder_map: Dict[Any, Callable[[Any], Any]]\n) -> Dict[Callable[[Any], Any], Tuple[Any, ...]]:\n    encoders_by_class_tuples: Dict[Callable[[Any], Any], Tuple[Any, ...]] = defaultdict(\n        tuple\n    )\n    for type_, encoder in type_encoder_map.items():\n        encoders_by_class_tuples[encoder] += (type_,)\n    return encoders_by_class_tuples", "is_method": false, "function_description": "Utility function that reorganizes a mapping of types to encoder functions into a mapping of encoder functions to tuples of associated types, facilitating reverse lookup of types by their encoder."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/encoders.py", "function": "jsonable_encoder", "line_number": 29, "body": "def jsonable_encoder(\n    obj: Any,\n    include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    by_alias: bool = True,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    custom_encoder: Dict[Any, Callable[[Any], Any]] = {},\n    sqlalchemy_safe: bool = True,\n) -> Any:\n    if include is not None and not isinstance(include, (set, dict)):\n        include = set(include)\n    if exclude is not None and not isinstance(exclude, (set, dict)):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoder = getattr(obj.__config__, \"json_encoders\", {})\n        if custom_encoder:\n            encoder.update(custom_encoder)\n        obj_dict = obj.dict(\n            include=include,  # type: ignore # in Pydantic\n            exclude=exclude,  # type: ignore # in Pydantic\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_none=exclude_none,\n            exclude_defaults=exclude_defaults,\n        )\n        if \"__root__\" in obj_dict:\n            obj_dict = obj_dict[\"__root__\"]\n        return jsonable_encoder(\n            obj_dict,\n            exclude_none=exclude_none,\n            exclude_defaults=exclude_defaults,\n            custom_encoder=encoder,\n            sqlalchemy_safe=sqlalchemy_safe,\n        )\n    if dataclasses.is_dataclass(obj):\n        return dataclasses.asdict(obj)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        for key, value in obj.items():\n            if (\n                (\n                    not sqlalchemy_safe\n                    or (not isinstance(key, str))\n                    or (not key.startswith(\"_sa\"))\n                )\n                and (value is not None or not exclude_none)\n                and ((include and key in include) or not exclude or key not in exclude)\n            ):\n                encoded_key = jsonable_encoder(\n                    key,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n                encoded_value = jsonable_encoder(\n                    value,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(\n                jsonable_encoder(\n                    item,\n                    include=include,\n                    exclude=exclude,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_defaults=exclude_defaults,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n            )\n        return encoded_list\n\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder(obj)\n\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n\n    errors: List[Exception] = []\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors)\n    return jsonable_encoder(\n        data,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        custom_encoder=custom_encoder,\n        sqlalchemy_safe=sqlalchemy_safe,\n    )", "is_method": false, "function_description": "Utility function that recursively converts complex Python objects\u2014including Pydantic models, dataclasses, enums, and common collections\u2014into JSON-serializable Python data structures, supporting customization and filtering options for flexible encoding."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/datastructures.py", "function": "Default", "line_number": 45, "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)", "is_method": false, "function_description": "Utility function that marks a value as a distinct default placeholder to internally detect when a default has been overridden, even with truthy values."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/datastructures.py", "function": "__get_validators__", "line_number": 14, "body": "def __get_validators__(cls: Type[\"UploadFile\"]) -> Iterable[Callable[..., Any]]:\n        yield cls.validate", "is_method": true, "class_name": "UploadFile", "function_description": "Provides a sequence of validation functions for the UploadFile class, enabling input data to be checked and validated before usage."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/datastructures.py", "function": "validate", "line_number": 18, "body": "def validate(cls: Type[\"UploadFile\"], v: Any) -> Any:\n        if not isinstance(v, StarletteUploadFile):\n            raise ValueError(f\"Expected UploadFile, received: {type(v)}\")\n        return v", "is_method": true, "class_name": "UploadFile", "function_description": "Validation method of the UploadFile class that ensures the input is a StarletteUploadFile instance, enforcing type correctness before further processing or storage."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/datastructures.py", "function": "__bool__", "line_number": 35, "body": "def __bool__(self) -> bool:\n        return bool(self.value)", "is_method": true, "class_name": "DefaultPlaceholder", "function_description": "Returns the truth value of the DefaultPlaceholder instance based on its internal value, enabling its use in boolean contexts."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/datastructures.py", "function": "__eq__", "line_number": 38, "body": "def __eq__(self, o: object) -> bool:\n        return isinstance(o, DefaultPlaceholder) and o.value == self.value", "is_method": true, "class_name": "DefaultPlaceholder", "function_description": "Equality method for DefaultPlaceholder that checks if another object is a DefaultPlaceholder instance with the same value, enabling comparison between DefaultPlaceholder objects."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Path", "line_number": 7, "body": "def Path(  # noqa: N802\n    default: Any,\n    *,\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    deprecated: Optional[bool] = None,\n    **extra: Any,\n) -> Any:\n    return params.Path(\n        default=default,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        deprecated=deprecated,\n        **extra,\n    )", "is_method": false, "function_description": "Utility function that defines metadata and validation constraints for path parameters in request handlers, enabling clear API parameter definitions with optional documentation and value restrictions."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Query", "line_number": 44, "body": "def Query(  # noqa: N802\n    default: Any,\n    *,\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    deprecated: Optional[bool] = None,\n    **extra: Any,\n) -> Any:\n    return params.Query(\n        default,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        deprecated=deprecated,\n        **extra,\n    )", "is_method": false, "function_description": "Function Query wraps and forwards parameters to another Query function from params, facilitating detailed configuration of query parameters with validation and metadata in request handling contexts. It enables specifying defaults, constraints, examples, and documentation for query inputs in web APIs."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Header", "line_number": 81, "body": "def Header(  # noqa: N802\n    default: Any,\n    *,\n    alias: Optional[str] = None,\n    convert_underscores: bool = True,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    deprecated: Optional[bool] = None,\n    **extra: Any,\n) -> Any:\n    return params.Header(\n        default,\n        alias=alias,\n        convert_underscores=convert_underscores,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        deprecated=deprecated,\n        **extra,\n    )", "is_method": false, "function_description": "Function that defines metadata and validation rules for HTTP header parameters in request handling, enabling structured extraction and validation of header values in API endpoints."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Cookie", "line_number": 120, "body": "def Cookie(  # noqa: N802\n    default: Any,\n    *,\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    deprecated: Optional[bool] = None,\n    **extra: Any,\n) -> Any:\n    return params.Cookie(\n        default,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        deprecated=deprecated,\n        **extra,\n    )", "is_method": false, "function_description": "Utility function that creates a cookie parameter with validation and metadata for API endpoints, facilitating consistent request cookie handling with constraints, examples, and descriptive information."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Body", "line_number": 157, "body": "def Body(  # noqa: N802\n    default: Any,\n    *,\n    embed: bool = False,\n    media_type: str = \"application/json\",\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    **extra: Any,\n) -> Any:\n    return params.Body(\n        default,\n        embed=embed,\n        media_type=media_type,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        **extra,\n    )", "is_method": false, "function_description": "Function returning a configured Body parameter object for request data validation and documentation, supporting constraints, metadata, and examples to define API endpoint inputs."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Form", "line_number": 196, "body": "def Form(  # noqa: N802\n    default: Any,\n    *,\n    media_type: str = \"application/x-www-form-urlencoded\",\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    **extra: Any,\n) -> Any:\n    return params.Form(\n        default,\n        media_type=media_type,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        **extra,\n    )", "is_method": false, "function_description": "Utility function that wraps parameter metadata for form data input, specifying validations and serialization details, to facilitate request data handling in web frameworks. It enables detailed form field configuration like constraints, aliases, and examples."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "File", "line_number": 233, "body": "def File(  # noqa: N802\n    default: Any,\n    *,\n    media_type: str = \"multipart/form-data\",\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    **extra: Any,\n) -> Any:\n    return params.File(\n        default,\n        media_type=media_type,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        **extra,\n    )", "is_method": false, "function_description": "Utility function that facilitates defining and validating file upload parameters in API endpoints, including metadata and constraints such as media type, size limits, and pattern matching."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Depends", "line_number": 270, "body": "def Depends(  # noqa: N802\n    dependency: Optional[Callable[..., Any]] = None, *, use_cache: bool = True\n) -> Any:\n    return params.Depends(dependency=dependency, use_cache=use_cache)", "is_method": false, "function_description": "Utility function that declares a dependency to be injected, optionally enabling caching for reuse. It supports dependency injection in application frameworks to manage and provide required components automatically."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Security", "line_number": 276, "body": "def Security(  # noqa: N802\n    dependency: Optional[Callable[..., Any]] = None,\n    *,\n    scopes: Optional[Sequence[str]] = None,\n    use_cache: bool = True,\n) -> Any:\n    return params.Security(dependency=dependency, scopes=scopes, use_cache=use_cache)", "is_method": false, "function_description": "Function acting as a wrapper to configure and provide security dependencies with optional scope restriction and caching support, facilitating consistent security handling in applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/responses.py", "function": "render", "line_number": 24, "body": "def render(self, content: Any) -> bytes:\n        assert ujson is not None, \"ujson must be installed to use UJSONResponse\"\n        return ujson.dumps(content, ensure_ascii=False).encode(\"utf-8\")", "is_method": true, "class_name": "UJSONResponse", "function_description": "Method of UJSONResponse that serializes Python objects to UTF-8 encoded JSON bytes using the ujson library for fast JSON rendering in HTTP responses."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/responses.py", "function": "render", "line_number": 32, "body": "def render(self, content: Any) -> bytes:\n        assert orjson is not None, \"orjson must be installed to use ORJSONResponse\"\n        return orjson.dumps(content)", "is_method": true, "class_name": "ORJSONResponse", "function_description": "Utility method of ORJSONResponse that serializes Python objects into JSON-formatted bytes using the orjson library for fast and efficient JSON rendering."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/params.py", "function": "__repr__", "line_number": 54, "body": "def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.default})\"", "is_method": true, "class_name": "Param", "function_description": "Provides a concise string representation of a Param instance, displaying the class name and its default value for easier inspection and debugging."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/params.py", "function": "__repr__", "line_number": 265, "body": "def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.default})\"", "is_method": true, "class_name": "Body", "function_description": "Provides a concise string representation of a Body instance showing its class name and default value for easier identification and debugging."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/params.py", "function": "__repr__", "line_number": 355, "body": "def __repr__(self) -> str:\n        attr = getattr(self.dependency, \"__name__\", type(self.dependency).__name__)\n        cache = \"\" if self.use_cache else \", use_cache=False\"\n        return f\"{self.__class__.__name__}({attr}{cache})\"", "is_method": true, "class_name": "Depends", "function_description": "Returns a string representation of the Depends instance, showing the name of its dependency and whether caching is enabled. This aids in debugging by summarizing the dependency's configuration."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "get_model_definitions", "line_number": 17, "body": "def get_model_definitions(\n    *,\n    flat_models: Set[Union[Type[BaseModel], Type[Enum]]],\n    model_name_map: Dict[Union[Type[BaseModel], Type[Enum]], str],\n) -> Dict[str, Any]:\n    definitions: Dict[str, Dict[str, Any]] = {}\n    for model in flat_models:\n        m_schema, m_definitions, m_nested_models = model_process_schema(\n            model, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n        )\n        definitions.update(m_definitions)\n        model_name = model_name_map[model]\n        definitions[model_name] = m_schema\n    return definitions", "is_method": false, "function_description": "Utility function that compiles and returns JSON schema definitions for a set of Pydantic models and enums, mapping model classes to their schema representations for use in data validation or API documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "get_path_param_names", "line_number": 33, "body": "def get_path_param_names(path: str) -> Set[str]:\n    return set(re.findall(\"{(.*?)}\", path))", "is_method": false, "function_description": "This function extracts and returns all parameter names enclosed in curly braces within a URL path string, enabling identification of dynamic segments for routing or URL pattern matching."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "create_response_field", "line_number": 37, "body": "def create_response_field(\n    name: str,\n    type_: Type[Any],\n    class_validators: Optional[Dict[str, Validator]] = None,\n    default: Optional[Any] = None,\n    required: Union[bool, UndefinedType] = False,\n    model_config: Type[BaseConfig] = BaseConfig,\n    field_info: Optional[FieldInfo] = None,\n    alias: Optional[str] = None,\n) -> ModelField:\n    \"\"\"\n    Create a new response field. Raises if type_ is invalid.\n    \"\"\"\n    class_validators = class_validators or {}\n    field_info = field_info or FieldInfo(None)\n\n    response_field = functools.partial(\n        ModelField,\n        name=name,\n        type_=type_,\n        class_validators=class_validators,\n        default=default,\n        required=required,\n        model_config=model_config,\n        alias=alias,\n    )\n\n    try:\n        return response_field(field_info=field_info)\n    except RuntimeError:\n        raise fastapi.exceptions.FastAPIError(\n            f\"Invalid args for response field! Hint: check that {type_} is a valid pydantic field type\"\n        )", "is_method": false, "function_description": "Utility function that creates and validates a response field with specified attributes for use in data models, ensuring type correctness and raising errors for invalid field definitions."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "create_cloned_field", "line_number": 72, "body": "def create_cloned_field(\n    field: ModelField,\n    *,\n    cloned_types: Optional[Dict[Type[BaseModel], Type[BaseModel]]] = None,\n) -> ModelField:\n    # _cloned_types has already cloned types, to support recursive models\n    if cloned_types is None:\n        cloned_types = dict()\n    original_type = field.type_\n    if is_dataclass(original_type) and hasattr(original_type, \"__pydantic_model__\"):\n        original_type = original_type.__pydantic_model__\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = cloned_types.get(original_type)\n        if use_type is None:\n            use_type = create_model(original_type.__name__, __base__=original_type)\n            cloned_types[original_type] = use_type\n            for f in original_type.__fields__.values():\n                use_type.__fields__[f.name] = create_cloned_field(\n                    f, cloned_types=cloned_types\n                )\n    new_field = create_response_field(name=field.name, type_=use_type)\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    new_field.field_info = field.field_info\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [\n            create_cloned_field(sub_field, cloned_types=cloned_types)\n            for sub_field in field.sub_fields\n        ]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(\n            field.key_field, cloned_types=cloned_types\n        )\n    new_field.validators = field.validators\n    new_field.pre_validators = field.pre_validators\n    new_field.post_validators = field.post_validators\n    new_field.parse_json = field.parse_json\n    new_field.shape = field.shape\n    new_field.populate_validators()\n    return new_field", "is_method": false, "function_description": "Creates a deep cloned version of a ModelField, including nested fields and validators, enabling safe modifications without affecting the original model structure. Useful for recursive models and dynamic type manipulation in Pydantic-based schemas."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "generate_operation_id_for_path", "line_number": 122, "body": "def generate_operation_id_for_path(*, name: str, path: str, method: str) -> str:\n    operation_id = name + path\n    operation_id = re.sub(\"[^0-9a-zA-Z_]\", \"_\", operation_id)\n    operation_id = operation_id + \"_\" + method.lower()\n    return operation_id", "is_method": false, "function_description": "Function that creates a unique, sanitized operation identifier by combining a given name, API path, and HTTP method, useful for consistent naming in API routing or documentation generation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "deep_dict_update", "line_number": 129, "body": "def deep_dict_update(main_dict: Dict[Any, Any], update_dict: Dict[Any, Any]) -> None:\n    for key in update_dict:\n        if (\n            key in main_dict\n            and isinstance(main_dict[key], dict)\n            and isinstance(update_dict[key], dict)\n        ):\n            deep_dict_update(main_dict[key], update_dict[key])\n        else:\n            main_dict[key] = update_dict[key]", "is_method": false, "function_description": "Utility function that recursively merges update_dict into main_dict, updating nested dictionaries without overwriting entire sub-dictionaries, useful for deep configuration or state updates."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "get_value_or_default", "line_number": 141, "body": "def get_value_or_default(\n    first_item: Union[DefaultPlaceholder, DefaultType],\n    *extra_items: Union[DefaultPlaceholder, DefaultType],\n) -> Union[DefaultPlaceholder, DefaultType]:\n    \"\"\"\n    Pass items or `DefaultPlaceholder`s by descending priority.\n\n    The first one to _not_ be a `DefaultPlaceholder` will be returned.\n\n    Otherwise, the first item (a `DefaultPlaceholder`) will be returned.\n    \"\"\"\n    items = (first_item,) + extra_items\n    for item in items:\n        if not isinstance(item, DefaultPlaceholder):\n            return item\n    return first_item", "is_method": false, "function_description": "Utility function that returns the highest-priority item that is not a DefaultPlaceholder, falling back to the first item if all are placeholders. It helps select meaningful values from prioritized options with defaults."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/security/utils.py", "function": "get_authorization_scheme_param", "line_number": 4, "body": "def get_authorization_scheme_param(authorization_header_value: str) -> Tuple[str, str]:\n    if not authorization_header_value:\n        return \"\", \"\"\n    scheme, _, param = authorization_header_value.partition(\" \")\n    return scheme, param", "is_method": false, "function_description": "This function extracts the authorization scheme and its parameter from an HTTP authorization header value, facilitating authentication parsing in API requests or web services."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/models.py", "function": "__get_validators__", "line_number": 16, "body": "def __get_validators__(cls) -> Iterable[Callable[..., Any]]:\n            yield cls.validate", "is_method": true, "class_name": "EmailStr", "function_description": "Provides a sequence of validator functions for the EmailStr class, enabling validation processes to be applied where EmailStr instances are used, such as data parsing or input validation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/models.py", "function": "validate", "line_number": 20, "body": "def validate(cls, v: Any) -> str:\n            logger.warning(\n                \"email-validator not installed, email fields will be treated as str.\\n\"\n                \"To install, run: pip install email-validator\"\n            )\n            return str(v)", "is_method": true, "class_name": "EmailStr", "function_description": "This EmailStr class method warns if the email-validator library is missing and returns the input value as a string, effectively bypassing validation. It provides a fallback conversion of email fields when validation is unavailable."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi_security_definitions", "line_number": 69, "body": "def get_openapi_security_definitions(\n    flat_dependant: Dependant,\n) -> Tuple[Dict[str, Any], List[Dict[str, Any]]]:\n    security_definitions = {}\n    operation_security = []\n    for security_requirement in flat_dependant.security_requirements:\n        security_definition = jsonable_encoder(\n            security_requirement.security_scheme.model,\n            by_alias=True,\n            exclude_none=True,\n        )\n        security_name = security_requirement.security_scheme.scheme_name\n        security_definitions[security_name] = security_definition\n        operation_security.append({security_name: security_requirement.scopes})\n    return security_definitions, operation_security", "is_method": false, "function_description": "Function that extracts and formats security schemes and requirements from a dependency object for generating OpenAPI-compliant security definitions and operation-level security specifications. Useful for automated API documentation and security integration."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi_operation_parameters", "line_number": 86, "body": "def get_openapi_operation_parameters(\n    *,\n    all_route_params: Sequence[ModelField],\n    model_name_map: Dict[Union[Type[BaseModel], Type[Enum]], str],\n) -> List[Dict[str, Any]]:\n    parameters = []\n    for param in all_route_params:\n        field_info = param.field_info\n        field_info = cast(Param, field_info)\n        parameter = {\n            \"name\": param.alias,\n            \"in\": field_info.in_.value,\n            \"required\": param.required,\n            \"schema\": field_schema(\n                param, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n            )[0],\n        }\n        if field_info.description:\n            parameter[\"description\"] = field_info.description\n        if field_info.examples:\n            parameter[\"examples\"] = jsonable_encoder(field_info.examples)\n        elif field_info.example != Undefined:\n            parameter[\"example\"] = jsonable_encoder(field_info.example)\n        if field_info.deprecated:\n            parameter[\"deprecated\"] = field_info.deprecated\n        parameters.append(parameter)\n    return parameters", "is_method": false, "function_description": "Utility function that transforms model route parameters into OpenAPI-compliant operation parameter dictionaries, supporting detailed schema, examples, and metadata for API documentation generation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi_operation_request_body", "line_number": 115, "body": "def get_openapi_operation_request_body(\n    *,\n    body_field: Optional[ModelField],\n    model_name_map: Dict[Union[Type[BaseModel], Type[Enum]], str],\n) -> Optional[Dict[str, Any]]:\n    if not body_field:\n        return None\n    assert isinstance(body_field, ModelField)\n    body_schema, _, _ = field_schema(\n        body_field, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n    )\n    field_info = cast(Body, body_field.field_info)\n    request_media_type = field_info.media_type\n    required = body_field.required\n    request_body_oai: Dict[str, Any] = {}\n    if required:\n        request_body_oai[\"required\"] = required\n    request_media_content: Dict[str, Any] = {\"schema\": body_schema}\n    if field_info.examples:\n        request_media_content[\"examples\"] = jsonable_encoder(field_info.examples)\n    elif field_info.example != Undefined:\n        request_media_content[\"example\"] = jsonable_encoder(field_info.example)\n    request_body_oai[\"content\"] = {request_media_type: request_media_content}\n    return request_body_oai", "is_method": false, "function_description": "Function that constructs an OpenAPI-compatible request body schema from a given model field, including media type, requirement status, and examples, for use in API documentation generation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "generate_operation_id", "line_number": 141, "body": "def generate_operation_id(*, route: routing.APIRoute, method: str) -> str:\n    if route.operation_id:\n        return route.operation_id\n    path: str = route.path_format\n    return generate_operation_id_for_path(name=route.name, path=path, method=method)", "is_method": false, "function_description": "Generates a unique operation identifier for an API route and HTTP method, using an existing ID if available or constructing one based on the route's name and path. This supports consistent operation identification in API routing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "generate_operation_summary", "line_number": 148, "body": "def generate_operation_summary(*, route: routing.APIRoute, method: str) -> str:\n    if route.summary:\n        return route.summary\n    return route.name.replace(\"_\", \" \").title()", "is_method": false, "function_description": "This function generates a concise operation summary for an API route, using an explicit summary if available or deriving one from the route's name. It aids in creating readable descriptions for API documentation or user interfaces."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi_operation_metadata", "line_number": 154, "body": "def get_openapi_operation_metadata(\n    *, route: routing.APIRoute, method: str\n) -> Dict[str, Any]:\n    operation: Dict[str, Any] = {}\n    if route.tags:\n        operation[\"tags\"] = route.tags\n    operation[\"summary\"] = generate_operation_summary(route=route, method=method)\n    if route.description:\n        operation[\"description\"] = route.description\n    operation[\"operationId\"] = generate_operation_id(route=route, method=method)\n    if route.deprecated:\n        operation[\"deprecated\"] = route.deprecated\n    return operation", "is_method": false, "function_description": "Function gathers and constructs metadata for an OpenAPI operation based on a given API route and HTTP method, providing details like tags, summary, description, operation ID, and deprecation status. It supports API documentation generation and tooling integration."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi_path", "line_number": 169, "body": "def get_openapi_path(\n    *, route: routing.APIRoute, model_name_map: Dict[type, str]\n) -> Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any]]:\n    path = {}\n    security_schemes: Dict[str, Any] = {}\n    definitions: Dict[str, Any] = {}\n    assert route.methods is not None, \"Methods must be a list\"\n    if isinstance(route.response_class, DefaultPlaceholder):\n        current_response_class: Type[Response] = route.response_class.value\n    else:\n        current_response_class = route.response_class\n    assert current_response_class, \"A response class is needed to generate OpenAPI\"\n    route_response_media_type: Optional[str] = current_response_class.media_type\n    if route.include_in_schema:\n        for method in route.methods:\n            operation = get_openapi_operation_metadata(route=route, method=method)\n            parameters: List[Dict[str, Any]] = []\n            flat_dependant = get_flat_dependant(route.dependant, skip_repeats=True)\n            security_definitions, operation_security = get_openapi_security_definitions(\n                flat_dependant=flat_dependant\n            )\n            if operation_security:\n                operation.setdefault(\"security\", []).extend(operation_security)\n            if security_definitions:\n                security_schemes.update(security_definitions)\n            all_route_params = get_flat_params(route.dependant)\n            operation_parameters = get_openapi_operation_parameters(\n                all_route_params=all_route_params, model_name_map=model_name_map\n            )\n            parameters.extend(operation_parameters)\n            if parameters:\n                operation[\"parameters\"] = list(\n                    {param[\"name\"]: param for param in parameters}.values()\n                )\n            if method in METHODS_WITH_BODY:\n                request_body_oai = get_openapi_operation_request_body(\n                    body_field=route.body_field, model_name_map=model_name_map\n                )\n                if request_body_oai:\n                    operation[\"requestBody\"] = request_body_oai\n            if route.callbacks:\n                callbacks = {}\n                for callback in route.callbacks:\n                    if isinstance(callback, routing.APIRoute):\n                        (\n                            cb_path,\n                            cb_security_schemes,\n                            cb_definitions,\n                        ) = get_openapi_path(\n                            route=callback, model_name_map=model_name_map\n                        )\n                        callbacks[callback.name] = {callback.path: cb_path}\n                operation[\"callbacks\"] = callbacks\n            if route.status_code is not None:\n                status_code = str(route.status_code)\n            else:\n                # It would probably make more sense for all response classes to have an\n                # explicit default status_code, and to extract it from them, instead of\n                # doing this inspection tricks, that would probably be in the future\n                # TODO: probably make status_code a default class attribute for all\n                # responses in Starlette\n                response_signature = inspect.signature(current_response_class.__init__)\n                status_code_param = response_signature.parameters.get(\"status_code\")\n                if status_code_param is not None:\n                    if isinstance(status_code_param.default, int):\n                        status_code = str(status_code_param.default)\n            operation.setdefault(\"responses\", {}).setdefault(status_code, {})[\n                \"description\"\n            ] = route.response_description\n            if (\n                route_response_media_type\n                and route.status_code not in STATUS_CODES_WITH_NO_BODY\n            ):\n                response_schema = {\"type\": \"string\"}\n                if lenient_issubclass(current_response_class, JSONResponse):\n                    if route.response_field:\n                        response_schema, _, _ = field_schema(\n                            route.response_field,\n                            model_name_map=model_name_map,\n                            ref_prefix=REF_PREFIX,\n                        )\n                    else:\n                        response_schema = {}\n                operation.setdefault(\"responses\", {}).setdefault(\n                    status_code, {}\n                ).setdefault(\"content\", {}).setdefault(route_response_media_type, {})[\n                    \"schema\"\n                ] = response_schema\n            if route.responses:\n                operation_responses = operation.setdefault(\"responses\", {})\n                for (\n                    additional_status_code,\n                    additional_response,\n                ) in route.responses.items():\n                    process_response = additional_response.copy()\n                    process_response.pop(\"model\", None)\n                    status_code_key = str(additional_status_code).upper()\n                    if status_code_key == \"DEFAULT\":\n                        status_code_key = \"default\"\n                    openapi_response = operation_responses.setdefault(\n                        status_code_key, {}\n                    )\n                    assert isinstance(\n                        process_response, dict\n                    ), \"An additional response must be a dict\"\n                    field = route.response_fields.get(additional_status_code)\n                    additional_field_schema: Optional[Dict[str, Any]] = None\n                    if field:\n                        additional_field_schema, _, _ = field_schema(\n                            field, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n                        )\n                        media_type = route_response_media_type or \"application/json\"\n                        additional_schema = (\n                            process_response.setdefault(\"content\", {})\n                            .setdefault(media_type, {})\n                            .setdefault(\"schema\", {})\n                        )\n                        deep_dict_update(additional_schema, additional_field_schema)\n                    status_text: Optional[str] = status_code_ranges.get(\n                        str(additional_status_code).upper()\n                    ) or http.client.responses.get(int(additional_status_code))\n                    description = (\n                        process_response.get(\"description\")\n                        or openapi_response.get(\"description\")\n                        or status_text\n                        or \"Additional Response\"\n                    )\n                    deep_dict_update(openapi_response, process_response)\n                    openapi_response[\"description\"] = description\n            http422 = str(HTTP_422_UNPROCESSABLE_ENTITY)\n            if (all_route_params or route.body_field) and not any(\n                [\n                    status in operation[\"responses\"]\n                    for status in [http422, \"4XX\", \"default\"]\n                ]\n            ):\n                operation[\"responses\"][http422] = {\n                    \"description\": \"Validation Error\",\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": REF_PREFIX + \"HTTPValidationError\"}\n                        }\n                    },\n                }\n                if \"ValidationError\" not in definitions:\n                    definitions.update(\n                        {\n                            \"ValidationError\": validation_error_definition,\n                            \"HTTPValidationError\": validation_error_response_definition,\n                        }\n                    )\n            if route.openapi_extra:\n                deep_dict_update(operation, route.openapi_extra)\n            path[method.lower()] = operation\n    return path, security_schemes, definitions", "is_method": false, "function_description": "Generates OpenAPI path specifications including operations, parameters, security, responses, and callbacks for an API route. It enables automated and comprehensive creation of OpenAPI documentation with associated security schemes and schema definitions."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_flat_models_from_routes", "line_number": 326, "body": "def get_flat_models_from_routes(\n    routes: Sequence[BaseRoute],\n) -> Set[Union[Type[BaseModel], Type[Enum]]]:\n    body_fields_from_routes: List[ModelField] = []\n    responses_from_routes: List[ModelField] = []\n    request_fields_from_routes: List[ModelField] = []\n    callback_flat_models: Set[Union[Type[BaseModel], Type[Enum]]] = set()\n    for route in routes:\n        if getattr(route, \"include_in_schema\", None) and isinstance(\n            route, routing.APIRoute\n        ):\n            if route.body_field:\n                assert isinstance(\n                    route.body_field, ModelField\n                ), \"A request body must be a Pydantic Field\"\n                body_fields_from_routes.append(route.body_field)\n            if route.response_field:\n                responses_from_routes.append(route.response_field)\n            if route.response_fields:\n                responses_from_routes.extend(route.response_fields.values())\n            if route.callbacks:\n                callback_flat_models |= get_flat_models_from_routes(route.callbacks)\n            params = get_flat_params(route.dependant)\n            request_fields_from_routes.extend(params)\n\n    flat_models = callback_flat_models | get_flat_models_from_fields(\n        body_fields_from_routes + responses_from_routes + request_fields_from_routes,\n        known_models=set(),\n    )\n    return flat_models", "is_method": false, "function_description": "Utility function that extracts and returns all unique Pydantic models and enums referenced in the request bodies, responses, parameters, and callbacks from a sequence of API route definitions, aiding schema analysis and validation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi", "line_number": 358, "body": "def get_openapi(\n    *,\n    title: str,\n    version: str,\n    openapi_version: str = \"3.0.2\",\n    description: Optional[str] = None,\n    routes: Sequence[BaseRoute],\n    tags: Optional[List[Dict[str, Any]]] = None,\n    servers: Optional[List[Dict[str, Union[str, Any]]]] = None,\n    terms_of_service: Optional[str] = None,\n    contact: Optional[Dict[str, Union[str, Any]]] = None,\n    license_info: Optional[Dict[str, Union[str, Any]]] = None,\n) -> Dict[str, Any]:\n    info: Dict[str, Any] = {\"title\": title, \"version\": version}\n    if description:\n        info[\"description\"] = description\n    if terms_of_service:\n        info[\"termsOfService\"] = terms_of_service\n    if contact:\n        info[\"contact\"] = contact\n    if license_info:\n        info[\"license\"] = license_info\n    output: Dict[str, Any] = {\"openapi\": openapi_version, \"info\": info}\n    if servers:\n        output[\"servers\"] = servers\n    components: Dict[str, Dict[str, Any]] = {}\n    paths: Dict[str, Dict[str, Any]] = {}\n    flat_models = get_flat_models_from_routes(routes)\n    model_name_map = get_model_name_map(flat_models)\n    definitions = get_model_definitions(\n        flat_models=flat_models, model_name_map=model_name_map\n    )\n    for route in routes:\n        if isinstance(route, routing.APIRoute):\n            result = get_openapi_path(route=route, model_name_map=model_name_map)\n            if result:\n                path, security_schemes, path_definitions = result\n                if path:\n                    paths.setdefault(route.path_format, {}).update(path)\n                if security_schemes:\n                    components.setdefault(\"securitySchemes\", {}).update(\n                        security_schemes\n                    )\n                if path_definitions:\n                    definitions.update(path_definitions)\n    if definitions:\n        components[\"schemas\"] = {k: definitions[k] for k in sorted(definitions)}\n    if components:\n        output[\"components\"] = components\n    output[\"paths\"] = paths\n    if tags:\n        output[\"tags\"] = tags\n    return jsonable_encoder(OpenAPI(**output), by_alias=True, exclude_none=True)", "is_method": false, "function_description": "Generates an OpenAPI specification dictionary from given API metadata and routes, enabling standardized API documentation and client generation. This function consolidates route info, models, and metadata into a compliant OpenAPI description."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/docs.py", "function": "get_swagger_ui_html", "line_number": 8, "body": "def get_swagger_ui_html(\n    *,\n    openapi_url: str,\n    title: str,\n    swagger_js_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui-bundle.js\",\n    swagger_css_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui.css\",\n    swagger_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    oauth2_redirect_url: Optional[str] = None,\n    init_oauth: Optional[Dict[str, Any]] = None,\n) -> HTMLResponse:\n\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{swagger_css_url}\">\n    <link rel=\"shortcut icon\" href=\"{swagger_favicon_url}\">\n    <title>{title}</title>\n    </head>\n    <body>\n    <div id=\"swagger-ui\">\n    </div>\n    <script src=\"{swagger_js_url}\"></script>\n    <!-- `SwaggerUIBundle` is now available on the page -->\n    <script>\n    const ui = SwaggerUIBundle({{\n        url: '{openapi_url}',\n    \"\"\"\n\n    if oauth2_redirect_url:\n        html += f\"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',\"\n\n    html += \"\"\"\n        dom_id: '#swagger-ui',\n        presets: [\n        SwaggerUIBundle.presets.apis,\n        SwaggerUIBundle.SwaggerUIStandalonePreset\n        ],\n        layout: \"BaseLayout\",\n        deepLinking: true,\n        showExtensions: true,\n        showCommonExtensions: true\n    })\"\"\"\n\n    if init_oauth:\n        html += f\"\"\"\n        ui.initOAuth({json.dumps(jsonable_encoder(init_oauth))})\n        \"\"\"\n\n    html += \"\"\"\n    </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)", "is_method": false, "function_description": "Generates an HTML page that embeds Swagger UI to visualize and interact with an OpenAPI specification, supporting OAuth2 and customizable UI resources. This function enables easy API documentation display and testing within web applications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/docs.py", "function": "get_redoc_html", "line_number": 65, "body": "def get_redoc_html(\n    *,\n    openapi_url: str,\n    title: str,\n    redoc_js_url: str = \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\",\n    redoc_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    with_google_fonts: bool = True,\n) -> HTMLResponse:\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>{title}</title>\n    <!-- needed for adaptive design -->\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    \"\"\"\n    if with_google_fonts:\n        html += \"\"\"\n    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n    \"\"\"\n    html += f\"\"\"\n    <link rel=\"shortcut icon\" href=\"{redoc_favicon_url}\">\n    <!--\n    ReDoc doesn't change outer page styles\n    -->\n    <style>\n      body {{\n        margin: 0;\n        padding: 0;\n      }}\n    </style>\n    </head>\n    <body>\n    <redoc spec-url=\"{openapi_url}\"></redoc>\n    <script src=\"{redoc_js_url}\"> </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)", "is_method": false, "function_description": "Generates an HTML page embedding the ReDoc API documentation viewer for a specified OpenAPI URL, customizable with title, favicon, script URLs, and optional Google Fonts inclusion. Useful for serving interactive API docs in web frameworks."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/docs.py", "function": "get_swagger_ui_oauth2_redirect_html", "line_number": 107, "body": "def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n    html = \"\"\"\n    <!DOCTYPE html>\n    <html lang=\"en-US\">\n    <body onload=\"run()\">\n    </body>\n    </html>\n    <script>\n        'use strict';\n        function run () {\n            var oauth2 = window.opener.swaggerUIRedirectOauth2;\n            var sentState = oauth2.state;\n            var redirectUrl = oauth2.redirectUrl;\n            var isValid, qp, arr;\n\n            if (/code|token|error/.test(window.location.hash)) {\n                qp = window.location.hash.substring(1);\n            } else {\n                qp = location.search.substring(1);\n            }\n\n            arr = qp.split(\"&\")\n            arr.forEach(function (v,i,_arr) { _arr[i] = '\"' + v.replace('=', '\":\"') + '\"';})\n            qp = qp ? JSON.parse('{' + arr.join() + '}',\n                    function (key, value) {\n                        return key === \"\" ? value : decodeURIComponent(value)\n                    }\n            ) : {}\n\n            isValid = qp.state === sentState\n\n            if ((\n            oauth2.auth.schema.get(\"flow\") === \"accessCode\"||\n            oauth2.auth.schema.get(\"flow\") === \"authorizationCode\"\n            ) && !oauth2.auth.code) {\n                if (!isValid) {\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"warning\",\n                        message: \"Authorization may be unsafe, passed state was changed in server Passed state wasn't returned from auth server\"\n                    });\n                }\n\n                if (qp.code) {\n                    delete oauth2.state;\n                    oauth2.auth.code = qp.code;\n                    oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\n                } else {\n                    let oauthErrorMsg\n                    if (qp.error) {\n                        oauthErrorMsg = \"[\"+qp.error+\"]: \" +\n                            (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\n                            (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\n                    }\n\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"error\",\n                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server\"\n                    });\n                }\n            } else {\n                oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\n            }\n            window.close();\n        }\n    </script>\n        \"\"\"\n    return HTMLResponse(content=html)", "is_method": false, "function_description": "Returns an HTML response containing the Swagger UI OAuth2 redirect page that processes OAuth2 authorization responses and triggers appropriate callbacks for handling tokens or authorization codes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "check_file_field", "line_number": 89, "body": "def check_file_field(field: ModelField) -> None:\n    field_info = field.field_info\n    if isinstance(field_info, params.Form):\n        try:\n            # __version__ is available in both multiparts, and can be mocked\n            from multipart import __version__  # type: ignore\n\n            assert __version__\n            try:\n                # parse_options_header is only available in the right multipart\n                from multipart.multipart import parse_options_header  # type: ignore\n\n                assert parse_options_header\n            except ImportError:\n                logger.error(multipart_incorrect_install_error)\n                raise RuntimeError(multipart_incorrect_install_error)\n        except ImportError:\n            logger.error(multipart_not_installed_error)\n            raise RuntimeError(multipart_not_installed_error)", "is_method": false, "function_description": "Utility function that verifies if a file upload field uses a properly installed and compatible multipart package, raising an error if the required multipart dependencies are missing or incorrectly installed."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_param_sub_dependant", "line_number": 110, "body": "def get_param_sub_dependant(\n    *, param: inspect.Parameter, path: str, security_scopes: Optional[List[str]] = None\n) -> Dependant:\n    depends: params.Depends = param.default\n    if depends.dependency:\n        dependency = depends.dependency\n    else:\n        dependency = param.annotation\n    return get_sub_dependant(\n        depends=depends,\n        dependency=dependency,\n        path=path,\n        name=param.name,\n        security_scopes=security_scopes,\n    )", "is_method": false, "function_description": "This function creates a Dependant object representing a sub-dependency for a given parameter, facilitating extraction and organization of nested dependencies in dependency injection systems with optional security scope handling."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_parameterless_sub_dependant", "line_number": 127, "body": "def get_parameterless_sub_dependant(*, depends: params.Depends, path: str) -> Dependant:\n    assert callable(\n        depends.dependency\n    ), \"A parameter-less dependency must have a callable dependency\"\n    return get_sub_dependant(depends=depends, dependency=depends.dependency, path=path)", "is_method": false, "function_description": "Utility function that extracts a parameter-less sub-dependency callable from a dependency descriptor, facilitating dependency resolution within a given path context."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_sub_dependant", "line_number": 134, "body": "def get_sub_dependant(\n    *,\n    depends: params.Depends,\n    dependency: Callable[..., Any],\n    path: str,\n    name: Optional[str] = None,\n    security_scopes: Optional[List[str]] = None,\n) -> Dependant:\n    security_requirement = None\n    security_scopes = security_scopes or []\n    if isinstance(depends, params.Security):\n        dependency_scopes = depends.scopes\n        security_scopes.extend(dependency_scopes)\n    if isinstance(dependency, SecurityBase):\n        use_scopes: List[str] = []\n        if isinstance(dependency, (OAuth2, OpenIdConnect)):\n            use_scopes = security_scopes\n        security_requirement = SecurityRequirement(\n            security_scheme=dependency, scopes=use_scopes\n        )\n    sub_dependant = get_dependant(\n        path=path,\n        call=dependency,\n        name=name,\n        security_scopes=security_scopes,\n        use_cache=depends.use_cache,\n    )\n    if security_requirement:\n        sub_dependant.security_requirements.append(security_requirement)\n    sub_dependant.security_scopes = security_scopes\n    return sub_dependant", "is_method": false, "function_description": "Utility function that constructs a Dependant object representing a specific dependency callable, incorporating its security scopes and requirements to support dependency injection with integrated security handling. It enables resolving sub-dependencies with proper authorization context."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_flat_dependant", "line_number": 170, "body": "def get_flat_dependant(\n    dependant: Dependant,\n    *,\n    skip_repeats: bool = False,\n    visited: Optional[List[CacheKey]] = None,\n) -> Dependant:\n    if visited is None:\n        visited = []\n    visited.append(dependant.cache_key)\n\n    flat_dependant = Dependant(\n        path_params=dependant.path_params.copy(),\n        query_params=dependant.query_params.copy(),\n        header_params=dependant.header_params.copy(),\n        cookie_params=dependant.cookie_params.copy(),\n        body_params=dependant.body_params.copy(),\n        security_schemes=dependant.security_requirements.copy(),\n        use_cache=dependant.use_cache,\n        path=dependant.path,\n    )\n    for sub_dependant in dependant.dependencies:\n        if skip_repeats and sub_dependant.cache_key in visited:\n            continue\n        flat_sub = get_flat_dependant(\n            sub_dependant, skip_repeats=skip_repeats, visited=visited\n        )\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant", "is_method": false, "function_description": "Utility function that recursively flattens a Dependant's nested dependencies into a single combined Dependant with consolidated parameters and security requirements, optionally avoiding repeated dependency processing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_flat_params", "line_number": 205, "body": "def get_flat_params(dependant: Dependant) -> List[ModelField]:\n    flat_dependant = get_flat_dependant(dependant, skip_repeats=True)\n    return (\n        flat_dependant.path_params\n        + flat_dependant.query_params\n        + flat_dependant.header_params\n        + flat_dependant.cookie_params\n    )", "is_method": false, "function_description": "Core utility function that extracts all flattened parameter fields\u2014path, query, header, and cookie\u2014from a Dependant instance, facilitating unified access to these parameters for processing in web request handling."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "is_scalar_field", "line_number": 215, "body": "def is_scalar_field(field: ModelField) -> bool:\n    field_info = field.field_info\n    if not (\n        field.shape == SHAPE_SINGLETON\n        and not lenient_issubclass(field.type_, BaseModel)\n        and not lenient_issubclass(field.type_, sequence_types + (dict,))\n        and not dataclasses.is_dataclass(field.type_)\n        and not isinstance(field_info, params.Body)\n    ):\n        return False\n    if field.sub_fields:\n        if not all(is_scalar_field(f) for f in field.sub_fields):\n            return False\n    return True", "is_method": false, "function_description": "Determines whether a given model field represents a scalar (non-composite, non-collection) value, supporting validation of simple data types in complex model definitions."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "is_scalar_sequence_field", "line_number": 231, "body": "def is_scalar_sequence_field(field: ModelField) -> bool:\n    if (field.shape in sequence_shapes) and not lenient_issubclass(\n        field.type_, BaseModel\n    ):\n        if field.sub_fields is not None:\n            for sub_field in field.sub_fields:\n                if not is_scalar_field(sub_field):\n                    return False\n        return True\n    if lenient_issubclass(field.type_, sequence_types):\n        return True\n    return False", "is_method": false, "function_description": "Utility function that determines if a given model field represents a sequence of scalar values, distinguishing it from nested model types for accurate data type handling."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_typed_signature", "line_number": 245, "body": "def get_typed_signature(call: Callable[..., Any]) -> inspect.Signature:\n    signature = inspect.signature(call)\n    globalns = getattr(call, \"__globals__\", {})\n    typed_params = [\n        inspect.Parameter(\n            name=param.name,\n            kind=param.kind,\n            default=param.default,\n            annotation=get_typed_annotation(param, globalns),\n        )\n        for param in signature.parameters.values()\n    ]\n    typed_signature = inspect.Signature(typed_params)\n    return typed_signature", "is_method": false, "function_description": "Function that extracts a callable's signature including accurate type annotations by resolving them in the callable's global context, aiding in precise introspection or type analysis of functions."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_typed_annotation", "line_number": 261, "body": "def get_typed_annotation(param: inspect.Parameter, globalns: Dict[str, Any]) -> Any:\n    annotation = param.annotation\n    if isinstance(annotation, str):\n        annotation = ForwardRef(annotation)\n        annotation = evaluate_forwardref(annotation, globalns, globalns)\n    return annotation", "is_method": false, "function_description": "Utility function that resolves and returns the actual type annotation of a function parameter, including handling and evaluating forward-referenced (string) annotations using the given global namespace."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_dependant", "line_number": 269, "body": "def get_dependant(\n    *,\n    path: str,\n    call: Callable[..., Any],\n    name: Optional[str] = None,\n    security_scopes: Optional[List[str]] = None,\n    use_cache: bool = True,\n) -> Dependant:\n    path_param_names = get_path_param_names(path)\n    endpoint_signature = get_typed_signature(call)\n    signature_params = endpoint_signature.parameters\n    dependant = Dependant(call=call, name=name, path=path, use_cache=use_cache)\n    for param_name, param in signature_params.items():\n        if isinstance(param.default, params.Depends):\n            sub_dependant = get_param_sub_dependant(\n                param=param, path=path, security_scopes=security_scopes\n            )\n            dependant.dependencies.append(sub_dependant)\n            continue\n        if add_non_field_param_to_dependency(param=param, dependant=dependant):\n            continue\n        param_field = get_param_field(\n            param=param, default_field_info=params.Query, param_name=param_name\n        )\n        if param_name in path_param_names:\n            assert is_scalar_field(\n                field=param_field\n            ), \"Path params must be of one of the supported types\"\n            if isinstance(param.default, params.Path):\n                ignore_default = False\n            else:\n                ignore_default = True\n            param_field = get_param_field(\n                param=param,\n                param_name=param_name,\n                default_field_info=params.Path,\n                force_type=params.ParamTypes.path,\n                ignore_default=ignore_default,\n            )\n            add_param_to_fields(field=param_field, dependant=dependant)\n        elif is_scalar_field(field=param_field):\n            add_param_to_fields(field=param_field, dependant=dependant)\n        elif isinstance(\n            param.default, (params.Query, params.Header)\n        ) and is_scalar_sequence_field(param_field):\n            add_param_to_fields(field=param_field, dependant=dependant)\n        else:\n            field_info = param_field.field_info\n            assert isinstance(\n                field_info, params.Body\n            ), f\"Param: {param_field.name} can only be a request body, using Body(...)\"\n            dependant.body_params.append(param_field)\n    return dependant", "is_method": false, "function_description": "Constructs a dependency representation of a callable endpoint, parsing its parameters based on the route path and request context to enable automated request handling and validation in a web framework."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "add_non_field_param_to_dependency", "line_number": 324, "body": "def add_non_field_param_to_dependency(\n    *, param: inspect.Parameter, dependant: Dependant\n) -> Optional[bool]:\n    if lenient_issubclass(param.annotation, Request):\n        dependant.request_param_name = param.name\n        return True\n    elif lenient_issubclass(param.annotation, WebSocket):\n        dependant.websocket_param_name = param.name\n        return True\n    elif lenient_issubclass(param.annotation, HTTPConnection):\n        dependant.http_connection_param_name = param.name\n        return True\n    elif lenient_issubclass(param.annotation, Response):\n        dependant.response_param_name = param.name\n        return True\n    elif lenient_issubclass(param.annotation, BackgroundTasks):\n        dependant.background_tasks_param_name = param.name\n        return True\n    elif lenient_issubclass(param.annotation, SecurityScopes):\n        dependant.security_scopes_param_name = param.name\n        return True\n    return None", "is_method": false, "function_description": "This function assigns special parameter names related to request, response, or connection objects to a dependency, enabling precise injection of these non-field parameters during dependency resolution. It helps frameworks handle contextual parameters like requests, websockets, and background tasks."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_param_field", "line_number": 348, "body": "def get_param_field(\n    *,\n    param: inspect.Parameter,\n    param_name: str,\n    default_field_info: Type[params.Param] = params.Param,\n    force_type: Optional[params.ParamTypes] = None,\n    ignore_default: bool = False,\n) -> ModelField:\n    default_value = Required\n    had_schema = False\n    if not param.default == param.empty and ignore_default is False:\n        default_value = param.default\n    if isinstance(default_value, FieldInfo):\n        had_schema = True\n        field_info = default_value\n        default_value = field_info.default\n        if (\n            isinstance(field_info, params.Param)\n            and getattr(field_info, \"in_\", None) is None\n        ):\n            field_info.in_ = default_field_info.in_\n        if force_type:\n            field_info.in_ = force_type  # type: ignore\n    else:\n        field_info = default_field_info(default_value)\n    required = default_value == Required\n    annotation: Any = Any\n    if not param.annotation == param.empty:\n        annotation = param.annotation\n    annotation = get_annotation_from_field_info(annotation, field_info, param_name)\n    if not field_info.alias and getattr(field_info, \"convert_underscores\", None):\n        alias = param.name.replace(\"_\", \"-\")\n    else:\n        alias = field_info.alias or param.name\n    field = create_response_field(\n        name=param.name,\n        type_=annotation,\n        default=None if required else default_value,\n        alias=alias,\n        required=required,\n        field_info=field_info,\n    )\n    field.required = required\n    if not had_schema and not is_scalar_field(field=field):\n        field.field_info = params.Body(field_info.default)\n\n    return field", "is_method": false, "function_description": "Utility function that converts a Python function parameter into a framework-specific ModelField, encapsulating type, default value, aliasing, and validation metadata for use in API parameter declaration."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "add_param_to_fields", "line_number": 397, "body": "def add_param_to_fields(*, field: ModelField, dependant: Dependant) -> None:\n    field_info = cast(params.Param, field.field_info)\n    if field_info.in_ == params.ParamTypes.path:\n        dependant.path_params.append(field)\n    elif field_info.in_ == params.ParamTypes.query:\n        dependant.query_params.append(field)\n    elif field_info.in_ == params.ParamTypes.header:\n        dependant.header_params.append(field)\n    else:\n        assert (\n            field_info.in_ == params.ParamTypes.cookie\n        ), f\"non-body parameters must be in path, query, header or cookie: {field.name}\"\n        dependant.cookie_params.append(field)", "is_method": false, "function_description": "Utility function that classifies a given model field by its parameter type and adds it to the corresponding parameter list of a dependant, supporting organized management of HTTP request parameters."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "is_coroutine_callable", "line_number": 412, "body": "def is_coroutine_callable(call: Callable[..., Any]) -> bool:\n    if inspect.isroutine(call):\n        return inspect.iscoroutinefunction(call)\n    if inspect.isclass(call):\n        return False\n    call = getattr(call, \"__call__\", None)\n    return inspect.iscoroutinefunction(call)", "is_method": false, "function_description": "Function that determines if a provided callable object is an asynchronous coroutine function, enabling distinction between regular and coroutine callables for async-aware processing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "is_async_gen_callable", "line_number": 421, "body": "def is_async_gen_callable(call: Callable[..., Any]) -> bool:\n    if inspect.isasyncgenfunction(call):\n        return True\n    call = getattr(call, \"__call__\", None)\n    return inspect.isasyncgenfunction(call)", "is_method": false, "function_description": "Utility function that determines if a given callable is an asynchronous generator function, supporting both direct callables and callable objects. It helps identify async generator capabilities in functions or objects."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "is_gen_callable", "line_number": 428, "body": "def is_gen_callable(call: Callable[..., Any]) -> bool:\n    if inspect.isgeneratorfunction(call):\n        return True\n    call = getattr(call, \"__call__\", None)\n    return inspect.isgeneratorfunction(call)", "is_method": false, "function_description": "Utility function that determines whether a given callable or its __call__ method is a generator function, assisting in identifying generator-based callables for control flow or iteration handling."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "request_params_to_args", "line_number": 577, "body": "def request_params_to_args(\n    required_params: Sequence[ModelField],\n    received_params: Union[Mapping[str, Any], QueryParams, Headers],\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values = {}\n    errors = []\n    for field in required_params:\n        if is_scalar_sequence_field(field) and isinstance(\n            received_params, (QueryParams, Headers)\n        ):\n            value = received_params.getlist(field.alias) or field.default\n        else:\n            value = received_params.get(field.alias)\n        field_info = field.field_info\n        assert isinstance(\n            field_info, params.Param\n        ), \"Params must be subclasses of Param\"\n        if value is None:\n            if field.required:\n                errors.append(\n                    ErrorWrapper(\n                        MissingError(), loc=(field_info.in_.value, field.alias)\n                    )\n                )\n            else:\n                values[field.name] = deepcopy(field.default)\n            continue\n        v_, errors_ = field.validate(\n            value, values, loc=(field_info.in_.value, field.alias)\n        )\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        else:\n            values[field.name] = v_\n    return values, errors", "is_method": false, "function_description": "Converts and validates incoming request parameters against required model fields, returning a dictionary of valid arguments and a list of validation errors. It supports handling of query parameters, headers, and required field defaults for robust API parameter parsing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_missing_field_error", "line_number": 699, "body": "def get_missing_field_error(loc: Tuple[str, ...]) -> ErrorWrapper:\n    missing_field_error = ErrorWrapper(MissingError(), loc=loc)\n    return missing_field_error", "is_method": false, "function_description": "Utility function that creates an error object indicating a required field is missing at a specified location, facilitating consistent error reporting in data validation processes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_schema_compatible_field", "line_number": 704, "body": "def get_schema_compatible_field(*, field: ModelField) -> ModelField:\n    out_field = field\n    if lenient_issubclass(field.type_, UploadFile):\n        use_type: type = bytes\n        if field.shape in sequence_shapes:\n            use_type = List[bytes]\n        out_field = create_response_field(\n            name=field.name,\n            type_=use_type,\n            class_validators=field.class_validators,\n            model_config=field.model_config,\n            default=field.default,\n            required=field.required,\n            alias=field.alias,\n            field_info=field.field_info,\n        )\n    return out_field", "is_method": false, "function_description": "Utility function that transforms fields of type UploadFile into schema-compatible byte or byte list fields, facilitating their inclusion in data validation and serialization workflows."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_body_field", "line_number": 723, "body": "def get_body_field(*, dependant: Dependant, name: str) -> Optional[ModelField]:\n    flat_dependant = get_flat_dependant(dependant)\n    if not flat_dependant.body_params:\n        return None\n    first_param = flat_dependant.body_params[0]\n    field_info = first_param.field_info\n    embed = getattr(field_info, \"embed\", None)\n    body_param_names_set = {param.name for param in flat_dependant.body_params}\n    if len(body_param_names_set) == 1 and not embed:\n        final_field = get_schema_compatible_field(field=first_param)\n        check_file_field(final_field)\n        return final_field\n    # If one field requires to embed, all have to be embedded\n    # in case a sub-dependency is evaluated with a single unique body field\n    # That is combined (embedded) with other body fields\n    for param in flat_dependant.body_params:\n        setattr(param.field_info, \"embed\", True)\n    model_name = \"Body_\" + name\n    BodyModel: Type[BaseModel] = create_model(model_name)\n    for f in flat_dependant.body_params:\n        BodyModel.__fields__[f.name] = get_schema_compatible_field(field=f)\n    required = any(True for f in flat_dependant.body_params if f.required)\n\n    BodyFieldInfo_kwargs: Dict[str, Any] = dict(default=None)\n    if any(isinstance(f.field_info, params.File) for f in flat_dependant.body_params):\n        BodyFieldInfo: Type[params.Body] = params.File\n    elif any(isinstance(f.field_info, params.Form) for f in flat_dependant.body_params):\n        BodyFieldInfo = params.Form\n    else:\n        BodyFieldInfo = params.Body\n\n        body_param_media_types = [\n            getattr(f.field_info, \"media_type\")\n            for f in flat_dependant.body_params\n            if isinstance(f.field_info, params.Body)\n        ]\n        if len(set(body_param_media_types)) == 1:\n            BodyFieldInfo_kwargs[\"media_type\"] = body_param_media_types[0]\n    final_field = create_response_field(\n        name=\"body\",\n        type_=BodyModel,\n        required=required,\n        alias=\"body\",\n        field_info=BodyFieldInfo(**BodyFieldInfo_kwargs),\n    )\n    check_file_field(final_field)\n    return final_field", "is_method": false, "function_description": "Utility function that constructs or retrieves a Pydantic model field representing the request body for a given dependency, supporting embedding, file, form, or custom media types in API request handling."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "get_security", "line_number": 27, "body": "def get_security(sec=Security(HTTPBasic())):\n    return sec", "is_method": false, "function_description": "Returns the provided security scheme object, defaulting to HTTP Basic authentication. This function supplies the security dependency for endpoint protection in web frameworks."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "get_security_oauth2", "line_number": 42, "body": "def get_security_oauth2(sec=Security(reusable_oauth2, scopes=[\"read:user\"])):\n    return sec", "is_method": false, "function_description": "Returns a configured security dependency for OAuth2 authentication with predefined user read scope, enabling consistent authorization handling in API endpoints."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "post_token", "line_number": 47, "body": "def post_token(request_data: OAuth2PasswordRequestForm = Form(...)):\n    data = request_data.parse()\n    access_token = data.username + \":\" + data.password\n    return {\"access_token\": access_token}", "is_method": false, "function_description": "Function that creates a simple access token by concatenating username and password from an OAuth2 password request form. It provides a basic token generation service for authentication workflows."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "require_token", "line_number": 94, "body": "def require_token(\n    token: str = Security(reusable_oauth2, scopes=[\"read:user\", \"write:user\"])\n):\n    raw_token = token.replace(\"Bearer \", \"\")\n    # Never do this plaintext password usage in production\n    username, password = raw_token.split(\":\")\n    return TokenUserData(username=username, password=password)", "is_method": false, "function_description": "Function that extracts username and password from a provided bearer token string, facilitating authentication by parsing token credentials into a structured user data object."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "require_user", "line_number": 103, "body": "def require_user(\n    db: FakeDB = Depends(connection_manager),\n    user_data: TokenUserData = Depends(require_token),\n):\n    return db.data[user_data.username]", "is_method": false, "function_description": "Retrieves user information from the database based on authentication token data. It provides a convenient way to obtain the current user's data for use in authenticated service functions."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "get_dependency", "line_number": 117, "body": "def get_dependency(user: UserInDB = Depends(require_user)):\n    return user", "is_method": false, "function_description": "Returns the authenticated user object, serving as a dependency provider for route handlers that require user information after authentication."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "__call__", "line_number": 75, "body": "def __call__(self):\n        return self.db", "is_method": true, "class_name": "DBConnectionManager", "function_description": "Returns the database connection managed by the DBConnectionManager instance, allowing other components to access the database interface easily."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/gitter_releases_bot.py", "function": "get_github_graphql", "line_number": 17, "body": "def get_github_graphql(tag_name: str):\n    github_graphql = \"\"\"\n    {\n    repository(owner: \"tiangolo\", name: \"fastapi\") {\n        release (tagName: \"{{tag_name}}\" ) {\n        description\n        }\n      }\n    }\n    \"\"\"\n    github_graphql = github_graphql.replace(\"{{tag_name}}\", tag_name)\n    return github_graphql", "is_method": false, "function_description": "Constructs a GitHub GraphQL query string to retrieve the description of a specific release by its tag in the \"tiangolo/fastapi\" repository. This function facilitates automated querying of release information based on version tags."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/gitter_releases_bot.py", "function": "get_github_release_text", "line_number": 31, "body": "def get_github_release_text(tag_name: str):\n    url = \"https://api.github.com/graphql\"\n    headers = {\"Authorization\": f\"Bearer {github_token}\"}\n    github_graphql = get_github_graphql(tag_name=tag_name)\n    response = requests.post(url, json={\"query\": github_graphql}, headers=headers)\n    assert response.status_code == 200\n    data = response.json()\n    return data[\"data\"][\"repository\"][\"release\"][\"description\"]", "is_method": false, "function_description": "Function that fetches and returns the description text of a specific GitHub release identified by its tag name using GitHub's GraphQL API."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/gitter_releases_bot.py", "function": "send_gitter_message", "line_number": 52, "body": "def send_gitter_message(text: str):\n    headers = {\"Authorization\": f\"Bearer {gitter_token}\"}\n    url = f\"https://api.gitter.im/v1/rooms/{room_id}/chatMessages\"\n    data = {\"text\": text}\n    response = requests.post(url, headers=headers, json=data)\n    assert response.status_code == 200", "is_method": false, "function_description": "Sends a text message to a specified Gitter chat room using the Gitter API. This function enables automated posting of messages to Gitter channels for notifications or interactions."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_en_config", "line_number": 30, "body": "def get_en_config() -> dict:\n    return mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))", "is_method": false, "function_description": "Utility function that loads and returns the English language configuration from a YAML file for MkDocs documentation builds."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_lang_paths", "line_number": 34, "body": "def get_lang_paths():\n    return sorted(docs_path.iterdir())", "is_method": false, "function_description": "Returns a sorted list of language-specific documentation paths available in the docs directory, facilitating easy access to different language versions of documentation files."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "lang_callback", "line_number": 38, "body": "def lang_callback(lang: Optional[str]):\n    if lang is None:\n        return\n    if not lang.isalpha() or len(lang) != 2:\n        typer.echo(\"Use a 2 letter language code, like: es\")\n        raise typer.Abort()\n    lang = lang.lower()\n    return lang", "is_method": false, "function_description": "Function that validates and normalizes a two-letter language code input, ensuring correct format before further processing in language-related workflows."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "complete_existing_lang", "line_number": 48, "body": "def complete_existing_lang(incomplete: str):\n    lang_path: Path\n    for lang_path in get_lang_paths():\n        if lang_path.is_dir() and lang_path.name.startswith(incomplete):\n            yield lang_path.name", "is_method": false, "function_description": "Function that yields language names starting with a given incomplete prefix by scanning available language directories, useful for autocompletion or language discovery features."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_base_lang_config", "line_number": 55, "body": "def get_base_lang_config(lang: str):\n    en_config = get_en_config()\n    fastapi_url_base = \"https://fastapi.tiangolo.com/\"\n    new_config = en_config.copy()\n    new_config[\"site_url\"] = en_config[\"site_url\"] + f\"{lang}/\"\n    new_config[\"theme\"][\"logo\"] = fastapi_url_base + en_config[\"theme\"][\"logo\"]\n    new_config[\"theme\"][\"favicon\"] = fastapi_url_base + en_config[\"theme\"][\"favicon\"]\n    new_config[\"theme\"][\"language\"] = lang\n    new_config[\"nav\"] = en_config[\"nav\"][:2]\n    extra_css = []\n    css: str\n    for css in en_config[\"extra_css\"]:\n        if css.startswith(\"http\"):\n            extra_css.append(css)\n        else:\n            extra_css.append(fastapi_url_base + css)\n    new_config[\"extra_css\"] = extra_css\n\n    extra_js = []\n    js: str\n    for js in en_config[\"extra_javascript\"]:\n        if js.startswith(\"http\"):\n            extra_js.append(js)\n        else:\n            extra_js.append(fastapi_url_base + js)\n    new_config[\"extra_javascript\"] = extra_js\n    return new_config", "is_method": false, "function_description": "Returns a modified language-specific configuration based on the English config, updating URLs and theme assets for localization. It enables consistent multilingual site setups by adjusting navigation and resource links according to the specified language."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "new_lang", "line_number": 85, "body": "def new_lang(lang: str = typer.Argument(..., callback=lang_callback)):\n    \"\"\"\n    Generate a new docs translation directory for the language LANG.\n\n    LANG should be a 2-letter language code, like: en, es, de, pt, etc.\n    \"\"\"\n    new_path: Path = Path(\"docs\") / lang\n    if new_path.exists():\n        typer.echo(f\"The language was already created: {lang}\")\n        raise typer.Abort()\n    new_path.mkdir()\n    new_config = get_base_lang_config(lang)\n    new_config_path: Path = Path(new_path) / mkdocs_name\n    new_config_path.write_text(\n        yaml.dump(new_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    new_config_docs_path: Path = new_path / \"docs\"\n    new_config_docs_path.mkdir()\n    en_index_path: Path = en_docs_path / \"docs\" / \"index.md\"\n    new_index_path: Path = new_config_docs_path / \"index.md\"\n    en_index_content = en_index_path.read_text(encoding=\"utf-8\")\n    new_index_content = f\"{missing_translation_snippet}\\n\\n{en_index_content}\"\n    new_index_path.write_text(new_index_content, encoding=\"utf-8\")\n    new_overrides_gitignore_path = new_path / \"overrides\" / \".gitignore\"\n    new_overrides_gitignore_path.parent.mkdir(parents=True, exist_ok=True)\n    new_overrides_gitignore_path.write_text(\"\")\n    typer.secho(f\"Successfully initialized: {new_path}\", color=typer.colors.GREEN)\n    update_languages(lang=None)", "is_method": false, "function_description": "Creates a new documentation translation directory for a specified 2-letter language code, initializing necessary files and structure to support translated docs. Useful for extending multilingual documentation in a standardized way."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "build_lang", "line_number": 117, "body": "def build_lang(\n    lang: str = typer.Argument(\n        ..., callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Build the docs for a language, filling missing pages with translation notifications.\n    \"\"\"\n    lang_path: Path = Path(\"docs\") / lang\n    if not lang_path.is_dir():\n        typer.echo(f\"The language translation doesn't seem to exist yet: {lang}\")\n        raise typer.Abort()\n    typer.echo(f\"Building docs for: {lang}\")\n    build_dir_path = Path(\"docs_build\")\n    build_dir_path.mkdir(exist_ok=True)\n    build_lang_path = build_dir_path / lang\n    en_lang_path = Path(\"docs/en\")\n    site_path = Path(\"site\").absolute()\n    if lang == \"en\":\n        dist_path = site_path\n    else:\n        dist_path: Path = site_path / lang\n    shutil.rmtree(build_lang_path, ignore_errors=True)\n    shutil.copytree(lang_path, build_lang_path)\n    shutil.copytree(en_docs_path / \"data\", build_lang_path / \"data\")\n    overrides_src = en_docs_path / \"overrides\"\n    overrides_dest = build_lang_path / \"overrides\"\n    for path in overrides_src.iterdir():\n        dest_path = overrides_dest / path.name\n        if not dest_path.exists():\n            shutil.copy(path, dest_path)\n    en_config_path: Path = en_lang_path / mkdocs_name\n    en_config: dict = mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))\n    nav = en_config[\"nav\"]\n    lang_config_path: Path = lang_path / mkdocs_name\n    lang_config: dict = mkdocs.utils.yaml_load(\n        lang_config_path.read_text(encoding=\"utf-8\")\n    )\n    lang_nav = lang_config[\"nav\"]\n    # Exclude first 2 entries FastAPI and Languages, for custom handling\n    use_nav = nav[2:]\n    lang_use_nav = lang_nav[2:]\n    file_to_nav = get_file_to_nav_map(use_nav)\n    sections = get_sections(use_nav)\n    lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    use_lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    for file in file_to_nav:\n        file_path = Path(file)\n        lang_file_path: Path = build_lang_path / \"docs\" / file_path\n        en_file_path: Path = en_lang_path / \"docs\" / file_path\n        lang_file_path.parent.mkdir(parents=True, exist_ok=True)\n        if not lang_file_path.is_file():\n            en_text = en_file_path.read_text(encoding=\"utf-8\")\n            lang_text = get_text_with_translate_missing(en_text)\n            lang_file_path.write_text(lang_text, encoding=\"utf-8\")\n            file_key = file_to_nav[file]\n            use_lang_file_to_nav[file] = file_key\n            if file_key:\n                composite_key = ()\n                new_key = ()\n                for key_part in file_key:\n                    composite_key += (key_part,)\n                    key_first_file = sections[composite_key]\n                    if key_first_file in lang_file_to_nav:\n                        new_key = lang_file_to_nav[key_first_file]\n                    else:\n                        new_key += (key_part,)\n                use_lang_file_to_nav[file] = new_key\n    key_to_section = {(): []}\n    for file, orig_file_key in file_to_nav.items():\n        if file in use_lang_file_to_nav:\n            file_key = use_lang_file_to_nav[file]\n        else:\n            file_key = orig_file_key\n        section = get_key_section(key_to_section=key_to_section, key=file_key)\n        section.append(file)\n    new_nav = key_to_section[()]\n    export_lang_nav = [lang_nav[0], nav[1]] + new_nav\n    lang_config[\"nav\"] = export_lang_nav\n    build_lang_config_path: Path = build_lang_path / mkdocs_name\n    build_lang_config_path.write_text(\n        yaml.dump(lang_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    current_dir = os.getcwd()\n    os.chdir(build_lang_path)\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(dist_path)))\n    os.chdir(current_dir)\n    typer.secho(f\"Successfully built docs for: {lang}\", color=typer.colors.GREEN)", "is_method": false, "function_description": "Builds and compiles documentation for a specified language, filling in missing pages with translation placeholders and producing a complete site build. This facilitates managing multilingual documentation with consistent structure and fallback notifications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "generate_readme_content", "line_number": 220, "body": "def generate_readme_content():\n    en_index = en_docs_path / \"docs\" / \"index.md\"\n    content = en_index.read_text(\"utf-8\")\n    match_start = re.search(r\"<!-- sponsors -->\", content)\n    match_end = re.search(r\"<!-- /sponsors -->\", content)\n    sponsors_data_path = en_docs_path / \"data\" / \"sponsors.yml\"\n    sponsors = mkdocs.utils.yaml_load(sponsors_data_path.read_text(encoding=\"utf-8\"))\n    if not (match_start and match_end):\n        raise RuntimeError(\"Couldn't auto-generate sponsors section\")\n    pre_end = match_start.end()\n    post_start = match_end.start()\n    template = Template(index_sponsors_template)\n    message = template.render(sponsors=sponsors)\n    pre_content = content[:pre_end]\n    post_content = content[post_start:]\n    new_content = pre_content + message + post_content\n    return new_content", "is_method": false, "function_description": "Generates updated README content by inserting a rendered sponsors section from YAML data into a markdown file, enabling automated README updates reflecting sponsor information."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "generate_readme", "line_number": 240, "body": "def generate_readme():\n    \"\"\"\n    Generate README.md content from main index.md\n    \"\"\"\n    typer.echo(\"Generating README\")\n    readme_path = Path(\"README.md\")\n    new_content = generate_readme_content()\n    readme_path.write_text(new_content, encoding=\"utf-8\")", "is_method": false, "function_description": "Function that creates or updates the README.md file by generating its content based on the main index.md, facilitating automatic documentation synchronization."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "verify_readme", "line_number": 251, "body": "def verify_readme():\n    \"\"\"\n    Verify README.md content from main index.md\n    \"\"\"\n    typer.echo(\"Verifying README\")\n    readme_path = Path(\"README.md\")\n    generated_content = generate_readme_content()\n    readme_content = readme_path.read_text(\"utf-8\")\n    if generated_content != readme_content:\n        typer.secho(\n            \"README.md outdated from the latest index.md\", color=typer.colors.RED\n        )\n        raise typer.Abort()\n    typer.echo(\"Valid README \u2705\")", "is_method": false, "function_description": "Function providing validation of the README.md by comparing its content with the latest generated index.md content, ensuring documentation is up-to-date and consistent."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "build_all", "line_number": 268, "body": "def build_all():\n    \"\"\"\n    Build mkdocs site for en, and then build each language inside, end result is located\n    at directory ./site/ with each language inside.\n    \"\"\"\n    site_path = Path(\"site\").absolute()\n    update_languages(lang=None)\n    current_dir = os.getcwd()\n    os.chdir(en_docs_path)\n    typer.echo(\"Building docs for: en\")\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(site_path)))\n    os.chdir(current_dir)\n    langs = []\n    for lang in get_lang_paths():\n        if lang == en_docs_path or not lang.is_dir():\n            continue\n        langs.append(lang.name)\n    cpu_count = os.cpu_count() or 1\n    with Pool(cpu_count * 2) as p:\n        p.map(build_lang, langs)", "is_method": false, "function_description": "Service function that builds the entire multi-language MkDocs website by compiling the English docs first, then concurrently building documentation for each available language, outputting all versions under the ./site/ directory."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "update_single_lang", "line_number": 290, "body": "def update_single_lang(lang: str):\n    lang_path = docs_path / lang\n    typer.echo(f\"Updating {lang_path.name}\")\n    update_config(lang_path.name)", "is_method": false, "function_description": "Updates the configuration for a specified language by invoking the relevant update process and logging the update action. This function supports maintaining language-specific settings or resources."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "update_languages", "line_number": 297, "body": "def update_languages(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Update the mkdocs.yml file Languages section including all the available languages.\n\n    The LANG argument is a 2-letter language code. If it's not provided, update all the\n    mkdocs.yml files (for all the languages).\n    \"\"\"\n    if lang is None:\n        for lang_path in get_lang_paths():\n            if lang_path.is_dir():\n                update_single_lang(lang_path.name)\n    else:\n        update_single_lang(lang)", "is_method": false, "function_description": "Function that updates the languages section in mkdocs.yml files by either refreshing all language configurations or updating a specific one based on a given language code. It supports managing multilingual documentation setups efficiently."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "serve", "line_number": 317, "body": "def serve():\n    \"\"\"\n    A quick server to preview a built site with translations.\n\n    For development, prefer the command live (or just mkdocs serve).\n\n    This is here only to preview a site with translations already built.\n\n    Make sure you run the build-all command first.\n    \"\"\"\n    typer.echo(\"Warning: this is a very simple server.\")\n    typer.echo(\"For development, use the command live instead.\")\n    typer.echo(\"This is here only to preview a site with translations already built.\")\n    typer.echo(\"Make sure you run the build-all command first.\")\n    os.chdir(\"site\")\n    server_address = (\"\", 8008)\n    server = HTTPServer(server_address, SimpleHTTPRequestHandler)\n    typer.echo(f\"Serving at: http://127.0.0.1:8008\")\n    server.serve_forever()", "is_method": false, "function_description": "This function starts a simple HTTP server to preview a pre-built multilingual site locally, primarily for quick inspection rather than active development. It requires the site to be built beforehand and serves content on port 8008."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "live", "line_number": 339, "body": "def live(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Serve with livereload a docs site for a specific language.\n\n    This only shows the actual translated files, not the placeholders created with\n    build-all.\n\n    Takes an optional LANG argument with the name of the language to serve, by default\n    en.\n    \"\"\"\n    if lang is None:\n        lang = \"en\"\n    lang_path: Path = docs_path / lang\n    os.chdir(lang_path)\n    mkdocs.commands.serve.serve(dev_addr=\"127.0.0.1:8008\")", "is_method": false, "function_description": "Provides a live-reloading local server for viewing translated documentation sites in a specified language, defaulting to English. This enables developers to preview actual language-specific docs during development."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "update_config", "line_number": 360, "body": "def update_config(lang: str):\n    lang_path: Path = docs_path / lang\n    config_path = lang_path / mkdocs_name\n    current_config: dict = mkdocs.utils.yaml_load(\n        config_path.read_text(encoding=\"utf-8\")\n    )\n    if lang == \"en\":\n        config = get_en_config()\n    else:\n        config = get_base_lang_config(lang)\n        config[\"nav\"] = current_config[\"nav\"]\n        config[\"theme\"][\"language\"] = current_config[\"theme\"][\"language\"]\n    languages = [{\"en\": \"/\"}]\n    alternate: List[Dict[str, str]] = config[\"extra\"].get(\"alternate\", [])\n    alternate_dict = {alt[\"link\"]: alt[\"name\"] for alt in alternate}\n    new_alternate: List[Dict[str, str]] = []\n    for lang_path in get_lang_paths():\n        if lang_path.name == \"en\" or not lang_path.is_dir():\n            continue\n        name = lang_path.name\n        languages.append({name: f\"/{name}/\"})\n    for lang_dict in languages:\n        name = list(lang_dict.keys())[0]\n        url = lang_dict[name]\n        if url not in alternate_dict:\n            new_alternate.append({\"link\": url, \"name\": name})\n        else:\n            use_name = alternate_dict[url]\n            new_alternate.append({\"link\": url, \"name\": use_name})\n    config[\"nav\"][1] = {\"Languages\": languages}\n    config[\"extra\"][\"alternate\"] = new_alternate\n    config_path.write_text(\n        yaml.dump(config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )", "is_method": false, "function_description": "Updates the language-specific MkDocs configuration by synchronizing navigation and language alternates, ensuring multilingual site settings stay consistent and accurate based on available language directories."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_key_section", "line_number": 397, "body": "def get_key_section(\n    *, key_to_section: Dict[Tuple[str, ...], list], key: Tuple[str, ...]\n) -> list:\n    if key in key_to_section:\n        return key_to_section[key]\n    super_key = key[:-1]\n    title = key[-1]\n    super_section = get_key_section(key_to_section=key_to_section, key=super_key)\n    new_section = []\n    super_section.append({title: new_section})\n    key_to_section[key] = new_section\n    return new_section", "is_method": false, "function_description": "This function retrieves or creates a nested section list corresponding to a hierarchical key, facilitating dynamic access and construction of a multi-level dictionary-like structure from tuple keys."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_text_with_translate_missing", "line_number": 411, "body": "def get_text_with_translate_missing(text: str) -> str:\n    lines = text.splitlines()\n    lines.insert(1, missing_translation_snippet)\n    new_text = \"\\n\".join(lines)\n    return new_text", "is_method": false, "function_description": "Utility function that inserts a predefined missing translation snippet after the first line of the given text, useful for marking or annotating untranslated content."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_file_to_nav_map", "line_number": 418, "body": "def get_file_to_nav_map(nav: list) -> Dict[str, Tuple[str, ...]]:\n    file_to_nav = {}\n    for item in nav:\n        if type(item) is str:\n            file_to_nav[item] = tuple()\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sub_file_to_nav = get_file_to_nav_map(sub_nav)\n            for k, v in sub_file_to_nav.items():\n                file_to_nav[k] = (item_key,) + v\n    return file_to_nav", "is_method": false, "function_description": "Function that converts a nested navigation structure into a mapping from file names to their hierarchical navigation paths as tuples. It enables quick lookup of navigation context for each file in a nested menu or directory tree."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_sections", "line_number": 432, "body": "def get_sections(nav: list) -> Dict[Tuple[str, ...], str]:\n    sections = {}\n    for item in nav:\n        if type(item) is str:\n            continue\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sections[(item_key,)] = sub_nav[0]\n            sub_sections = get_sections(sub_nav)\n            for k, v in sub_sections.items():\n                new_key = (item_key,) + k\n                sections[new_key] = v\n    return sections", "is_method": false, "function_description": "This function recursively extracts hierarchical section titles and their first items from a nested navigation structure, returning a dictionary that maps section paths to corresponding content summaries. It helps in organizing and accessing nested navigation data by section keys."}]