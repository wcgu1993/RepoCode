[{"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/watch-previews/app/main.py", "function": "get_message", "line_number": 39, "body": "def get_message(commit: str) -> str:\n    return f\"Docs preview for commit {commit} at\"", "is_method": false, "function_description": "Generates a standard message string for a documentation preview, embedding the provided commit identifier."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_graphql_response", "line_number": 265, "body": "def get_graphql_response(\n    *, settings: Settings, query: str, after: Optional[str] = None\n):\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    variables = {\"after\": after}\n    response = httpx.post(\n        github_graphql_url,\n        headers=headers,\n        json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n    )\n    if not response.status_code == 200:\n        logging.error(f\"Response was not 200, after: {after}\")\n        logging.error(response.text)\n        raise RuntimeError(response.text)\n    data = response.json()\n    return data", "is_method": false, "function_description": "Sends a GraphQL query to an API endpoint with authentication and pagination support. It retrieves and returns the structured JSON response, handling basic errors."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_graphql_issue_edges", "line_number": 283, "body": "def get_graphql_issue_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=issues_query, after=after)\n    graphql_response = IssuesResponse.parse_obj(data)\n    return graphql_response.data.repository.issues.edges", "is_method": false, "function_description": "Retrieves a paginated list of issue edges from a GraphQL repository API, useful for fetching issues data."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_graphql_pr_edges", "line_number": 289, "body": "def get_graphql_pr_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=prs_query, after=after)\n    graphql_response = PRsResponse.parse_obj(data)\n    return graphql_response.data.repository.pullRequests.edges", "is_method": false, "function_description": "Provides a service to retrieve paginated pull request data from a GraphQL API. It specifically extracts and returns the 'edges' representing individual pull request objects."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_graphql_sponsor_edges", "line_number": 295, "body": "def get_graphql_sponsor_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=sponsors_query, after=after)\n    graphql_response = SponsorsResponse.parse_obj(data)\n    return graphql_response.data.user.sponsorshipsAsMaintainer.edges", "is_method": false, "function_description": "Retrieves paginated sponsor relationship data (edges) that a user maintains via a GraphQL API. It queries the API and parses the response to extract these connections."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_experts", "line_number": 301, "body": "def get_experts(settings: Settings):\n    issue_nodes: List[IssuesNode] = []\n    issue_edges = get_graphql_issue_edges(settings=settings)\n\n    while issue_edges:\n        for edge in issue_edges:\n            issue_nodes.append(edge.node)\n        last_edge = issue_edges[-1]\n        issue_edges = get_graphql_issue_edges(settings=settings, after=last_edge.cursor)\n\n    commentors = Counter()\n    last_month_commentors = Counter()\n    authors: Dict[str, Author] = {}\n\n    now = datetime.now(tz=timezone.utc)\n    one_month_ago = now - timedelta(days=30)\n\n    for issue in issue_nodes:\n        issue_author_name = None\n        if issue.author:\n            authors[issue.author.login] = issue.author\n            issue_author_name = issue.author.login\n        issue_commentors = set()\n        for comment in issue.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == issue_author_name:\n                    continue\n                issue_commentors.add(comment.author.login)\n        for author_name in issue_commentors:\n            commentors[author_name] += 1\n            if issue.createdAt > one_month_ago:\n                last_month_commentors[author_name] += 1\n    return commentors, last_month_commentors, authors", "is_method": false, "function_description": "Calculates total and last-month comment counts for users involved in issues. This provides metrics and author details to identify highly active contributors."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_contributors", "line_number": 337, "body": "def get_contributors(settings: Settings):\n    pr_nodes: List[PullRequestNode] = []\n    pr_edges = get_graphql_pr_edges(settings=settings)\n\n    while pr_edges:\n        for edge in pr_edges:\n            pr_nodes.append(edge.node)\n        last_edge = pr_edges[-1]\n        pr_edges = get_graphql_pr_edges(settings=settings, after=last_edge.cursor)\n\n    contributors = Counter()\n    commentors = Counter()\n    reviewers = Counter()\n    authors: Dict[str, Author] = {}\n\n    for pr in pr_nodes:\n        author_name = None\n        if pr.author:\n            authors[pr.author.login] = pr.author\n            author_name = pr.author.login\n        pr_commentors: Set[str] = set()\n        pr_reviewers: Set[str] = set()\n        for comment in pr.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == author_name:\n                    continue\n                pr_commentors.add(comment.author.login)\n        for author_name in pr_commentors:\n            commentors[author_name] += 1\n        for review in pr.reviews.nodes:\n            if review.author:\n                authors[review.author.login] = review.author\n                pr_reviewers.add(review.author.login)\n        for reviewer in pr_reviewers:\n            reviewers[reviewer] += 1\n        if pr.state == \"MERGED\" and pr.author:\n            contributors[pr.author.login] += 1\n    return contributors, commentors, reviewers, authors", "is_method": false, "function_description": "This function retrieves and analyzes all pull requests to quantify project contributions. It provides detailed counts of authors with merged PRs, commentors, and reviewers, along with author details."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_individual_sponsors", "line_number": 378, "body": "def get_individual_sponsors(settings: Settings):\n    nodes: List[SponsorshipAsMaintainerNode] = []\n    edges = get_graphql_sponsor_edges(settings=settings)\n\n    while edges:\n        for edge in edges:\n            nodes.append(edge.node)\n        last_edge = edges[-1]\n        edges = get_graphql_sponsor_edges(settings=settings, after=last_edge.cursor)\n\n    tiers: DefaultDict[float, Dict[str, SponsorEntity]] = defaultdict(dict)\n    for node in nodes:\n        tiers[node.tier.monthlyPriceInDollars][\n            node.sponsorEntity.login\n        ] = node.sponsorEntity\n    return tiers", "is_method": false, "function_description": "Fetches a complete list of individual sponsors, grouping them into a dictionary by their monthly contribution amount. This enables easy access and categorization of all individual sponsorship data."}, {"file": "./dataset/RepoExec/test-apps/fastapi/.github/actions/people/app/main.py", "function": "get_top_users", "line_number": 396, "body": "def get_top_users(\n    *,\n    counter: Counter,\n    min_count: int,\n    authors: Dict[str, Author],\n    skip_users: Container[str],\n):\n    users = []\n    for commentor, count in counter.most_common(50):\n        if commentor in skip_users:\n            continue\n        if count >= min_count:\n            author = authors[commentor]\n            users.append(\n                {\n                    \"login\": commentor,\n                    \"count\": count,\n                    \"avatarUrl\": author.avatarUrl,\n                    \"url\": author.url,\n                }\n            )\n    return users", "is_method": false, "function_description": "This function identifies and retrieves details for a limited number of top users based on their activity count. It filters users by a minimum count and a skip list, providing their login, count, and profile information."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/wsgi/tutorial001.py", "function": "flask_main", "line_number": 9, "body": "def flask_main():\n    name = request.args.get(\"name\", \"World\")\n    return f\"Hello, {escape(name)} from Flask!\"", "is_method": false, "function_description": "This function defines a basic Flask web endpoint. It retrieves an optional name from URL query parameters to generate and return a personalized \"Hello\" greeting."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/wsgi/tutorial001.py", "function": "read_main", "line_number": 18, "body": "def read_main():\n    return {\"message\": \"Hello World\"}", "is_method": false, "function_description": "Provides a simple 'Hello World' message as a basic response. Commonly used for a default API endpoint or a health check."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_cookies/tutorial001.py", "function": "create_cookie", "line_number": 8, "body": "def create_cookie():\n    content = {\"message\": \"Come to the dark side, we have cookies\"}\n    response = JSONResponse(content=content)\n    response.set_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\")\n    return response", "is_method": false, "function_description": "Creates a JSON response containing a message and sets a 'fakesession' cookie. It provides a basic example of returning data with a session identifier via HTTP."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_cookies/tutorial002.py", "function": "create_cookie", "line_number": 7, "body": "def create_cookie(response: Response):\n    response.set_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\")\n    return {\"message\": \"Come to the dark side, we have cookies\"}", "is_method": false, "function_description": "This function adds a predefined 'fakesession' cookie to the HTTP response. It provides a simple mechanism for establishing a basic, fixed-value session for the client."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/using_request_directly/tutorial001.py", "function": "read_root", "line_number": 7, "body": "def read_root(item_id: str, request: Request):\n    client_host = request.client.host\n    return {\"client_host\": client_host, \"item_id\": item_id}", "is_method": false, "function_description": "This function processes a web request, returning the client's host address and a specified item identifier. It serves as a basic API endpoint for information retrieval."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/nosql_databases/tutorial001.py", "function": "get_bucket", "line_number": 12, "body": "def get_bucket():\n    cluster = Cluster(\n        \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\"\n    )\n    authenticator = PasswordAuthenticator(\"username\", \"password\")\n    cluster.authenticate(authenticator)\n    bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT)\n    bucket.timeout = 30\n    bucket.n1ql_timeout = 300\n    return bucket", "is_method": false, "function_description": "Establishes an authenticated connection to a Couchbase cluster and returns a configured bucket object, providing access for database operations."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/nosql_databases/tutorial001.py", "function": "get_user", "line_number": 36, "body": "def get_user(bucket: Bucket, username: str):\n    doc_id = f\"userprofile::{username}\"\n    result = bucket.get(doc_id, quiet=True)\n    if not result.value:\n        return None\n    user = UserInDB(**result.value)\n    return user", "is_method": false, "function_description": "Retrieves a user's profile data from the specified data bucket based on their username. It returns a structured UserInDB object if found, otherwise None."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/nosql_databases/tutorial001.py", "function": "read_user", "line_number": 50, "body": "def read_user(username: str):\n    bucket = get_bucket()\n    user = get_user(bucket=bucket, username=username)\n    return user", "is_method": false, "function_description": "Provides a service to fetch a user's profile or data using their unique username from a configured data store."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/extending_openapi/tutorial001.py", "function": "custom_openapi", "line_number": 12, "body": "def custom_openapi():\n    if app.openapi_schema:\n        return app.openapi_schema\n    openapi_schema = get_openapi(\n        title=\"Custom title\",\n        version=\"2.5.0\",\n        description=\"This is a very custom OpenAPI schema\",\n        routes=app.routes,\n    )\n    openapi_schema[\"info\"][\"x-logo\"] = {\n        \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\"\n    }\n    app.openapi_schema = openapi_schema\n    return app.openapi_schema", "is_method": false, "function_description": "Provides a customized OpenAPI schema for the application, adding specific metadata and caching it for efficient retrieval."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dataclasses/tutorial003.py", "function": "get_authors", "line_number": 29, "body": "def get_authors():  # (8)\n    return [  # (9)\n        {\n            \"name\": \"Breaters\",\n            \"items\": [\n                {\n                    \"name\": \"Island In The Moon\",\n                    \"description\": \"A place to be be playin' and havin' fun\",\n                },\n                {\"name\": \"Holy Buddies\"},\n            ],\n        },\n        {\n            \"name\": \"System of an Up\",\n            \"items\": [\n                {\n                    \"name\": \"Salt\",\n                    \"description\": \"The kombucha mushroom people's favorite\",\n                },\n                {\"name\": \"Pad Thai\"},\n                {\n                    \"name\": \"Lonely Night\",\n                    \"description\": \"The mostests lonliest nightiest of allest\",\n                },\n            ],\n        },\n    ]", "is_method": false, "function_description": "This function provides a hardcoded list of authors, each with a name and a collection of items. It serves as a static data source for author-related information."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sub_applications/tutorial001.py", "function": "read_main", "line_number": 7, "body": "def read_main():\n    return {\"message\": \"Hello World from main app\"}", "is_method": false, "function_description": "Provides a simple \"Hello World\" message, often used as a basic health check or root endpoint for a web application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/graphql/tutorial001.py", "function": "user", "line_number": 15, "body": "def user(self) -> User:\n        return User(name=\"Patrick\", age=100)", "is_method": true, "class_name": "Query", "function_description": "This method of the Query class returns a hardcoded `User` object with a fixed name and age. It serves as a placeholder or example for user retrieval."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial004.py", "function": "verify_password", "line_number": 55, "body": "def verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)", "is_method": false, "function_description": "This function securely verifies if a plain password matches a given hashed password. It is typically used for user authentication."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial004.py", "function": "get_password_hash", "line_number": 59, "body": "def get_password_hash(password):\n    return pwd_context.hash(password)", "is_method": false, "function_description": "Generates a secure hash for a given plaintext password. This service is crucial for safely storing user credentials and verifying them."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial004.py", "function": "get_user", "line_number": 63, "body": "def get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)", "is_method": false, "function_description": "Retrieves user information from the database using a given username. It returns the user's data as a `UserInDB` object if found."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial004.py", "function": "authenticate_user", "line_number": 69, "body": "def authenticate_user(fake_db, username: str, password: str):\n    user = get_user(fake_db, username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user", "is_method": false, "function_description": "Authenticates a user by validating provided username and password against stored credentials. This function determines if a user can successfully log in or gain access."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial004.py", "function": "create_access_token", "line_number": 78, "body": "def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt", "is_method": false, "function_description": "Generates a secure, time-limited JSON Web Token (JWT) from provided data. This token is suitable for authentication and authorization purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial007.py", "function": "get_current_username", "line_number": 11, "body": "def get_current_username(credentials: HTTPBasicCredentials = Depends(security)):\n    correct_username = secrets.compare_digest(credentials.username, \"stanleyjobson\")\n    correct_password = secrets.compare_digest(credentials.password, \"swordfish\")\n    if not (correct_username and correct_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect email or password\",\n            headers={\"WWW-Authenticate\": \"Basic\"},\n        )\n    return credentials.username", "is_method": false, "function_description": "Authenticates a user by validating provided HTTP Basic credentials against hardcoded values. It returns the username if successful, otherwise raises an unauthorized error."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial007.py", "function": "read_current_user", "line_number": 24, "body": "def read_current_user(username: str = Depends(get_current_username)):\n    return {\"username\": username}", "is_method": false, "function_description": "Retrieves the username of the currently authenticated user. It provides a simple API endpoint for identifying the active user."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial003.py", "function": "fake_hash_password", "line_number": 27, "body": "def fake_hash_password(password: str):\n    return \"fakehashed\" + password", "is_method": false, "function_description": "Provides a simple, non-cryptographic \"hash\" by prepending 'fakehashed' to a given password string. Useful for testing or mock security implementations."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial003.py", "function": "get_user", "line_number": 45, "body": "def get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)", "is_method": false, "function_description": "Retrieves user data from a database using a provided username. It instantiates the raw data into a `UserInDB` object for structured access."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial005.py", "function": "verify_password", "line_number": 70, "body": "def verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)", "is_method": false, "function_description": "Checks if a plain-text password matches a given hashed password. This function provides a secure way to authenticate users by validating their input."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial005.py", "function": "get_password_hash", "line_number": 74, "body": "def get_password_hash(password):\n    return pwd_context.hash(password)", "is_method": false, "function_description": "Generates a secure cryptographic hash for a given plain-text password. This is essential for securely storing and verifying user passwords."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial005.py", "function": "get_user", "line_number": 78, "body": "def get_user(db, username: str):\n    if username in db:\n        user_dict = db[username]\n        return UserInDB(**user_dict)", "is_method": false, "function_description": "Retrieves a user's data from a database-like object by username. It constructs and returns a `UserInDB` object containing the retrieved user information."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial005.py", "function": "authenticate_user", "line_number": 84, "body": "def authenticate_user(fake_db, username: str, password: str):\n    user = get_user(fake_db, username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user", "is_method": false, "function_description": "This function verifies a user's provided username and password against a stored user database. It ensures only valid credentials grant access, returning the user object on successful authentication."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial005.py", "function": "create_access_token", "line_number": 93, "body": "def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt", "is_method": false, "function_description": "Generates a secure JSON Web Token (JWT) access token. It embeds provided data and an expiration time for authentication and authorization purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial002.py", "function": "fake_decode_token", "line_number": 19, "body": "def fake_decode_token(token):\n    return User(\n        username=token + \"fakedecoded\", email=\"john@example.com\", full_name=\"John Doe\"\n    )", "is_method": false, "function_description": "This function simulates the decoding of a token, returning a mock User object for testing or development purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/security/tutorial006.py", "function": "read_current_user", "line_number": 10, "body": "def read_current_user(credentials: HTTPBasicCredentials = Depends(security)):\n    return {\"username\": credentials.username, \"password\": credentials.password}", "is_method": false, "function_description": "Retrieves the username and password for the currently authenticated user's request, often used in API endpoints requiring user context."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/conditional_openapi/tutorial001.py", "function": "root", "line_number": 15, "body": "def root():\n    return {\"message\": \"Hello World\"}", "is_method": false, "function_description": "Provides a basic \"Hello World\" message. This function typically serves as a root endpoint to confirm an API or web service is running."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/websockets/tutorial003.py", "function": "disconnect", "line_number": 54, "body": "def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)", "is_method": true, "class_name": "ConnectionManager", "function_description": "Removes a specified WebSocket connection from the manager's list of active connections, effectively marking it as disconnected."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial004.py", "function": "get_name_with_age", "line_number": 1, "body": "def get_name_with_age(name: str, age: int):\n    name_with_age = name + \" is this old: \" + str(age)\n    return name_with_age", "is_method": false, "function_description": "This function combines a person's name and age into a single descriptive string, stating their name and how old they are."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial008.py", "function": "process_items", "line_number": 4, "body": "def process_items(prices: Dict[str, float]):\n    for item_name, item_price in prices.items():\n        print(item_name)\n        print(item_price)", "is_method": false, "function_description": "Iterates through a dictionary of item names and prices, printing each item's name and its associated price to the console."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial001.py", "function": "get_full_name", "line_number": 1, "body": "def get_full_name(first_name, last_name):\n    full_name = first_name.title() + \" \" + last_name.title()\n    return full_name", "is_method": false, "function_description": "This function combines a given first and last name into a single, properly capitalized full name string. It provides a standardized full name for display or record-keeping."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial009.py", "function": "say_hi", "line_number": 4, "body": "def say_hi(name: Optional[str] = None):\n    if name is not None:\n        print(f\"Hey {name}!\")\n    else:\n        print(\"Hello World\")", "is_method": false, "function_description": "Prints a personalized greeting using the provided name, or a default \"Hello World\" message if no name is specified."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial005.py", "function": "get_items", "line_number": 1, "body": "def get_items(item_a: str, item_b: int, item_c: float, item_d: bool, item_e: bytes):\n    return item_a, item_b, item_c, item_d, item_d, item_e", "is_method": false, "function_description": "This function collects five distinct input values of various types and returns them as a tuple. It provides a simple way to package specific, heterogeneous data for further use."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial002.py", "function": "get_full_name", "line_number": 1, "body": "def get_full_name(first_name: str, last_name: str):\n    full_name = first_name.title() + \" \" + last_name.title()\n    return full_name", "is_method": false, "function_description": "This function combines a given first name and last name into a single, title-cased full name string. It provides a standardized way to format personal names."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial010.py", "function": "get_person_name", "line_number": 6, "body": "def get_person_name(one_person: Person):\n    return one_person.name", "is_method": false, "function_description": "Retrieves the name of a given Person object. This simplifies accessing an individual's identity within the system."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/python_types/tutorial006.py", "function": "process_items", "line_number": 4, "body": "def process_items(items: List[str]):\n    for item in items:\n        print(item)", "is_method": false, "function_description": "Iterates through a list of strings, printing each item to the console."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/path_operation_advanced_configuration/tutorial002.py", "function": "use_route_names_as_operation_ids", "line_number": 12, "body": "def use_route_names_as_operation_ids(app: FastAPI) -> None:\n    \"\"\"\n    Simplify operation IDs so that generated API clients have simpler function\n    names.\n\n    Should be called only after all routes have been added.\n    \"\"\"\n    for route in app.routes:\n        if isinstance(route, APIRoute):\n            route.operation_id = route.name", "is_method": false, "function_description": "Modifies a FastAPI application to use route names as OpenAPI operation IDs. This simplifies function names in generated API clients, enhancing usability for API consumers."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/first_steps/tutorial003.py", "function": "root", "line_number": 7, "body": "def root():\n    return {\"message\": \"Hello World\"}", "is_method": false, "function_description": "Provides a basic \"Hello World\" message. It is typically used as a root endpoint for a web API or a simple health check."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_directly/tutorial001.py", "function": "update_item", "line_number": 20, "body": "def update_item(id: str, item: Item):\n    json_compatible_item_data = jsonable_encoder(item)\n    return JSONResponse(content=json_compatible_item_data)", "is_method": false, "function_description": "Serializes a given item object into a JSON-compatible format and returns it wrapped in a JSON response."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_directly/tutorial002.py", "function": "get_legacy_data", "line_number": 7, "body": "def get_legacy_data():\n    data = \"\"\"<?xml version=\"1.0\"?>\n    <shampoo>\n    <Header>\n        Apply shampoo here.\n    </Header>\n    <Body>\n        You'll have to use soap here.\n    </Body>\n    </shampoo>\n    \"\"\"\n    return Response(content=data, media_type=\"application/xml\")", "is_method": false, "function_description": "This function provides a hardcoded XML string as an HTTP response with an XML media type. It serves as a fixed endpoint for legacy data or for testing XML parsing capabilities."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/events/tutorial002.py", "function": "shutdown_event", "line_number": 7, "body": "def shutdown_event():\n    with open(\"log.txt\", mode=\"a\") as log:\n        log.write(\"Application shutdown\")", "is_method": false, "function_description": "Logs the application shutdown event by appending a specific message to a log file."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_response/tutorial004.py", "function": "generate_html_response", "line_number": 7, "body": "def generate_html_response():\n    html_content = \"\"\"\n    <html>\n        <head>\n            <title>Some HTML in here</title>\n        </head>\n        <body>\n            <h1>Look ma! HTML!</h1>\n        </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(content=html_content, status_code=200)", "is_method": false, "function_description": "This function generates a simple, static HTML page and returns it as an HTTP response. It provides a basic web endpoint."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_response/tutorial008.py", "function": "main", "line_number": 9, "body": "def main():\n    def iterfile():  # (1)\n        with open(some_file_path, mode=\"rb\") as file_like:  # (2)\n            yield from file_like  # (3)\n\n    return StreamingResponse(iterfile(), media_type=\"video/mp4\")", "is_method": false, "function_description": "This function creates a streaming response to serve a video file. It reads the file iteratively from disk, enabling efficient delivery of large media content."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_response/tutorial008.py", "function": "iterfile", "line_number": 10, "body": "def iterfile():  # (1)\n        with open(some_file_path, mode=\"rb\") as file_like:  # (2)\n            yield from file_like", "is_method": false, "function_description": "Provides an efficient iterator to read a file's content in binary mode. This enables processing large files without loading them fully into memory."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "get_user", "line_number": 6, "body": "def get_user(db: Session, user_id: int):\n    return db.query(models.User).filter(models.User.id == user_id).first()", "is_method": false, "function_description": "Retrieves a single user record from the database by a specific user ID. This function provides a core capability for fetching user data."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "get_user_by_email", "line_number": 10, "body": "def get_user_by_email(db: Session, email: str):\n    return db.query(models.User).filter(models.User.email == email).first()", "is_method": false, "function_description": "Retrieves a single user record from the database based on their email address. This function provides a lookup service for user authentication and data retrieval."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "get_users", "line_number": 14, "body": "def get_users(db: Session, skip: int = 0, limit: int = 100):\n    return db.query(models.User).offset(skip).limit(limit).all()", "is_method": false, "function_description": "Retrieves a paginated list of user records from the database. This function is useful for displaying user directories or managing user data."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "create_user", "line_number": 18, "body": "def create_user(db: Session, user: schemas.UserCreate):\n    fake_hashed_password = user.password + \"notreallyhashed\"\n    db_user = models.User(email=user.email, hashed_password=fake_hashed_password)\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return db_user", "is_method": false, "function_description": "This function creates and stores a new user record in the database. It manages the user's email and a placeholder password for new user registration."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "get_items", "line_number": 27, "body": "def get_items(db: Session, skip: int = 0, limit: int = 100):\n    return db.query(models.Item).offset(skip).limit(limit).all()", "is_method": false, "function_description": "Retrieves a paginated list of `Item` records from the database. This function is useful for displaying or processing data in manageable chunks."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/crud.py", "function": "create_user_item", "line_number": 31, "body": "def create_user_item(db: Session, item: schemas.ItemCreate, user_id: int):\n    db_item = models.Item(**item.dict(), owner_id=user_id)\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "is_method": false, "function_description": "Creates and stores a new item record in the database, linking it to a specific user as its owner. This function provides a service for persisting user-generated content."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "get_db", "line_number": 15, "body": "def get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()", "is_method": false, "function_description": "Manages a database session's lifecycle, providing it for operations and ensuring it's always closed. Ideal for dependency injection patterns."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "create_user", "line_number": 24, "body": "def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):\n    db_user = crud.get_user_by_email(db, email=user.email)\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    return crud.create_user(db=db, user=user)", "is_method": false, "function_description": "Registers a new user in the system. It ensures email uniqueness before creation, preventing duplicate user accounts."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "read_users", "line_number": 32, "body": "def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    users = crud.get_users(db, skip=skip, limit=limit)\n    return users", "is_method": false, "function_description": "Retrieves a paginated list of user records. It allows skipping a number of initial entries and limiting the total number of users returned."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "read_user", "line_number": 38, "body": "def read_user(user_id: int, db: Session = Depends(get_db)):\n    db_user = crud.get_user(db, user_id=user_id)\n    if db_user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return db_user", "is_method": false, "function_description": "Retrieves a specific user's details from the database using their unique ID. It raises an HTTP 404 error if the user is not found, making it ideal for API endpoints."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "create_item_for_user", "line_number": 46, "body": "def create_item_for_user(\n    user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db)\n):\n    return crud.create_user_item(db=db, item=item, user_id=user_id)", "is_method": false, "function_description": "Creates a new item in the database and associates it with a specified user. This function serves as an API endpoint for creating user-specific data."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/main.py", "function": "read_items", "line_number": 53, "body": "def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    items = crud.get_items(db, skip=skip, limit=limit)\n    return items", "is_method": false, "function_description": "Retrieves a paginated list of items from the database."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "get_db", "line_number": 26, "body": "def get_db(request: Request):\n    return request.state.db", "is_method": false, "function_description": "Retrieves the database session or connection from the current request's state, enabling other functions to interact with the database."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "create_user", "line_number": 31, "body": "def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):\n    db_user = crud.get_user_by_email(db, email=user.email)\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    return crud.create_user(db=db, user=user)", "is_method": false, "function_description": "Registers a new user in the system. It ensures email uniqueness before storing user data, preventing duplicate accounts."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "read_users", "line_number": 39, "body": "def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    users = crud.get_users(db, skip=skip, limit=limit)\n    return users", "is_method": false, "function_description": "This function retrieves a paginated list of users from the database. It allows specifying the number of users to skip and the maximum number to retrieve."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "read_user", "line_number": 45, "body": "def read_user(user_id: int, db: Session = Depends(get_db)):\n    db_user = crud.get_user(db, user_id=user_id)\n    if db_user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return db_user", "is_method": false, "function_description": "Retrieves a specific user's data from the database by ID. It raises an HTTP 404 error if the user is not found."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "create_item_for_user", "line_number": 53, "body": "def create_item_for_user(\n    user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db)\n):\n    return crud.create_user_item(db=db, item=item, user_id=user_id)", "is_method": false, "function_description": "This function creates a new item in the database and associates it with a specific user, enabling users to add personalized content or data."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/alt_main.py", "function": "read_items", "line_number": 60, "body": "def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    items = crud.get_items(db, skip=skip, limit=limit)\n    return items", "is_method": false, "function_description": "Retrieves a paginated list of items from the database. It allows specifying an offset and a maximum number of items to retrieve."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/tests/test_sql_app.py", "function": "override_get_db", "line_number": 19, "body": "def override_get_db():\n    try:\n        db = TestingSessionLocal()\n        yield db\n    finally:\n        db.close()", "is_method": false, "function_description": "Provides a temporary, isolated database session, typically for testing. It ensures the database connection is properly closed after use."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases/sql_app/tests/test_sql_app.py", "function": "test_create_user", "line_number": 32, "body": "def test_create_user():\n    response = client.post(\n        \"/users/\",\n        json={\"email\": \"deadpool@example.com\", \"password\": \"chimichangas4life\"},\n    )\n    assert response.status_code == 200, response.text\n    data = response.json()\n    assert data[\"email\"] == \"deadpool@example.com\"\n    assert \"id\" in data\n    user_id = data[\"id\"]\n\n    response = client.get(f\"/users/{user_id}\")\n    assert response.status_code == 200, response.text\n    data = response.json()\n    assert data[\"email\"] == \"deadpool@example.com\"\n    assert data[\"id\"] == user_id", "is_method": false, "function_description": "This test function verifies the successful creation of a new user through a POST request and subsequently confirms the user's data can be accurately retrieved via a GET request to the user API endpoint."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/openapi_callbacks/tutorial001.py", "function": "create_invoice", "line_number": 36, "body": "def create_invoice(invoice: Invoice, callback_url: Optional[HttpUrl] = None):\n    \"\"\"\n    Create an invoice.\n\n    This will (let's imagine) let the API user (some external developer) create an\n    invoice.\n\n    And this path operation will:\n\n    * Send the invoice to the client.\n    * Collect the money from the client.\n    * Send a notification back to the API user (the external developer), as a callback.\n        * At this point is that the API will somehow send a POST request to the\n            external API with the notification of the invoice event\n            (e.g. \"payment successful\").\n    \"\"\"\n    # Send the invoice, collect the money, send the notification (the callback)\n    return {\"msg\": \"Invoice received\"}", "is_method": false, "function_description": "This function creates and processes an invoice, managing its delivery to the client and money collection. It provides a callback notification to the external API user regarding the invoice's status."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_change_status_code/tutorial001.py", "function": "get_or_create_task", "line_number": 9, "body": "def get_or_create_task(task_id: str, response: Response):\n    if task_id not in tasks:\n        tasks[task_id] = \"This didn't exist before\"\n        response.status_code = status.HTTP_201_CREATED\n    return tasks[task_id]", "is_method": false, "function_description": "This function retrieves a task by its ID, or creates a new one if it doesn't exist, signaling creation with an HTTP 201 status code."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependency_testing/tutorial001.py", "function": "test_override_in_items", "line_number": 33, "body": "def test_override_in_items():\n    response = client.get(\"/items/\")\n    assert response.status_code == 200\n    assert response.json() == {\n        \"message\": \"Hello Items!\",\n        \"params\": {\"q\": None, \"skip\": 5, \"limit\": 10},\n    }", "is_method": false, "function_description": "This function is a test case that verifies the `/items/` API endpoint behaves correctly. It asserts the response status and content, including the handling of default and overridden query parameters."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependency_testing/tutorial001.py", "function": "test_override_in_items_with_q", "line_number": 42, "body": "def test_override_in_items_with_q():\n    response = client.get(\"/items/?q=foo\")\n    assert response.status_code == 200\n    assert response.json() == {\n        \"message\": \"Hello Items!\",\n        \"params\": {\"q\": \"foo\", \"skip\": 5, \"limit\": 10},\n    }", "is_method": false, "function_description": "Verifies an API endpoint's behavior when queried with specific parameters, ensuring correct data processing and default value application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependency_testing/tutorial001.py", "function": "test_override_in_items_with_params", "line_number": 51, "body": "def test_override_in_items_with_params():\n    response = client.get(\"/items/?q=foo&skip=100&limit=200\")\n    assert response.status_code == 200\n    assert response.json() == {\n        \"message\": \"Hello Items!\",\n        \"params\": {\"q\": \"foo\", \"skip\": 5, \"limit\": 10},\n    }", "is_method": false, "function_description": "Tests an API endpoint's handling of query parameters. It verifies that the server overrides `skip` and `limit` to specific default values, despite different values sent in the request."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/encoder/tutorial001.py", "function": "update_item", "line_number": 21, "body": "def update_item(id: str, item: Item):\n    json_compatible_item_data = jsonable_encoder(item)\n    fake_db[id] = json_compatible_item_data", "is_method": false, "function_description": "Updates or creates an item in a simulated in-memory database. It converts the input object into a JSON-compatible format before storage."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/settings/app03/main.py", "function": "get_settings", "line_number": 11, "body": "def get_settings():\n    return config.Settings()", "is_method": false, "function_description": "Provides a mechanism to retrieve the application's global configuration settings. This function serves as a central access point for system parameters."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/settings/app02/main.py", "function": "get_settings", "line_number": 11, "body": "def get_settings():\n    return Settings()", "is_method": false, "function_description": "Provides access to the application's configuration settings by instantiating and returning a `Settings` object. This function ensures a single point of entry for retrieving settings."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/settings/app02/test_main.py", "function": "get_settings_override", "line_number": 9, "body": "def get_settings_override():\n    return Settings(admin_email=\"testing_admin@example.com\")", "is_method": false, "function_description": "Provides a predefined Settings object with an overridden admin email. Useful for testing or specific application configurations."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/settings/app02/test_main.py", "function": "test_app", "line_number": 16, "body": "def test_app():\n    response = client.get(\"/info\")\n    data = response.json()\n    assert data == {\n        \"app_name\": \"Awesome API\",\n        \"admin_email\": \"testing_admin@example.com\",\n        \"items_per_user\": 50,\n    }", "is_method": false, "function_description": "This function tests the `/info` API endpoint to ensure it returns the expected application configuration data. It validates the basic setup of an application's public information."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/database.py", "function": "__setattr__", "line_number": 15, "body": "def __setattr__(self, name, value):\n        self._state.get()[name] = value", "is_method": true, "class_name": "PeeweeConnectionState", "function_description": "Intercepts attribute assignments for the connection state, storing them in a thread-local or context-specific state. This ensures proper isolation for database connections."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/database.py", "function": "__getattr__", "line_number": 18, "body": "def __getattr__(self, name):\n        return self._state.get()[name]", "is_method": true, "class_name": "PeeweeConnectionState", "function_description": "Delegates attribute lookups to the underlying thread-local database connection state. This simplifies direct access to context-specific connection properties."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/schemas.py", "function": "get", "line_number": 9, "body": "def get(self, key: Any, default: Any = None):\n        res = getattr(self._obj, key, default)\n        if isinstance(res, peewee.ModelSelect):\n            return list(res)\n        return res", "is_method": true, "class_name": "PeeweeGetterDict", "function_description": "Provides dictionary-like attribute access for a wrapped object, handling Peewee ModelSelect query results by materializing them into lists."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "get_user", "line_number": 4, "body": "def get_user(user_id: int):\n    return models.User.filter(models.User.id == user_id).first()", "is_method": false, "function_description": "This function retrieves a single user record from the database based on a provided user ID. It provides a core utility for accessing specific user information."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "get_user_by_email", "line_number": 8, "body": "def get_user_by_email(email: str):\n    return models.User.filter(models.User.email == email).first()", "is_method": false, "function_description": "Retrieves a user object from the database based on their email address, providing a lookup service for user authentication and profile access."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "get_users", "line_number": 12, "body": "def get_users(skip: int = 0, limit: int = 100):\n    return list(models.User.select().offset(skip).limit(limit))", "is_method": false, "function_description": "This function retrieves a paginated list of user records from the database. It provides a way to fetch users with specified offset and limit for display or API consumption."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "create_user", "line_number": 16, "body": "def create_user(user: schemas.UserCreate):\n    fake_hashed_password = user.password + \"notreallyhashed\"\n    db_user = models.User(email=user.email, hashed_password=fake_hashed_password)\n    db_user.save()\n    return db_user", "is_method": false, "function_description": "Creates a new user account in the system. It processes user registration details and persists the new user record in the database."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "get_items", "line_number": 23, "body": "def get_items(skip: int = 0, limit: int = 100):\n    return list(models.Item.select().offset(skip).limit(limit))", "is_method": false, "function_description": "Retrieves a paginated list of items from the data store. It allows specifying an offset and limit for efficient data retrieval."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/crud.py", "function": "create_user_item", "line_number": 27, "body": "def create_user_item(item: schemas.ItemCreate, user_id: int):\n    db_item = models.Item(**item.dict(), owner_id=user_id)\n    db_item.save()\n    return db_item", "is_method": false, "function_description": "Creates and stores a new item in the database, linking it to a specific user as the owner. This function enables users to add personal items to the system."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "get_db", "line_number": 23, "body": "def get_db(db_state=Depends(reset_db_state)):\n    try:\n        database.db.connect()\n        yield\n    finally:\n        if not database.db.is_closed():\n            database.db.close()", "is_method": false, "function_description": "Provides a managed database connection for application use, ensuring the connection is opened and properly closed."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "create_user", "line_number": 33, "body": "def create_user(user: schemas.UserCreate):\n    db_user = crud.get_user_by_email(email=user.email)\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    return crud.create_user(user=user)", "is_method": false, "function_description": "Creates a new user account in the system. It ensures the provided email address is unique before registration, preventing duplicates."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "read_users", "line_number": 41, "body": "def read_users(skip: int = 0, limit: int = 100):\n    users = crud.get_users(skip=skip, limit=limit)\n    return users", "is_method": false, "function_description": "Retrieves a paginated list of user records. It provides a service to fetch a subset of users, useful for displaying or processing user data."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "read_user", "line_number": 49, "body": "def read_user(user_id: int):\n    db_user = crud.get_user(user_id=user_id)\n    if db_user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return db_user", "is_method": false, "function_description": "Retrieves a specific user's data from the database by ID. It raises an HTTP 404 error if the user is not found, making it suitable for API endpoints."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "create_item_for_user", "line_number": 61, "body": "def create_item_for_user(user_id: int, item: schemas.ItemCreate):\n    return crud.create_user_item(item=item, user_id=user_id)", "is_method": false, "function_description": "Creates a new item and associates it with a specific user ID. This function provides a service for adding user-owned items to the system."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "read_items", "line_number": 66, "body": "def read_items(skip: int = 0, limit: int = 100):\n    items = crud.get_items(skip=skip, limit=limit)\n    return items", "is_method": false, "function_description": "This function retrieves a paginated list of items from a data source. It provides a convenient way to fetch data in manageable chunks for display or processing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/sql_databases_peewee/sql_app/main.py", "function": "read_slow_users", "line_number": 74, "body": "def read_slow_users(skip: int = 0, limit: int = 100):\n    global sleep_time\n    sleep_time = max(0, sleep_time - 1)\n    time.sleep(sleep_time)  # Fake long processing request\n    users = crud.get_users(skip=skip, limit=limit)\n    return users", "is_method": false, "function_description": "Retrieves a paginated list of users while simulating a long processing time. This function is designed to mimic slow data retrieval, primarily for testing purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/response_headers/tutorial001.py", "function": "get_headers", "line_number": 8, "body": "def get_headers():\n    content = {\"message\": \"Hello World\"}\n    headers = {\"X-Cat-Dog\": \"alone in the world\", \"Content-Language\": \"en-US\"}\n    return JSONResponse(content=content, headers=headers)", "is_method": false, "function_description": "This function creates and returns a JSON web response. It specifically includes a predefined message and custom HTTP headers, useful for testing API endpoints."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/debugging/tutorial001.py", "function": "root", "line_number": 8, "body": "def root():\n    a = \"a\"\n    b = \"b\" + a\n    return {\"hello world\": b}", "is_method": false, "function_description": "Provides a fixed dictionary as a response, mapping \"hello world\" to a concatenated string. This function is typically used as a simple endpoint for health checks or initial API interactions."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/background_tasks/tutorial001.py", "function": "write_notification", "line_number": 6, "body": "def write_notification(email: str, message=\"\"):\n    with open(\"log.txt\", mode=\"w\") as email_file:\n        content = f\"notification for {email}: {message}\"\n        email_file.write(content)", "is_method": false, "function_description": "This function logs a notification message associated with a specific email address to a file. It provides a simple record-keeping capability for system notifications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/background_tasks/tutorial002.py", "function": "write_log", "line_number": 8, "body": "def write_log(message: str):\n    with open(\"log.txt\", mode=\"a\") as log:\n        log.write(message)", "is_method": false, "function_description": "This function appends a given message string to a log file named 'log.txt'. It provides a simple utility for recording program events or debugging information persistently."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/background_tasks/tutorial002.py", "function": "get_query", "line_number": 13, "body": "def get_query(background_tasks: BackgroundTasks, q: Optional[str] = None):\n    if q:\n        message = f\"found query: {q}\\n\"\n        background_tasks.add_task(write_log, message)\n    return q", "is_method": false, "function_description": "This function retrieves an optional query string. If a query is provided, it logs its presence asynchronously using background tasks."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/extra_models/tutorial001.py", "function": "fake_save_user", "line_number": 33, "body": "def fake_save_user(user_in: UserIn):\n    hashed_password = fake_password_hasher(user_in.password)\n    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)\n    print(\"User saved! ..not really\")\n    return user_in_db", "is_method": false, "function_description": "Simulates saving a user by hashing the password and creating a database-ready object. This function is for testing or demonstration purposes, as it does not actually persist user data."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/extra_models/tutorial002.py", "function": "fake_save_user", "line_number": 31, "body": "def fake_save_user(user_in: UserIn):\n    hashed_password = fake_password_hasher(user_in.password)\n    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)\n    print(\"User saved! ..not really\")\n    return user_in_db", "is_method": false, "function_description": "This function simulates the process of saving a user by preparing user data with a hashed password and returning a UserInDB object, without actual persistence."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/behind_a_proxy/tutorial004.py", "function": "read_main", "line_number": 14, "body": "def read_main(request: Request):\n    return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")}", "is_method": false, "function_description": "Provides a basic HTTP GET endpoint that returns a \"Hello World\" message and the application's root path. Useful for testing application reachability or as a simple default route."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/behind_a_proxy/tutorial001.py", "function": "read_main", "line_number": 7, "body": "def read_main(request: Request):\n    return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")}", "is_method": false, "function_description": "This function defines a basic web endpoint that serves a \"Hello World\" message. It also returns the application's root path, primarily for simple confirmation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/behind_a_proxy/tutorial003.py", "function": "read_main", "line_number": 13, "body": "def read_main(request: Request):\n    return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")}", "is_method": false, "function_description": "This function provides a basic \"Hello World\" message for the application's root endpoint. It includes the configured root path, useful for a simple connectivity test or welcome page."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/behind_a_proxy/tutorial002.py", "function": "read_main", "line_number": 7, "body": "def read_main(request: Request):\n    return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")}", "is_method": false, "function_description": "Provides a basic, static JSON response to an incoming web request. It serves as a simple root endpoint or health check for an API."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/app_testing/test_main_b.py", "function": "test_read_item_bad_token", "line_number": 18, "body": "def test_read_item_bad_token():\n    response = client.get(\"/items/foo\", headers={\"X-Token\": \"hailhydra\"})\n    assert response.status_code == 400\n    assert response.json() == {\"detail\": \"Invalid X-Token header\"}", "is_method": false, "function_description": "Verifies that the API correctly handles requests with an invalid security token, returning a 400 status code and a specific error message."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/app_testing/test_main_b.py", "function": "test_read_inexistent_item", "line_number": 24, "body": "def test_read_inexistent_item():\n    response = client.get(\"/items/baz\", headers={\"X-Token\": \"coneofsilence\"})\n    assert response.status_code == 404\n    assert response.json() == {\"detail\": \"Item not found\"}", "is_method": false, "function_description": "Tests an API endpoint's error handling for non-existent items. It verifies that requests for items not found correctly return a 404 status code and a specific error message."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/app_testing/test_main_b.py", "function": "test_create_item_bad_token", "line_number": 44, "body": "def test_create_item_bad_token():\n    response = client.post(\n        \"/items/\",\n        headers={\"X-Token\": \"hailhydra\"},\n        json={\"id\": \"bazz\", \"title\": \"Bazz\", \"description\": \"Drop the bazz\"},\n    )\n    assert response.status_code == 400\n    assert response.json() == {\"detail\": \"Invalid X-Token header\"}", "is_method": false, "function_description": "Verifies the API's error handling for item creation when an invalid 'X-Token' is provided, ensuring a 400 status code and a specific error message are returned."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/app_testing/tutorial001.py", "function": "test_read_main", "line_number": 15, "body": "def test_read_main():\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"msg\": \"Hello World\"}", "is_method": false, "function_description": "This function tests the main API endpoint by making a GET request to verify it returns \"Hello World\" with a 200 status code. It validates the basic functionality of the application's root path."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/app_testing/tutorial003.py", "function": "test_read_items", "line_number": 20, "body": "def test_read_items():\n    with TestClient(app) as client:\n        response = client.get(\"/items/foo\")\n        assert response.status_code == 200\n        assert response.json() == {\"name\": \"Fighters\"}", "is_method": false, "function_description": "Verifies the API's `/items/foo` endpoint. It checks if a GET request returns a 200 status and the expected JSON response, ensuring correct item retrieval."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/app_testing/tutorial002.py", "function": "test_read_main", "line_number": 20, "body": "def test_read_main():\n    client = TestClient(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"msg\": \"Hello World\"}", "is_method": false, "function_description": "Tests the root endpoint of a FastAPI application. It verifies that the API returns a 200 status code and the expected 'Hello World' message."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/app_testing/tutorial002.py", "function": "test_websocket", "line_number": 27, "body": "def test_websocket():\n    client = TestClient(app)\n    with client.websocket_connect(\"/ws\") as websocket:\n        data = websocket.receive_json()\n        assert data == {\"msg\": \"Hello WebSocket\"}", "is_method": false, "function_description": "This function tests a WebSocket endpoint by establishing a connection with a test client, receiving a JSON message, and asserting that the received data matches the expected output. It verifies basic WebSocket communication."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_request_and_route/tutorial001.py", "function": "get_route_handler", "line_number": 19, "body": "def get_route_handler(self) -> Callable:\n        original_route_handler = super().get_route_handler()\n\n        async def custom_route_handler(request: Request) -> Response:\n            request = GzipRequest(request.scope, request.receive)\n            return await original_route_handler(request)\n\n        return custom_route_handler", "is_method": true, "class_name": "GzipRoute", "function_description": "Overrides the default route handler to transparently wrap incoming requests as `GzipRequest` objects. This prepares the request for Gzip processing before it reaches the original handler."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_request_and_route/tutorial003.py", "function": "get_route_handler", "line_number": 9, "body": "def get_route_handler(self) -> Callable:\n        original_route_handler = super().get_route_handler()\n\n        async def custom_route_handler(request: Request) -> Response:\n            before = time.time()\n            response: Response = await original_route_handler(request)\n            duration = time.time() - before\n            response.headers[\"X-Response-Time\"] = str(duration)\n            print(f\"route duration: {duration}\")\n            print(f\"route response: {response}\")\n            print(f\"route response headers: {response.headers}\")\n            return response\n\n        return custom_route_handler", "is_method": true, "class_name": "TimedRoute", "function_description": "Returns a new route handler that measures the execution time of the original handler. It adds an 'X-Response-Time' header to the response for performance monitoring."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/custom_request_and_route/tutorial002.py", "function": "get_route_handler", "line_number": 9, "body": "def get_route_handler(self) -> Callable:\n        original_route_handler = super().get_route_handler()\n\n        async def custom_route_handler(request: Request) -> Response:\n            try:\n                return await original_route_handler(request)\n            except RequestValidationError as exc:\n                body = await request.body()\n                detail = {\"errors\": exc.errors(), \"body\": body.decode()}\n                raise HTTPException(status_code=422, detail=detail)\n\n        return custom_route_handler", "is_method": true, "class_name": "ValidationErrorLoggingRoute", "function_description": "This method returns a route handler that catches `RequestValidationError`s. It enriches the error response by including the original request body, enabling better debugging of validation failures."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependencies/tutorial005.py", "function": "query_or_cookie_extractor", "line_number": 12, "body": "def query_or_cookie_extractor(\n    q: str = Depends(query_extractor), last_query: Optional[str] = Cookie(None)\n):\n    if not q:\n        return last_query\n    return q", "is_method": false, "function_description": "This function retrieves a query string. It prioritizes a new query from the request, falling back to a previously stored query from a cookie if no new query is provided."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependencies/tutorial010.py", "function": "__enter__", "line_number": 5, "body": "def __enter__(self):\n        return self.db", "is_method": true, "class_name": "MySuperContextManager", "function_description": "Prepares the context and returns the managed database resource, making it available for use within a 'with' statement."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependencies/tutorial010.py", "function": "__exit__", "line_number": 8, "body": "def __exit__(self, exc_type, exc_value, traceback):\n        self.db.close()", "is_method": true, "class_name": "MySuperContextManager", "function_description": "Ensures the database connection is closed when exiting the context, guaranteeing proper resource release."}, {"file": "./dataset/RepoExec/test-apps/fastapi/docs_src/dependencies/tutorial011.py", "function": "__call__", "line_number": 10, "body": "def __call__(self, q: str = \"\"):\n        if q:\n            return self.fixed_content in q\n        return False", "is_method": true, "class_name": "FixedContentQueryChecker", "function_description": "This method allows the `FixedContentQueryChecker` instance to act as a function, checking if a provided query string contains its pre-defined fixed content. It returns true if the content is found in the non-empty query."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "_prepare_response_content", "line_number": 60, "body": "def _prepare_response_content(\n    res: Any,\n    *,\n    exclude_unset: bool,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -> Any:\n    if isinstance(res, BaseModel):\n        read_with_orm_mode = getattr(res.__config__, \"read_with_orm_mode\", None)\n        if read_with_orm_mode:\n            # Let from_orm extract the data from this model instead of converting\n            # it now to a dict.\n            # Otherwise there's no way to extract lazy data that requires attribute\n            # access instead of dict iteration, e.g. lazy relationships.\n            return res\n        return res.dict(\n            by_alias=True,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n    elif isinstance(res, list):\n        return [\n            _prepare_response_content(\n                item,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for item in res\n        ]\n    elif isinstance(res, dict):\n        return {\n            k: _prepare_response_content(\n                v,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for k, v in res.items()\n        }\n    elif dataclasses.is_dataclass(res):\n        return dataclasses.asdict(res)\n    return res", "is_method": false, "function_description": "Prepares various data structures (Pydantic models, lists, dicts, dataclasses) for serialization. It converts them into a dictionary format, applying specified exclusion rules for values."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "get_request_handler", "line_number": 164, "body": "def get_request_handler(\n    dependant: Dependant,\n    body_field: Optional[ModelField] = None,\n    status_code: Optional[int] = None,\n    response_class: Union[Type[Response], DefaultPlaceholder] = Default(JSONResponse),\n    response_field: Optional[ModelField] = None,\n    response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    response_model_by_alias: bool = True,\n    response_model_exclude_unset: bool = False,\n    response_model_exclude_defaults: bool = False,\n    response_model_exclude_none: bool = False,\n    dependency_overrides_provider: Optional[Any] = None,\n) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.field_info, params.Form)\n    if isinstance(response_class, DefaultPlaceholder):\n        actual_response_class: Type[Response] = response_class.value\n    else:\n        actual_response_class = response_class\n\n    async def app(request: Request) -> Response:\n        try:\n            body: Any = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        json_body: Any = Undefined\n                        content_type_value = request.headers.get(\"content-type\")\n                        if not content_type_value:\n                            json_body = await request.json()\n                        else:\n                            message = email.message.Message()\n                            message[\"content-type\"] = content_type_value\n                            if message.get_content_maintype() == \"application\":\n                                subtype = message.get_content_subtype()\n                                if subtype == \"json\" or subtype.endswith(\"+json\"):\n                                    json_body = await request.json()\n                        if json_body != Undefined:\n                            body = json_body\n                        else:\n                            body = body_bytes\n        except json.JSONDecodeError as e:\n            raise RequestValidationError([ErrorWrapper(e, (\"body\", e.pos))], body=e.doc)\n        except Exception as e:\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            ) from e\n        solved_result = await solve_dependencies(\n            request=request,\n            dependant=dependant,\n            body=body,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, background_tasks, sub_response, _ = solved_result\n        if errors:\n            raise RequestValidationError(errors, body=body)\n        else:\n            raw_response = await run_endpoint_function(\n                dependant=dependant, values=values, is_coroutine=is_coroutine\n            )\n\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = await serialize_response(\n                field=response_field,\n                response_content=raw_response,\n                include=response_model_include,\n                exclude=response_model_exclude,\n                by_alias=response_model_by_alias,\n                exclude_unset=response_model_exclude_unset,\n                exclude_defaults=response_model_exclude_defaults,\n                exclude_none=response_model_exclude_none,\n                is_coroutine=is_coroutine,\n            )\n            response_args: Dict[str, Any] = {\"background\": background_tasks}\n            # If status_code was set, use it, otherwise use the default from the\n            # response class, in the case of redirect it's 307\n            if status_code is not None:\n                response_args[\"status_code\"] = status_code\n            response = actual_response_class(response_data, **response_args)\n            response.headers.raw.extend(sub_response.headers.raw)\n            if sub_response.status_code:\n                response.status_code = sub_response.status_code\n            return response\n\n    return app", "is_method": false, "function_description": "Generates an asynchronous HTTP request handler that parses the request body, resolves dependencies, executes the associated endpoint function, and serializes its output into a web response."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "get_websocket_app", "line_number": 259, "body": "def get_websocket_app(\n    dependant: Dependant, dependency_overrides_provider: Optional[Any] = None\n) -> Callable[[WebSocket], Coroutine[Any, Any, Any]]:\n    async def app(websocket: WebSocket) -> None:\n        solved_result = await solve_dependencies(\n            request=websocket,\n            dependant=dependant,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, _, _2, _3 = solved_result\n        if errors:\n            await websocket.close(code=WS_1008_POLICY_VIOLATION)\n            raise WebSocketRequestValidationError(errors)\n        assert dependant.call is not None, \"dependant.call must be a function\"\n        await dependant.call(**values)\n\n    return app", "is_method": false, "function_description": "Creates a WebSocket application handler that resolves and injects dependencies for a WebSocket endpoint function. It ensures all required dependencies are met before the function executes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "get_route_handler", "line_number": 419, "body": "def get_route_handler(self) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n        return get_request_handler(\n            dependant=self.dependant,\n            body_field=self.body_field,\n            status_code=self.status_code,\n            response_class=self.response_class,\n            response_field=self.secure_cloned_response_field,\n            response_model_include=self.response_model_include,\n            response_model_exclude=self.response_model_exclude,\n            response_model_by_alias=self.response_model_by_alias,\n            response_model_exclude_unset=self.response_model_exclude_unset,\n            response_model_exclude_defaults=self.response_model_exclude_defaults,\n            response_model_exclude_none=self.response_model_exclude_none,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )", "is_method": true, "class_name": "APIRoute", "function_description": "Provides the configured request handler for the API route. This handler encapsulates all route-specific settings for processing incoming HTTP requests."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "add_api_route", "line_number": 479, "body": "def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        name: Optional[str] = None,\n        route_class_override: Optional[Type[APIRoute]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        route_class = route_class_override or self.route_class\n        responses = responses or {}\n        combined_responses = {**self.responses, **responses}\n        current_response_class = get_value_or_default(\n            response_class, self.default_response_class\n        )\n        current_tags = self.tags.copy()\n        if tags:\n            current_tags.extend(tags)\n        current_dependencies = self.dependencies.copy()\n        if dependencies:\n            current_dependencies.extend(dependencies)\n        current_callbacks = self.callbacks.copy()\n        if callbacks:\n            current_callbacks.extend(callbacks)\n        route = route_class(\n            self.prefix + path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=current_tags,\n            dependencies=current_dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=combined_responses,\n            deprecated=deprecated or self.deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema and self.include_in_schema,\n            response_class=current_response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            callbacks=current_callbacks,\n            openapi_extra=openapi_extra,\n        )\n        self.routes.append(route)", "is_method": true, "class_name": "APIRouter", "function_description": "Registers a new API endpoint by associating a URL path with an endpoint function. It allows extensive configuration for the route's behavior, documentation, and dependencies."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "api_route", "line_number": 554, "body": "def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                callbacks=callbacks,\n                openapi_extra=openapi_extra,\n            )\n            return func\n\n        return decorator", "is_method": true, "class_name": "APIRouter", "function_description": "This method serves as a decorator factory to register a Python function as an API endpoint. It configures the route's path, HTTP methods, response models, and OpenAPI documentation details."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "add_api_websocket_route", "line_number": 612, "body": "def add_api_websocket_route(\n        self, path: str, endpoint: Callable[..., Any], name: Optional[str] = None\n    ) -> None:\n        route = APIWebSocketRoute(\n            path,\n            endpoint=endpoint,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n        self.routes.append(route)", "is_method": true, "class_name": "APIRouter", "function_description": "Registers a new WebSocket endpoint on the API router. It maps a URL path to a handler function for WebSocket connections."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "websocket", "line_number": 623, "body": "def websocket(\n        self, path: str, name: Optional[str] = None\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator", "is_method": true, "class_name": "APIRouter", "function_description": "This method acts as a decorator to register a function as a WebSocket route. It allows defining real-time communication endpoints within the API router."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "include_router", "line_number": 632, "body": "def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        else:\n            for r in router.routes:\n                path = getattr(r, \"path\")\n                name = getattr(r, \"name\", \"unknown\")\n                if path is not None and not path:\n                    raise Exception(\n                        f\"Prefix and path cannot be both empty (path operation: {name})\"\n                    )\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                use_response_class = get_value_or_default(\n                    route.response_class,\n                    router.default_response_class,\n                    default_response_class,\n                    self.default_response_class,\n                )\n                current_tags = []\n                if tags:\n                    current_tags.extend(tags)\n                if route.tags:\n                    current_tags.extend(route.tags)\n                current_dependencies: List[params.Depends] = []\n                if dependencies:\n                    current_dependencies.extend(dependencies)\n                if route.dependencies:\n                    current_dependencies.extend(route.dependencies)\n                current_callbacks = []\n                if callbacks:\n                    current_callbacks.extend(callbacks)\n                if route.callbacks:\n                    current_callbacks.extend(route.callbacks)\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=current_tags,\n                    dependencies=current_dependencies,\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated or deprecated or self.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_exclude_unset=route.response_model_exclude_unset,\n                    response_model_exclude_defaults=route.response_model_exclude_defaults,\n                    response_model_exclude_none=route.response_model_exclude_none,\n                    include_in_schema=route.include_in_schema\n                    and self.include_in_schema\n                    and include_in_schema,\n                    response_class=use_response_class,\n                    name=route.name,\n                    route_class_override=type(route),\n                    callbacks=current_callbacks,\n                    openapi_extra=route.openapi_extra,\n                )\n            elif isinstance(route, routing.Route):\n                methods = list(route.methods or [])  # type: ignore # in Starlette\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=methods,\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                self.add_api_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n        for handler in router.on_startup:\n            self.add_event_handler(\"startup\", handler)\n        for handler in router.on_shutdown:\n            self.add_event_handler(\"shutdown\", handler)", "is_method": true, "class_name": "APIRouter", "function_description": "Enables modular API design by integrating routes and event handlers from another router into the current one. It allows applying a path prefix and combining various configurations for the included routes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "get", "line_number": 735, "body": "def get(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Defines an API route that handles HTTP GET requests for a specified path. It decorates a function to configure the endpoint's behavior, response models, and OpenAPI documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "put", "line_number": 787, "body": "def put(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Registers an HTTP PUT endpoint for the API, allowing extensive configuration of its behavior, response model, and OpenAPI documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "post", "line_number": 839, "body": "def post(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Provides a decorator to register an API endpoint that processes HTTP POST requests. It allows comprehensive configuration for path, responses, and OpenAPI documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "delete", "line_number": 891, "body": "def delete(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "This method serves as a decorator to define an API route that processes HTTP DELETE requests, offering comprehensive configuration for responses and OpenAPI specification."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "options", "line_number": 943, "body": "def options(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Provides a decorator to define an API endpoint that specifically handles HTTP OPTIONS requests. It configures the route's response model, status code, dependencies, and OpenAPI documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "head", "line_number": 995, "body": "def head(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Configures an API route to handle HTTP HEAD requests for a given path. This allows defining endpoints that return only headers, useful for checking resource metadata or existence."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "patch", "line_number": 1047, "body": "def patch(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "This `APIRouter` method registers an API endpoint that handles HTTP PATCH requests. It serves as a decorator to define route functions, allowing comprehensive configuration for endpoint behavior and documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "trace", "line_number": 1099, "body": "def trace(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "APIRouter", "function_description": "Registers an API endpoint to handle HTTP TRACE requests. It allows configuring the route with various options like response models, status codes, and OpenAPI documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "decorator", "line_number": 581, "body": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                callbacks=callbacks,\n                openapi_extra=openapi_extra,\n            )\n            return func", "is_method": true, "class_name": "APIRouter", "function_description": "Provides a decorator to register a Python function as an API endpoint within the router, configuring its path, response model, and other API specifications."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/routing.py", "function": "decorator", "line_number": 626, "body": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func", "is_method": true, "class_name": "APIRouter", "function_description": "Registers the decorated function as an API WebSocket route within this router. It provides a convenient way to declare WebSocket endpoints."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "openapi", "line_number": 134, "body": "def openapi(self) -> Dict[str, Any]:\n        if not self.openapi_schema:\n            self.openapi_schema = get_openapi(\n                title=self.title,\n                version=self.version,\n                openapi_version=self.openapi_version,\n                description=self.description,\n                terms_of_service=self.terms_of_service,\n                contact=self.contact,\n                license_info=self.license_info,\n                routes=self.routes,\n                tags=self.openapi_tags,\n                servers=self.servers,\n            )\n        return self.openapi_schema", "is_method": true, "class_name": "FastAPI", "function_description": "This method generates or retrieves the OpenAPI specification (formerly Swagger) for the FastAPI application, enabling standardized API documentation and client generation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "setup", "line_number": 150, "body": "def setup(self) -> None:\n        if self.openapi_url:\n            urls = (server_data.get(\"url\") for server_data in self.servers)\n            server_urls = {url for url in urls if url}\n\n            async def openapi(req: Request) -> JSONResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                if root_path not in server_urls:\n                    if root_path and self.root_path_in_servers:\n                        self.servers.insert(0, {\"url\": root_path})\n                        server_urls.add(root_path)\n                return JSONResponse(self.openapi())\n\n            self.add_route(self.openapi_url, openapi, include_in_schema=False)\n        if self.openapi_url and self.docs_url:\n\n            async def swagger_ui_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                oauth2_redirect_url = self.swagger_ui_oauth2_redirect_url\n                if oauth2_redirect_url:\n                    oauth2_redirect_url = root_path + oauth2_redirect_url\n                return get_swagger_ui_html(\n                    openapi_url=openapi_url,\n                    title=self.title + \" - Swagger UI\",\n                    oauth2_redirect_url=oauth2_redirect_url,\n                    init_oauth=self.swagger_ui_init_oauth,\n                )\n\n            self.add_route(self.docs_url, swagger_ui_html, include_in_schema=False)\n\n            if self.swagger_ui_oauth2_redirect_url:\n\n                async def swagger_ui_redirect(req: Request) -> HTMLResponse:\n                    return get_swagger_ui_oauth2_redirect_html()\n\n                self.add_route(\n                    self.swagger_ui_oauth2_redirect_url,\n                    swagger_ui_redirect,\n                    include_in_schema=False,\n                )\n        if self.openapi_url and self.redoc_url:\n\n            async def redoc_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                return get_redoc_html(\n                    openapi_url=openapi_url, title=self.title + \" - ReDoc\"\n                )\n\n            self.add_route(self.redoc_url, redoc_html, include_in_schema=False)", "is_method": true, "class_name": "FastAPI", "function_description": "Configures and adds routes for serving the OpenAPI specification, Swagger UI, and ReDoc documentation interfaces. This enables automatic, interactive API documentation for the FastAPI application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "add_api_route", "line_number": 212, "body": "def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Coroutine[Any, Any, Response]],\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        name: Optional[str] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        self.router.add_api_route(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "This method registers a new API route within the FastAPI application, connecting a URL path to a specific endpoint function. It offers extensive options to configure the route's behavior, documentation, and response characteristics."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "api_route", "line_number": 267, "body": "def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.router.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                openapi_extra=openapi_extra,\n            )\n            return func\n\n        return decorator", "is_method": true, "class_name": "FastAPI", "function_description": "Registers a Python function as an API endpoint, defining its path, HTTP methods, response models, and OpenAPI documentation details."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "add_api_websocket_route", "line_number": 323, "body": "def add_api_websocket_route(\n        self, path: str, endpoint: Callable[..., Any], name: Optional[str] = None\n    ) -> None:\n        self.router.add_api_websocket_route(path, endpoint, name=name)", "is_method": true, "class_name": "FastAPI", "function_description": "This method adds a WebSocket route to the FastAPI application, mapping a URL path to an endpoint function for real-time communication."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "websocket", "line_number": 328, "body": "def websocket(\n        self, path: str, name: Optional[str] = None\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator", "is_method": true, "class_name": "FastAPI", "function_description": "Provides a decorator to register a Python function as a WebSocket endpoint. It maps a given URL path to the decorated function for handling WebSocket connections in FastAPI."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "include_router", "line_number": 337, "body": "def include_router(\n        self,\n        router: routing.APIRouter,\n        *,\n        prefix: str = \"\",\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> None:\n        self.router.include_router(\n            router,\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            responses=responses,\n            deprecated=deprecated,\n            include_in_schema=include_in_schema,\n            default_response_class=default_response_class,\n            callbacks=callbacks,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Adds a collection of API routes and their configurations from an APIRouter to the FastAPI application. It enables modular design and organization for web APIs."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "get", "line_number": 362, "body": "def get(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.get(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Registers an API endpoint that handles HTTP GET requests for a given path. It provides extensive configuration for responses, dependencies, and OpenAPI documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "put", "line_number": 413, "body": "def put(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.put(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Configures and registers an API endpoint to handle HTTP PUT requests at a specified path. It serves as a decorator for functions that update resources, allowing detailed OpenAPI documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "post", "line_number": 464, "body": "def post(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.post(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Configures an API endpoint to handle HTTP POST requests. It allows defining a path, response models, documentation, and other route-specific behaviors for your FastAPI application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "delete", "line_number": 515, "body": "def delete(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.delete(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            operation_id=operation_id,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "This method acts as a decorator to define an HTTP DELETE endpoint in a FastAPI application. It configures the route's path, response model, status code, and OpenAPI documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "options", "line_number": 566, "body": "def options(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.options(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Configures an API endpoint to respond to HTTP OPTIONS requests at a given path. It enables defining custom behavior and OpenAPI documentation for the route."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "head", "line_number": 617, "body": "def head(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.head(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Registers an API endpoint that responds to HTTP HEAD requests for the given path. It enables extensive configuration for the route's behavior and OpenAPI documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "patch", "line_number": 668, "body": "def patch(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.patch(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Defines and configures an API endpoint to handle HTTP PATCH requests. It serves as a decorator for functions that implement partial resource updates, providing comprehensive API documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "trace", "line_number": 719, "body": "def trace(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: Optional[int] = None,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.router.trace(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n        )", "is_method": true, "class_name": "FastAPI", "function_description": "Registers an API route that handles HTTP TRACE requests at the specified path. It allows configuring various route options and OpenAPI documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "decorator", "line_number": 293, "body": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.router.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                openapi_extra=openapi_extra,\n            )\n            return func", "is_method": true, "class_name": "FastAPI", "function_description": "This method serves as a decorator for the FastAPI application, enabling the registration of a Python function as an API route. It configures the endpoint's path, HTTP methods, response model, and OpenAPI documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/applications.py", "function": "decorator", "line_number": 331, "body": "def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func", "is_method": true, "class_name": "FastAPI", "function_description": "Registers the decorated function as a WebSocket endpoint in a FastAPI application. This allows the function to handle WebSocket connections at the specified path."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/encoders.py", "function": "generate_encoders_by_class_tuples", "line_number": 15, "body": "def generate_encoders_by_class_tuples(\n    type_encoder_map: Dict[Any, Callable[[Any], Any]]\n) -> Dict[Callable[[Any], Any], Tuple[Any, ...]]:\n    encoders_by_class_tuples: Dict[Callable[[Any], Any], Tuple[Any, ...]] = defaultdict(\n        tuple\n    )\n    for type_, encoder in type_encoder_map.items():\n        encoders_by_class_tuples[encoder] += (type_,)\n    return encoders_by_class_tuples", "is_method": false, "function_description": "This function transforms a map of types to encoders into a new map where each encoder is associated with a tuple of all types it processes. It effectively groups types by their assigned encoder."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/encoders.py", "function": "jsonable_encoder", "line_number": 29, "body": "def jsonable_encoder(\n    obj: Any,\n    include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    by_alias: bool = True,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    custom_encoder: Dict[Any, Callable[[Any], Any]] = {},\n    sqlalchemy_safe: bool = True,\n) -> Any:\n    if include is not None and not isinstance(include, (set, dict)):\n        include = set(include)\n    if exclude is not None and not isinstance(exclude, (set, dict)):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoder = getattr(obj.__config__, \"json_encoders\", {})\n        if custom_encoder:\n            encoder.update(custom_encoder)\n        obj_dict = obj.dict(\n            include=include,  # type: ignore # in Pydantic\n            exclude=exclude,  # type: ignore # in Pydantic\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_none=exclude_none,\n            exclude_defaults=exclude_defaults,\n        )\n        if \"__root__\" in obj_dict:\n            obj_dict = obj_dict[\"__root__\"]\n        return jsonable_encoder(\n            obj_dict,\n            exclude_none=exclude_none,\n            exclude_defaults=exclude_defaults,\n            custom_encoder=encoder,\n            sqlalchemy_safe=sqlalchemy_safe,\n        )\n    if dataclasses.is_dataclass(obj):\n        return dataclasses.asdict(obj)\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        for key, value in obj.items():\n            if (\n                (\n                    not sqlalchemy_safe\n                    or (not isinstance(key, str))\n                    or (not key.startswith(\"_sa\"))\n                )\n                and (value is not None or not exclude_none)\n                and ((include and key in include) or not exclude or key not in exclude)\n            ):\n                encoded_key = jsonable_encoder(\n                    key,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n                encoded_value = jsonable_encoder(\n                    value,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(\n                jsonable_encoder(\n                    item,\n                    include=include,\n                    exclude=exclude,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_defaults=exclude_defaults,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n            )\n        return encoded_list\n\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder(obj)\n\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n\n    errors: List[Exception] = []\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors)\n    return jsonable_encoder(\n        data,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        custom_encoder=custom_encoder,\n        sqlalchemy_safe=sqlalchemy_safe,\n    )", "is_method": false, "function_description": "Converts complex Python objects, including Pydantic models, into a format suitable for JSON serialization. It offers fine-grained control over fields and supports custom type encoding, facilitating robust data interchange."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/datastructures.py", "function": "Default", "line_number": 45, "body": "def Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)", "is_method": false, "function_description": "Provides an internal marker to distinguish if a default value has been explicitly overwritten, even if the new value is truthy. This function is for internal use and should not be called directly."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/datastructures.py", "function": "__get_validators__", "line_number": 14, "body": "def __get_validators__(cls: Type[\"UploadFile\"]) -> Iterable[Callable[..., Any]]:\n        yield cls.validate", "is_method": true, "class_name": "UploadFile", "function_description": "Registers `UploadFile.validate` as a custom validator. It enables a data validation framework to use the class's own logic for validating `UploadFile` instances."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/datastructures.py", "function": "validate", "line_number": 18, "body": "def validate(cls: Type[\"UploadFile\"], v: Any) -> Any:\n        if not isinstance(v, StarletteUploadFile):\n            raise ValueError(f\"Expected UploadFile, received: {type(v)}\")\n        return v", "is_method": true, "class_name": "UploadFile", "function_description": "This class method validates that an input value is a Starlette `UploadFile` instance. It ensures data type correctness, raising an error for invalid types."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/datastructures.py", "function": "__bool__", "line_number": 35, "body": "def __bool__(self) -> bool:\n        return bool(self.value)", "is_method": true, "class_name": "DefaultPlaceholder", "function_description": "Defines the truthiness of the DefaultPlaceholder object. It returns the boolean equivalent of its encapsulated value."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/datastructures.py", "function": "__eq__", "line_number": 38, "body": "def __eq__(self, o: object) -> bool:\n        return isinstance(o, DefaultPlaceholder) and o.value == self.value", "is_method": true, "class_name": "DefaultPlaceholder", "function_description": "Establishes how DefaultPlaceholder instances are compared for equality, treating them as equal if they are of the same type and share the same internal value."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Path", "line_number": 7, "body": "def Path(  # noqa: N802\n    default: Any,\n    *,\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    deprecated: Optional[bool] = None,\n    **extra: Any,\n) -> Any:\n    return params.Path(\n        default=default,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        deprecated=deprecated,\n        **extra,\n    )", "is_method": false, "function_description": "This function defines an API path parameter, including its metadata, validation rules, and examples. It enables automatic documentation and robust data handling for web requests."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Query", "line_number": 44, "body": "def Query(  # noqa: N802\n    default: Any,\n    *,\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    deprecated: Optional[bool] = None,\n    **extra: Any,\n) -> Any:\n    return params.Query(\n        default,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        deprecated=deprecated,\n        **extra,\n    )", "is_method": false, "function_description": "Declares an API query parameter, providing default values, validation constraints (e.g., numeric ranges, string length), and descriptive metadata for documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Header", "line_number": 81, "body": "def Header(  # noqa: N802\n    default: Any,\n    *,\n    alias: Optional[str] = None,\n    convert_underscores: bool = True,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    deprecated: Optional[bool] = None,\n    **extra: Any,\n) -> Any:\n    return params.Header(\n        default,\n        alias=alias,\n        convert_underscores=convert_underscores,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        deprecated=deprecated,\n        **extra,\n    )", "is_method": false, "function_description": "Defines an HTTP header parameter for API routes, allowing specification of a default value, validation constraints, and rich metadata for documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Cookie", "line_number": 120, "body": "def Cookie(  # noqa: N802\n    default: Any,\n    *,\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    deprecated: Optional[bool] = None,\n    **extra: Any,\n) -> Any:\n    return params.Cookie(\n        default,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        deprecated=deprecated,\n        **extra,\n    )", "is_method": false, "function_description": "This function serves as a factory to define a web cookie parameter. It allows specifying a default value along with various validation constraints and metadata for API documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Body", "line_number": 157, "body": "def Body(  # noqa: N802\n    default: Any,\n    *,\n    embed: bool = False,\n    media_type: str = \"application/json\",\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    **extra: Any,\n) -> Any:\n    return params.Body(\n        default,\n        embed=embed,\n        media_type=media_type,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        **extra,\n    )", "is_method": false, "function_description": "Declares and configures an HTTP request body parameter, specifying its default value, media type, and validation rules. It also provides metadata for API documentation like title and description."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Form", "line_number": 196, "body": "def Form(  # noqa: N802\n    default: Any,\n    *,\n    media_type: str = \"application/x-www-form-urlencoded\",\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    **extra: Any,\n) -> Any:\n    return params.Form(\n        default,\n        media_type=media_type,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        **extra,\n    )", "is_method": false, "function_description": "Declares an API endpoint parameter that expects form data, allowing for default values, metadata like title and description, and various validation rules."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "File", "line_number": 233, "body": "def File(  # noqa: N802\n    default: Any,\n    *,\n    media_type: str = \"multipart/form-data\",\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    example: Any = Undefined,\n    examples: Optional[Dict[str, Any]] = None,\n    **extra: Any,\n) -> Any:\n    return params.File(\n        default,\n        media_type=media_type,\n        alias=alias,\n        title=title,\n        description=description,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        example=example,\n        examples=examples,\n        **extra,\n    )", "is_method": false, "function_description": "Defines a file upload parameter for an API or data model. It allows specifying media type, metadata, and various validation constraints for the uploaded file."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Depends", "line_number": 270, "body": "def Depends(  # noqa: N802\n    dependency: Optional[Callable[..., Any]] = None, *, use_cache: bool = True\n) -> Any:\n    return params.Depends(dependency=dependency, use_cache=use_cache)", "is_method": false, "function_description": "Declares a dependency that can be resolved by a callable, with an option to cache its result. Typically used in dependency injection systems to specify required components."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/param_functions.py", "function": "Security", "line_number": 276, "body": "def Security(  # noqa: N802\n    dependency: Optional[Callable[..., Any]] = None,\n    *,\n    scopes: Optional[Sequence[str]] = None,\n    use_cache: bool = True,\n) -> Any:\n    return params.Security(dependency=dependency, scopes=scopes, use_cache=use_cache)", "is_method": false, "function_description": "Defines security requirements for an operation, including required scopes and dependencies. This enables enforcing access control and leveraging dependency injection with caching."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/responses.py", "function": "render", "line_number": 24, "body": "def render(self, content: Any) -> bytes:\n        assert ujson is not None, \"ujson must be installed to use UJSONResponse\"\n        return ujson.dumps(content, ensure_ascii=False).encode(\"utf-8\")", "is_method": true, "class_name": "UJSONResponse", "function_description": "This `UJSONResponse` method serializes arbitrary Python content into a UTF-8 encoded JSON byte string. It provides a fast way to prepare JSON data for network transmission."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/responses.py", "function": "render", "line_number": 32, "body": "def render(self, content: Any) -> bytes:\n        assert orjson is not None, \"orjson must be installed to use ORJSONResponse\"\n        return orjson.dumps(content)", "is_method": true, "class_name": "ORJSONResponse", "function_description": "This method efficiently serializes Python data into a JSON byte string, preparing it for an HTTP response."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/params.py", "function": "__repr__", "line_number": 54, "body": "def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.default})\"", "is_method": true, "class_name": "Param", "function_description": "Provides a developer-friendly string representation of a Param object, showing its class name and default value. Useful for debugging and inspection."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/params.py", "function": "__repr__", "line_number": 265, "body": "def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.default})\"", "is_method": true, "class_name": "Body", "function_description": "Provides a clear, developer-friendly string representation of the object. It displays the class name and the value of its `default` attribute for inspection."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/params.py", "function": "__repr__", "line_number": 355, "body": "def __repr__(self) -> str:\n        attr = getattr(self.dependency, \"__name__\", type(self.dependency).__name__)\n        cache = \"\" if self.use_cache else \", use_cache=False\"\n        return f\"{self.__class__.__name__}({attr}{cache})\"", "is_method": true, "class_name": "Depends", "function_description": "Provides a concise string representation of the `Depends` object. It displays the name of the wrapped dependency and whether caching is disabled, useful for debugging."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "get_model_definitions", "line_number": 17, "body": "def get_model_definitions(\n    *,\n    flat_models: Set[Union[Type[BaseModel], Type[Enum]]],\n    model_name_map: Dict[Union[Type[BaseModel], Type[Enum]], str],\n) -> Dict[str, Any]:\n    definitions: Dict[str, Dict[str, Any]] = {}\n    for model in flat_models:\n        m_schema, m_definitions, m_nested_models = model_process_schema(\n            model, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n        )\n        definitions.update(m_definitions)\n        model_name = model_name_map[model]\n        definitions[model_name] = m_schema\n    return definitions", "is_method": false, "function_description": "Generates a comprehensive dictionary of schema definitions for a given set of data models and enums. It processes each model and its nested structures to provide a complete schema representation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "get_path_param_names", "line_number": 33, "body": "def get_path_param_names(path: str) -> Set[str]:\n    return set(re.findall(\"{(.*?)}\", path))", "is_method": false, "function_description": "Provides the unique names of dynamic path parameters found within a URL route string. Useful for routing and API endpoint definition."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "create_response_field", "line_number": 37, "body": "def create_response_field(\n    name: str,\n    type_: Type[Any],\n    class_validators: Optional[Dict[str, Validator]] = None,\n    default: Optional[Any] = None,\n    required: Union[bool, UndefinedType] = False,\n    model_config: Type[BaseConfig] = BaseConfig,\n    field_info: Optional[FieldInfo] = None,\n    alias: Optional[str] = None,\n) -> ModelField:\n    \"\"\"\n    Create a new response field. Raises if type_ is invalid.\n    \"\"\"\n    class_validators = class_validators or {}\n    field_info = field_info or FieldInfo(None)\n\n    response_field = functools.partial(\n        ModelField,\n        name=name,\n        type_=type_,\n        class_validators=class_validators,\n        default=default,\n        required=required,\n        model_config=model_config,\n        alias=alias,\n    )\n\n    try:\n        return response_field(field_info=field_info)\n    except RuntimeError:\n        raise fastapi.exceptions.FastAPIError(\n            f\"Invalid args for response field! Hint: check that {type_} is a valid pydantic field type\"\n        )", "is_method": false, "function_description": "Creates a `ModelField` object, defining a structured data field for validation or API responses. It sets properties like name, type, and default values."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "create_cloned_field", "line_number": 72, "body": "def create_cloned_field(\n    field: ModelField,\n    *,\n    cloned_types: Optional[Dict[Type[BaseModel], Type[BaseModel]]] = None,\n) -> ModelField:\n    # _cloned_types has already cloned types, to support recursive models\n    if cloned_types is None:\n        cloned_types = dict()\n    original_type = field.type_\n    if is_dataclass(original_type) and hasattr(original_type, \"__pydantic_model__\"):\n        original_type = original_type.__pydantic_model__\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = cloned_types.get(original_type)\n        if use_type is None:\n            use_type = create_model(original_type.__name__, __base__=original_type)\n            cloned_types[original_type] = use_type\n            for f in original_type.__fields__.values():\n                use_type.__fields__[f.name] = create_cloned_field(\n                    f, cloned_types=cloned_types\n                )\n    new_field = create_response_field(name=field.name, type_=use_type)\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    new_field.field_info = field.field_info\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [\n            create_cloned_field(sub_field, cloned_types=cloned_types)\n            for sub_field in field.sub_fields\n        ]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(\n            field.key_field, cloned_types=cloned_types\n        )\n    new_field.validators = field.validators\n    new_field.pre_validators = field.pre_validators\n    new_field.post_validators = field.post_validators\n    new_field.parse_json = field.parse_json\n    new_field.shape = field.shape\n    new_field.populate_validators()\n    return new_field", "is_method": false, "function_description": "Creates a new `ModelField` by deep cloning an existing one. It recursively duplicates Pydantic model types and their nested fields, useful for generating new model structures."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "generate_operation_id_for_path", "line_number": 122, "body": "def generate_operation_id_for_path(*, name: str, path: str, method: str) -> str:\n    operation_id = name + path\n    operation_id = re.sub(\"[^0-9a-zA-Z_]\", \"_\", operation_id)\n    operation_id = operation_id + \"_\" + method.lower()\n    return operation_id", "is_method": false, "function_description": "Generates a unique, sanitized identifier string (operation ID) from a name, path, and HTTP method. This standardizes ID creation for API specifications or internal routing purposes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "deep_dict_update", "line_number": 129, "body": "def deep_dict_update(main_dict: Dict[Any, Any], update_dict: Dict[Any, Any]) -> None:\n    for key in update_dict:\n        if (\n            key in main_dict\n            and isinstance(main_dict[key], dict)\n            and isinstance(update_dict[key], dict)\n        ):\n            deep_dict_update(main_dict[key], update_dict[key])\n        else:\n            main_dict[key] = update_dict[key]", "is_method": false, "function_description": "Recursively merges `update_dict` into `main_dict`, performing a deep update that combines nested dictionaries rather than overwriting them. It provides a utility for deeply merging configurations or data structures."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/utils.py", "function": "get_value_or_default", "line_number": 141, "body": "def get_value_or_default(\n    first_item: Union[DefaultPlaceholder, DefaultType],\n    *extra_items: Union[DefaultPlaceholder, DefaultType],\n) -> Union[DefaultPlaceholder, DefaultType]:\n    \"\"\"\n    Pass items or `DefaultPlaceholder`s by descending priority.\n\n    The first one to _not_ be a `DefaultPlaceholder` will be returned.\n\n    Otherwise, the first item (a `DefaultPlaceholder`) will be returned.\n    \"\"\"\n    items = (first_item,) + extra_items\n    for item in items:\n        if not isinstance(item, DefaultPlaceholder):\n            return item\n    return first_item", "is_method": false, "function_description": "This function retrieves the first non-placeholder value from a sequence of prioritized items. If all items are placeholders, it returns the initial placeholder."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/security/utils.py", "function": "get_authorization_scheme_param", "line_number": 4, "body": "def get_authorization_scheme_param(authorization_header_value: str) -> Tuple[str, str]:\n    if not authorization_header_value:\n        return \"\", \"\"\n    scheme, _, param = authorization_header_value.partition(\" \")\n    return scheme, param", "is_method": false, "function_description": "This function parses an HTTP Authorization header value, extracting the authentication scheme and its associated parameter. It provides the core components needed to process incoming authentication requests."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/models.py", "function": "__get_validators__", "line_number": 16, "body": "def __get_validators__(cls) -> Iterable[Callable[..., Any]]:\n            yield cls.validate", "is_method": true, "class_name": "EmailStr", "function_description": "This method registers the `EmailStr` class's `validate` function for use by a data validation framework. It enables automatic validation of strings as email addresses."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi_security_definitions", "line_number": 69, "body": "def get_openapi_security_definitions(\n    flat_dependant: Dependant,\n) -> Tuple[Dict[str, Any], List[Dict[str, Any]]]:\n    security_definitions = {}\n    operation_security = []\n    for security_requirement in flat_dependant.security_requirements:\n        security_definition = jsonable_encoder(\n            security_requirement.security_scheme.model,\n            by_alias=True,\n            exclude_none=True,\n        )\n        security_name = security_requirement.security_scheme.scheme_name\n        security_definitions[security_name] = security_definition\n        operation_security.append({security_name: security_requirement.scopes})\n    return security_definitions, operation_security", "is_method": false, "function_description": "This function processes security requirements from a dependant object. It generates the OpenAPI security definitions and operation-level security configurations for API documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi_operation_parameters", "line_number": 86, "body": "def get_openapi_operation_parameters(\n    *,\n    all_route_params: Sequence[ModelField],\n    model_name_map: Dict[Union[Type[BaseModel], Type[Enum]], str],\n) -> List[Dict[str, Any]]:\n    parameters = []\n    for param in all_route_params:\n        field_info = param.field_info\n        field_info = cast(Param, field_info)\n        parameter = {\n            \"name\": param.alias,\n            \"in\": field_info.in_.value,\n            \"required\": param.required,\n            \"schema\": field_schema(\n                param, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n            )[0],\n        }\n        if field_info.description:\n            parameter[\"description\"] = field_info.description\n        if field_info.examples:\n            parameter[\"examples\"] = jsonable_encoder(field_info.examples)\n        elif field_info.example != Undefined:\n            parameter[\"example\"] = jsonable_encoder(field_info.example)\n        if field_info.deprecated:\n            parameter[\"deprecated\"] = field_info.deprecated\n        parameters.append(parameter)\n    return parameters", "is_method": false, "function_description": "Generates a list of OpenAPI parameter objects from a sequence of route parameters. It maps internal Python parameter definitions to the standardized OpenAPI specification format for API documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi_operation_request_body", "line_number": 115, "body": "def get_openapi_operation_request_body(\n    *,\n    body_field: Optional[ModelField],\n    model_name_map: Dict[Union[Type[BaseModel], Type[Enum]], str],\n) -> Optional[Dict[str, Any]]:\n    if not body_field:\n        return None\n    assert isinstance(body_field, ModelField)\n    body_schema, _, _ = field_schema(\n        body_field, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n    )\n    field_info = cast(Body, body_field.field_info)\n    request_media_type = field_info.media_type\n    required = body_field.required\n    request_body_oai: Dict[str, Any] = {}\n    if required:\n        request_body_oai[\"required\"] = required\n    request_media_content: Dict[str, Any] = {\"schema\": body_schema}\n    if field_info.examples:\n        request_media_content[\"examples\"] = jsonable_encoder(field_info.examples)\n    elif field_info.example != Undefined:\n        request_media_content[\"example\"] = jsonable_encoder(field_info.example)\n    request_body_oai[\"content\"] = {request_media_type: request_media_content}\n    return request_body_oai", "is_method": false, "function_description": "Generates an OpenAPI request body definition from a Pydantic model field. It includes the schema, media type, and examples for API documentation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "generate_operation_id", "line_number": 141, "body": "def generate_operation_id(*, route: routing.APIRoute, method: str) -> str:\n    if route.operation_id:\n        return route.operation_id\n    path: str = route.path_format\n    return generate_operation_id_for_path(name=route.name, path=path, method=method)", "is_method": false, "function_description": "Provides a unique operation ID for an API route. It prioritizes a predefined ID or generates one based on the route's path, name, and HTTP method."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "generate_operation_summary", "line_number": 148, "body": "def generate_operation_summary(*, route: routing.APIRoute, method: str) -> str:\n    if route.summary:\n        return route.summary\n    return route.name.replace(\"_\", \" \").title()", "is_method": false, "function_description": "Provides a concise, user-friendly summary for an API operation. It uses a predefined summary if available or formats the route's name."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi_operation_metadata", "line_number": 154, "body": "def get_openapi_operation_metadata(\n    *, route: routing.APIRoute, method: str\n) -> Dict[str, Any]:\n    operation: Dict[str, Any] = {}\n    if route.tags:\n        operation[\"tags\"] = route.tags\n    operation[\"summary\"] = generate_operation_summary(route=route, method=method)\n    if route.description:\n        operation[\"description\"] = route.description\n    operation[\"operationId\"] = generate_operation_id(route=route, method=method)\n    if route.deprecated:\n        operation[\"deprecated\"] = route.deprecated\n    return operation", "is_method": false, "function_description": "Compiles a dictionary of essential OpenAPI metadata for a given API route and HTTP method. This includes operation tags, summary, description, and a unique operation ID."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi_path", "line_number": 169, "body": "def get_openapi_path(\n    *, route: routing.APIRoute, model_name_map: Dict[type, str]\n) -> Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any]]:\n    path = {}\n    security_schemes: Dict[str, Any] = {}\n    definitions: Dict[str, Any] = {}\n    assert route.methods is not None, \"Methods must be a list\"\n    if isinstance(route.response_class, DefaultPlaceholder):\n        current_response_class: Type[Response] = route.response_class.value\n    else:\n        current_response_class = route.response_class\n    assert current_response_class, \"A response class is needed to generate OpenAPI\"\n    route_response_media_type: Optional[str] = current_response_class.media_type\n    if route.include_in_schema:\n        for method in route.methods:\n            operation = get_openapi_operation_metadata(route=route, method=method)\n            parameters: List[Dict[str, Any]] = []\n            flat_dependant = get_flat_dependant(route.dependant, skip_repeats=True)\n            security_definitions, operation_security = get_openapi_security_definitions(\n                flat_dependant=flat_dependant\n            )\n            if operation_security:\n                operation.setdefault(\"security\", []).extend(operation_security)\n            if security_definitions:\n                security_schemes.update(security_definitions)\n            all_route_params = get_flat_params(route.dependant)\n            operation_parameters = get_openapi_operation_parameters(\n                all_route_params=all_route_params, model_name_map=model_name_map\n            )\n            parameters.extend(operation_parameters)\n            if parameters:\n                operation[\"parameters\"] = list(\n                    {param[\"name\"]: param for param in parameters}.values()\n                )\n            if method in METHODS_WITH_BODY:\n                request_body_oai = get_openapi_operation_request_body(\n                    body_field=route.body_field, model_name_map=model_name_map\n                )\n                if request_body_oai:\n                    operation[\"requestBody\"] = request_body_oai\n            if route.callbacks:\n                callbacks = {}\n                for callback in route.callbacks:\n                    if isinstance(callback, routing.APIRoute):\n                        (\n                            cb_path,\n                            cb_security_schemes,\n                            cb_definitions,\n                        ) = get_openapi_path(\n                            route=callback, model_name_map=model_name_map\n                        )\n                        callbacks[callback.name] = {callback.path: cb_path}\n                operation[\"callbacks\"] = callbacks\n            if route.status_code is not None:\n                status_code = str(route.status_code)\n            else:\n                # It would probably make more sense for all response classes to have an\n                # explicit default status_code, and to extract it from them, instead of\n                # doing this inspection tricks, that would probably be in the future\n                # TODO: probably make status_code a default class attribute for all\n                # responses in Starlette\n                response_signature = inspect.signature(current_response_class.__init__)\n                status_code_param = response_signature.parameters.get(\"status_code\")\n                if status_code_param is not None:\n                    if isinstance(status_code_param.default, int):\n                        status_code = str(status_code_param.default)\n            operation.setdefault(\"responses\", {}).setdefault(status_code, {})[\n                \"description\"\n            ] = route.response_description\n            if (\n                route_response_media_type\n                and route.status_code not in STATUS_CODES_WITH_NO_BODY\n            ):\n                response_schema = {\"type\": \"string\"}\n                if lenient_issubclass(current_response_class, JSONResponse):\n                    if route.response_field:\n                        response_schema, _, _ = field_schema(\n                            route.response_field,\n                            model_name_map=model_name_map,\n                            ref_prefix=REF_PREFIX,\n                        )\n                    else:\n                        response_schema = {}\n                operation.setdefault(\"responses\", {}).setdefault(\n                    status_code, {}\n                ).setdefault(\"content\", {}).setdefault(route_response_media_type, {})[\n                    \"schema\"\n                ] = response_schema\n            if route.responses:\n                operation_responses = operation.setdefault(\"responses\", {})\n                for (\n                    additional_status_code,\n                    additional_response,\n                ) in route.responses.items():\n                    process_response = additional_response.copy()\n                    process_response.pop(\"model\", None)\n                    status_code_key = str(additional_status_code).upper()\n                    if status_code_key == \"DEFAULT\":\n                        status_code_key = \"default\"\n                    openapi_response = operation_responses.setdefault(\n                        status_code_key, {}\n                    )\n                    assert isinstance(\n                        process_response, dict\n                    ), \"An additional response must be a dict\"\n                    field = route.response_fields.get(additional_status_code)\n                    additional_field_schema: Optional[Dict[str, Any]] = None\n                    if field:\n                        additional_field_schema, _, _ = field_schema(\n                            field, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n                        )\n                        media_type = route_response_media_type or \"application/json\"\n                        additional_schema = (\n                            process_response.setdefault(\"content\", {})\n                            .setdefault(media_type, {})\n                            .setdefault(\"schema\", {})\n                        )\n                        deep_dict_update(additional_schema, additional_field_schema)\n                    status_text: Optional[str] = status_code_ranges.get(\n                        str(additional_status_code).upper()\n                    ) or http.client.responses.get(int(additional_status_code))\n                    description = (\n                        process_response.get(\"description\")\n                        or openapi_response.get(\"description\")\n                        or status_text\n                        or \"Additional Response\"\n                    )\n                    deep_dict_update(openapi_response, process_response)\n                    openapi_response[\"description\"] = description\n            http422 = str(HTTP_422_UNPROCESSABLE_ENTITY)\n            if (all_route_params or route.body_field) and not any(\n                [\n                    status in operation[\"responses\"]\n                    for status in [http422, \"4XX\", \"default\"]\n                ]\n            ):\n                operation[\"responses\"][http422] = {\n                    \"description\": \"Validation Error\",\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": REF_PREFIX + \"HTTPValidationError\"}\n                        }\n                    },\n                }\n                if \"ValidationError\" not in definitions:\n                    definitions.update(\n                        {\n                            \"ValidationError\": validation_error_definition,\n                            \"HTTPValidationError\": validation_error_response_definition,\n                        }\n                    )\n            if route.openapi_extra:\n                deep_dict_update(operation, route.openapi_extra)\n            path[method.lower()] = operation\n    return path, security_schemes, definitions", "is_method": false, "function_description": "Constructs the OpenAPI Path Item Object for an API route. It defines API operations for each method, including parameters, request/response bodies, security, and callbacks, enabling automatic API documentation generation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_flat_models_from_routes", "line_number": 326, "body": "def get_flat_models_from_routes(\n    routes: Sequence[BaseRoute],\n) -> Set[Union[Type[BaseModel], Type[Enum]]]:\n    body_fields_from_routes: List[ModelField] = []\n    responses_from_routes: List[ModelField] = []\n    request_fields_from_routes: List[ModelField] = []\n    callback_flat_models: Set[Union[Type[BaseModel], Type[Enum]]] = set()\n    for route in routes:\n        if getattr(route, \"include_in_schema\", None) and isinstance(\n            route, routing.APIRoute\n        ):\n            if route.body_field:\n                assert isinstance(\n                    route.body_field, ModelField\n                ), \"A request body must be a Pydantic Field\"\n                body_fields_from_routes.append(route.body_field)\n            if route.response_field:\n                responses_from_routes.append(route.response_field)\n            if route.response_fields:\n                responses_from_routes.extend(route.response_fields.values())\n            if route.callbacks:\n                callback_flat_models |= get_flat_models_from_routes(route.callbacks)\n            params = get_flat_params(route.dependant)\n            request_fields_from_routes.extend(params)\n\n    flat_models = callback_flat_models | get_flat_models_from_fields(\n        body_fields_from_routes + responses_from_routes + request_fields_from_routes,\n        known_models=set(),\n    )\n    return flat_models", "is_method": false, "function_description": "Retrieves all unique Pydantic models and Enums from a sequence of API routes. It consolidates models from request bodies, responses, and parameters, including those within callbacks, essential for API schema generation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/utils.py", "function": "get_openapi", "line_number": 358, "body": "def get_openapi(\n    *,\n    title: str,\n    version: str,\n    openapi_version: str = \"3.0.2\",\n    description: Optional[str] = None,\n    routes: Sequence[BaseRoute],\n    tags: Optional[List[Dict[str, Any]]] = None,\n    servers: Optional[List[Dict[str, Union[str, Any]]]] = None,\n    terms_of_service: Optional[str] = None,\n    contact: Optional[Dict[str, Union[str, Any]]] = None,\n    license_info: Optional[Dict[str, Union[str, Any]]] = None,\n) -> Dict[str, Any]:\n    info: Dict[str, Any] = {\"title\": title, \"version\": version}\n    if description:\n        info[\"description\"] = description\n    if terms_of_service:\n        info[\"termsOfService\"] = terms_of_service\n    if contact:\n        info[\"contact\"] = contact\n    if license_info:\n        info[\"license\"] = license_info\n    output: Dict[str, Any] = {\"openapi\": openapi_version, \"info\": info}\n    if servers:\n        output[\"servers\"] = servers\n    components: Dict[str, Dict[str, Any]] = {}\n    paths: Dict[str, Dict[str, Any]] = {}\n    flat_models = get_flat_models_from_routes(routes)\n    model_name_map = get_model_name_map(flat_models)\n    definitions = get_model_definitions(\n        flat_models=flat_models, model_name_map=model_name_map\n    )\n    for route in routes:\n        if isinstance(route, routing.APIRoute):\n            result = get_openapi_path(route=route, model_name_map=model_name_map)\n            if result:\n                path, security_schemes, path_definitions = result\n                if path:\n                    paths.setdefault(route.path_format, {}).update(path)\n                if security_schemes:\n                    components.setdefault(\"securitySchemes\", {}).update(\n                        security_schemes\n                    )\n                if path_definitions:\n                    definitions.update(path_definitions)\n    if definitions:\n        components[\"schemas\"] = {k: definitions[k] for k in sorted(definitions)}\n    if components:\n        output[\"components\"] = components\n    output[\"paths\"] = paths\n    if tags:\n        output[\"tags\"] = tags\n    return jsonable_encoder(OpenAPI(**output), by_alias=True, exclude_none=True)", "is_method": false, "function_description": "This function constructs a complete OpenAPI specification, detailing API routes, models, and security schemes for documentation and tooling. It provides a standardized description of an API's capabilities."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/docs.py", "function": "get_swagger_ui_html", "line_number": 8, "body": "def get_swagger_ui_html(\n    *,\n    openapi_url: str,\n    title: str,\n    swagger_js_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui-bundle.js\",\n    swagger_css_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui.css\",\n    swagger_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    oauth2_redirect_url: Optional[str] = None,\n    init_oauth: Optional[Dict[str, Any]] = None,\n) -> HTMLResponse:\n\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{swagger_css_url}\">\n    <link rel=\"shortcut icon\" href=\"{swagger_favicon_url}\">\n    <title>{title}</title>\n    </head>\n    <body>\n    <div id=\"swagger-ui\">\n    </div>\n    <script src=\"{swagger_js_url}\"></script>\n    <!-- `SwaggerUIBundle` is now available on the page -->\n    <script>\n    const ui = SwaggerUIBundle({{\n        url: '{openapi_url}',\n    \"\"\"\n\n    if oauth2_redirect_url:\n        html += f\"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',\"\n\n    html += \"\"\"\n        dom_id: '#swagger-ui',\n        presets: [\n        SwaggerUIBundle.presets.apis,\n        SwaggerUIBundle.SwaggerUIStandalonePreset\n        ],\n        layout: \"BaseLayout\",\n        deepLinking: true,\n        showExtensions: true,\n        showCommonExtensions: true\n    })\"\"\"\n\n    if init_oauth:\n        html += f\"\"\"\n        ui.initOAuth({json.dumps(jsonable_encoder(init_oauth))})\n        \"\"\"\n\n    html += \"\"\"\n    </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)", "is_method": false, "function_description": "Creates the HTML page for rendering interactive Swagger UI, allowing users to explore API documentation from an OpenAPI specification."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/docs.py", "function": "get_redoc_html", "line_number": 65, "body": "def get_redoc_html(\n    *,\n    openapi_url: str,\n    title: str,\n    redoc_js_url: str = \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\",\n    redoc_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    with_google_fonts: bool = True,\n) -> HTMLResponse:\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>{title}</title>\n    <!-- needed for adaptive design -->\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    \"\"\"\n    if with_google_fonts:\n        html += \"\"\"\n    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n    \"\"\"\n    html += f\"\"\"\n    <link rel=\"shortcut icon\" href=\"{redoc_favicon_url}\">\n    <!--\n    ReDoc doesn't change outer page styles\n    -->\n    <style>\n      body {{\n        margin: 0;\n        padding: 0;\n      }}\n    </style>\n    </head>\n    <body>\n    <redoc spec-url=\"{openapi_url}\"></redoc>\n    <script src=\"{redoc_js_url}\"> </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)", "is_method": false, "function_description": "Generates the complete HTML content for displaying interactive API documentation using the Redoc library. It allows web applications to serve OpenAPI specifications dynamically."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/openapi/docs.py", "function": "get_swagger_ui_oauth2_redirect_html", "line_number": 107, "body": "def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n    html = \"\"\"\n    <!DOCTYPE html>\n    <html lang=\"en-US\">\n    <body onload=\"run()\">\n    </body>\n    </html>\n    <script>\n        'use strict';\n        function run () {\n            var oauth2 = window.opener.swaggerUIRedirectOauth2;\n            var sentState = oauth2.state;\n            var redirectUrl = oauth2.redirectUrl;\n            var isValid, qp, arr;\n\n            if (/code|token|error/.test(window.location.hash)) {\n                qp = window.location.hash.substring(1);\n            } else {\n                qp = location.search.substring(1);\n            }\n\n            arr = qp.split(\"&\")\n            arr.forEach(function (v,i,_arr) { _arr[i] = '\"' + v.replace('=', '\":\"') + '\"';})\n            qp = qp ? JSON.parse('{' + arr.join() + '}',\n                    function (key, value) {\n                        return key === \"\" ? value : decodeURIComponent(value)\n                    }\n            ) : {}\n\n            isValid = qp.state === sentState\n\n            if ((\n            oauth2.auth.schema.get(\"flow\") === \"accessCode\"||\n            oauth2.auth.schema.get(\"flow\") === \"authorizationCode\"\n            ) && !oauth2.auth.code) {\n                if (!isValid) {\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"warning\",\n                        message: \"Authorization may be unsafe, passed state was changed in server Passed state wasn't returned from auth server\"\n                    });\n                }\n\n                if (qp.code) {\n                    delete oauth2.state;\n                    oauth2.auth.code = qp.code;\n                    oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\n                } else {\n                    let oauthErrorMsg\n                    if (qp.error) {\n                        oauthErrorMsg = \"[\"+qp.error+\"]: \" +\n                            (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\n                            (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\n                    }\n\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"error\",\n                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server\"\n                    });\n                }\n            } else {\n                oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\n            }\n            window.close();\n        }\n    </script>\n        \"\"\"\n    return HTMLResponse(content=html)", "is_method": false, "function_description": "Provides the HTML page and JavaScript logic for Swagger UI's OAuth2 redirect flow. It processes the authorization server's response and securely relays tokens back to Swagger UI."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "check_file_field", "line_number": 89, "body": "def check_file_field(field: ModelField) -> None:\n    field_info = field.field_info\n    if isinstance(field_info, params.Form):\n        try:\n            # __version__ is available in both multiparts, and can be mocked\n            from multipart import __version__  # type: ignore\n\n            assert __version__\n            try:\n                # parse_options_header is only available in the right multipart\n                from multipart.multipart import parse_options_header  # type: ignore\n\n                assert parse_options_header\n            except ImportError:\n                logger.error(multipart_incorrect_install_error)\n                raise RuntimeError(multipart_incorrect_install_error)\n        except ImportError:\n            logger.error(multipart_not_installed_error)\n            raise RuntimeError(multipart_not_installed_error)", "is_method": false, "function_description": "Validates that the `multipart` library, essential for processing form data and file uploads, is correctly installed. This prevents runtime errors related to missing dependencies."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_param_sub_dependant", "line_number": 110, "body": "def get_param_sub_dependant(\n    *, param: inspect.Parameter, path: str, security_scopes: Optional[List[str]] = None\n) -> Dependant:\n    depends: params.Depends = param.default\n    if depends.dependency:\n        dependency = depends.dependency\n    else:\n        dependency = param.annotation\n    return get_sub_dependant(\n        depends=depends,\n        dependency=dependency,\n        path=path,\n        name=param.name,\n        security_scopes=security_scopes,\n    )", "is_method": false, "function_description": "This function resolves a function parameter's dependency to construct a `Dependant` object. It provides the specific callable or object needed for dependency injection, aiding in endpoint dependency graph construction."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_parameterless_sub_dependant", "line_number": 127, "body": "def get_parameterless_sub_dependant(*, depends: params.Depends, path: str) -> Dependant:\n    assert callable(\n        depends.dependency\n    ), \"A parameter-less dependency must have a callable dependency\"\n    return get_sub_dependant(depends=depends, dependency=depends.dependency, path=path)", "is_method": false, "function_description": "Creates a Dependant object for a dependency that takes no parameters. It configures simple, stateless dependencies within a dependency injection framework."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_sub_dependant", "line_number": 134, "body": "def get_sub_dependant(\n    *,\n    depends: params.Depends,\n    dependency: Callable[..., Any],\n    path: str,\n    name: Optional[str] = None,\n    security_scopes: Optional[List[str]] = None,\n) -> Dependant:\n    security_requirement = None\n    security_scopes = security_scopes or []\n    if isinstance(depends, params.Security):\n        dependency_scopes = depends.scopes\n        security_scopes.extend(dependency_scopes)\n    if isinstance(dependency, SecurityBase):\n        use_scopes: List[str] = []\n        if isinstance(dependency, (OAuth2, OpenIdConnect)):\n            use_scopes = security_scopes\n        security_requirement = SecurityRequirement(\n            security_scheme=dependency, scopes=use_scopes\n        )\n    sub_dependant = get_dependant(\n        path=path,\n        call=dependency,\n        name=name,\n        security_scopes=security_scopes,\n        use_cache=depends.use_cache,\n    )\n    if security_requirement:\n        sub_dependant.security_requirements.append(security_requirement)\n    sub_dependant.security_scopes = security_scopes\n    return sub_dependant", "is_method": false, "function_description": "Constructs a structured `Dependant` object for a given callable dependency. It aggregates and applies relevant security scopes and requirements, ensuring the sub-dependency is correctly configured for API authorization."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_flat_dependant", "line_number": 170, "body": "def get_flat_dependant(\n    dependant: Dependant,\n    *,\n    skip_repeats: bool = False,\n    visited: Optional[List[CacheKey]] = None,\n) -> Dependant:\n    if visited is None:\n        visited = []\n    visited.append(dependant.cache_key)\n\n    flat_dependant = Dependant(\n        path_params=dependant.path_params.copy(),\n        query_params=dependant.query_params.copy(),\n        header_params=dependant.header_params.copy(),\n        cookie_params=dependant.cookie_params.copy(),\n        body_params=dependant.body_params.copy(),\n        security_schemes=dependant.security_requirements.copy(),\n        use_cache=dependant.use_cache,\n        path=dependant.path,\n    )\n    for sub_dependant in dependant.dependencies:\n        if skip_repeats and sub_dependant.cache_key in visited:\n            continue\n        flat_sub = get_flat_dependant(\n            sub_dependant, skip_repeats=skip_repeats, visited=visited\n        )\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant", "is_method": false, "function_description": "Consolidates all parameters and security requirements from a dependency tree into a single, \"flat\" Dependant object. This provides a complete aggregated view of all necessary inputs."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_flat_params", "line_number": 205, "body": "def get_flat_params(dependant: Dependant) -> List[ModelField]:\n    flat_dependant = get_flat_dependant(dependant, skip_repeats=True)\n    return (\n        flat_dependant.path_params\n        + flat_dependant.query_params\n        + flat_dependant.header_params\n        + flat_dependant.cookie_params\n    )", "is_method": false, "function_description": "Extracts all path, query, header, and cookie parameters from a `Dependant` object. This provides a flattened list of `ModelField` representations for introspection."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "is_scalar_field", "line_number": 215, "body": "def is_scalar_field(field: ModelField) -> bool:\n    field_info = field.field_info\n    if not (\n        field.shape == SHAPE_SINGLETON\n        and not lenient_issubclass(field.type_, BaseModel)\n        and not lenient_issubclass(field.type_, sequence_types + (dict,))\n        and not dataclasses.is_dataclass(field.type_)\n        and not isinstance(field_info, params.Body)\n    ):\n        return False\n    if field.sub_fields:\n        if not all(is_scalar_field(f) for f in field.sub_fields):\n            return False\n    return True", "is_method": false, "function_description": "Checks if a `ModelField` represents a simple, non-composite scalar type. It excludes complex objects, collections, and recursively validates nested fields to determine atomicity."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "is_scalar_sequence_field", "line_number": 231, "body": "def is_scalar_sequence_field(field: ModelField) -> bool:\n    if (field.shape in sequence_shapes) and not lenient_issubclass(\n        field.type_, BaseModel\n    ):\n        if field.sub_fields is not None:\n            for sub_field in field.sub_fields:\n                if not is_scalar_field(sub_field):\n                    return False\n        return True\n    if lenient_issubclass(field.type_, sequence_types):\n        return True\n    return False", "is_method": false, "function_description": "Identifies if a model field represents a sequence containing only scalar types, or if it is a general sequence type. This aids in data validation and schema introspection."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_typed_signature", "line_number": 245, "body": "def get_typed_signature(call: Callable[..., Any]) -> inspect.Signature:\n    signature = inspect.signature(call)\n    globalns = getattr(call, \"__globals__\", {})\n    typed_params = [\n        inspect.Parameter(\n            name=param.name,\n            kind=param.kind,\n            default=param.default,\n            annotation=get_typed_annotation(param, globalns),\n        )\n        for param in signature.parameters.values()\n    ]\n    typed_signature = inspect.Signature(typed_params)\n    return typed_signature", "is_method": false, "function_description": "Generates an `inspect.Signature` for a callable with all parameter type annotations resolved to concrete type objects. This enables robust runtime type inspection and validation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_typed_annotation", "line_number": 261, "body": "def get_typed_annotation(param: inspect.Parameter, globalns: Dict[str, Any]) -> Any:\n    annotation = param.annotation\n    if isinstance(annotation, str):\n        annotation = ForwardRef(annotation)\n        annotation = evaluate_forwardref(annotation, globalns, globalns)\n    return annotation", "is_method": false, "function_description": "Resolves a function parameter's type annotation, handling string-based forward references by evaluating them against the provided global namespace."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_dependant", "line_number": 269, "body": "def get_dependant(\n    *,\n    path: str,\n    call: Callable[..., Any],\n    name: Optional[str] = None,\n    security_scopes: Optional[List[str]] = None,\n    use_cache: bool = True,\n) -> Dependant:\n    path_param_names = get_path_param_names(path)\n    endpoint_signature = get_typed_signature(call)\n    signature_params = endpoint_signature.parameters\n    dependant = Dependant(call=call, name=name, path=path, use_cache=use_cache)\n    for param_name, param in signature_params.items():\n        if isinstance(param.default, params.Depends):\n            sub_dependant = get_param_sub_dependant(\n                param=param, path=path, security_scopes=security_scopes\n            )\n            dependant.dependencies.append(sub_dependant)\n            continue\n        if add_non_field_param_to_dependency(param=param, dependant=dependant):\n            continue\n        param_field = get_param_field(\n            param=param, default_field_info=params.Query, param_name=param_name\n        )\n        if param_name in path_param_names:\n            assert is_scalar_field(\n                field=param_field\n            ), \"Path params must be of one of the supported types\"\n            if isinstance(param.default, params.Path):\n                ignore_default = False\n            else:\n                ignore_default = True\n            param_field = get_param_field(\n                param=param,\n                param_name=param_name,\n                default_field_info=params.Path,\n                force_type=params.ParamTypes.path,\n                ignore_default=ignore_default,\n            )\n            add_param_to_fields(field=param_field, dependant=dependant)\n        elif is_scalar_field(field=param_field):\n            add_param_to_fields(field=param_field, dependant=dependant)\n        elif isinstance(\n            param.default, (params.Query, params.Header)\n        ) and is_scalar_sequence_field(param_field):\n            add_param_to_fields(field=param_field, dependant=dependant)\n        else:\n            field_info = param_field.field_info\n            assert isinstance(\n                field_info, params.Body\n            ), f\"Param: {param_field.name} can only be a request body, using Body(...)\"\n            dependant.body_params.append(param_field)\n    return dependant", "is_method": false, "function_description": "Constructs a Dependant object by analyzing a callable's signature and path. It categorizes parameters as path, query, body, or nested dependencies, providing a structured representation for request handling."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "add_non_field_param_to_dependency", "line_number": 324, "body": "def add_non_field_param_to_dependency(\n    *, param: inspect.Parameter, dependant: Dependant\n) -> Optional[bool]:\n    if lenient_issubclass(param.annotation, Request):\n        dependant.request_param_name = param.name\n        return True\n    elif lenient_issubclass(param.annotation, WebSocket):\n        dependant.websocket_param_name = param.name\n        return True\n    elif lenient_issubclass(param.annotation, HTTPConnection):\n        dependant.http_connection_param_name = param.name\n        return True\n    elif lenient_issubclass(param.annotation, Response):\n        dependant.response_param_name = param.name\n        return True\n    elif lenient_issubclass(param.annotation, BackgroundTasks):\n        dependant.background_tasks_param_name = param.name\n        return True\n    elif lenient_issubclass(param.annotation, SecurityScopes):\n        dependant.security_scopes_param_name = param.name\n        return True\n    return None", "is_method": false, "function_description": "Identifies and registers specific framework-managed parameters (e.g., Request, Response) within a `Dependant` object. This helps a web framework correctly inject core service objects into handlers."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_param_field", "line_number": 348, "body": "def get_param_field(\n    *,\n    param: inspect.Parameter,\n    param_name: str,\n    default_field_info: Type[params.Param] = params.Param,\n    force_type: Optional[params.ParamTypes] = None,\n    ignore_default: bool = False,\n) -> ModelField:\n    default_value = Required\n    had_schema = False\n    if not param.default == param.empty and ignore_default is False:\n        default_value = param.default\n    if isinstance(default_value, FieldInfo):\n        had_schema = True\n        field_info = default_value\n        default_value = field_info.default\n        if (\n            isinstance(field_info, params.Param)\n            and getattr(field_info, \"in_\", None) is None\n        ):\n            field_info.in_ = default_field_info.in_\n        if force_type:\n            field_info.in_ = force_type  # type: ignore\n    else:\n        field_info = default_field_info(default_value)\n    required = default_value == Required\n    annotation: Any = Any\n    if not param.annotation == param.empty:\n        annotation = param.annotation\n    annotation = get_annotation_from_field_info(annotation, field_info, param_name)\n    if not field_info.alias and getattr(field_info, \"convert_underscores\", None):\n        alias = param.name.replace(\"_\", \"-\")\n    else:\n        alias = field_info.alias or param.name\n    field = create_response_field(\n        name=param.name,\n        type_=annotation,\n        default=None if required else default_value,\n        alias=alias,\n        required=required,\n        field_info=field_info,\n    )\n    field.required = required\n    if not had_schema and not is_scalar_field(field=field):\n        field.field_info = params.Body(field_info.default)\n\n    return field", "is_method": false, "function_description": "Converts an `inspect.Parameter` into a `ModelField` object, encapsulating its type, default, and schema details. This utility facilitates automatic API schema generation and request validation from function signatures."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "add_param_to_fields", "line_number": 397, "body": "def add_param_to_fields(*, field: ModelField, dependant: Dependant) -> None:\n    field_info = cast(params.Param, field.field_info)\n    if field_info.in_ == params.ParamTypes.path:\n        dependant.path_params.append(field)\n    elif field_info.in_ == params.ParamTypes.query:\n        dependant.query_params.append(field)\n    elif field_info.in_ == params.ParamTypes.header:\n        dependant.header_params.append(field)\n    else:\n        assert (\n            field_info.in_ == params.ParamTypes.cookie\n        ), f\"non-body parameters must be in path, query, header or cookie: {field.name}\"\n        dependant.cookie_params.append(field)", "is_method": false, "function_description": "This function categorizes a model field based on whether it's a path, query, header, or cookie parameter. It then adds the field to the appropriate list within a `Dependant` object for processing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "is_coroutine_callable", "line_number": 412, "body": "def is_coroutine_callable(call: Callable[..., Any]) -> bool:\n    if inspect.isroutine(call):\n        return inspect.iscoroutinefunction(call)\n    if inspect.isclass(call):\n        return False\n    call = getattr(call, \"__call__\", None)\n    return inspect.iscoroutinefunction(call)", "is_method": false, "function_description": "Determines if a given callable is an awaitable coroutine function or method. This helps identify if a callable requires `await` in asynchronous programming contexts."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "is_async_gen_callable", "line_number": 421, "body": "def is_async_gen_callable(call: Callable[..., Any]) -> bool:\n    if inspect.isasyncgenfunction(call):\n        return True\n    call = getattr(call, \"__call__\", None)\n    return inspect.isasyncgenfunction(call)", "is_method": false, "function_description": "Checks if a given callable, or its `__call__` method, is an asynchronous generator function. This function helps to introspect callable objects for async generator behavior."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "is_gen_callable", "line_number": 428, "body": "def is_gen_callable(call: Callable[..., Any]) -> bool:\n    if inspect.isgeneratorfunction(call):\n        return True\n    call = getattr(call, \"__call__\", None)\n    return inspect.isgeneratorfunction(call)", "is_method": false, "function_description": "Determines if a callable, or its `__call__` method, is a generator function. Useful for identifying objects that produce iterators when invoked."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "request_params_to_args", "line_number": 577, "body": "def request_params_to_args(\n    required_params: Sequence[ModelField],\n    received_params: Union[Mapping[str, Any], QueryParams, Headers],\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values = {}\n    errors = []\n    for field in required_params:\n        if is_scalar_sequence_field(field) and isinstance(\n            received_params, (QueryParams, Headers)\n        ):\n            value = received_params.getlist(field.alias) or field.default\n        else:\n            value = received_params.get(field.alias)\n        field_info = field.field_info\n        assert isinstance(\n            field_info, params.Param\n        ), \"Params must be subclasses of Param\"\n        if value is None:\n            if field.required:\n                errors.append(\n                    ErrorWrapper(\n                        MissingError(), loc=(field_info.in_.value, field.alias)\n                    )\n                )\n            else:\n                values[field.name] = deepcopy(field.default)\n            continue\n        v_, errors_ = field.validate(\n            value, values, loc=(field_info.in_.value, field.alias)\n        )\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        else:\n            values[field.name] = v_\n    return values, errors", "is_method": false, "function_description": "This function validates and extracts parameters from an incoming request against a defined schema. It returns a dictionary of valid arguments and a list of any encountered validation errors, typically for API input processing."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_missing_field_error", "line_number": 699, "body": "def get_missing_field_error(loc: Tuple[str, ...]) -> ErrorWrapper:\n    missing_field_error = ErrorWrapper(MissingError(), loc=loc)\n    return missing_field_error", "is_method": false, "function_description": "This function creates a standardized `ErrorWrapper` instance, specifically representing a missing field error at a specified data location. It provides a consistent way to generate errors when required fields are absent."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_schema_compatible_field", "line_number": 704, "body": "def get_schema_compatible_field(*, field: ModelField) -> ModelField:\n    out_field = field\n    if lenient_issubclass(field.type_, UploadFile):\n        use_type: type = bytes\n        if field.shape in sequence_shapes:\n            use_type = List[bytes]\n        out_field = create_response_field(\n            name=field.name,\n            type_=use_type,\n            class_validators=field.class_validators,\n            model_config=field.model_config,\n            default=field.default,\n            required=field.required,\n            alias=field.alias,\n            field_info=field.field_info,\n        )\n    return out_field", "is_method": false, "function_description": "Adapts a model field for schema compatibility. It converts `UploadFile` types to `bytes` or `List[bytes]` for proper schema representation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/fastapi/dependencies/utils.py", "function": "get_body_field", "line_number": 723, "body": "def get_body_field(*, dependant: Dependant, name: str) -> Optional[ModelField]:\n    flat_dependant = get_flat_dependant(dependant)\n    if not flat_dependant.body_params:\n        return None\n    first_param = flat_dependant.body_params[0]\n    field_info = first_param.field_info\n    embed = getattr(field_info, \"embed\", None)\n    body_param_names_set = {param.name for param in flat_dependant.body_params}\n    if len(body_param_names_set) == 1 and not embed:\n        final_field = get_schema_compatible_field(field=first_param)\n        check_file_field(final_field)\n        return final_field\n    # If one field requires to embed, all have to be embedded\n    # in case a sub-dependency is evaluated with a single unique body field\n    # That is combined (embedded) with other body fields\n    for param in flat_dependant.body_params:\n        setattr(param.field_info, \"embed\", True)\n    model_name = \"Body_\" + name\n    BodyModel: Type[BaseModel] = create_model(model_name)\n    for f in flat_dependant.body_params:\n        BodyModel.__fields__[f.name] = get_schema_compatible_field(field=f)\n    required = any(True for f in flat_dependant.body_params if f.required)\n\n    BodyFieldInfo_kwargs: Dict[str, Any] = dict(default=None)\n    if any(isinstance(f.field_info, params.File) for f in flat_dependant.body_params):\n        BodyFieldInfo: Type[params.Body] = params.File\n    elif any(isinstance(f.field_info, params.Form) for f in flat_dependant.body_params):\n        BodyFieldInfo = params.Form\n    else:\n        BodyFieldInfo = params.Body\n\n        body_param_media_types = [\n            getattr(f.field_info, \"media_type\")\n            for f in flat_dependant.body_params\n            if isinstance(f.field_info, params.Body)\n        ]\n        if len(set(body_param_media_types)) == 1:\n            BodyFieldInfo_kwargs[\"media_type\"] = body_param_media_types[0]\n    final_field = create_response_field(\n        name=\"body\",\n        type_=BodyModel,\n        required=required,\n        alias=\"body\",\n        field_info=BodyFieldInfo(**BodyFieldInfo_kwargs),\n    )\n    check_file_field(final_field)\n    return final_field", "is_method": false, "function_description": "This function creates a unified `ModelField` for a dependency's request body. It dynamically aggregates individual body parameters into a single Pydantic model for schema generation and validation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "get_security", "line_number": 27, "body": "def get_security(sec=Security(HTTPBasic())):\n    return sec", "is_method": false, "function_description": "Returns a security configuration object, defaulting to HTTP basic authentication if none is provided. This allows other functions to easily access a pre-configured security scheme."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "get_security_oauth2", "line_number": 42, "body": "def get_security_oauth2(sec=Security(reusable_oauth2, scopes=[\"read:user\"])):\n    return sec", "is_method": false, "function_description": "This function provides a reusable FastAPI dependency to enforce OAuth2 security. It ensures API endpoints require a valid token with \"read:user\" scope for access."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "post_token", "line_number": 47, "body": "def post_token(request_data: OAuth2PasswordRequestForm = Form(...)):\n    data = request_data.parse()\n    access_token = data.username + \":\" + data.password\n    return {\"access_token\": access_token}", "is_method": false, "function_description": "Handles an OAuth2 password grant request by creating an access token from the provided username and password. This function provides a basic access token for user authentication."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "require_token", "line_number": 94, "body": "def require_token(\n    token: str = Security(reusable_oauth2, scopes=[\"read:user\", \"write:user\"])\n):\n    raw_token = token.replace(\"Bearer \", \"\")\n    # Never do this plaintext password usage in production\n    username, password = raw_token.split(\":\")\n    return TokenUserData(username=username, password=password)", "is_method": false, "function_description": "This function serves as an API security dependency, processing an incoming authentication token to extract user credentials. It provides validated user data for securing endpoints."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "require_user", "line_number": 103, "body": "def require_user(\n    db: FakeDB = Depends(connection_manager),\n    user_data: TokenUserData = Depends(require_token),\n):\n    return db.data[user_data.username]", "is_method": false, "function_description": "Ensures user authentication via token and retrieves the full user object from the database. This function provides a validated user data dependency for protected API endpoints."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "get_dependency", "line_number": 117, "body": "def get_dependency(user: UserInDB = Depends(require_user)):\n    return user", "is_method": false, "function_description": "Provides access to an authenticated `UserInDB` object within FastAPI routes. It acts as a dependency injection point, delivering the user resolved by `require_user`."}, {"file": "./dataset/RepoExec/test-apps/fastapi/pending_tests/main.py", "function": "__call__", "line_number": 75, "body": "def __call__(self):\n        return self.db", "is_method": true, "class_name": "DBConnectionManager", "function_description": "Enables direct access to the managed database connection by allowing the instance to be called like a function. It provides the active database session."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/gitter_releases_bot.py", "function": "get_github_graphql", "line_number": 17, "body": "def get_github_graphql(tag_name: str):\n    github_graphql = \"\"\"\n    {\n    repository(owner: \"tiangolo\", name: \"fastapi\") {\n        release (tagName: \"{{tag_name}}\" ) {\n        description\n        }\n      }\n    }\n    \"\"\"\n    github_graphql = github_graphql.replace(\"{{tag_name}}\", tag_name)\n    return github_graphql", "is_method": false, "function_description": "Generates a GitHub GraphQL query string. This query is designed to retrieve release descriptions for a specified tag name from the 'tiangolo/fastapi' repository."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/gitter_releases_bot.py", "function": "get_github_release_text", "line_number": 31, "body": "def get_github_release_text(tag_name: str):\n    url = \"https://api.github.com/graphql\"\n    headers = {\"Authorization\": f\"Bearer {github_token}\"}\n    github_graphql = get_github_graphql(tag_name=tag_name)\n    response = requests.post(url, json={\"query\": github_graphql}, headers=headers)\n    assert response.status_code == 200\n    data = response.json()\n    return data[\"data\"][\"repository\"][\"release\"][\"description\"]", "is_method": false, "function_description": "Retrieves the description text for a specific GitHub repository release, identified by its tag name. This provides the official release notes."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/gitter_releases_bot.py", "function": "get_gitter_message", "line_number": 41, "body": "def get_gitter_message(release_text: str):\n    text = f\"\"\"\n    New release! :tada: :rocket:\n    (by FastAPI bot)\n\n    ## {tag_name}\n    \"\"\"\n    text = inspect.cleandoc(text) + \"\\n\\n\" + release_text\n    return text", "is_method": false, "function_description": "This function composes a formatted message for a new software release announcement. It combines a standard header that includes a release tag with provided release notes, suitable for Gitter."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/gitter_releases_bot.py", "function": "send_gitter_message", "line_number": 52, "body": "def send_gitter_message(text: str):\n    headers = {\"Authorization\": f\"Bearer {gitter_token}\"}\n    url = f\"https://api.gitter.im/v1/rooms/{room_id}/chatMessages\"\n    data = {\"text\": text}\n    response = requests.post(url, headers=headers, json=data)\n    assert response.status_code == 200", "is_method": false, "function_description": "Sends a text message to a designated Gitter chat room. It serves to programmatically post notifications or updates to Gitter."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/gitter_releases_bot.py", "function": "main", "line_number": 60, "body": "def main():\n    release_text = get_github_release_text(tag_name=tag_name)\n    text = get_gitter_message(release_text=release_text)\n    send_gitter_message(text=text)", "is_method": false, "function_description": "This function orchestrates the process of fetching release text from GitHub, formatting it as a Gitter message, and then posting it. It automates release announcements to a Gitter channel."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_en_config", "line_number": 30, "body": "def get_en_config() -> dict:\n    return mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))", "is_method": false, "function_description": "Retrieves the English configuration settings from a YAML file, providing ready-to-use configuration data for other parts of the application."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_lang_paths", "line_number": 34, "body": "def get_lang_paths():\n    return sorted(docs_path.iterdir())", "is_method": false, "function_description": "This function retrieves and returns a sorted list of all entries within the documentation path. It provides an organized view of available language-specific documentation directories."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "lang_callback", "line_number": 38, "body": "def lang_callback(lang: Optional[str]):\n    if lang is None:\n        return\n    if not lang.isalpha() or len(lang) != 2:\n        typer.echo(\"Use a 2 letter language code, like: es\")\n        raise typer.Abort()\n    lang = lang.lower()\n    return lang", "is_method": false, "function_description": "Provides validation and normalization for a language code. It ensures the input is a 2-letter alphabetic string, converting it to lowercase, or aborts on invalid input."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "complete_existing_lang", "line_number": 48, "body": "def complete_existing_lang(incomplete: str):\n    lang_path: Path\n    for lang_path in get_lang_paths():\n        if lang_path.is_dir() and lang_path.name.startswith(incomplete):\n            yield lang_path.name", "is_method": false, "function_description": "Provides a generator that yields existing language directory names that start with a given incomplete string, useful for autocompletion."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_base_lang_config", "line_number": 55, "body": "def get_base_lang_config(lang: str):\n    en_config = get_en_config()\n    fastapi_url_base = \"https://fastapi.tiangolo.com/\"\n    new_config = en_config.copy()\n    new_config[\"site_url\"] = en_config[\"site_url\"] + f\"{lang}/\"\n    new_config[\"theme\"][\"logo\"] = fastapi_url_base + en_config[\"theme\"][\"logo\"]\n    new_config[\"theme\"][\"favicon\"] = fastapi_url_base + en_config[\"theme\"][\"favicon\"]\n    new_config[\"theme\"][\"language\"] = lang\n    new_config[\"nav\"] = en_config[\"nav\"][:2]\n    extra_css = []\n    css: str\n    for css in en_config[\"extra_css\"]:\n        if css.startswith(\"http\"):\n            extra_css.append(css)\n        else:\n            extra_css.append(fastapi_url_base + css)\n    new_config[\"extra_css\"] = extra_css\n\n    extra_js = []\n    js: str\n    for js in en_config[\"extra_javascript\"]:\n        if js.startswith(\"http\"):\n            extra_js.append(js)\n        else:\n            extra_js.append(fastapi_url_base + js)\n    new_config[\"extra_javascript\"] = extra_js\n    return new_config", "is_method": false, "function_description": "Generates a language-specific configuration dictionary based on an English template. It customizes URLs, theme assets, and scripts for internationalization."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "new_lang", "line_number": 85, "body": "def new_lang(lang: str = typer.Argument(..., callback=lang_callback)):\n    \"\"\"\n    Generate a new docs translation directory for the language LANG.\n\n    LANG should be a 2-letter language code, like: en, es, de, pt, etc.\n    \"\"\"\n    new_path: Path = Path(\"docs\") / lang\n    if new_path.exists():\n        typer.echo(f\"The language was already created: {lang}\")\n        raise typer.Abort()\n    new_path.mkdir()\n    new_config = get_base_lang_config(lang)\n    new_config_path: Path = Path(new_path) / mkdocs_name\n    new_config_path.write_text(\n        yaml.dump(new_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    new_config_docs_path: Path = new_path / \"docs\"\n    new_config_docs_path.mkdir()\n    en_index_path: Path = en_docs_path / \"docs\" / \"index.md\"\n    new_index_path: Path = new_config_docs_path / \"index.md\"\n    en_index_content = en_index_path.read_text(encoding=\"utf-8\")\n    new_index_content = f\"{missing_translation_snippet}\\n\\n{en_index_content}\"\n    new_index_path.write_text(new_index_content, encoding=\"utf-8\")\n    new_overrides_gitignore_path = new_path / \"overrides\" / \".gitignore\"\n    new_overrides_gitignore_path.parent.mkdir(parents=True, exist_ok=True)\n    new_overrides_gitignore_path.write_text(\"\")\n    typer.secho(f\"Successfully initialized: {new_path}\", color=typer.colors.GREEN)\n    update_languages(lang=None)", "is_method": false, "function_description": "Creates a new documentation translation directory for the specified language. It sets up the necessary folder structure, initial configuration, and base content, preparing for new translations."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "build_lang", "line_number": 117, "body": "def build_lang(\n    lang: str = typer.Argument(\n        ..., callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Build the docs for a language, filling missing pages with translation notifications.\n    \"\"\"\n    lang_path: Path = Path(\"docs\") / lang\n    if not lang_path.is_dir():\n        typer.echo(f\"The language translation doesn't seem to exist yet: {lang}\")\n        raise typer.Abort()\n    typer.echo(f\"Building docs for: {lang}\")\n    build_dir_path = Path(\"docs_build\")\n    build_dir_path.mkdir(exist_ok=True)\n    build_lang_path = build_dir_path / lang\n    en_lang_path = Path(\"docs/en\")\n    site_path = Path(\"site\").absolute()\n    if lang == \"en\":\n        dist_path = site_path\n    else:\n        dist_path: Path = site_path / lang\n    shutil.rmtree(build_lang_path, ignore_errors=True)\n    shutil.copytree(lang_path, build_lang_path)\n    shutil.copytree(en_docs_path / \"data\", build_lang_path / \"data\")\n    overrides_src = en_docs_path / \"overrides\"\n    overrides_dest = build_lang_path / \"overrides\"\n    for path in overrides_src.iterdir():\n        dest_path = overrides_dest / path.name\n        if not dest_path.exists():\n            shutil.copy(path, dest_path)\n    en_config_path: Path = en_lang_path / mkdocs_name\n    en_config: dict = mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))\n    nav = en_config[\"nav\"]\n    lang_config_path: Path = lang_path / mkdocs_name\n    lang_config: dict = mkdocs.utils.yaml_load(\n        lang_config_path.read_text(encoding=\"utf-8\")\n    )\n    lang_nav = lang_config[\"nav\"]\n    # Exclude first 2 entries FastAPI and Languages, for custom handling\n    use_nav = nav[2:]\n    lang_use_nav = lang_nav[2:]\n    file_to_nav = get_file_to_nav_map(use_nav)\n    sections = get_sections(use_nav)\n    lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    use_lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    for file in file_to_nav:\n        file_path = Path(file)\n        lang_file_path: Path = build_lang_path / \"docs\" / file_path\n        en_file_path: Path = en_lang_path / \"docs\" / file_path\n        lang_file_path.parent.mkdir(parents=True, exist_ok=True)\n        if not lang_file_path.is_file():\n            en_text = en_file_path.read_text(encoding=\"utf-8\")\n            lang_text = get_text_with_translate_missing(en_text)\n            lang_file_path.write_text(lang_text, encoding=\"utf-8\")\n            file_key = file_to_nav[file]\n            use_lang_file_to_nav[file] = file_key\n            if file_key:\n                composite_key = ()\n                new_key = ()\n                for key_part in file_key:\n                    composite_key += (key_part,)\n                    key_first_file = sections[composite_key]\n                    if key_first_file in lang_file_to_nav:\n                        new_key = lang_file_to_nav[key_first_file]\n                    else:\n                        new_key += (key_part,)\n                use_lang_file_to_nav[file] = new_key\n    key_to_section = {(): []}\n    for file, orig_file_key in file_to_nav.items():\n        if file in use_lang_file_to_nav:\n            file_key = use_lang_file_to_nav[file]\n        else:\n            file_key = orig_file_key\n        section = get_key_section(key_to_section=key_to_section, key=file_key)\n        section.append(file)\n    new_nav = key_to_section[()]\n    export_lang_nav = [lang_nav[0], nav[1]] + new_nav\n    lang_config[\"nav\"] = export_lang_nav\n    build_lang_config_path: Path = build_lang_path / mkdocs_name\n    build_lang_config_path.write_text(\n        yaml.dump(lang_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    current_dir = os.getcwd()\n    os.chdir(build_lang_path)\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(dist_path)))\n    os.chdir(current_dir)\n    typer.secho(f\"Successfully built docs for: {lang}\", color=typer.colors.GREEN)", "is_method": false, "function_description": "Builds the documentation site for a specified language. It copies existing translated pages and creates placeholders for missing English pages, indicating they require translation."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "generate_readme_content", "line_number": 220, "body": "def generate_readme_content():\n    en_index = en_docs_path / \"docs\" / \"index.md\"\n    content = en_index.read_text(\"utf-8\")\n    match_start = re.search(r\"<!-- sponsors -->\", content)\n    match_end = re.search(r\"<!-- /sponsors -->\", content)\n    sponsors_data_path = en_docs_path / \"data\" / \"sponsors.yml\"\n    sponsors = mkdocs.utils.yaml_load(sponsors_data_path.read_text(encoding=\"utf-8\"))\n    if not (match_start and match_end):\n        raise RuntimeError(\"Couldn't auto-generate sponsors section\")\n    pre_end = match_start.end()\n    post_start = match_end.start()\n    template = Template(index_sponsors_template)\n    message = template.render(sponsors=sponsors)\n    pre_content = content[:pre_end]\n    post_content = content[post_start:]\n    new_content = pre_content + message + post_content\n    return new_content", "is_method": false, "function_description": "Generates the complete content for a documentation index or README file. It dynamically embeds a templated sponsors section, pulling data from a YAML file into an existing Markdown structure."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "generate_readme", "line_number": 240, "body": "def generate_readme():\n    \"\"\"\n    Generate README.md content from main index.md\n    \"\"\"\n    typer.echo(\"Generating README\")\n    readme_path = Path(\"README.md\")\n    new_content = generate_readme_content()\n    readme_path.write_text(new_content, encoding=\"utf-8\")", "is_method": false, "function_description": "This function generates or updates the project's `README.md` file. It sources the content for the README from an `index.md` file."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "verify_readme", "line_number": 251, "body": "def verify_readme():\n    \"\"\"\n    Verify README.md content from main index.md\n    \"\"\"\n    typer.echo(\"Verifying README\")\n    readme_path = Path(\"README.md\")\n    generated_content = generate_readme_content()\n    readme_content = readme_path.read_text(\"utf-8\")\n    if generated_content != readme_content:\n        typer.secho(\n            \"README.md outdated from the latest index.md\", color=typer.colors.RED\n        )\n        raise typer.Abort()\n    typer.echo(\"Valid README \u2705\")", "is_method": false, "function_description": "This function verifies if the `README.md` file's content matches its dynamically generated version. It ensures the README is up-to-date with its source, raising an error if discrepancies are found."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "build_all", "line_number": 268, "body": "def build_all():\n    \"\"\"\n    Build mkdocs site for en, and then build each language inside, end result is located\n    at directory ./site/ with each language inside.\n    \"\"\"\n    site_path = Path(\"site\").absolute()\n    update_languages(lang=None)\n    current_dir = os.getcwd()\n    os.chdir(en_docs_path)\n    typer.echo(\"Building docs for: en\")\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(site_path)))\n    os.chdir(current_dir)\n    langs = []\n    for lang in get_lang_paths():\n        if lang == en_docs_path or not lang.is_dir():\n            continue\n        langs.append(lang.name)\n    cpu_count = os.cpu_count() or 1\n    with Pool(cpu_count * 2) as p:\n        p.map(build_lang, langs)", "is_method": false, "function_description": "Builds the complete multi-language documentation site. It first builds the English version, then concurrently builds all other language versions, placing them in the `./site/` directory."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "update_single_lang", "line_number": 290, "body": "def update_single_lang(lang: str):\n    lang_path = docs_path / lang\n    typer.echo(f\"Updating {lang_path.name}\")\n    update_config(lang_path.name)", "is_method": false, "function_description": "Initiates a configuration update process for a single, specified language. It prepares the language identifier for the core update function."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "update_languages", "line_number": 297, "body": "def update_languages(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Update the mkdocs.yml file Languages section including all the available languages.\n\n    The LANG argument is a 2-letter language code. If it's not provided, update all the\n    mkdocs.yml files (for all the languages).\n    \"\"\"\n    if lang is None:\n        for lang_path in get_lang_paths():\n            if lang_path.is_dir():\n                update_single_lang(lang_path.name)\n    else:\n        update_single_lang(lang)", "is_method": false, "function_description": "Manages multilingual documentation by updating the 'Languages' section in `mkdocs.yml`. It can update for a specific language code or all available languages."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "serve", "line_number": 317, "body": "def serve():\n    \"\"\"\n    A quick server to preview a built site with translations.\n\n    For development, prefer the command live (or just mkdocs serve).\n\n    This is here only to preview a site with translations already built.\n\n    Make sure you run the build-all command first.\n    \"\"\"\n    typer.echo(\"Warning: this is a very simple server.\")\n    typer.echo(\"For development, use the command live instead.\")\n    typer.echo(\"This is here only to preview a site with translations already built.\")\n    typer.echo(\"Make sure you run the build-all command first.\")\n    os.chdir(\"site\")\n    server_address = (\"\", 8008)\n    server = HTTPServer(server_address, SimpleHTTPRequestHandler)\n    typer.echo(f\"Serving at: http://127.0.0.1:8008\")\n    server.serve_forever()", "is_method": false, "function_description": "Starts a simple HTTP server to preview a pre-built static site. Its primary use is for viewing sites with translations that have already been generated."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "live", "line_number": 339, "body": "def live(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Serve with livereload a docs site for a specific language.\n\n    This only shows the actual translated files, not the placeholders created with\n    build-all.\n\n    Takes an optional LANG argument with the name of the language to serve, by default\n    en.\n    \"\"\"\n    if lang is None:\n        lang = \"en\"\n    lang_path: Path = docs_path / lang\n    os.chdir(lang_path)\n    mkdocs.commands.serve.serve(dev_addr=\"127.0.0.1:8008\")", "is_method": false, "function_description": "Serves a localized documentation site with livereload for a specified language. This allows real-time preview of actual translated content, not placeholders."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "update_config", "line_number": 360, "body": "def update_config(lang: str):\n    lang_path: Path = docs_path / lang\n    config_path = lang_path / mkdocs_name\n    current_config: dict = mkdocs.utils.yaml_load(\n        config_path.read_text(encoding=\"utf-8\")\n    )\n    if lang == \"en\":\n        config = get_en_config()\n    else:\n        config = get_base_lang_config(lang)\n        config[\"nav\"] = current_config[\"nav\"]\n        config[\"theme\"][\"language\"] = current_config[\"theme\"][\"language\"]\n    languages = [{\"en\": \"/\"}]\n    alternate: List[Dict[str, str]] = config[\"extra\"].get(\"alternate\", [])\n    alternate_dict = {alt[\"link\"]: alt[\"name\"] for alt in alternate}\n    new_alternate: List[Dict[str, str]] = []\n    for lang_path in get_lang_paths():\n        if lang_path.name == \"en\" or not lang_path.is_dir():\n            continue\n        name = lang_path.name\n        languages.append({name: f\"/{name}/\"})\n    for lang_dict in languages:\n        name = list(lang_dict.keys())[0]\n        url = lang_dict[name]\n        if url not in alternate_dict:\n            new_alternate.append({\"link\": url, \"name\": name})\n        else:\n            use_name = alternate_dict[url]\n            new_alternate.append({\"link\": url, \"name\": use_name})\n    config[\"nav\"][1] = {\"Languages\": languages}\n    config[\"extra\"][\"alternate\"] = new_alternate\n    config_path.write_text(\n        yaml.dump(config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )", "is_method": false, "function_description": "Modifies a language-specific MkDocs configuration file. It updates navigation to include all available languages and manages \"alternate\" links for multi-language site support."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_key_section", "line_number": 397, "body": "def get_key_section(\n    *, key_to_section: Dict[Tuple[str, ...], list], key: Tuple[str, ...]\n) -> list:\n    if key in key_to_section:\n        return key_to_section[key]\n    super_key = key[:-1]\n    title = key[-1]\n    super_section = get_key_section(key_to_section=key_to_section, key=super_key)\n    new_section = []\n    super_section.append({title: new_section})\n    key_to_section[key] = new_section\n    return new_section", "is_method": false, "function_description": "Provides a mechanism to retrieve or create nested list-based sections based on a hierarchical key. It ensures the entire path to the section exists, building it if necessary."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_text_with_translate_missing", "line_number": 411, "body": "def get_text_with_translate_missing(text: str) -> str:\n    lines = text.splitlines()\n    lines.insert(1, missing_translation_snippet)\n    new_text = \"\\n\".join(lines)\n    return new_text", "is_method": false, "function_description": "Inserts a \"missing translation\" snippet after the first line of the input text. This function is useful for programmatically marking content that requires localization or review."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_file_to_nav_map", "line_number": 418, "body": "def get_file_to_nav_map(nav: list) -> Dict[str, Tuple[str, ...]]:\n    file_to_nav = {}\n    for item in nav:\n        if type(item) is str:\n            file_to_nav[item] = tuple()\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sub_file_to_nav = get_file_to_nav_map(sub_nav)\n            for k, v in sub_file_to_nav.items():\n                file_to_nav[k] = (item_key,) + v\n    return file_to_nav", "is_method": false, "function_description": "Provides a direct mapping from file names to their full hierarchical path within a nested navigation structure. Useful for generating breadcrumbs or understanding content organization."}, {"file": "./dataset/RepoExec/test-apps/fastapi/scripts/docs.py", "function": "get_sections", "line_number": 432, "body": "def get_sections(nav: list) -> Dict[Tuple[str, ...], str]:\n    sections = {}\n    for item in nav:\n        if type(item) is str:\n            continue\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sections[(item_key,)] = sub_nav[0]\n            sub_sections = get_sections(sub_nav)\n            for k, v in sub_sections.items():\n                new_key = (item_key,) + k\n                sections[new_key] = v\n    return sections", "is_method": false, "function_description": "Extracts and flattens content from a deeply nested navigation-like structure. It maps hierarchical paths as tuples to their corresponding string values."}]