[{"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "__eq__", "line_number": 116, "body": "def __eq__(self, other: Any) -> bool:\n        \"\"\"\n        Checks if the `self` and `other` are same currencies.\n        \"\"\"\n        return isinstance(other, Currency) and self.hashcache == other.hashcache", "is_method": true, "class_name": "Currency", "function_description": "Method of the Currency class that determines if another object represents the same currency by comparing their internal identifiers. It enables currency equality checks for consistent handling in financial contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "__hash__", "line_number": 122, "body": "def __hash__(self) -> int:\n        \"\"\"\n        Returns the pre-computed and cached hash.\n        \"\"\"\n        return self.hashcache", "is_method": true, "class_name": "Currency", "function_description": "Provides a quick hash value for the Currency instance by returning a pre-computed cached hash, enabling efficient use in hash-based collections like sets or dictionaries."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "quantize", "line_number": 128, "body": "def quantize(self, qty: Decimal) -> Decimal:\n        \"\"\"\n        Quantizes the decimal ``qty`` wrt to ccy's minor units fraction. Note that\n        the [ROUND HALF TO EVEN](https://en.wikipedia.org/wiki/Rounding) method\n        is used for rounding purposes.\n\n        **Note** that the HALF-TO-EVEN method is inherited from the default decimal context instead of\n        explicitly passing it. Therefore, if call-site application is making changes to the default\n        context, the rounding method may not be HALF-TO-EVEN anymore.\n        \"\"\"\n        return qty.quantize(self.quantizer)", "is_method": true, "class_name": "Currency", "function_description": "Service method of the Currency class that rounds a Decimal quantity to the currency's minor unit precision using half-to-even rounding. It ensures monetary values align with the smallest currency units for accurate calculations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "of", "line_number": 141, "body": "def of(cls, code: str, name: str, decimals: int, ctype: CurrencyType) -> \"Currency\":\n        \"\"\"\n        Attempts to create a currency instance and returns it.\n        \"\"\"\n        ## Check the code:\n        ProgrammingError.passert(isinstance(code, str), \"Currency code must be a string\")\n        ProgrammingError.passert(code.isalpha(), \"Currency code must contain only alphabetic characters\")\n        ProgrammingError.passert(code.isupper(), \"Currency code must be all uppercase\")\n\n        ## Check the name:\n        ProgrammingError.passert(isinstance(name, str), \"Currency name must be a string\")\n        ProgrammingError.passert(name != \"\", \"Currency name can not be empty\")\n        ProgrammingError.passert(not (name.startswith(\" \") or name.endswith(\" \")), \"Trim the currency name\")\n\n        ## Check the decimals:\n        ProgrammingError.passert(isinstance(decimals, int), \"Number of decimals must be an integer\")\n        ProgrammingError.passert(decimals >= -1, \"Number of decimals can not be less than -1\")\n\n        ## Check the type:\n        ProgrammingError.passert(isinstance(ctype, CurrencyType), \"Currency Type must be of type `CurrencyType`\")\n\n        ## Define the quantizer:\n        if decimals > 0:\n            quantizer = make_quantizer(decimals)\n        elif decimals < 0:\n            quantizer = MaxPrecisionQuantizer\n        else:\n            quantizer = ZERO\n\n        ## By now, we should have all required instance attributes. However, we want to compute and cache the hash.\n        hashcode = hash((code, name, decimals, ctype, quantizer))\n\n        ## Done, create the currency object and return:\n        return Currency(code, name, decimals, ctype, quantizer, hashcode)", "is_method": true, "class_name": "Currency", "function_description": "Factory method of the Currency class that validates inputs and creates a new Currency instance with proper attributes, including quantization settings based on decimal places."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "__new__", "line_number": 208, "body": "def __new__(cls) -> \"CurrencyRegistry\":\n        \"\"\"\n        Creates the singleton instance, or returns the existing one.\n        \"\"\"\n        ## Do we have the singleton instance?\n        if CurrencyRegistry.__instance is None:\n            ## Nope, not yet. Creat one:\n            CurrencyRegistry.__instance = object.__new__(cls)\n\n        ## Return the singleton instance.\n        return CurrencyRegistry.__instance", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Singleton pattern implementation in CurrencyRegistry that ensures only one instance of the class exists, providing a consistent centralized registry for currency-related data or operations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "__enter__", "line_number": 239, "body": "def __enter__(self) -> Callable[[Currency], None]:\n        \"\"\"\n        Enters the registry population context.\n        \"\"\"\n        ## Mark the context as open:\n        self.__ctx_open = True\n\n        ## OK, return the add method:\n        return self.__register", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Provides context manager entry for CurrencyRegistry, enabling a block where currencies can be registered via the returned add method. This supports convenient, scoped population of the currency registry."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "__exit__", "line_number": 249, "body": "def __exit__(self, exc_type: Optional[Type[Exception]], exc_value: Optional[str], tracebackx: Any) -> None:\n        \"\"\"\n        Exits the registry population context and performs some finalization tasks.\n        \"\"\"\n        ## Re-sort the registry:\n        self.__registry = OrderedDict([(c.code, c) for c in sorted(self.__registry.values(), key=lambda x: x.code)])\n\n        ## Re-sort currencies buffer:\n        self.__currencies = [c for c in self.__registry.values()]\n\n        ## Re-sort the currency codes buffer:\n        self.__codes = [c.code for c in self.__currencies]\n\n        ## Re-sort the choices buffer\n        self.__codenames = [(c.code, c.name) for c in self.__currencies]\n\n        ## Close the context:\n        self.__ctx_open = False", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Finalizes the CurrencyRegistry context by sorting and updating internal currency collections and flags, ensuring the registry's data is organized and ready for use after modifications."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "__register", "line_number": 268, "body": "def __register(self, currency: Currency) -> None:\n        \"\"\"\n        Attempts to add the currency to the registry.\n        \"\"\"\n        ## Check of the registry population context is open:\n        if not self.__ctx_open:\n            ## Nope, raise error:\n            raise ProgrammingError(\"Can not create currencies outside registry context.\")\n\n        ## Check if the currency is already added:\n        if currency.code in self.__registry:\n            raise ValueError(f\"Currency {currency.code} is already registered.\")\n\n        ## Add to the containers:\n        self.__registry[currency.code] = currency", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Private method of CurrencyRegistry that adds a new currency to the registry, ensuring it is registered only within an open context and preventing duplicate entries."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "__len__", "line_number": 284, "body": "def __len__(self) -> int:\n        \"\"\"\n        Returns the number of registered currencies.\n        \"\"\"\n        return len(self.__registry)", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Returns the total count of currencies currently registered in the CurrencyRegistry, providing a quick way to assess its size."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "__contains__", "line_number": 290, "body": "def __contains__(self, code: str) -> bool:\n        \"\"\"\n        Checks if a given currency code is available.\n        \"\"\"\n        return code in self.__registry", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Utility method in CurrencyRegistry that checks if a specific currency code is registered, facilitating quick verification of currency availability."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "__getitem__", "line_number": 296, "body": "def __getitem__(self, code: str) -> Currency:\n        \"\"\"\n        Returns the currency identified by the code or raises lookup error.\n        \"\"\"\n        try:\n            return self.__registry[code]\n        except KeyError:\n            raise CurrencyLookupError(code)", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Core method of CurrencyRegistry that retrieves a Currency object by its code or raises an error if the code is not found. It enables direct access to registered currencies through dictionary-like lookup."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "has", "line_number": 305, "body": "def has(self, code: str) -> bool:\n        \"\"\"\n        Indicates if the code is a valid currency code.\n        \"\"\"\n        return code in self.__registry", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Checks if a given code exists as a valid currency code within the CurrencyRegistry. This function helps validate currency codes against the registry\u2019s records."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "get", "line_number": 311, "body": "def get(self, code: str, default: Optional[Currency] = None) -> Optional[Currency]:\n        \"\"\"\n        Returns the currency for the given code.\n\n        Note that if the code is not a valid currency code, a currency lookup error is raised.\n        \"\"\"\n        return self.__registry.get(code, default)", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Core method of the CurrencyRegistry class that retrieves a Currency object by its code, returning a default if not found. It facilitates currency lookup services for financial or localization applications."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "all", "line_number": 320, "body": "def all(self) -> List[\"Currency\"]:\n        \"\"\"\n        Returns the list of currencies.\n        \"\"\"\n        return self.__currencies", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Returns a list of all currency objects registered in the CurrencyRegistry. This function provides access to the complete set of available currencies for further processing or reference."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "codes", "line_number": 327, "body": "def codes(self) -> List[str]:\n        \"\"\"\n        Returns a list of codes.\n        \"\"\"\n        return self.__codes", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Returns the list of all registered currency codes in the CurrencyRegistry. This provides access to the available currency identifiers managed by the registry."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/currencies.py", "function": "codenames", "line_number": 334, "body": "def codenames(self) -> List[Tuple[str, str]]:\n        \"\"\"\n        Returns a list of code/name tuples.\n        \"\"\"\n        return self.__codenames", "is_method": true, "class_name": "CurrencyRegistry", "function_description": "Returns a list of currency code and name pairs managed by the CurrencyRegistry, providing access to its stored currency identifiers and their corresponding names."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "_as_ccys", "line_number": 23, "body": "def _as_ccys(codes: Set[str]) -> Set[Currency]:\n    \"\"\"\n    Converts a set of currency codes to a set of currencies.\n    \"\"\"\n    return {Currencies[c] for c in codes}", "is_method": false, "function_description": "Helper function that converts a set of currency code strings into their corresponding Currency objects, enabling consistent currency handling in financial applications."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "_get_date_range", "line_number": 30, "body": "def _get_date_range(start: Date, end: Date) -> Iterable[Date]:\n    \"\"\"\n    Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: A generator of dates.\n    \"\"\"\n    for i in range((end - start).days):\n        yield start + datetime.timedelta(days=i)", "is_method": false, "function_description": "Utility function that generates all dates from a start date up to but excluding an end date, facilitating iteration over a specified date range for time-based processing tasks."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "_get_actual_day_count", "line_number": 42, "body": "def _get_actual_day_count(start: Date, end: Date) -> int:\n    \"\"\"\n    Counts the actual number of days in the given period.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: The number of days in the given period.\n\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n    0\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n    1\n    \"\"\"\n    return (end - start).days", "is_method": false, "function_description": "Utility function that calculates the number of full days between two dates, useful for determining durations excluding the start date."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "_has_leap_day", "line_number": 58, "body": "def _has_leap_day(start: Date, end: Date) -> bool:\n    \"\"\"\n    Indicates if the range has any leap day.\n    \"\"\"\n    ## Get all leap years:\n    years = {year for year in range(start.year, end.year + 1) if calendar.isleap(year)}\n\n    ## Check if any of the lap day falls in our range:\n    for year in years:\n        ## Construct the leap day:\n        leapday = datetime.date(year, 2, 29)\n\n        ## Is the leap date in the range?\n        if start <= leapday <= end:\n            ## Yes, the leap day is within the date range. Return True:\n            return True\n\n    ## No leap day in the range, return False:\n    return False", "is_method": false, "function_description": "Checks if the given date range includes February 29 of any leap year, indicating the presence of a leap day within the interval. Useful for date calculations requiring leap day awareness."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "_is_last_day_of_month", "line_number": 79, "body": "def _is_last_day_of_month(date: Date) -> bool:\n    \"\"\"\n    Indicates if the date is the last day of the month.\n    \"\"\"\n    return date.day == calendar.monthrange(date.year, date.month)[1]", "is_method": false, "function_description": "Function that determines whether a given date falls on the last day of its month, useful for date boundary checks or scheduling tasks at month-end."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "_last_payment_date", "line_number": 86, "body": "def _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    ## Make sure that we have eom:\n    eom = eom or start.day\n\n    ## Get the starting month:\n    s_month = start.month\n\n    ## Get the period:\n    period = int(12 / frequency)\n\n    ## Get the current day, month and year:\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n\n    ## Get the payment schedule:\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period)])])\n\n    ## Filter out previous:\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n\n    ## Get the previous month and year:\n    p_year, p_month = (c_year, future[-1]) if future else (c_year - 1, schedule[-1])\n\n    ## Return the date:\n    if p_year < 1 or p_month < 1 or eom < 1:\n        return start\n\n    ## Construct and return the date safely:\n    return _construct_date(p_year, p_month, eom)", "is_method": false, "function_description": "Utility function that calculates the most recent coupon payment date before or on a given date, based on a start date and payment frequency. Useful for financial instruments tracking periodic payments."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "_next_payment_date", "line_number": 149, "body": "def _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate", "is_method": false, "function_description": "Calculate the next coupon payment date by advancing from a start date based on an annual frequency and optionally adjusting to a specified day of the month. Useful for scheduling recurring payments in financial applications."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "_construct_date", "line_number": 176, "body": "def _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc", "is_method": false, "function_description": "Utility function that constructs a valid date object, adjusting the day downward if it exceeds the month's range, ensuring safe date creation from given year, month, and day inputs."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcc", "line_number": 367, "body": "def dcc(name: str, altnames: Optional[Set[str]] = None, ccys: Optional[Set[Currency]] = None) -> Callable[[DCFC], DCFC]:\n    \"\"\"\n    Registers a day count fraction calculator under the given names and alternative names (if any).\n\n    :param name: The name of the day count convention.\n    :param altnames: A set of alternative names of the day count convention, if any.\n    :param ccys: A set of currencies which are known to use this convention by default, if any.\n    :return: Registered day count fraction calculation function.\n    \"\"\"\n\n    def register_and_return_dcfc(func: DCFC) -> DCFC:\n        \"\"\"\n        Registers the given day count fraction calculator and returns it.\n\n        :param func: Day count fraction calculation function to be registered.\n        :return: Registered day count fraction calculation function.\n        \"\"\"\n        ## Create the DCC instance:\n        dcc = DCC(name, altnames or set([]), ccys or set([]), func)\n\n        ## Attempt to register the DCC:\n        DCCRegistry.register(dcc)\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func\n\n    return register_and_return_dcfc", "is_method": false, "function_description": "Function that provides a decorator for registering day count fraction calculators under specified names and associated currencies, enabling standardized management and lookup of day count conventions in financial calculations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_act_act", "line_number": 400, "body": "def dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    ## Get all years of interest by checking the leap year:\n    years = {year: calendar.isleap(year) for year in range(start.year, asof.year + 1)}\n\n    ## Define the buffer of days for the day count. The former is for non-leap years, the latter for leap years:\n    buffer: List[int] = [0, 0]\n\n    ## Iterate over the date range and count:\n    for date in _get_date_range(start, asof):\n        ## Check the year and modify buffer accordingly:\n        if years[date.year]:\n            ## Yep, it is a leap year:\n            buffer[1] += 1\n        else:\n            ## Nope, not a leap year:\n            buffer[0] += 1\n\n    ## Done, compute and return:\n    return Decimal(buffer[0]) / Decimal(365) + Decimal(buffer[1]) / Decimal(366)", "is_method": false, "function_description": "Function that calculates the proportion of a period elapsed between two dates using the Actual/Actual day count convention, accounting for leap and non-leap years. Useful for precise interest or accrual computations in financial contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_act_act_icma", "line_number": 444, "body": "def dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    ## Get the number of actual days:\n    p1 = Decimal(_get_actual_day_count(start, asof))\n\n    ## Get the number of days in the period:\n    p2 = Decimal(_get_actual_day_count(start, end))\n\n    ## Compute the ratio and return:\n    return p1 / p2 / Decimal(freq or ONE)", "is_method": false, "function_description": "Calculates the day count fraction for a given period using the Act/Act (ICMA) convention, aiding precise interest accrual in financial date calculations. Useful for prorating interest between start, as-of, and end dates in fixed income contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_act_360", "line_number": 472, "body": "def dcfc_act_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/360\" convention.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.17222222222222')\n    >>> round(dcfc_act_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17500000000000')\n    >>> round(dcfc_act_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.10000000000000')\n    >>> round(dcfc_act_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.34722222222222')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(360)", "is_method": false, "function_description": "Computes the day count fraction between two dates using the Actual/360 convention, commonly used in finance to calculate interest accruals over a period. It provides a standardized measure of elapsed time as a fraction of a 360-day year."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_act_365_f", "line_number": 497, "body": "def dcfc_act_365_f(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365F\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)", "is_method": false, "function_description": "Calculates the fraction of a year between two dates based on the \"Act/365F\" day count convention, commonly used in finance for interest and coupon calculations. It helps standardize time periods for accrual and payment computations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_act_365_a", "line_number": 523, "body": "def dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)", "is_method": false, "function_description": "Calculates the day count fraction for a period using the Act/365A convention, considering leap years. It supports accurate interest or accrual calculations in financial date intervals."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_act_365_l", "line_number": 549, "body": "def dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)", "is_method": false, "function_description": "Function that calculates the day count fraction between two dates using the Act/365L convention, useful for interest and financial calculations involving accrued time periods."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_nl_365", "line_number": 575, "body": "def dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)", "is_method": false, "function_description": "Function that calculates the day count fraction between given dates using the \"NL/365\" convention, commonly used in finance to measure interest accrual over periods accounting for leap days."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_30_360_isda", "line_number": 601, "body": "def dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)", "is_method": false, "function_description": "Calculates the fraction of a year between two dates using the 30/360 ISDA day count convention, commonly used in financial contracts to standardize interest calculations. This function aids in determining interest accrual or payment periods."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_30_e_360", "line_number": 639, "body": "def dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)", "is_method": false, "function_description": "Function that calculates the day count fraction between two dates using the 30E/360 convention, commonly applied in financial contexts for interest and accrual computations. It supports precise period fraction calculations for date intervals under this standardized method."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_30_e_plus_360", "line_number": 677, "body": "def dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)", "is_method": false, "function_description": "Function that calculates the day count fraction between two dates using the \"30E+/360\" financial day count convention, supporting interest and accrual calculations in fixed income and derivatives contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_30_360_german", "line_number": 716, "body": "def dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    ## Get the new asof date, if required:\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)", "is_method": false, "function_description": "Function that calculates the day count fraction between two dates using the 30/360 German day count convention, commonly used in finance to measure accrued interest over a period. It supports precise interest computations for fixed income instruments."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "dcfc_30_360_us", "line_number": 758, "body": "def dcfc_30_360_us(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get D1 and D2:\n    d1 = start.day\n    d2 = asof.day\n\n    ## Need to change D1?\n    if _is_last_day_of_month(start):\n        ## Yep, change it:\n        d1 = 30\n\n        ## Shall we change the d2, too?\n        if _is_last_day_of_month(asof):\n            d2 = 30\n\n    ## Revisit d2:\n    if d2 == 31 and (d1 == 30 or d1 == 31):\n        d2 = 30\n\n    ## Revisit d1:\n    if d1 == 31:\n        d1 = 30\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, return:\n    return nod / Decimal(360)", "is_method": false, "function_description": "Calculates the day count fraction between two dates using the 30/360 US convention, commonly applied in bond and loan interest calculations for standardized period measurements. It enables precise interest accrual computations over irregular date intervals."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "calculate_fraction", "line_number": 208, "body": "def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)", "is_method": true, "class_name": "DCC", "function_description": "Core method of the DCC class that computes the day count fraction for a given date range, ensuring date validity before applying the defined calculation methodology. It supports customizable frequency parameters for flexible financial day count computations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "calculate_daily_fraction", "line_number": 220, "body": "def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact", "is_method": true, "class_name": "DCC", "function_description": "Calculates the fractional change between two consecutive dates relative to a date range, useful for determining daily increments of a cumulative fraction in time-based financial or data analysis contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "interest", "line_number": 239, "body": "def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)", "is_method": true, "class_name": "DCC", "function_description": "Utility method in DCC that calculates accrued interest over a specified period using given principal, rate, and date parameters, supporting custom time fractions and optional frequency for flexible interest computations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "coupon", "line_number": 253, "body": "def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))", "is_method": true, "class_name": "DCC", "function_description": "Calculates the accrued interest for a bond coupon payment between specified dates, supporting regular payment schedules. This function is useful for determining coupon amounts as of a given date within bond cash flow modeling."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "_is_registered", "line_number": 304, "body": "def _is_registered(self, name: str) -> bool:\n        \"\"\"\n        Checks if the given name is ever registered before.\n        \"\"\"\n        return name in self._buffer_main or name in self._buffer_altn", "is_method": true, "class_name": "DCCRegistryMachinery", "function_description": "Utility method in DCCRegistryMachinery that verifies whether a given name has been previously registered within its main or alternate buffers."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "register", "line_number": 310, "body": "def register(self, dcc: DCC) -> None:\n        \"\"\"\n        Attempts to register the given day count convention.\n        \"\"\"\n        ## Check if the main name is ever registered before:\n        if self._is_registered(dcc.name):\n            ## Yep, raise a TypeError:\n            raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n        ## Add to the main buffer:\n        self._buffer_main[dcc.name] = dcc\n\n        ## Check if there is any registry conflict:\n        for name in dcc.altnames:\n            ## Check if the name is ever registered:\n            if self._is_registered(name):\n                ## Yep, raise a TypeError:\n                raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n            ## Register to the alternative buffer:\n            self._buffer_altn[name] = dcc", "is_method": true, "class_name": "DCCRegistryMachinery", "function_description": "Registers a new day count convention by its main and alternative names, ensuring no duplicate registrations occur, thereby managing uniqueness within the DCCRegistryMachinery."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "_find_strict", "line_number": 332, "body": "def _find_strict(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n        \"\"\"\n        return self._buffer_main.get(name) or self._buffer_altn.get(name)", "is_method": true, "class_name": "DCCRegistryMachinery", "function_description": "Internal helper of DCCRegistryMachinery that locates a day count convention by its exact name from primary or alternate registries."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "find", "line_number": 338, "body": "def find(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n\n        Note that all day count conventions are registered under stripped, uppercased names. Therefore,\n        the implementation will first attempt to find by given name as is. If it can not find it, it will\n        strip and uppercase the name and try to find it as such as a last resort.\n        \"\"\"\n        return self._find_strict(name) or self._find_strict(name.strip().upper())", "is_method": true, "class_name": "DCCRegistryMachinery", "function_description": "Retrieves a day count convention by name, trying both the exact and a normalized (stripped, uppercased) version. Useful for flexible lookup of registered day count conventions in financial calculations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "registry", "line_number": 349, "body": "def registry(self) -> List[DCC]:\n        \"\"\"\n        Returns the main registry values.\n        \"\"\"\n        return list(self._buffer_main.values())", "is_method": true, "class_name": "DCCRegistryMachinery", "function_description": "Provides access to the primary collection of DCC objects managed by the DCCRegistryMachinery, enabling retrieval of all registered entries for further use or inspection."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "table", "line_number": 356, "body": "def table(self) -> Dict[str, DCC]:\n        \"\"\"\n        Returns a lookup table for available day count conventions.\n        \"\"\"\n        return {**{k: v for k, v in self._buffer_main.items()}, **{k: v for k, v in self._buffer_altn.items()}}", "is_method": true, "class_name": "DCCRegistryMachinery", "function_description": "Provides a lookup table combining all available day count conventions from primary and alternate sources for easy access and reference within the DCCRegistryMachinery class."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/dcc.py", "function": "register_and_return_dcfc", "line_number": 377, "body": "def register_and_return_dcfc(func: DCFC) -> DCFC:\n        \"\"\"\n        Registers the given day count fraction calculator and returns it.\n\n        :param func: Day count fraction calculation function to be registered.\n        :return: Registered day count fraction calculation function.\n        \"\"\"\n        ## Create the DCC instance:\n        dcc = DCC(name, altnames or set([]), ccys or set([]), func)\n\n        ## Attempt to register the DCC:\n        DCCRegistry.register(dcc)\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func", "is_method": false, "function_description": "Utility function that registers a day count fraction calculation function within a registry and returns the registered function, enabling consistent identification and management of day count fraction calculators in financial applications."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/exchange.py", "function": "__invert__", "line_number": 81, "body": "def __invert__(self) -> \"FXRate\":\n        \"\"\"\n        Returns the inverted foreign exchange rate.\n\n        >>> import datetime\n        >>> from decimal import Decimal\n        >>> from pypara.currencies import Currencies\n        >>> nrate = FXRate(Currencies[\"EUR\"], Currencies[\"USD\"], datetime.date.today(), Decimal(\"2\"))\n        >>> rrate = FXRate(Currencies[\"USD\"], Currencies[\"EUR\"], datetime.date.today(), Decimal(\"0.5\"))\n        >>> ~nrate == rrate\n        True\n        \"\"\"\n        return FXRate(self[1], self[0], self[2], self[3] ** -1)", "is_method": true, "class_name": "FXRate", "function_description": "Provides a convenient way to obtain the inverse of a foreign exchange rate, flipping currency pairs and reciprocating the rate value. Useful for currency conversion applications requiring reciprocal FX rate calculations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/exchange.py", "function": "of", "line_number": 96, "body": "def of(cls, ccy1: Currency, ccy2: Currency, date: Date, value: Decimal) -> \"FXRate\":\n        \"\"\"\n        Creates and returns an FX rate instance by validating arguments.\n\n        >>> import datetime\n        >>> from decimal import Decimal\n        >>> from pypara.currencies import Currencies\n        >>> urate = FXRate(Currencies[\"EUR\"], Currencies[\"USD\"], datetime.date.today(), Decimal(\"2\"))\n        >>> srate = FXRate.of(Currencies[\"EUR\"], Currencies[\"USD\"], datetime.date.today(), Decimal(\"2\"))\n        >>> urate == srate\n        True\n        \"\"\"\n        ## All argument must be of the respective specified type:\n        if not isinstance(ccy1, Currency):\n            raise ValueError(\"CCY/1 must be of type `Currency`.\")\n        if not isinstance(ccy2, Currency):\n            raise ValueError(\"CCY/2 must be of type `Currency`.\")\n        if not isinstance(ccy1, Currency):\n            raise ValueError(\"FX rate value must be of type `Decimal`.\")\n        if not isinstance(ccy1, Currency):\n            raise ValueError(\"FX rate date must be of type `date`.\")\n\n        ## Check the value:\n        if value <= ZERO:\n            raise ValueError(\"FX rate value can not be equal to or less than `zero`.\")\n\n        ## Check consistency:\n        if ccy1 == ccy2 and value != ONE:\n            raise ValueError(\"FX rate to the same currency must be `one`.\")\n\n        ## Create and return the FX rate instance:\n        return cls(ccy1, ccy2, date, value)", "is_method": true, "class_name": "FXRate", "function_description": "Creates and returns a validated FXRate instance representing the exchange rate between two currencies on a specific date. This ensures correct input types and logical consistency before instantiation."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/exchange.py", "function": "query", "line_number": 142, "body": "def query(self, ccy1: Currency, ccy2: Currency, asof: Date, strict: bool = False) -> Optional[FXRate]:\n        \"\"\"\n        Returns the foreign exchange rate of a given currency pair as of a given date.\n\n        :param ccy1: The first currency of foreign exchange rate.\n        :param ccy2: The second currency of foreign exchange rate.\n        :param asof: Temporal dimension the foreign exchange rate is effective as of.\n        :param strict: Indicates if we should raise a lookup error if that the foreign exchange rate can not be found.\n        :return: The foreign exhange rate as a :class:`Decimal` instance or None.\n        \"\"\"\n        pass", "is_method": true, "class_name": "FXRateService", "function_description": "Core method of FXRateService that retrieves the foreign exchange rate for a specified currency pair on a given date, optionally enforcing strict existence checks. It supports historical FX rate queries for financial calculations and analysis."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_boolean", "line_number": 101, "body": "def as_boolean(self) -> bool:\n        \"\"\"\n        Returns the logical representation of the money object.\n\n        In particular:\n\n        1. ``False`` if money is *undefined* **or** money quantity is ``zero``.\n        2. ``True`` otherwise.\n        \"\"\"\n        raise NotImplementedError", "is_method": true, "class_name": "Money", "function_description": "Returns the logical truth value of a Money object, indicating True if it has a defined, non-zero amount, and False if it is undefined or zero."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "of", "line_number": 314, "body": "def of(cls, ccy: Optional[Currency], qty: Optional[Decimal], dov: Optional[Date]) -> \"Money\":\n        \"\"\"\n        Provides a factory method to create a new money object in a safe manner.\n        \"\"\"\n        if qty is None or ccy is None or dov is None:\n            return NoMoney\n        return SomeMoney(ccy, ccy.quantize(qty), dov)", "is_method": true, "class_name": "Money", "function_description": "Factory method in the Money class that safely creates a Money instance when currency, amount, and date are provided; otherwise, it returns a sentinel NoMoney value."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "__round__", "line_number": 351, "body": "def __round__(self) -> int:\n        ...", "is_method": true, "class_name": "Money", "function_description": "Returns the monetary value rounded to the nearest integer. This allows consistent rounding behavior for Money objects in financial calculations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "__round__", "line_number": 359, "body": "def __round__(self, ndigits: int) -> \"Money\":\n        ...", "is_method": true, "class_name": "Money", "function_description": "Core method of the Money class that rounds the monetary amount to a specified number of decimal places, providing convenient precision control for financial calculations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "__round__", "line_number": 362, "body": "def __round__(self, ndigits: Optional[int] = 0) -> Union[\"Money\", int]:\n        return self.round(ndigits or 0)", "is_method": true, "class_name": "Money", "function_description": "Method in the Money class that rounds the monetary amount to a specified number of decimal places, returning a rounded Money instance or an integer when no digits are specified."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "is_equal", "line_number": 421, "body": "def is_equal(self, other: Any) -> bool:\n        return other.__class__ is SomeMoney and tuple(self) == tuple(other)", "is_method": true, "class_name": "SomeMoney", "function_description": "Method that checks equality between two SomeMoney instances by comparing their class type and internal values, ensuring precise monetary object comparison for use cases like financial calculations or data validation."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_boolean", "line_number": 424, "body": "def as_boolean(self) -> bool:\n        return self[1].__bool__()", "is_method": true, "class_name": "SomeMoney", "function_description": "Core utility method of the SomeMoney class that returns the boolean representation of its internal value, enabling truthiness checks in conditional contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_float", "line_number": 427, "body": "def as_float(self) -> float:\n        return self[1].__float__()", "is_method": true, "class_name": "SomeMoney", "function_description": "Utility method in the SomeMoney class that converts the numeric part of a monetary value to a float, facilitating numerical operations and calculations with monetary amounts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_integer", "line_number": 430, "body": "def as_integer(self) -> int:\n        return self[1].__int__()", "is_method": true, "class_name": "SomeMoney", "function_description": "Core utility method of the SomeMoney class that returns the integer representation of its second element, enabling consistent numeric processing of monetary values."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "abs", "line_number": 433, "body": "def abs(self) -> \"Money\":\n        c, q, d = self\n        return SomeMoney(c, q.__abs__(), d)", "is_method": true, "class_name": "SomeMoney", "function_description": "Returns a new Money instance with the absolute value of the quantity, preserving currency and denomination. This provides a way to obtain a non-negative representation of a monetary amount."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "negative", "line_number": 437, "body": "def negative(self) -> \"Money\":\n        c, q, d = self\n        return SomeMoney(c, q.__neg__(), d)", "is_method": true, "class_name": "SomeMoney", "function_description": "Utility method of SomeMoney that returns a new Money instance representing the negation of its quantity, supporting operations like reversing monetary values or balances."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "positive", "line_number": 441, "body": "def positive(self) -> \"Money\":\n        c, q, d = self\n        return SomeMoney(c, q.__pos__(), d)", "is_method": true, "class_name": "SomeMoney", "function_description": "Returns a new Money instance with a positive quantity, preserving currency and date. It provides a simple way to ensure the monetary amount is non-negative within the SomeMoney context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "round", "line_number": 445, "body": "def round(self, ndigits: int = 0) -> \"Money\":\n        c, q, d = self\n        dec = c.decimals\n        return SomeMoney(c, q.__round__(ndigits if ndigits < dec else dec), d)", "is_method": true, "class_name": "SomeMoney", "function_description": "Utility method of SomeMoney that rounds its numeric value to a specified precision, constrained by the currency's decimal limits, returning a new rounded Money instance."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "add", "line_number": 450, "body": "def add(self, other: \"Money\") -> \"Money\":\n        if other.undefined:\n            return self\n\n        c1: Currency\n        q1: Decimal\n        d1: Date\n        c2: Currency\n        q2: Decimal\n        d2: Date\n        c1, q1, d1 = self\n        c2, q2, d2 = other  # type: ignore\n\n        if c1 != c2:\n            raise IncompatibleCurrencyError(ccy1=c1, ccy2=c2, operation=\"addition\")\n\n        return SomeMoney(c1, q1 + q2, d1 if d1 > d2 else d2)", "is_method": true, "class_name": "SomeMoney", "function_description": "Service method of the SomeMoney class that adds two Money instances with the same currency, returning a new SomeMoney object with the combined amount and the later of the two dates. It ensures currency compatibility and ignores undefined amounts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "scalar_add", "line_number": 468, "body": "def scalar_add(self, other: Numeric) -> \"Money\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomeMoney(c, (q + Decimal(other)).quantize(c.quantizer), d)", "is_method": true, "class_name": "SomeMoney", "function_description": "Core method of the SomeMoney class that adds a numeric value to the monetary amount, returning a new Money instance with the updated quantity while preserving the original currency and details."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "subtract", "line_number": 473, "body": "def subtract(self, other: \"Money\") -> \"Money\":\n        if other.undefined:\n            return self\n\n        c1: Currency\n        q1: Decimal\n        d1: Date\n        c2: Currency\n        q2: Decimal\n        d2: Date\n        c1, q1, d1 = self\n        c2, q2, d2 = other  # type: ignore\n\n        if c1 != c2:\n            raise IncompatibleCurrencyError(ccy1=c1, ccy2=c2, operation=\"subtraction\")\n\n        return SomeMoney(c1, q1 - q2, d1 if d1 > d2 else d2)", "is_method": true, "class_name": "SomeMoney", "function_description": "Performs currency-aware subtraction of two Money instances, ensuring matching currencies and returning a new Money object with the later date. Useful for accurate financial calculations involving money values."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "scalar_subtract", "line_number": 491, "body": "def scalar_subtract(self, other: Numeric) -> \"Money\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomeMoney(c, (q - Decimal(other)).quantize(c.quantizer), d)", "is_method": true, "class_name": "SomeMoney", "function_description": "Utility method of the SomeMoney class that subtracts a numeric value from its quantity, returning a new Money instance with the updated amount while maintaining consistency in decimal precision."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "multiply", "line_number": 496, "body": "def multiply(self, other: Numeric) -> \"Money\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomeMoney(c, (q * Decimal(other)).quantize(c.quantizer), d)", "is_method": true, "class_name": "SomeMoney", "function_description": "Utility method of the SomeMoney class that multiplies a monetary amount by a numeric value, returning a new Money instance with the adjusted quantity accurately quantized."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "divide", "line_number": 501, "body": "def divide(self, other: Numeric) -> \"Money\":\n        ## TODO: **try** not casting other to Decimal.\n        try:\n            c, q, d = self\n            return SomeMoney(c, (q / Decimal(other)).quantize(c.quantizer), d)\n        except (InvalidOperation, DivisionByZero):\n            return NoMoney", "is_method": true, "class_name": "SomeMoney", "function_description": "Method of the SomeMoney class that divides a monetary amount by a numeric value, returning the resulting amount or a sentinel value if the operation is invalid or causes division by zero."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "floor_divide", "line_number": 509, "body": "def floor_divide(self, other: Numeric) -> \"Money\":\n        ## TODO: **try** not casting other to Decimal.\n        try:\n            c, q, d = self\n            return SomeMoney(c, (q // Decimal(other)).quantize(c.quantizer), d)\n        except (InvalidOperation, DivisionByZero):\n            return NoMoney", "is_method": true, "class_name": "SomeMoney", "function_description": "Method of SomeMoney that performs floor division between a monetary value and a numeric operand, returning the resulting monetary amount or a special NoMoney value if the operation fails."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "lt", "line_number": 517, "body": "def lt(self, other: \"Money\") -> bool:\n        if other.undefined:\n            return False\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"< comparision\")\n        return self.qty < other.qty", "is_method": true, "class_name": "SomeMoney", "function_description": "Provides a comparison function to determine if one Money instance is less than another, ensuring currency compatibility before comparing their quantities. Useful for financial operations requiring currency-consistent ordering."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "lte", "line_number": 524, "body": "def lte(self, other: \"Money\") -> bool:\n        if other.undefined:\n            return False\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"<= comparision\")\n        return self.qty <= other.qty", "is_method": true, "class_name": "SomeMoney", "function_description": "Provides a comparison method that determines if one Money instance is less than or equal to another, ensuring currency compatibility and handling undefined values. Useful for financial operations requiring safe currency-aware comparisons."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "gt", "line_number": 531, "body": "def gt(self, other: \"Money\") -> bool:\n        if other.undefined:\n            return True\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"> comparision\")\n        return self.qty > other.qty", "is_method": true, "class_name": "SomeMoney", "function_description": "Comparison method in the SomeMoney class that determines if one Money instance represents a greater amount than another, ensuring currencies match and handling undefined values appropriately."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "gte", "line_number": 538, "body": "def gte(self, other: \"Money\") -> bool:\n        if other.undefined:\n            return True\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\">= comparision\")\n        return self.qty >= other.qty", "is_method": true, "class_name": "SomeMoney", "function_description": "Method of the SomeMoney class that compares two monetary amounts, returning True if the current amount is greater or equal, ensuring currencies match or handling undefined values appropriately."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_ccy", "line_number": 545, "body": "def with_ccy(self, ccy: Currency) -> \"Money\":\n        return SomeMoney(ccy, self[1], self[2])", "is_method": true, "class_name": "SomeMoney", "function_description": "Creates a new SomeMoney instance with the specified currency while preserving the original amount and other attributes. Useful for currency conversion or standardizing money representations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_qty", "line_number": 548, "body": "def with_qty(self, qty: Decimal) -> \"Money\":\n        c, q, d = self\n        return SomeMoney(c, qty.quantize(c.quantizer), d)", "is_method": true, "class_name": "SomeMoney", "function_description": "Method of the SomeMoney class that creates a new monetary amount instance with a specified quantity, ensuring the quantity conforms to the currency's decimal precision rules."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_dov", "line_number": 552, "body": "def with_dov(self, dov: Date) -> \"Money\":\n        return SomeMoney(self[0], self[1], dov)", "is_method": true, "class_name": "SomeMoney", "function_description": "Creates a new SomeMoney instance with the same currency and amount but a different date of value (dov). This enables adjusting the monetary value's effective date without altering other attributes."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "convert", "line_number": 555, "body": "def convert(self, to: Currency, asof: Optional[Date] = None, strict: bool = False) -> \"Money\":\n        ## Get slots:\n        ccy, qty, dov = self\n\n        ## Get date of conversion:\n        asof = asof or dov\n\n        ## Attempt to get the FX rate:\n        try:\n            rate = FXRateService.default.query(ccy, to, asof, strict)  # type: ignore\n        except AttributeError as exc:\n            if FXRateService.default is None:\n                raise ProgrammingError(\"Did you implement and set the default FX rate service?\")\n            else:\n                raise exc\n\n        ## Do we have a rate?\n        if rate is None:\n            ## Nope, shall we raise exception?\n            if strict:\n                ## Yep:\n                raise FXRateLookupError(ccy, to, asof)\n            else:\n                ## Just return NA:\n                return NoMoney\n\n        ## Compute and return:\n        return SomeMoney(to, (qty * rate.value).quantize(to.quantizer), asof)", "is_method": true, "class_name": "SomeMoney", "function_description": "Converts an amount of money from one currency to another using a specified exchange rate service, optionally raising errors for missing rates or returning a no-value result. Useful for currency conversions with date and strictness controls."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "price", "line_number": 585, "body": "def price(self) -> \"Price\":\n        return SomePrice(*self)", "is_method": true, "class_name": "SomeMoney", "function_description": "Returns a Price representation based on the current SomeMoney instance, providing a way to convert or interpret monetary values within related pricing contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_boolean", "line_number": 629, "body": "def as_boolean(self) -> bool:\n        return False", "is_method": true, "class_name": "NoneMoney", "function_description": "This function consistently returns False, providing a boolean representation for the NoneMoney type, indicating it effectively represents the absence or zero value of money."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "is_equal", "line_number": 632, "body": "def is_equal(self, other: Any) -> bool:\n        return other.__class__ is NoneMoney", "is_method": true, "class_name": "NoneMoney", "function_description": "Method that checks whether another object is exactly of the NoneMoney class, providing type-based equality verification."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "abs", "line_number": 635, "body": "def abs(self) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the current Money instance as its absolute value. This method provides a consistent interface for absolute value retrieval without modifying the original object."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_float", "line_number": 638, "body": "def as_float(self) -> float:\n        raise TypeError(\"Undefined monetary values do not have quantity information.\")", "is_method": true, "class_name": "NoneMoney", "function_description": "Raises an error when attempting to convert an undefined monetary value to a float, indicating that such values lack quantifiable information. This prevents invalid numeric operations on non-defined monetary amounts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_integer", "line_number": 641, "body": "def as_integer(self) -> int:\n        raise TypeError(\"Undefined monetary values do not have quantity information.\")", "is_method": true, "class_name": "NoneMoney", "function_description": "Raises an error when attempting to retrieve a numeric value from an undefined monetary amount, preventing misuse of non-quantifiable money representations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "round", "line_number": 644, "body": "def round(self, ndigits: int = 0) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the current Money instance unchanged, ignoring any rounding requests. This function effectively disables rounding operations on the Money object."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "negative", "line_number": 647, "body": "def negative(self) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the current Money instance unchanged, effectively providing a no-op negative operation. This can be used where negation is expected but not applicable or overridden."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "positive", "line_number": 650, "body": "def positive(self) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the current instance of Money, representing a positive monetary value without modification. This can be used to ensure or express that a Money object is positive."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "add", "line_number": 653, "body": "def add(self, other: \"Money\") -> \"Money\":\n        return other", "is_method": true, "class_name": "NoneMoney", "function_description": "This method returns the given Money instance as is without performing any addition. It effectively replaces the current Money object with another."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "scalar_add", "line_number": 656, "body": "def scalar_add(self, other: Numeric) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the current Money instance unchanged, ignoring any scalar addition. This might serve as a placeholder or a no-op implementation for scalar addition."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "subtract", "line_number": 659, "body": "def subtract(self, other: \"Money\") -> \"Money\":\n        return -other", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the negation of the given Money instance rather than performing a subtraction operation. This function provides a way to obtain the inverse value of a Money object."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "scalar_subtract", "line_number": 662, "body": "def scalar_subtract(self, other: Numeric) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the current Money instance unchanged, regardless of the subtraction operation requested."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "multiply", "line_number": 665, "body": "def multiply(self, other: Numeric) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the current Money instance unchanged when multiplied by a numeric value, effectively making multiplication operations no-ops for this class."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "divide", "line_number": 668, "body": "def divide(self, other: Numeric) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Core method of the NoneMoney class that provides a division operation returning the instance itself, potentially representing a non-value or null monetary amount in arithmetic contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "floor_divide", "line_number": 671, "body": "def floor_divide(self, other: Numeric) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Core method of NoneMoney that overrides floor division to return itself, likely serving as a neutral or no-op placeholder in arithmetic operations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "lt", "line_number": 674, "body": "def lt(self, other: \"Money\") -> bool:\n        return other.defined", "is_method": true, "class_name": "NoneMoney", "function_description": "Compares two Money objects by checking if the other object is defined, providing a custom less-than evaluation based on the defined status of the compared instance."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "lte", "line_number": 677, "body": "def lte(self, other: \"Money\") -> bool:\n        return True", "is_method": true, "class_name": "NoneMoney", "function_description": "Always returns True regardless of the compared Money value, effectively indicating this amount is less than or equal to any other. This may serve as a placeholder or a special comparison override in monetary contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "gt", "line_number": 680, "body": "def gt(self, other: \"Money\") -> bool:\n        return False", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns False for any greater-than comparison, effectively disabling this comparison operation between Money instances."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "gte", "line_number": 683, "body": "def gte(self, other: \"Money\") -> bool:\n        return other.undefined", "is_method": true, "class_name": "NoneMoney", "function_description": "This function returns True if the compared Money instance is undefined, serving as a comparison utility that prioritizes undefined values in ordering logic."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_ccy", "line_number": 686, "body": "def with_ccy(self, ccy: Currency) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the current Money instance unchanged, ignoring any currency conversion requests. This can be used when currency adjustments are not applicable or needed."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_qty", "line_number": 689, "body": "def with_qty(self, qty: Decimal) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the current Money instance unchanged, regardless of the provided quantity. This placeholder method may be intended for interface compatibility or future extension."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_dov", "line_number": 692, "body": "def with_dov(self, dov: Date) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the current Money instance unchanged, ignoring any provided date. This method serves as a placeholder or default implementation for date-specific adjustments."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "convert", "line_number": 695, "body": "def convert(self, to: Currency, asof: Optional[Date] = None, strict: bool = False) -> \"Money\":\n        return self", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns the current instance unchanged, effectively bypassing any currency conversion operation while maintaining compatibility with conversion interfaces. This is useful when no conversion is needed or applicable."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "price", "line_number": 699, "body": "def price(self) -> \"Price\":\n        return NoPrice", "is_method": true, "class_name": "NoneMoney", "function_description": "Returns a constant price value indicating the absence of a valid price. This function provides a standard way to represent \"no price\" within financial computations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "of", "line_number": 1014, "body": "def of(cls, ccy: Optional[Currency], qty: Optional[Decimal], dov: Optional[Date]) -> \"Price\":\n        \"\"\"\n        Provides a factory method to create a new price object in a safe manner.\n        \"\"\"\n        if qty is None or ccy is None or dov is None:\n            return NoPrice\n        return SomePrice(ccy, qty, dov)", "is_method": true, "class_name": "Price", "function_description": "Factory method of the Price class that safely creates a new price object from currency, quantity, and date inputs, returning a placeholder if any required value is missing."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "__round__", "line_number": 1043, "body": "def __round__(self) -> int:\n        ...", "is_method": true, "class_name": "Price", "function_description": "Returns the rounded integer value of the Price instance, enabling consistent use in calculations or comparisons where integer pricing is required."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "__round__", "line_number": 1051, "body": "def __round__(self, ndigits: int) -> \"Price\":\n        ...", "is_method": true, "class_name": "Price", "function_description": "Enables rounding of a Price instance to a specified number of decimal places, returning a new Price object with the rounded value. Useful for controlling price precision in financial calculations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "__round__", "line_number": 1054, "body": "def __round__(self, ndigits: Optional[int] = 0) -> Union[\"Price\", int]:\n        return self.round(ndigits or 0)", "is_method": true, "class_name": "Price", "function_description": "Overrides the built-in rounding behavior to provide custom rounding of price values to a specified number of decimal places, returning either a rounded Price object or an integer."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "is_equal", "line_number": 1113, "body": "def is_equal(self, other: Any) -> bool:\n        return other.__class__ is SomePrice and tuple(self) == tuple(other)", "is_method": true, "class_name": "SomePrice", "function_description": "Method of SomePrice that compares two instances for equality by checking class type and internal data, enabling precise value comparison between price objects."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_boolean", "line_number": 1116, "body": "def as_boolean(self) -> bool:\n        return self.qty.__bool__()", "is_method": true, "class_name": "SomePrice", "function_description": "Utility method of the SomePrice class that converts the quantity attribute to a boolean value, indicating its truthiness for conditional evaluations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_float", "line_number": 1119, "body": "def as_float(self) -> float:\n        return self.qty.__float__()", "is_method": true, "class_name": "SomePrice", "function_description": "Converts the quantity attribute of a SomePrice instance to a floating-point number. This allows other functions to easily obtain a numeric representation for calculations or comparisons."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_integer", "line_number": 1122, "body": "def as_integer(self) -> int:\n        return self.qty.__int__()", "is_method": true, "class_name": "SomePrice", "function_description": "Utility method of the SomePrice class that returns the quantity attribute as an integer value, enabling numeric operations or comparisons involving the price quantity."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "abs", "line_number": 1125, "body": "def abs(self) -> \"Price\":\n        c, q, d = self\n        return SomePrice(c, q.__abs__(), d)", "is_method": true, "class_name": "SomePrice", "function_description": "Returns a new SomePrice instance with the absolute value of the quantity, preserving the currency and date attributes. This allows users to obtain the non-negative equivalent of a price object."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "negative", "line_number": 1129, "body": "def negative(self) -> \"Price\":\n        c, q, d = self\n        return SomePrice(c, q.__neg__(), d)", "is_method": true, "class_name": "SomePrice", "function_description": "Returns a new SomePrice instance with the quantity negated, enabling easy inversion of price quantities for arithmetic or comparison operations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "positive", "line_number": 1133, "body": "def positive(self) -> \"Price\":\n        c, q, d = self\n        return SomePrice(c, q.__pos__(), d)", "is_method": true, "class_name": "SomePrice", "function_description": "Core method of SomePrice that returns a new Price instance with the quantity made positive, preserving the other attributes. It standardizes price representation with a non-negative quantity."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "round", "line_number": 1137, "body": "def round(self, ndigits: int = 0) -> \"Price\":\n        c, q, d = self\n        return SomePrice(c, q.__round__(ndigits), d)", "is_method": true, "class_name": "SomePrice", "function_description": "Method of the SomePrice class that returns a new Price instance with the quantity rounded to a specified number of decimal places. It facilitates precise quantity adjustments without altering other price components."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "add", "line_number": 1141, "body": "def add(self, other: \"Price\") -> \"Price\":\n        if other.undefined:\n            return self\n\n        c1: Currency\n        q1: Decimal\n        d1: Date\n        c2: Currency\n        q2: Decimal\n        d2: Date\n        c1, q1, d1 = self\n        c2, q2, d2 = other  # type: ignore\n\n        if c1 != c2:\n            raise IncompatibleCurrencyError(ccy1=c1, ccy2=c2, operation=\"addition\")\n\n        return SomePrice(c1, q1 + q2, d1 if d1 > d2 else d2)", "is_method": true, "class_name": "SomePrice", "function_description": "Adds two Price objects if they share the same currency, returning a new Price with the combined quantity and the later date. It ensures currency compatibility and gracefully handles undefined prices."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "scalar_add", "line_number": 1159, "body": "def scalar_add(self, other: Numeric) -> \"Price\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomePrice(c, q + Decimal(other), d)", "is_method": true, "class_name": "SomePrice", "function_description": "Method of SomePrice that returns a new price by adding a numeric value to the quantity component, enabling convenient arithmetic operations on price quantities."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "subtract", "line_number": 1164, "body": "def subtract(self, other: \"Price\") -> \"Price\":\n        if other.undefined:\n            return self\n\n        c1: Currency\n        q1: Decimal\n        d1: Date\n        c2: Currency\n        q2: Decimal\n        d2: Date\n        c1, q1, d1 = self\n        c2, q2, d2 = other  # type: ignore\n\n        if c1 != c2:\n            raise IncompatibleCurrencyError(ccy1=c1, ccy2=c2, operation=\"subtraction\")\n\n        return SomePrice(c1, q1 - q2, d1 if d1 > d2 else d2)", "is_method": true, "class_name": "SomePrice", "function_description": "Method of the SomePrice class that subtracts one price from another, ensuring currency compatibility and returning a new price with the later date. It provides safe arithmetic operations on price objects with currency and date validation."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "scalar_subtract", "line_number": 1182, "body": "def scalar_subtract(self, other: Numeric) -> \"Price\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomePrice(c, q - Decimal(other), d)", "is_method": true, "class_name": "SomePrice", "function_description": "Utility method in SomePrice that subtracts a numeric value from the quantity component, returning a new Price instance reflecting the updated quantity."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "multiply", "line_number": 1187, "body": "def multiply(self, other: Numeric) -> \"Price\":\n        ## TODO: **try** not casting other to Decimal.\n        c, q, d = self\n        return SomePrice(c, q * Decimal(other), d)", "is_method": true, "class_name": "SomePrice", "function_description": "Service method of SomePrice that returns a new Price by scaling its quantity with a given numeric value, enabling easy multiplication of price quantities within pricing calculations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "times", "line_number": 1192, "body": "def times(self, other: Numeric) -> \"Money\":\n        c, q, d = self\n        return SomeMoney(c, (q * Decimal(other)).quantize(c.quantizer), self.dov)", "is_method": true, "class_name": "SomePrice", "function_description": "Performs multiplication of a monetary amount by a numeric value, returning a new Money instance with the scaled quantity while preserving currency and precision settings."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "divide", "line_number": 1196, "body": "def divide(self, other: Numeric) -> \"Price\":\n        ## TODO: **try** not casting other to Decimal.\n        try:\n            c, q, d = self\n            return SomePrice(c, q / Decimal(other), d)\n        except (InvalidOperation, DivisionByZero):\n            return NoPrice", "is_method": true, "class_name": "SomePrice", "function_description": "Method of SomePrice that divides its quantity by a given number, returning a new price instance or a sentinel value if division fails. Useful for scaling price quantities safely with error handling."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "floor_divide", "line_number": 1204, "body": "def floor_divide(self, other: Numeric) -> \"Price\":\n        ## TODO: **try** not casting other to Decimal.\n        try:\n            c, q, d = self\n            return SomePrice(c, q // Decimal(other), d)\n        except (InvalidOperation, DivisionByZero):\n            return NoPrice", "is_method": true, "class_name": "SomePrice", "function_description": "Method of the SomePrice class that performs floor division of its quantity by another numeric value, returning a new price or a sentinel value if the operation is invalid or divides by zero."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "lt", "line_number": 1212, "body": "def lt(self, other: \"Price\") -> bool:\n        if other.undefined:\n            return False\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"< comparision\")\n        return self.qty < other.qty", "is_method": true, "class_name": "SomePrice", "function_description": "Compares two Price objects to determine if one is less than the other, ensuring currency compatibility and handling undefined values. It supports safe price comparisons within the same currency context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "lte", "line_number": 1219, "body": "def lte(self, other: \"Price\") -> bool:\n        if other.undefined:\n            return False\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"<= comparision\")\n        return self.qty <= other.qty", "is_method": true, "class_name": "SomePrice", "function_description": "Compares two Price objects to determine if the current price is less than or equal to another, ensuring currencies match; raises an error if currencies differ and returns False if the other price is undefined."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "gt", "line_number": 1226, "body": "def gt(self, other: \"Price\") -> bool:\n        if other.undefined:\n            return True\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\"> comparision\")\n        return self.qty > other.qty", "is_method": true, "class_name": "SomePrice", "function_description": "Compares two Price objects to determine if the current price is greater, ensuring currency compatibility and handling undefined prices. It supports safe price comparison within a consistent currency context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "gte", "line_number": 1233, "body": "def gte(self, other: \"Price\") -> bool:\n        if other.undefined:\n            return True\n        elif self.ccy != other.ccy:\n            raise IncompatibleCurrencyError(ccy1=self.ccy, ccy2=other.ccy, operation=\">= comparision\")\n        return self.qty >= other.qty", "is_method": true, "class_name": "SomePrice", "function_description": "Compares two Price objects and determines if the current price is greater than or equal to another, ensuring both prices use the same currency and handling undefined values appropriately."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_ccy", "line_number": 1240, "body": "def with_ccy(self, ccy: Currency) -> \"Price\":\n        return SomePrice(ccy, self[1], self[2])", "is_method": true, "class_name": "SomePrice", "function_description": "Returns a new SomePrice instance with the specified currency, preserving the original price values. This enables easy currency updates without altering other price components."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_qty", "line_number": 1243, "body": "def with_qty(self, qty: Decimal) -> \"Price\":\n        return SomePrice(self[0], qty, self[2])", "is_method": true, "class_name": "SomePrice", "function_description": "Creates a new Price instance from the current one but with a specified quantity, facilitating operations that require price adjustments based on quantity."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_dov", "line_number": 1246, "body": "def with_dov(self, dov: Date) -> \"Price\":\n        return SomePrice(self[0], self[1], dov)", "is_method": true, "class_name": "SomePrice", "function_description": "Creates a new SomePrice instance with the specified date of value while preserving the original price attributes. Useful for updating the date without altering price details."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "convert", "line_number": 1249, "body": "def convert(self, to: Currency, asof: Optional[Date] = None, strict: bool = False) -> \"Price\":\n        ## Get slots:\n        ccy, qty, dov = self\n\n        ## Get date of conversion:\n        asof = asof or dov\n\n        ## Attempt to get the FX rate:\n        try:\n            rate = FXRateService.default.query(ccy, to, asof, strict)  # type: ignore\n        except AttributeError as exc:\n            if FXRateService.default is None:\n                raise ProgrammingError(\"Did you implement and set the default FX rate service?\")\n            else:\n                raise exc\n\n        ## Do we have a rate?\n        if rate is None:\n            ## Nope, shall we raise exception?\n            if strict:\n                ## Yep:\n                raise FXRateLookupError(ccy, to, asof)\n            else:\n                ## Just return NA:\n                return NoPrice\n\n        ## Compute and return:\n        return SomePrice(to, qty * rate.value, asof)", "is_method": true, "class_name": "SomePrice", "function_description": "Core method of the SomePrice class that converts a price from one currency to another using an FX rate on a specified date, optionally enforcing strict rate availability or returning a no-price indicator."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "money", "line_number": 1279, "body": "def money(self) -> Money:\n        c, q, d = self\n        return SomeMoney(c, q.quantize(c.quantizer), d)", "is_method": true, "class_name": "SomePrice", "function_description": "Returns a standardized monetary value by quantizing the quantity according to the currency's rules, facilitating precise financial calculations within the SomePrice context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_boolean", "line_number": 1324, "body": "def as_boolean(self) -> bool:\n        return False", "is_method": true, "class_name": "NonePrice", "function_description": "This function consistently returns False, providing a boolean representation for the object. It can be used to define a falsy behavior in boolean contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "is_equal", "line_number": 1327, "body": "def is_equal(self, other: Any) -> bool:\n        return other.__class__ is NonePrice", "is_method": true, "class_name": "NonePrice", "function_description": "Utility method that checks if another object is an instance of the NonePrice class, supporting identity comparison based on class type."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "abs", "line_number": 1330, "body": "def abs(self) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the same Price instance without modification, effectively providing an absolute value method that does not alter the object."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_float", "line_number": 1333, "body": "def as_float(self) -> float:\n        raise TypeError(\"Undefined monetary values do not have quantity information.\")", "is_method": true, "class_name": "NonePrice", "function_description": "This function raises an error when attempting to represent an undefined monetary value as a float, indicating such values lack quantity information. It prevents invalid numerical conversions in monetary computations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "as_integer", "line_number": 1336, "body": "def as_integer(self) -> int:\n        raise TypeError(\"Undefined monetary values do not have quantity information.\")", "is_method": true, "class_name": "NonePrice", "function_description": "Raises an error when attempting to convert undefined monetary values to an integer, signaling the absence of quantity information. This enforces that non-specific price representations cannot be quantified."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "round", "line_number": 1339, "body": "def round(self, ndigits: int = 0) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the current Price instance unchanged, ignoring any rounding request. This method preserves the original price value without modification."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "negative", "line_number": 1342, "body": "def negative(self) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the current Price instance without modification, effectively representing its negative value as itself. This method provides a consistent interface for retrieving the negation of a price where applicable."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "positive", "line_number": 1345, "body": "def positive(self) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the current Price instance unchanged, effectively serving as a placeholder or identity method within the NonePrice context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "add", "line_number": 1348, "body": "def add(self, other: \"Price\") -> \"Price\":\n        return other", "is_method": true, "class_name": "NonePrice", "function_description": "This method returns the given Price object without modification, effectively bypassing any addition logic. It provides a placeholder or trivial implementation for adding Price instances."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "scalar_add", "line_number": 1351, "body": "def scalar_add(self, other: Numeric) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the current Price instance without modification regardless of the input, effectively ignoring addition operations. It provides a no-op behavior for scalar addition on Price objects."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "subtract", "line_number": 1354, "body": "def subtract(self, other: \"Price\") -> \"Price\":\n        return -other", "is_method": true, "class_name": "NonePrice", "function_description": "Performs subtraction by returning the negation of another Price instance, enabling arithmetic operations in the Price context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "scalar_subtract", "line_number": 1357, "body": "def scalar_subtract(self, other: Numeric) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the current Price instance unchanged, effectively ignoring any subtraction operation with a numeric value. This may act as a placeholder or represent prices that do not change with subtraction."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "multiply", "line_number": 1360, "body": "def multiply(self, other: Numeric) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the same Price instance, effectively ignoring multiplication. This method likely serves as a placeholder or a no-op in price calculations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "times", "line_number": 1363, "body": "def times(self, other: Numeric) -> \"Money\":\n        return NoMoney", "is_method": true, "class_name": "NonePrice", "function_description": "Returns a constant \"NoMoney\" value regardless of the input, effectively representing a zero or null monetary amount in multiplication operations. This can be used to handle cases where no monetary value should be produced."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "divide", "line_number": 1366, "body": "def divide(self, other: Numeric) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the current Price object unchanged regardless of the division operation requested. This method likely serves as a placeholder or default implementation for division involving Price instances."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "floor_divide", "line_number": 1369, "body": "def floor_divide(self, other: Numeric) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the current instance of Price without performing any division, effectively acting as a placeholder or no-op for floor division operations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "lt", "line_number": 1372, "body": "def lt(self, other: \"Price\") -> bool:\n        return other.defined", "is_method": true, "class_name": "NonePrice", "function_description": "Compares this price to another by checking if the other price is defined, serving as a basic comparison operator that determines ordering based on definition status."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "lte", "line_number": 1375, "body": "def lte(self, other: \"Price\") -> bool:\n        return True", "is_method": true, "class_name": "NonePrice", "function_description": "This function always returns True when comparing if one price is less than or equal to another, effectively overriding any real comparison logic. Its intended use or logic is unclear given the constant return value."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "gt", "line_number": 1378, "body": "def gt(self, other: \"Price\") -> bool:\n        return False", "is_method": true, "class_name": "NonePrice", "function_description": "This method consistently indicates that the current price is not greater than any other Price instance, effectively disabling greater-than comparisons. It serves as a fixed comparison rule within the NonePrice context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "gte", "line_number": 1381, "body": "def gte(self, other: \"Price\") -> bool:\n        return other.undefined", "is_method": true, "class_name": "NonePrice", "function_description": "Compares two Price objects by returning True if the other Price is undefined, indicating a comparison rule based on undefined pricing."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_ccy", "line_number": 1384, "body": "def with_ccy(self, ccy: Currency) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "The function returns the current Price instance unchanged, likely ignoring the provided currency parameter. It may support interface consistency without altering the price."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_qty", "line_number": 1387, "body": "def with_qty(self, qty: Decimal) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the current Price instance unchanged, regardless of the quantity provided. This function may serve as a placeholder or default implementation for quantity-specific price adjustments."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "with_dov", "line_number": 1390, "body": "def with_dov(self, dov: Date) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the current Price instance unchanged, ignoring the provided date parameter. This may serve as a placeholder or default behavior in the NonePrice context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/monetary.py", "function": "convert", "line_number": 1393, "body": "def convert(self, to: Currency, asof: Optional[Date] = None, strict: bool = False) -> \"Price\":\n        return self", "is_method": true, "class_name": "NonePrice", "function_description": "Returns the current price instance without any conversion, effectively serving as a no-op placeholder in currency conversion contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "__lt__", "line_number": 108, "body": "def __lt__(self, other: \"AccountType\") -> bool:\n        \"\"\"\n        Provides a comparison for account type enums.\n        \"\"\"\n        ## Provides the order of enums:\n        order: Dict[\"AccountType\", int] = {\n            AccountType.ASSETS: 0,\n            AccountType.LIABILITIES: 1,\n            AccountType.EQUITIES: 2,\n            AccountType.REVENUES: 3,\n            AccountType.EXPENSES: 4,\n        }\n\n        ## Compare and return the order of enums:\n        return order[self] < order[other]", "is_method": true, "class_name": "AccountType", "function_description": "Provides a way to compare AccountType enum members by defining a custom order used to determine their relative ranking. This supports sorting or ordering of account types consistently in financial contexts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "code", "line_number": 133, "body": "def code(self) -> Code:\n        \"\"\"\n        Code of the account.\n        \"\"\"\n        ...", "is_method": true, "class_name": "Account", "function_description": "Returns the unique code associated with the account. This method provides a simple way to access the account's identifying code within the Account class."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "parent", "line_number": 165, "body": "def parent(self) -> Optional[\"Account\"]:\n        \"\"\"\n        Parent of the account, if any.\n        \"\"\"\n        ...", "is_method": true, "class_name": "Account", "function_description": "Returns the parent account of the current account if it exists, supporting hierarchical account structures and navigation."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "parent", "line_number": 191, "body": "def parent(self) -> Optional[\"Account\"]:\n        \"\"\"\n        Parent account.\n        \"\"\"\n        ## I wish I could do `parent: ClassVar[Optional[\"Account\"]] = None` instead!\n        return None", "is_method": true, "class_name": "RootAccount", "function_description": "Returns the parent account of the current RootAccount, if any. Currently, always returns None since RootAccount has no parent."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "type", "line_number": 215, "body": "def type(self) -> AccountType:\n        \"\"\"\n        Type of the account.\n        \"\"\"\n        return self.parent.type", "is_method": true, "class_name": "SubAccount", "function_description": "Returns the account type by referencing its parent account, providing access to the account classification within a SubAccount context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "coa", "line_number": 222, "body": "def coa(self) -> \"COA\":\n        \"\"\"\n        Chart of accounts the account belongs to.\n        \"\"\"\n        return self.parent.coa", "is_method": true, "class_name": "SubAccount", "function_description": "Returns the chart of accounts associated with this sub-account by accessing its parent account, enabling hierarchical financial account organization and reference."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "__post_init__", "line_number": 256, "body": "def __post_init__(self, rootspec: Optional[Dict[AccountType, Tuple[Code, str]]]) -> None:\n        \"\"\"\n        Initializes the root accounts buffer.\n        \"\"\"\n        ## Do we have a rootspec?\n        rootspec = rootspec or {}\n\n        ## Iterate over account types and initialize root accounts:\n        for c, t in enumerate(AccountType, start=1):\n            ## Attempt to get or initialize code/name tuple for the type:\n            code, name = rootspec.get(t, (Code(str(c)), t.name.capitalize()))\n\n            ## Create the account and add to the buffer:\n            self._accounts[code] = RootAccount(code, name, t, self)", "is_method": true, "class_name": "COA", "function_description": "Initializes root account entries based on a provided specification or default values, setting up the foundational structure of accounts within the COA class. This enables consistent management of root accounts by type."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "__iter__", "line_number": 271, "body": "def __iter__(self) -> Iterator[Tuple[Code, Account]]:\n        \"\"\"\n        Returns an iterable of account code and account tuples.\n        \"\"\"\n        return ((c, a) for c, a in self._accounts.items())", "is_method": true, "class_name": "COA", "function_description": "Provides an iterator over all account code and account pairs in the COA class, enabling easy traversal of its stored accounts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "accounts", "line_number": 278, "body": "def accounts(self) -> Iterable[Account]:\n        \"\"\"\n        All accounts of the chart of accounts.\n        \"\"\"\n        return iter(self._accounts.values())", "is_method": true, "class_name": "COA", "function_description": "Utility method of the COA class that provides an iterable over all accounts in the chart of accounts, enabling access to the complete set of account objects."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "toplevel", "line_number": 285, "body": "def toplevel(self) -> Iterable[Account]:\n        \"\"\"\n        Top-level accounts (balance sheet and income statement accounts) of the chart of accounts.\n        \"\"\"\n        return (a for a in self.accounts if a.parent is None)", "is_method": true, "class_name": "COA", "function_description": "Returns all top-level accounts in the chart of accounts, filtering those without a parent. Useful for accessing primary balance sheet and income statement accounts directly."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "structure", "line_number": 292, "body": "def structure(self) -> Iterable[\"COA.Node\"]:\n        \"\"\"\n        Tree-like structure of the chart of accounts.\n        \"\"\"\n        return map(self.nodify, self.toplevel)", "is_method": true, "class_name": "COA", "function_description": "Returns an iterable representing the chart of accounts as a tree structure, providing access to its top-level nodes for hierarchical processing or traversal."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "find", "line_number": 298, "body": "def find(self, code: Code) -> Optional[Account]:\n        \"\"\"\n        Attempts to find and return the account by the given code.\n\n        :param code: Code of the account we want to retrieve.\n        :return: :py:class:`Account` identified by the given code if found, ``None`` otherwise.\n        \"\"\"\n        return self._accounts.get(code, None)", "is_method": true, "class_name": "COA", "function_description": "Core method of the COA class that retrieves an Account object by its code, returning None if no matching account exists. It enables quick lookup of accounts within the chart of accounts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "subaccounts", "line_number": 307, "body": "def subaccounts(self, account: Account) -> List[Account]:\n        \"\"\"\n        Attempts to find and return sub-accounts of the given account.\n\n        :param account: Account we want to retrieve sub-accounts of.\n        :return: List of sub-accounts.\n        \"\"\"\n        return self._subaccounts.get(account, [])", "is_method": true, "class_name": "COA", "function_description": "Returns the list of sub-accounts associated with a given account, enabling hierarchical account management and retrieval within the COA context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "nodify", "line_number": 316, "body": "def nodify(self, account: Account) -> \"COA.Node\":\n        \"\"\"\n        Compiles a :py:class:`Node` instance for the given account.\n\n        :param account: Account we want to compile the :py:class:`Node` for.\n        :return: Account :py:class:`Node` within the chart of accounts.\n        \"\"\"\n        return self.Node(account, [self.nodify(a) for a in self.subaccounts(account)])", "is_method": true, "class_name": "COA", "function_description": "Provides a hierarchical Node representation of an account and its subaccounts within the chart of accounts, enabling structured traversal or manipulation of account relationships."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "add", "line_number": 325, "body": "def add(self, parent: Code, code: Code, name: str) -> Account:\n        \"\"\"\n        Attempts to add a new account to the chart of accounts.\n\n        :param parent: Code of the parent account.\n        :param code: Account code.\n        :param name: Account name.\n        :return: Newly created account (or existing one).\n        \"\"\"\n        ## Check if parent and code are same:\n        if parent == code:\n            raise ValueError(\"An account can not be the parent of itself.\")\n\n        ## Attempt to get the parent instance:\n        parentinstance = self._accounts.get(parent)\n\n        ## Check if we have a parent instance:\n        if parentinstance is None:\n            raise ValueError(\"Parent account is not (yet) defined.\")\n\n        ## Check if we already have an account:\n        if code in self._accounts:\n            ## Get the account:\n            account = self._accounts[code]\n\n            ## Check account information is consistent:\n            if account.parent == parentinstance and account.name == name and account.code == code:\n                return account\n            else:\n                raise ValueError(\"Account name, code and parent do not match existing chart of accounts member.\")\n\n        ## Create the account:\n        account = SubAccount(code, name, self._accounts[parent])\n\n        ## Add to the COA:\n        self._accounts[code] = account\n\n        ## Add the account to children buffer:\n        if account.parent not in self._subaccounts:\n            self._subaccounts[account.parent] = []\n        self._subaccounts[account.parent].append(account)\n\n        ## Done, return the new account:\n        return account", "is_method": true, "class_name": "COA", "function_description": "Utility method of the COA class that adds a new account under a specified parent in the chart of accounts, ensuring hierarchical integrity and preventing duplicates with conflicting details."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "print", "line_number": 370, "body": "def print(self) -> None:\n        \"\"\"\n        Prints the chart of accounts in a tree-like form.\n\n        :param coa: Chart of accounts to print.\n        \"\"\"\n        for tree in self.structure:\n            self._print_node(tree, 0)", "is_method": true, "class_name": "COA", "function_description": "Method of the COA class that prints the chart of accounts as a tree structure, providing a clear hierarchical view of account organization for easy understanding and inspection."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/accounts.py", "function": "_print_node", "line_number": 380, "body": "def _print_node(cls, node: \"COA.Node\", level: int = 0) -> None:\n        \"\"\"\n        Prints a node.\n\n        This is an auxiliary function to :py:func:`print_coa`.\n\n        :param node: Node to print.\n        :param level: Level to print node at.\n        \"\"\"\n        print(f\"{''.join(['    '] * level)}[{node.account.code}] {node.account.name}\")\n        for c in node.children:\n            cls._print_node(c, level + 1)", "is_method": true, "class_name": "COA", "function_description": "Auxiliary method of the COA class that recursively prints a hierarchical node and its children with indentation reflecting their depth, supporting structured visualization of the chart of accounts."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "build_general_ledger", "line_number": 162, "body": "def build_general_ledger(\n    period: DateRange, journal: Iterable[JournalEntry[_T]], initial: InitialBalances\n) -> GeneralLedger[_T]:\n    \"\"\"\n    Builds a general ledger.\n\n    :param period: Accounting period.\n    :param journal: All available journal entries.\n    :param initial: Opening balances for terminal accounts, if any.\n    :return: A :py:class:`GeneralLedger` instance.\n    \"\"\"\n    ## Initialize ledgers buffer as per available initial balances:\n    ledgers: Dict[Account, Ledger[_T]] = {a: Ledger(a, b) for a, b in initial.items()}\n\n    ## Iterate over journal postings and populate ledgers:\n    for posting in (p for j in journal for p in j.postings if period.since <= j.date <= period.until):\n        ## Check if we have the ledger yet, and create if not:\n        if posting.account not in ledgers:\n            ledgers[posting.account] = Ledger(posting.account, Balance(period.since, Quantity(Decimal(0))))\n\n        ## Add the posting to the ledger:\n        ledgers[posting.account].add(posting)\n\n    ## Done, return general ledger.\n    return GeneralLedger(period, ledgers)", "is_method": false, "function_description": "Builds a general ledger summarizing account balances and postings within a given period, starting from initial balances. It consolidates journal entries into ledger accounts, facilitating financial reporting and analysis for the specified timeframe."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "compile_general_ledger_program", "line_number": 207, "body": "def compile_general_ledger_program(\n    read_initial_balances: ReadInitialBalances,\n    read_journal_entries: ReadJournalEntries[_T],\n) -> GeneralLedgerProgram[_T]:\n    \"\"\"\n    Consumes implementations of the algebra and returns a program which consumes opening and closing dates and produces\n    a general ledger.\n\n    :param read_initial_balances: Algebra implementation which reads initial balances.\n    :param read_journal_entries: Algebra implementation which reads journal entries.\n    :return: A function which consumes opening and closing dates and produces a general ledger\n    \"\"\"\n\n    def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)\n\n    ## Return the compiled program.\n    return _program", "is_method": false, "function_description": "Provides a function that, given implementations to read initial balances and journal entries, returns a general ledger generator which produces a ledger for any specified accounting period. It enables customizable ledger compilation based on different data sources."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "date", "line_number": 51, "body": "def date(self) -> datetime.date:\n        \"\"\"\n        Date of the ledger entry.\n        \"\"\"\n        return self.posting.date", "is_method": true, "class_name": "LedgerEntry", "function_description": "Returns the posting date associated with the ledger entry, allowing other components to access the entry's transaction date for record-keeping or financial computations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "description", "line_number": 58, "body": "def description(self) -> str:\n        \"\"\"\n        Description of the ledger entry.\n        \"\"\"\n        return self.posting.journal.description", "is_method": true, "class_name": "LedgerEntry", "function_description": "Returns the description of the journal associated with the ledger entry, providing a textual summary useful for understanding the entry\u2019s context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "amount", "line_number": 65, "body": "def amount(self) -> Amount:\n        \"\"\"\n        Amount of the ledger entry.\n        \"\"\"\n        return self.posting.amount", "is_method": true, "class_name": "LedgerEntry", "function_description": "Returns the monetary amount associated with the ledger entry, providing access to the financial value recorded in its posting."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "cntraccts", "line_number": 72, "body": "def cntraccts(self) -> List[Account]:\n        \"\"\"\n        Counter accounts for the ledger entry.\n        \"\"\"\n        return [p.account for p in self.posting.journal.postings if p.direction != self.posting.direction]", "is_method": true, "class_name": "LedgerEntry", "function_description": "Returns the list of accounts involved in postings that have the opposite direction to the current ledger entry, enabling identification of counterparty accounts for transaction balancing."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "is_debit", "line_number": 79, "body": "def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a debit.\n        \"\"\"\n        return self.posting.is_debit", "is_method": true, "class_name": "LedgerEntry", "function_description": "Returns whether the ledger entry represents a debit transaction, supporting financial record classification and accounting operations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "is_credit", "line_number": 86, "body": "def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if the ledger entry is a credit.\n        \"\"\"\n        return self.posting.is_credit", "is_method": true, "class_name": "LedgerEntry", "function_description": "Utility method in LedgerEntry that indicates whether the entry represents a credit transaction, facilitating transaction type checks in financial records."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "debit", "line_number": 93, "body": "def debit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the debit amount, if any.\n        \"\"\"\n        return self.amount if self.is_debit else None", "is_method": true, "class_name": "LedgerEntry", "function_description": "Returns the debit amount of the ledger entry if it exists; otherwise, returns None. This method helps distinguish debit transactions within financial records."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "credit", "line_number": 100, "body": "def credit(self) -> Optional[Amount]:\n        \"\"\"\n        Returns the credit amount, if any.\n        \"\"\"\n        return self.amount if self.is_credit else None", "is_method": true, "class_name": "LedgerEntry", "function_description": "Returns the credit amount of the ledger entry if it represents a credit transaction; otherwise, returns None. Useful for distinguishing credit entries in financial records."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "_last_balance", "line_number": 123, "body": "def _last_balance(self) -> Quantity:\n        \"\"\"\n        Returns the last balance.\n        \"\"\"\n        try:\n            return self.entries[-1].balance\n        except IndexError:\n            return self.initial.value", "is_method": true, "class_name": "Ledger", "function_description": "Utility method of the Ledger class that returns the most recent balance from ledger entries or the initial value if no entries exist. It supports balance retrieval for accurate financial tracking or calculations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "add", "line_number": 132, "body": "def add(self, posting: Posting[_T]) -> LedgerEntry[_T]:\n        \"\"\"\n        Adds a new ledger entry.\n\n        :param posting: Posting the ledger entry is based on.\n        :return: The new ledger entry.\n        \"\"\"\n        ## Create the ledger entry.\n        entry = LedgerEntry(self, posting, Quantity(self._last_balance + posting.amount * posting.direction.value))\n\n        ## Add to the buffer:\n        self.entries.append(entry)\n\n        ## Done, return:\n        return entry", "is_method": true, "class_name": "Ledger", "function_description": "Adds a new ledger entry based on a given posting, updating the ledger's balance and storing the entry. This function supports tracking sequential financial transactions within the Ledger."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/ledger.py", "function": "_program", "line_number": 220, "body": "def _program(period: DateRange) -> GeneralLedger[_T]:\n        \"\"\"\n        Consumes the opening and closing dates and produces a general ledger.\n\n        :param period: Accounting period.\n        :return: A general ledger.\n        \"\"\"\n        ## Get initial balances as of the end of previous financial period:\n        initial_balances = read_initial_balances(period)\n\n        ## Read journal entries and post each of them:\n        journal_entries = read_journal_entries(period)\n\n        ## Build the general ledger and return:\n        return build_general_ledger(period, journal_entries, initial_balances)", "is_method": false, "function_description": "Produces a general ledger for a specified accounting period by aggregating initial balances and journal entries. This function supports financial reporting and accounting workflows requiring period-based ledger generation."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/journaling.py", "function": "of", "line_number": 41, "body": "def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC", "is_method": true, "class_name": "Direction", "function_description": "Determines the directional sign (increment or decrement) of a non-zero quantity, raising an error if zero. Useful for interpreting quantity changes or trends within the Direction context."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/journaling.py", "function": "is_debit", "line_number": 82, "body": "def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]", "is_method": true, "class_name": "Posting", "function_description": "Determines whether the posting represents a debit transaction based on its account type and direction. Useful for financial processing to classify postings by transaction nature."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/journaling.py", "function": "is_credit", "line_number": 89, "body": "def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit", "is_method": true, "class_name": "Posting", "function_description": "Returns whether the posting represents a credit transaction, distinguishing it from a debit. This method helps classify financial entries by their type for transaction processing."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/journaling.py", "function": "increments", "line_number": 118, "body": "def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)", "is_method": true, "class_name": "JournalEntry", "function_description": "Returns all postings in the journal entry that represent increment events. This enables filtering and processing of only increment-type postings within the entry."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/journaling.py", "function": "decrements", "line_number": 125, "body": "def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)", "is_method": true, "class_name": "JournalEntry", "function_description": "Method of JournalEntry that provides an iterable of all postings representing decrement events within the journal entry. It enables filtering relevant transactions based on their decrement direction for further processing or analysis."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/journaling.py", "function": "debits", "line_number": 132, "body": "def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)", "is_method": true, "class_name": "JournalEntry", "function_description": "Returns all debit postings from the journal entry, providing an iterable of postings classified as debits for financial transaction processing or accounting analysis."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/journaling.py", "function": "credits", "line_number": 139, "body": "def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)", "is_method": true, "class_name": "JournalEntry", "function_description": "Returns all credit postings within the journal entry, providing access to entries categorized as credits for financial transaction processing and analysis."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/journaling.py", "function": "post", "line_number": 145, "body": "def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self", "is_method": true, "class_name": "JournalEntry", "function_description": "Utility method of the JournalEntry class that records a positive or negative amount to a specified account on a given date, enabling accurate tracking of incremental financial events."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/accounting/journaling.py", "function": "validate", "line_number": 160, "body": "def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"", "is_method": true, "class_name": "JournalEntry", "function_description": "Ensures a JournalEntry instance is balanced by verifying total debits equal total credits, raising an error if inconsistencies exist. This validation supports accurate accounting recordkeeping."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/commons/errors.py", "function": "passert", "line_number": 19, "body": "def passert(cls, condition: bool, message: Optional[str]) -> None:\n        \"\"\"\n        Raises a :py:class:`ProgrammingError` if the condition is ``False``.\n\n        :param condition: Indicates if the expectation is fulfilled.\n        :param message: Message of the error to be raised in case that the condition is not met.\n        :raises ProgrammingError: In case that the condition is ``False``.\n        \"\"\"\n        if not condition:\n            raise cls(message or \"Broken coherence. Check your code against domain logic to fix it.\")", "is_method": true, "class_name": "ProgrammingError", "function_description": "Static method of the ProgrammingError class that enforces domain logic by raising a ProgrammingError when a given condition is not met, helping to catch programming inconsistencies early."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/commons/others.py", "function": "makeguid", "line_number": 14, "body": "def makeguid() -> Guid:\n    \"\"\"\n    Creates a new :py:class:`Guid`.\n\n    :return: :py:class:`Guid` instance.\n    \"\"\"\n    return Guid(uuid4().hex)", "is_method": false, "function_description": "Function that generates and returns a new unique Guid instance. It provides a convenient way to create globally unique identifiers for use in identification or tracking tasks."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/commons/others.py", "function": "identity", "line_number": 27, "body": "def identity(x: _T) -> _T:\n    \"\"\"\n    Provides the identity function.\n\n    :param x: Any value of the generic type.\n    :return: The value consumed.\n    \"\"\"\n    return x", "is_method": false, "function_description": "Generic utility function that returns its input unchanged, useful for default behaviors or function composition when no transformation is needed."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/commons/numbers.py", "function": "make_quantizer", "line_number": 53, "body": "def make_quantizer(precision: int) -> Decimal:\n    \"\"\"\n    Creates a quantifier as per the given precision.\n    \"\"\"\n    return Decimal(f\"0.{''.join(['0' * precision])}\")", "is_method": false, "function_description": "This function generates a Decimal quantizer with the specified number of decimal places, useful for consistent rounding or precision control in numerical calculations."}, {"file": "./dataset/RepoExec/test-apps/pypara/pypara/commons/numbers.py", "function": "isum", "line_number": 67, "body": "def isum(xs: Iterable[DecimalLike], start: Optional[DecimalLike] = None) -> DecimalLike:\n    \"\"\"\n    Computes the sum of an iterable of :py:class:`DecimalLike` values such as :py:class:`Amount` or\n    :py:class:`Quantity` including :py:class:`Decimal` itself.\n\n    The return type is the same as the input element type. The base condition is :py:const:`ZERO` of\n    :py:class:`decimal.Decimal` type but cast to the type variable if required.\n\n    :param xs: An iterable of :py:class:`Decimal`-like values.\n    :param start: Optional initial value. This defaults to :py:const:`ZERO` in the implementation.\n    :return: Sum of the elements in the same type as the elements in the argument.\n\n    >>> isum([Amount(ONE), Amount(ONE)])  # Return value is of type `Amount` during type-checking.\n    Decimal('2')\n    >>> isum([Quantity(ONE), Quantity(ONE)])  # Return value is of type `Quantity` during type-checking.\n    Decimal('2')\n    >>> isum([Amount(ONE), Amount(ONE)], Amount(ONE))  # Return value is of type `Amount` during type-checking.\n    Decimal('3')\n    >>> isum([Quantity(ONE), Quantity(ONE)], Quantity(ONE))  # Return value is of type `Quantity` during type-checking.\n    Decimal('3')\n    \"\"\"\n    return sum(xs, start or cast(DecimalLike, ZERO))", "is_method": false, "function_description": "Utility function that sums an iterable of Decimal-like values, returning the result in the same type. It supports optional initial values, making it useful for aggregating amounts or quantities consistently."}]