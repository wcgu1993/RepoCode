[{"file": "./dataset/RepoExec/test-apps/httpie/setup.py", "function": "long_description", "line_number": 67, "body": "def long_description():\n    with codecs.open('README.rst', encoding='utf8') as f:\n        return f.read()", "is_method": false, "function_description": "Reads and returns the entire content of a UTF-8 encoded README.rst file as a string. Useful for loading detailed project descriptions or documentation text."}, {"file": "./dataset/RepoExec/test-apps/httpie/setup.py", "function": "finalize_options", "line_number": 19, "body": "def finalize_options(self):\n        TestCommand.finalize_options(self)\n        self.test_args = [\n            '--doctest-modules',\n            '--verbose',\n            './httpie',\n            './tests',\n        ]\n        self.test_suite = True", "is_method": true, "class_name": "PyTest", "function_description": "Sets up default test arguments and marks the test suite as active, configuring the test command to run doctests and verbose tests in specified directories for the PyTest class."}, {"file": "./dataset/RepoExec/test-apps/httpie/setup.py", "function": "run_tests", "line_number": 29, "body": "def run_tests(self):\n        import pytest\n        sys.exit(pytest.main(self.test_args))", "is_method": true, "class_name": "PyTest", "function_description": "Runs pytest with specified arguments and exits the program with the test results, enabling automated test execution within the PyTest class context."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/uploads.py", "function": "prepare_request_body", "line_number": 37, "body": "def prepare_request_body(\n    body: Union[str, bytes, IO, MultipartEncoder, RequestDataDict],\n    body_read_callback: Callable[[bytes], bytes],\n    content_length_header_value: int = None,\n    chunked=False,\n    offline=False,\n) -> Union[str, bytes, IO, MultipartEncoder, ChunkedUploadStream]:\n\n    is_file_like = hasattr(body, 'read')\n\n    if isinstance(body, RequestDataDict):\n        body = urlencode(body, doseq=True)\n\n    if offline:\n        if is_file_like:\n            return body.read()\n        return body\n\n    if not is_file_like:\n        if chunked:\n            body = ChunkedUploadStream(\n                # Pass the entire body as one chunk.\n                stream=(chunk.encode() for chunk in [body]),\n                callback=body_read_callback,\n            )\n    else:\n        # File-like object.\n\n        if not super_len(body):\n            # Zero-length -> assume stdin.\n            if content_length_header_value is None and not chunked:\n                #\n                # Read the whole stdin to determine `Content-Length`.\n                #\n                # TODO: Instead of opt-in --chunked, consider making\n                #   `Transfer-Encoding: chunked` for STDIN opt-out via\n                #   something like --no-chunked.\n                #   This would be backwards-incompatible so wait until v3.0.0.\n                #\n                body = body.read()\n        else:\n            orig_read = body.read\n\n            def new_read(*args):\n                chunk = orig_read(*args)\n                body_read_callback(chunk)\n                return chunk\n\n            body.read = new_read\n\n        if chunked:\n            if isinstance(body, MultipartEncoder):\n                body = ChunkedMultipartUploadStream(\n                    encoder=body,\n                )\n            else:\n                body = ChunkedUploadStream(\n                    stream=body,\n                    callback=body_read_callback,\n                )\n\n    return body", "is_method": false, "function_description": "Function that processes various types of request bodies, adapting them for streaming, chunked uploads, or offline mode while applying read callbacks and encoding as needed for HTTP requests. It enables flexible preparation of request payloads for diverse network communication scenarios."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/uploads.py", "function": "get_multipart_data_and_content_type", "line_number": 101, "body": "def get_multipart_data_and_content_type(\n    data: MultipartRequestDataDict,\n    boundary: str = None,\n    content_type: str = None,\n) -> Tuple[MultipartEncoder, str]:\n    encoder = MultipartEncoder(\n        fields=data.items(),\n        boundary=boundary,\n    )\n    if content_type:\n        content_type = content_type.strip()\n        if 'boundary=' not in content_type:\n            content_type = f'{content_type}; boundary={encoder.boundary_value}'\n    else:\n        content_type = encoder.content_type\n\n    data = encoder\n    return data, content_type", "is_method": false, "function_description": "Utility function that encodes multipart form data with an optional boundary and returns both the encoded data and the appropriate Content-Type header for HTTP requests. It simplifies preparing multipart payloads for network communication."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/uploads.py", "function": "compress_request", "line_number": 121, "body": "def compress_request(\n    request: requests.PreparedRequest,\n    always: bool,\n):\n    deflater = zlib.compressobj()\n    if isinstance(request.body, str):\n        body_bytes = request.body.encode()\n    elif hasattr(request.body, 'read'):\n        body_bytes = request.body.read()\n    else:\n        body_bytes = request.body\n    deflated_data = deflater.compress(body_bytes)\n    deflated_data += deflater.flush()\n    is_economical = len(deflated_data) < len(body_bytes)\n    if is_economical or always:\n        request.body = deflated_data\n        request.headers['Content-Encoding'] = 'deflate'\n        request.headers['Content-Length'] = str(len(deflated_data))", "is_method": false, "function_description": "Function that compresses the body of an HTTP request using deflate encoding when compression reduces size or when forced, updating the request headers accordingly to indicate compressed content. It helps optimize network transmission by reducing request payload size."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/uploads.py", "function": "__iter__", "line_number": 17, "body": "def __iter__(self) -> Iterable[Union[str, bytes]]:\n        for chunk in self.stream:\n            self.callback(chunk)\n            yield chunk", "is_method": true, "class_name": "ChunkedUploadStream", "function_description": "This iterator method yields data chunks from a stream, invoking a callback on each chunk to enable monitoring or processing during iteration. It supports chunk-wise handling in streaming data workflows."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/uploads.py", "function": "__iter__", "line_number": 29, "body": "def __iter__(self) -> Iterable[Union[str, bytes]]:\n        while True:\n            chunk = self.encoder.read(self.chunk_size)\n            if not chunk:\n                break\n            yield chunk", "is_method": true, "class_name": "ChunkedMultipartUploadStream", "function_description": "Provides an iterator that yields data chunks of a specified size from an encoded stream, facilitating efficient multipart upload handling in manageable pieces."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/sessions.py", "function": "get_httpie_session", "line_number": 30, "body": "def get_httpie_session(\n    config_dir: Path,\n    session_name: str,\n    host: Optional[str],\n    url: str,\n) -> 'Session':\n    if os.path.sep in session_name:\n        path = os.path.expanduser(session_name)\n    else:\n        hostname = host or urlsplit(url).netloc.split('@')[-1]\n        if not hostname:\n            # HACK/FIXME: httpie-unixsocket's URLs have no hostname.\n            hostname = 'localhost'\n\n        # host:port => host_port\n        hostname = hostname.replace(':', '_')\n        path = (\n            config_dir / SESSIONS_DIR_NAME / hostname / f'{session_name}.json'\n        )\n    session = Session(path)\n    session.load()\n    return session", "is_method": false, "function_description": "Utility function that loads an HTTPie session from a configuration directory based on session name and host or URL, enabling reuse of saved HTTP session data for subsequent requests."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/sessions.py", "function": "update_headers", "line_number": 68, "body": "def update_headers(self, request_headers: RequestHeadersDict):\n        \"\"\"\n        Update the session headers with the request ones while ignoring\n        certain name prefixes.\n\n        \"\"\"\n        headers = self.headers\n        for name, value in request_headers.items():\n\n            if value is None:\n                continue  # Ignore explicitly unset headers\n\n            if type(value) is not str:\n                value = value.decode('utf8')\n\n            if name.lower() == 'user-agent' and value.startswith('HTTPie/'):\n                continue\n\n            if name.lower() == 'cookie':\n                for cookie_name, morsel in SimpleCookie(value).items():\n                    self['cookies'][cookie_name] = {'value': morsel.value}\n                del request_headers[name]\n                continue\n\n            for prefix in SESSION_IGNORED_HEADER_PREFIXES:\n                if name.lower().startswith(prefix.lower()):\n                    break\n            else:\n                headers[name] = value\n\n        self['headers'] = dict(headers)", "is_method": true, "class_name": "Session", "function_description": "Utility method of the Session class that updates session headers from a request while excluding headers with specific prefixes, handling cookies separately, and ignoring certain user-agent headers. It ensures relevant headers are merged without overwriting ignored ones."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/sessions.py", "function": "headers", "line_number": 101, "body": "def headers(self) -> RequestHeadersDict:\n        return RequestHeadersDict(self['headers'])", "is_method": true, "class_name": "Session", "function_description": "Returns the HTTP headers of the session as a RequestHeadersDict object, providing convenient access to session-specific header information."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/sessions.py", "function": "cookies", "line_number": 105, "body": "def cookies(self) -> RequestsCookieJar:\n        jar = RequestsCookieJar()\n        for name, cookie_dict in self['cookies'].items():\n            jar.set_cookie(create_cookie(\n                name, cookie_dict.pop('value'), **cookie_dict))\n        jar.clear_expired_cookies()\n        return jar", "is_method": true, "class_name": "Session", "function_description": "Returns a RequestsCookieJar containing all current session cookies, converting stored cookie data into a format compatible with HTTP requests and removing expired cookies."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/sessions.py", "function": "cookies", "line_number": 114, "body": "def cookies(self, jar: RequestsCookieJar):\n        # <https://docs.python.org/2/library/cookielib.html#cookie-objects>\n        stored_attrs = ['value', 'path', 'secure', 'expires']\n        self['cookies'] = {}\n        for cookie in jar:\n            self['cookies'][cookie.name] = {\n                attname: getattr(cookie, attname)\n                for attname in stored_attrs\n            }", "is_method": true, "class_name": "Session", "function_description": "Stores selected attributes of cookies from a RequestsCookieJar into the session\u2019s cookie dictionary, facilitating cookie management and access within the Session object."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/sessions.py", "function": "auth", "line_number": 125, "body": "def auth(self) -> Optional[AuthBase]:\n        auth = self.get('auth', None)\n        if not auth or not auth['type']:\n            return\n\n        plugin = plugin_manager.get_auth_plugin(auth['type'])()\n\n        credentials = {'username': None, 'password': None}\n        try:\n            # New style\n            plugin.raw_auth = auth['raw_auth']\n        except KeyError:\n            # Old style\n            credentials = {\n                'username': auth['username'],\n                'password': auth['password'],\n            }\n        else:\n            if plugin.auth_parse:\n                from httpie.cli.argtypes import parse_auth\n                parsed = parse_auth(plugin.raw_auth)\n                credentials = {\n                    'username': parsed.key,\n                    'password': parsed.value,\n                }\n\n        return plugin.get_auth(**credentials)", "is_method": true, "class_name": "Session", "function_description": "Provides an authentication object by extracting and processing stored credentials using a specified authentication plugin, supporting both legacy and modern credential formats for flexible session authentication."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/sessions.py", "function": "auth", "line_number": 154, "body": "def auth(self, auth: dict):\n        assert {'type', 'raw_auth'} == auth.keys()\n        self['auth'] = auth", "is_method": true, "class_name": "Session", "function_description": "Utility method of the Session class that stores authentication information after verifying required keys, supporting session management with user credentials."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/sessions.py", "function": "remove_cookies", "line_number": 158, "body": "def remove_cookies(self, names: Iterable[str]):\n        for name in names:\n            if name in self['cookies']:\n                del self['cookies'][name]", "is_method": true, "class_name": "Session", "function_description": "Removes specified cookies from the session's cookie storage. Useful for managing session state by deleting unwanted or expired cookies."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/models.py", "function": "content_type", "line_number": 35, "body": "def content_type(self) -> str:\n        \"\"\"Return the message content type.\"\"\"\n        ct = self._orig.headers.get('Content-Type', '')\n        if not isinstance(ct, str):\n            ct = ct.decode('utf8')\n        return ct", "is_method": true, "class_name": "HTTPMessage", "function_description": "Returns the content type header of the HTTP message as a string, providing the media type information of the message body for use in processing or handling HTTP communications."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/models.py", "function": "iter_body", "line_number": 46, "body": "def iter_body(self, chunk_size=1):\n        return self._orig.iter_content(chunk_size=chunk_size)", "is_method": true, "class_name": "HTTPResponse", "function_description": "Provides an iterator over the HTTP response body that yields data in chunks of a specified size, facilitating efficient streaming or processing of large response content."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/models.py", "function": "iter_lines", "line_number": 49, "body": "def iter_lines(self, chunk_size):\n        return ((line, b'\\n') for line in self._orig.iter_lines(chunk_size))", "is_method": true, "class_name": "HTTPResponse", "function_description": "Provides an iterator over the response content lines with specified chunk size, yielding each line paired with a newline delimiter. This supports efficient line-by-line processing of HTTP response data."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/models.py", "function": "headers", "line_number": 54, "body": "def headers(self):\n        original = self._orig.raw._original_response\n\n        version = {\n            9: '0.9',\n            10: '1.0',\n            11: '1.1',\n            20: '2',\n        }[original.version]\n\n        status_line = f'HTTP/{version} {original.status} {original.reason}'\n        headers = [status_line]\n        try:\n            # `original.msg` is a `http.client.HTTPMessage` on Python 3\n            # `_headers` is a 2-tuple\n            headers.extend(\n                '%s: %s' % header for header in original.msg._headers)\n        except AttributeError:\n            # and a `httplib.HTTPMessage` on Python 2.x\n            # `headers` is a list of `name: val<CRLF>`.\n            headers.extend(h.strip() for h in original.msg.headers)\n\n        return '\\r\\n'.join(headers)", "is_method": true, "class_name": "HTTPResponse", "function_description": "Returns the full HTTP response headers as a formatted string, including the status line and all header fields. This enables easy access to the raw headers for inspection or logging purposes."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/models.py", "function": "encoding", "line_number": 79, "body": "def encoding(self):\n        return self._orig.encoding or 'utf8'", "is_method": true, "class_name": "HTTPResponse", "function_description": "Returns the character encoding of the HTTP response, defaulting to 'utf8' if no encoding is specified. This helps consumers correctly interpret the response content."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/models.py", "function": "body", "line_number": 83, "body": "def body(self):\n        # Only now the response body is fetched.\n        # Shouldn't be touched unless the body is actually needed.\n        return self._orig.content", "is_method": true, "class_name": "HTTPResponse", "function_description": "Provides access to the HTTP response's content body, deferring retrieval until explicitly needed to optimize resource usage."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/models.py", "function": "iter_body", "line_number": 92, "body": "def iter_body(self, chunk_size):\n        yield self.body", "is_method": true, "class_name": "HTTPRequest", "function_description": "Returns the full HTTP request body as a single chunk, regardless of the specified chunk size. Useful for iterating over the request payload in a consistent manner."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/models.py", "function": "iter_lines", "line_number": 95, "body": "def iter_lines(self, chunk_size):\n        yield self.body, b''", "is_method": true, "class_name": "HTTPRequest", "function_description": "Returns an iterator that yields the entire request body once, facilitating line-by-line processing in specified chunk sizes."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/models.py", "function": "headers", "line_number": 99, "body": "def headers(self):\n        url = urlsplit(self._orig.url)\n\n        request_line = '{method} {path}{query} HTTP/1.1'.format(\n            method=self._orig.method,\n            path=url.path or '/',\n            query='?' + url.query if url.query else ''\n        )\n\n        headers = dict(self._orig.headers)\n        if 'Host' not in self._orig.headers:\n            headers['Host'] = url.netloc.split('@')[-1]\n\n        headers = [\n            '%s: %s' % (\n                name,\n                value if isinstance(value, str) else value.decode('utf8')\n            )\n            for name, value in headers.items()\n        ]\n\n        headers.insert(0, request_line)\n        headers = '\\r\\n'.join(headers).strip()\n\n        if isinstance(headers, bytes):\n            # Python < 3\n            headers = headers.decode('utf8')\n        return headers", "is_method": true, "class_name": "HTTPRequest", "function_description": "Constructs and returns the full HTTP request headers as a formatted string, including the request line and a Host header if missing. It provides a ready-to-send representation of the HTTP request headers."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/models.py", "function": "encoding", "line_number": 129, "body": "def encoding(self):\n        return 'utf8'", "is_method": true, "class_name": "HTTPRequest", "function_description": "Returns the character encoding used by the HTTPRequest, indicating it defaults to UTF-8 for processing request data."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/models.py", "function": "body", "line_number": 133, "body": "def body(self):\n        body = self._orig.body\n        if isinstance(body, str):\n            # Happens with JSON/form request data parsed from the command line.\n            body = body.encode('utf8')\n        return body or b''", "is_method": true, "class_name": "HTTPRequest", "function_description": "Returns the HTTP request body as bytes, handling cases where the body might initially be a string. This enables consistent binary access to the request payload for further processing."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/client.py", "function": "collect_messages", "line_number": 33, "body": "def collect_messages(\n    args: argparse.Namespace,\n    config_dir: Path,\n    request_body_read_callback: Callable[[bytes], None] = None,\n) -> Iterable[Union[requests.PreparedRequest, requests.Response]]:\n    httpie_session = None\n    httpie_session_headers = None\n    if args.session or args.session_read_only:\n        httpie_session = get_httpie_session(\n            config_dir=config_dir,\n            session_name=args.session or args.session_read_only,\n            host=args.headers.get('Host'),\n            url=args.url,\n        )\n        httpie_session_headers = httpie_session.headers\n\n    request_kwargs = make_request_kwargs(\n        args=args,\n        base_headers=httpie_session_headers,\n        request_body_read_callback=request_body_read_callback\n    )\n    send_kwargs = make_send_kwargs(args)\n    send_kwargs_mergeable_from_env = make_send_kwargs_mergeable_from_env(args)\n    requests_session = build_requests_session(\n        ssl_version=args.ssl_version,\n        ciphers=args.ciphers,\n        verify=bool(send_kwargs_mergeable_from_env['verify'])\n    )\n\n    if httpie_session:\n        httpie_session.update_headers(request_kwargs['headers'])\n        requests_session.cookies = httpie_session.cookies\n        if args.auth_plugin:\n            # Save auth from CLI to HTTPie session.\n            httpie_session.auth = {\n                'type': args.auth_plugin.auth_type,\n                'raw_auth': args.auth_plugin.raw_auth,\n            }\n        elif httpie_session.auth:\n            # Apply auth from HTTPie session\n            request_kwargs['auth'] = httpie_session.auth\n\n    if args.debug:\n        # TODO: reflect the split between request and send kwargs.\n        dump_request(request_kwargs)\n\n    request = requests.Request(**request_kwargs)\n    prepared_request = requests_session.prepare_request(request)\n    if args.path_as_is:\n        prepared_request.url = ensure_path_as_is(\n            orig_url=args.url,\n            prepped_url=prepared_request.url,\n        )\n    if args.compress and prepared_request.body:\n        compress_request(\n            request=prepared_request,\n            always=args.compress > 1,\n        )\n    response_count = 0\n    expired_cookies = []\n    while prepared_request:\n        yield prepared_request\n        if not args.offline:\n            send_kwargs_merged = requests_session.merge_environment_settings(\n                url=prepared_request.url,\n                **send_kwargs_mergeable_from_env,\n            )\n            with max_headers(args.max_headers):\n                response = requests_session.send(\n                    request=prepared_request,\n                    **send_kwargs_merged,\n                    **send_kwargs,\n                )\n\n            # noinspection PyProtectedMember\n            expired_cookies += get_expired_cookies(\n                headers=response.raw._original_response.msg._headers\n            )\n\n            response_count += 1\n            if response.next:\n                if args.max_redirects and response_count == args.max_redirects:\n                    raise requests.TooManyRedirects\n                if args.follow:\n                    prepared_request = response.next\n                    if args.all:\n                        yield response\n                    continue\n            yield response\n        break\n\n    if httpie_session:\n        if httpie_session.is_new() or not args.session_read_only:\n            httpie_session.cookies = requests_session.cookies\n            httpie_session.remove_cookies(\n                # TODO: take path & domain into account?\n                cookie['name'] for cookie in expired_cookies\n            )\n            httpie_session.save()", "is_method": false, "function_description": "Function that constructs, sends, and yields HTTP requests and their responses based on CLI arguments and session data, supporting features like redirects, cookies, compression, and authentication management. It enables HTTP interactions with session persistence and configurable request handling."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/client.py", "function": "max_headers", "line_number": 136, "body": "def max_headers(limit):\n    # <https://github.com/httpie/httpie/issues/802>\n    # noinspection PyUnresolvedReferences\n    orig = http.client._MAXHEADERS\n    http.client._MAXHEADERS = limit or float('Inf')\n    try:\n        yield\n    finally:\n        http.client._MAXHEADERS = orig", "is_method": false, "function_description": "Provides a context manager to temporarily adjust the maximum number of HTTP headers allowed, enabling control over header limits during HTTP client operations."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/client.py", "function": "build_requests_session", "line_number": 147, "body": "def build_requests_session(\n    verify: bool,\n    ssl_version: str = None,\n    ciphers: str = None,\n) -> requests.Session:\n    requests_session = requests.Session()\n\n    # Install our adapter.\n    https_adapter = HTTPieHTTPSAdapter(\n        ciphers=ciphers,\n        verify=verify,\n        ssl_version=(\n            AVAILABLE_SSL_VERSION_ARG_MAPPING[ssl_version]\n            if ssl_version else None\n        ),\n    )\n    requests_session.mount('https://', https_adapter)\n\n    # Install adapters from plugins.\n    for plugin_cls in plugin_manager.get_transport_plugins():\n        transport_plugin = plugin_cls()\n        requests_session.mount(\n            prefix=transport_plugin.prefix,\n            adapter=transport_plugin.get_adapter(),\n        )\n\n    return requests_session", "is_method": false, "function_description": "Constructs and configures a customized requests.Session with specified SSL settings and support for plugin-based transport adapters, enabling secure and extensible HTTP communication."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/client.py", "function": "dump_request", "line_number": 176, "body": "def dump_request(kwargs: dict):\n    sys.stderr.write(\n        f'\\n>>> requests.request(**{repr_dict(kwargs)})\\n\\n')", "is_method": false, "function_description": "Utility function that logs the details of an HTTP request's keyword arguments to the standard error stream for debugging or monitoring purposes."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/client.py", "function": "finalize_headers", "line_number": 181, "body": "def finalize_headers(headers: RequestHeadersDict) -> RequestHeadersDict:\n    final_headers = RequestHeadersDict()\n    for name, value in headers.items():\n        if value is not None:\n            # \u201cleading or trailing LWS MAY be removed without\n            # changing the semantics of the field value\u201d\n            # <https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html>\n            # Also, requests raises `InvalidHeader` for leading spaces.\n            value = value.strip()\n            if isinstance(value, str):\n                # See <https://github.com/httpie/httpie/issues/212>\n                value = value.encode('utf8')\n        final_headers[name] = value\n    return final_headers", "is_method": false, "function_description": "Function that cleans and encodes HTTP headers by stripping whitespace and converting string values to UTF-8 bytes, ensuring headers are properly formatted for HTTP requests."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/client.py", "function": "make_default_headers", "line_number": 197, "body": "def make_default_headers(args: argparse.Namespace) -> RequestHeadersDict:\n    default_headers = RequestHeadersDict({\n        'User-Agent': DEFAULT_UA\n    })\n\n    auto_json = args.data and not args.form\n    if args.json or auto_json:\n        default_headers['Accept'] = JSON_ACCEPT\n        if args.json or (auto_json and args.data):\n            default_headers['Content-Type'] = JSON_CONTENT_TYPE\n\n    elif args.form and not args.files:\n        # If sending files, `requests` will set\n        # the `Content-Type` for us.\n        default_headers['Content-Type'] = FORM_CONTENT_TYPE\n    return default_headers", "is_method": false, "function_description": "Utility function that generates default HTTP request headers based on command-line arguments, setting appropriate content-type and accept headers for JSON or form data submissions."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/client.py", "function": "make_send_kwargs", "line_number": 215, "body": "def make_send_kwargs(args: argparse.Namespace) -> dict:\n    kwargs = {\n        'timeout': args.timeout or None,\n        'allow_redirects': False,\n    }\n    return kwargs", "is_method": false, "function_description": "Utility function that constructs keyword arguments for sending HTTP requests, setting a configurable timeout and disallowing redirects based on provided arguments."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/client.py", "function": "make_send_kwargs_mergeable_from_env", "line_number": 223, "body": "def make_send_kwargs_mergeable_from_env(args: argparse.Namespace) -> dict:\n    cert = None\n    if args.cert:\n        cert = args.cert\n        if args.cert_key:\n            cert = cert, args.cert_key\n    kwargs = {\n        'proxies': {p.key: p.value for p in args.proxy},\n        'stream': True,\n        'verify': {\n            'yes': True,\n            'true': True,\n            'no': False,\n            'false': False,\n        }.get(args.verify.lower(), args.verify),\n        'cert': cert,\n    }\n    return kwargs", "is_method": false, "function_description": "Function that converts command-line environment arguments into HTTP request parameters, preparing proxies, SSL verification, and certificates for seamless network communication."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/client.py", "function": "make_request_kwargs", "line_number": 243, "body": "def make_request_kwargs(\n    args: argparse.Namespace,\n    base_headers: RequestHeadersDict = None,\n    request_body_read_callback=lambda chunk: chunk\n) -> dict:\n    \"\"\"\n    Translate our `args` into `requests.Request` keyword arguments.\n\n    \"\"\"\n    files = args.files\n    # Serialize JSON data, if needed.\n    data = args.data\n    auto_json = data and not args.form\n    if (args.json or auto_json) and isinstance(data, dict):\n        if data:\n            data = json.dumps(data)\n        else:\n            # We need to set data to an empty string to prevent requests\n            # from assigning an empty list to `response.request.data`.\n            data = ''\n\n    # Finalize headers.\n    headers = make_default_headers(args)\n    if base_headers:\n        headers.update(base_headers)\n    headers.update(args.headers)\n    if args.offline and args.chunked and 'Transfer-Encoding' not in headers:\n        # When online, we let requests set the header instead to be able more\n        # easily verify chunking is taking place.\n        headers['Transfer-Encoding'] = 'chunked'\n    headers = finalize_headers(headers)\n\n    if (args.form and files) or args.multipart:\n        data, headers['Content-Type'] = get_multipart_data_and_content_type(\n            data=args.multipart_data,\n            boundary=args.boundary,\n            content_type=args.headers.get('Content-Type'),\n        )\n\n    kwargs = {\n        'method': args.method.lower(),\n        'url': args.url,\n        'headers': headers,\n        'data': prepare_request_body(\n            body=data,\n            body_read_callback=request_body_read_callback,\n            chunked=args.chunked,\n            offline=args.offline,\n            content_length_header_value=headers.get('Content-Length'),\n        ),\n        'auth': args.auth,\n        'params': args.params.items(),\n    }\n\n    return kwargs", "is_method": false, "function_description": "Function that converts command-line argument values into a dictionary of keyword arguments for an HTTP request, preparing headers, body content, and parameters to be used with a requests.Request call."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/client.py", "function": "ensure_path_as_is", "line_number": 300, "body": "def ensure_path_as_is(orig_url: str, prepped_url: str) -> str:\n    \"\"\"\n    Handle `--path-as-is` by replacing the path component of the prepared\n    URL with the path component from the original URL. Other parts stay\n    untouched because other (welcome) processing on the URL might have\n    taken place.\n\n    <https://github.com/httpie/httpie/issues/895>\n\n\n    <https://ec.haxx.se/http/http-basics#path-as-is>\n    <https://curl.haxx.se/libcurl/c/CURLOPT_PATH_AS_IS.html>\n\n    >>> ensure_path_as_is('http://foo/../', 'http://foo/?foo=bar')\n    'http://foo/../?foo=bar'\n\n    \"\"\"\n    parsed_orig, parsed_prepped = urlparse(orig_url), urlparse(prepped_url)\n    final_dict = {\n        # noinspection PyProtectedMember\n        **parsed_prepped._asdict(),\n        'path': parsed_orig.path,\n    }\n    final_url = urlunparse(tuple(final_dict.values()))\n    return final_url", "is_method": false, "function_description": "Function that replaces the path component of a prepared URL with that from the original URL, preserving other URL parts. It ensures the path remains exactly as originally specified, useful for precise URL handling with path-as-is semantics."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/utils.py", "function": "load_json_preserve_order", "line_number": 14, "body": "def load_json_preserve_order(s):\n    return json.loads(s, object_pairs_hook=OrderedDict)", "is_method": false, "function_description": "Function that parses a JSON string while preserving the order of key-value pairs, returning an ordered dictionary instead of a standard dictionary. Useful for scenarios where the order of JSON elements matters."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/utils.py", "function": "repr_dict", "line_number": 18, "body": "def repr_dict(d: dict) -> str:\n    return pformat(d)", "is_method": false, "function_description": "Utility function that returns a neatly formatted string representation of a dictionary for improved readability in outputs or logs."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/utils.py", "function": "humanize_bytes", "line_number": 22, "body": "def humanize_bytes(n, precision=2):\n    # Author: Doug Latornell\n    # Licence: MIT\n    # URL: https://code.activestate.com/recipes/577081/\n    \"\"\"Return a humanized string representation of a number of bytes.\n\n    Assumes `from __future__ import division`.\n\n    >>> humanize_bytes(1)\n    '1 B'\n    >>> humanize_bytes(1024, precision=1)\n    '1.0 kB'\n    >>> humanize_bytes(1024 * 123, precision=1)\n    '123.0 kB'\n    >>> humanize_bytes(1024 * 12342, precision=1)\n    '12.1 MB'\n    >>> humanize_bytes(1024 * 12342, precision=2)\n    '12.05 MB'\n    >>> humanize_bytes(1024 * 1234, precision=2)\n    '1.21 MB'\n    >>> humanize_bytes(1024 * 1234 * 1111, precision=2)\n    '1.31 GB'\n    >>> humanize_bytes(1024 * 1234 * 1111, precision=1)\n    '1.3 GB'\n\n    \"\"\"\n    abbrevs = [\n        (1 << 50, 'PB'),\n        (1 << 40, 'TB'),\n        (1 << 30, 'GB'),\n        (1 << 20, 'MB'),\n        (1 << 10, 'kB'),\n        (1, 'B')\n    ]\n\n    if n == 1:\n        return '1 B'\n\n    for factor, suffix in abbrevs:\n        if n >= factor:\n            break\n\n    # noinspection PyUnboundLocalVariable\n    return '%.*f %s' % (precision, n / factor, suffix)", "is_method": false, "function_description": "Function that converts a byte count into a human-readable string using appropriate size units, allowing precision control. It helps display file sizes or data amounts in a more understandable format."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/utils.py", "function": "get_content_type", "line_number": 77, "body": "def get_content_type(filename):\n    \"\"\"\n    Return the content type for ``filename`` in format appropriate\n    for Content-Type headers, or ``None`` if the file type is unknown\n    to ``mimetypes``.\n\n    \"\"\"\n    mime, encoding = mimetypes.guess_type(filename, strict=False)\n    if mime:\n        content_type = mime\n        if encoding:\n            content_type = '%s; charset=%s' % (mime, encoding)\n        return content_type", "is_method": false, "function_description": "Function that determines the MIME content type of a given filename, returning a suitable Content-Type header value or None if unknown. Useful for setting HTTP headers or handling files based on their type."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/utils.py", "function": "get_expired_cookies", "line_number": 92, "body": "def get_expired_cookies(\n    headers: List[Tuple[str, str]],\n    now: float = None\n) -> List[dict]:\n\n    now = now or time.time()\n\n    def is_expired(expires: Optional[float]) -> bool:\n        return expires is not None and expires <= now\n\n    attr_sets: List[Tuple[str, str]] = parse_ns_headers(\n        value for name, value in headers\n        if name.lower() == 'set-cookie'\n    )\n    cookies = [\n        # The first attr name is the cookie name.\n        dict(attrs[1:], name=attrs[0][0])\n        for attrs in attr_sets\n    ]\n\n    _max_age_to_expires(cookies=cookies, now=now)\n\n    return [\n        {\n            'name': cookie['name'],\n            'path': cookie.get('path', '/')\n        }\n        for cookie in cookies\n        if is_expired(expires=cookie.get('expires'))\n    ]", "is_method": false, "function_description": "Function that parses HTTP headers to identify and return a list of cookies that have expired based on the current or specified time, useful for managing cookie validity in web applications."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/utils.py", "function": "_max_age_to_expires", "line_number": 124, "body": "def _max_age_to_expires(cookies, now):\n    \"\"\"\n    Translate `max-age` into `expires` for Requests to take it into account.\n\n    HACK/FIXME: <https://github.com/psf/requests/issues/5743>\n\n    \"\"\"\n    for cookie in cookies:\n        if 'expires' in cookie:\n            continue\n        max_age = cookie.get('max-age')\n        if max_age and max_age.isdigit():\n            cookie['expires'] = now + float(max_age)", "is_method": false, "function_description": "Converts cookies' max-age attributes into expires timestamps to ensure compatibility with Requests library handling. This function updates cookies in place to support proper expiration management."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/utils.py", "function": "__call__", "line_number": 73, "body": "def __call__(self, r):\n        return r", "is_method": true, "class_name": "ExplicitNullAuth", "function_description": "Core method of ExplicitNullAuth that returns the input request unchanged, typically used as a placeholder or no-op authenticator in HTTP request handling."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/utils.py", "function": "is_expired", "line_number": 99, "body": "def is_expired(expires: Optional[float]) -> bool:\n        return expires is not None and expires <= now", "is_method": false, "function_description": "This function checks if a given expiration timestamp has passed relative to the current time. It is useful for validating whether time-limited data or sessions are still valid or have expired."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "parse_content_range", "line_number": 44, "body": "def parse_content_range(content_range: str, resumed_from: int) -> int:\n    \"\"\"\n    Parse and validate Content-Range header.\n\n    <https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>\n\n    :param content_range: the value of a Content-Range response header\n                          eg. \"bytes 21010-47021/47022\"\n    :param resumed_from: first byte pos. from the Range request header\n    :return: total size of the response body when fully downloaded.\n\n    \"\"\"\n    if content_range is None:\n        raise ContentRangeError('Missing Content-Range')\n\n    pattern = (\n        r'^bytes (?P<first_byte_pos>\\d+)-(?P<last_byte_pos>\\d+)'\n        r'/(\\*|(?P<instance_length>\\d+))$'\n    )\n    match = re.match(pattern, content_range)\n\n    if not match:\n        raise ContentRangeError(\n            'Invalid Content-Range format %r' % content_range)\n\n    content_range_dict = match.groupdict()\n    first_byte_pos = int(content_range_dict['first_byte_pos'])\n    last_byte_pos = int(content_range_dict['last_byte_pos'])\n    instance_length = (\n        int(content_range_dict['instance_length'])\n        if content_range_dict['instance_length']\n        else None\n    )\n\n    # \"A byte-content-range-spec with a byte-range-resp-spec whose\n    # last- byte-pos value is less than its first-byte-pos value,\n    # or whose instance-length value is less than or equal to its\n    # last-byte-pos value, is invalid. The recipient of an invalid\n    # byte-content-range- spec MUST ignore it and any content\n    # transferred along with it.\"\n    if (first_byte_pos >= last_byte_pos\n        or (instance_length is not None\n            and instance_length <= last_byte_pos)):\n        raise ContentRangeError(\n            'Invalid Content-Range returned: %r' % content_range)\n\n    if (first_byte_pos != resumed_from\n        or (instance_length is not None\n            and last_byte_pos + 1 != instance_length)):\n        # Not what we asked for.\n        raise ContentRangeError(\n            'Unexpected Content-Range returned (%r)'\n            ' for the requested Range (\"bytes=%d-\")'\n            % (content_range, resumed_from)\n        )\n\n    return last_byte_pos + 1", "is_method": false, "function_description": "Function that validates and parses an HTTP Content-Range header, ensuring it matches expected byte positions, and returns the total size of the complete resource for resumed or partial downloads."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "filename_from_content_disposition", "line_number": 103, "body": "def filename_from_content_disposition(\n    content_disposition: str\n) -> Optional[str]:\n    \"\"\"\n    Extract and validate filename from a Content-Disposition header.\n\n    :param content_disposition: Content-Disposition value\n    :return: the filename if present and valid, otherwise `None`\n\n    \"\"\"\n    # attachment; filename=jakubroztocil-httpie-0.4.1-20-g40bd8f6.tar.gz\n\n    msg = Message('Content-Disposition: %s' % content_disposition)\n    filename = msg.get_filename()\n    if filename:\n        # Basic sanitation.\n        filename = os.path.basename(filename).lstrip('.').strip()\n        if filename:\n            return filename", "is_method": false, "function_description": "Function that extracts and sanitizes a valid filename from an HTTP Content-Disposition header, supporting safe retrieval of attachment filenames in web-related contexts."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "filename_from_url", "line_number": 124, "body": "def filename_from_url(url: str, content_type: Optional[str]) -> str:\n    fn = urlsplit(url).path.rstrip('/')\n    fn = os.path.basename(fn) if fn else 'index'\n    if '.' not in fn and content_type:\n        content_type = content_type.split(';')[0]\n        if content_type == 'text/plain':\n            # mimetypes returns '.ksh'\n            ext = '.txt'\n        else:\n            ext = mimetypes.guess_extension(content_type)\n\n        if ext == '.htm':  # Python 3\n            ext = '.html'\n\n        if ext:\n            fn += ext\n\n    return fn", "is_method": false, "function_description": "Function that derives a suitable filename from a URL, appending an appropriate extension based on content type when missing. Useful for saving web resources with correct file naming conventions."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "trim_filename", "line_number": 144, "body": "def trim_filename(filename: str, max_len: int) -> str:\n    if len(filename) > max_len:\n        trim_by = len(filename) - max_len\n        name, ext = os.path.splitext(filename)\n        if trim_by >= len(name):\n            filename = filename[:-trim_by]\n        else:\n            filename = name[:-trim_by] + ext\n    return filename", "is_method": false, "function_description": "Function that shortens a filename to a specified maximum length by trimming characters from its base name while preserving the file extension, ensuring filename length constraints are respected."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "get_filename_max_length", "line_number": 155, "body": "def get_filename_max_length(directory: str) -> int:\n    max_len = 255\n    try:\n        pathconf = os.pathconf\n    except AttributeError:\n        pass  # non-posix\n    else:\n        try:\n            max_len = pathconf(directory, 'PC_NAME_MAX')\n        except OSError as e:\n            if e.errno != errno.EINVAL:\n                raise\n    return max_len", "is_method": false, "function_description": "Function that determines the maximum allowed filename length in a given directory, adapting to the underlying filesystem constraints. It helps validate or generate filenames compatible with the target directory's filesystem limits."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "trim_filename_if_needed", "line_number": 170, "body": "def trim_filename_if_needed(filename: str, directory='.', extra=0) -> str:\n    max_len = get_filename_max_length(directory) - extra\n    if len(filename) > max_len:\n        filename = trim_filename(filename, max_len)\n    return filename", "is_method": false, "function_description": "Utility function that ensures a filename fits within the maximum allowed length for a given directory, optionally reserving extra space, by trimming it if necessary."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "get_unique_filename", "line_number": 177, "body": "def get_unique_filename(filename: str, exists=os.path.exists) -> str:\n    attempt = 0\n    while True:\n        suffix = '-' + str(attempt) if attempt > 0 else ''\n        try_filename = trim_filename_if_needed(filename, extra=len(suffix))\n        try_filename += suffix\n        if not exists(try_filename):\n            return try_filename\n        attempt += 1", "is_method": false, "function_description": "Function that generates a unique filename by appending incremental suffixes if a file with the given name already exists, preventing filename collisions during file creation or saving operations."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "pre_request", "line_number": 216, "body": "def pre_request(self, request_headers: dict):\n        \"\"\"Called just before the HTTP request is sent.\n\n        Might alter `request_headers`.\n\n        \"\"\"\n        # Ask the server not to encode the content so that we can resume, etc.\n        request_headers['Accept-Encoding'] = 'identity'\n        if self._resume:\n            bytes_have = os.path.getsize(self._output_file.name)\n            if bytes_have:\n                # Set ``Range`` header to resume the download\n                # TODO: Use \"If-Range: mtime\" to make sure it's fresh?\n                request_headers['Range'] = 'bytes=%d-' % bytes_have\n                self._resumed_from = bytes_have", "is_method": true, "class_name": "Downloader", "function_description": "Prepares and modifies HTTP request headers to facilitate resuming interrupted downloads by specifying byte ranges and preventing content encoding. This enables efficient download continuation and partial content retrieval."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "start", "line_number": 232, "body": "def start(\n        self,\n        initial_url: str,\n        final_response: requests.Response\n    ) -> Tuple[RawStream, IO]:\n        \"\"\"\n        Initiate and return a stream for `response` body  with progress\n        callback attached. Can be called only once.\n\n        :param initial_url: The original requested URL\n        :param final_response: Initiated response object with headers already fetched\n\n        :return: RawStream, output_file\n\n        \"\"\"\n        assert not self.status.time_started\n\n        # FIXME: some servers still might sent Content-Encoding: gzip\n        # <https://github.com/httpie/httpie/issues/423>\n        try:\n            total_size = int(final_response.headers['Content-Length'])\n        except (KeyError, ValueError, TypeError):\n            total_size = None\n\n        if not self._output_file:\n            self._output_file = self._get_output_file_from_response(\n                initial_url=initial_url,\n                final_response=final_response,\n            )\n        else:\n            # `--output, -o` provided\n            if self._resume and final_response.status_code == PARTIAL_CONTENT:\n                total_size = parse_content_range(\n                    final_response.headers.get('Content-Range'),\n                    self._resumed_from\n                )\n\n            else:\n                self._resumed_from = 0\n                try:\n                    self._output_file.seek(0)\n                    self._output_file.truncate()\n                except IOError:\n                    pass  # stdout\n\n        self.status.started(\n            resumed_from=self._resumed_from,\n            total_size=total_size\n        )\n\n        stream = RawStream(\n            msg=HTTPResponse(final_response),\n            with_headers=False,\n            with_body=True,\n            on_body_chunk_downloaded=self.chunk_downloaded,\n            chunk_size=1024 * 8\n        )\n\n        self._progress_reporter.output.write(\n            'Downloading %sto \"%s\"\\n' % (\n                (humanize_bytes(total_size) + ' '\n                 if total_size is not None\n                 else ''),\n                self._output_file.name\n            )\n        )\n        self._progress_reporter.start()\n\n        return stream, self._output_file", "is_method": true, "class_name": "Downloader", "function_description": "Starts a downloadable stream from a given HTTP response while attaching progress reporting and handles output file setup, supporting resume functionality. It enables consumers to process the response body incrementally with download progress feedback."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "finish", "line_number": 302, "body": "def finish(self):\n        assert not self.finished\n        self.finished = True\n        self.status.finished()", "is_method": true, "class_name": "Downloader", "function_description": "Marks the download process as complete and updates its status accordingly, ensuring that completion actions are performed only once."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "failed", "line_number": 307, "body": "def failed(self):\n        self._progress_reporter.stop()", "is_method": true, "class_name": "Downloader", "function_description": "Stops the progress reporting when a download operation fails, signaling the termination of progress updates."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "interrupted", "line_number": 311, "body": "def interrupted(self) -> bool:\n        return (\n            self.finished\n            and self.status.total_size\n            and self.status.total_size != self.status.downloaded\n        )", "is_method": true, "class_name": "Downloader", "function_description": "Helper method in Downloader that checks if a finished download was interrupted before completion by comparing downloaded size to total size."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "chunk_downloaded", "line_number": 318, "body": "def chunk_downloaded(self, chunk: bytes):\n        \"\"\"\n        A download progress callback.\n\n        :param chunk: A chunk of response body data that has just\n                      been downloaded and written to the output.\n\n        \"\"\"\n        self.status.chunk_downloaded(len(chunk))", "is_method": true, "class_name": "Downloader", "function_description": "Reports progress by notifying the download status handler about the size of each downloaded data chunk. This method supports tracking incremental download progress within the Downloader class."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "_get_output_file_from_response", "line_number": 329, "body": "def _get_output_file_from_response(\n        initial_url: str,\n        final_response: requests.Response,\n    ) -> IO:\n        # Output file not specified. Pick a name that doesn't exist yet.\n        filename = None\n        if 'Content-Disposition' in final_response.headers:\n            filename = filename_from_content_disposition(\n                final_response.headers['Content-Disposition'])\n        if not filename:\n            filename = filename_from_url(\n                url=initial_url,\n                content_type=final_response.headers.get('Content-Type'),\n            )\n        unique_filename = get_unique_filename(filename)\n        return open(unique_filename, mode='a+b')", "is_method": true, "class_name": "Downloader", "function_description": "Internal utility of the Downloader class that determines and opens a unique output file based on HTTP response headers or URL, ensuring no existing file is overwritten during downloads."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "started", "line_number": 357, "body": "def started(self, resumed_from=0, total_size=None):\n        assert self.time_started is None\n        self.total_size = total_size\n        self.downloaded = self.resumed_from = resumed_from\n        self.time_started = time()", "is_method": true, "class_name": "DownloadStatus", "function_description": "Initializes and marks the start of a download session, setting parameters for resumed position, total size, and start time tracking within the DownloadStatus context."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "chunk_downloaded", "line_number": 363, "body": "def chunk_downloaded(self, size):\n        assert self.time_finished is None\n        self.downloaded += size", "is_method": true, "class_name": "DownloadStatus", "function_description": "Updates the current download progress by adding the specified chunk size; ensures the download is still in progress before updating."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "has_finished", "line_number": 368, "body": "def has_finished(self):\n        return self.time_finished is not None", "is_method": true, "class_name": "DownloadStatus", "function_description": "Method of the DownloadStatus class that indicates whether the download process has completed by checking if the finish time is recorded. It helps track download completion status in monitoring or control flows."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "finished", "line_number": 371, "body": "def finished(self):\n        assert self.time_started is not None\n        assert self.time_finished is None\n        self.time_finished = time()", "is_method": true, "class_name": "DownloadStatus", "function_description": "Marks the download as finished by recording the completion time, ensuring it was started but not yet completed. This helps track download durations and status transitions in the DownloadStatus class."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "stop", "line_number": 403, "body": "def stop(self):\n        \"\"\"Stop reporting on next tick.\"\"\"\n        self._should_stop.set()", "is_method": true, "class_name": "ProgressReporterThread", "function_description": "Stops the ProgressReporterThread from continuing to report by signaling it to halt on the next update cycle. This allows controlled termination of progress reporting operations."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "run", "line_number": 407, "body": "def run(self):\n        while not self._should_stop.is_set():\n            if self.status.has_finished:\n                self.sum_up()\n                break\n\n            self.report_speed()\n            sleep(self._tick)", "is_method": true, "class_name": "ProgressReporterThread", "function_description": "Core utility method of the ProgressReporterThread class that continuously monitors progress, reports speed updates at regular intervals, and summarizes results once processing is complete."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "report_speed", "line_number": 416, "body": "def report_speed(self):\n\n        now = time()\n\n        if now - self._prev_time >= self._update_interval:\n            downloaded = self.status.downloaded\n            try:\n                speed = ((downloaded - self._prev_bytes)\n                         / (now - self._prev_time))\n            except ZeroDivisionError:\n                speed = 0\n\n            if not self.status.total_size:\n                self._status_line = PROGRESS_NO_CONTENT_LENGTH.format(\n                    downloaded=humanize_bytes(downloaded),\n                    speed=humanize_bytes(speed),\n                )\n            else:\n                try:\n                    percentage = downloaded / self.status.total_size * 100\n                except ZeroDivisionError:\n                    percentage = 0\n\n                if not speed:\n                    eta = '-:--:--'\n                else:\n                    s = int((self.status.total_size - downloaded) / speed)\n                    h, s = divmod(s, 60 * 60)\n                    m, s = divmod(s, 60)\n                    eta = '{0}:{1:0>2}:{2:0>2}'.format(h, m, s)\n\n                self._status_line = PROGRESS.format(\n                    percentage=percentage,\n                    downloaded=humanize_bytes(downloaded),\n                    speed=humanize_bytes(speed),\n                    eta=eta,\n                )\n\n            self._prev_time = now\n            self._prev_bytes = downloaded\n\n        self.output.write(\n            CLEAR_LINE\n            + ' '\n            + SPINNER[self._spinner_pos]\n            + ' '\n            + self._status_line\n        )\n        self.output.flush()\n\n        self._spinner_pos = (self._spinner_pos + 1\n                             if self._spinner_pos + 1 != len(SPINNER)\n                             else 0)", "is_method": true, "class_name": "ProgressReporterThread", "function_description": "Utility method of ProgressReporterThread that calculates and displays current download speed, progress percentage, and estimated time remaining, providing real-time feedback during data transfer operations."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/downloads.py", "function": "sum_up", "line_number": 470, "body": "def sum_up(self):\n        actually_downloaded = (\n            self.status.downloaded - self.status.resumed_from)\n        time_taken = self.status.time_finished - self.status.time_started\n\n        self.output.write(CLEAR_LINE)\n\n        try:\n            speed = actually_downloaded / time_taken\n        except ZeroDivisionError:\n            # Either time is 0 (not all systems provide `time.time`\n            # with a better precision than 1 second), and/or nothing\n            # has been downloaded.\n            speed = actually_downloaded\n\n        self.output.write(SUMMARY.format(\n            downloaded=humanize_bytes(actually_downloaded),\n            total=(self.status.total_size\n                   and humanize_bytes(self.status.total_size)),\n            speed=humanize_bytes(speed),\n            time=time_taken,\n        ))\n        self.output.flush()", "is_method": true, "class_name": "ProgressReporterThread", "function_description": "Method of ProgressReporterThread that summarizes and displays the download progress, including total downloaded data, transfer speed, and elapsed time. It provides a concise status update during or after a file download operation."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/core.py", "function": "main", "line_number": 22, "body": "def main(args: List[Union[str, bytes]] = sys.argv, env=Environment()) -> ExitStatus:\n    \"\"\"\n    The main function.\n\n    Pre-process args, handle some special types of invocations,\n    and run the main program with error handling.\n\n    Return exit status code.\n\n    \"\"\"\n    program_name, *args = args\n    env.program_name = os.path.basename(program_name)\n    args = decode_raw_args(args, env.stdin_encoding)\n    plugin_manager.load_installed_plugins()\n\n    from httpie.cli.definition import parser\n\n    if env.config.default_options:\n        args = env.config.default_options + args\n\n    include_debug_info = '--debug' in args\n    include_traceback = include_debug_info or '--traceback' in args\n\n    if include_debug_info:\n        print_debug_info(env)\n        if args == ['--debug']:\n            return ExitStatus.SUCCESS\n\n    exit_status = ExitStatus.SUCCESS\n\n    try:\n        parsed_args = parser.parse_args(\n            args=args,\n            env=env,\n        )\n    except KeyboardInterrupt:\n        env.stderr.write('\\n')\n        if include_traceback:\n            raise\n        exit_status = ExitStatus.ERROR_CTRL_C\n    except SystemExit as e:\n        if e.code != ExitStatus.SUCCESS:\n            env.stderr.write('\\n')\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR\n    else:\n        try:\n            exit_status = program(\n                args=parsed_args,\n                env=env,\n            )\n        except KeyboardInterrupt:\n            env.stderr.write('\\n')\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR_CTRL_C\n        except SystemExit as e:\n            if e.code != ExitStatus.SUCCESS:\n                env.stderr.write('\\n')\n                if include_traceback:\n                    raise\n                exit_status = ExitStatus.ERROR\n        except requests.Timeout:\n            exit_status = ExitStatus.ERROR_TIMEOUT\n            env.log_error(f'Request timed out ({parsed_args.timeout}s).')\n        except requests.TooManyRedirects:\n            exit_status = ExitStatus.ERROR_TOO_MANY_REDIRECTS\n            env.log_error(\n                f'Too many redirects'\n                f' (--max-redirects={parsed_args.max_redirects}).'\n            )\n        except Exception as e:\n            # TODO: Further distinction between expected and unexpected errors.\n            msg = str(e)\n            if hasattr(e, 'request'):\n                request = e.request\n                if hasattr(request, 'url'):\n                    msg = (\n                        f'{msg} while doing a {request.method}'\n                        f' request to URL: {request.url}'\n                    )\n            env.log_error(f'{type(e).__name__}: {msg}')\n            if include_traceback:\n                raise\n            exit_status = ExitStatus.ERROR\n\n    return exit_status", "is_method": false, "function_description": "Main entry point that preprocesses command-line arguments, manages plugins, parses inputs, runs the program, and handles errors to return an appropriate exit status code for the execution."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/core.py", "function": "get_output_options", "line_number": 112, "body": "def get_output_options(\n    args: argparse.Namespace,\n    message: Union[requests.PreparedRequest, requests.Response]\n) -> Tuple[bool, bool]:\n    return {\n        requests.PreparedRequest: (\n            OUT_REQ_HEAD in args.output_options,\n            OUT_REQ_BODY in args.output_options,\n        ),\n        requests.Response: (\n            OUT_RESP_HEAD in args.output_options,\n            OUT_RESP_BODY in args.output_options,\n        ),\n    }[type(message)]", "is_method": false, "function_description": "This function determines which parts of a request or response (headers and/or body) should be output based on user-specified options. It enables flexible control over message data to display or process in HTTP interactions."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/core.py", "function": "program", "line_number": 128, "body": "def program(args: argparse.Namespace, env: Environment) -> ExitStatus:\n    \"\"\"\n    The main program without error handling.\n\n    \"\"\"\n    # TODO: Refactor and drastically simplify, especially so that the separator logic is elsewhere.\n    exit_status = ExitStatus.SUCCESS\n    downloader = None\n    initial_request: Optional[requests.PreparedRequest] = None\n    final_response: Optional[requests.Response] = None\n\n    def separate():\n        getattr(env.stdout, 'buffer', env.stdout).write(MESSAGE_SEPARATOR_BYTES)\n\n    def request_body_read_callback(chunk: bytes):\n        should_pipe_to_stdout = bool(\n            # Request body output desired\n            OUT_REQ_BODY in args.output_options\n            # & not `.read()` already pre-request (e.g., for  compression)\n            and initial_request\n            # & non-EOF chunk\n            and chunk\n        )\n        if should_pipe_to_stdout:\n            msg = requests.PreparedRequest()\n            msg.is_body_upload_chunk = True\n            msg.body = chunk\n            msg.headers = initial_request.headers\n            write_message(requests_message=msg, env=env, args=args, with_body=True, with_headers=False)\n\n    try:\n        if args.download:\n            args.follow = True  # --download implies --follow.\n            downloader = Downloader(output_file=args.output_file, progress_file=env.stderr, resume=args.download_resume)\n            downloader.pre_request(args.headers)\n        messages = collect_messages(args=args, config_dir=env.config.directory,\n                                    request_body_read_callback=request_body_read_callback)\n        force_separator = False\n        prev_with_body = False\n\n        # Process messages as they\u2019re generated\n        for message in messages:\n            is_request = isinstance(message, requests.PreparedRequest)\n            with_headers, with_body = get_output_options(args=args, message=message)\n            do_write_body = with_body\n            if prev_with_body and (with_headers or with_body) and (force_separator or not env.stdout_isatty):\n                # Separate after a previous message with body, if needed. See test_tokens.py.\n                separate()\n            force_separator = False\n            if is_request:\n                if not initial_request:\n                    initial_request = message\n                    is_streamed_upload = not isinstance(message.body, (str, bytes))\n                    if with_body:\n                        do_write_body = not is_streamed_upload\n                        force_separator = is_streamed_upload and env.stdout_isatty\n            else:\n                final_response = message\n                if args.check_status or downloader:\n                    exit_status = http_status_to_exit_status(http_status=message.status_code, follow=args.follow)\n                    if exit_status != ExitStatus.SUCCESS and (not env.stdout_isatty or args.quiet):\n                        env.log_error(f'HTTP {message.raw.status} {message.raw.reason}', level='warning')\n            write_message(requests_message=message, env=env, args=args, with_headers=with_headers,\n                          with_body=do_write_body)\n            prev_with_body = with_body\n\n        # Cleanup\n        if force_separator:\n            separate()\n        if downloader and exit_status == ExitStatus.SUCCESS:\n            # Last response body download.\n            download_stream, download_to = downloader.start(\n                initial_url=initial_request.url,\n                final_response=final_response,\n            )\n            write_stream(stream=download_stream, outfile=download_to, flush=False)\n            downloader.finish()\n            if downloader.interrupted:\n                exit_status = ExitStatus.ERROR\n                env.log_error(\n                    'Incomplete download: size=%d; downloaded=%d' % (\n                        downloader.status.total_size,\n                        downloader.status.downloaded\n                    ))\n        return exit_status\n\n    finally:\n        if downloader and not downloader.finished:\n            downloader.failed()\n        if not isinstance(args, list) and args.output_file and args.output_file_specified:\n            args.output_file.close()", "is_method": false, "function_description": "Primary function of the program that executes an HTTP request workflow, handles optional downloading with progress and resume support, processes streaming messages, and manages output including headers and bodies. It coordinates request/response I/O and determines the appropriate exit status."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/core.py", "function": "print_debug_info", "line_number": 221, "body": "def print_debug_info(env: Environment):\n    env.stderr.writelines([\n        f'HTTPie {httpie_version}\\n',\n        f'Requests {requests_version}\\n',\n        f'Pygments {pygments_version}\\n',\n        f'Python {sys.version}\\n{sys.executable}\\n',\n        f'{platform.system()} {platform.release()}',\n    ])\n    env.stderr.write('\\n\\n')\n    env.stderr.write(repr(env))\n    env.stderr.write('\\n')", "is_method": false, "function_description": "Utility function that outputs detailed environment and version information to the given environment's error stream for debugging purposes."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/core.py", "function": "decode_raw_args", "line_number": 234, "body": "def decode_raw_args(\n    args: List[Union[str, bytes]],\n    stdin_encoding: str\n) -> List[str]:\n    \"\"\"\n    Convert all bytes args to str\n    by decoding them using stdin encoding.\n\n    \"\"\"\n    return [\n        arg.decode(stdin_encoding)\n        if type(arg) is bytes else arg\n        for arg in args\n    ]", "is_method": false, "function_description": "Function that converts a list of string or byte arguments into strings by decoding byte entries using a specified encoding. It enables consistent handling of command-line or input arguments regardless of their initial type."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/core.py", "function": "request_body_read_callback", "line_number": 142, "body": "def request_body_read_callback(chunk: bytes):\n        should_pipe_to_stdout = bool(\n            # Request body output desired\n            OUT_REQ_BODY in args.output_options\n            # & not `.read()` already pre-request (e.g., for  compression)\n            and initial_request\n            # & non-EOF chunk\n            and chunk\n        )\n        if should_pipe_to_stdout:\n            msg = requests.PreparedRequest()\n            msg.is_body_upload_chunk = True\n            msg.body = chunk\n            msg.headers = initial_request.headers\n            write_message(requests_message=msg, env=env, args=args, with_body=True, with_headers=False)", "is_method": false, "function_description": "Provides a callback to conditionally capture and output chunks of an HTTP request body during upload, supporting diagnostic or logging purposes based on runtime options."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/context.py", "function": "__str__", "line_number": 88, "body": "def __str__(self):\n        defaults = dict(type(self).__dict__)\n        actual = dict(defaults)\n        actual.update(self.__dict__)\n        actual['config'] = self.config\n        return repr_dict({\n            key: value\n            for key, value in actual.items()\n            if not key.startswith('_')\n        })", "is_method": true, "class_name": "Environment", "function_description": "Provides a string representation of the Environment instance showing its public attributes, including configuration, for easy inspection and debugging without exposing private details."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/context.py", "function": "__repr__", "line_number": 99, "body": "def __repr__(self):\n        return f'<{type(self).__name__} {self}>'", "is_method": true, "class_name": "Environment", "function_description": "Returns a string representation of the Environment instance showing its class name and current state for easier identification during debugging and logging."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/context.py", "function": "config", "line_number": 105, "body": "def config(self) -> Config:\n        config = self._config\n        if not config:\n            self._config = config = Config(directory=self.config_dir)\n            if not config.is_new():\n                try:\n                    config.load()\n                except ConfigFileError as e:\n                    self.log_error(e, level='warning')\n        return config", "is_method": true, "class_name": "Environment", "function_description": "Core method of the Environment class that retrieves the current configuration, loading it from disk if necessary, and handles loading errors gracefully. It provides access to the environment\u2019s configuration settings for other components."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/context.py", "function": "devnull", "line_number": 117, "body": "def devnull(self) -> IO:\n        if self._devnull is None:\n            self._devnull = open(os.devnull, 'w+')\n        return self._devnull", "is_method": true, "class_name": "Environment", "function_description": "Provides a reusable writable file-like object that discards all written data, useful for suppressing output or ignoring unwanted writes within the Environment context."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/context.py", "function": "devnull", "line_number": 123, "body": "def devnull(self, value):\n        self._devnull = value", "is_method": true, "class_name": "Environment", "function_description": "Setter method in the Environment class to assign a value to the internal _devnull attribute, potentially controlling or redirecting output or logging behavior."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/context.py", "function": "log_error", "line_number": 126, "body": "def log_error(self, msg, level='error'):\n        assert level in ['error', 'warning']\n        self._orig_stderr.write(f'\\n{self.program_name}: {level}: {msg}\\n\\n')", "is_method": true, "class_name": "Environment", "function_description": "Utility method of the Environment class that logs error or warning messages to the original standard error stream, tagging them with the program name and severity level. It supports basic error tracking and diagnostic output."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/ssl.py", "function": "init_poolmanager", "line_number": 42, "body": "def init_poolmanager(self, *args, **kwargs):\n        kwargs['ssl_context'] = self._ssl_context\n        return super().init_poolmanager(*args, **kwargs)", "is_method": true, "class_name": "HTTPieHTTPSAdapter", "function_description": "This method initializes a connection pool manager with a custom SSL context for secure HTTP connections. It ensures that all connections use the specified SSL settings, supporting secure communication in HTTPieHTTPSAdapter."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/ssl.py", "function": "proxy_manager_for", "line_number": 46, "body": "def proxy_manager_for(self, *args, **kwargs):\n        kwargs['ssl_context'] = self._ssl_context\n        return super().proxy_manager_for(*args, **kwargs)", "is_method": true, "class_name": "HTTPieHTTPSAdapter", "function_description": "Overrides proxy manager creation to inject a custom SSL context, enabling HTTPS connections with specific SSL settings in HTTPieHTTPSAdapter."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/ssl.py", "function": "_create_ssl_context", "line_number": 51, "body": "def _create_ssl_context(\n        verify: bool,\n        ssl_version: str = None,\n        ciphers: str = None,\n    ) -> 'ssl.SSLContext':\n        return create_urllib3_context(\n            ciphers=ciphers,\n            ssl_version=resolve_ssl_version(ssl_version),\n            # Since we are using a custom SSL context, we need to pass this\n            # here manually, even though it\u2019s also passed to the connection\n            # in `super().cert_verify()`.\n            cert_reqs=ssl.CERT_REQUIRED if verify else ssl.CERT_NONE\n        )", "is_method": true, "class_name": "HTTPieHTTPSAdapter", "function_description": "Creates and configures an SSL context for secure HTTP connections, customizing verification, SSL version, and cipher settings. This supports making HTTPS requests with tailored security parameters."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/status.py", "function": "http_status_to_exit_status", "line_number": 23, "body": "def http_status_to_exit_status(http_status: int, follow=False) -> ExitStatus:\n    \"\"\"\n    Translate HTTP status code to exit status code.\n\n    (Relevant only when invoked with --check-status or --download.)\n\n    \"\"\"\n    if 300 <= http_status <= 399 and not follow:\n        # Redirect\n        return ExitStatus.ERROR_HTTP_3XX\n    elif 400 <= http_status <= 499:\n        # Client Error\n        return ExitStatus.ERROR_HTTP_4XX\n    elif 500 <= http_status <= 599:\n        # Server Error\n        return ExitStatus.ERROR_HTTP_5XX\n    else:\n        return ExitStatus.SUCCESS", "is_method": false, "function_description": "Converts an HTTP response status code into a corresponding exit status, indicating success or specific error categories like redirects, client errors, or server errors, aiding command-line tools in interpreting HTTP results."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/config.py", "function": "get_default_config_dir", "line_number": 20, "body": "def get_default_config_dir() -> Path:\n    \"\"\"\n    Return the path to the httpie configuration directory.\n\n    This directory isn't guaranteed to exist, and nor are any of its\n    ancestors (only the legacy ~/.httpie, if returned, is guaranteed to exist).\n\n    XDG Base Directory Specification support:\n\n        <https://wiki.archlinux.org/index.php/XDG_Base_Directory>\n\n        $XDG_CONFIG_HOME is supported; $XDG_CONFIG_DIRS is not\n\n    \"\"\"\n    # 1. explicitly set through env\n    env_config_dir = os.environ.get(ENV_HTTPIE_CONFIG_DIR)\n    if env_config_dir:\n        return Path(env_config_dir)\n\n    # 2. Windows\n    if is_windows:\n        return DEFAULT_WINDOWS_CONFIG_DIR\n\n    home_dir = Path.home()\n\n    # 3. legacy ~/.httpie\n    legacy_config_dir = home_dir / DEFAULT_RELATIVE_LEGACY_CONFIG_DIR\n    if legacy_config_dir.exists():\n        return legacy_config_dir\n\n    # 4. XDG\n    xdg_config_home_dir = os.environ.get(\n        ENV_XDG_CONFIG_HOME,  # 4.1. explicit\n        home_dir / DEFAULT_RELATIVE_XDG_CONFIG_HOME  # 4.2. default\n    )\n    return Path(xdg_config_home_dir) / DEFAULT_CONFIG_DIRNAME", "is_method": false, "function_description": "Provides the file system path to the default configuration directory for the HTTPie tool, respecting environment variables, platform conventions, and legacy locations. This enables other functions to locate or create configuration files reliably across systems."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/config.py", "function": "ensure_directory", "line_number": 74, "body": "def ensure_directory(self):\n        try:\n            self.path.parent.mkdir(mode=0o700, parents=True)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise", "is_method": true, "class_name": "BaseConfigDict", "function_description": "Ensures that the directory containing the specified path exists by creating it with secure permissions if necessary, handling existing directories gracefully. This supports reliable file system setup before file operations."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/config.py", "function": "is_new", "line_number": 81, "body": "def is_new(self) -> bool:\n        return not self.path.exists()", "is_method": true, "class_name": "BaseConfigDict", "function_description": "Determines whether the configuration represented by this object is new by checking if its associated file path does not exist. Useful for initialization or setup processes that depend on the presence of configuration files."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/config.py", "function": "load", "line_number": 84, "body": "def load(self):\n        config_type = type(self).__name__.lower()\n        try:\n            with self.path.open('rt') as f:\n                try:\n                    data = json.load(f)\n                except ValueError as e:\n                    raise ConfigFileError(\n                        f'invalid {config_type} file: {e} [{self.path}]'\n                    )\n                self.update(data)\n        except IOError as e:\n            if e.errno != errno.ENOENT:\n                raise ConfigFileError(f'cannot read {config_type} file: {e}')", "is_method": true, "class_name": "BaseConfigDict", "function_description": "Loads and parses JSON configuration data from a file into the BaseConfigDict instance, handling file access and JSON format errors for robust configuration management."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/config.py", "function": "save", "line_number": 99, "body": "def save(self, fail_silently=False):\n        self['__meta__'] = {\n            'httpie': __version__\n        }\n        if self.helpurl:\n            self['__meta__']['help'] = self.helpurl\n\n        if self.about:\n            self['__meta__']['about'] = self.about\n\n        self.ensure_directory()\n\n        json_string = json.dumps(\n            obj=self,\n            indent=4,\n            sort_keys=True,\n            ensure_ascii=True,\n        )\n        try:\n            self.path.write_text(json_string + '\\n')\n        except IOError:\n            if not fail_silently:\n                raise", "is_method": true, "class_name": "BaseConfigDict", "function_description": "Saves the configuration dictionary as a formatted JSON file, embedding metadata and creating necessary directories. It optionally suppresses IO errors during the write operation."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/config.py", "function": "delete", "line_number": 123, "body": "def delete(self):\n        try:\n            self.path.unlink()\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise", "is_method": true, "class_name": "BaseConfigDict", "function_description": "Utility method of the BaseConfigDict class that deletes the configuration file at the specified path, ignoring errors if the file does not exist while raising others."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/config.py", "function": "default_options", "line_number": 143, "body": "def default_options(self) -> list:\n        return self['default_options']", "is_method": true, "class_name": "Config", "function_description": "Returns the list of default configuration options from the Config object. This provides quick access to standard settings predefined in the configuration."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/processing.py", "function": "is_valid_mime", "line_number": 12, "body": "def is_valid_mime(mime):\n    return mime and MIME_RE.match(mime)", "is_method": false, "function_description": "This function checks if a given string is a valid MIME type based on a predefined pattern. It helps validate MIME format correctness for functions handling content types or file formats."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/processing.py", "function": "get_converter", "line_number": 19, "body": "def get_converter(mime: str) -> Optional[ConverterPlugin]:\n        if is_valid_mime(mime):\n            for converter_class in plugin_manager.get_converters():\n                if converter_class.supports(mime):\n                    return converter_class(mime)", "is_method": true, "class_name": "Conversion", "function_description": "Core utility method of the Conversion class that returns a converter plugin supporting the given MIME type, enabling dynamic selection of appropriate converters for data transformation tasks."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/processing.py", "function": "format_headers", "line_number": 44, "body": "def format_headers(self, headers: str) -> str:\n        for p in self.enabled_plugins:\n            headers = p.format_headers(headers)\n        return headers", "is_method": true, "class_name": "Formatting", "function_description": "Applies a series of enabled plugins to process and format header strings, producing a finalized formatted header output. Useful for dynamically enhancing or standardizing headers through plugin extensions."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/processing.py", "function": "format_body", "line_number": 49, "body": "def format_body(self, content: str, mime: str) -> str:\n        if is_valid_mime(mime):\n            for p in self.enabled_plugins:\n                content = p.format_body(content, mime)\n        return content", "is_method": true, "class_name": "Formatting", "function_description": "Core method of the Formatting class that applies a series of enabled plugins to transform content based on its MIME type, facilitating customizable content formatting workflows."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/streams.py", "function": "get_headers", "line_number": 49, "body": "def get_headers(self) -> bytes:\n        \"\"\"Return the headers' bytes.\"\"\"\n        return self.msg.headers.encode('utf8')", "is_method": true, "class_name": "BaseStream", "function_description": "Method of BaseStream that returns the message headers encoded as UTF-8 bytes, facilitating transmission or processing of header information in byte form."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/streams.py", "function": "__iter__", "line_number": 57, "body": "def __iter__(self) -> Iterable[bytes]:\n        \"\"\"Return an iterator over `self.msg`.\"\"\"\n        if self.with_headers:\n            yield self.get_headers()\n            yield b'\\r\\n\\r\\n'\n\n        if self.with_body:\n            try:\n                for chunk in self.iter_body():\n                    yield chunk\n                    if self.on_body_chunk_downloaded:\n                        self.on_body_chunk_downloaded(chunk)\n            except DataSuppressedError as e:\n                if self.with_headers:\n                    yield b'\\n'\n                yield e.message", "is_method": true, "class_name": "BaseStream", "function_description": "Provides an iterator over the stream's message, optionally including headers and body chunks, and supports callback handling for downloaded body data and error message yielding. Enables incremental streaming of message content with customizable parts."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/streams.py", "function": "iter_body", "line_number": 85, "body": "def iter_body(self) -> Iterable[bytes]:\n        return self.msg.iter_body(self.chunk_size)", "is_method": true, "class_name": "RawStream", "function_description": "Returns an iterable that yields the raw message body in byte chunks, facilitating efficient streaming or processing of large data within the RawStream context."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/streams.py", "function": "iter_body", "line_number": 110, "body": "def iter_body(self) -> Iterable[bytes]:\n        for line, lf in self.msg.iter_lines(self.CHUNK_SIZE):\n            if b'\\0' in line:\n                raise BinarySuppressedError()\n            yield line.decode(self.msg.encoding) \\\n                      .encode(self.output_encoding, 'replace') + lf", "is_method": true, "class_name": "EncodedStream", "function_description": "Method of EncodedStream that iterates over message lines, re-encoding them while detecting and blocking binary content to prevent processing errors. It provides safe, encoded streaming of message body parts for downstream consumers."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/streams.py", "function": "get_headers", "line_number": 139, "body": "def get_headers(self) -> bytes:\n        return self.formatting.format_headers(\n            self.msg.headers).encode(self.output_encoding)", "is_method": true, "class_name": "PrettyStream", "function_description": "Core method of PrettyStream that formats and encodes message headers, providing them as byte strings for output or transmission purposes."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/streams.py", "function": "iter_body", "line_number": 143, "body": "def iter_body(self) -> Iterable[bytes]:\n        first_chunk = True\n        iter_lines = self.msg.iter_lines(self.CHUNK_SIZE)\n        for line, lf in iter_lines:\n            if b'\\0' in line:\n                if first_chunk:\n                    converter = self.conversion.get_converter(self.mime)\n                    if converter:\n                        body = bytearray()\n                        # noinspection PyAssignmentToLoopOrWithParameter\n                        for line, lf in chain([(line, lf)], iter_lines):\n                            body.extend(line)\n                            body.extend(lf)\n                        self.mime, body = converter.convert(body)\n                        assert isinstance(body, str)\n                        yield self.process_body(body)\n                        return\n                raise BinarySuppressedError()\n            yield self.process_body(line) + lf\n            first_chunk = False", "is_method": true, "class_name": "PrettyStream", "function_description": "Core method of PrettyStream that yields processed byte chunks from a message body, handling special MIME conversions and suppressing binary content to support safe streaming of text-based payloads."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/streams.py", "function": "process_body", "line_number": 164, "body": "def process_body(self, chunk: Union[str, bytes]) -> bytes:\n        if not isinstance(chunk, str):\n            # Text when a converter has been used,\n            # otherwise it will always be bytes.\n            chunk = chunk.decode(self.msg.encoding, 'replace')\n        chunk = self.formatting.format_body(content=chunk, mime=self.mime)\n        return chunk.encode(self.output_encoding, 'replace')", "is_method": true, "class_name": "PrettyStream", "function_description": "Core method of PrettyStream that processes and reformats message body chunks, converting them between encodings and applying specific formatting for consistent output handling."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/streams.py", "function": "iter_body", "line_number": 183, "body": "def iter_body(self) -> Iterable[bytes]:\n        # Read the whole body before prettifying it,\n        # but bail out immediately if the body is binary.\n        converter = None\n        body = bytearray()\n\n        for chunk in self.msg.iter_body(self.CHUNK_SIZE):\n            if not converter and b'\\0' in chunk:\n                converter = self.conversion.get_converter(self.mime)\n                if not converter:\n                    raise BinarySuppressedError()\n            body.extend(chunk)\n\n        if converter:\n            self.mime, body = converter.convert(body)\n\n        yield self.process_body(body)", "is_method": true, "class_name": "BufferedPrettyStream", "function_description": "Utility method of BufferedPrettyStream that reads and optionally converts a message body to a prettified form, handling binary content differently to prevent processing unsupported data types."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/writer.py", "function": "write_message", "line_number": 19, "body": "def write_message(\n    requests_message: Union[requests.PreparedRequest, requests.Response],\n    env: Environment,\n    args: argparse.Namespace,\n    with_headers=False,\n    with_body=False,\n):\n    if not (with_body or with_headers):\n        return\n    write_stream_kwargs = {\n        'stream': build_output_stream_for_message(\n            args=args,\n            env=env,\n            requests_message=requests_message,\n            with_body=with_body,\n            with_headers=with_headers,\n        ),\n        # NOTE: `env.stdout` will in fact be `stderr` with `--download`\n        'outfile': env.stdout,\n        'flush': env.stdout_isatty or args.stream\n    }\n    try:\n        if env.is_windows and 'colors' in args.prettify:\n            write_stream_with_colors_win_py3(**write_stream_kwargs)\n        else:\n            write_stream(**write_stream_kwargs)\n    except IOError as e:\n        show_traceback = args.debug or args.traceback\n        if not show_traceback and e.errno == errno.EPIPE:\n            # Ignore broken pipes unless --traceback.\n            env.stderr.write('\\n')\n        else:\n            raise", "is_method": false, "function_description": "Utility function that outputs HTTP request or response messages with optional headers and body, handling platform-specific streaming and error conditions for customizable console display."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/writer.py", "function": "write_stream", "line_number": 54, "body": "def write_stream(\n    stream: BaseStream,\n    outfile: Union[IO, TextIO],\n    flush: bool\n):\n    \"\"\"Write the output stream.\"\"\"\n    try:\n        # Writing bytes so we use the buffer interface (Python 3).\n        buf = outfile.buffer\n    except AttributeError:\n        buf = outfile\n\n    for chunk in stream:\n        buf.write(chunk)\n        if flush:\n            outfile.flush()", "is_method": false, "function_description": "Function that writes data chunks from a stream to a given output file or buffer, optionally flushing the output after each write to ensure immediate data persistence. Useful for streaming data writes to files or IO streams efficiently."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/writer.py", "function": "write_stream_with_colors_win_py3", "line_number": 72, "body": "def write_stream_with_colors_win_py3(\n    stream: 'BaseStream',\n    outfile: TextIO,\n    flush: bool\n):\n    \"\"\"Like `write`, but colorized chunks are written as text\n    directly to `outfile` to ensure it gets processed by colorama.\n    Applies only to Windows with Python 3 and colorized terminal output.\n\n    \"\"\"\n    color = b'\\x1b['\n    encoding = outfile.encoding\n    for chunk in stream:\n        if color in chunk:\n            outfile.write(chunk.decode(encoding))\n        else:\n            outfile.buffer.write(chunk)\n        if flush:\n            outfile.flush()", "is_method": false, "function_description": "Utility function for Windows Python 3 that writes colorized output streams to a file, ensuring ANSI color codes are correctly processed by colorama for colored terminal output."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/writer.py", "function": "build_output_stream_for_message", "line_number": 93, "body": "def build_output_stream_for_message(\n    args: argparse.Namespace,\n    env: Environment,\n    requests_message: Union[requests.PreparedRequest, requests.Response],\n    with_headers: bool,\n    with_body: bool,\n):\n    stream_class, stream_kwargs = get_stream_type_and_kwargs(\n        env=env,\n        args=args,\n    )\n    message_class = {\n        requests.PreparedRequest: HTTPRequest,\n        requests.Response: HTTPResponse,\n    }[type(requests_message)]\n    yield from stream_class(\n        msg=message_class(requests_message),\n        with_headers=with_headers,\n        with_body=with_body,\n        **stream_kwargs,\n    )\n    if (env.stdout_isatty and with_body\n            and not getattr(requests_message, 'is_body_upload_chunk', False)):\n        # Ensure a blank line after the response body.\n        # For terminal output only.\n        yield MESSAGE_SEPARATOR_BYTES", "is_method": false, "function_description": "Function that generates a formatted byte stream of an HTTP request or response message, optionally including headers and body, tailored for terminal output or other environments. Useful for displaying or processing HTTP messages with flexible detail levels."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/writer.py", "function": "get_stream_type_and_kwargs", "line_number": 121, "body": "def get_stream_type_and_kwargs(\n    env: Environment,\n    args: argparse.Namespace\n) -> Tuple[Type['BaseStream'], dict]:\n    \"\"\"Pick the right stream type and kwargs for it based on `env` and `args`.\n\n    \"\"\"\n    if not env.stdout_isatty and not args.prettify:\n        stream_class = RawStream\n        stream_kwargs = {\n            'chunk_size': (\n                RawStream.CHUNK_SIZE_BY_LINE\n                if args.stream\n                else RawStream.CHUNK_SIZE\n            )\n        }\n    elif args.prettify:\n        stream_class = PrettyStream if args.stream else BufferedPrettyStream\n        stream_kwargs = {\n            'env': env,\n            'conversion': Conversion(),\n            'formatting': Formatting(\n                env=env,\n                groups=args.prettify,\n                color_scheme=args.style,\n                explicit_json=args.json,\n                format_options=args.format_options,\n            )\n        }\n    else:\n        stream_class = EncodedStream\n        stream_kwargs = {\n            'env': env\n        }\n\n    return stream_class, stream_kwargs", "is_method": false, "function_description": "Determines and returns the appropriate stream class and its configuration based on the environment and user arguments, facilitating flexible output formatting and streaming behavior."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/formatters/colors.py", "function": "get_lexer", "line_number": 109, "body": "def get_lexer(\n    mime: str,\n    explicit_json=False,\n    body=''\n) -> Optional[Type[Lexer]]:\n    # Build candidate mime type and lexer names.\n    mime_types, lexer_names = [mime], []\n    type_, subtype = mime.split('/', 1)\n    if '+' not in subtype:\n        lexer_names.append(subtype)\n    else:\n        subtype_name, subtype_suffix = subtype.split('+', 1)\n        lexer_names.extend([subtype_name, subtype_suffix])\n        mime_types.extend([\n            '%s/%s' % (type_, subtype_name),\n            '%s/%s' % (type_, subtype_suffix)\n        ])\n\n    # As a last resort, if no lexer feels responsible, and\n    # the subtype contains 'json', take the JSON lexer\n    if 'json' in subtype:\n        lexer_names.append('json')\n\n    # Try to resolve the right lexer.\n    lexer = None\n    for mime_type in mime_types:\n        try:\n            lexer = pygments.lexers.get_lexer_for_mimetype(mime_type)\n            break\n        except ClassNotFound:\n            pass\n    else:\n        for name in lexer_names:\n            try:\n                lexer = pygments.lexers.get_lexer_by_name(name)\n            except ClassNotFound:\n                pass\n\n    if explicit_json and body and (not lexer or isinstance(lexer, TextLexer)):\n        # JSON response with an incorrect Content-Type?\n        try:\n            json.loads(body)  # FIXME: the body also gets parsed in json.py\n        except ValueError:\n            pass  # Nope\n        else:\n            lexer = pygments.lexers.get_lexer_by_name('json')\n\n    return lexer", "is_method": false, "function_description": "Function that determines and returns the appropriate syntax lexer based on a MIME type, optionally verifying JSON content. It aids in syntax highlighting by identifying the correct lexer for given content types."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/formatters/colors.py", "function": "format_headers", "line_number": 74, "body": "def format_headers(self, headers: str) -> str:\n        return pygments.highlight(\n            code=headers,\n            lexer=self.http_lexer,\n            formatter=self.formatter,\n        ).strip()", "is_method": true, "class_name": "ColorFormatter", "function_description": "Core method of the ColorFormatter class that applies syntax highlighting to HTTP header strings, enhancing readability and visual distinction for display purposes."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/formatters/colors.py", "function": "format_body", "line_number": 81, "body": "def format_body(self, body: str, mime: str) -> str:\n        lexer = self.get_lexer_for_body(mime, body)\n        if lexer:\n            body = pygments.highlight(\n                code=body,\n                lexer=lexer,\n                formatter=self.formatter,\n            )\n        return body", "is_method": true, "class_name": "ColorFormatter", "function_description": "Core method of ColorFormatter that applies syntax highlighting to text based on its MIME type, returning a color-formatted string suitable for display in environments supporting rich text."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/formatters/colors.py", "function": "get_lexer_for_body", "line_number": 91, "body": "def get_lexer_for_body(\n        self, mime: str,\n        body: str\n    ) -> Optional[Type[Lexer]]:\n        return get_lexer(\n            mime=mime,\n            explicit_json=self.explicit_json,\n            body=body,\n        )", "is_method": true, "class_name": "ColorFormatter", "function_description": "Utility method in ColorFormatter that selects and returns the appropriate syntax lexer based on the MIME type and content body, facilitating accurate syntax highlighting."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/formatters/colors.py", "function": "get_style_class", "line_number": 102, "body": "def get_style_class(color_scheme: str) -> Type[pygments.style.Style]:\n        try:\n            return pygments.styles.get_style_by_name(color_scheme)\n        except ClassNotFound:\n            return Solarized256Style", "is_method": true, "class_name": "ColorFormatter", "function_description": "Returns the Pygments style class matching a given color scheme name, defaulting to Solarized256Style if the scheme is not found. This enables consistent syntax highlighting styles based on user-specified or fallback color themes."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/formatters/headers.py", "function": "format_headers", "line_number": 10, "body": "def format_headers(self, headers: str) -> str:\n        \"\"\"\n        Sorts headers by name while retaining relative\n        order of multiple headers with the same name.\n\n        \"\"\"\n        lines = headers.splitlines()\n        headers = sorted(lines[1:], key=lambda h: h.split(':')[0])\n        return '\\r\\n'.join(lines[:1] + headers)", "is_method": true, "class_name": "HeadersFormatter", "function_description": "Formats header lines by sorting them alphabetically by header name while preserving the original order of duplicate headers, useful for consistent header organization in protocols like HTTP."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/output/formatters/json.py", "function": "format_body", "line_number": 13, "body": "def format_body(self, body: str, mime: str) -> str:\n        maybe_json = [\n            'json',\n            'javascript',\n            'text',\n        ]\n        if (self.kwargs['explicit_json']\n                or any(token in mime for token in maybe_json)):\n            try:\n                obj = json.loads(body)\n            except ValueError:\n                pass  # Invalid JSON, ignore.\n            else:\n                # Indent, sort keys by name, and avoid\n                # unicode escapes to improve readability.\n                body = json.dumps(\n                    obj=obj,\n                    sort_keys=self.format_options['json']['sort_keys'],\n                    ensure_ascii=False,\n                    indent=self.format_options['json']['indent']\n                )\n        return body", "is_method": true, "class_name": "JSONFormatter", "function_description": "Formats a string as pretty-printed JSON if the MIME type or settings indicate JSON content, enhancing readability by sorting keys and indenting. It supports flexible formatting based on explicit flags or MIME type hints."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/builtin.py", "function": "__call__", "line_number": 15, "body": "def __call__(\n        self,\n        request: requests.PreparedRequest\n    ) -> requests.PreparedRequest:\n        \"\"\"\n        Override username/password serialization to allow unicode.\n\n        See https://github.com/httpie/httpie/issues/212\n\n        \"\"\"\n        # noinspection PyTypeChecker\n        request.headers['Authorization'] = type(self).make_header(\n            self.username, self.password).encode('latin1')\n        return request", "is_method": true, "class_name": "HTTPBasicAuth", "function_description": "Overrides the HTTPBasicAuth call method to properly encode username and password with unicode support, ensuring correct Authorization header formatting for HTTP requests requiring basic authentication."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/builtin.py", "function": "make_header", "line_number": 31, "body": "def make_header(username: str, password: str) -> str:\n        credentials = u'%s:%s' % (username, password)\n        token = b64encode(credentials.encode('utf8')).strip().decode('latin1')\n        return 'Basic %s' % token", "is_method": true, "class_name": "HTTPBasicAuth", "function_description": "Constructs an HTTP Basic Authentication header value by encoding the provided username and password, facilitating authorized HTTP requests requiring basic auth credentials."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/builtin.py", "function": "get_auth", "line_number": 43, "body": "def get_auth(self, username: str, password: str) -> HTTPBasicAuth:\n        return HTTPBasicAuth(username, password)", "is_method": true, "class_name": "BasicAuthPlugin", "function_description": "Utility method of the BasicAuthPlugin class that creates an HTTPBasicAuth object using provided username and password, facilitating HTTP Basic Authentication for API requests or web services."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/builtin.py", "function": "get_auth", "line_number": 53, "body": "def get_auth(\n        self,\n        username: str,\n        password: str\n    ) -> requests.auth.HTTPDigestAuth:\n        return requests.auth.HTTPDigestAuth(username, password)", "is_method": true, "class_name": "DigestAuthPlugin", "function_description": "Provides an HTTP Digest Authentication handler using the supplied username and password, enabling secure authenticated requests in HTTP clients."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/base.py", "function": "format_headers", "line_number": 133, "body": "def format_headers(self, headers: str) -> str:\n        \"\"\"Return processed `headers`\n\n        :param headers: The headers as text.\n\n        \"\"\"\n        return headers", "is_method": true, "class_name": "FormatterPlugin", "function_description": "Returns the given headers text without modification, serving as a placeholder for customized header formatting in the FormatterPlugin class."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/base.py", "function": "format_body", "line_number": 141, "body": "def format_body(self, content: str, mime: str) -> str:\n        \"\"\"Return processed `content`.\n\n        :param mime: E.g., 'application/atom+xml'.\n        :param content: The body content as text\n\n        \"\"\"\n        return content", "is_method": true, "class_name": "FormatterPlugin", "function_description": "Returns the given content as-is without any formatting or processing, serving as a placeholder method in content formatting workflows."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "register", "line_number": 21, "body": "def register(self, *plugins: Type[BasePlugin]):\n        for plugin in plugins:\n            self.append(plugin)", "is_method": true, "class_name": "PluginManager", "function_description": "Core method of PluginManager that registers one or more plugin classes by adding them to the manager's collection, enabling dynamic extension of application functionality through plugin integration."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "unregister", "line_number": 25, "body": "def unregister(self, plugin: Type[BasePlugin]):\n        self.remove(plugin)", "is_method": true, "class_name": "PluginManager", "function_description": "Utility method of PluginManager that removes a specified plugin from the system, effectively unregistering it from active use."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "filter", "line_number": 28, "body": "def filter(self, by_type=Type[BasePlugin]):\n        return [plugin for plugin in self if issubclass(plugin, by_type)]", "is_method": true, "class_name": "PluginManager", "function_description": "Utility method in PluginManager that filters and returns plugins based on a specified plugin type or base class, enabling selective access to plugins matching specific criteria."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "load_installed_plugins", "line_number": 31, "body": "def load_installed_plugins(self):\n        for entry_point_name in ENTRY_POINT_NAMES:\n            for entry_point in iter_entry_points(entry_point_name):\n                plugin = entry_point.load()\n                plugin.package_name = entry_point.dist.key\n                self.register(entry_point.load())", "is_method": true, "class_name": "PluginManager", "function_description": "Method of PluginManager that discovers and loads all installed plugins from predefined entry points, registering them for use within the system. It enables dynamic plugin management by automatically integrating available extensions."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "get_auth_plugins", "line_number": 39, "body": "def get_auth_plugins(self) -> List[Type[AuthPlugin]]:\n        return self.filter(AuthPlugin)", "is_method": true, "class_name": "PluginManager", "function_description": "Utility method of the PluginManager class that retrieves all registered authentication plugins, enabling easy access to components responsible for handling authentication mechanisms."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "get_auth_plugin_mapping", "line_number": 42, "body": "def get_auth_plugin_mapping(self) -> Dict[str, Type[AuthPlugin]]:\n        return {\n            plugin.auth_type: plugin for plugin in self.get_auth_plugins()\n        }", "is_method": true, "class_name": "PluginManager", "function_description": "Provides a mapping of authentication types to their corresponding AuthPlugin classes, enabling efficient lookup and management of authentication plugins within the PluginManager."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "get_auth_plugin", "line_number": 47, "body": "def get_auth_plugin(self, auth_type: str) -> Type[AuthPlugin]:\n        return self.get_auth_plugin_mapping()[auth_type]", "is_method": true, "class_name": "PluginManager", "function_description": "Method of PluginManager that returns the authentication plugin class corresponding to a given authentication type, enabling dynamic retrieval of auth plugins based on type identifiers."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "get_formatters", "line_number": 51, "body": "def get_formatters(self) -> List[Type[FormatterPlugin]]:\n        return self.filter(FormatterPlugin)", "is_method": true, "class_name": "PluginManager", "function_description": "Returns a list of all registered formatter plugins, enabling clients to access and utilize available formatting capabilities within the plugin system."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "get_formatters_grouped", "line_number": 54, "body": "def get_formatters_grouped(self) -> Dict[str, List[Type[FormatterPlugin]]]:\n        return {\n            group_name: list(group)\n            for group_name, group\n            in groupby(self.get_formatters(), key=attrgetter('group_name'))\n        }", "is_method": true, "class_name": "PluginManager", "function_description": "Returns all formatter plugins grouped by their group_name attribute, enabling organized access to formatter types for downstream processing or management within the PluginManager."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "get_converters", "line_number": 61, "body": "def get_converters(self) -> List[Type[ConverterPlugin]]:\n        return self.filter(ConverterPlugin)", "is_method": true, "class_name": "PluginManager", "function_description": "Returns a list of all registered converter plugins, providing access to available converters for data transformation or processing tasks within the PluginManager."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "get_transport_plugins", "line_number": 65, "body": "def get_transport_plugins(self) -> List[Type[TransportPlugin]]:\n        return self.filter(TransportPlugin)", "is_method": true, "class_name": "PluginManager", "function_description": "Method in PluginManager that returns all registered transport plugins by filtering available plugins to those of type TransportPlugin, enabling dynamic retrieval of transport-related extensions."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/plugins/manager.py", "function": "__repr__", "line_number": 68, "body": "def __repr__(self):\n        return f'<PluginManager: {list(self)}>'", "is_method": true, "class_name": "PluginManager", "function_description": "Provides a readable string representation of the PluginManager instance, showing its contained plugins for easy inspection and debugging."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/definition.py", "function": "__contains__", "line_number": 523, "body": "def __contains__(self, item):\n        return item in plugin_manager.get_auth_plugin_mapping()", "is_method": true, "class_name": "_AuthTypeLazyChoices", "function_description": "Checks if a given item exists within the current authentication plugin mappings. This provides a convenient membership test for available authentication types in the plugin system."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/definition.py", "function": "__iter__", "line_number": 526, "body": "def __iter__(self):\n        return iter(sorted(plugin_manager.get_auth_plugin_mapping().keys()))", "is_method": true, "class_name": "_AuthTypeLazyChoices", "function_description": "Provides an iterable over sorted authentication plugin names, enabling iteration through available authentication types registered in the system."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "readable_file_arg", "line_number": 179, "body": "def readable_file_arg(filename):\n    try:\n        with open(filename, 'rb'):\n            return filename\n    except IOError as ex:\n        raise argparse.ArgumentTypeError(f'{filename}: {ex.args[1]}')", "is_method": false, "function_description": "Utility function that verifies if a file can be opened for reading and returns the filename; raises an argument parsing error if the file is not accessible, helping validate command-line file inputs."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "parse_format_options", "line_number": 187, "body": "def parse_format_options(s: str, defaults: Optional[dict]) -> dict:\n    \"\"\"\n    Parse `s` and update `defaults` with the parsed values.\n\n    >>> parse_format_options(\n    ... defaults={'json': {'indent': 4, 'sort_keys': True}},\n    ... s='json.indent:2,json.sort_keys:False',\n    ... )\n    {'json': {'indent': 2, 'sort_keys': False}}\n\n    \"\"\"\n    value_map = {\n        'true': True,\n        'false': False,\n    }\n    options = deepcopy(defaults or {})\n    for option in s.split(','):\n        try:\n            path, value = option.lower().split(':')\n            section, key = path.split('.')\n        except ValueError:\n            raise argparse.ArgumentTypeError(f'invalid option {option!r}')\n\n        if value in value_map:\n            parsed_value = value_map[value]\n        else:\n            if value.isnumeric():\n                parsed_value = int(value)\n            else:\n                parsed_value = value\n\n        if defaults is None:\n            options.setdefault(section, {})\n        else:\n            try:\n                default_value = defaults[section][key]\n            except KeyError:\n                raise argparse.ArgumentTypeError(\n                    f'invalid key {path!r}')\n\n            default_type, parsed_type = type(default_value), type(parsed_value)\n            if parsed_type is not default_type:\n                raise argparse.ArgumentTypeError(\n                    'invalid value'\n                    f' {value!r} in {option!r}'\n                    f' (expected {default_type.__name__}'\n                    f' got {parsed_type.__name__})'\n                )\n\n        options[section][key] = parsed_value\n\n    return options", "is_method": false, "function_description": "Utility function that parses a string of dot-separated option keys and values, updating a nested dictionary of default settings with these parsed values, enforcing type consistency and supporting boolean and integer conversion."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "__eq__", "line_number": 21, "body": "def __eq__(self, other: 'KeyValueArg'):\n        return self.__dict__ == other.__dict__", "is_method": true, "class_name": "KeyValueArg", "function_description": "Overrides equality comparison to determine if two KeyValueArg instances have identical attributes and values."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "__repr__", "line_number": 24, "body": "def __repr__(self):\n        return repr(self.__dict__)", "is_method": true, "class_name": "KeyValueArg", "function_description": "Returns the string representation of the KeyValueArg instance by displaying its internal attribute dictionary. This aids in debugging or inspecting the object's current state."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "__call__", "line_number": 33, "body": "def __call__(self, value: str) -> str:\n        # Session name can be a path or just a name.\n        if (os.path.sep not in value\n                and not VALID_SESSION_NAME_PATTERN.search(value)):\n            raise argparse.ArgumentError(None, self.error_message)\n        return value", "is_method": true, "class_name": "SessionNameValidator", "function_description": "Core method of SessionNameValidator that validates a session name string, ensuring it adheres to a specific pattern or represents a valid path, and raises an error for invalid names."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "__repr__", "line_number": 44, "body": "def __repr__(self):\n        return f\"Escaped({repr(str(self))})\"", "is_method": true, "class_name": "Escaped", "function_description": "Returns a string representation of the Escaped instance, showing its escaped content in a clear, readable format for debugging or logging purposes."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "__call__", "line_number": 64, "body": "def __call__(self, s: str) -> KeyValueArg:\n        \"\"\"Parse raw string arg  and return `self.key_value_class` instance.\n\n        The best of `self.separators` is determined (first found, longest).\n        Back slash escaped characters aren't considered as separators\n        (or parts thereof). Literal back slash characters have to be escaped\n        as well (r'\\\\').\n\n        \"\"\"\n        tokens = self.tokenize(s)\n\n        # Sorting by length ensures that the longest one will be\n        # chosen as it will overwrite any shorter ones starting\n        # at the same position in the `found` dictionary.\n        separators = sorted(self.separators, key=len)\n\n        for i, token in enumerate(tokens):\n\n            if isinstance(token, Escaped):\n                continue\n\n            found = {}\n            for sep in separators:\n                pos = token.find(sep)\n                if pos != -1:\n                    found[pos] = sep\n\n            if found:\n                # Starting first, longest separator found.\n                sep = found[min(found.keys())]\n\n                key, value = token.split(sep, 1)\n\n                # Any preceding tokens are part of the key.\n                key = ''.join(tokens[:i]) + key\n\n                # Any following tokens are part of the value.\n                value += ''.join(tokens[i + 1:])\n\n                break\n\n        else:\n            raise argparse.ArgumentTypeError(f'{s!r} is not a valid value')\n\n        return self.key_value_class(key=key, value=value, sep=sep, orig=s)", "is_method": true, "class_name": "KeyValueArgType", "function_description": "Parses a raw string into a key-value pair based on predefined separators, correctly handling escaped characters. It returns a structured key-value instance for use in command-line argument processing or similar contexts."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "tokenize", "line_number": 110, "body": "def tokenize(self, s: str) -> List[Union[str, Escaped]]:\n        r\"\"\"Tokenize the raw arg string\n\n        There are only two token types - strings and escaped characters:\n\n        >>> KeyValueArgType('=').tokenize(r'foo\\=bar\\\\baz')\n        ['foo', Escaped('='), 'bar', Escaped('\\\\'), 'baz']\n\n        \"\"\"\n        tokens = ['']\n        characters = iter(s)\n        for char in characters:\n            if char == '\\\\':\n                char = next(characters, '')\n                if char not in self.special_characters:\n                    tokens[-1] += '\\\\' + char\n                else:\n                    tokens.extend([Escaped(char), ''])\n            else:\n                tokens[-1] += char\n        return tokens", "is_method": true, "class_name": "KeyValueArgType", "function_description": "Splits a string into a list of plain text segments and escaped special characters, distinguishing between regular and specially escaped tokens for further parsing or processing."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "has_password", "line_number": 136, "body": "def has_password(self) -> bool:\n        return self.value is not None", "is_method": true, "class_name": "AuthCredentials", "function_description": "Utility method of the AuthCredentials class that checks if a password value is set. It enables authentication processes to verify the presence of credentials before proceeding."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "prompt_password", "line_number": 139, "body": "def prompt_password(self, host: str):\n        prompt_text = f'http: password for {self.key}@{host}: '\n        try:\n            self.value = self._getpass(prompt_text)\n        except (EOFError, KeyboardInterrupt):\n            sys.stderr.write('\\n')\n            sys.exit(0)", "is_method": true, "class_name": "AuthCredentials", "function_description": "Utility method of AuthCredentials that securely prompts the user to enter a password for a specified host, capturing and storing it for authentication purposes."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "_getpass", "line_number": 148, "body": "def _getpass(prompt):\n        # To allow easy mocking.\n        return getpass.getpass(str(prompt))", "is_method": true, "class_name": "AuthCredentials", "function_description": "Internal helper function in AuthCredentials that securely prompts the user for sensitive input, such as passwords, supporting easy mocking for testing purposes."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argtypes.py", "function": "__call__", "line_number": 158, "body": "def __call__(self, s):\n        \"\"\"Parse credentials from `s`.\n\n        (\"username\" or \"username:password\").\n\n        \"\"\"\n        try:\n            return super().__call__(s)\n        except argparse.ArgumentTypeError:\n            # No password provided, will prompt for it later.\n            return self.key_value_class(\n                key=s,\n                value=None,\n                sep=SEPARATOR_CREDENTIALS,\n                orig=s\n            )", "is_method": true, "class_name": "AuthCredentialsArgType", "function_description": "Parses an input string into authentication credentials, supporting either \"username\" alone or \"username:password\" format. It handles missing passwords by returning a credential object with a placeholder for later input."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_split_lines", "line_number": 46, "body": "def _split_lines(self, text, width):\n        text = dedent(text).strip() + '\\n\\n'\n        return text.splitlines()", "is_method": true, "class_name": "HTTPieHelpFormatter", "function_description": "Internal helper method of HTTPieHelpFormatter that processes and splits a given text into individual lines after dedenting and trimming, aiding in consistent formatting of help messages."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "parse_args", "line_number": 69, "body": "def parse_args(\n        self,\n        env: Environment,\n        args=None,\n        namespace=None\n    ) -> argparse.Namespace:\n        self.env = env\n        self.args, no_options = super().parse_known_args(args, namespace)\n        if self.args.debug:\n            self.args.traceback = True\n        self.has_stdin_data = (\n            self.env.stdin\n            and not self.args.ignore_stdin\n            and not self.env.stdin_isatty\n        )\n        # Arguments processing and environment setup.\n        self._apply_no_options(no_options)\n        self._process_request_type()\n        self._process_download_options()\n        self._setup_standard_streams()\n        self._process_output_options()\n        self._process_pretty_options()\n        self._process_format_options()\n        self._guess_method()\n        self._parse_items()\n        if self.has_stdin_data:\n            self._body_from_file(self.env.stdin)\n        self._process_url()\n        self._process_auth()\n\n        if self.args.compress:\n            # TODO: allow --compress with --chunked / --multipart\n            if self.args.chunked:\n                self.error('cannot combine --compress and --chunked')\n            if self.args.multipart:\n                self.error('cannot combine --compress and --multipart')\n\n        return self.args", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Parses and processes command-line arguments for HTTPie, integrating environment input and setting up request parameters, data handling, output formatting, and authentication options for HTTP requests."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_process_request_type", "line_number": 108, "body": "def _process_request_type(self):\n        request_type = self.args.request_type\n        self.args.json = request_type is RequestType.JSON\n        self.args.multipart = request_type is RequestType.MULTIPART\n        self.args.form = request_type in {\n            RequestType.FORM,\n            RequestType.MULTIPART,\n        }", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Utility method in HTTPieArgumentParser that sets argument flags based on the specified HTTP request type, indicating if the request should be JSON, multipart, or form data. This enables consistent handling of different request payload formats."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_process_url", "line_number": 117, "body": "def _process_url(self):\n        if not URL_SCHEME_RE.match(self.args.url):\n            if os.path.basename(self.env.program_name) == 'https':\n                scheme = 'https://'\n            else:\n                scheme = self.args.default_scheme + '://'\n\n            # See if we're using curl style shorthand for localhost (:3000/foo)\n            shorthand = re.match(r'^:(?!:)(\\d*)(/?.*)$', self.args.url)\n            if shorthand:\n                port = shorthand.group(1)\n                rest = shorthand.group(2)\n                self.args.url = scheme + 'localhost'\n                if port:\n                    self.args.url += ':' + port\n                self.args.url += rest\n            else:\n                self.args.url = scheme + self.args.url", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Processes and normalizes a URL argument by ensuring it has a proper scheme and expands shorthand localhost syntax, providing a consistent URL format for HTTP request handling."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_print_message", "line_number": 137, "body": "def _print_message(self, message, file=None):\n        # Sneak in our stderr/stdout.\n        file = {\n            sys.stdout: self.env.stdout,\n            sys.stderr: self.env.stderr,\n            None: self.env.stderr\n        }.get(file, file)\n        if not hasattr(file, 'buffer') and isinstance(message, str):\n            message = message.encode(self.env.stdout_encoding)\n        super()._print_message(message, file)", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Utility method in HTTPieArgumentParser that redirects output streams to environment-specific stdout or stderr, ensuring message encoding is consistent before printing."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_setup_standard_streams", "line_number": 148, "body": "def _setup_standard_streams(self):\n        \"\"\"\n        Modify `env.stdout` and `env.stdout_isatty` based on args, if needed.\n\n        \"\"\"\n\n        self.args.output_file_specified = bool(self.args.output_file)\n        if self.args.download:\n            # FIXME: Come up with a cleaner solution.\n            if not self.args.output_file and not self.env.stdout_isatty:\n                # Use stdout as the download output file.\n                self.args.output_file = self.env.stdout\n            # With `--download`, we write everything that would normally go to\n            # `stdout` to `stderr` instead. Let's replace the stream so that\n            # we don't have to use many `if`s throughout the codebase.\n            # The response body will be treated separately.\n            self.env.stdout = self.env.stderr\n            self.env.stdout_isatty = self.env.stderr_isatty\n\n        elif self.args.output_file:\n            # When not `--download`ing, then `--output` simply replaces\n            # `stdout`. The file is opened for appending, which isn't what\n            # we want in this case.\n            self.args.output_file.seek(0)\n            try:\n                self.args.output_file.truncate()\n            except IOError as e:\n                if e.errno == errno.EINVAL:\n                    # E.g. /dev/null on Linux.\n                    pass\n                else:\n                    raise\n            self.env.stdout = self.args.output_file\n            self.env.stdout_isatty = False\n\n        if self.args.quiet:\n            self.env.stderr = self.env.devnull\n            if not (self.args.output_file_specified and not self.args.download):\n                self.env.stdout = self.env.devnull", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Configures standard output and error streams based on command-line arguments, handling file output, download mode, and quiet mode to control where response data and messages are directed."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_process_auth", "line_number": 188, "body": "def _process_auth(self):\n        # TODO: refactor & simplify this method.\n        self.args.auth_plugin = None\n        default_auth_plugin = plugin_manager.get_auth_plugins()[0]\n        auth_type_set = self.args.auth_type is not None\n        url = urlsplit(self.args.url)\n\n        if self.args.auth is None and not auth_type_set:\n            if url.username is not None:\n                # Handle http://username:password@hostname/\n                username = url.username\n                password = url.password or ''\n                self.args.auth = AuthCredentials(\n                    key=username,\n                    value=password,\n                    sep=SEPARATOR_CREDENTIALS,\n                    orig=SEPARATOR_CREDENTIALS.join([username, password])\n                )\n\n        if self.args.auth is not None or auth_type_set:\n            if not self.args.auth_type:\n                self.args.auth_type = default_auth_plugin.auth_type\n            plugin = plugin_manager.get_auth_plugin(self.args.auth_type)()\n\n            if (not self.args.ignore_netrc\n                    and self.args.auth is None\n                    and plugin.netrc_parse):\n                # Only host needed, so it\u2019s OK URL not finalized.\n                netrc_credentials = get_netrc_auth(self.args.url)\n                if netrc_credentials:\n                    self.args.auth = AuthCredentials(\n                        key=netrc_credentials[0],\n                        value=netrc_credentials[1],\n                        sep=SEPARATOR_CREDENTIALS,\n                        orig=SEPARATOR_CREDENTIALS.join(netrc_credentials)\n                    )\n\n            if plugin.auth_require and self.args.auth is None:\n                self.error('--auth required')\n\n            plugin.raw_auth = self.args.auth\n            self.args.auth_plugin = plugin\n            already_parsed = isinstance(self.args.auth, AuthCredentials)\n\n            if self.args.auth is None or not plugin.auth_parse:\n                self.args.auth = plugin.get_auth()\n            else:\n                if already_parsed:\n                    # from the URL\n                    credentials = self.args.auth\n                else:\n                    credentials = parse_auth(self.args.auth)\n\n                if (not credentials.has_password()\n                        and plugin.prompt_password):\n                    if self.args.ignore_stdin:\n                        # Non-tty stdin read by now\n                        self.error(\n                            'Unable to prompt for passwords because'\n                            ' --ignore-stdin is set.'\n                        )\n                    credentials.prompt_password(url.netloc)\n                self.args.auth = plugin.get_auth(\n                    username=credentials.key,\n                    password=credentials.value,\n                )\n        if not self.args.auth and self.args.ignore_netrc:\n            # Set a no-op auth to force requests to ignore .netrc\n            # <https://github.com/psf/requests/issues/2773#issuecomment-174312831>\n            self.args.auth = ExplicitNullAuth()", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Processes and configures authentication credentials for HTTP requests by extracting them from the URL, netrc files, or user input. It ensures the appropriate authentication plugin is set and handles required prompts or errors accordingly."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_apply_no_options", "line_number": 259, "body": "def _apply_no_options(self, no_options):\n        \"\"\"For every `--no-OPTION` in `no_options`, set `args.OPTION` to\n        its default value. This allows for un-setting of options, e.g.,\n        specified in config.\n\n        \"\"\"\n        invalid = []\n\n        for option in no_options:\n            if not option.startswith('--no-'):\n                invalid.append(option)\n                continue\n\n            # --no-option => --option\n            inverted = '--' + option[5:]\n            for action in self._actions:\n                if inverted in action.option_strings:\n                    setattr(self.args, action.dest, action.default)\n                    break\n            else:\n                invalid.append(option)\n\n        if invalid:\n            msg = 'unrecognized arguments: %s'\n            self.error(msg % ' '.join(invalid))", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Method of HTTPieArgumentParser that processes `--no-OPTION` arguments to reset corresponding options to their default values, enabling explicit un-setting of options typically set in configuration. It validates and error-reports unsupported `--no-` arguments."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_body_from_file", "line_number": 285, "body": "def _body_from_file(self, fd):\n        \"\"\"There can only be one source of request data.\n\n        Bytes are always read.\n\n        \"\"\"\n        if self.args.data or self.args.files:\n            self.error('Request body (from stdin or a file) and request '\n                       'data (key=value) cannot be mixed. Pass '\n                       '--ignore-stdin to let key/value take priority. '\n                       'See https://httpie.org/doc#scripting for details.')\n        self.args.data = getattr(fd, 'buffer', fd)", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Private method in HTTPieArgumentParser that assigns raw byte input from a file descriptor to the request body while enforcing that request data sources do not conflict. It supports input validation for request construction consistency."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_guess_method", "line_number": 298, "body": "def _guess_method(self):\n        \"\"\"Set `args.method` if not specified to either POST or GET\n        based on whether the request has data or not.\n\n        \"\"\"\n        if self.args.method is None:\n            # Invoked as `http URL'.\n            assert not self.args.request_items\n            if self.has_stdin_data:\n                self.args.method = HTTP_POST\n            else:\n                self.args.method = HTTP_GET\n\n        # FIXME: False positive, e.g., \"localhost\" matches but is a valid URL.\n        elif not re.match('^[a-zA-Z]+$', self.args.method):\n            # Invoked as `http URL item+'. The URL is now in `args.method`\n            # and the first ITEM is now incorrectly in `args.url`.\n            try:\n                # Parse the URL as an ITEM and store it as the first ITEM arg.\n                self.args.request_items.insert(0, KeyValueArgType(\n                    *SEPARATOR_GROUP_ALL_ITEMS).__call__(self.args.url))\n\n            except argparse.ArgumentTypeError as e:\n                if self.args.traceback:\n                    raise\n                self.error(e.args[0])\n\n            else:\n                # Set the URL correctly\n                self.args.url = self.args.method\n                # Infer the method\n                has_data = (\n                    self.has_stdin_data\n                    or any(\n                        item.sep in SEPARATOR_GROUP_DATA_ITEMS\n                        for item in self.args.request_items)\n                )\n                self.args.method = HTTP_POST if has_data else HTTP_GET", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Automatically determines and sets the HTTP method (POST or GET) for a request based on the presence of input data or request items when no method is explicitly specified. It also corrects misinterpreted URL and request arguments to ensure proper HTTP method inference."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_parse_items", "line_number": 337, "body": "def _parse_items(self):\n        \"\"\"\n        Parse `args.request_items` into `args.headers`, `args.data`,\n        `args.params`, and `args.files`.\n\n        \"\"\"\n        try:\n            request_items = RequestItems.from_args(\n                request_item_args=self.args.request_items,\n                as_form=self.args.form,\n            )\n        except ParseError as e:\n            if self.args.traceback:\n                raise\n            self.error(e.args[0])\n        else:\n            self.args.headers = request_items.headers\n            self.args.data = request_items.data\n            self.args.files = request_items.files\n            self.args.params = request_items.params\n            self.args.multipart_data = request_items.multipart_data\n\n        if self.args.files and not self.args.form:\n            # `http url @/path/to/file`\n            file_fields = list(self.args.files.keys())\n            if file_fields != ['']:\n                self.error(\n                    'Invalid file fields (perhaps you meant --form?): %s'\n                    % ','.join(file_fields))\n\n            fn, fd, ct = self.args.files['']\n            self.args.files = {}\n\n            self._body_from_file(fd)\n\n            if 'Content-Type' not in self.args.headers:\n                content_type = get_content_type(fn)\n                if content_type:\n                    self.args.headers['Content-Type'] = content_type", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Parses raw request input into structured HTTP components such as headers, data, parameters, and files, validating and preparing them for an HTTP request within the HTTPieArgumentParser context."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_process_output_options", "line_number": 377, "body": "def _process_output_options(self):\n        \"\"\"Apply defaults to output options, or validate the provided ones.\n\n        The default output options are stdout-type-sensitive.\n\n        \"\"\"\n\n        def check_options(value, option):\n            unknown = set(value) - OUTPUT_OPTIONS\n            if unknown:\n                self.error('Unknown output options: {0}={1}'.format(\n                    option,\n                    ','.join(unknown)\n                ))\n\n        if self.args.verbose:\n            self.args.all = True\n\n        if self.args.output_options is None:\n            if self.args.verbose:\n                self.args.output_options = ''.join(OUTPUT_OPTIONS)\n            elif self.args.offline:\n                self.args.output_options = OUTPUT_OPTIONS_DEFAULT_OFFLINE\n            elif not self.env.stdout_isatty:\n                self.args.output_options = OUTPUT_OPTIONS_DEFAULT_STDOUT_REDIRECTED\n            else:\n                self.args.output_options = OUTPUT_OPTIONS_DEFAULT\n\n        if self.args.output_options_history is None:\n            self.args.output_options_history = self.args.output_options\n\n        check_options(self.args.output_options, '--print')\n        check_options(self.args.output_options_history, '--history-print')\n\n        if self.args.download and OUT_RESP_BODY in self.args.output_options:\n            # Response body is always downloaded with --download and it goes\n            # through a different routine, so we remove it.\n            self.args.output_options = str(\n                set(self.args.output_options) - set(OUT_RESP_BODY))", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Core method of the HTTPieArgumentParser class that validates and applies default output-related options based on the current command-line arguments, ensuring consistent and correct output behavior for HTTP responses."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_process_pretty_options", "line_number": 417, "body": "def _process_pretty_options(self):\n        if self.args.prettify == PRETTY_STDOUT_TTY_ONLY:\n            self.args.prettify = PRETTY_MAP[\n                'all' if self.env.stdout_isatty else 'none']\n        elif (self.args.prettify and self.env.is_windows\n              and self.args.output_file):\n            self.error('Only terminal output can be colorized on Windows.')\n        else:\n            # noinspection PyTypeChecker\n            self.args.prettify = PRETTY_MAP[self.args.prettify]", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Private method of HTTPieArgumentParser that determines and sets pretty-printing options based on user input, environment conditions, and output destination, ensuring valid and appropriate colorized output configuration."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_process_download_options", "line_number": 428, "body": "def _process_download_options(self):\n        if self.args.offline:\n            self.args.download = False\n            self.args.download_resume = False\n            return\n        if not self.args.download:\n            if self.args.download_resume:\n                self.error('--continue only works with --download')\n        if self.args.download_resume and not (\n                self.args.download and self.args.output_file):\n            self.error('--continue requires --output to be specified')", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Internal method of HTTPieArgumentParser that validates and adjusts download-related command-line options, ensuring consistent and correct use of offline mode, download, resume, and output file flags."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "_process_format_options", "line_number": 440, "body": "def _process_format_options(self):\n        parsed_options = PARSED_DEFAULT_FORMAT_OPTIONS\n        for options_group in self.args.format_options or []:\n            parsed_options = parse_format_options(options_group, defaults=parsed_options)\n        self.args.format_options = parsed_options", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Internal method of HTTPieArgumentParser that processes and merges user-provided format option groups into a consolidated set of formatting options for HTTP requests."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/argparser.py", "function": "check_options", "line_number": 384, "body": "def check_options(value, option):\n            unknown = set(value) - OUTPUT_OPTIONS\n            if unknown:\n                self.error('Unknown output options: {0}={1}'.format(\n                    option,\n                    ','.join(unknown)\n                ))", "is_method": true, "class_name": "HTTPieArgumentParser", "function_description": "Validates that provided output options are known and supported, raising an error for any unrecognized options. This ensures command-line arguments conform to expected output settings."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/dicts.py", "function": "__setitem__", "line_number": 20, "body": "def __setitem__(self, key, value):\n        \"\"\"\n        If `key` is assigned more than once, `self[key]` holds a\n        `list` of all the values.\n\n        This allows having multiple fields with the same name in form\n        data and URL params.\n\n        \"\"\"\n        assert not isinstance(value, list)\n        if key not in self:\n            super().__setitem__(key, value)\n        else:\n            if not isinstance(self[key], list):\n                super().__setitem__(key, [self[key]])\n            self[key].append(value)", "is_method": true, "class_name": "MultiValueOrderedDict", "function_description": "Core method of MultiValueOrderedDict that allows storing multiple values under the same key by converting single values into a list, supporting cases like form data and URL parameters with repeated field names."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/dicts.py", "function": "items", "line_number": 37, "body": "def items(self):\n        for key, values in super().items():\n            if not isinstance(values, list):\n                values = [values]\n            for value in values:\n                yield key, value", "is_method": true, "class_name": "MultiValueOrderedDict", "function_description": "Method of MultiValueOrderedDict that iterates over all key-value pairs, flattening stored lists so each individual value is yielded with its key, facilitating access when multiple values are associated with a single key."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/requestitems.py", "function": "process_header_arg", "line_number": 87, "body": "def process_header_arg(arg: KeyValueArg) -> Optional[str]:\n    return arg.value or None", "is_method": false, "function_description": "This function extracts and returns the string value from a key-value argument, or None if the value is empty, providing a simple utility for processing optional header arguments."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/requestitems.py", "function": "process_empty_header_arg", "line_number": 91, "body": "def process_empty_header_arg(arg: KeyValueArg) -> str:\n    if arg.value:\n        raise ParseError(\n            'Invalid item \"%s\" '\n            '(to specify an empty header use `Header;`)'\n            % arg.orig\n        )\n    return arg.value", "is_method": false, "function_description": "Function that validates a header argument to ensure it is empty, raising an error if a non-empty value is provided; it helps enforce correct syntax for specifying empty headers."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/requestitems.py", "function": "process_query_param_arg", "line_number": 101, "body": "def process_query_param_arg(arg: KeyValueArg) -> str:\n    return arg.value", "is_method": false, "function_description": "Returns the string value stored in a key-value argument object. This function extracts the parameter's content for further processing or use."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/requestitems.py", "function": "process_file_upload_arg", "line_number": 105, "body": "def process_file_upload_arg(arg: KeyValueArg) -> Tuple[str, IO, str]:\n    parts = arg.value.split(SEPARATOR_FILE_UPLOAD_TYPE)\n    filename = parts[0]\n    mime_type = parts[1] if len(parts) > 1 else None\n    try:\n        f = open(os.path.expanduser(filename), 'rb')\n    except IOError as e:\n        raise ParseError('\"%s\": %s' % (arg.orig, e))\n    return (\n        os.path.basename(filename),\n        f,\n        mime_type or get_content_type(filename),\n    )", "is_method": false, "function_description": "Function that parses a file upload argument to extract the filename, open the file as a binary stream, and determine its MIME type, facilitating file handling and content type identification during upload processing."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/requestitems.py", "function": "process_data_item_arg", "line_number": 120, "body": "def process_data_item_arg(arg: KeyValueArg) -> str:\n    return arg.value", "is_method": false, "function_description": "This function extracts and returns the value from a KeyValueArg object, providing a simple interface to access the argument's content. It is useful in contexts where standardized retrieval of argument values is needed."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/requestitems.py", "function": "process_data_embed_file_contents_arg", "line_number": 124, "body": "def process_data_embed_file_contents_arg(arg: KeyValueArg) -> str:\n    return load_text_file(arg)", "is_method": false, "function_description": "This function processes an input argument representing a key-value pair and returns the contents of a text file specified by that argument. It serves as a utility to extract file data from structured input parameters."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/requestitems.py", "function": "process_data_embed_raw_json_file_arg", "line_number": 128, "body": "def process_data_embed_raw_json_file_arg(arg: KeyValueArg) -> JSONType:\n    contents = load_text_file(arg)\n    value = load_json(arg, contents)\n    return value", "is_method": false, "function_description": "Function that loads and parses JSON content from a file specified by a key-value argument, providing structured data for further processing."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/requestitems.py", "function": "process_data_raw_json_embed_arg", "line_number": 134, "body": "def process_data_raw_json_embed_arg(arg: KeyValueArg) -> JSONType:\n    value = load_json(arg, arg.value)\n    return value", "is_method": false, "function_description": "Function that parses and returns JSON data from a given argument, providing a standardized way to handle raw JSON inputs for downstream processing."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/requestitems.py", "function": "load_text_file", "line_number": 139, "body": "def load_text_file(item: KeyValueArg) -> str:\n    path = item.value\n    try:\n        with open(os.path.expanduser(path), 'rb') as f:\n            return f.read().decode()\n    except IOError as e:\n        raise ParseError('\"%s\": %s' % (item.orig, e))\n    except UnicodeDecodeError:\n        raise ParseError(\n            '\"%s\": cannot embed the content of \"%s\",'\n            ' not a UTF8 or ASCII-encoded text file'\n            % (item.orig, item.value)\n        )", "is_method": false, "function_description": "Function that loads and returns the UTF-8 or ASCII text content from a specified file path, raising parsing errors for file access or decoding issues. It provides a safe way to read text files with proper error handling."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/requestitems.py", "function": "load_json", "line_number": 154, "body": "def load_json(arg: KeyValueArg, contents: str) -> JSONType:\n    try:\n        return load_json_preserve_order(contents)\n    except ValueError as e:\n        raise ParseError('\"%s\": %s' % (arg.orig, e))", "is_method": false, "function_description": "Function that loads JSON content while preserving key order and raises a parsing error with context if the input is invalid. It ensures ordered JSON parsing with clear error reporting."}, {"file": "./dataset/RepoExec/test-apps/httpie/httpie/cli/requestitems.py", "function": "from_args", "line_number": 32, "body": "def from_args(\n        cls,\n        request_item_args: List[KeyValueArg],\n        as_form=False,\n    ) -> 'RequestItems':\n        instance = cls(as_form=as_form)\n        rules: Dict[str, Tuple[Callable, dict]] = {\n            SEPARATOR_HEADER: (\n                process_header_arg,\n                instance.headers,\n            ),\n            SEPARATOR_HEADER_EMPTY: (\n                process_empty_header_arg,\n                instance.headers,\n            ),\n            SEPARATOR_QUERY_PARAM: (\n                process_query_param_arg,\n                instance.params,\n            ),\n            SEPARATOR_FILE_UPLOAD: (\n                process_file_upload_arg,\n                instance.files,\n            ),\n            SEPARATOR_DATA_STRING: (\n                process_data_item_arg,\n                instance.data,\n            ),\n            SEPARATOR_DATA_EMBED_FILE_CONTENTS: (\n                process_data_embed_file_contents_arg,\n                instance.data,\n            ),\n            SEPARATOR_DATA_RAW_JSON: (\n                process_data_raw_json_embed_arg,\n                instance.data,\n            ),\n            SEPARATOR_DATA_EMBED_RAW_JSON_FILE: (\n                process_data_embed_raw_json_file_arg,\n                instance.data,\n            ),\n        }\n\n        for arg in request_item_args:\n            processor_func, target_dict = rules[arg.sep]\n            value = processor_func(arg)\n            target_dict[arg.key] = value\n\n            if arg.sep in SEPARATORS_GROUP_MULTIPART:\n                instance.multipart_data[arg.key] = value\n\n        return instance", "is_method": true, "class_name": "RequestItems", "function_description": "Creates and returns a RequestItems instance by parsing a list of key-value arguments into categorized request components like headers, query parameters, files, and data for flexible HTTP request construction."}, {"file": "./dataset/RepoExec/test-apps/httpie/extras/brew-deps.py", "function": "get_package_meta", "line_number": 28, "body": "def get_package_meta(package_name):\n    api_url = f'https://pypi.python.org/pypi/{package_name}/json'\n    resp = requests.get(api_url).json()\n    hasher = hashlib.sha256()\n    for release in resp['urls']:\n        download_url = release['url']\n        if download_url.endswith('.tar.gz'):\n            hasher.update(requests.get(download_url).content)\n            return {\n                'name': package_name,\n                'url': download_url,\n                'sha256': hasher.hexdigest(),\n            }\n    else:\n        raise RuntimeError(f'{package_name}: download not found: {resp}')", "is_method": false, "function_description": "Function that fetches a package's metadata from PyPI, including the tarball URL and its SHA-256 checksum, enabling verification and information retrieval for Python packages."}, {"file": "./dataset/RepoExec/test-apps/httpie/extras/brew-deps.py", "function": "main", "line_number": 45, "body": "def main():\n    package_meta_map = {\n        package_name: get_package_meta(package_name)\n        for package_name in PACKAGES\n    }\n    httpie_meta = package_meta_map.pop('httpie')\n    print()\n    print('  url \"{url}\"'.format(url=httpie_meta['url']))\n    print('  sha256 \"{sha256}\"'.format(sha256=httpie_meta['sha256']))\n    print()\n    for dep_meta in package_meta_map.values():\n        print('  resource \"{name}\" do'.format(name=dep_meta['name']))\n        print('    url \"{url}\"'.format(url=dep_meta['url']))\n        print('    sha256 \"{sha256}\"'.format(sha256=dep_meta['sha256']))\n        print('  end')\n        print('')", "is_method": false, "function_description": "Main script function that gathers metadata for specified packages, then prints formatted URL and SHA256 checksum details for a primary package and its dependencies."}]