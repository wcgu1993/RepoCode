[{"file": "./dataset/RepoExec/test-apps/tornado/maint/circlerefs/circlerefs.py", "function": "main", "line_number": 86, "body": "def main():\n    gc.disable()\n    gc.collect()\n    gc.set_debug(gc.DEBUG_STATS | gc.DEBUG_SAVEALL)\n    print('GC disabled')\n\n    print(\"Start on 8888\")\n    application.listen(8888, '127.0.0.1')\n\n    # Do a little work. Alternately, could leave this script running and\n    # poke at it with a browser.\n    client = httpclient.AsyncHTTPClient()\n    yield client.fetch('http://127.0.0.1:8888/dummy/')\n    yield client.fetch('http://127.0.0.1:8888/dummyasync/', raise_error=False)\n\n    # Now report on the results.\n    resp = yield client.fetch('http://127.0.0.1:8888/collect/')\n    print(resp.body)", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/circlerefs/circlerefs.py", "function": "inner", "line_number": 18, "body": "def inner(level):\n        for item in level:\n            item_id = id(item)\n            if item_id not in garbage_ids:\n                continue\n            if item_id in visited_ids:\n                continue\n            if item_id in stack_ids:\n                candidate = stack[stack.index(item):]\n                candidate.append(item)\n                found.append(candidate)\n                continue\n\n            stack.append(item)\n            stack_ids.add(item_id)\n            inner(gc.get_referents(item))\n            stack.pop()\n            stack_ids.remove(item_id)\n            visited_ids.add(item_id)", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/benchmark/gen_benchmark.py", "function": "e1", "line_number": 26, "body": "def e1():\n    for i in range(10):\n        yield gen.Task(e2)", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/benchmark/gen_benchmark.py", "function": "c2", "line_number": 32, "body": "def c2():\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/benchmark/gen_benchmark.py", "function": "c1", "line_number": 37, "body": "def c1():\n    for i in range(10):\n        yield c2()", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/benchmark/chunk_benchmark.py", "function": "callback", "line_number": 35, "body": "def callback(response):\n        response.rethrow()\n        assert len(response.body) == (options.num_chunks * options.chunk_size)\n        logging.warning(\"fetch completed in %s seconds\", response.request_time)\n        IOLoop.current().stop()", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/benchmark/template_benchmark.py", "function": "render", "line_number": 56, "body": "def render():\n    tmpl.generate(**context)", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/benchmark/template_benchmark.py", "function": "main", "line_number": 60, "body": "def main():\n    parse_command_line()\n    if options.dump:\n        print(tmpl.code)\n        sys.exit(0)\n    t = Timer(render)\n    results = t.timeit(options.num) / options.num\n    print('%0.3f ms per iteration' % (results * 1000))", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/benchmark/benchmark.py", "function": "main", "line_number": 62, "body": "def main():\n    parse_command_line()\n    if options.ioloop:\n        IOLoop.configure(options.ioloop)\n    for i in xrange(options.num_runs):\n        run()", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/benchmark/benchmark.py", "function": "_log", "line_number": 54, "body": "def _log(self):\n        pass", "is_method": true, "class_name": "RootHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/benchmark/parsing_benchmark.py", "function": "headers_split_re", "line_number": 30, "body": "def headers_split_re(headers: str) -> None:\n    for line in _CRLF_RE.split(headers):\n        pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/benchmark/parsing_benchmark.py", "function": "headers_split_simple", "line_number": 35, "body": "def headers_split_simple(headers: str) -> None:\n    for line in headers.split(\"\\n\"):\n        if line.endswith(\"\\r\"):\n            line = line[:-1]", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/test/websocket/client.py", "function": "main", "line_number": 38, "body": "def main():\n    parse_command_line()\n\n    IOLoop.instance().add_callback(run_tests)\n\n    IOLoop.instance().start()", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/test/redbot/red_test.py", "function": "work", "line_number": 119, "body": "def work():\n            red.run(thor.stop)\n            thor.run()\n            self.io_loop.add_callback(self.stop)", "is_method": true, "class_name": "TestMixin", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/maint/scripts/test_resolvers.py", "function": "main", "line_number": 25, "body": "def main():\n    args = parse_command_line()\n\n    if not args:\n        args = ['localhost', 'www.google.com',\n                'www.facebook.com', 'www.dropbox.com']\n\n    resolvers = [Resolver(), ThreadedResolver()]\n\n    if twisted is not None:\n        from tornado.platform.twisted import TwistedResolver\n        resolvers.append(TwistedResolver())\n\n    if pycares is not None:\n        from tornado.platform.caresresolver import CaresResolver\n        resolvers.append(CaresResolver())\n\n    family = {\n        'unspec': socket.AF_UNSPEC,\n        'inet': socket.AF_INET,\n        'inet6': socket.AF_INET6,\n    }[options.family]\n\n    for host in args:\n        print('Resolving %s' % host)\n        for resolver in resolvers:\n            addrinfo = yield resolver.resolve(host, 80, family)\n            print('%s: %s' % (resolver.__class__.__name__,\n                              pprint.pformat(addrinfo)))\n        print()", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/demos/websocket/chatdemo.py", "function": "main", "line_number": 94, "body": "def main():\n    tornado.options.parse_command_line()\n    app = Application()\n    app.listen(options.port)\n    tornado.ioloop.IOLoop.current().start()", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/demos/twitter/twitterdemo.py", "function": "main", "line_number": 89, "body": "def main():\n    parse_command_line(final=False)\n    parse_config_file(options.config_file)\n\n    app = Application(\n        [(\"/\", MainHandler), (\"/login\", LoginHandler), (\"/logout\", LogoutHandler)],\n        login_url=\"/login\",\n        **options.group_dict(\"application\")\n    )\n    app.listen(options.port)\n\n    logging.info(\"Listening on http://localhost:%d\" % options.port)\n    IOLoop.current().start()", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/demos/tcpecho/client.py", "function": "send_message", "line_number": 14, "body": "def send_message():\n    stream = yield TCPClient().connect(options.host, options.port)\n    yield stream.write((options.message + \"\\n\").encode())\n    print(\"Sent to server:\", options.message)\n    reply = yield stream.read_until(b\"\\n\")\n    print(\"Response from server:\", reply.decode().strip())", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/routing.py", "function": "_unquote_or_none", "line_number": 699, "body": "def _unquote_or_none(s: str) -> bytes:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/routing.py", "function": "_unquote_or_none", "line_number": 704, "body": "def _unquote_or_none(s: None) -> None:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/routing.py", "function": "find_handler", "line_number": 193, "body": "def find_handler(\n        self, request: httputil.HTTPServerRequest, **kwargs: Any\n    ) -> Optional[httputil.HTTPMessageDelegate]:\n        \"\"\"Must be implemented to return an appropriate instance of `~.httputil.HTTPMessageDelegate`\n        that can serve the request.\n        Routing implementations may pass additional kwargs to extend the routing logic.\n\n        :arg httputil.HTTPServerRequest request: current HTTP request.\n        :arg kwargs: additional keyword arguments passed by routing implementation.\n        :returns: an instance of `~.httputil.HTTPMessageDelegate` that will be used to\n            process the request.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "Router", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/routing.py", "function": "reverse_url", "line_number": 218, "body": "def reverse_url(self, name: str, *args: Any) -> Optional[str]:\n        \"\"\"Returns url string for a given route name and arguments\n        or ``None`` if no match is found.\n\n        :arg str name: route name.\n        :arg args: url parameters.\n        :returns: parametrized url string for a given route name (or ``None``).\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "ReversibleRouter", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/routing.py", "function": "match", "line_number": 493, "body": "def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]:\n        \"\"\"Matches current instance against the request.\n\n        :arg httputil.HTTPServerRequest request: current HTTP request\n        :returns: a dict of parameters to be passed to the target handler\n            (for example, ``handler_kwargs``, ``path_args``, ``path_kwargs``\n            can be passed for proper `~.web.RequestHandler` instantiation).\n            An empty dict is a valid (and common) return value to indicate a match\n            when the argument-passing features are not used.\n            ``None`` must be returned to indicate that there is no match.\"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "Matcher", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/routing.py", "function": "reverse", "line_number": 505, "body": "def reverse(self, *args: Any) -> Optional[str]:\n        \"\"\"Reconstructs full url from matcher instance and additional arguments.\"\"\"\n        return None", "is_method": true, "class_name": "Matcher", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/escape.py", "function": "url_unescape", "line_number": 107, "body": "def url_unescape(value: Union[str, bytes], encoding: None, plus: bool = True) -> bytes:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/escape.py", "function": "url_unescape", "line_number": 112, "body": "def url_unescape(\n    value: Union[str, bytes], encoding: str = \"utf-8\", plus: bool = True\n) -> str:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/escape.py", "function": "utf8", "line_number": 174, "body": "def utf8(value: bytes) -> bytes:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/escape.py", "function": "utf8", "line_number": 179, "body": "def utf8(value: str) -> bytes:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/escape.py", "function": "utf8", "line_number": 184, "body": "def utf8(value: None) -> None:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/escape.py", "function": "to_unicode", "line_number": 205, "body": "def to_unicode(value: str) -> str:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/escape.py", "function": "to_unicode", "line_number": 210, "body": "def to_unicode(value: bytes) -> str:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/escape.py", "function": "to_unicode", "line_number": 215, "body": "def to_unicode(value: None) -> None:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/locks.py", "function": "__enter__", "line_number": 274, "body": "def __enter__(self) -> None:\n        pass", "is_method": true, "class_name": "_ReleasingContextManager", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/locks.py", "function": "__exit__", "line_number": 446, "body": "def __exit__(\n        self,\n        typ: \"Optional[Type[BaseException]]\",\n        value: Optional[BaseException],\n        traceback: Optional[types.TracebackType],\n    ) -> None:\n        self.__enter__()", "is_method": true, "class_name": "Semaphore", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/locks.py", "function": "__exit__", "line_number": 554, "body": "def __exit__(\n        self,\n        typ: \"Optional[Type[BaseException]]\",\n        value: Optional[BaseException],\n        tb: Optional[types.TracebackType],\n    ) -> None:\n        self.__enter__()", "is_method": true, "class_name": "Lock", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/tcpserver.py", "function": "handle_stream", "line_number": 265, "body": "def handle_stream(\n        self, stream: IOStream, address: tuple\n    ) -> Optional[Awaitable[None]]:\n        \"\"\"Override to handle a new `.IOStream` from an incoming connection.\n\n        This method may be a coroutine; if so any exceptions it raises\n        asynchronously will be logged. Accepting of incoming connections\n        will not be blocked by this coroutine.\n\n        If this `TCPServer` is configured for SSL, ``handle_stream``\n        may be called before the SSL handshake has completed. Use\n        `.SSLIOStream.wait_for_handshake` if you need to verify the client's\n        certificate or use NPN/ALPN.\n\n        .. versionchanged:: 4.2\n           Added the option for this method to be a coroutine.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "TCPServer", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/template.py", "function": "resolve_path", "line_number": 437, "body": "def resolve_path(self, name: str, parent_path: Optional[str] = None) -> str:\n        \"\"\"Converts a possibly-relative path to absolute (used internally).\"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "BaseLoader", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/template.py", "function": "_create_template", "line_number": 449, "body": "def _create_template(self, name: str) -> Template:\n        raise NotImplementedError()", "is_method": true, "class_name": "BaseLoader", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/template.py", "function": "generate", "line_number": 508, "body": "def generate(self, writer: \"_CodeWriter\") -> None:\n        raise NotImplementedError()", "is_method": true, "class_name": "_Node", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/httputil.py", "function": "start_request", "line_number": 494, "body": "def start_request(\n        self, server_conn: object, request_conn: \"HTTPConnection\"\n    ) -> \"HTTPMessageDelegate\":\n        \"\"\"This method is called by the server when a new request has started.\n\n        :arg server_conn: is an opaque object representing the long-lived\n            (e.g. tcp-level) connection.\n        :arg request_conn: is a `.HTTPConnection` object for a single\n            request/response exchange.\n\n        This method should return a `.HTTPMessageDelegate`.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "HTTPServerConnectionDelegate", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/httputil.py", "function": "on_close", "line_number": 508, "body": "def on_close(self, server_conn: object) -> None:\n        \"\"\"This method is called when a connection has been closed.\n\n        :arg server_conn: is a server connection that has previously been\n            passed to ``start_request``.\n        \"\"\"\n        pass", "is_method": true, "class_name": "HTTPServerConnectionDelegate", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/httputil.py", "function": "data_received", "line_number": 543, "body": "def data_received(self, chunk: bytes) -> Optional[Awaitable[None]]:\n        \"\"\"Called when a chunk of data has been received.\n\n        May return a `.Future` for flow control.\n        \"\"\"\n        pass", "is_method": true, "class_name": "HTTPMessageDelegate", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/httputil.py", "function": "finish", "line_number": 550, "body": "def finish(self) -> None:\n        \"\"\"Called after the last chunk of data has been received.\"\"\"\n        pass", "is_method": true, "class_name": "HTTPMessageDelegate", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/httputil.py", "function": "on_connection_close", "line_number": 554, "body": "def on_connection_close(self) -> None:\n        \"\"\"Called if the connection is closed without finishing the request.\n\n        If ``headers_received`` is called, either ``finish`` or\n        ``on_connection_close`` will be called, but not both.\n        \"\"\"\n        pass", "is_method": true, "class_name": "HTTPMessageDelegate", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/httputil.py", "function": "write_headers", "line_number": 569, "body": "def write_headers(\n        self,\n        start_line: Union[\"RequestStartLine\", \"ResponseStartLine\"],\n        headers: HTTPHeaders,\n        chunk: Optional[bytes] = None,\n    ) -> \"Future[None]\":\n        \"\"\"Write an HTTP header block.\n\n        :arg start_line: a `.RequestStartLine` or `.ResponseStartLine`.\n        :arg headers: a `.HTTPHeaders` instance.\n        :arg chunk: the first (optional) chunk of data.  This is an optimization\n            so that small responses can be written in the same call as their\n            headers.\n\n        The ``version`` field of ``start_line`` is ignored.\n\n        Returns a future for flow control.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "HTTPConnection", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/httputil.py", "function": "write", "line_number": 593, "body": "def write(self, chunk: bytes) -> \"Future[None]\":\n        \"\"\"Writes a chunk of body data.\n\n        Returns a future for flow control.\n\n        .. versionchanged:: 6.0\n\n           The ``callback`` argument was removed.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "HTTPConnection", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/httputil.py", "function": "finish", "line_number": 604, "body": "def finish(self) -> None:\n        \"\"\"Indicates that the last body data has been written.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "HTTPConnection", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/http1connection.py", "function": "__enter__", "line_number": 56, "body": "def __enter__(self) -> None:\n        pass", "is_method": true, "class_name": "_ExceptionLoggingContext", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/concurrent.py", "function": "future_add_done_callback", "line_number": 234, "body": "def future_add_done_callback(\n    future: \"futures.Future[_T]\", callback: Callable[[\"futures.Future[_T]\"], None]\n) -> None:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/concurrent.py", "function": "future_add_done_callback", "line_number": 241, "body": "def future_add_done_callback(\n    future: \"Future[_T]\", callback: Callable[[\"Future[_T]\"], None]\n) -> None:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/concurrent.py", "function": "shutdown", "line_number": 67, "body": "def shutdown(self, wait: bool = True) -> None:\n        pass", "is_method": true, "class_name": "DummyExecutor", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/concurrent.py", "function": "copy", "line_number": 153, "body": "def copy(future: \"Future[_T]\") -> None:\n        assert future is a\n        if b.done():\n            return\n        if hasattr(a, \"exc_info\") and a.exc_info() is not None:  # type: ignore\n            future_set_exc_info(b, a.exc_info())  # type: ignore\n        elif a.exception() is not None:\n            b.set_exception(a.exception())\n        else:\n            b.set_result(a.result())", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/concurrent.py", "function": "wrapper", "line_number": 120, "body": "def wrapper(self: Any, *args: Any, **kwargs: Any) -> Future:\n            async_future = Future()  # type: Future\n            conc_future = getattr(self, executor).submit(fn, self, *args, **kwargs)\n            chain_future(conc_future, async_future)\n            return async_future", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/util.py", "function": "_initialize", "line_number": 309, "body": "def _initialize(self) -> None:\n        pass", "is_method": true, "class_name": "Configurable", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/util.py", "function": "is_finalizing", "line_number": 57, "body": "def is_finalizing() -> bool:\n            # Not referencing any globals here\n            return L != []", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/httpclient.py", "function": "fetch_impl", "line_number": 309, "body": "def fetch_impl(\n        self, request: \"HTTPRequest\", callback: Callable[[\"HTTPResponse\"], None]\n    ) -> None:\n        raise NotImplementedError()", "is_method": true, "class_name": "AsyncHTTPClient", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/gen.py", "function": "coroutine", "line_number": 173, "body": "def coroutine(func: Callable[..., _T]) -> Callable[..., \"Future[_T]\"]:\n    ...", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/gen.py", "function": "callback", "line_number": 520, "body": "def callback(fut: Future) -> None:\n        unfinished_children.remove(fut)\n        if not unfinished_children:\n            result_list = []\n            for f in children_futs:\n                try:\n                    result_list.append(f.result())\n                except Exception as e:\n                    if future.done():\n                        if not isinstance(e, quiet_exceptions):\n                            app_log.error(\n                                \"Multiple exceptions in yield list\", exc_info=True\n                            )\n                    else:\n                        future_set_exc_info(future, sys.exc_info())\n            if not future.done():\n                if keys is not None:\n                    future_set_result_unless_cancelled(\n                        future, dict(zip(keys, result_list))\n                    )\n                else:\n                    future_set_result_unless_cancelled(future, result_list)", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/gen.py", "function": "timeout_callback", "line_number": 627, "body": "def timeout_callback() -> None:\n        if not result.done():\n            result.set_exception(TimeoutError(\"Timeout\"))\n        # In case the wrapped future goes on to fail, log it.\n        future_add_done_callback(future_converted, error_callback)", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/iostream.py", "function": "close_fd", "line_number": 290, "body": "def close_fd(self) -> None:\n        \"\"\"Closes the file underlying this stream.\n\n        ``close_fd`` is called by `BaseIOStream` and should not be called\n        elsewhere; other users should call `close` instead.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "BaseIOStream", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/iostream.py", "function": "write_to_fd", "line_number": 298, "body": "def write_to_fd(self, data: memoryview) -> int:\n        \"\"\"Attempts to write ``data`` to the underlying file.\n\n        Returns the number of bytes written.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "BaseIOStream", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/iostream.py", "function": "read_from_fd", "line_number": 305, "body": "def read_from_fd(self, buf: Union[bytearray, memoryview]) -> Optional[int]:\n        \"\"\"Attempts to read from the underlying file.\n\n        Reads up to ``len(buf)`` bytes, storing them in the buffer.\n        Returns the number of bytes read. Returns None if there was\n        nothing to read (the socket returned `~errno.EWOULDBLOCK` or\n        equivalent), and zero on EOF.\n\n        .. versionchanged:: 5.0\n\n           Interface redesigned to take a buffer and return a number\n           of bytes instead of a freshly-allocated object.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "BaseIOStream", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/iostream.py", "function": "set_nodelay", "line_number": 664, "body": "def set_nodelay(self, value: bool) -> None:\n        \"\"\"Sets the no-delay flag for this stream.\n\n        By default, data written to TCP streams may be held for a time\n        to make the most efficient use of bandwidth (according to\n        Nagle's algorithm).  The no-delay flag requests that data be\n        written as soon as possible, even if doing so would consume\n        additional bandwidth.\n\n        This flag is currently defined only for TCP-based ``IOStreams``.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        pass", "is_method": true, "class_name": "BaseIOStream", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/iostream.py", "function": "_handle_connect", "line_number": 679, "body": "def _handle_connect(self) -> None:\n        raise NotImplementedError()", "is_method": true, "class_name": "BaseIOStream", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/locale.py", "function": "translate", "line_number": 304, "body": "def translate(\n        self,\n        message: str,\n        plural_message: Optional[str] = None,\n        count: Optional[int] = None,\n    ) -> str:\n        \"\"\"Returns the translation for the given message for this locale.\n\n        If ``plural_message`` is given, you must also provide\n        ``count``. We return ``plural_message`` when ``count != 1``,\n        and we return the singular form for the given message when\n        ``count == 1``.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "Locale", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/locale.py", "function": "pgettext", "line_number": 319, "body": "def pgettext(\n        self,\n        context: str,\n        message: str,\n        plural_message: Optional[str] = None,\n        count: Optional[int] = None,\n    ) -> str:\n        raise NotImplementedError()", "is_method": true, "class_name": "Locale", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/netutil.py", "function": "remove_handler", "line_number": 278, "body": "def remove_handler() -> None:\n        io_loop.remove_handler(sock)\n        removed[0] = True", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/netutil.py", "function": "resolve", "line_number": 339, "body": "def resolve(\n        self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC\n    ) -> Awaitable[List[Tuple[int, Any]]]:\n        \"\"\"Resolves an address.\n\n        The ``host`` argument is a string which may be a hostname or a\n        literal IP address.\n\n        Returns a `.Future` whose result is a list of (family,\n        address) pairs, where address is a tuple suitable to pass to\n        `socket.connect <socket.socket.connect>` (i.e. a ``(host,\n        port)`` pair for IPv4; additional fields may be present for\n        IPv6). If a ``callback`` is passed, it will be run with the\n        result as an argument when it is complete.\n\n        :raises IOError: if the address cannot be resolved.\n\n        .. versionchanged:: 4.4\n           Standardized all implementations to raise `IOError`.\n\n        .. versionchanged:: 6.0 The ``callback`` argument was removed.\n           Use the returned awaitable object instead.\n\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "Resolver", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/netutil.py", "function": "close", "line_number": 365, "body": "def close(self) -> None:\n        \"\"\"Closes the `Resolver`, freeing any resources used.\n\n        .. versionadded:: 3.1\n\n        \"\"\"\n        pass", "is_method": true, "class_name": "Resolver", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/netutil.py", "function": "initialize", "line_number": 458, "body": "def initialize(self) -> None:  # type: ignore\n        super().initialize()", "is_method": true, "class_name": "BlockingResolver", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/netutil.py", "function": "initialize", "line_number": 528, "body": "def initialize(self, resolver: Resolver, mapping: dict) -> None:\n        self.resolver = resolver\n        self.mapping = mapping", "is_method": true, "class_name": "OverrideResolver", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/queues.py", "function": "_init", "line_number": 306, "body": "def _init(self) -> None:\n        self._queue = collections.deque()", "is_method": true, "class_name": "Queue", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/queues.py", "function": "_init", "line_number": 407, "body": "def _init(self) -> None:\n        self._queue = []", "is_method": true, "class_name": "LifoQueue", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/queues.py", "function": "on_timeout", "line_number": 64, "body": "def on_timeout() -> None:\n            if not future.done():\n                future.set_exception(gen.TimeoutError())", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/curl_httpclient.py", "function": "ioctl", "line_number": 482, "body": "def ioctl(cmd: int) -> None:\n                if cmd == curl.IOCMD_RESTARTREAD:  # type: ignore\n                    request_buffer.seek(0)", "is_method": true, "class_name": "CurlAsyncHTTPClient", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/testing.py", "function": "gen_test", "line_number": 514, "body": "def gen_test(\n    *, timeout: Optional[float] = None\n) -> Callable[[Callable[..., Union[Generator, \"Coroutine\"]]], Callable[..., None]]:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/testing.py", "function": "gen_test", "line_number": 521, "body": "def gen_test(func: Callable[..., Union[Generator, \"Coroutine\"]]) -> Callable[..., None]:\n    pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/testing.py", "function": "pre_coroutine", "line_number": 580, "body": "def pre_coroutine(self, *args, **kwargs):\n            # type: (AsyncTestCase, *Any, **Any) -> Union[Generator, Coroutine]\n            # Type comments used to avoid pypy3 bug.\n            result = f(self, *args, **kwargs)\n            if isinstance(result, Generator) or inspect.iscoroutine(result):\n                self._test_generator = result\n            else:\n                self._test_generator = None\n            return result", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/testing.py", "function": "post_coroutine", "line_number": 596, "body": "def post_coroutine(self, *args, **kwargs):\n            # type: (AsyncTestCase, *Any, **Any) -> None\n            try:\n                return self.io_loop.run_sync(\n                    functools.partial(coro, self, *args, **kwargs), timeout=timeout\n                )\n            except TimeoutError as e:\n                # run_sync raises an error with an unhelpful traceback.\n                # If the underlying generator is still running, we can throw the\n                # exception back into it so the stack trace is replaced by the\n                # point where the test is stopped. The only reason the generator\n                # would not be running would be if it were cancelled, which means\n                # a native coroutine, so we can rely on the cr_running attribute.\n                if self._test_generator is not None and getattr(\n                    self._test_generator, \"cr_running\", True\n                ):\n                    self._test_generator.throw(type(e), e)\n                    # In case the test contains an overly broad except\n                    # clause, we may get back here.\n                # Coroutine was stopped or didn't raise a useful stack trace,\n                # so re-raise the original exception which is better than nothing.\n                raise", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/testing.py", "function": "timeout_func", "line_number": 320, "body": "def timeout_func() -> None:\n                    try:\n                        raise self.failureException(\n                            \"Async operation timed out after %s seconds\" % timeout\n                        )\n                    except Exception:\n                        self.__failure = sys.exc_info()\n                    self.stop()", "is_method": true, "class_name": "AsyncTestCase", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "_initialize", "line_number": 235, "body": "def _initialize(self) -> None:\n        pass", "is_method": true, "class_name": "RequestHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "prepare", "line_number": 274, "body": "def prepare(self) -> Optional[Awaitable[None]]:\n        \"\"\"Called at the beginning of a request before  `get`/`post`/etc.\n\n        Override this method to perform common initialization regardless\n        of the request method.\n\n        Asynchronous support: Use ``async def`` or decorate this method with\n        `.gen.coroutine` to make it asynchronous.\n        If this method returns an  ``Awaitable`` execution will not proceed\n        until the ``Awaitable`` is done.\n\n        .. versionadded:: 3.1\n           Asynchronous support.\n        \"\"\"\n        pass", "is_method": true, "class_name": "RequestHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "on_finish", "line_number": 290, "body": "def on_finish(self) -> None:\n        \"\"\"Called after the end of a request.\n\n        Override this method to perform cleanup, logging, etc.\n        This method is a counterpart to `prepare`.  ``on_finish`` may\n        not produce any output, as it is called after the response\n        has been sent to the client.\n        \"\"\"\n        pass", "is_method": true, "class_name": "RequestHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "get_argument", "line_number": 424, "body": "def get_argument(self, name: str, default: str, strip: bool = True) -> str:\n        pass", "is_method": true, "class_name": "RequestHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "get_argument", "line_number": 428, "body": "def get_argument(  # noqa: F811\n        self, name: str, default: _ArgDefaultMarker = _ARG_DEFAULT, strip: bool = True\n    ) -> str:\n        pass", "is_method": true, "class_name": "RequestHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "get_argument", "line_number": 434, "body": "def get_argument(  # noqa: F811\n        self, name: str, default: None, strip: bool = True\n    ) -> Optional[str]:\n        pass", "is_method": true, "class_name": "RequestHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "get_current_user", "line_number": 1347, "body": "def get_current_user(self) -> Any:\n        \"\"\"Override to determine the current user from, e.g., a cookie.\n\n        This method may not be a coroutine.\n        \"\"\"\n        return None", "is_method": true, "class_name": "RequestHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "data_received", "line_number": 1721, "body": "def data_received(self, chunk: bytes) -> Optional[Awaitable[None]]:\n        \"\"\"Implement this method to handle streamed request data.\n\n        Requires the `.stream_request_body` decorator.\n\n        May be a coroutine for flow control.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "RequestHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "wrapper", "line_number": 1894, "body": "def wrapper(  # type: ignore\n        self: RequestHandler, *args, **kwargs\n    ) -> Optional[Awaitable[None]]:\n        if not self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path + \"/\"\n                if self.request.query:\n                    uri += \"?\" + self.request.query\n                self.redirect(uri, permanent=True)\n                return None\n            raise HTTPError(404)\n        return method(self, *args, **kwargs)", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "check_xsrf_cookie", "line_number": 2432, "body": "def check_xsrf_cookie(self) -> None:\n        # POSTs to an ErrorHandler don't actually have side effects,\n        # so we don't need to check the xsrf token.  This allows POSTs\n        # to the wrong url to return a 404 instead of 403.\n        pass", "is_method": true, "class_name": "ErrorHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "set_extra_headers", "line_number": 2901, "body": "def set_extra_headers(self, path: str) -> None:\n        \"\"\"For subclass to add extra headers to the response\"\"\"\n        pass", "is_method": true, "class_name": "StaticFileHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/web.py", "function": "render", "line_number": 3198, "body": "def render(self, *args: Any, **kwargs: Any) -> str:\n        \"\"\"Override in subclasses to return this module's output.\"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "UIModule", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "open", "line_number": 400, "body": "def open(self, *args: str, **kwargs: str) -> Optional[Awaitable[None]]:\n        \"\"\"Invoked when a new WebSocket is opened.\n\n        The arguments to `open` are extracted from the `tornado.web.URLSpec`\n        regular expression, just like the arguments to\n        `tornado.web.RequestHandler.get`.\n\n        `open` may be a coroutine. `on_message` will not be called until\n        `open` has returned.\n\n        .. versionchanged:: 5.1\n\n           ``open`` may be a coroutine.\n        \"\"\"\n        pass", "is_method": true, "class_name": "WebSocketHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "on_message", "line_number": 416, "body": "def on_message(self, message: Union[str, bytes]) -> Optional[Awaitable[None]]:\n        \"\"\"Handle incoming messages on the WebSocket\n\n        This method must be overridden.\n\n        .. versionchanged:: 4.5\n\n           ``on_message`` can be a coroutine.\n        \"\"\"\n        raise NotImplementedError", "is_method": true, "class_name": "WebSocketHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "on_pong", "line_number": 448, "body": "def on_pong(self, data: bytes) -> None:\n        \"\"\"Invoked when the response to a ping frame is received.\"\"\"\n        pass", "is_method": true, "class_name": "WebSocketHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "on_ping", "line_number": 452, "body": "def on_ping(self, data: bytes) -> None:\n        \"\"\"Invoked when the a ping frame is received.\"\"\"\n        pass", "is_method": true, "class_name": "WebSocketHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "on_close", "line_number": 456, "body": "def on_close(self) -> None:\n        \"\"\"Invoked when the WebSocket is closed.\n\n        If the connection was closed cleanly and a status code or reason\n        phrase was supplied, these values will be available as the attributes\n        ``self.close_code`` and ``self.close_reason``.\n\n        .. versionchanged:: 4.0\n\n           Added ``close_code`` and ``close_reason`` attributes.\n        \"\"\"\n        pass", "is_method": true, "class_name": "WebSocketHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "close", "line_number": 671, "body": "def close(self, code: Optional[int] = None, reason: Optional[str] = None) -> None:\n        raise NotImplementedError()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "is_closing", "line_number": 675, "body": "def is_closing(self) -> bool:\n        raise NotImplementedError()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "write_message", "line_number": 683, "body": "def write_message(\n        self, message: Union[str, bytes], binary: bool = False\n    ) -> \"Future[None]\":\n        raise NotImplementedError()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "selected_subprotocol", "line_number": 690, "body": "def selected_subprotocol(self) -> Optional[str]:\n        raise NotImplementedError()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "write_ping", "line_number": 694, "body": "def write_ping(self, data: bytes) -> None:\n        raise NotImplementedError()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "_process_server_headers", "line_number": 702, "body": "def _process_server_headers(\n        self, key: Union[str, bytes], headers: httputil.HTTPHeaders\n    ) -> None:\n        raise NotImplementedError()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "start_pinging", "line_number": 708, "body": "def start_pinging(self) -> None:\n        raise NotImplementedError()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "set_nodelay", "line_number": 716, "body": "def set_nodelay(self, x: bool) -> None:\n        raise NotImplementedError()", "is_method": true, "class_name": "WebSocketProtocol", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "on_pong", "line_number": 1561, "body": "def on_pong(self, data: bytes) -> None:\n        pass", "is_method": true, "class_name": "WebSocketClientConnection", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "on_ping", "line_number": 1564, "body": "def on_ping(self, data: bytes) -> None:\n        pass", "is_method": true, "class_name": "WebSocketClientConnection", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "compress", "line_number": 63, "body": "def compress(self, data: bytes) -> bytes:\n            pass", "is_method": true, "class_name": "_Compressor", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "flush", "line_number": 66, "body": "def flush(self, mode: int) -> bytes:\n            pass", "is_method": true, "class_name": "_Compressor", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "decompress", "line_number": 72, "body": "def decompress(self, data: bytes, max_length: int) -> bytes:\n            pass", "is_method": true, "class_name": "_Decompressor", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "on_ws_connection_close", "line_number": 79, "body": "def on_ws_connection_close(\n            self, close_code: Optional[int] = None, close_reason: Optional[str] = None\n        ) -> None:\n            pass", "is_method": true, "class_name": "_WebSocketDelegate", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "on_message", "line_number": 84, "body": "def on_message(self, message: Union[str, bytes]) -> Optional[\"Awaitable[None]\"]:\n            pass", "is_method": true, "class_name": "_WebSocketDelegate", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "on_ping", "line_number": 87, "body": "def on_ping(self, data: bytes) -> None:\n            pass", "is_method": true, "class_name": "_WebSocketDelegate", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "on_pong", "line_number": 90, "body": "def on_pong(self, data: bytes) -> None:\n            pass", "is_method": true, "class_name": "_WebSocketDelegate", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/websocket.py", "function": "log_exception", "line_number": 93, "body": "def log_exception(\n            self,\n            typ: Optional[Type[BaseException]],\n            value: Optional[BaseException],\n            tb: Optional[TracebackType],\n        ) -> None:\n            pass", "is_method": true, "class_name": "_WebSocketDelegate", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "fileno", "line_number": 67, "body": "def fileno(self) -> int:\n        pass", "is_method": true, "class_name": "_Selectable", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "close", "line_number": 70, "body": "def close(self) -> None:\n        pass", "is_method": true, "class_name": "_Selectable", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "current", "line_number": 233, "body": "def current() -> \"IOLoop\":\n        pass", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "current", "line_number": 238, "body": "def current(instance: bool = True) -> Optional[\"IOLoop\"]:  # noqa: F811\n        pass", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "make_current", "line_number": 279, "body": "def make_current(self) -> None:\n        \"\"\"Makes this the `IOLoop` for the current thread.\n\n        An `IOLoop` automatically becomes current for its thread\n        when it is started, but it is sometimes useful to call\n        `make_current` explicitly before starting the `IOLoop`,\n        so that code run at startup time can find the right\n        instance.\n\n        .. versionchanged:: 4.1\n           An `IOLoop` created while there is no current `IOLoop`\n           will automatically become current.\n\n        .. versionchanged:: 5.0\n           This method also sets the current `asyncio` event loop.\n        \"\"\"\n        # The asyncio event loops override this method.\n        raise NotImplementedError()", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "_clear_current_hook", "line_number": 313, "body": "def _clear_current_hook(self) -> None:\n        \"\"\"Instance method called when an IOLoop ceases to be current.\n\n        May be overridden by subclasses as a counterpart to make_current.\n        \"\"\"\n        pass", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "close", "line_number": 341, "body": "def close(self, all_fds: bool = False) -> None:\n        \"\"\"Closes the `IOLoop`, freeing any resources used.\n\n        If ``all_fds`` is true, all file descriptors registered on the\n        IOLoop will be closed (not just the ones created by the\n        `IOLoop` itself).\n\n        Many applications will only use a single `IOLoop` that runs for the\n        entire lifetime of the process.  In that case closing the `IOLoop`\n        is not necessary since everything will be cleaned up when the\n        process exits.  `IOLoop.close` is provided mainly for scenarios\n        such as unit tests, which create and destroy a large number of\n        ``IOLoops``.\n\n        An `IOLoop` must be completely stopped before it can be closed.  This\n        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must\n        be allowed to return before attempting to call `IOLoop.close()`.\n        Therefore the call to `close` will usually appear just after\n        the call to `start` rather than near the call to `stop`.\n\n        .. versionchanged:: 3.1\n           If the `IOLoop` implementation supports non-integer objects\n           for \"file descriptors\", those objects will have their\n           ``close`` method when ``all_fds`` is true.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "add_handler", "line_number": 369, "body": "def add_handler(\n        self, fd: int, handler: Callable[[int, int], None], events: int\n    ) -> None:\n        pass", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "add_handler", "line_number": 375, "body": "def add_handler(\n        self, fd: _S, handler: Callable[[_S, int], None], events: int\n    ) -> None:\n        pass", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "add_handler", "line_number": 380, "body": "def add_handler(  # noqa: F811\n        self, fd: Union[int, _Selectable], handler: Callable[..., None], events: int\n    ) -> None:\n        \"\"\"Registers the given handler to receive the given events for ``fd``.\n\n        The ``fd`` argument may either be an integer file descriptor or\n        a file-like object with a ``fileno()`` and ``close()`` method.\n\n        The ``events`` argument is a bitwise or of the constants\n        ``IOLoop.READ``, ``IOLoop.WRITE``, and ``IOLoop.ERROR``.\n\n        When an event occurs, ``handler(fd, events)`` will be run.\n\n        .. versionchanged:: 4.0\n           Added the ability to pass file-like objects in addition to\n           raw file descriptors.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "update_handler", "line_number": 399, "body": "def update_handler(self, fd: Union[int, _Selectable], events: int) -> None:\n        \"\"\"Changes the events we listen for ``fd``.\n\n        .. versionchanged:: 4.0\n           Added the ability to pass file-like objects in addition to\n           raw file descriptors.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "remove_handler", "line_number": 408, "body": "def remove_handler(self, fd: Union[int, _Selectable]) -> None:\n        \"\"\"Stop listening for events on ``fd``.\n\n        .. versionchanged:: 4.0\n           Added the ability to pass file-like objects in addition to\n           raw file descriptors.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "start", "line_number": 417, "body": "def start(self) -> None:\n        \"\"\"Starts the I/O loop.\n\n        The loop will run until one of the callbacks calls `stop()`, which\n        will make the loop stop after the current event iteration completes.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "stop", "line_number": 445, "body": "def stop(self) -> None:\n        \"\"\"Stop the I/O loop.\n\n        If the event loop is not currently running, the next call to `start()`\n        will return immediately.\n\n        Note that even after `stop` has been called, the `IOLoop` is not\n        completely stopped until `IOLoop.start` has also returned.\n        Some work that was scheduled before the call to `stop` may still\n        be run before the `IOLoop` shuts down.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "add_callback", "line_number": 629, "body": "def add_callback(self, callback: Callable, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        It is safe to call this method from any thread at any time,\n        except from a signal handler.  Note that this is the **only**\n        method in `IOLoop` that makes this thread-safety guarantee; all\n        other interaction with the `IOLoop` must be done from that\n        `IOLoop`'s thread.  `add_callback()` may be used to transfer\n        control from other threads to the `IOLoop`'s thread.\n\n        To add a callback from a signal handler, see\n        `add_callback_from_signal`.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "add_callback_from_signal", "line_number": 644, "body": "def add_callback_from_signal(\n        self, callback: Callable, *args: Any, **kwargs: Any\n    ) -> None:\n        \"\"\"Calls the given callback on the next I/O loop iteration.\n\n        Safe for use from a Python signal handler; should not be used\n        otherwise.\n        \"\"\"\n        raise NotImplementedError()", "is_method": true, "class_name": "IOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/ioloop.py", "function": "timeout_callback", "line_number": 514, "body": "def timeout_callback() -> None:\n                # If we can cancel the future, do so and wait on it. If not,\n                # Just stop the loop and return with the task still pending.\n                # (If we neither cancel nor wait for the task, a warning\n                # will be logged).\n                assert future_cell[0] is not None\n                if not future_cell[0].cancel():\n                    self.stop()", "is_method": true, "class_name": "IOLoop", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/platform/twisted.py", "function": "_", "line_number": 134, "body": "def _(d: Deferred) -> Future:\n        f = Future()  # type: Future[Any]\n\n        def errback(failure: failure.Failure) -> None:\n            try:\n                failure.raiseException()\n                # Should never happen, but just in case\n                raise Exception(\"errback called without error\")\n            except:\n                future_set_exc_info(f, sys.exc_info())\n\n        d.addCallbacks(f.set_result, errback)\n        return f", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/platform/asyncio.py", "function": "make_current", "line_number": 281, "body": "def make_current(self) -> None:\n        # AsyncIOMainLoop already refers to the current asyncio loop so\n        # nothing to do here.\n        pass", "is_method": true, "class_name": "AsyncIOMainLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/platform/asyncio.py", "function": "fileno", "line_number": 45, "body": "def fileno(self) -> int:\n            pass", "is_method": true, "class_name": "_HasFileno", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/locks_test.py", "function": "test_notify_n_with_timeout", "line_number": 123, "body": "def test_notify_n_with_timeout(self):\n        # Register callbacks 0, 1, 2, and 3. Callback 1 has a timeout.\n        # Wait for that timeout to expire, then do notify(2) and make\n        # sure everyone runs. Verifies that a timed-out callback does\n        # not count against the 'n' argument to notify().\n        c = locks.Condition()\n        self.record_done(c.wait(), 0)\n        self.record_done(c.wait(timedelta(seconds=0.01)), 1)\n        self.record_done(c.wait(), 2)\n        self.record_done(c.wait(), 3)\n\n        # Wait for callback 1 to time out.\n        yield gen.sleep(0.02)\n        self.assertEqual([\"timeout\"], self.history)\n\n        c.notify(2)\n        yield gen.sleep(0.01)\n        self.assertEqual([\"timeout\", 0, 2], self.history)\n        self.assertEqual([\"timeout\", 0, 2], self.history)\n        c.notify()\n        yield\n        self.assertEqual([\"timeout\", 0, 2, 3], self.history)", "is_method": true, "class_name": "ConditionTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/locks_test.py", "function": "callback", "line_number": 31, "body": "def callback(_):\n            if not future.result():\n                # wait() resolved to False, meaning it timed out.\n                self.history.append(\"timeout\")\n            else:\n                self.history.append(key)", "is_method": true, "class_name": "ConditionTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/locks_test.py", "function": "f", "line_number": 473, "body": "def f(idx):\n            with (yield lock.acquire()):\n                history.append(idx)", "is_method": true, "class_name": "LockTests", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/tcpclient_test.py", "function": "resolve", "line_number": 176, "body": "def resolve(self, *args, **kwargs):\n                return Future()", "is_method": true, "class_name": "TimeoutResolver", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/twisted_test.py", "function": "f", "line_number": 180, "body": "def f():\n            # This is simpler than the non-coroutine version, but it cheats\n            # by reading the body in one blob instead of streaming it with\n            # a Protocol.\n            client = Agent(self.reactor)\n            response = yield client.request(b\"GET\", utf8(url))\n            with warnings.catch_warnings():\n                # readBody has a buggy DeprecationWarning in Twisted 15.0:\n                # https://twistedmatrix.com/trac/changeset/43379\n                warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n                body[0] = yield readBody(response)\n            self.stop_loop()", "is_method": true, "class_name": "CompatibilityTests", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/twisted_test.py", "function": "fn", "line_number": 224, "body": "def fn():\n            if False:\n                # inlineCallbacks doesn't work with regular functions;\n                # must have a yield even if it's unreachable.\n                yield\n            returnValue(42)", "is_method": true, "class_name": "ConvertDeferredTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/twisted_test.py", "function": "fn", "line_number": 237, "body": "def fn():\n            if False:\n                yield\n            1 / 0", "is_method": true, "class_name": "ConvertDeferredTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/twisted_test.py", "function": "dataReceived", "line_number": 146, "body": "def dataReceived(self, data):\n                chunks.append(data)", "is_method": true, "class_name": "Accumulator", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/locale_test.py", "function": "test_gettext", "line_number": 60, "body": "def test_gettext(self):\n        tornado.locale.load_gettext_translations(\n            os.path.join(os.path.dirname(__file__), \"gettext_translations\"),\n            \"tornado_test\",\n        )\n        locale = tornado.locale.get(\"fr_FR\")\n        self.assertTrue(isinstance(locale, tornado.locale.GettextLocale))\n        self.assertEqual(locale.translate(\"school\"), u\"\\u00e9cole\")\n        self.assertEqual(locale.pgettext(\"law\", \"right\"), u\"le droit\")\n        self.assertEqual(locale.pgettext(\"good\", \"right\"), u\"le bien\")\n        self.assertEqual(\n            locale.pgettext(\"organization\", \"club\", \"clubs\", 1), u\"le club\"\n        )\n        self.assertEqual(\n            locale.pgettext(\"organization\", \"club\", \"clubs\", 2), u\"les clubs\"\n        )\n        self.assertEqual(locale.pgettext(\"stick\", \"club\", \"clubs\", 1), u\"le b\\xe2ton\")\n        self.assertEqual(locale.pgettext(\"stick\", \"club\", \"clubs\", 2), u\"les b\\xe2tons\")", "is_method": true, "class_name": "TranslationLoaderTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/util_test.py", "function": "function", "line_number": 235, "body": "def function(x, y, callback=None, z=None):\n            pass", "is_method": true, "class_name": "ArgReplacerTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/testing_test.py", "function": "test_gen", "line_number": 122, "body": "def test_gen(self):\n                yield", "is_method": true, "class_name": "Test", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/testing_test.py", "function": "test_gen", "line_number": 154, "body": "def test_gen(self):\n                yield", "is_method": true, "class_name": "Test", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "dummy", "line_number": 632, "body": "def dummy(self):\n        pass", "is_method": true, "class_name": "TestPeriodicCallbackMath", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "schedule_callback", "line_number": 56, "body": "def schedule_callback():\n            self.called = False\n            self.io_loop.add_callback(callback)\n            # Store away the time so we can check if we woke up immediately\n            self.start_time = time.time()", "is_method": true, "class_name": "TestIOLoop", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "target", "line_number": 137, "body": "def target():\n            other_ioloop.add_callback(other_ioloop.stop)\n            other_ioloop.start()\n            closing.set()\n            other_ioloop.close(all_fds=True)", "is_method": true, "class_name": "TestIOLoop", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "t1", "line_number": 199, "body": "def t1():\n            calls[0] = True\n            self.io_loop.remove_timeout(t2_handle)", "is_method": true, "class_name": "TestIOLoop", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "t2", "line_number": 205, "body": "def t2():\n            calls[1] = True", "is_method": true, "class_name": "TestIOLoop", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "f", "line_number": 299, "body": "def f(fd, events):\n            pass", "is_method": true, "class_name": "TestIOLoop", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "callback", "line_number": 315, "body": "def callback():\n            try:\n                self.io_loop.start()\n                returned_from_start[0] = True\n            except Exception:\n                got_exception[0] = True\n            self.stop()", "is_method": true, "class_name": "TestIOLoop", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "sync_func", "line_number": 547, "body": "def sync_func():\n            event.set()", "is_method": true, "class_name": "TestIOLoopFutures", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "f", "line_number": 575, "body": "def f():\n            yield gen.moment\n            raise gen.Return(42)", "is_method": true, "class_name": "TestIOLoopRunSync", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "f", "line_number": 583, "body": "def f():\n            yield gen.moment\n            1 / 0", "is_method": true, "class_name": "TestIOLoopRunSync", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "f", "line_number": 591, "body": "def f():\n            self.assertIs(IOLoop.current(), self.io_loop)", "is_method": true, "class_name": "TestIOLoopRunSync", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "f", "line_number": 598, "body": "def f():\n            yield gen.sleep(1)", "is_method": true, "class_name": "TestIOLoopRunSync", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "f1", "line_number": 605, "body": "def f1():\n            yield gen.moment", "is_method": true, "class_name": "TestIOLoopRunSync", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "mock_random", "line_number": 685, "body": "def mock_random():\n            return random_times.pop(0)", "is_method": true, "class_name": "TestPeriodicCallbackMath", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "handler", "line_number": 158, "body": "def handler(fd, events):\n                self.assertEqual(events, IOLoop.READ)\n                self.stop()", "is_method": true, "class_name": "TestIOLoop", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "handle_read", "line_number": 385, "body": "def handle_read(fd, events):\n                chunks.append(fd.recv(1024))\n                if fd is client:\n                    self.io_loop.remove_handler(server)\n                else:\n                    self.io_loop.remove_handler(client)", "is_method": true, "class_name": "TestIOLoop", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "f", "line_number": 447, "body": "def f():\n                self.current_io_loop = IOLoop.current()\n                assert self.io_loop is not None\n                self.io_loop.stop()", "is_method": true, "class_name": "TestIOLoopCurrent", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/ioloop_test.py", "function": "dummy", "line_number": 482, "body": "def dummy():\n                pass", "is_method": true, "class_name": "TestIOLoopFutures", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "get_handlers", "line_number": 75, "body": "def get_handlers(self):\n        raise NotImplementedError()", "is_method": true, "class_name": "WebTestCase", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "initialize", "line_number": 459, "body": "def initialize(self, test):\n        self.test = test", "is_method": true, "class_name": "ConnectionCloseHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "test_get_current_user_is_lazy", "line_number": 2064, "body": "def test_get_current_user_is_lazy(self):\n        # TODO: Make this test pass. See #820.\n        response = self.fetch(\"/without_user\")\n        self.assertEqual(response.body, b\"False\")", "is_method": true, "class_name": "GetCurrentUserTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "get", "line_number": 1892, "body": "def get(self):\n            1 / 0", "is_method": true, "class_name": "Handler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "log_exception", "line_number": 1895, "body": "def log_exception(self, typ, value, tb):\n            1 / 0", "is_method": true, "class_name": "Handler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "get_user_locale", "line_number": 1974, "body": "def get_user_locale(self):\n            raise NotImplementedError()", "is_method": true, "class_name": "Handler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "get_current_user", "line_number": 1977, "body": "def get_current_user(self):\n            raise NotImplementedError()", "is_method": true, "class_name": "Handler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "body_producer", "line_number": 2396, "body": "def body_producer(write):\n            for i in chunks:\n                yield write(i)", "is_method": true, "class_name": "BaseStreamingRequestFlowControlTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "get", "line_number": 1020, "body": "def get(self):\n                1 / 0", "is_method": true, "class_name": "FailedWriteErrorHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "render", "line_number": 1993, "body": "def render(self):\n                return \"\"", "is_method": true, "class_name": "WithoutUserModule", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "initialize", "line_number": 2239, "body": "def initialize(self, test):\n                self.test = test", "is_method": true, "class_name": "StreamingBodyHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "initialize", "line_number": 2261, "body": "def initialize(self, test):\n                self.test = test", "is_method": true, "class_name": "CloseDetectionHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "get", "line_number": 2975, "body": "def get(self):\n                pass", "is_method": true, "class_name": "RemoveSlashHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/web_test.py", "function": "get", "line_number": 2980, "body": "def get(self):\n                pass", "is_method": true, "class_name": "AddSlashHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "_make_client_iostream", "line_number": 55, "body": "def _make_client_iostream(self):\n        raise NotImplementedError()", "is_method": true, "class_name": "TestIOStreamWebMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "make_iostream_pair", "line_number": 169, "body": "def make_iostream_pair(self, **kwargs):\n        raise NotImplementedError", "is_method": true, "class_name": "TestReadWriteMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "test_small_read_untils_from_large_buffer", "line_number": 555, "body": "def test_small_read_untils_from_large_buffer(self: typing.Any):\n        # 10KB buffer size, 100KB available to read.\n        # Read 1KB at a time and make sure that the buffer is not eagerly\n        # filled.\n        rs, ws = yield self.make_iostream_pair(max_buffer_size=10 * 1024)\n        try:\n            ws.write((b\"a\" * 1023 + b\"\\n\") * 100)\n            for i in range(100):\n                data = yield rs.read_until(b\"\\n\", max_bytes=4096)\n                self.assertEqual(data, b\"a\" * 1023 + b\"\\n\")\n        finally:\n            ws.close()\n            rs.close()", "is_method": true, "class_name": "TestReadWriteMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "test_read_into", "line_number": 588, "body": "def test_read_into(self: typing.Any):\n        rs, ws = yield self.make_iostream_pair()\n\n        def sleep_some():\n            self.io_loop.run_sync(lambda: gen.sleep(0.05))\n\n        try:\n            buf = bytearray(10)\n            fut = rs.read_into(buf)\n            ws.write(b\"hello\")\n            yield gen.sleep(0.05)\n            self.assertTrue(rs.reading())\n            ws.write(b\"world!!\")\n            data = yield fut\n            self.assertFalse(rs.reading())\n            self.assertEqual(data, 10)\n            self.assertEqual(bytes(buf), b\"helloworld\")\n\n            # Existing buffer is fed into user buffer\n            fut = rs.read_into(buf)\n            yield gen.sleep(0.05)\n            self.assertTrue(rs.reading())\n            ws.write(b\"1234567890\")\n            data = yield fut\n            self.assertFalse(rs.reading())\n            self.assertEqual(data, 10)\n            self.assertEqual(bytes(buf), b\"!!12345678\")\n\n            # Existing buffer can satisfy read immediately\n            buf = bytearray(4)\n            ws.write(b\"abcdefghi\")\n            data = yield rs.read_into(buf)\n            self.assertEqual(data, 4)\n            self.assertEqual(bytes(buf), b\"90ab\")\n\n            data = yield rs.read_bytes(7)\n            self.assertEqual(data, b\"cdefghi\")\n        finally:\n            ws.close()\n            rs.close()", "is_method": true, "class_name": "TestReadWriteMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "_make_server_iostream", "line_number": 721, "body": "def _make_server_iostream(self, connection, **kwargs):\n        raise NotImplementedError()", "is_method": true, "class_name": "TestIOStreamMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "_make_client_iostream", "line_number": 724, "body": "def _make_client_iostream(self, connection, **kwargs):\n        raise NotImplementedError()", "is_method": true, "class_name": "TestIOStreamMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "close_callback", "line_number": 358, "body": "def close_callback():\n            closed[0] = True\n            cond.notify()", "is_method": true, "class_name": "TestReadWriteMixin", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "produce", "line_number": 682, "body": "def produce():\n            remaining = nbytes\n            while remaining > 0:\n                size = r.randint(1, min(1000, remaining))\n                data = os.urandom(size)\n                produce_hash.update(data)\n                yield ws.write(data)\n                remaining -= size\n            assert remaining == 0", "is_method": true, "class_name": "TestReadWriteMixin", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "consume", "line_number": 693, "body": "def consume():\n            remaining = nbytes\n            while remaining > 0:\n                if r.random() > 0.5:\n                    # read_bytes()\n                    size = r.randint(1, min(1000, remaining))\n                    data = yield rs.read_bytes(size)\n                    consume_hash.update(data)\n                    remaining -= size\n                else:\n                    # read_into()\n                    size = r.randint(1, min(1000, remaining))\n                    buf = bytearray(size)\n                    n = yield rs.read_into(buf)\n                    assert n == size\n                    consume_hash.update(buf)\n                    remaining -= size\n            assert remaining == 0", "is_method": true, "class_name": "TestReadWriteMixin", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "accept_callback", "line_number": 732, "body": "def accept_callback(connection, address):\n            server_stream_fut.set_result(\n                self._make_server_iostream(connection, **kwargs)\n            )", "is_method": true, "class_name": "TestIOStreamMixin", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "produce", "line_number": 864, "body": "def produce():\n            data = b\"x\" * m\n            for i in range(n):\n                yield server.write(data)", "is_method": true, "class_name": "TestIOStreamMixin", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "consume", "line_number": 870, "body": "def consume():\n            nread = 0\n            while nread < total_bytes:\n                res = yield client.read_bytes(m)\n                nread += len(res)", "is_method": true, "class_name": "TestIOStreamMixin", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "fake_read_from_fd", "line_number": 839, "body": "def fake_read_from_fd():\n                os.close(server.socket.fileno())\n                server.__class__.read_from_fd(server)", "is_method": true, "class_name": "TestIOStreamMixin", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "handle_connection", "line_number": 1089, "body": "def handle_connection(self, stream):\n                yield stream.wait_for_handshake()\n                handshake_future.set_result(None)", "is_method": true, "class_name": "TestServer", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/iostream_test.py", "function": "handle_stream", "line_number": 1119, "body": "def handle_stream(self, stream, address):\n                yield stream.wait_for_handshake()\n                yield stream.wait_for_handshake()\n                handshake_future.set_result(None)", "is_method": true, "class_name": "TestServer", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/websocket_test.py", "function": "on_message", "line_number": 73, "body": "def on_message(self, message):\n        1 / 0", "is_method": true, "class_name": "ErrorInOnMessageHandler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/websocket_test.py", "function": "get_server_compression_options", "line_number": 648, "body": "def get_server_compression_options(self):\n        return None", "is_method": true, "class_name": "CompressionTestMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/websocket_test.py", "function": "get_client_compression_options", "line_number": 651, "body": "def get_client_compression_options(self):\n        return None", "is_method": true, "class_name": "CompressionTestMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/websocket_test.py", "function": "verify_wire_bytes", "line_number": 654, "body": "def verify_wire_bytes(self, bytes_in: int, bytes_out: int) -> None:\n        raise NotImplementedError()", "is_method": true, "class_name": "CompressionTestMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/websocket_test.py", "function": "mask", "line_number": 728, "body": "def mask(self, mask: bytes, data: bytes) -> bytes:\n        raise NotImplementedError()", "is_method": true, "class_name": "MaskFunctionMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/websocket_test.py", "function": "test_mask", "line_number": 731, "body": "def test_mask(self: typing.Any):\n        self.assertEqual(self.mask(b\"abcd\", b\"\"), b\"\")\n        self.assertEqual(self.mask(b\"abcd\", b\"b\"), b\"\\x03\")\n        self.assertEqual(self.mask(b\"abcd\", b\"54321\"), b\"TVPVP\")\n        self.assertEqual(self.mask(b\"ZXCV\", b\"98765432\"), b\"c`t`olpd\")\n        # Include test cases with \\x00 bytes (to ensure that the C\n        # extension isn't depending on null-terminated strings) and\n        # bytes with the high bit set (to smoke out signedness issues).\n        self.assertEqual(\n            self.mask(b\"\\x00\\x01\\x02\\x03\", b\"\\xff\\xfb\\xfd\\xfc\\xfe\\xfa\"),\n            b\"\\xff\\xfa\\xff\\xff\\xfe\\xfb\",\n        )\n        self.assertEqual(\n            self.mask(b\"\\xff\\xfb\\xfd\\xfc\", b\"\\x00\\x01\\x02\\x03\\x04\\x05\"),\n            b\"\\xff\\xfa\\xff\\xff\\xfb\\xfe\",\n        )", "is_method": true, "class_name": "MaskFunctionMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/http1connection_test.py", "function": "data_received", "line_number": 52, "body": "def data_received(self, data):\n                body.append(data)", "is_method": true, "class_name": "Delegate", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/http1connection_test.py", "function": "finish", "line_number": 55, "body": "def finish(self):\n                event.set()", "is_method": true, "class_name": "Delegate", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/simple_httpclient_test.py", "function": "create_client", "line_number": 146, "body": "def create_client(self, **kwargs):\n        raise NotImplementedError()", "is_method": true, "class_name": "SimpleHTTPClientTestMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/simple_httpclient_test.py", "function": "cb", "line_number": 206, "body": "def cb(fut, i=i):\n                    seen.append(i)\n                    self.stop()", "is_method": true, "class_name": "SimpleHTTPClientTestMixin", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/httpclient_test.py", "function": "_clear_representation_headers", "line_number": 111, "body": "def _clear_representation_headers(self):\n        # Tornado strips content-length from 304 responses, but here we\n        # want to simulate servers that include the headers anyway.\n        pass", "is_method": true, "class_name": "ContentLength304Handler", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/httpclient_test.py", "function": "streaming_callback", "line_number": 464, "body": "def streaming_callback(chunk):\n            # All header callbacks are run before any streaming callbacks,\n            # so the header data is available to process the data as it\n            # comes in.\n            self.assertEqual(headers[\"content-type\"], \"text/html; charset=UTF-8\")\n            chunks.append(chunk)", "is_method": true, "class_name": "HTTPClientCommonTestCase", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/httpclient_test.py", "function": "start", "line_number": 768, "body": "def start():\n            self.server_ioloop.run_sync(init_server)\n            self.server_ioloop.start()", "is_method": true, "class_name": "SyncHTTPClientTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/httpclient_test.py", "function": "accept_callback", "line_number": 515, "body": "def accept_callback(conn, address):\n                stream = IOStream(conn)\n                request_data = yield stream.read_until(b\"\\r\\n\\r\\n\")\n                if b\"HTTP/1.\" not in request_data:\n                    self.skipTest(\"requires HTTP/1.x\")\n                yield stream.write(\n                    b\"\"\"\\\nHTTP/1.1 200 OK\nX-XSS-Protection: 1;\n\\tmode=block\n\n\"\"\".replace(\n                        b\"\\n\", b\"\\r\\n\"\n                    )\n                )\n                stream.close()", "is_method": true, "class_name": "HTTPClientCommonTestCase", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/httpclient_test.py", "function": "slow_stop", "line_number": 788, "body": "def slow_stop():\n                yield self.server.close_all_connections()\n                # The number of iterations is difficult to predict. Typically,\n                # one is sufficient, although sometimes it needs more.\n                for i in range(5):\n                    yield\n                self.server_ioloop.stop()", "is_method": true, "class_name": "SyncHTTPClientTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "test_iterator", "line_number": 876, "body": "def test_iterator(self):\n        futures = [Future(), Future(), Future(), Future()]  # type: List[Future[int]]\n\n        self.finish_coroutines(0, futures)\n\n        g = gen.WaitIterator(*futures)\n\n        i = 0\n        while not g.done():\n            try:\n                r = yield g.next()\n            except ZeroDivisionError:\n                self.assertIs(g.current_future, futures[0], \"exception future invalid\")\n            else:\n                if i == 0:\n                    self.assertEqual(r, 24, \"iterator value incorrect\")\n                    self.assertEqual(g.current_index, 2, \"wrong index\")\n                elif i == 2:\n                    self.assertEqual(r, 42, \"iterator value incorrect\")\n                    self.assertEqual(g.current_index, 1, \"wrong index\")\n                elif i == 3:\n                    self.assertEqual(r, 84, \"iterator value incorrect\")\n                    self.assertEqual(g.current_index, 3, \"wrong index\")\n            i += 1", "is_method": true, "class_name": "WaitIteratorTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "test_iterator_async_await", "line_number": 902, "body": "def test_iterator_async_await(self):\n        # Recreate the previous test with py35 syntax. It's a little clunky\n        # because of the way the previous test handles an exception on\n        # a single iteration.\n        futures = [Future(), Future(), Future(), Future()]  # type: List[Future[int]]\n        self.finish_coroutines(0, futures)\n        self.finished = False\n\n        async def f():\n            i = 0\n            g = gen.WaitIterator(*futures)\n            try:\n                async for r in g:\n                    if i == 0:\n                        self.assertEqual(r, 24, \"iterator value incorrect\")\n                        self.assertEqual(g.current_index, 2, \"wrong index\")\n                    else:\n                        raise Exception(\"expected exception on iteration 1\")\n                    i += 1\n            except ZeroDivisionError:\n                i += 1\n            async for r in g:\n                if i == 2:\n                    self.assertEqual(r, 42, \"iterator value incorrect\")\n                    self.assertEqual(g.current_index, 1, \"wrong index\")\n                elif i == 3:\n                    self.assertEqual(r, 84, \"iterator value incorrect\")\n                    self.assertEqual(g.current_index, 3, \"wrong index\")\n                else:\n                    raise Exception(\"didn't expect iteration %d\" % i)\n                i += 1\n            self.finished = True\n\n        yield f()\n        self.assertTrue(self.finished)", "is_method": true, "class_name": "WaitIteratorTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 55, "body": "def f():\n            pass", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 62, "body": "def f():\n            1 / 0", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 69, "body": "def f():\n            yield gen.moment\n            1 / 0", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 91, "body": "def f():\n            yield gen.moment", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 99, "body": "def f():\n            yield None", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 106, "body": "def f():\n            results = yield [self.add_one_async(1), self.add_one_async(2)]\n            self.assertEqual(results, [2, 3])", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 114, "body": "def f():\n            results = yield dict(foo=self.add_one_async(1), bar=self.add_one_async(2))\n            self.assertEqual(results, dict(foo=2, bar=3))", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 122, "body": "def f():\n            # callbacks run at different times\n            responses = yield gen.multi_future(\n                [self.delay(3, \"v1\"), self.delay(1, \"v2\")]\n            )\n            self.assertEqual(responses, [\"v1\", \"v2\"])", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 245, "body": "def f():\n            yield gen.moment\n            raise gen.Return()", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 253, "body": "def f():\n            raise gen.Return(42)", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 267, "body": "def f():\n            yield gen.moment\n            raise gen.Return(42)", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 275, "body": "def f():\n            yield gen.moment\n            raise gen.Return((1, 2))", "is_method": true, "class_name": "GenBasicTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 297, "body": "def f():\n            yield gen.moment", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 308, "body": "def f():\n            yield gen.moment", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 350, "body": "def f():\n            yield gen.moment\n            return 42", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 364, "body": "def f():\n            if True:\n                return 42\n            yield gen.Task(self.io_loop.add_callback)", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f1", "line_number": 408, "body": "def f1():\n            yield gen.moment", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f3", "line_number": 416, "body": "def f3():\n            yield gen.moment\n            raise gen.Return(43)", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 436, "body": "def f():\n            return", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 447, "body": "def f():\n            yield gen.moment\n            return", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 472, "body": "def f():\n            yield gen.moment\n            1 / 0", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f2", "line_number": 510, "body": "def f2():\n            try:\n                yield f1()\n            except ZeroDivisionError:\n                raise gen.Return(42)", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "inner", "line_number": 583, "body": "def inner():\n            class Foo(object):\n                pass\n\n            local_var = Foo()\n            self.local_ref = weakref.ref(local_var)\n\n            def dummy():\n                pass\n\n            yield gen.coroutine(dummy)()\n            raise ValueError(\"Some error\")", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "inner2", "line_number": 597, "body": "def inner2():\n            try:\n                yield inner()\n            except ValueError:\n                pass", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "f", "line_number": 615, "body": "def f():\n            yield gen.moment", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "tester", "line_number": 964, "body": "def tester():\n            fut = Future()  # type: Future[int]\n            weakref_scope[0] = weakref.ref(fut)\n            self.io_loop.add_callback(callback)\n            yield fut", "is_method": true, "class_name": "RunnerGCTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "infinite_coro", "line_number": 981, "body": "def infinite_coro():\n            try:\n                while True:\n                    yield gen.sleep(1e-3)\n                    result.append(True)\n            finally:\n                # coroutine finalizer\n                result.append(None)", "is_method": true, "class_name": "RunnerGCTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "do_something", "line_number": 991, "body": "def do_something():\n            fut = infinite_coro()\n            fut._refcycle = fut  # type: ignore\n            wfut.append(weakref.ref(fut))\n            yield gen.sleep(0.2)", "is_method": true, "class_name": "RunnerGCTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "do_something", "line_number": 1026, "body": "def do_something():\n            fut = asyncio.get_event_loop().create_task(infinite_coro(result))\n            fut._refcycle = fut  # type: ignore\n            wfut.append(weakref.ref(fut))\n            yield gen.sleep(0.2)", "is_method": true, "class_name": "RunnerGCTest", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "dummy", "line_number": 590, "body": "def dummy():\n                pass", "is_method": true, "class_name": "GenCoroutineTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/gen_test.py", "function": "dummy", "line_number": 780, "body": "def dummy():\n                pass", "is_method": true, "class_name": "WithTimeoutTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/concurrent_test.py", "function": "f", "line_number": 129, "body": "def f():\n            result = yield self.client.capitalize(\"hello\")\n            self.assertEqual(result, \"HELLO\")", "is_method": true, "class_name": "ClientTestMixin", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/httpserver_test.py", "function": "get_ssl_version", "line_number": 124, "body": "def get_ssl_version(self):\n        raise NotImplementedError()", "is_method": true, "class_name": "SSLTestMixin", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/httpserver_test.py", "function": "data_received", "line_number": 64, "body": "def data_received(self, chunk):\n            chunks.append(chunk)", "is_method": true, "class_name": "Delegate", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/httpserver_test.py", "function": "body_producer", "line_number": 1100, "body": "def body_producer(write):\n            write(compressed[:20])\n            write(compressed[20:])", "is_method": true, "class_name": "StreamingChunkSizeTest", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/tornado/tornado/test/queues_test.py", "function": "worker", "line_number": 326, "body": "def worker():\n            while True:\n                item = yield q.get()\n                self.accumulator += item\n                q.task_done()\n                yield gen.sleep(random() * 0.01)", "is_method": true, "class_name": "QueueJoinTest", "function_description": "Not sure"}]