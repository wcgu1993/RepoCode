[{"file": "./dataset/RepoExec/test-apps/PySnooper/setup.py", "function": "read_file", "line_number": 7, "body": "def read_file(filename):\n    with open(filename) as file:\n        return file.read()", "is_method": false, "function_description": "Utility function that reads the entire content of a specified file and returns it as a string, facilitating file content retrieval for other processes."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "get_local_reprs", "line_number": 25, "body": "def get_local_reprs(frame, watch=(), custom_repr=(), max_length=None, normalize=False):\n    code = frame.f_code\n    vars_order = (code.co_varnames + code.co_cellvars + code.co_freevars +\n                  tuple(frame.f_locals.keys()))\n\n    result_items = [(key, utils.get_shortish_repr(value, custom_repr,\n                                                  max_length, normalize))\n                    for key, value in frame.f_locals.items()]\n    result_items.sort(key=lambda key_value: vars_order.index(key_value[0]))\n    result = collections.OrderedDict(result_items)\n\n    for variable in watch:\n        result.update(sorted(variable.items(frame, normalize)))\n    return result", "is_method": false, "function_description": "Utility function that extracts and orders local variables' concise representations from a stack frame, optionally including watched variables. It supports customization, normalization, and length control for debugging or introspective purposes."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "get_path_and_source_from_frame", "line_number": 49, "body": "def get_path_and_source_from_frame(frame):\n    globs = frame.f_globals or {}\n    module_name = globs.get('__name__')\n    file_name = frame.f_code.co_filename\n    cache_key = (module_name, file_name)\n    try:\n        return source_and_path_cache[cache_key]\n    except KeyError:\n        pass\n    loader = globs.get('__loader__')\n\n    source = None\n    if hasattr(loader, 'get_source'):\n        try:\n            source = loader.get_source(module_name)\n        except ImportError:\n            pass\n        if source is not None:\n            source = source.splitlines()\n    if source is None:\n        ipython_filename_match = ipython_filename_pattern.match(file_name)\n        if ipython_filename_match:\n            entry_number = int(ipython_filename_match.group(1))\n            try:\n                import IPython\n                ipython_shell = IPython.get_ipython()\n                ((_, _, source_chunk),) = ipython_shell.history_manager. \\\n                                  get_range(0, entry_number, entry_number + 1)\n                source = source_chunk.splitlines()\n            except Exception:\n                pass\n        else:\n            try:\n                with open(file_name, 'rb') as fp:\n                    source = fp.read().splitlines()\n            except utils.file_reading_errors:\n                pass\n    if not source:\n        # We used to check `if source is None` but I found a rare bug where it\n        # was empty, but not `None`, so now we check `if not source`.\n        source = UnavailableSource()\n\n    # If we just read the source from a file, or if the loader did not\n    # apply tokenize.detect_encoding to decode the source into a\n    # string, then we should do that ourselves.\n    if isinstance(source[0], bytes):\n        encoding = 'utf-8'\n        for line in source[:2]:\n            # File coding may be specified. Match pattern from PEP-263\n            # (https://www.python.org/dev/peps/pep-0263/)\n            match = re.search(br'coding[:=]\\s*([-\\w.]+)', line)\n            if match:\n                encoding = match.group(1).decode('ascii')\n                break\n        source = [pycompat.text_type(sline, encoding, 'replace') for sline in\n                  source]\n\n    result = (file_name, source)\n    source_and_path_cache[cache_key] = result\n    return result", "is_method": false, "function_description": "Utility function that retrieves the file path and source code lines for a given stack frame, supporting various sources like module loaders, IPython history, and direct file access with caching for efficiency."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "get_write_function", "line_number": 111, "body": "def get_write_function(output, overwrite):\n    is_path = isinstance(output, (pycompat.PathLike, str))\n    if overwrite and not is_path:\n        raise Exception('`overwrite=True` can only be used when writing '\n                        'content to file.')\n    if output is None:\n        def write(s):\n            stderr = sys.stderr\n            try:\n                stderr.write(s)\n            except UnicodeEncodeError:\n                # God damn Python 2\n                stderr.write(utils.shitcode(s))\n    elif is_path:\n        return FileWriter(output, overwrite).write\n    elif callable(output):\n        write = output\n    else:\n        assert isinstance(output, utils.WritableStream)\n\n        def write(s):\n            output.write(s)\n    return write", "is_method": false, "function_description": "Provides a write function tailored to the given output type, handling strings, file paths with optional overwriting, callable outputs, or writable streams. It enables flexible content writing abstraction across different output destinations."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "__getitem__", "line_number": 42, "body": "def __getitem__(self, i):\n        return u'SOURCE IS UNAVAILABLE'", "is_method": true, "class_name": "UnavailableSource", "function_description": "Returns a constant placeholder string indicating the source is unavailable, regardless of the access index. This method provides a consistent unavailable source message for indexing operations."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "write", "line_number": 141, "body": "def write(self, s):\n        with open(self.path, 'w' if self.overwrite else 'a',\n                  encoding='utf-8') as output_file:\n            output_file.write(s)\n        self.overwrite = False", "is_method": true, "class_name": "FileWriter", "function_description": "Writes a string to a file at the specified path, overwriting or appending based on the overwrite flag. This method manages file content updates with flexible write modes."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "__call__", "line_number": 237, "body": "def __call__(self, function_or_class):\n        if DISABLED:\n            return function_or_class\n\n        if inspect.isclass(function_or_class):\n            return self._wrap_class(function_or_class)\n        else:\n            return self._wrap_function(function_or_class)", "is_method": true, "class_name": "Tracer", "function_description": "Core method of the Tracer class that conditionally wraps a function or class with tracing logic when enabled, providing dynamic instrumentation for monitoring or debugging."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "_wrap_class", "line_number": 246, "body": "def _wrap_class(self, cls):\n        for attr_name, attr in cls.__dict__.items():\n            # Coroutines are functions, but snooping them is not supported\n            # at the moment\n            if pycompat.iscoroutinefunction(attr):\n                continue\n\n            if inspect.isfunction(attr):\n                setattr(cls, attr_name, self._wrap_function(attr))\n        return cls", "is_method": true, "class_name": "Tracer", "function_description": "Wraps all standard functions of a class with a tracing wrapper, excluding coroutine functions, to enable function-level tracing or logging within the Tracer context."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "_wrap_function", "line_number": 257, "body": "def _wrap_function(self, function):\n        self.target_codes.add(function.__code__)\n\n        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)\n\n        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e\n\n        if pycompat.iscoroutinefunction(function):\n            raise NotImplementedError\n        if pycompat.isasyncgenfunction(function):\n            raise NotImplementedError\n        elif inspect.isgeneratorfunction(function):\n            return generator_wrapper\n        else:\n            return simple_wrapper", "is_method": true, "class_name": "Tracer", "function_description": "Provides wrapped versions of synchronous or generator functions to trace their execution within a controlled context, enabling instrumentation of both normal calls and generators for debugging or monitoring purposes."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "write", "line_number": 289, "body": "def write(self, s):\n        s = u'{self.prefix}{s}\\n'.format(**locals())\n        self._write(s)", "is_method": true, "class_name": "Tracer", "function_description": "Method of the Tracer class that writes a given string prefixed with a specified value and followed by a newline, supporting consistent formatted output for tracing or logging purposes."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "__enter__", "line_number": 293, "body": "def __enter__(self):\n        if DISABLED:\n            return\n        thread_global.__dict__.setdefault('depth', -1)\n        calling_frame = inspect.currentframe().f_back\n        if not self._is_internal_frame(calling_frame):\n            calling_frame.f_trace = self.trace\n            self.target_frames.add(calling_frame)\n\n        stack = self.thread_local.__dict__.setdefault(\n            'original_trace_functions', []\n        )\n        stack.append(sys.gettrace())\n        self.start_times[calling_frame] = datetime_module.datetime.now()\n        sys.settrace(self.trace)", "is_method": true, "class_name": "Tracer", "function_description": "Initializes tracing by setting up frame hooks and timing to monitor execution depth and calls for external frames, enabling detailed runtime tracing within the Tracer context."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "__exit__", "line_number": 309, "body": "def __exit__(self, exc_type, exc_value, exc_traceback):\n        if DISABLED:\n            return\n        stack = self.thread_local.original_trace_functions\n        sys.settrace(stack.pop())\n        calling_frame = inspect.currentframe().f_back\n        self.target_frames.discard(calling_frame)\n        self.frame_to_local_reprs.pop(calling_frame, None)\n\n        ### Writing elapsed time: #############################################\n        #                                                                     #\n        start_time = self.start_times.pop(calling_frame)\n        duration = datetime_module.datetime.now() - start_time\n        elapsed_time_string = pycompat.timedelta_format(duration)\n        indent = ' ' * 4 * (thread_global.depth + 1)\n        self.write(\n            '{indent}Elapsed time: {elapsed_time_string}'.format(**locals())\n        )", "is_method": true, "class_name": "Tracer", "function_description": "Utility method for the Tracer class that finalizes tracing by restoring the previous trace function, cleaning up frame references, and logging the elapsed execution time of the traced code block."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "_is_internal_frame", "line_number": 330, "body": "def _is_internal_frame(self, frame):\n        return frame.f_code.co_filename == Tracer.__enter__.__code__.co_filename", "is_method": true, "class_name": "Tracer", "function_description": "Private method in Tracer that checks if a stack frame originates from within the Tracer's own source file, supporting internal tracking or filtering of frames during execution tracing."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "set_thread_info_padding", "line_number": 333, "body": "def set_thread_info_padding(self, thread_info):\n        current_thread_len = len(thread_info)\n        self.thread_info_padding = max(self.thread_info_padding,\n                                       current_thread_len)\n        return thread_info.ljust(self.thread_info_padding)", "is_method": true, "class_name": "Tracer", "function_description": "Utility method of the Tracer class that adjusts and applies consistent padding to thread information strings for aligned display or logging across multiple threads."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "trace", "line_number": 339, "body": "def trace(self, frame, event, arg):\n\n        ### Checking whether we should trace this line: #######################\n        #                                                                     #\n        # We should trace this line either if it's in the decorated function,\n        # or the user asked to go a few levels deeper and we're within that\n        # number of levels deeper.\n\n        if not (frame.f_code in self.target_codes or frame in self.target_frames):\n            if self.depth == 1:\n                # We did the most common and quickest check above, because the\n                # trace function runs so incredibly often, therefore it's\n                # crucial to hyper-optimize it for the common case.\n                return None\n            elif self._is_internal_frame(frame):\n                return None\n            else:\n                _frame_candidate = frame\n                for i in range(1, self.depth):\n                    _frame_candidate = _frame_candidate.f_back\n                    if _frame_candidate is None:\n                        return None\n                    elif _frame_candidate.f_code in self.target_codes or _frame_candidate in self.target_frames:\n                        break\n                else:\n                    return None\n\n        if event == 'call':\n            thread_global.depth += 1\n        indent = ' ' * 4 * thread_global.depth\n\n        #                                                                     #\n        ### Finished checking whether we should trace this line. ##############\n\n        ### Making timestamp: #################################################\n        #                                                                     #\n        if self.normalize:\n            timestamp = ' ' * 15\n        elif self.relative_time:\n            try:\n                start_time = self.start_times[frame]\n            except KeyError:\n                start_time = self.start_times[frame] = \\\n                                                 datetime_module.datetime.now()\n            duration = datetime_module.datetime.now() - start_time\n            timestamp = pycompat.timedelta_format(duration)\n        else:\n            timestamp = pycompat.time_isoformat(\n                datetime_module.datetime.now().time(),\n                timespec='microseconds'\n            )\n        #                                                                     #\n        ### Finished making timestamp. ########################################\n\n        line_no = frame.f_lineno\n        source_path, source = get_path_and_source_from_frame(frame)\n        source_path = source_path if not self.normalize else os.path.basename(source_path)\n        if self.last_source_path != source_path:\n            self.write(u'{indent}Source path:... {source_path}'.\n                       format(**locals()))\n            self.last_source_path = source_path\n        source_line = source[line_no - 1]\n        thread_info = \"\"\n        if self.thread_info:\n            if self.normalize:\n                raise NotImplementedError(\"normalize is not supported with \"\n                                          \"thread_info\")\n            current_thread = threading.current_thread()\n            thread_info = \"{ident}-{name} \".format(\n                ident=current_thread.ident, name=current_thread.getName())\n        thread_info = self.set_thread_info_padding(thread_info)\n\n        ### Reporting newish and modified variables: ##########################\n        #                                                                     #\n        old_local_reprs = self.frame_to_local_reprs.get(frame, {})\n        self.frame_to_local_reprs[frame] = local_reprs = \\\n                                       get_local_reprs(frame,\n                                                       watch=self.watch, custom_repr=self.custom_repr,\n                                                       max_length=self.max_variable_length,\n                                                       normalize=self.normalize,\n                                                       )\n\n        newish_string = ('Starting var:.. ' if event == 'call' else\n                                                            'New var:....... ')\n\n        for name, value_repr in local_reprs.items():\n            if name not in old_local_reprs:\n                self.write('{indent}{newish_string}{name} = {value_repr}'.format(\n                                                                       **locals()))\n            elif old_local_reprs[name] != value_repr:\n                self.write('{indent}Modified var:.. {name} = {value_repr}'.format(\n                                                                   **locals()))\n\n        #                                                                     #\n        ### Finished newish and modified variables. ###########################\n\n\n        ### Dealing with misplaced function definition: #######################\n        #                                                                     #\n        if event == 'call' and source_line.lstrip().startswith('@'):\n            # If a function decorator is found, skip lines until an actual\n            # function definition is found.\n            for candidate_line_no in itertools.count(line_no):\n                try:\n                    candidate_source_line = source[candidate_line_no - 1]\n                except IndexError:\n                    # End of source file reached without finding a function\n                    # definition. Fall back to original source line.\n                    break\n\n                if candidate_source_line.lstrip().startswith('def'):\n                    # Found the def line!\n                    line_no = candidate_line_no\n                    source_line = candidate_source_line\n                    break\n        #                                                                     #\n        ### Finished dealing with misplaced function definition. ##############\n\n        # If a call ends due to an exception, we still get a 'return' event\n        # with arg = None. This seems to be the only way to tell the difference\n        # https://stackoverflow.com/a/12800909/2482744\n        code_byte = frame.f_code.co_code[frame.f_lasti]\n        if not isinstance(code_byte, int):\n            code_byte = ord(code_byte)\n        ended_by_exception = (\n                event == 'return'\n                and arg is None\n                and (opcode.opname[code_byte]\n                     not in ('RETURN_VALUE', 'YIELD_VALUE'))\n        )\n\n        if ended_by_exception:\n            self.write('{indent}Call ended by exception'.\n                       format(**locals()))\n        else:\n            self.write(u'{indent}{timestamp} {thread_info}{event:9} '\n                       u'{line_no:4} {source_line}'.format(**locals()))\n\n        if event == 'return':\n            self.frame_to_local_reprs.pop(frame, None)\n            self.start_times.pop(frame, None)\n            thread_global.depth -= 1\n\n            if not ended_by_exception:\n                return_value_repr = utils.get_shortish_repr(arg,\n                                                            custom_repr=self.custom_repr,\n                                                            max_length=self.max_variable_length,\n                                                            normalize=self.normalize,\n                                                            )\n                self.write('{indent}Return value:.. {return_value_repr}'.\n                           format(**locals()))\n\n        if event == 'exception':\n            exception = '\\n'.join(traceback.format_exception_only(*arg[:2])).strip()\n            if self.max_variable_length:\n                exception = utils.truncate(exception, self.max_variable_length)\n            self.write('{indent}Exception:..... {exception}'.\n                       format(**locals()))\n\n        return self.trace", "is_method": true, "class_name": "Tracer", "function_description": "Core method of the Tracer class that monitors program execution by logging function calls, returns, exceptions, and variable changes with contextual details like timestamps, source code lines, and threading info for debugging and tracing purposes."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "write", "line_number": 117, "body": "def write(s):\n            stderr = sys.stderr\n            try:\n                stderr.write(s)\n            except UnicodeEncodeError:\n                # God damn Python 2\n                stderr.write(utils.shitcode(s))", "is_method": false, "function_description": "Function that writes a string to standard error, handling encoding issues by applying a fallback encoding when necessary to ensure error messages are output correctly."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/tracer.py", "function": "generator_wrapper", "line_number": 266, "body": "def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e", "is_method": true, "class_name": "Tracer", "function_description": "Core method in the Tracer class that wraps a generator function to intercept and manage its execution and communication, enabling tracing or modification of the generator's input/output interaction."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/utils.py", "function": "_check_methods", "line_number": 10, "body": "def _check_methods(C, *methods):\n    mro = C.__mro__\n    for method in methods:\n        for B in mro:\n            if method in B.__dict__:\n                if B.__dict__[method] is None:\n                    return NotImplemented\n                break\n        else:\n            return NotImplemented\n    return True", "is_method": false, "function_description": "Utility function that verifies whether specified methods exist and are properly implemented (not None) in a class or its ancestors, supporting dynamic capability checks in class hierarchies."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/utils.py", "function": "shitcode", "line_number": 44, "body": "def shitcode(s):\n    return ''.join(\n        (c if (0 < ord(c) < 256) else '?') for c in s\n    )", "is_method": false, "function_description": "Function that replaces any character outside the extended ASCII range in a string with a question mark, ensuring the result contains only characters with codes between 1 and 255. This can be used to sanitize or normalize text for systems limited to such characters."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/utils.py", "function": "get_repr_function", "line_number": 50, "body": "def get_repr_function(item, custom_repr):\n    for condition, action in custom_repr:\n        if isinstance(condition, type):\n            condition = lambda x, y=condition: isinstance(x, y)\n        if condition(item):\n            return action\n    return repr", "is_method": false, "function_description": "Utility function that selects a custom string representation function for an item based on specified type or condition mappings, defaulting to Python's built-in repr if no conditions match. Useful for customizing how objects are represented contextually."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/utils.py", "function": "normalize_repr", "line_number": 62, "body": "def normalize_repr(item_repr):\n    \"\"\"Remove memory address (0x...) from a default python repr\"\"\"\n    return DEFAULT_REPR_RE.sub('', item_repr)", "is_method": false, "function_description": "This function cleans a Python object's string representation by removing memory addresses. It provides a standardized, memory-independent representation useful for comparison or display purposes."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/utils.py", "function": "get_shortish_repr", "line_number": 67, "body": "def get_shortish_repr(item, custom_repr=(), max_length=None, normalize=False):\n    repr_function = get_repr_function(item, custom_repr)\n    try:\n        r = repr_function(item)\n    except Exception:\n        r = 'REPR FAILED'\n    r = r.replace('\\r', '').replace('\\n', '')\n    if normalize:\n        r = normalize_repr(r)\n    if max_length:\n        r = truncate(r, max_length)\n    return r", "is_method": false, "function_description": "Utility function that generates a concise, optionally normalized and truncated string representation of an item using customizable representation functions. Useful for controlled display or logging of object summaries without multiline formatting."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/utils.py", "function": "truncate", "line_number": 81, "body": "def truncate(string, max_length):\n    if (max_length is None) or (len(string) <= max_length):\n        return string\n    else:\n        left = (max_length - 3) // 2\n        right = max_length - 3 - left\n        return u'{}...{}'.format(string[:left], string[-right:])", "is_method": false, "function_description": "Utility function that truncates a string to a specified maximum length, preserving the start and end parts with an ellipsis in the middle when truncation is necessary."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/utils.py", "function": "ensure_tuple", "line_number": 90, "body": "def ensure_tuple(x):\n    if isinstance(x, collections_abc.Iterable) and \\\n                                               not isinstance(x, string_types):\n        return tuple(x)\n    else:\n        return (x,)", "is_method": false, "function_description": "Utility function that ensures its input is returned as a tuple, wrapping non-iterables or strings into a single-element tuple while converting other iterables into tuples. Useful for consistent input processing requiring tuple formats."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/utils.py", "function": "__subclasshook__", "line_number": 29, "body": "def __subclasshook__(cls, C):\n        if cls is WritableStream:\n            return _check_methods(C, 'write')\n        return NotImplemented", "is_method": true, "class_name": "WritableStream", "function_description": "Special method enabling isinstance and issubclass checks to verify if a class supports writing by ensuring it implements a 'write' method."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/pycompat.py", "function": "timedelta_format", "line_number": 86, "body": "def timedelta_format(timedelta):\n    time = (datetime_module.datetime.min + timedelta).time()\n    return time_isoformat(time, timespec='microseconds')", "is_method": false, "function_description": "Utility function that converts a timedelta object into an ISO 8601 formatted time string with microsecond precision. It enables consistent and precise time representation of durations."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/pycompat.py", "function": "timedelta_parse", "line_number": 90, "body": "def timedelta_parse(s):\n    hours, minutes, seconds, microseconds = map(\n        int,\n        s.replace('.', ':').split(':')\n    )\n    return datetime_module.timedelta(hours=hours, minutes=minutes,\n                                     seconds=seconds,\n                                     microseconds=microseconds)", "is_method": false, "function_description": "Function that parses a time duration string with hour, minute, second, and microsecond components into a timedelta object for time interval representation and calculations."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/pycompat.py", "function": "time_isoformat", "line_number": 75, "body": "def time_isoformat(time, timespec='microseconds'):\n        assert isinstance(time, datetime_module.time)\n        if timespec != 'microseconds':\n            raise NotImplementedError\n        result = '{:02d}:{:02d}:{:02d}.{:06d}'.format(\n            time.hour, time.minute, time.second, time.microsecond\n        )\n        assert len(result) == 15\n        return result", "is_method": false, "function_description": "Function that formats a time object into an ISO 8601 string with microsecond precision, providing a standardized textual representation of time values."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/pycompat.py", "function": "__fspath__", "line_number": 32, "body": "def __fspath__(self):\n            \"\"\"Return the file system path representation of the object.\"\"\"\n            raise NotImplementedError", "is_method": true, "class_name": "PathLike", "function_description": "Returns the file system path representation of the object. Raises an error if not implemented."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/pycompat.py", "function": "__subclasshook__", "line_number": 37, "body": "def __subclasshook__(cls, subclass):\n            return (\n                hasattr(subclass, '__fspath__') or\n                # Make a concession for older `pathlib` versions:g\n                (hasattr(subclass, 'open') and\n                 'path' in subclass.__name__.lower())\n            )", "is_method": true, "class_name": "PathLike", "function_description": "Special method of PathLike that determines if a class qualifies as a path-like object by checking for a file system path interface or typical path-related attributes. It supports compatibility with various path implementations."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "needs_parentheses", "line_number": 13, "body": "def needs_parentheses(source):\n    def code(s):\n        return compile(s, '<variable>', 'eval').co_code\n\n    return code('{}.x'.format(source)) != code('({}).x'.format(source))", "is_method": false, "function_description": "Utility function that determines if a source expression requires parentheses to preserve evaluation order when accessing an attribute, helping to avoid syntax or semantic ambiguities in dynamically generated code."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "code", "line_number": 14, "body": "def code(s):\n        return compile(s, '<variable>', 'eval').co_code", "is_method": false, "function_description": "Function that compiles a string expression into Python bytecode, returning the raw bytecode sequence suitable for evaluation or analysis purposes."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "items", "line_number": 30, "body": "def items(self, frame, normalize=False):\n        try:\n            main_value = eval(self.code, frame.f_globals or {}, frame.f_locals)\n        except Exception:\n            return ()\n        return self._items(main_value, normalize)", "is_method": true, "class_name": "BaseVariable", "function_description": "Utility method in BaseVariable that evaluates its stored code in a given frame and returns processed items, optionally normalized, based on the evaluation result."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "_fingerprint", "line_number": 42, "body": "def _fingerprint(self):\n        return (type(self), self.source, self.exclude)", "is_method": true, "class_name": "BaseVariable", "function_description": "Returns a unique identifier tuple representing the variable's type, source, and exclusion status for differentiation or comparison purposes."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "__hash__", "line_number": 45, "body": "def __hash__(self):\n        return hash(self._fingerprint)", "is_method": true, "class_name": "BaseVariable", "function_description": "Overrides the default hash behavior using a unique fingerprint, enabling instances of BaseVariable to be used reliably as dictionary keys or in sets."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "__eq__", "line_number": 48, "body": "def __eq__(self, other):\n        return (isinstance(other, BaseVariable) and\n                                       self._fingerprint == other._fingerprint)", "is_method": true, "class_name": "BaseVariable", "function_description": "Defines equality comparison for BaseVariable instances based on their unique fingerprint, enabling consistent identification and comparison of variables within systems using this class."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "_items", "line_number": 54, "body": "def _items(self, main_value, normalize=False):\n        result = [(self.source, utils.get_shortish_repr(main_value, normalize=normalize))]\n        for key in self._safe_keys(main_value):\n            try:\n                if key in self.exclude:\n                    continue\n                value = self._get_value(main_value, key)\n            except Exception:\n                continue\n            result.append((\n                '{}{}'.format(self.unambiguous_source, self._format_key(key)),\n                utils.get_shortish_repr(value)\n            ))\n        return result", "is_method": true, "class_name": "CommonVariable", "function_description": "Provides a list of key-value pairs representing a main value and its accessible attributes, optionally normalized and excluding specified keys, useful for consistent and unambiguous variable inspection or display."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "_safe_keys", "line_number": 69, "body": "def _safe_keys(self, main_value):\n        try:\n            for key in self._keys(main_value):\n                yield key\n        except Exception:\n            pass", "is_method": true, "class_name": "CommonVariable", "function_description": "Internal generator method of the CommonVariable class that safely yields keys from a given value, suppressing any exceptions during key retrieval to ensure robust iteration."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "_keys", "line_number": 87, "body": "def _keys(self, main_value):\n        return itertools.chain(\n            getattr(main_value, '__dict__', ()),\n            getattr(main_value, '__slots__', ())\n        )", "is_method": true, "class_name": "Attrs", "function_description": "Utility method in the Attrs class that yields attribute keys from an object's __dict__ and __slots__, facilitating unified access to all attribute names regardless of storage mechanism."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "_format_key", "line_number": 93, "body": "def _format_key(self, key):\n        return '.' + key", "is_method": true, "class_name": "Attrs", "function_description": "Private helper method in the Attrs class that formats a given key by prefixing it with a dot. It standardizes key representation for internal use or output formatting."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "_get_value", "line_number": 96, "body": "def _get_value(self, main_value, key):\n        return getattr(main_value, key)", "is_method": true, "class_name": "Attrs", "function_description": "Utility method in the Attrs class that retrieves the attribute named by key from the given main_value object. It simplifies direct attribute access within internal operations."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "_keys", "line_number": 101, "body": "def _keys(self, main_value):\n        return main_value.keys()", "is_method": true, "class_name": "Keys", "function_description": "Returns the keys of the given dictionary-like object, providing access to its available keys."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "_format_key", "line_number": 104, "body": "def _format_key(self, key):\n        return '[{}]'.format(utils.get_shortish_repr(key))", "is_method": true, "class_name": "Keys", "function_description": "Utility method of the Keys class that formats a key into a concise string representation enclosed in brackets for consistent display or logging purposes."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "_get_value", "line_number": 107, "body": "def _get_value(self, main_value, key):\n        return main_value[key]", "is_method": true, "class_name": "Keys", "function_description": "Returns the value associated with a given key from a provided dictionary or mapping. This method supports key-based value retrieval within the Keys class."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "_keys", "line_number": 114, "body": "def _keys(self, main_value):\n        return range(len(main_value))[self._slice]", "is_method": true, "class_name": "Indices", "function_description": "Utility method within Indices that returns a range of positions based on the length of the input and an internal slice configuration, facilitating selective indexing operations."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "__getitem__", "line_number": 117, "body": "def __getitem__(self, item):\n        assert isinstance(item, slice)\n        result = deepcopy(self)\n        result._slice = item\n        return result", "is_method": true, "class_name": "Indices", "function_description": "Provides slicing capability for Indices instances, returning a new Indices object representing the specified slice while preserving the original. Useful for subsetting or segmenting index collections efficiently."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/pysnooper/variables.py", "function": "_items", "line_number": 125, "body": "def _items(self, main_value, normalize=False):\n        if isinstance(main_value, Mapping):\n            cls = Keys\n        elif isinstance(main_value, Sequence):\n            cls = Indices\n        else:\n            cls = Attrs\n\n        return cls(self.source, self.exclude)._items(main_value, normalize)", "is_method": true, "class_name": "Exploding", "function_description": "Utility method of the Exploding class that selects and delegates item extraction based on the type of the input value, supporting mappings, sequences, or other objects with attributes. It enables flexible retrieval of keys, indices, or attributes accordingly."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/misc/generate_authors.py", "function": "drop_recurrences", "line_number": 23, "body": "def drop_recurrences(iterable):\n    s = set()\n    for item in iterable:\n        if item not in s:\n            s.add(item)\n            yield item", "is_method": false, "function_description": "Function that yields unique items from an iterable by filtering out repeated occurrences, providing a way to iterate over distinct elements while preserving their original order."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/misc/generate_authors.py", "function": "iterate_authors_by_chronological_order", "line_number": 31, "body": "def iterate_authors_by_chronological_order(branch):\n    log_call = subprocess.run(\n        (\n            'git', 'log', branch, '--encoding=utf-8', '--full-history',\n            '--reverse', '--format=format:%at;%an;%ae'\n        ),\n        stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n    )\n    log_lines = log_call.stdout.decode('utf-8').split('\\n')\n\n    return drop_recurrences(\n        (line.strip().split(\";\")[1] for line in log_lines)\n    )", "is_method": false, "function_description": "Function that extracts and returns the unique list of authors who contributed to a Git branch, ordered by the chronological sequence of their commits."}, {"file": "./dataset/RepoExec/test-apps/PySnooper/misc/generate_authors.py", "function": "print_authors", "line_number": 46, "body": "def print_authors(branch):\n    for author in iterate_authors_by_chronological_order(branch):\n        sys.stdout.buffer.write(author.encode())\n        sys.stdout.buffer.write(b'\\n')", "is_method": false, "function_description": "Function outputs authors from a given branch in chronological order, writing each author's encoded name to standard output. It serves as a utility to sequentially display author information from version control or revision history."}]