[{"file": "./dataset/RepoExec/test-apps/youtube-dl/setup.py", "function": "initialize_options", "line_number": 90, "body": "def initialize_options(self):\n        pass", "is_method": true, "class_name": "build_lazy_extractors", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/setup.py", "function": "finalize_options", "line_number": 93, "body": "def finalize_options(self):\n        pass", "is_method": true, "class_name": "build_lazy_extractors", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/devscripts/buildserver.py", "function": "win_service_handler", "line_number": 141, "body": "def win_service_handler(stop_event, *args):\n    try:\n        raise ValueError('Handler called with args ' + repr(args))\n        TODO\n    except Exception as e:\n        tb = traceback.format_exc()\n        msg = str(e) + '\\n' + tb\n        win_service_report_event(service_name, msg, is_error=True)\n        raise", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/devscripts/buildserver.py", "function": "win_service_main", "line_number": 164, "body": "def win_service_main(service_name, real_main, argc, argv_raw):\n    try:\n        # args = [argv_raw[i].value for i in range(argc)]\n        stop_event = threading.Event()\n        handler = HandlerEx(functools.partial(stop_event, win_service_handler))\n        h = advapi32.RegisterServiceCtrlHandlerExW(service_name, handler, None)\n        if not h:\n            raise OSError('Handler registration failed: %s' %\n                          ctypes.FormatError())\n\n        TODO\n    except Exception as e:\n        tb = traceback.format_exc()\n        msg = str(e) + '\\n' + tb\n        win_service_report_event(service_name, msg, is_error=True)\n        raise", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/devscripts/buildserver.py", "function": "start", "line_number": 389, "body": "def start(self):\n        pass", "is_method": true, "class_name": "Null", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/devscripts/buildserver.py", "function": "close", "line_number": 392, "body": "def close(self):\n        pass", "is_method": true, "class_name": "Null", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/devscripts/buildserver.py", "function": "build", "line_number": 395, "body": "def build(self):\n        pass", "is_method": true, "class_name": "Null", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/compat.py", "function": "doctype", "line_number": 2527, "body": "def doctype(self, name, pubid, system):\n        pass", "is_method": true, "class_name": "_TreeBuilder", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/compat.py", "function": "_testfunc", "line_number": 2814, "body": "def _testfunc(x):\n        pass", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/compat.py", "function": "encode_elem", "line_number": 2455, "body": "def encode_elem(e):\n            if isinstance(e, dict):\n                e = encode_dict(e)\n            elif isinstance(e, (list, tuple,)):\n                list_e = encode_list(e)\n                e = tuple(list_e) if isinstance(e, tuple) else list_e\n            elif isinstance(e, compat_str):\n                e = e.encode(encoding)\n            return e", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/compat.py", "function": "_compat_add_option", "line_number": 2872, "body": "def _compat_add_option(self, *args, **kwargs):\n            enc = lambda v: (\n                v.encode('ascii', 'replace') if isinstance(v, compat_str)\n                else v)\n            bargs = [enc(a) for a in args]\n            bkwargs = dict(\n                (k, enc(v)) for k, v in kwargs.items())\n            return real_add_option(self, *bargs, **bkwargs)", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/jsinterp.py", "function": "resf", "line_number": 255, "body": "def resf(args):\n            local_vars = dict(zip(argnames, args))\n            for stmt in code.split(';'):\n                res, abort = self.interpret_statement(stmt, local_vars)\n                if abort:\n                    break\n            return res", "is_method": true, "class_name": "JSInterpreter", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/YoutubeDL.py", "function": "report_download", "line_number": 997, "body": "def report_download(num_entries):\n            self.to_screen(\n                '[%s] playlist %s: Downloading %d videos' %\n                (ie_result['extractor'], playlist, num_entries))", "is_method": true, "class_name": "YoutubeDL", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/YoutubeDL.py", "function": "_filter", "line_number": 1135, "body": "def _filter(f):\n            actual_value = f.get(m.group('key'))\n            if actual_value is None:\n                return m.group('none_inclusive')\n            return op(actual_value, comparison_value)", "is_method": true, "class_name": "YoutubeDL", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/YoutubeDL.py", "function": "print_mandatory", "line_number": 1747, "body": "def print_mandatory(field):\n            if (self.params.get('force%s' % field, False)\n                    and (not incomplete or info_dict.get(field) is not None)):\n                self.to_stdout(info_dict[field])", "is_method": true, "class_name": "YoutubeDL", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/YoutubeDL.py", "function": "print_optional", "line_number": 1752, "body": "def print_optional(field):\n            if (self.params.get('force%s' % field, False)\n                    and info_dict.get(field) is not None):\n                self.to_stdout(info_dict[field])", "is_method": true, "class_name": "YoutubeDL", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/YoutubeDL.py", "function": "selector_function", "line_number": 1280, "body": "def selector_function(ctx):\n                    for f in fs:\n                        for format in f(ctx):\n                            yield format", "is_method": true, "class_name": "YoutubeDL", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/swfinterp.py", "function": "_s24", "line_number": 130, "body": "def _s24(reader):\n    bs = reader.read(3)\n    assert len(bs) == 3\n    last_byte = b'\\xff' if (ord(bs[2:3]) >= 0x80) else b'\\x00'\n    return compat_struct_unpack('<i', bs + last_byte)[0]", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/utils.py", "function": "_find_xpath", "line_number": 1888, "body": "def _find_xpath(xpath):\n        return node.find(compat_xpath(xpath))", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/utils.py", "function": "_get_pixel", "line_number": 5608, "body": "def _get_pixel(idx):\n        x = idx % stride\n        y = idx // stride\n        return pixels[y][x]", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/utils.py", "function": "_hc_connect", "line_number": 2525, "body": "def _hc_connect(self, *args, **kwargs):\n                sock = _create_connection(\n                    (self.host, self.port), self.timeout, sa)\n                if is_https:\n                    self.sock = ssl.wrap_socket(\n                        sock, self.key_file, self.cert_file,\n                        ssl_version=ssl.PROTOCOL_TLSv1)\n                else:\n                    self.sock = sock", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/utils.py", "function": "_lock_file", "line_number": 3318, "body": "def _lock_file(f, exclusive):\n            raise IOError(UNSUPPORTED_MSG)", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/utils.py", "function": "_unlock_file", "line_number": 3321, "body": "def _unlock_file(f):\n            raise IOError(UNSUPPORTED_MSG)", "is_method": false, "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/postprocessor/common.py", "function": "run", "line_number": 41, "body": "def run(self, information):\n        \"\"\"Run the PostProcessor.\n\n        The \"information\" argument is a dictionary like the ones\n        composed by InfoExtractors. The only difference is that this\n        one has an extra field called \"filepath\" that points to the\n        downloaded file.\n\n        This method returns a tuple, the first element is a list of the files\n        that can be deleted, and the second of which is the updated\n        information.\n\n        In addition, this method may raise a PostProcessingError\n        exception if post processing fails.\n        \"\"\"\n        return [], information", "is_method": true, "class_name": "PostProcessor", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/downloader/common.py", "function": "trouble", "line_number": 158, "body": "def trouble(self, *args, **kargs):\n        self.ydl.trouble(*args, **kargs)", "is_method": true, "class_name": "FileDownloader", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/downloader/common.py", "function": "real_download", "line_number": 368, "body": "def real_download(self, filename, info_dict):\n        \"\"\"Real download process. Redefine in subclasses.\"\"\"\n        raise NotImplementedError('This method must be implemented by subclasses')", "is_method": true, "class_name": "FileDownloader", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/downloader/fragment.py", "function": "to_screen", "line_number": 18, "body": "def to_screen(self, *args, **kargs):\n        pass", "is_method": true, "class_name": "HttpQuietDownloader", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/googledrive.py", "function": "add_source_format", "line_number": 220, "body": "def add_source_format(urlh):\n                formats.append({\n                    # Use redirect URLs as download URLs in order to calculate\n                    # correct cookies in _calc_cookies.\n                    # Using original URLs may result in redirect loop due to\n                    # google.com's cookies mistakenly used for googleusercontent.com\n                    # redirect URLs (see #23919).\n                    'url': urlh.geturl(),\n                    'ext': determine_ext(title, 'mp4').lower(),\n                    'format_id': 'source',\n                    'quality': 1,\n                })", "is_method": true, "class_name": "GoogleDriveIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/teamtreehouse.py", "function": "extract_urls", "line_number": 107, "body": "def extract_urls(html, extract_info=None):\n                for path in re.findall(r'<a[^>]+href=\"([^\"]+)\"', html):\n                    page_url = urljoin(url, path)\n                    entry = {\n                        '_type': 'url_transparent',\n                        'id': self._match_id(page_url),\n                        'url': page_url,\n                        'id_key': self.ie_key(),\n                    }\n                    if extract_info:\n                        entry.update(extract_info)\n                    entries.append(entry)", "is_method": true, "class_name": "TeamTreeHouseIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/npo.py", "function": "add_format_url", "line_number": 354, "body": "def add_format_url(format_url):\n                width = int_or_none(self._search_regex(\n                    r'(\\d+)[xX]\\d+', format_url, 'width', default=None))\n                height = int_or_none(self._search_regex(\n                    r'\\d+[xX](\\d+)', format_url, 'height', default=None))\n                if item_label in QUALITY_LABELS:\n                    quality = quality_from_label(item_label)\n                    f_id = item_label\n                elif item_label in QUALITY_FORMATS:\n                    quality = quality_from_format_id(format_id)\n                    f_id = format_id\n                else:\n                    quality, f_id = [None] * 2\n                formats.append({\n                    'url': format_url,\n                    'format_id': f_id,\n                    'width': width,\n                    'height': height,\n                    'quality': quality,\n                })", "is_method": true, "class_name": "NPOIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/pbs.py", "function": "extract_redirect_urls", "line_number": 552, "body": "def extract_redirect_urls(info):\n            for encoding_name in ('recommended_encoding', 'alternate_encoding'):\n                redirect = info.get(encoding_name)\n                if not redirect:\n                    continue\n                redirect_url = redirect.get('url')\n                if redirect_url and redirect_url not in redirect_urls:\n                    redirects.append(redirect)\n                    redirect_urls.add(redirect_url)\n            encodings = info.get('encodings')\n            if isinstance(encodings, list):\n                for encoding in encodings:\n                    encoding_url = url_or_none(encoding)\n                    if encoding_url and encoding_url not in redirect_urls:\n                        redirects.append({'url': encoding_url})\n                        redirect_urls.add(encoding_url)", "is_method": true, "class_name": "PBSIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/breakcom.py", "function": "get", "line_number": 76, "body": "def get(key, name):\n            return int_or_none(self._search_regex(\n                r'%s[\"\\']\\s*:\\s*[\"\\'](\\d+)' % key, webpage, name,\n                default=None))", "is_method": true, "class_name": "BreakIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/brightcove.py", "function": "build_format_id", "line_number": 521, "body": "def build_format_id(kind):\n                    format_id = kind\n                    if tbr:\n                        format_id += '-%dk' % int(tbr)\n                    if height:\n                        format_id += '-%dp' % height\n                    return format_id", "is_method": true, "class_name": "BrightcoveNewIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/pornhub.py", "function": "dl_webpage", "line_number": 260, "body": "def dl_webpage(platform):\n            self._set_cookie(host, 'platform', platform)\n            return self._download_webpage(\n                'https://www.%s/view_video.php?viewkey=%s' % (host, video_id),\n                video_id, 'Downloading %s webpage' % platform)", "is_method": true, "class_name": "PornHubIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/pornhub.py", "function": "extract_list", "line_number": 462, "body": "def extract_list(meta_key):\n            div = self._search_regex(\n                r'(?s)<div[^>]+\\bclass=[\"\\'].*?\\b%sWrapper[^>]*>(.+?)</div>'\n                % meta_key, webpage, meta_key, default=None)\n            if div:\n                return re.findall(r'<a[^>]+\\bhref=[^>]+>([^<]+)', div)", "is_method": true, "class_name": "PornHubIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/limelight.py", "function": "smuggle", "line_number": 30, "body": "def smuggle(url):\n            return smuggle_url(url, {'source_url': source_url})", "is_method": true, "class_name": "LimelightBaseIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/audioboom.py", "function": "from_clip", "line_number": 47, "body": "def from_clip(field):\n            if clip:\n                return clip.get(field)", "is_method": true, "class_name": "AudioBoomIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/cnn.py", "function": "_extract_timestamp", "line_number": 86, "body": "def _extract_timestamp(self, video_data):\n        # TODO: fix timestamp extraction\n        return None", "is_method": true, "class_name": "CNNIE", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/common.py", "function": "_real_initialize", "line_number": 568, "body": "def _real_initialize(self):\n        \"\"\"Real initialization process. Redefine in subclasses.\"\"\"\n        pass", "is_method": true, "class_name": "InfoExtractor", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/common.py", "function": "_real_extract", "line_number": 572, "body": "def _real_extract(self, url):\n        \"\"\"Real extraction process. Redefine in subclasses.\"\"\"\n        pass", "is_method": true, "class_name": "InfoExtractor", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/common.py", "function": "_get_subtitles", "line_number": 2971, "body": "def _get_subtitles(self, *args, **kwargs):\n        raise NotImplementedError('This method must be implemented by subclasses')", "is_method": true, "class_name": "InfoExtractor", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/common.py", "function": "_get_automatic_captions", "line_number": 2997, "body": "def _get_automatic_captions(self, *args, **kwargs):\n        raise NotImplementedError('This method must be implemented by subclasses')", "is_method": true, "class_name": "InfoExtractor", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/common.py", "function": "_mark_watched", "line_number": 3006, "body": "def _mark_watched(self, *args, **kwargs):\n        raise NotImplementedError('This method must be implemented by subclasses')", "is_method": true, "class_name": "InfoExtractor", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/common.py", "function": "_get_n_results", "line_number": 3058, "body": "def _get_n_results(self, query, n):\n        \"\"\"Get a specified number of results for a query\"\"\"\n        raise NotImplementedError('This method must be implemented by subclasses')", "is_method": true, "class_name": "SearchInfoExtractor", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/common.py", "function": "_add_ns", "line_number": 2103, "body": "def _add_ns(path):\n            return self._xpath_ns(path, namespace)", "is_method": true, "class_name": "InfoExtractor", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/common.py", "function": "add_segment_url", "line_number": 2293, "body": "def add_segment_url():\n                                    segment_url = media_template % {\n                                        'Time': segment_time,\n                                        'Bandwidth': bandwidth,\n                                        'Number': segment_number,\n                                    }\n                                    representation_ms_info['fragments'].append({\n                                        media_location_key: segment_url,\n                                        'duration': float_or_none(segment_d, representation_ms_info['timescale']),\n                                    })", "is_method": true, "class_name": "InfoExtractor", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/spankbang.py", "function": "extract_format", "line_number": 85, "body": "def extract_format(format_id, format_url):\n            f_url = url_or_none(format_url)\n            if not f_url:\n                return\n            f = parse_resolution(format_id)\n            ext = determine_ext(f_url)\n            if format_id.startswith('m3u8') or ext == 'm3u8':\n                formats.extend(self._extract_m3u8_formats(\n                    f_url, video_id, 'mp4', entry_protocol='m3u8_native',\n                    m3u8_id='hls', fatal=False))\n            elif format_id.startswith('mpd') or ext == 'mpd':\n                formats.extend(self._extract_mpd_formats(\n                    f_url, video_id, mpd_id='dash', fatal=False))\n            elif ext == 'mp4' or f.get('width') or f.get('height'):\n                f.update({\n                    'url': f_url,\n                    'format_id': format_id,\n                })\n                formats.append(f)", "is_method": true, "class_name": "SpankBangIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/animeondemand.py", "function": "extract_episodes", "line_number": 250, "body": "def extract_episodes(html):\n            for num, episode_html in enumerate(re.findall(\n                    r'(?s)<h3[^>]+class=\"episodebox-title\".+?>Episodeninhalt<', html), 1):\n                episodebox_title = self._search_regex(\n                    (r'class=\"episodebox-title\"[^>]+title=([\"\\'])(?P<title>.+?)\\1',\n                     r'class=\"episodebox-title\"[^>]+>(?P<title>.+?)<'),\n                    episode_html, 'episodebox title', default=None, group='title')\n                if not episodebox_title:\n                    continue\n\n                episode_number = int(self._search_regex(\n                    r'(?:Episode|Film)\\s*(\\d+)',\n                    episodebox_title, 'episode number', default=num))\n                episode_title = self._search_regex(\n                    r'(?:Episode|Film)\\s*\\d+\\s*-\\s*(.+)',\n                    episodebox_title, 'episode title', default=None)\n\n                video_id = 'episode-%d' % episode_number\n\n                common_info = {\n                    'id': video_id,\n                    'series': anime_title,\n                    'episode': episode_title,\n                    'episode_number': episode_number,\n                }\n\n                for e in extract_entries(episode_html, video_id, common_info):\n                    yield e", "is_method": true, "class_name": "AnimeOnDemandIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/spreaker.py", "function": "duration", "line_number": 37, "body": "def duration(key):\n        return float_or_none(data.get(key), scale=1000)", "is_method": false, "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/iprima.py", "function": "extract_formats", "line_number": 103, "body": "def extract_formats(format_url, format_key=None, lang=None):\n            ext = determine_ext(format_url)\n            new_formats = []\n            if format_key == 'hls' or ext == 'm3u8':\n                new_formats = self._extract_m3u8_formats(\n                    format_url, video_id, 'mp4', entry_protocol='m3u8_native',\n                    m3u8_id='hls', fatal=False)\n            elif format_key == 'dash' or ext == 'mpd':\n                return\n                new_formats = self._extract_mpd_formats(\n                    format_url, video_id, mpd_id='dash', fatal=False)\n            if lang:\n                for f in new_formats:\n                    if not f.get('language'):\n                        f['language'] = lang\n            formats.extend(new_formats)", "is_method": true, "class_name": "IPrimaIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/tvn24.py", "function": "extract_json", "line_number": 60, "body": "def extract_json(attr, name, default=NO_DEFAULT, fatal=True):\n            return self._parse_json(\n                self._search_regex(\n                    r'\\b%s=([\"\\'])(?P<json>(?!\\1).+?)\\1' % attr, webpage,\n                    name, group='json', default=default, fatal=fatal) or '{}',\n                display_id, transform_source=unescapeHTML, fatal=fatal)", "is_method": true, "class_name": "TVN24IE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/twitter.py", "function": "extract_from_video_info", "line_number": 474, "body": "def extract_from_video_info(media):\n            video_info = media.get('video_info') or {}\n\n            formats = []\n            for variant in video_info.get('variants', []):\n                formats.extend(self._extract_variant_formats(variant, twid))\n            self._sort_formats(formats)\n\n            thumbnails = []\n            media_url = media.get('media_url_https') or media.get('media_url')\n            if media_url:\n                def add_thumbnail(name, size):\n                    thumbnails.append({\n                        'id': name,\n                        'url': update_url_query(media_url, {'name': name}),\n                        'width': int_or_none(size.get('w') or size.get('width')),\n                        'height': int_or_none(size.get('h') or size.get('height')),\n                    })\n                for name, size in media.get('sizes', {}).items():\n                    add_thumbnail(name, size)\n                add_thumbnail('orig', media.get('original_info') or {})\n\n            info.update({\n                'formats': formats,\n                'thumbnails': thumbnails,\n                'duration': float_or_none(video_info.get('duration_millis'), 1000),\n            })", "is_method": true, "class_name": "TwitterIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/twitter.py", "function": "_find_dimension", "line_number": 607, "body": "def _find_dimension(target):\n            w = int_or_none(self._html_search_meta(\n                'twitter:%s:width' % target, webpage, fatal=False))\n            h = int_or_none(self._html_search_meta(\n                'twitter:%s:height' % target, webpage, fatal=False))\n            return w, h", "is_method": true, "class_name": "TwitterAmplifyIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/nextmedia.py", "function": "_fetch_timestamp", "line_number": 189, "body": "def _fetch_timestamp(self, page):\n        return None", "is_method": true, "class_name": "AppleDailyIE", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/periscope.py", "function": "add_width_and_height", "line_number": 112, "body": "def add_width_and_height(f):\n            for key, val in (('width', width), ('height', height)):\n                if not f.get(key):\n                    f[key] = val", "is_method": true, "class_name": "PeriscopeIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/xnxx.py", "function": "get", "line_number": 42, "body": "def get(meta, default=NO_DEFAULT, fatal=True):\n            return self._search_regex(\n                r'set%s\\s*\\(\\s*([\"\\'])(?P<value>(?:(?!\\1).)+)\\1' % meta,\n                webpage, meta, default=default, fatal=fatal, group='value')", "is_method": true, "class_name": "XNXXIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/nrk.py", "function": "_extract_description", "line_number": 782, "body": "def _extract_description(self, webpage):\n        pass", "is_method": true, "class_name": "NRKPlaylistBaseIE", "function_description": "Not Implemented"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/lifenews.py", "function": "extract_m3u8", "line_number": 195, "body": "def extract_m3u8(manifest_url):\n            formats.extend(self._extract_m3u8_formats(\n                manifest_url, video_id, 'mp4',\n                entry_protocol='m3u8_native', m3u8_id='m3u8'))", "is_method": true, "class_name": "LifeEmbedIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/bbc.py", "function": "_get_episode", "line_number": 1559, "body": "def _get_episode(element):\n        return element", "is_method": true, "class_name": "BBCCoUkIPlayerGroupIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/bbc.py", "function": "extract_all", "line_number": 1215, "body": "def extract_all(pattern):\n            return list(filter(None, map(\n                lambda s: self._parse_json(s, playlist_id, fatal=False),\n                re.findall(pattern, webpage))))", "is_method": true, "class_name": "BBCIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/soundcloud.py", "function": "add_format", "line_number": 349, "body": "def add_format(f, protocol, is_preview=False):\n            mobj = re.search(r'\\.(?P<abr>\\d+)\\.(?P<ext>[0-9a-z]{3,4})(?=[/?])', stream_url)\n            if mobj:\n                for k, v in mobj.groupdict().items():\n                    if not f.get(k):\n                        f[k] = v\n            format_id_list = []\n            if protocol:\n                format_id_list.append(protocol)\n            ext = f.get('ext')\n            if ext == 'aac':\n                f['abr'] = '256'\n            for k in ('ext', 'abr'):\n                v = f.get(k)\n                if v:\n                    format_id_list.append(v)\n            preview = is_preview or re.search(r'/(?:preview|playlist)/0/30/', f['url'])\n            if preview:\n                format_id_list.append('preview')\n            abr = f.get('abr')\n            if abr:\n                f['abr'] = int(abr)\n            if protocol == 'hls':\n                protocol = 'm3u8' if ext == 'aac' else 'm3u8_native'\n            else:\n                protocol = 'http'\n            f.update({\n                'format_id': '_'.join(format_id_list),\n                'protocol': protocol,\n                'preference': -10 if preview else None,\n            })\n            formats.append(f)", "is_method": true, "class_name": "SoundcloudIE", "function_description": "Not sure"}, {"file": "./dataset/RepoExec/test-apps/youtube-dl/youtube_dl/extractor/nexx.py", "function": "find_video", "line_number": 298, "body": "def find_video(result):\n            if isinstance(result, dict):\n                return result\n            elif isinstance(result, list):\n                vid = int(video_id)\n                for v in result:\n                    if try_get(v, lambda x: x['general']['ID'], int) == vid:\n                        return v\n            return None", "is_method": true, "class_name": "NexxIE", "function_description": "Not sure"}]