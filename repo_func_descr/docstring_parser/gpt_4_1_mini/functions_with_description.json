[{"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "parse", "line_number": 269, "body": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)", "is_method": false, "function_description": "Utility function that parses a Google-style docstring into its structured components, facilitating docstring analysis and processing for documentation or code analysis tools."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "_setup", "line_number": 75, "body": "def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )", "is_method": true, "class_name": "GoogleParser", "function_description": "Internal setup method of GoogleParser that compiles a regex pattern to detect section titles optionally followed by a colon, facilitating subsequent parsing of structured text sections."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "_build_meta", "line_number": 89, "body": "def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)", "is_method": true, "class_name": "GoogleParser", "function_description": "Constructs a docstring metadata element by parsing the given text and section title, handling singular and multiple-type sections to extract structured content for further processing."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "_build_single_meta", "line_number": 116, "body": "def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)", "is_method": true, "class_name": "GoogleParser", "function_description": "Constructs metadata objects from a given section and description, categorizing docstring elements like returns, yields, and raises for structured documentation parsing."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "_build_multi_meta", "line_number": 132, "body": "def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)", "is_method": true, "class_name": "GoogleParser", "function_description": "Constructs and returns a detailed metadata object representing a parsed docstring section, capturing parameters, return types, raised exceptions, or general metadata based on the section type and provided descriptions. This supports structured parsing of Google-style Python docstrings."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "add_section", "line_number": 175, "body": "def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()", "is_method": true, "class_name": "GoogleParser", "function_description": "Adds or updates a section within the GoogleParser by its title, maintaining the collection of sections for further processing. This supports dynamic modification of parsed document content."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "parse", "line_number": 184, "body": "def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret", "is_method": true, "class_name": "GoogleParser", "function_description": "Service method of the GoogleParser class that processes a Google-style docstring, extracting and organizing its descriptive and metadata components into a structured Docstring object for downstream usage."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/parser.py", "function": "parse", "line_number": 7, "body": "def parse(text: str, style: Style = Style.auto) -> Docstring:\n    \"\"\"Parse the docstring into its components.\n\n    :param text: docstring text to parse\n    :param style: docstring style\n    :returns: parsed docstring representation\n    \"\"\"\n\n    if style != Style.auto:\n        return STYLES[style](text)\n    rets = []\n    for parse_ in STYLES.values():\n        try:\n            rets.append(parse_(text))\n        except ParseError as e:\n            exc = e\n    if not rets:\n        raise exc\n    return sorted(rets, key=lambda d: len(d.meta), reverse=True)[0]", "is_method": false, "function_description": "Parses a docstring text into a structured representation based on a specified or automatically detected style, facilitating consistent extraction of docstring components for various documentation formats."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_pairwise", "line_number": 21, "body": "def _pairwise(iterable: T.Iterable, end=None) -> T.Iterable:\n    a, b = itertools.tee(iterable)\n    next(b, None)\n    return itertools.zip_longest(a, b, fillvalue=end)", "is_method": false, "function_description": "Utility function that generates successive pairs of items from an iterable, optionally filling the last pair with a specified end value. Useful for processing or comparing adjacent elements in sequences."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_clean_str", "line_number": 27, "body": "def _clean_str(string: str) -> T.Optional[str]:\n    string = string.strip()\n    if len(string) > 0:\n        return string", "is_method": false, "function_description": "Utility function that trims whitespace from a string and returns the cleaned string only if it is not empty; otherwise, it returns None."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "parse", "line_number": 326, "body": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return NumpydocParser().parse(text)", "is_method": false, "function_description": "Utility function that parses a numpy-style docstring into its structured components, enabling analysis or manipulation of docstring content in documentation or code inspection tools."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "title_pattern", "line_number": 63, "body": "def title_pattern(self) -> str:\n        \"\"\"Regular expression pattern matching this section's header.\n\n        This pattern will match this instance's ``title`` attribute in\n        an anonymous group.\n        \"\"\"\n        return r\"^({})\\s*?\\n{}\\s*$\".format(self.title, \"-\" * len(self.title))", "is_method": true, "class_name": "Section", "function_description": "Provides a regular expression pattern that matches the section's title followed by an underline of dashes, enabling precise identification of the section header in text parsing scenarios."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "parse", "line_number": 71, "body": "def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        \"\"\"Parse ``DocstringMeta`` objects from the body of this section.\n\n        :param text: section body text. Should be cleaned with\n                     ``inspect.cleandoc`` before parsing.\n        \"\"\"\n        yield DocstringMeta([self.key], description=_clean_str(text))", "is_method": true, "class_name": "Section", "function_description": "This method extracts and yields metadata objects from a cleaned text body of a section, associating them with the section's key. It serves to transform raw section text into structured docstring metadata for further processing."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "parse", "line_number": 94, "body": "def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        for match, next_match in _pairwise(KV_REGEX.finditer(text)):\n            start = match.end()\n            end = next_match.start() if next_match is not None else None\n            value = text[start:end]\n            yield self._parse_item(\n                key=match.group(), value=inspect.cleandoc(value)\n            )", "is_method": true, "class_name": "_KVSection", "function_description": "Parses key-value pairs from a text string, yielding structured metadata items for each pair. It enables extracting and processing formatted key-value data blocks within documents."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "title_pattern", "line_number": 113, "body": "def title_pattern(self) -> str:\n        return r\"^\\.\\.\\s*({})\\s*::\".format(self.title)", "is_method": true, "class_name": "_SphinxSection", "function_description": "Constructs a regular expression pattern that matches reStructuredText section titles based on the section's title attribute. Useful for parsing or identifying specific sections within Sphinx documentation sources."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_parse_item", "line_number": 128, "body": "def _parse_item(self, key: str, value: str) -> DocstringParam:\n        m = PARAM_KEY_REGEX.match(key)\n        arg_name = type_name = is_optional = None\n        if m is not None:\n            arg_name, type_name = m.group(\"name\"), m.group(\"type\")\n            if type_name is not None:\n                optional_match = PARAM_OPTIONAL_REGEX.match(type_name)\n                if optional_match is not None:\n                    type_name = optional_match.group(\"type\")\n                    is_optional = True\n                else:\n                    is_optional = False\n\n        default = None\n        if len(value) > 0:\n            default_match = PARAM_DEFAULT_REGEX.search(value)\n            if default_match is not None:\n                default = default_match.group(\"value\")\n\n        return DocstringParam(\n            args=[self.key, arg_name],\n            description=_clean_str(value),\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )", "is_method": true, "class_name": "ParamSection", "function_description": "Parses a parameter key-value pair from a docstring section into a structured DocstringParam object, extracting name, type, optionality, default value, and description details. Useful for standardized docstring parameter analysis."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_parse_item", "line_number": 165, "body": "def _parse_item(self, key: str, value: str) -> DocstringRaises:\n        return DocstringRaises(\n            args=[self.key, key],\n            description=_clean_str(value),\n            type_name=key if len(key) > 0 else None,\n        )", "is_method": true, "class_name": "RaisesSection", "function_description": "Utility method of RaisesSection that creates a DocstringRaises object from a key-value pair, capturing the exception type and its description for documentation purposes."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_parse_item", "line_number": 185, "body": "def _parse_item(self, key: str, value: str) -> DocstringReturns:\n        m = RETURN_KEY_REGEX.match(key)\n        if m is not None:\n            return_name, type_name = m.group(\"name\"), m.group(\"type\")\n        else:\n            return_name = type_name = None\n\n        return DocstringReturns(\n            args=[self.key],\n            description=_clean_str(value),\n            type_name=type_name,\n            is_generator=self.is_generator,\n            return_name=return_name,\n        )", "is_method": true, "class_name": "ReturnsSection", "function_description": "Parses a return section key and value to extract return variable name, type, and description, producing a structured DocstringReturns object for documenting function return values."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "parse", "line_number": 210, "body": "def parse(self, text: str) -> T.Iterable[DocstringDeprecated]:\n        version, desc, *_ = text.split(sep=\"\\n\", maxsplit=1) + [None, None]\n\n        if desc is not None:\n            desc = _clean_str(inspect.cleandoc(desc))\n\n        yield DocstringDeprecated(\n            args=[self.key], description=desc, version=_clean_str(version)\n        )", "is_method": true, "class_name": "DeprecationSection", "function_description": "Parses a deprecation section from a text block, extracting the deprecated version and description for structured documentation purposes. It enables consistent handling of deprecation information in docstrings."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_setup", "line_number": 266, "body": "def _setup(self):\n        self.titles_re = re.compile(\n            r\"|\".join(s.title_pattern for s in self.sections.values()),\n            flags=re.M,\n        )", "is_method": true, "class_name": "NumpydocParser", "function_description": "Private method of NumpydocParser that initializes a regex pattern to detect section titles based on configured section patterns. It prepares the parser for identifying structured docstring sections."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "add_section", "line_number": 272, "body": "def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()", "is_method": true, "class_name": "NumpydocParser", "function_description": "Adds or updates a section within the NumpydocParser, managing document structure for later parsing or processing. This enables dynamic modification of sections in the parsed documentation."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "parse", "line_number": 281, "body": "def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the numpy-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        for match, nextmatch in _pairwise(self.titles_re.finditer(meta_chunk)):\n            title = next(g for g in match.groups() if g is not None)\n            factory = self.sections[title]\n\n            # section chunk starts after the header,\n            # ends at the start of the next header\n            start = match.end()\n            end = nextmatch.start() if nextmatch is not None else None\n            ret.meta.extend(factory.parse(meta_chunk[start:end]))\n\n        return ret", "is_method": true, "class_name": "NumpydocParser", "function_description": "Parses a numpy-style docstring into its structured components including short and long descriptions as well as metadata sections. This supports extracting detailed documentation elements for further processing or display."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/rest.py", "function": "_build_meta", "line_number": 21, "body": "def _build_meta(args: T.List[str], desc: str) -> DocstringMeta:\n    key = args[0]\n\n    if key in PARAM_KEYWORDS:\n        if len(args) == 3:\n            key, type_name, arg_name = args\n            if type_name.endswith(\"?\"):\n                is_optional = True\n                type_name = type_name[:-1]\n            else:\n                is_optional = False\n        elif len(args) == 2:\n            key, arg_name = args\n            type_name = None\n            is_optional = None\n        else:\n            raise ParseError(\n                \"Expected one or two arguments for a {} keyword.\".format(key)\n            )\n\n        m = re.match(r\".*defaults to (.+)\", desc, flags=re.DOTALL)\n        default = m.group(1).rstrip(\".\") if m else None\n\n        return DocstringParam(\n            args=args,\n            description=desc,\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n    if key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n\n        return DocstringReturns(\n            args=args,\n            description=desc,\n            type_name=type_name,\n            is_generator=key in YIELDS_KEYWORDS,\n        )\n\n    if key in RAISES_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n        return DocstringRaises(\n            args=args, description=desc, type_name=type_name\n        )\n\n    return DocstringMeta(args=args, description=desc)", "is_method": false, "function_description": "This function parses docstring components based on recognized keywords, creating structured metadata objects representing parameters, return values, yields, or exceptions for detailed documentation analysis."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/rest.py", "function": "parse", "line_number": 86, "body": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    ret = Docstring()\n    if not text:\n        return ret\n\n    text = inspect.cleandoc(text)\n    match = re.search(\"^:\", text, flags=re.M)\n    if match:\n        desc_chunk = text[: match.start()]\n        meta_chunk = text[match.start() :]\n    else:\n        desc_chunk = text\n        meta_chunk = \"\"\n\n    parts = desc_chunk.split(\"\\n\", 1)\n    ret.short_description = parts[0] or None\n    if len(parts) > 1:\n        long_desc_chunk = parts[1] or \"\"\n        ret.blank_after_short_description = long_desc_chunk.startswith(\"\\n\")\n        ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n        ret.long_description = long_desc_chunk.strip() or None\n\n    for match in re.finditer(\n        r\"(^:.*?)(?=^:|\\Z)\", meta_chunk, flags=re.S | re.M\n    ):\n        chunk = match.group(0)\n        if not chunk:\n            continue\n        try:\n            args_chunk, desc_chunk = chunk.lstrip(\":\").split(\":\", 1)\n        except ValueError:\n            raise ParseError(\n                'Error parsing meta information near \"{}\".'.format(chunk)\n            )\n        args = args_chunk.split()\n        desc = desc_chunk.strip()\n        if \"\\n\" in desc:\n            first_line, rest = desc.split(\"\\n\", 1)\n            desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n\n        ret.meta.append(_build_meta(args, desc))\n\n    return ret", "is_method": false, "function_description": "Parses a ReST-style docstring into structured components including short description, long description, and metadata, facilitating programmatic extraction and analysis of documentation details for code elements."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/common.py", "function": "params", "line_number": 125, "body": "def params(self) -> T.List[DocstringParam]:\n        return [item for item in self.meta if isinstance(item, DocstringParam)]", "is_method": true, "class_name": "Docstring", "function_description": "Method of the Docstring class that extracts and returns all parameter descriptions from its metadata, facilitating access to structured information about function or method parameters."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/common.py", "function": "raises", "line_number": 129, "body": "def raises(self) -> T.List[DocstringRaises]:\n        return [\n            item for item in self.meta if isinstance(item, DocstringRaises)\n        ]", "is_method": true, "class_name": "Docstring", "function_description": "Returns a list of all exception-raising clauses documented in the docstring. This method helps extract error information for understanding function failure modes or generating documentation."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/common.py", "function": "returns", "line_number": 135, "body": "def returns(self) -> T.Optional[DocstringReturns]:\n        for item in self.meta:\n            if isinstance(item, DocstringReturns):\n                return item\n        return None", "is_method": true, "class_name": "Docstring", "function_description": "This method scans the Docstring metadata to find and return its associated return value description, if available. It helps extract specific information about function return types documented within the docstring."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/common.py", "function": "deprecation", "line_number": 142, "body": "def deprecation(self) -> T.Optional[DocstringDeprecated]:\n        for item in self.meta:\n            if isinstance(item, DocstringDeprecated):\n                return item\n        return None", "is_method": true, "class_name": "Docstring", "function_description": "Returns the deprecation information from the Docstring metadata if present, allowing identification of deprecated features or elements within documentation."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_short_description", "line_number": 109, "body": "def test_short_description(source: str, expected: str) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected\n    assert docstring.long_description is None\n    assert docstring.meta == []", "is_method": false, "function_description": "This function verifies that a parsed docstring contains a specified short description, has no long description, and has an empty metadata list. It is useful for testing docstring parsing accuracy in documentation tools."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_long_description", "line_number": 179, "body": "def test_long_description(\n    source: str,\n    expected_short_desc: str,\n    expected_long_desc: str,\n    expected_blank: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank\n    assert docstring.meta == []", "is_method": false, "function_description": "This function tests whether a parsed docstring's short description, long description, blank line presence, and metadata match expected values. It validates docstring parsing accuracy for given source input."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_meta_newlines", "line_number": 273, "body": "def test_meta_newlines(\n    source: str,\n    expected_short_desc: T.Optional[str],\n    expected_long_desc: T.Optional[str],\n    expected_blank_short_desc: bool,\n    expected_blank_long_desc: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank_short_desc\n    assert docstring.blank_after_long_description == expected_blank_long_desc\n    assert len(docstring.meta) == 1", "is_method": false, "function_description": "Utility test function that validates parsing of docstring components and formatting, ensuring extracted short and long descriptions and their line spacing match expected values."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_returns", "line_number": 472, "body": "def test_returns() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        \"\"\"\n    )\n    assert docstring.returns is None\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Returns:\n            description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name is None\n    assert docstring.returns.description == \"description\"\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Returns:\n            description with: a colon!\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name is None\n    assert docstring.returns.description == \"description with: a colon!\"\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Returns:\n            int: description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"int\"\n    assert docstring.returns.description == \"description\"\n\n    docstring = parse(\n        \"\"\"\n        Returns:\n            Optional[Mapping[str, List[int]]]: A description: with a colon\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"Optional[Mapping[str, List[int]]]\"\n    assert docstring.returns.description == \"A description: with a colon\"\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Yields:\n            int: description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"int\"\n    assert docstring.returns.description == \"description\"\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Returns:\n            int: description\n            with much text\n\n            even some spacing\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"int\"\n    assert docstring.returns.description == (\n        \"description\\n\" \"with much text\\n\\n\" \"even some spacing\"\n    )", "is_method": false, "function_description": "This test function verifies that the docstring parser correctly extracts the return type and description from various docstring formats. It ensures accurate parsing of \"Returns\" and \"Yields\" sections with different complexities and formatting."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_raises", "line_number": 551, "body": "def test_raises() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        \"\"\"\n    )\n    assert len(docstring.raises) == 0\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Raises:\n            ValueError: description\n        \"\"\"\n    )\n    assert len(docstring.raises) == 1\n    assert docstring.raises[0].type_name == \"ValueError\"\n    assert docstring.raises[0].description == \"description\"", "is_method": false, "function_description": "Tests that the docstring parser correctly identifies and extracts exception types and descriptions from the \"Raises\" section of docstrings."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_examples", "line_number": 571, "body": "def test_examples() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        Example:\n            example: 1\n        Examples:\n            long example\n\n            more here\n        \"\"\"\n    )\n    assert len(docstring.meta) == 2\n    assert docstring.meta[0].description == \"example: 1\"\n    assert docstring.meta[1].description == \"long example\\n\\nmore here\"", "is_method": false, "function_description": "This function validates that the parse function correctly extracts multiple example descriptions from a docstring, ensuring accurate parsing of example metadata for testing purposes."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_broken_meta", "line_number": 588, "body": "def test_broken_meta() -> None:\n    with pytest.raises(ParseError):\n        parse(\"Args:\")\n\n    with pytest.raises(ParseError):\n        parse(\"Args:\\n    herp derp\")", "is_method": false, "function_description": "This function validates that the parsing process correctly raises errors when given malformed metadata. It serves as a test to ensure robust error handling for invalid input formats."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_short_description", "line_number": 17, "body": "def test_short_description(source: str, expected: str) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected\n    assert docstring.long_description is None\n    assert docstring.meta == []", "is_method": false, "function_description": "This function verifies that a parsed docstring's short description matches an expected value while ensuring no long description or metadata exists. It serves as a test utility for validating docstring summaries."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_long_description", "line_number": 87, "body": "def test_long_description(\n    source: str,\n    expected_short_desc: str,\n    expected_long_desc: str,\n    expected_blank: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank\n    assert docstring.meta == []", "is_method": false, "function_description": "This function validates that a parsed docstring's short description, long description, blank line presence, and metadata match expected values, supporting accurate docstring parsing tests."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_meta_newlines", "line_number": 187, "body": "def test_meta_newlines(\n    source: str,\n    expected_short_desc: T.Optional[str],\n    expected_long_desc: T.Optional[str],\n    expected_blank_short_desc: bool,\n    expected_blank_long_desc: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank_short_desc\n    assert docstring.blank_after_long_description == expected_blank_long_desc\n    assert len(docstring.meta) == 1", "is_method": false, "function_description": "This function verifies that a parsed docstring's short and long descriptions, blank line flags, and metadata count match expected values. It serves as a test utility to validate docstring parsing accuracy."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_meta_with_multiline_description", "line_number": 202, "body": "def test_meta_with_multiline_description() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        Parameters\n        ----------\n        spam\n            asd\n            1\n                2\n            3\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].args == [\"param\", \"spam\"]\n    assert docstring.meta[0].arg_name == \"spam\"\n    assert docstring.meta[0].description == \"asd\\n1\\n    2\\n3\"", "is_method": false, "function_description": "Test function that validates parsing of multi-line parameter descriptions within a docstring, ensuring correct extraction of short description and parameter metadata."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_default_args", "line_number": 223, "body": "def test_default_args():\n    docstring = parse(\n        \"\"\"\n        A sample function\n\n        A function the demonstrates docstrings\n\n        Parameters\n        ----------\n        arg1 : int\n            The firsty arg\n        arg2 : str\n            The second arg\n        arg3 : float, optional\n            The third arg. Default is 1.0.\n        arg4 : Optional[Dict[str, Any]], optional\n            The fourth arg. Defaults to None\n        arg5 : str, optional\n            The fifth arg. Default: DEFAULT_ARGS\n\n        Returns\n        -------\n        Mapping[str, Any]\n            The args packed in a mapping\n        \"\"\"\n    )\n    assert docstring is not None\n    assert len(docstring.params) == 5\n\n    arg4 = docstring.params[3]\n    assert arg4.arg_name == \"arg4\"\n    assert arg4.is_optional\n    assert arg4.type_name == \"Optional[Dict[str, Any]]\"\n    assert arg4.default == \"None\"\n    assert arg4.description == \"The fourth arg. Defaults to None\"", "is_method": false, "function_description": "This function verifies correct parsing and interpretation of default arguments in a docstring, ensuring argument metadata is accurately extracted for use in documentation or validation purposes."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_other_params", "line_number": 418, "body": "def test_other_params() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        Other Parameters\n        ----------------\n        only_seldom_used_keywords : type, optional\n            Explanation\n        common_parameters_listed_above : type, optional\n            Explanation\n        \"\"\"\n    )\n    assert len(docstring.meta) == 2\n    assert docstring.meta[0].args == [\n        \"other_param\",\n        \"only_seldom_used_keywords\",\n    ]\n    assert docstring.meta[0].arg_name == \"only_seldom_used_keywords\"\n    assert docstring.meta[0].type_name == \"type\"\n    assert docstring.meta[0].is_optional\n    assert docstring.meta[0].description == \"Explanation\"\n\n    assert docstring.meta[1].args == [\n        \"other_param\",\n        \"common_parameters_listed_above\",\n    ]", "is_method": false, "function_description": "This function tests parsing of \"Other Parameters\" in a docstring, verifying correct extraction of parameter metadata and attributes for use in documentation or validation. It serves as a unit test for docstring parsing accuracy."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_yields", "line_number": 446, "body": "def test_yields() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        Yields\n        ------\n        int\n            description\n        \"\"\"\n    )\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].args == [\"yields\"]\n    assert docstring.meta[0].type_name == \"int\"\n    assert docstring.meta[0].description == \"description\"\n    assert docstring.meta[0].return_name is None\n    assert docstring.meta[0].is_generator", "is_method": false, "function_description": "This function validates the parsing of a docstring's \"Yields\" section to ensure it correctly extracts metadata about the yielded values. It serves as a test utility for docstring parsing functionality."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_returns", "line_number": 464, "body": "def test_returns() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        \"\"\"\n    )\n    assert docstring.returns is None\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Returns\n        -------\n        type\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"type\"\n    assert docstring.returns.description is None\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Returns\n        -------\n        int\n            description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"int\"\n    assert docstring.returns.description == \"description\"\n\n    docstring = parse(\n        \"\"\"\n        Returns\n        -------\n        Optional[Mapping[str, List[int]]]\n            A description: with a colon\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"Optional[Mapping[str, List[int]]]\"\n    assert docstring.returns.description == \"A description: with a colon\"\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Returns\n        -------\n        int\n            description\n            with much text\n\n            even some spacing\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"int\"\n    assert docstring.returns.description == (\n        \"description\\n\" \"with much text\\n\\n\" \"even some spacing\"\n    )", "is_method": false, "function_description": "Function that tests the parsing of return type information from docstrings, validating correct extraction of return types and their descriptions in various formats. It ensures the parser accurately identifies and captures return-related details."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_warns", "line_number": 550, "body": "def test_warns() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        Warns\n        -----\n        UserWarning\n            description\n        \"\"\"\n    )\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].type_name == \"UserWarning\"\n    assert docstring.meta[0].description == \"description\"", "is_method": false, "function_description": "This function validates that a docstring parser correctly identifies and extracts warning metadata, specifically UserWarning and its description, ensuring the parser's accuracy for warning annotations."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_examples", "line_number": 611, "body": "def test_examples() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        Examples\n        --------\n        long example\n\n        more here\n        \"\"\"\n    )\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].description == \"long example\\n\\nmore here\"", "is_method": false, "function_description": "Function that validates parsing by checking that example content is correctly extracted from a docstring, useful for testing docstring parsing functionality."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_deprecation", "line_number": 652, "body": "def test_deprecation(\n    source: str,\n    expected_depr_version: T.Optional[str],\n    expected_depr_desc: T.Optional[str],\n) -> None:\n    docstring = parse(source)\n\n    assert docstring.deprecation is not None\n    assert docstring.deprecation.version == expected_depr_version\n    assert docstring.deprecation.description == expected_depr_desc", "is_method": false, "function_description": "Function that validates a parsed docstring's deprecation information against expected version and description values, useful for testing documentation compliance."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_short_description", "line_number": 18, "body": "def test_short_description(source: str, expected: str) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected\n    assert docstring.long_description is None\n    assert docstring.meta == []", "is_method": false, "function_description": "Utility function that verifies if a parsed docstring's short description matches an expected value and confirms the absence of long description or metadata. It aids in validating docstring parsing accuracy during testing."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_long_description", "line_number": 88, "body": "def test_long_description(\n    source: str,\n    expected_short_desc: str,\n    expected_long_desc: str,\n    expected_blank: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank\n    assert docstring.meta == []", "is_method": false, "function_description": "Raises assertions to verify that a parsed docstring matches expected short and long descriptions, and metadata conditions. Useful for testing accurate extraction and classification of docstring components."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_meta_newlines", "line_number": 176, "body": "def test_meta_newlines(\n    source: str,\n    expected_short_desc: T.Optional[str],\n    expected_long_desc: T.Optional[str],\n    expected_blank_short_desc: bool,\n    expected_blank_long_desc: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank_short_desc\n    assert docstring.blank_after_long_description == expected_blank_long_desc\n    assert len(docstring.meta) == 1", "is_method": false, "function_description": "Function that verifies parsing results of a docstring from source code against expected short and long descriptions, blank-line flags, and metadata count for testing docstring parsing accuracy."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_meta_with_multiline_description", "line_number": 191, "body": "def test_meta_with_multiline_description() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        :meta: asd\n            1\n                2\n            3\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].args == [\"meta\"]\n    assert docstring.meta[0].description == \"asd\\n1\\n    2\\n3\"", "is_method": false, "function_description": "This function tests parsing of docstrings containing multiline meta descriptions, verifying that the short description and associated metadata are correctly extracted and formatted. It provides validation for accurate handling of complex docstring metadata entries."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_multiple_meta", "line_number": 208, "body": "def test_multiple_meta() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        :meta1: asd\n            1\n                2\n            3\n        :meta2: herp\n        :meta3: derp\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert len(docstring.meta) == 3\n    assert docstring.meta[0].args == [\"meta1\"]\n    assert docstring.meta[0].description == \"asd\\n1\\n    2\\n3\"\n    assert docstring.meta[1].args == [\"meta2\"]\n    assert docstring.meta[1].description == \"herp\"\n    assert docstring.meta[2].args == [\"meta3\"]\n    assert docstring.meta[2].description == \"derp\"", "is_method": false, "function_description": "This function tests that multiple metadata fields and their multiline descriptions are correctly parsed from a docstring. It ensures the parsing logic accurately extracts short descriptions and associated metadata entries."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_returns", "line_number": 294, "body": "def test_returns() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        \"\"\"\n    )\n    assert docstring.returns is None\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        :returns: description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name is None\n    assert docstring.returns.description == \"description\"\n    assert not docstring.returns.is_generator\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        :returns int: description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"int\"\n    assert docstring.returns.description == \"description\"\n    assert not docstring.returns.is_generator", "is_method": false, "function_description": "This function tests the parsing of return value annotations in docstrings, verifying correct extraction of return descriptions, types, and generator flags. It ensures accurate interpretation of return-related documentation in various formats."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_yields", "line_number": 325, "body": "def test_yields() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        \"\"\"\n    )\n    assert docstring.returns is None\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        :yields: description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name is None\n    assert docstring.returns.description == \"description\"\n    assert docstring.returns.is_generator\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        :yields int: description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"int\"\n    assert docstring.returns.description == \"description\"\n    assert docstring.returns.is_generator", "is_method": false, "function_description": "This function tests the parsing and interpretation of yield annotations in docstrings, verifying correct recognition and extraction of yield types and descriptions for documentation consistency and validation purposes."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_broken_meta", "line_number": 385, "body": "def test_broken_meta() -> None:\n    with pytest.raises(ParseError):\n        parse(\":\")\n\n    with pytest.raises(ParseError):\n        parse(\":param herp derp\")\n\n    with pytest.raises(ParseError):\n        parse(\":param: invalid\")\n\n    with pytest.raises(ParseError):\n        parse(\":param with too many args: desc\")\n\n    # these should not raise any errors\n    parse(\":sthstrange: desc\")", "is_method": false, "function_description": "Function that tests the parse function's error handling by verifying it raises ParseError on malformed metadata inputs and succeeds with valid but unusual metadata strings."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_parser.py", "function": "test_rest", "line_number": 4, "body": "def test_rest() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        Long description\n\n        Causing people to indent:\n\n            A lot sometimes\n\n        :param spam: spam desc\n        :param int bla: bla desc\n        :param str yay:\n        :raises ValueError: exc desc\n        :returns tuple: ret desc\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert docstring.long_description == (\n        \"Long description\\n\\n\"\n        \"Causing people to indent:\\n\\n\"\n        \"    A lot sometimes\"\n    )\n    assert len(docstring.params) == 3\n    assert docstring.params[0].arg_name == \"spam\"\n    assert docstring.params[0].type_name is None\n    assert docstring.params[0].description == \"spam desc\"\n    assert docstring.params[1].arg_name == \"bla\"\n    assert docstring.params[1].type_name == \"int\"\n    assert docstring.params[1].description == \"bla desc\"\n    assert docstring.params[2].arg_name == \"yay\"\n    assert docstring.params[2].type_name == \"str\"\n    assert docstring.params[2].description == \"\"\n    assert len(docstring.raises) == 1\n    assert docstring.raises[0].type_name == \"ValueError\"\n    assert docstring.raises[0].description == \"exc desc\"\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"tuple\"\n    assert docstring.returns.description == \"ret desc\"", "is_method": false, "function_description": "Function that tests the parsing of structured docstrings, verifying correct extraction of descriptions, parameters, exceptions, and return types for validation purposes. It serves as a unit test to ensure reliable docstring interpretation."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_parser.py", "function": "test_google", "line_number": 46, "body": "def test_google() -> None:\n    docstring = parse(\n        \"\"\"Short description\n\n        Long description\n\n        Causing people to indent:\n\n            A lot sometimes\n\n        Args:\n            spam: spam desc\n            bla (int): bla desc\n            yay (str):\n\n        Raises:\n            ValueError: exc desc\n\n        Returns:\n            tuple: ret desc\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert docstring.long_description == (\n        \"Long description\\n\\n\"\n        \"Causing people to indent:\\n\\n\"\n        \"    A lot sometimes\"\n    )\n    assert len(docstring.params) == 3\n    assert docstring.params[0].arg_name == \"spam\"\n    assert docstring.params[0].type_name is None\n    assert docstring.params[0].description == \"spam desc\"\n    assert docstring.params[1].arg_name == \"bla\"\n    assert docstring.params[1].type_name == \"int\"\n    assert docstring.params[1].description == \"bla desc\"\n    assert docstring.params[2].arg_name == \"yay\"\n    assert docstring.params[2].type_name == \"str\"\n    assert docstring.params[2].description == \"\"\n    assert len(docstring.raises) == 1\n    assert docstring.raises[0].type_name == \"ValueError\"\n    assert docstring.raises[0].description == \"exc desc\"\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"tuple\"\n    assert docstring.returns.description == \"ret desc\"", "is_method": false, "function_description": "This function tests the parsing of a structured docstring, verifying that its components like descriptions, parameters, exceptions, and return types are correctly extracted and represented. It serves as a validation utility for docstring parsing correctness."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_parser.py", "function": "test_numpydoc", "line_number": 92, "body": "def test_numpydoc() -> None:\n    docstring = parse(\n        \"\"\"Short description\n\n        Long description\n\n        Causing people to indent:\n\n            A lot sometimes\n\n        Parameters\n        ----------\n        spam\n            spam desc\n        bla : int\n            bla desc\n        yay : str\n\n        Raises\n        ------\n        ValueError\n            exc desc\n\n        Other Parameters\n        ----------------\n        this_guy : int, optional\n            you know him\n\n        Returns\n        -------\n        tuple\n            ret desc\n\n        See Also\n        --------\n        multiple lines...\n        something else?\n\n        Warnings\n        --------\n        multiple lines...\n        none of this is real!\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert docstring.long_description == (\n        \"Long description\\n\\n\"\n        \"Causing people to indent:\\n\\n\"\n        \"    A lot sometimes\"\n    )\n    assert len(docstring.params) == 4\n    assert docstring.params[0].arg_name == \"spam\"\n    assert docstring.params[0].type_name is None\n    assert docstring.params[0].description == \"spam desc\"\n    assert docstring.params[1].arg_name == \"bla\"\n    assert docstring.params[1].type_name == \"int\"\n    assert docstring.params[1].description == \"bla desc\"\n    assert docstring.params[2].arg_name == \"yay\"\n    assert docstring.params[2].type_name == \"str\"\n    assert docstring.params[2].description is None\n    assert docstring.params[3].arg_name == \"this_guy\"\n    assert docstring.params[3].type_name == \"int\"\n    assert docstring.params[3].is_optional\n    assert docstring.params[3].description == \"you know him\"\n\n    assert len(docstring.raises) == 1\n    assert docstring.raises[0].type_name == \"ValueError\"\n    assert docstring.raises[0].description == \"exc desc\"\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"tuple\"\n    assert docstring.returns.description == \"ret desc\"", "is_method": false, "function_description": "This function tests the parsing of a numpydoc-style docstring, verifying correct extraction of descriptions, parameters, exceptions, and return types. It ensures the parser accurately interprets structured docstring components."}]