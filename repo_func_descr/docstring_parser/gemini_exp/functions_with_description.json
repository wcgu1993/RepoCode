[{"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "parse", "line_number": 269, "body": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the Google-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return GoogleParser().parse(text)", "is_method": false, "function_description": "This function parses a Google-style docstring string into its structured components, providing a programmatic representation of its various parts."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "_setup", "line_number": 75, "body": "def _setup(self):\n        if self.title_colon:\n            colon = \":\"\n        else:\n            colon = \"\"\n        self.titles_re = re.compile(\n            \"^(\"\n            + \"|\".join(\"(%s)\" % t for t in self.sections)\n            + \")\"\n            + colon\n            + \"[ \\t\\r\\f\\v]*$\",\n            flags=re.M,\n        )", "is_method": true, "class_name": "GoogleParser", "function_description": "Prepares a regular expression pattern to efficiently match and locate specific section titles within a document, considering optional colons."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "_build_meta", "line_number": 89, "body": "def _build_meta(self, text: str, title: str) -> DocstringMeta:\n        \"\"\"Build docstring element.\n\n        :param text: docstring element text\n        :param title: title of section containing element\n        :return:\n        \"\"\"\n\n        section = self.sections[title]\n\n        if (\n            section.type == SectionType.SINGULAR_OR_MULTIPLE\n            and not MULTIPLE_PATTERN.match(text)\n        ) or section.type == SectionType.SINGULAR:\n            return self._build_single_meta(section, text)\n\n        # Split spec and description\n        before, desc = text.split(\":\", 1)\n        if desc:\n            desc = desc[1:] if desc[0] == \" \" else desc\n            if \"\\n\" in desc:\n                first_line, rest = desc.split(\"\\n\", 1)\n                desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n            desc = desc.strip(\"\\n\")\n\n        return self._build_multi_meta(section, before, desc)", "is_method": true, "class_name": "GoogleParser", "function_description": "Parses a Google-style docstring element, structuring its text into `DocstringMeta`. It handles both single and multi-item descriptions for accurate interpretation."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "_build_single_meta", "line_number": 116, "body": "def _build_single_meta(self, section: Section, desc: str) -> DocstringMeta:\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key],\n                description=desc,\n                type_name=None,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key], description=desc, type_name=None\n            )\n        if section.key in PARAM_KEYWORDS:\n            raise ParseError(\"Expected paramenter name.\")\n        return DocstringMeta(args=[section.key], description=desc)", "is_method": true, "class_name": "GoogleParser", "function_description": "Constructs a specific `DocstringMeta` object for a docstring section based on its keyword, differentiating between returns, yields, and raises. This helper method standardizes metadata creation for a Google-style docstring parser."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "_build_multi_meta", "line_number": 132, "body": "def _build_multi_meta(\n        self, section: Section, before: str, desc: str\n    ) -> DocstringMeta:\n        if section.key in PARAM_KEYWORDS:\n            m = GOOGLE_TYPED_ARG_REGEX.match(before)\n            if m:\n                arg_name, type_name = m.group(1, 2)\n                if type_name.endswith(\", optional\"):\n                    is_optional = True\n                    type_name = type_name[:-10]\n                elif type_name.endswith(\"?\"):\n                    is_optional = True\n                    type_name = type_name[:-1]\n                else:\n                    is_optional = False\n            else:\n                arg_name, type_name = before, None\n                is_optional = None\n\n            m = GOOGLE_ARG_DESC_REGEX.match(desc)\n            default = m.group(1) if m else None\n\n            return DocstringParam(\n                args=[section.key, before],\n                description=desc,\n                arg_name=arg_name,\n                type_name=type_name,\n                is_optional=is_optional,\n                default=default,\n            )\n        if section.key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n            return DocstringReturns(\n                args=[section.key, before],\n                description=desc,\n                type_name=before,\n                is_generator=section.key in YIELDS_KEYWORDS,\n            )\n        if section.key in RAISES_KEYWORDS:\n            return DocstringRaises(\n                args=[section.key, before], description=desc, type_name=before\n            )\n        return DocstringMeta(args=[section.key, before], description=desc)", "is_method": true, "class_name": "GoogleParser", "function_description": "A `GoogleParser` helper method that parses sections of a Google-style docstring. It extracts and structures metadata for parameters, return values, and raised exceptions into specialized `DocstringMeta` objects."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "add_section", "line_number": 175, "body": "def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()", "is_method": true, "class_name": "GoogleParser", "function_description": "Adds or replaces a section within the GoogleParser's internal document representation. This enables dynamic modification and structuring of the parsed content."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/google.py", "function": "parse", "line_number": 184, "body": "def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the Google-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        # Split by sections determined by titles\n        matches = list(self.titles_re.finditer(meta_chunk))\n        if not matches:\n            return ret\n        splits = []\n        for j in range(len(matches) - 1):\n            splits.append((matches[j].end(), matches[j + 1].start()))\n        splits.append((matches[-1].end(), len(meta_chunk)))\n\n        chunks = OrderedDict()\n        for j, (start, end) in enumerate(splits):\n            title = matches[j].group(1)\n            if title not in self.sections:\n                continue\n            chunks[title] = meta_chunk[start:end].strip(\"\\n\")\n        if not chunks:\n            return ret\n\n        # Add elements from each chunk\n        for title, chunk in chunks.items():\n            # Determine indent\n            indent_match = re.search(r\"^\\s+\", chunk)\n            if not indent_match:\n                raise ParseError('Can\\'t infer indent from \"{}\"'.format(chunk))\n            indent = indent_match.group()\n\n            # Check for singular elements\n            if self.sections[title].type in [\n                SectionType.SINGULAR,\n                SectionType.SINGULAR_OR_MULTIPLE,\n            ]:\n                part = inspect.cleandoc(chunk)\n                ret.meta.append(self._build_meta(part, title))\n                continue\n\n            # Split based on lines which have exactly that indent\n            _re = \"^\" + indent + r\"(?=\\S)\"\n            c_matches = list(re.finditer(_re, chunk, flags=re.M))\n            if not c_matches:\n                raise ParseError(\n                    'No specification for \"{}\": \"{}\"'.format(title, chunk)\n                )\n            c_splits = []\n            for j in range(len(c_matches) - 1):\n                c_splits.append((c_matches[j].end(), c_matches[j + 1].start()))\n            c_splits.append((c_matches[-1].end(), len(chunk)))\n            for j, (start, end) in enumerate(c_splits):\n                part = chunk[start:end].strip(\"\\n\")\n                ret.meta.append(self._build_meta(part, title))\n\n        return ret", "is_method": true, "class_name": "GoogleParser", "function_description": "This method of `GoogleParser` transforms a Google-style docstring string into a structured `Docstring` object. It extracts and organizes descriptions and categorized metadata for programmatic use."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/parser.py", "function": "parse", "line_number": 7, "body": "def parse(text: str, style: Style = Style.auto) -> Docstring:\n    \"\"\"Parse the docstring into its components.\n\n    :param text: docstring text to parse\n    :param style: docstring style\n    :returns: parsed docstring representation\n    \"\"\"\n\n    if style != Style.auto:\n        return STYLES[style](text)\n    rets = []\n    for parse_ in STYLES.values():\n        try:\n            rets.append(parse_(text))\n        except ParseError as e:\n            exc = e\n    if not rets:\n        raise exc\n    return sorted(rets, key=lambda d: len(d.meta), reverse=True)[0]", "is_method": false, "function_description": "Parses raw docstring text into a structured Docstring object. It supports various docstring styles, including automatic style detection, for programmatic analysis and documentation generation."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_pairwise", "line_number": 21, "body": "def _pairwise(iterable: T.Iterable, end=None) -> T.Iterable:\n    a, b = itertools.tee(iterable)\n    next(b, None)\n    return itertools.zip_longest(a, b, fillvalue=end)", "is_method": false, "function_description": "Provides an iterator for processing an iterable in consecutive, overlapping pairs. An optional fill value handles the last element."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_clean_str", "line_number": 27, "body": "def _clean_str(string: str) -> T.Optional[str]:\n    string = string.strip()\n    if len(string) > 0:\n        return string", "is_method": false, "function_description": "This function cleans a string by removing leading/trailing whitespace. It returns the cleaned string, or None if the string is empty or contains only whitespace after cleaning."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "parse", "line_number": 326, "body": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the numpy-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    return NumpydocParser().parse(text)", "is_method": false, "function_description": "Parses a numpy-style docstring from a text string into its structured components. This enables programmatic access and analysis of docstring content."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "title_pattern", "line_number": 63, "body": "def title_pattern(self) -> str:\n        \"\"\"Regular expression pattern matching this section's header.\n\n        This pattern will match this instance's ``title`` attribute in\n        an anonymous group.\n        \"\"\"\n        return r\"^({})\\s*?\\n{}\\s*$\".format(self.title, \"-\" * len(self.title))", "is_method": true, "class_name": "Section", "function_description": "Provides a regular expression pattern tailored to match this section's header, including its title and underline. Useful for parsing text to locate section boundaries."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "parse", "line_number": 71, "body": "def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        \"\"\"Parse ``DocstringMeta`` objects from the body of this section.\n\n        :param text: section body text. Should be cleaned with\n                     ``inspect.cleandoc`` before parsing.\n        \"\"\"\n        yield DocstringMeta([self.key], description=_clean_str(text))", "is_method": true, "class_name": "Section", "function_description": "This method parses the given text body, converting it into a `DocstringMeta` object. It represents the section's content as structured documentation metadata, using the section's key."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "parse", "line_number": 94, "body": "def parse(self, text: str) -> T.Iterable[DocstringMeta]:\n        for match, next_match in _pairwise(KV_REGEX.finditer(text)):\n            start = match.end()\n            end = next_match.start() if next_match is not None else None\n            value = text[start:end]\n            yield self._parse_item(\n                key=match.group(), value=inspect.cleandoc(value)\n            )", "is_method": true, "class_name": "_KVSection", "function_description": "Parses input text to extract key-value sections defined by a regex. It yields structured `DocstringMeta` objects, providing cleaned metadata for further processing."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "title_pattern", "line_number": 113, "body": "def title_pattern(self) -> str:\n        return r\"^\\.\\.\\s*({})\\s*::\".format(self.title)", "is_method": true, "class_name": "_SphinxSection", "function_description": "Provides a regular expression pattern to match the reStructuredText directive that defines the section's title within Sphinx documentation."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_parse_item", "line_number": 128, "body": "def _parse_item(self, key: str, value: str) -> DocstringParam:\n        m = PARAM_KEY_REGEX.match(key)\n        arg_name = type_name = is_optional = None\n        if m is not None:\n            arg_name, type_name = m.group(\"name\"), m.group(\"type\")\n            if type_name is not None:\n                optional_match = PARAM_OPTIONAL_REGEX.match(type_name)\n                if optional_match is not None:\n                    type_name = optional_match.group(\"type\")\n                    is_optional = True\n                else:\n                    is_optional = False\n\n        default = None\n        if len(value) > 0:\n            default_match = PARAM_DEFAULT_REGEX.search(value)\n            if default_match is not None:\n                default = default_match.group(\"value\")\n\n        return DocstringParam(\n            args=[self.key, arg_name],\n            description=_clean_str(value),\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )", "is_method": true, "class_name": "ParamSection", "function_description": "Parses a raw key-value pair from a docstring's parameter section. It extracts the argument's name, type, optionality, and default value, returning a structured DocstringParam object."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_parse_item", "line_number": 165, "body": "def _parse_item(self, key: str, value: str) -> DocstringRaises:\n        return DocstringRaises(\n            args=[self.key, key],\n            description=_clean_str(value),\n            type_name=key if len(key) > 0 else None,\n        )", "is_method": true, "class_name": "RaisesSection", "function_description": "Parses a single exception entry from a docstring's 'raises' section. It constructs a structured `DocstringRaises` object representing the exception type and its description."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_parse_item", "line_number": 185, "body": "def _parse_item(self, key: str, value: str) -> DocstringReturns:\n        m = RETURN_KEY_REGEX.match(key)\n        if m is not None:\n            return_name, type_name = m.group(\"name\"), m.group(\"type\")\n        else:\n            return_name = type_name = None\n\n        return DocstringReturns(\n            args=[self.key],\n            description=_clean_str(value),\n            type_name=type_name,\n            is_generator=self.is_generator,\n            return_name=return_name,\n        )", "is_method": true, "class_name": "ReturnsSection", "function_description": "Converts a docstring return key and its description into a structured `DocstringReturns` object, extracting the return name and type. This supports detailed docstring analysis."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "parse", "line_number": 210, "body": "def parse(self, text: str) -> T.Iterable[DocstringDeprecated]:\n        version, desc, *_ = text.split(sep=\"\\n\", maxsplit=1) + [None, None]\n\n        if desc is not None:\n            desc = _clean_str(inspect.cleandoc(desc))\n\n        yield DocstringDeprecated(\n            args=[self.key], description=desc, version=_clean_str(version)\n        )", "is_method": true, "class_name": "DeprecationSection", "function_description": "Parses a raw text string containing deprecation information, separating the version from the description. It yields a structured `DocstringDeprecated` object, enabling standardized representation of deprecation notices."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "_setup", "line_number": 266, "body": "def _setup(self):\n        self.titles_re = re.compile(\n            r\"|\".join(s.title_pattern for s in self.sections.values()),\n            flags=re.M,\n        )", "is_method": true, "class_name": "NumpydocParser", "function_description": "This internal method prepares the parser by pre-compiling a regular expression. It allows the parser to efficiently find all known section titles within numpydoc-formatted strings, optimizing subsequent parsing."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "add_section", "line_number": 272, "body": "def add_section(self, section: Section):\n        \"\"\"Add or replace a section.\n\n        :param section: The new section.\n        \"\"\"\n\n        self.sections[section.title] = section\n        self._setup()", "is_method": true, "class_name": "NumpydocParser", "function_description": "Adds or replaces a section within the parser's internal representation, managing the structured content of a numpydoc-style docstring."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/numpydoc.py", "function": "parse", "line_number": 281, "body": "def parse(self, text: str) -> Docstring:\n        \"\"\"Parse the numpy-style docstring into its components.\n\n        :returns: parsed docstring\n        \"\"\"\n        ret = Docstring()\n        if not text:\n            return ret\n\n        # Clean according to PEP-0257\n        text = inspect.cleandoc(text)\n\n        # Find first title and split on its position\n        match = self.titles_re.search(text)\n        if match:\n            desc_chunk = text[: match.start()]\n            meta_chunk = text[match.start() :]\n        else:\n            desc_chunk = text\n            meta_chunk = \"\"\n\n        # Break description into short and long parts\n        parts = desc_chunk.split(\"\\n\", 1)\n        ret.short_description = parts[0] or None\n        if len(parts) > 1:\n            long_desc_chunk = parts[1] or \"\"\n            ret.blank_after_short_description = long_desc_chunk.startswith(\n                \"\\n\"\n            )\n            ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n            ret.long_description = long_desc_chunk.strip() or None\n\n        for match, nextmatch in _pairwise(self.titles_re.finditer(meta_chunk)):\n            title = next(g for g in match.groups() if g is not None)\n            factory = self.sections[title]\n\n            # section chunk starts after the header,\n            # ends at the start of the next header\n            start = match.end()\n            end = nextmatch.start() if nextmatch is not None else None\n            ret.meta.extend(factory.parse(meta_chunk[start:end]))\n\n        return ret", "is_method": true, "class_name": "NumpydocParser", "function_description": "Parses a numpy-style docstring string into a structured `Docstring` object. It extracts and organizes the short description, long description, and various meta-sections, enabling programmatic access to docstring components."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/rest.py", "function": "_build_meta", "line_number": 21, "body": "def _build_meta(args: T.List[str], desc: str) -> DocstringMeta:\n    key = args[0]\n\n    if key in PARAM_KEYWORDS:\n        if len(args) == 3:\n            key, type_name, arg_name = args\n            if type_name.endswith(\"?\"):\n                is_optional = True\n                type_name = type_name[:-1]\n            else:\n                is_optional = False\n        elif len(args) == 2:\n            key, arg_name = args\n            type_name = None\n            is_optional = None\n        else:\n            raise ParseError(\n                \"Expected one or two arguments for a {} keyword.\".format(key)\n            )\n\n        m = re.match(r\".*defaults to (.+)\", desc, flags=re.DOTALL)\n        default = m.group(1).rstrip(\".\") if m else None\n\n        return DocstringParam(\n            args=args,\n            description=desc,\n            arg_name=arg_name,\n            type_name=type_name,\n            is_optional=is_optional,\n            default=default,\n        )\n\n    if key in RETURNS_KEYWORDS | YIELDS_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n\n        return DocstringReturns(\n            args=args,\n            description=desc,\n            type_name=type_name,\n            is_generator=key in YIELDS_KEYWORDS,\n        )\n\n    if key in RAISES_KEYWORDS:\n        if len(args) == 2:\n            type_name = args[1]\n        elif len(args) == 1:\n            type_name = None\n        else:\n            raise ParseError(\n                \"Expected one or no arguments for a {} keyword.\".format(key)\n            )\n        return DocstringRaises(\n            args=args, description=desc, type_name=type_name\n        )\n\n    return DocstringMeta(args=args, description=desc)", "is_method": false, "function_description": "Parses a segment of a docstring, converting keyword-prefixed lines into structured metadata objects. It extracts details for parameters, return values, or raised exceptions, facilitating docstring analysis."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/rest.py", "function": "parse", "line_number": 86, "body": "def parse(text: str) -> Docstring:\n    \"\"\"Parse the ReST-style docstring into its components.\n\n    :returns: parsed docstring\n    \"\"\"\n    ret = Docstring()\n    if not text:\n        return ret\n\n    text = inspect.cleandoc(text)\n    match = re.search(\"^:\", text, flags=re.M)\n    if match:\n        desc_chunk = text[: match.start()]\n        meta_chunk = text[match.start() :]\n    else:\n        desc_chunk = text\n        meta_chunk = \"\"\n\n    parts = desc_chunk.split(\"\\n\", 1)\n    ret.short_description = parts[0] or None\n    if len(parts) > 1:\n        long_desc_chunk = parts[1] or \"\"\n        ret.blank_after_short_description = long_desc_chunk.startswith(\"\\n\")\n        ret.blank_after_long_description = long_desc_chunk.endswith(\"\\n\\n\")\n        ret.long_description = long_desc_chunk.strip() or None\n\n    for match in re.finditer(\n        r\"(^:.*?)(?=^:|\\Z)\", meta_chunk, flags=re.S | re.M\n    ):\n        chunk = match.group(0)\n        if not chunk:\n            continue\n        try:\n            args_chunk, desc_chunk = chunk.lstrip(\":\").split(\":\", 1)\n        except ValueError:\n            raise ParseError(\n                'Error parsing meta information near \"{}\".'.format(chunk)\n            )\n        args = args_chunk.split()\n        desc = desc_chunk.strip()\n        if \"\\n\" in desc:\n            first_line, rest = desc.split(\"\\n\", 1)\n            desc = first_line + \"\\n\" + inspect.cleandoc(rest)\n\n        ret.meta.append(_build_meta(args, desc))\n\n    return ret", "is_method": false, "function_description": "This function parses a ReST-style docstring string into a structured Docstring object. It extracts the short description, long description, and metadata such as parameters and return values, for programmatic access."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/common.py", "function": "params", "line_number": 125, "body": "def params(self) -> T.List[DocstringParam]:\n        return [item for item in self.meta if isinstance(item, DocstringParam)]", "is_method": true, "class_name": "Docstring", "function_description": "Retrieves all parameter definitions parsed from the docstring. It provides a structured list of arguments for documentation or static analysis tools."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/common.py", "function": "raises", "line_number": 129, "body": "def raises(self) -> T.List[DocstringRaises]:\n        return [\n            item for item in self.meta if isinstance(item, DocstringRaises)\n        ]", "is_method": true, "class_name": "Docstring", "function_description": "This method extracts and returns all documented 'raises' sections from a docstring. It provides a structured list of `DocstringRaises` objects, detailing potential exceptions."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/common.py", "function": "returns", "line_number": 135, "body": "def returns(self) -> T.Optional[DocstringReturns]:\n        for item in self.meta:\n            if isinstance(item, DocstringReturns):\n                return item\n        return None", "is_method": true, "class_name": "Docstring", "function_description": "This method of the `Docstring` class retrieves the parsed return type and description information from the docstring's metadata, if specified. It provides structured access to the function's return specification."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/common.py", "function": "deprecation", "line_number": 142, "body": "def deprecation(self) -> T.Optional[DocstringDeprecated]:\n        for item in self.meta:\n            if isinstance(item, DocstringDeprecated):\n                return item\n        return None", "is_method": true, "class_name": "Docstring", "function_description": "Retrieves deprecation metadata from the docstring, if present. This service helps identify and flag deprecated code elements."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_google_parser", "line_number": 8, "body": "def test_google_parser():\n    parser = GoogleParser()\n    docstring = parse(\n        \"\"\"\n        Unknown:\n            spam: a\n        \"\"\"\n    )\n    assert docstring.short_description == \"Unknown:\"\n    assert docstring.long_description == \"spam: a\"\n    assert len(docstring.meta) == 0\n\n    parser = GoogleParser(\n        [\n            Section(\"DESCRIPTION\", \"desc\", SectionType.SINGULAR),\n            Section(\"ARGUMENTS\", \"param\", SectionType.MULTIPLE),\n            Section(\"ATTRIBUTES\", \"attribute\", SectionType.MULTIPLE),\n            Section(\"EXAMPLES\", \"examples\", SectionType.SINGULAR),\n        ],\n        title_colon=False,\n    )\n    docstring = parser.parse(\n        \"\"\"\n        DESCRIPTION\n            This is the description.\n\n        ARGUMENTS\n            arg1: first arg\n            arg2: second arg\n\n        ATTRIBUTES\n            attr1: first attribute\n            attr2: second attribute\n\n        EXAMPLES\n            Many examples\n            More examples\n        \"\"\"\n    )\n\n    assert docstring.short_description is None\n    assert docstring.long_description is None\n    assert len(docstring.meta) == 6\n    assert docstring.meta[0].args == [\"desc\"]\n    assert docstring.meta[0].description == \"This is the description.\"\n    assert docstring.meta[1].args == [\"param\", \"arg1\"]\n    assert docstring.meta[1].description == \"first arg\"\n    assert docstring.meta[2].args == [\"param\", \"arg2\"]\n    assert docstring.meta[2].description == \"second arg\"\n    assert docstring.meta[3].args == [\"attribute\", \"attr1\"]\n    assert docstring.meta[3].description == \"first attribute\"\n    assert docstring.meta[4].args == [\"attribute\", \"attr2\"]\n    assert docstring.meta[4].description == \"second attribute\"\n    assert docstring.meta[5].args == [\"examples\"]\n    assert docstring.meta[5].description == \"Many examples\\nMore examples\"\n\n    parser.add_section(Section(\"Note\", \"note\", SectionType.SINGULAR))\n    docstring = parser.parse(\n        \"\"\"\n        short description\n\n        Note:\n            a note\n        \"\"\"\n    )\n    assert docstring.short_description == \"short description\"\n    assert docstring.long_description == \"Note:\\n    a note\"\n\n    docstring = parser.parse(\n        \"\"\"\n        short description\n\n        Note a note\n        \"\"\"\n    )\n    assert docstring.short_description == \"short description\"\n    assert docstring.long_description == \"Note a note\"\n\n    docstring = parser.parse(\n        \"\"\"\n        short description\n\n        Note\n            a note\n        \"\"\"\n    )\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].args == [\"note\"]\n    assert docstring.meta[0].description == \"a note\"", "is_method": false, "function_description": "Verifies the GoogleParser's ability to correctly parse various Google-style docstrings, ensuring accurate extraction of short/long descriptions and structured metadata sections based on defined rules."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_short_description", "line_number": 109, "body": "def test_short_description(source: str, expected: str) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected\n    assert docstring.long_description is None\n    assert docstring.meta == []", "is_method": false, "function_description": "This function is a unit test that verifies a parsing utility accurately extracts only the short description from a docstring. It ensures that the parsing mechanism correctly identifies and isolates the brief summary."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_long_description", "line_number": 179, "body": "def test_long_description(\n    source: str,\n    expected_short_desc: str,\n    expected_long_desc: str,\n    expected_blank: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank\n    assert docstring.meta == []", "is_method": false, "function_description": "Tests the parsing logic for Python docstrings. It verifies the correct extraction of short and long descriptions and blank line presence."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_meta_newlines", "line_number": 273, "body": "def test_meta_newlines(\n    source: str,\n    expected_short_desc: T.Optional[str],\n    expected_long_desc: T.Optional[str],\n    expected_blank_short_desc: bool,\n    expected_blank_long_desc: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank_short_desc\n    assert docstring.blank_after_long_description == expected_blank_long_desc\n    assert len(docstring.meta) == 1", "is_method": false, "function_description": "Tests the parsing of docstrings to ensure correct extraction of short and long descriptions, including handling of blank lines and meta information."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_meta_with_multiline_description", "line_number": 288, "body": "def test_meta_with_multiline_description() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        Args:\n            spam: asd\n                1\n                    2\n                3\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].args == [\"param\", \"spam\"]\n    assert docstring.meta[0].arg_name == \"spam\"\n    assert docstring.meta[0].description == \"asd\\n1\\n    2\\n3\"", "is_method": false, "function_description": "This function tests a docstring parser. It verifies the correct extraction of the short description and proper handling of multi-line argument descriptions, preserving indentation and newlines."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_default_args", "line_number": 307, "body": "def test_default_args():\n    docstring = parse(\n        \"\"\"A sample function\n\n    A function the demonstrates docstrings\n    \n    Args:\n        arg1 (int): The firsty arg\n        arg2 (str): The second arg\n        arg3 (float, optional): The third arg. Defaults to 1.0.\n        arg4 (Optional[Dict[str, Any]], optional): The fourth arg. Defaults to None.\n        arg5 (str, optional): The fifth arg. Defaults to DEFAULT_ARG5.\n    \n    Returns:\n        Mapping[str, Any]: The args packed in a mapping\n    \"\"\"\n    )\n    assert docstring is not None\n    assert len(docstring.params) == 5\n\n    arg4 = docstring.params[3]\n    assert arg4.arg_name == \"arg4\"\n    assert arg4.is_optional\n    assert arg4.type_name == \"Optional[Dict[str, Any]]\"\n    assert arg4.default == \"None\"\n    assert arg4.description == \"The fourth arg. Defaults to None.\"", "is_method": false, "function_description": "Tests the docstring parser's ability to correctly extract parameter information, including default values and optional types, from a sample docstring."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_multiple_meta", "line_number": 335, "body": "def test_multiple_meta() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        Args:\n            spam: asd\n                1\n                    2\n                3\n\n        Raises:\n            bla: herp\n            yay: derp\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert len(docstring.meta) == 3\n    assert docstring.meta[0].args == [\"param\", \"spam\"]\n    assert docstring.meta[0].arg_name == \"spam\"\n    assert docstring.meta[0].description == \"asd\\n1\\n    2\\n3\"\n    assert docstring.meta[1].args == [\"raises\", \"bla\"]\n    assert docstring.meta[1].type_name == \"bla\"\n    assert docstring.meta[1].description == \"herp\"\n    assert docstring.meta[2].args == [\"raises\", \"yay\"]\n    assert docstring.meta[2].type_name == \"yay\"\n    assert docstring.meta[2].description == \"derp\"", "is_method": false, "function_description": "Verifies that the docstring parsing logic correctly extracts the short description and multiple, potentially multi-line, metadata fields like arguments and raised exceptions."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_returns", "line_number": 472, "body": "def test_returns() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        \"\"\"\n    )\n    assert docstring.returns is None\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Returns:\n            description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name is None\n    assert docstring.returns.description == \"description\"\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Returns:\n            description with: a colon!\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name is None\n    assert docstring.returns.description == \"description with: a colon!\"\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Returns:\n            int: description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"int\"\n    assert docstring.returns.description == \"description\"\n\n    docstring = parse(\n        \"\"\"\n        Returns:\n            Optional[Mapping[str, List[int]]]: A description: with a colon\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"Optional[Mapping[str, List[int]]]\"\n    assert docstring.returns.description == \"A description: with a colon\"\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Yields:\n            int: description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"int\"\n    assert docstring.returns.description == \"description\"\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        Returns:\n            int: description\n            with much text\n\n            even some spacing\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"int\"\n    assert docstring.returns.description == (\n        \"description\\n\" \"with much text\\n\\n\" \"even some spacing\"\n    )", "is_method": false, "function_description": "This function is a unit test that validates the robust parsing of 'Returns:' and 'Yields:' sections within a docstring. It ensures the correct extraction of return types and descriptions by the docstring parser."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_google.py", "function": "test_examples", "line_number": 571, "body": "def test_examples() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        Example:\n            example: 1\n        Examples:\n            long example\n\n            more here\n        \"\"\"\n    )\n    assert len(docstring.meta) == 2\n    assert docstring.meta[0].description == \"example: 1\"\n    assert docstring.meta[1].description == \"long example\\n\\nmore here\"", "is_method": false, "function_description": "Verifies the parsing of 'Example' and 'Examples' sections within a docstring, ensuring accurate extraction of example descriptions as metadata."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_short_description", "line_number": 17, "body": "def test_short_description(source: str, expected: str) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected\n    assert docstring.long_description is None\n    assert docstring.meta == []", "is_method": false, "function_description": "Tests if a docstring parser correctly extracts the short description from a source string, ensuring no long description or metadata is present."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_long_description", "line_number": 87, "body": "def test_long_description(\n    source: str,\n    expected_short_desc: str,\n    expected_long_desc: str,\n    expected_blank: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank\n    assert docstring.meta == []", "is_method": false, "function_description": "Tests the docstring parser's ability to accurately separate short and long descriptions and detect blank lines."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_meta_newlines", "line_number": 187, "body": "def test_meta_newlines(\n    source: str,\n    expected_short_desc: T.Optional[str],\n    expected_long_desc: T.Optional[str],\n    expected_blank_short_desc: bool,\n    expected_blank_long_desc: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank_short_desc\n    assert docstring.blank_after_long_description == expected_blank_long_desc\n    assert len(docstring.meta) == 1", "is_method": false, "function_description": "Tests a docstring parser's ability to correctly extract short and long descriptions and detect blank lines. It also verifies proper handling of metadata and newlines within the docstring structure."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_meta_with_multiline_description", "line_number": 202, "body": "def test_meta_with_multiline_description() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        Parameters\n        ----------\n        spam\n            asd\n            1\n                2\n            3\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].args == [\"param\", \"spam\"]\n    assert docstring.meta[0].arg_name == \"spam\"\n    assert docstring.meta[0].description == \"asd\\n1\\n    2\\n3\"", "is_method": false, "function_description": "Tests a docstring parser's capability to correctly extract and represent multi-line parameter descriptions, including nested indentation, ensuring accurate documentation parsing."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_default_args", "line_number": 223, "body": "def test_default_args():\n    docstring = parse(\n        \"\"\"\n        A sample function\n\n        A function the demonstrates docstrings\n\n        Parameters\n        ----------\n        arg1 : int\n            The firsty arg\n        arg2 : str\n            The second arg\n        arg3 : float, optional\n            The third arg. Default is 1.0.\n        arg4 : Optional[Dict[str, Any]], optional\n            The fourth arg. Defaults to None\n        arg5 : str, optional\n            The fifth arg. Default: DEFAULT_ARGS\n\n        Returns\n        -------\n        Mapping[str, Any]\n            The args packed in a mapping\n        \"\"\"\n    )\n    assert docstring is not None\n    assert len(docstring.params) == 5\n\n    arg4 = docstring.params[3]\n    assert arg4.arg_name == \"arg4\"\n    assert arg4.is_optional\n    assert arg4.type_name == \"Optional[Dict[str, Any]]\"\n    assert arg4.default == \"None\"\n    assert arg4.description == \"The fourth arg. Defaults to None\"", "is_method": false, "function_description": "This test function verifies the correct parsing and extraction of information for optional parameters, including their default values, from a docstring. It ensures a docstring parsing utility accurately represents parameter metadata."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_multiple_meta", "line_number": 260, "body": "def test_multiple_meta() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        Parameters\n        ----------\n        spam\n            asd\n            1\n                2\n            3\n\n        Raises\n        ------\n        bla\n            herp\n        yay\n            derp\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert len(docstring.meta) == 3\n    assert docstring.meta[0].args == [\"param\", \"spam\"]\n    assert docstring.meta[0].arg_name == \"spam\"\n    assert docstring.meta[0].description == \"asd\\n1\\n    2\\n3\"\n    assert docstring.meta[1].args == [\"raises\", \"bla\"]\n    assert docstring.meta[1].type_name == \"bla\"\n    assert docstring.meta[1].description == \"herp\"\n    assert docstring.meta[2].args == [\"raises\", \"yay\"]\n    assert docstring.meta[2].type_name == \"yay\"\n    assert docstring.meta[2].description == \"derp\"", "is_method": false, "function_description": "Verifies that the docstring parsing utility correctly handles docstrings with multiple meta sections, such as parameters and raises, including multi-line descriptions. It ensures accurate extraction of all docstring elements."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_params", "line_number": 294, "body": "def test_params() -> None:\n    docstring = parse(\"Short description\")\n    assert len(docstring.params) == 0\n\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        Parameters\n        ----------\n        name\n            description 1\n        priority : int\n            description 2\n        sender : str, optional\n            description 3\n        ratio : Optional[float], optional\n            description 4\n        \"\"\"\n    )\n    assert len(docstring.params) == 4\n    assert docstring.params[0].arg_name == \"name\"\n    assert docstring.params[0].type_name is None\n    assert docstring.params[0].description == \"description 1\"\n    assert not docstring.params[0].is_optional\n    assert docstring.params[1].arg_name == \"priority\"\n    assert docstring.params[1].type_name == \"int\"\n    assert docstring.params[1].description == \"description 2\"\n    assert not docstring.params[1].is_optional\n    assert docstring.params[2].arg_name == \"sender\"\n    assert docstring.params[2].type_name == \"str\"\n    assert docstring.params[2].description == \"description 3\"\n    assert docstring.params[2].is_optional\n    assert docstring.params[3].arg_name == \"ratio\"\n    assert docstring.params[3].type_name == \"Optional[float]\"\n    assert docstring.params[3].description == \"description 4\"\n    assert docstring.params[3].is_optional\n\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        Parameters\n        ----------\n        name\n            description 1\n            with multi-line text\n        priority : int\n            description 2\n        \"\"\"\n    )\n    assert len(docstring.params) == 2\n    assert docstring.params[0].arg_name == \"name\"\n    assert docstring.params[0].type_name is None\n    assert docstring.params[0].description == (\n        \"description 1\\n\" \"with multi-line text\"\n    )\n    assert docstring.params[1].arg_name == \"priority\"\n    assert docstring.params[1].type_name == \"int\"\n    assert docstring.params[1].description == \"description 2\"", "is_method": false, "function_description": "Tests the ability of a docstring parser to correctly extract parameter details. It verifies names, types, descriptions, and optional status from various docstring formats."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_warns", "line_number": 550, "body": "def test_warns() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        Warns\n        -----\n        UserWarning\n            description\n        \"\"\"\n    )\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].type_name == \"UserWarning\"\n    assert docstring.meta[0].description == \"description\"", "is_method": false, "function_description": "Tests the parsing of docstrings containing a 'Warns' section. Ensures correct extraction of warning types and their associated descriptions."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_examples", "line_number": 611, "body": "def test_examples() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        Examples\n        --------\n        long example\n\n        more here\n        \"\"\"\n    )\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].description == \"long example\\n\\nmore here\"", "is_method": false, "function_description": "This function validates the parsing of docstrings, specifically confirming the accurate extraction and storage of content from 'Examples' sections."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_numpydoc.py", "function": "test_deprecation", "line_number": 652, "body": "def test_deprecation(\n    source: str,\n    expected_depr_version: T.Optional[str],\n    expected_depr_desc: T.Optional[str],\n) -> None:\n    docstring = parse(source)\n\n    assert docstring.deprecation is not None\n    assert docstring.deprecation.version == expected_depr_version\n    assert docstring.deprecation.description == expected_depr_desc", "is_method": false, "function_description": "This function tests the correct parsing and extraction of deprecation information from a source string. It verifies that the parsed deprecation version and description match expected values."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_short_description", "line_number": 18, "body": "def test_short_description(source: str, expected: str) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected\n    assert docstring.long_description is None\n    assert docstring.meta == []", "is_method": false, "function_description": "This function is a unit test that verifies a docstring parsing utility. It checks if the utility correctly extracts the short description and handles long description and metadata as expected."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_long_description", "line_number": 88, "body": "def test_long_description(\n    source: str,\n    expected_short_desc: str,\n    expected_long_desc: str,\n    expected_blank: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank\n    assert docstring.meta == []", "is_method": false, "function_description": "This function serves as a test case to verify that a `parse` utility correctly extracts and separates short and long descriptions from a docstring. It ensures accurate parsing of docstring structure and content."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_meta_newlines", "line_number": 176, "body": "def test_meta_newlines(\n    source: str,\n    expected_short_desc: T.Optional[str],\n    expected_long_desc: T.Optional[str],\n    expected_blank_short_desc: bool,\n    expected_blank_long_desc: bool,\n) -> None:\n    docstring = parse(source)\n    assert docstring.short_description == expected_short_desc\n    assert docstring.long_description == expected_long_desc\n    assert docstring.blank_after_short_description == expected_blank_short_desc\n    assert docstring.blank_after_long_description == expected_blank_long_desc\n    assert len(docstring.meta) == 1", "is_method": false, "function_description": "This function tests a docstring parser by verifying correct extraction of short and long descriptions, blank line indicators, and meta-information from a source string."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_meta_with_multiline_description", "line_number": 191, "body": "def test_meta_with_multiline_description() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        :meta: asd\n            1\n                2\n            3\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].args == [\"meta\"]\n    assert docstring.meta[0].description == \"asd\\n1\\n    2\\n3\"", "is_method": false, "function_description": "Tests the parsing of docstrings with multi-line `:meta:` tags. It verifies that the docstring parser correctly extracts the short description and the full, formatted content of the meta tag."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_meta_with_args", "line_number": 231, "body": "def test_meta_with_args() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        :meta ene due rabe: asd\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert len(docstring.meta) == 1\n    assert docstring.meta[0].args == [\"meta\", \"ene\", \"due\", \"rabe\"]\n    assert docstring.meta[0].description == \"asd\"", "is_method": false, "function_description": "This function serves as a unit test for a docstring parsing utility. It verifies the correct extraction of the short description and meta fields, including their arguments and descriptions."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_yields", "line_number": 325, "body": "def test_yields() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n        \"\"\"\n    )\n    assert docstring.returns is None\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        :yields: description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name is None\n    assert docstring.returns.description == \"description\"\n    assert docstring.returns.is_generator\n\n    docstring = parse(\n        \"\"\"\n        Short description\n        :yields int: description\n        \"\"\"\n    )\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"int\"\n    assert docstring.returns.description == \"description\"\n    assert docstring.returns.is_generator", "is_method": false, "function_description": "This function serves as a test case to validate the parsing of `:yields:` tags within docstrings. It ensures that the docstring parsing logic correctly identifies generator functions and extracts their yielded types and descriptions."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_rest.py", "function": "test_broken_meta", "line_number": 385, "body": "def test_broken_meta() -> None:\n    with pytest.raises(ParseError):\n        parse(\":\")\n\n    with pytest.raises(ParseError):\n        parse(\":param herp derp\")\n\n    with pytest.raises(ParseError):\n        parse(\":param: invalid\")\n\n    with pytest.raises(ParseError):\n        parse(\":param with too many args: desc\")\n\n    # these should not raise any errors\n    parse(\":sthstrange: desc\")", "is_method": false, "function_description": "This function tests the `parse` function's error handling for malformed input strings. It verifies that `ParseError` is correctly raised for various invalid meta-data syntaxes."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_parser.py", "function": "test_rest", "line_number": 4, "body": "def test_rest() -> None:\n    docstring = parse(\n        \"\"\"\n        Short description\n\n        Long description\n\n        Causing people to indent:\n\n            A lot sometimes\n\n        :param spam: spam desc\n        :param int bla: bla desc\n        :param str yay:\n        :raises ValueError: exc desc\n        :returns tuple: ret desc\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert docstring.long_description == (\n        \"Long description\\n\\n\"\n        \"Causing people to indent:\\n\\n\"\n        \"    A lot sometimes\"\n    )\n    assert len(docstring.params) == 3\n    assert docstring.params[0].arg_name == \"spam\"\n    assert docstring.params[0].type_name is None\n    assert docstring.params[0].description == \"spam desc\"\n    assert docstring.params[1].arg_name == \"bla\"\n    assert docstring.params[1].type_name == \"int\"\n    assert docstring.params[1].description == \"bla desc\"\n    assert docstring.params[2].arg_name == \"yay\"\n    assert docstring.params[2].type_name == \"str\"\n    assert docstring.params[2].description == \"\"\n    assert len(docstring.raises) == 1\n    assert docstring.raises[0].type_name == \"ValueError\"\n    assert docstring.raises[0].description == \"exc desc\"\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"tuple\"\n    assert docstring.returns.description == \"ret desc\"", "is_method": false, "function_description": "This test function verifies the correct parsing of reStructuredText-style docstrings. It asserts that short and long descriptions, parameters, raised exceptions, and return values are accurately extracted."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_parser.py", "function": "test_google", "line_number": 46, "body": "def test_google() -> None:\n    docstring = parse(\n        \"\"\"Short description\n\n        Long description\n\n        Causing people to indent:\n\n            A lot sometimes\n\n        Args:\n            spam: spam desc\n            bla (int): bla desc\n            yay (str):\n\n        Raises:\n            ValueError: exc desc\n\n        Returns:\n            tuple: ret desc\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert docstring.long_description == (\n        \"Long description\\n\\n\"\n        \"Causing people to indent:\\n\\n\"\n        \"    A lot sometimes\"\n    )\n    assert len(docstring.params) == 3\n    assert docstring.params[0].arg_name == \"spam\"\n    assert docstring.params[0].type_name is None\n    assert docstring.params[0].description == \"spam desc\"\n    assert docstring.params[1].arg_name == \"bla\"\n    assert docstring.params[1].type_name == \"int\"\n    assert docstring.params[1].description == \"bla desc\"\n    assert docstring.params[2].arg_name == \"yay\"\n    assert docstring.params[2].type_name == \"str\"\n    assert docstring.params[2].description == \"\"\n    assert len(docstring.raises) == 1\n    assert docstring.raises[0].type_name == \"ValueError\"\n    assert docstring.raises[0].description == \"exc desc\"\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"tuple\"\n    assert docstring.returns.description == \"ret desc\"", "is_method": false, "function_description": "This function serves as a test case, verifying that the `parse` utility correctly extracts structured information from a complex Google-style docstring, including descriptions, parameters, exceptions, and return types."}, {"file": "./dataset/RepoExec/test-apps/docstring_parser/docstring_parser/tests/test_parser.py", "function": "test_numpydoc", "line_number": 92, "body": "def test_numpydoc() -> None:\n    docstring = parse(\n        \"\"\"Short description\n\n        Long description\n\n        Causing people to indent:\n\n            A lot sometimes\n\n        Parameters\n        ----------\n        spam\n            spam desc\n        bla : int\n            bla desc\n        yay : str\n\n        Raises\n        ------\n        ValueError\n            exc desc\n\n        Other Parameters\n        ----------------\n        this_guy : int, optional\n            you know him\n\n        Returns\n        -------\n        tuple\n            ret desc\n\n        See Also\n        --------\n        multiple lines...\n        something else?\n\n        Warnings\n        --------\n        multiple lines...\n        none of this is real!\n        \"\"\"\n    )\n    assert docstring.short_description == \"Short description\"\n    assert docstring.long_description == (\n        \"Long description\\n\\n\"\n        \"Causing people to indent:\\n\\n\"\n        \"    A lot sometimes\"\n    )\n    assert len(docstring.params) == 4\n    assert docstring.params[0].arg_name == \"spam\"\n    assert docstring.params[0].type_name is None\n    assert docstring.params[0].description == \"spam desc\"\n    assert docstring.params[1].arg_name == \"bla\"\n    assert docstring.params[1].type_name == \"int\"\n    assert docstring.params[1].description == \"bla desc\"\n    assert docstring.params[2].arg_name == \"yay\"\n    assert docstring.params[2].type_name == \"str\"\n    assert docstring.params[2].description is None\n    assert docstring.params[3].arg_name == \"this_guy\"\n    assert docstring.params[3].type_name == \"int\"\n    assert docstring.params[3].is_optional\n    assert docstring.params[3].description == \"you know him\"\n\n    assert len(docstring.raises) == 1\n    assert docstring.raises[0].type_name == \"ValueError\"\n    assert docstring.raises[0].description == \"exc desc\"\n    assert docstring.returns is not None\n    assert docstring.returns.type_name == \"tuple\"\n    assert docstring.returns.description == \"ret desc\"", "is_method": false, "function_description": "This function is a unit test that verifies the correct parsing of NumPy-style docstrings. It asserts that the `parse` utility accurately extracts short/long descriptions, parameters, raises, and return information."}]