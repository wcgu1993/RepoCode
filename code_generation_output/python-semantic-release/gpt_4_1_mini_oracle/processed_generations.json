{"task_id": 153, "project": "test-apps/python-semantic-release", "module": "semantic_release.ci_checks", "predictions": ["from typing import Callable\nfrom semantic_release.errors import CiVerificationError\n\ndef checker(func: Callable) -> Callable:\n    \"\"\"\n    A decorator that will convert AssertionErrors into\n    CiVerificationError.\n\n    :param func: A function that will raise AssertionError\n    :return: The given function wrapped to raise a CiVerificationError on AssertionError\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except AssertionError as e:\n            raise CiVerificationError(str(e)) from e\n    return wrapper", "from typing import Callable\nfrom semantic_release.errors import CiVerificationError\n\ndef checker(func: Callable) -> Callable:\n    \"\"\"\n    A decorator that will convert AssertionErrors into\n    CiVerificationError.\n\n    :param func: A function that will raise AssertionError\n    :return: The given function wrapped to raise a CiVerificationError on AssertionError\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except AssertionError as e:\n            raise CiVerificationError(str(e)) from e\n\n    return wrapper", "from typing import Callable\nfrom semantic_release.errors import CiVerificationError\n\ndef checker(func: Callable) -> Callable:\n    \"\"\"\n    A decorator that will convert AssertionErrors into\n    CiVerificationError.\n\n    :param func: A function that will raise AssertionError\n    :return: The given function wrapped to raise a CiVerificationError on AssertionError\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except AssertionError as e:\n            raise CiVerificationError(str(e)) from e\n    return wrapper", "from typing import Callable\nfrom semantic_release.errors import CiVerificationError\n\ndef checker(func: Callable) -> Callable:\n    \"\"\"\n    A decorator that will convert AssertionErrors into\n    CiVerificationError.\n\n    :param func: A function that will raise AssertionError\n    :return: The given function wrapped to raise a CiVerificationError on AssertionError\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except AssertionError as e:\n            raise CiVerificationError(str(e)) from e\n    return wrapper", "from typing import Callable\nfrom semantic_release.errors import CiVerificationError\n\ndef checker(func: Callable) -> Callable:\n    \"\"\"\n    A decorator that will convert AssertionErrors into\n    CiVerificationError.\n\n    :param func: A function that will raise AssertionError\n    :return: The given function wrapped to raise a CiVerificationError on AssertionError\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except AssertionError as e:\n            raise CiVerificationError(str(e)) from e\n    return wrapper"], "test": ["\nimport sys\nsys.path.insert(1, \"/input/test-apps/python-semantic-release\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport os\nfrom typing import Callable\n\nfrom semantic_release.errors import CiVerificationError\n\n\nfrom typing import Callable\nfrom semantic_release.errors import CiVerificationError\n\ndef checker(func: Callable) -> Callable:\n    \"\"\"\n    A decorator that will convert AssertionErrors into\n    CiVerificationError.\n\n    :param func: A function that will raise AssertionError\n    :return: The given function wrapped to raise a CiVerificationError on AssertionError\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except AssertionError as e:\n            raise CiVerificationError(str(e)) from e\n    return wrapper\n\n\n@checker\ndef travis(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the travis build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"TRAVIS_BRANCH\") == branch\n    assert os.environ.get(\"TRAVIS_PULL_REQUEST\") == \"false\"\n\n\n@checker\ndef semaphore(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the semaphore build is successful,\n    on the correct branch and not a pull-request.\n\n    :param branch:  The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BRANCH_NAME\") == branch\n    assert os.environ.get(\"PULL_REQUEST_NUMBER\") is None\n    assert os.environ.get(\"SEMAPHORE_THREAD_RESULT\") != \"failed\"\n\n\n@checker\ndef frigg(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the frigg build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"FRIGG_BUILD_BRANCH\") == branch\n    assert not os.environ.get(\"FRIGG_PULL_REQUEST\")\n\n\n@checker\ndef circle(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the circle build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CIRCLE_BRANCH\") == branch\n    assert not os.environ.get(\"CI_PULL_REQUEST\")\n\n\n@checker\ndef gitlab(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the gitlab build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CI_COMMIT_REF_NAME\") == branch\n    # TODO - don't think there's a merge request indicator variable\n\n\n@checker\ndef bitbucket(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the bitbucket build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BITBUCKET_BRANCH\") == branch\n    assert not os.environ.get(\"BITBUCKET_PR_ID\")\n\n\n@checker\ndef jenkins(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the jenkins build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n\n    branch_name = os.environ.get(\"BRANCH_NAME\") or os.environ.get(\"GIT_BRANCH\")\n    assert os.environ.get(\"JENKINS_URL\") is not None\n    assert branch_name == branch\n    assert not os.environ.get(\"CHANGE_ID\")  # pull request id\n\n\ndef check(branch: str = \"master\"):\n    \"\"\"\n    Detects the current CI environment, if any, and performs necessary\n    environment checks.\n\n    :param branch: The branch that should be the current branch.\n    \"\"\"\n    if os.environ.get(\"TRAVIS\") == \"true\":\n        travis(branch)\n    elif os.environ.get(\"SEMAPHORE\") == \"true\":\n        semaphore(branch)\n    elif os.environ.get(\"FRIGG\") == \"true\":\n        frigg(branch)\n    elif os.environ.get(\"CIRCLECI\") == \"true\":\n        circle(branch)\n    elif os.environ.get(\"GITLAB_CI\") == \"true\":\n        gitlab(branch)\n    elif os.environ.get(\"JENKINS_URL\") is not None:\n        jenkins(branch)\n    elif \"BITBUCKET_BUILD_NUMBER\" in os.environ:\n        bitbucket(branch)\n\n\nimport pickle\ndef test_0():\n    assert checker(lambda: False)() is True\ntest_0()\n\ndef test_5():\n    assert 1 == checker(lambda x: 1)(1)\ntest_5()\n\ndef test_9():\n    assert checker(lambda: True)() is True\ntest_9()\n\ndef test_3():\n    with open(\"/output/test-apps+python-semantic-release/test_output/semantic_release+ci_checks/checker/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert checker(lambda x: 1)(0) == output\ntest_3()\n\n\ndef test_extra_0():\n    try:\n        checker(lambda: 1/0)()\n    except ZeroDivisionError as e:\n        assert str(e) == \"division by zero\"\n    else:\n        assert False, \"A ZeroDivisionError should have been raised\"\ntest_extra_0()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/python-semantic-release\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport os\nfrom typing import Callable\n\nfrom semantic_release.errors import CiVerificationError\n\n\nfrom typing import Callable\nfrom semantic_release.errors import CiVerificationError\n\ndef checker(func: Callable) -> Callable:\n    \"\"\"\n    A decorator that will convert AssertionErrors into\n    CiVerificationError.\n\n    :param func: A function that will raise AssertionError\n    :return: The given function wrapped to raise a CiVerificationError on AssertionError\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except AssertionError as e:\n            raise CiVerificationError(str(e)) from e\n\n    return wrapper\n\n\n@checker\ndef travis(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the travis build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"TRAVIS_BRANCH\") == branch\n    assert os.environ.get(\"TRAVIS_PULL_REQUEST\") == \"false\"\n\n\n@checker\ndef semaphore(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the semaphore build is successful,\n    on the correct branch and not a pull-request.\n\n    :param branch:  The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BRANCH_NAME\") == branch\n    assert os.environ.get(\"PULL_REQUEST_NUMBER\") is None\n    assert os.environ.get(\"SEMAPHORE_THREAD_RESULT\") != \"failed\"\n\n\n@checker\ndef frigg(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the frigg build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"FRIGG_BUILD_BRANCH\") == branch\n    assert not os.environ.get(\"FRIGG_PULL_REQUEST\")\n\n\n@checker\ndef circle(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the circle build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CIRCLE_BRANCH\") == branch\n    assert not os.environ.get(\"CI_PULL_REQUEST\")\n\n\n@checker\ndef gitlab(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the gitlab build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CI_COMMIT_REF_NAME\") == branch\n    # TODO - don't think there's a merge request indicator variable\n\n\n@checker\ndef bitbucket(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the bitbucket build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BITBUCKET_BRANCH\") == branch\n    assert not os.environ.get(\"BITBUCKET_PR_ID\")\n\n\n@checker\ndef jenkins(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the jenkins build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n\n    branch_name = os.environ.get(\"BRANCH_NAME\") or os.environ.get(\"GIT_BRANCH\")\n    assert os.environ.get(\"JENKINS_URL\") is not None\n    assert branch_name == branch\n    assert not os.environ.get(\"CHANGE_ID\")  # pull request id\n\n\ndef check(branch: str = \"master\"):\n    \"\"\"\n    Detects the current CI environment, if any, and performs necessary\n    environment checks.\n\n    :param branch: The branch that should be the current branch.\n    \"\"\"\n    if os.environ.get(\"TRAVIS\") == \"true\":\n        travis(branch)\n    elif os.environ.get(\"SEMAPHORE\") == \"true\":\n        semaphore(branch)\n    elif os.environ.get(\"FRIGG\") == \"true\":\n        frigg(branch)\n    elif os.environ.get(\"CIRCLECI\") == \"true\":\n        circle(branch)\n    elif os.environ.get(\"GITLAB_CI\") == \"true\":\n        gitlab(branch)\n    elif os.environ.get(\"JENKINS_URL\") is not None:\n        jenkins(branch)\n    elif \"BITBUCKET_BUILD_NUMBER\" in os.environ:\n        bitbucket(branch)\n\n\nimport pickle\ndef test_0():\n    assert checker(lambda: False)() is True\ntest_0()\n\ndef test_5():\n    assert 1 == checker(lambda x: 1)(1)\ntest_5()\n\ndef test_9():\n    assert checker(lambda: True)() is True\ntest_9()\n\ndef test_3():\n    with open(\"/output/test-apps+python-semantic-release/test_output/semantic_release+ci_checks/checker/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert checker(lambda x: 1)(0) == output\ntest_3()\n\n\ndef test_extra_0():\n    try:\n        checker(lambda: 1/0)()\n    except ZeroDivisionError as e:\n        assert str(e) == \"division by zero\"\n    else:\n        assert False, \"A ZeroDivisionError should have been raised\"\ntest_extra_0()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/python-semantic-release\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport os\nfrom typing import Callable\n\nfrom semantic_release.errors import CiVerificationError\n\n\nfrom typing import Callable\nfrom semantic_release.errors import CiVerificationError\n\ndef checker(func: Callable) -> Callable:\n    \"\"\"\n    A decorator that will convert AssertionErrors into\n    CiVerificationError.\n\n    :param func: A function that will raise AssertionError\n    :return: The given function wrapped to raise a CiVerificationError on AssertionError\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except AssertionError as e:\n            raise CiVerificationError(str(e)) from e\n    return wrapper\n\n\n@checker\ndef travis(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the travis build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"TRAVIS_BRANCH\") == branch\n    assert os.environ.get(\"TRAVIS_PULL_REQUEST\") == \"false\"\n\n\n@checker\ndef semaphore(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the semaphore build is successful,\n    on the correct branch and not a pull-request.\n\n    :param branch:  The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BRANCH_NAME\") == branch\n    assert os.environ.get(\"PULL_REQUEST_NUMBER\") is None\n    assert os.environ.get(\"SEMAPHORE_THREAD_RESULT\") != \"failed\"\n\n\n@checker\ndef frigg(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the frigg build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"FRIGG_BUILD_BRANCH\") == branch\n    assert not os.environ.get(\"FRIGG_PULL_REQUEST\")\n\n\n@checker\ndef circle(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the circle build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CIRCLE_BRANCH\") == branch\n    assert not os.environ.get(\"CI_PULL_REQUEST\")\n\n\n@checker\ndef gitlab(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the gitlab build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CI_COMMIT_REF_NAME\") == branch\n    # TODO - don't think there's a merge request indicator variable\n\n\n@checker\ndef bitbucket(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the bitbucket build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BITBUCKET_BRANCH\") == branch\n    assert not os.environ.get(\"BITBUCKET_PR_ID\")\n\n\n@checker\ndef jenkins(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the jenkins build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n\n    branch_name = os.environ.get(\"BRANCH_NAME\") or os.environ.get(\"GIT_BRANCH\")\n    assert os.environ.get(\"JENKINS_URL\") is not None\n    assert branch_name == branch\n    assert not os.environ.get(\"CHANGE_ID\")  # pull request id\n\n\ndef check(branch: str = \"master\"):\n    \"\"\"\n    Detects the current CI environment, if any, and performs necessary\n    environment checks.\n\n    :param branch: The branch that should be the current branch.\n    \"\"\"\n    if os.environ.get(\"TRAVIS\") == \"true\":\n        travis(branch)\n    elif os.environ.get(\"SEMAPHORE\") == \"true\":\n        semaphore(branch)\n    elif os.environ.get(\"FRIGG\") == \"true\":\n        frigg(branch)\n    elif os.environ.get(\"CIRCLECI\") == \"true\":\n        circle(branch)\n    elif os.environ.get(\"GITLAB_CI\") == \"true\":\n        gitlab(branch)\n    elif os.environ.get(\"JENKINS_URL\") is not None:\n        jenkins(branch)\n    elif \"BITBUCKET_BUILD_NUMBER\" in os.environ:\n        bitbucket(branch)\n\n\nimport pickle\ndef test_0():\n    assert checker(lambda: False)() is True\ntest_0()\n\ndef test_5():\n    assert 1 == checker(lambda x: 1)(1)\ntest_5()\n\ndef test_9():\n    assert checker(lambda: True)() is True\ntest_9()\n\ndef test_3():\n    with open(\"/output/test-apps+python-semantic-release/test_output/semantic_release+ci_checks/checker/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert checker(lambda x: 1)(0) == output\ntest_3()\n\n\ndef test_extra_0():\n    try:\n        checker(lambda: 1/0)()\n    except ZeroDivisionError as e:\n        assert str(e) == \"division by zero\"\n    else:\n        assert False, \"A ZeroDivisionError should have been raised\"\ntest_extra_0()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/python-semantic-release\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport os\nfrom typing import Callable\n\nfrom semantic_release.errors import CiVerificationError\n\n\nfrom typing import Callable\nfrom semantic_release.errors import CiVerificationError\n\ndef checker(func: Callable) -> Callable:\n    \"\"\"\n    A decorator that will convert AssertionErrors into\n    CiVerificationError.\n\n    :param func: A function that will raise AssertionError\n    :return: The given function wrapped to raise a CiVerificationError on AssertionError\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except AssertionError as e:\n            raise CiVerificationError(str(e)) from e\n    return wrapper\n\n\n@checker\ndef travis(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the travis build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"TRAVIS_BRANCH\") == branch\n    assert os.environ.get(\"TRAVIS_PULL_REQUEST\") == \"false\"\n\n\n@checker\ndef semaphore(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the semaphore build is successful,\n    on the correct branch and not a pull-request.\n\n    :param branch:  The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BRANCH_NAME\") == branch\n    assert os.environ.get(\"PULL_REQUEST_NUMBER\") is None\n    assert os.environ.get(\"SEMAPHORE_THREAD_RESULT\") != \"failed\"\n\n\n@checker\ndef frigg(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the frigg build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"FRIGG_BUILD_BRANCH\") == branch\n    assert not os.environ.get(\"FRIGG_PULL_REQUEST\")\n\n\n@checker\ndef circle(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the circle build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CIRCLE_BRANCH\") == branch\n    assert not os.environ.get(\"CI_PULL_REQUEST\")\n\n\n@checker\ndef gitlab(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the gitlab build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CI_COMMIT_REF_NAME\") == branch\n    # TODO - don't think there's a merge request indicator variable\n\n\n@checker\ndef bitbucket(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the bitbucket build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BITBUCKET_BRANCH\") == branch\n    assert not os.environ.get(\"BITBUCKET_PR_ID\")\n\n\n@checker\ndef jenkins(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the jenkins build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n\n    branch_name = os.environ.get(\"BRANCH_NAME\") or os.environ.get(\"GIT_BRANCH\")\n    assert os.environ.get(\"JENKINS_URL\") is not None\n    assert branch_name == branch\n    assert not os.environ.get(\"CHANGE_ID\")  # pull request id\n\n\ndef check(branch: str = \"master\"):\n    \"\"\"\n    Detects the current CI environment, if any, and performs necessary\n    environment checks.\n\n    :param branch: The branch that should be the current branch.\n    \"\"\"\n    if os.environ.get(\"TRAVIS\") == \"true\":\n        travis(branch)\n    elif os.environ.get(\"SEMAPHORE\") == \"true\":\n        semaphore(branch)\n    elif os.environ.get(\"FRIGG\") == \"true\":\n        frigg(branch)\n    elif os.environ.get(\"CIRCLECI\") == \"true\":\n        circle(branch)\n    elif os.environ.get(\"GITLAB_CI\") == \"true\":\n        gitlab(branch)\n    elif os.environ.get(\"JENKINS_URL\") is not None:\n        jenkins(branch)\n    elif \"BITBUCKET_BUILD_NUMBER\" in os.environ:\n        bitbucket(branch)\n\n\nimport pickle\ndef test_0():\n    assert checker(lambda: False)() is True\ntest_0()\n\ndef test_5():\n    assert 1 == checker(lambda x: 1)(1)\ntest_5()\n\ndef test_9():\n    assert checker(lambda: True)() is True\ntest_9()\n\ndef test_3():\n    with open(\"/output/test-apps+python-semantic-release/test_output/semantic_release+ci_checks/checker/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert checker(lambda x: 1)(0) == output\ntest_3()\n\n\ndef test_extra_0():\n    try:\n        checker(lambda: 1/0)()\n    except ZeroDivisionError as e:\n        assert str(e) == \"division by zero\"\n    else:\n        assert False, \"A ZeroDivisionError should have been raised\"\ntest_extra_0()", "\nimport sys\nsys.path.insert(1, \"/input/test-apps/python-semantic-release\")\nimport unittest, pytest\nimport math\nimport random\nimport re\nimport copy\nimport datetime\nimport itertools\nimport collections\nimport heapq\nimport statistics\nimport functools\nimport hashlib\nimport numpy\nimport numpy as np\nimport string\nfrom typing import *\nfrom collections import *\nimport pickle\nimport timeout_decorator\n\n\nimport os\nfrom typing import Callable\n\nfrom semantic_release.errors import CiVerificationError\n\n\nfrom typing import Callable\nfrom semantic_release.errors import CiVerificationError\n\ndef checker(func: Callable) -> Callable:\n    \"\"\"\n    A decorator that will convert AssertionErrors into\n    CiVerificationError.\n\n    :param func: A function that will raise AssertionError\n    :return: The given function wrapped to raise a CiVerificationError on AssertionError\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except AssertionError as e:\n            raise CiVerificationError(str(e)) from e\n    return wrapper\n\n\n@checker\ndef travis(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the travis build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"TRAVIS_BRANCH\") == branch\n    assert os.environ.get(\"TRAVIS_PULL_REQUEST\") == \"false\"\n\n\n@checker\ndef semaphore(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the semaphore build is successful,\n    on the correct branch and not a pull-request.\n\n    :param branch:  The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BRANCH_NAME\") == branch\n    assert os.environ.get(\"PULL_REQUEST_NUMBER\") is None\n    assert os.environ.get(\"SEMAPHORE_THREAD_RESULT\") != \"failed\"\n\n\n@checker\ndef frigg(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the frigg build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"FRIGG_BUILD_BRANCH\") == branch\n    assert not os.environ.get(\"FRIGG_PULL_REQUEST\")\n\n\n@checker\ndef circle(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the circle build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CIRCLE_BRANCH\") == branch\n    assert not os.environ.get(\"CI_PULL_REQUEST\")\n\n\n@checker\ndef gitlab(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the gitlab build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"CI_COMMIT_REF_NAME\") == branch\n    # TODO - don't think there's a merge request indicator variable\n\n\n@checker\ndef bitbucket(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the bitbucket build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n    assert os.environ.get(\"BITBUCKET_BRANCH\") == branch\n    assert not os.environ.get(\"BITBUCKET_PR_ID\")\n\n\n@checker\ndef jenkins(branch: str):\n    \"\"\"\n    Performs necessary checks to ensure that the jenkins build is one\n    that should create releases.\n\n    :param branch: The branch the environment should be running against.\n    \"\"\"\n\n    branch_name = os.environ.get(\"BRANCH_NAME\") or os.environ.get(\"GIT_BRANCH\")\n    assert os.environ.get(\"JENKINS_URL\") is not None\n    assert branch_name == branch\n    assert not os.environ.get(\"CHANGE_ID\")  # pull request id\n\n\ndef check(branch: str = \"master\"):\n    \"\"\"\n    Detects the current CI environment, if any, and performs necessary\n    environment checks.\n\n    :param branch: The branch that should be the current branch.\n    \"\"\"\n    if os.environ.get(\"TRAVIS\") == \"true\":\n        travis(branch)\n    elif os.environ.get(\"SEMAPHORE\") == \"true\":\n        semaphore(branch)\n    elif os.environ.get(\"FRIGG\") == \"true\":\n        frigg(branch)\n    elif os.environ.get(\"CIRCLECI\") == \"true\":\n        circle(branch)\n    elif os.environ.get(\"GITLAB_CI\") == \"true\":\n        gitlab(branch)\n    elif os.environ.get(\"JENKINS_URL\") is not None:\n        jenkins(branch)\n    elif \"BITBUCKET_BUILD_NUMBER\" in os.environ:\n        bitbucket(branch)\n\n\nimport pickle\ndef test_0():\n    assert checker(lambda: False)() is True\ntest_0()\n\ndef test_5():\n    assert 1 == checker(lambda x: 1)(1)\ntest_5()\n\ndef test_9():\n    assert checker(lambda: True)() is True\ntest_9()\n\ndef test_3():\n    with open(\"/output/test-apps+python-semantic-release/test_output/semantic_release+ci_checks/checker/test_3\", \"rb\") as f:\n        output = pickle.load(f)\n    assert checker(lambda x: 1)(0) == output\ntest_3()\n\n\ndef test_extra_0():\n    try:\n        checker(lambda: 1/0)()\n    except ZeroDivisionError as e:\n        assert str(e) == \"division by zero\"\n    else:\n        assert False, \"A ZeroDivisionError should have been raised\"\ntest_extra_0()"]}
